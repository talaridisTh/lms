/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 10);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/codemirror/addon/display/autorefresh.js":
/*!**************************************************************!*\
  !*** ./node_modules/codemirror/addon/display/autorefresh.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (true) // CommonJS\n    mod(__webpack_require__(/*! ../../lib/codemirror */ \"./node_modules/codemirror/lib/codemirror.js\"))\n  else {}\n})(function(CodeMirror) {\n  \"use strict\"\n\n  CodeMirror.defineOption(\"autoRefresh\", false, function(cm, val) {\n    if (cm.state.autoRefresh) {\n      stopListening(cm, cm.state.autoRefresh)\n      cm.state.autoRefresh = null\n    }\n    if (val && cm.display.wrapper.offsetHeight == 0)\n      startListening(cm, cm.state.autoRefresh = {delay: val.delay || 250})\n  })\n\n  function startListening(cm, state) {\n    function check() {\n      if (cm.display.wrapper.offsetHeight) {\n        stopListening(cm, state)\n        if (cm.display.lastWrapHeight != cm.display.wrapper.clientHeight)\n          cm.refresh()\n      } else {\n        state.timeout = setTimeout(check, state.delay)\n      }\n    }\n    state.timeout = setTimeout(check, state.delay)\n    state.hurry = function() {\n      clearTimeout(state.timeout)\n      state.timeout = setTimeout(check, 50)\n    }\n    CodeMirror.on(window, \"mouseup\", state.hurry)\n    CodeMirror.on(window, \"keyup\", state.hurry)\n  }\n\n  function stopListening(_cm, state) {\n    clearTimeout(state.timeout)\n    CodeMirror.off(window, \"mouseup\", state.hurry)\n    CodeMirror.off(window, \"keyup\", state.hurry)\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29kZW1pcnJvci9hZGRvbi9kaXNwbGF5L2F1dG9yZWZyZXNoLmpzP2Y0YmEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBLE1BQU0sSUFBdUQ7QUFDN0QsUUFBUSxtQkFBTyxDQUFDLHlFQUFzQjtBQUN0QyxPQUFPLEVBR1k7QUFDbkIsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCx3QkFBd0I7QUFDekUsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9jb2RlbWlycm9yL2FkZG9uL2Rpc3BsYXkvYXV0b3JlZnJlc2guanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb2RlTWlycm9yLCBjb3B5cmlnaHQgKGMpIGJ5IE1hcmlqbiBIYXZlcmJla2UgYW5kIG90aGVyc1xuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgYW4gTUlUIGxpY2Vuc2U6IGh0dHBzOi8vY29kZW1pcnJvci5uZXQvTElDRU5TRVxuXG4oZnVuY3Rpb24obW9kKSB7XG4gIGlmICh0eXBlb2YgZXhwb3J0cyA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUgPT0gXCJvYmplY3RcIikgLy8gQ29tbW9uSlNcbiAgICBtb2QocmVxdWlyZShcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCIpKVxuICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSAvLyBBTURcbiAgICBkZWZpbmUoW1wiLi4vLi4vbGliL2NvZGVtaXJyb3JcIl0sIG1vZClcbiAgZWxzZSAvLyBQbGFpbiBicm93c2VyIGVudlxuICAgIG1vZChDb2RlTWlycm9yKVxufSkoZnVuY3Rpb24oQ29kZU1pcnJvcikge1xuICBcInVzZSBzdHJpY3RcIlxuXG4gIENvZGVNaXJyb3IuZGVmaW5lT3B0aW9uKFwiYXV0b1JlZnJlc2hcIiwgZmFsc2UsIGZ1bmN0aW9uKGNtLCB2YWwpIHtcbiAgICBpZiAoY20uc3RhdGUuYXV0b1JlZnJlc2gpIHtcbiAgICAgIHN0b3BMaXN0ZW5pbmcoY20sIGNtLnN0YXRlLmF1dG9SZWZyZXNoKVxuICAgICAgY20uc3RhdGUuYXV0b1JlZnJlc2ggPSBudWxsXG4gICAgfVxuICAgIGlmICh2YWwgJiYgY20uZGlzcGxheS53cmFwcGVyLm9mZnNldEhlaWdodCA9PSAwKVxuICAgICAgc3RhcnRMaXN0ZW5pbmcoY20sIGNtLnN0YXRlLmF1dG9SZWZyZXNoID0ge2RlbGF5OiB2YWwuZGVsYXkgfHwgMjUwfSlcbiAgfSlcblxuICBmdW5jdGlvbiBzdGFydExpc3RlbmluZyhjbSwgc3RhdGUpIHtcbiAgICBmdW5jdGlvbiBjaGVjaygpIHtcbiAgICAgIGlmIChjbS5kaXNwbGF5LndyYXBwZXIub2Zmc2V0SGVpZ2h0KSB7XG4gICAgICAgIHN0b3BMaXN0ZW5pbmcoY20sIHN0YXRlKVxuICAgICAgICBpZiAoY20uZGlzcGxheS5sYXN0V3JhcEhlaWdodCAhPSBjbS5kaXNwbGF5LndyYXBwZXIuY2xpZW50SGVpZ2h0KVxuICAgICAgICAgIGNtLnJlZnJlc2goKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUudGltZW91dCA9IHNldFRpbWVvdXQoY2hlY2ssIHN0YXRlLmRlbGF5KVxuICAgICAgfVxuICAgIH1cbiAgICBzdGF0ZS50aW1lb3V0ID0gc2V0VGltZW91dChjaGVjaywgc3RhdGUuZGVsYXkpXG4gICAgc3RhdGUuaHVycnkgPSBmdW5jdGlvbigpIHtcbiAgICAgIGNsZWFyVGltZW91dChzdGF0ZS50aW1lb3V0KVxuICAgICAgc3RhdGUudGltZW91dCA9IHNldFRpbWVvdXQoY2hlY2ssIDUwKVxuICAgIH1cbiAgICBDb2RlTWlycm9yLm9uKHdpbmRvdywgXCJtb3VzZXVwXCIsIHN0YXRlLmh1cnJ5KVxuICAgIENvZGVNaXJyb3Iub24od2luZG93LCBcImtleXVwXCIsIHN0YXRlLmh1cnJ5KVxuICB9XG5cbiAgZnVuY3Rpb24gc3RvcExpc3RlbmluZyhfY20sIHN0YXRlKSB7XG4gICAgY2xlYXJUaW1lb3V0KHN0YXRlLnRpbWVvdXQpXG4gICAgQ29kZU1pcnJvci5vZmYod2luZG93LCBcIm1vdXNldXBcIiwgc3RhdGUuaHVycnkpXG4gICAgQ29kZU1pcnJvci5vZmYod2luZG93LCBcImtleXVwXCIsIHN0YXRlLmh1cnJ5KVxuICB9XG59KTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/codemirror/addon/display/autorefresh.js\n");

/***/ }),

/***/ "./node_modules/codemirror/lib/codemirror.css":
/*!****************************************************!*\
  !*** ./node_modules/codemirror/lib/codemirror.css ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\nvar content = __webpack_require__(/*! !../../css-loader??ref--10-1!../../postcss-loader/src??ref--10-2!./codemirror.css */ \"./node_modules/css-loader/index.js?!./node_modules/postcss-loader/src/index.js?!./node_modules/codemirror/lib/codemirror.css\");\n\nif(typeof content === 'string') content = [[module.i, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = __webpack_require__(/*! ../../style-loader/lib/addStyles.js */ \"./node_modules/style-loader/lib/addStyles.js\")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(false) {}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29kZW1pcnJvci9saWIvY29kZW1pcnJvci5jc3M/MzI2NyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLHVOQUFzRzs7QUFFNUgsNENBQTRDLFFBQVM7O0FBRXJEO0FBQ0E7Ozs7QUFJQSxlQUFlOztBQUVmO0FBQ0E7O0FBRUEsYUFBYSxtQkFBTyxDQUFDLHlGQUFzQzs7QUFFM0Q7O0FBRUEsR0FBRyxLQUFVLEVBQUUiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY29kZW1pcnJvci9saWIvY29kZW1pcnJvci5jc3MuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vY3NzLWxvYWRlci9pbmRleC5qcz8/cmVmLS0xMC0xIS4uLy4uL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cmVmLS0xMC0yIS4vY29kZW1pcnJvci5jc3NcIik7XG5cbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuXG52YXIgdHJhbnNmb3JtO1xudmFyIGluc2VydEludG87XG5cblxuXG52YXIgb3B0aW9ucyA9IHtcImhtclwiOnRydWV9XG5cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG5vcHRpb25zLmluc2VydEludG8gPSB1bmRlZmluZWQ7XG5cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2FscztcblxuaWYobW9kdWxlLmhvdCkge1xuXHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vY3NzLWxvYWRlci9pbmRleC5qcz8/cmVmLS0xMC0xIS4uLy4uL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cmVmLS0xMC0yIS4vY29kZW1pcnJvci5jc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9jc3MtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTEwLTEhLi4vLi4vcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9yZWYtLTEwLTIhLi9jb2RlbWlycm9yLmNzc1wiKTtcblxuXHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXG5cdFx0dmFyIGxvY2FscyA9IChmdW5jdGlvbihhLCBiKSB7XG5cdFx0XHR2YXIga2V5LCBpZHggPSAwO1xuXG5cdFx0XHRmb3Ioa2V5IGluIGEpIHtcblx0XHRcdFx0aWYoIWIgfHwgYVtrZXldICE9PSBiW2tleV0pIHJldHVybiBmYWxzZTtcblx0XHRcdFx0aWR4Kys7XG5cdFx0XHR9XG5cblx0XHRcdGZvcihrZXkgaW4gYikgaWR4LS07XG5cblx0XHRcdHJldHVybiBpZHggPT09IDA7XG5cdFx0fShjb250ZW50LmxvY2FscywgbmV3Q29udGVudC5sb2NhbHMpKTtcblxuXHRcdGlmKCFsb2NhbHMpIHRocm93IG5ldyBFcnJvcignQWJvcnRpbmcgQ1NTIEhNUiBkdWUgdG8gY2hhbmdlZCBjc3MtbW9kdWxlcyBsb2NhbHMuJyk7XG5cblx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdH0pO1xuXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/codemirror/lib/codemirror.css\n");

/***/ }),

/***/ "./node_modules/codemirror/lib/codemirror.js":
/*!***************************************************!*\
  !*** ./node_modules/codemirror/lib/codemirror.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n// This is CodeMirror (https://codemirror.net), a code editor\n// implemented in JavaScript on top of the browser's DOM.\n//\n// You can find some technical background for some of the code below\n// at http://marijnhaverbeke.nl/blog/#cm-internals .\n\n(function (global, factory) {\n   true ? module.exports = factory() :\n  undefined;\n}(this, (function () { 'use strict';\n\n  // Kludges for bugs and behavior differences that can't be feature\n  // detected are enabled based on userAgent etc sniffing.\n  var userAgent = navigator.userAgent;\n  var platform = navigator.platform;\n\n  var gecko = /gecko\\/\\d/i.test(userAgent);\n  var ie_upto10 = /MSIE \\d/.test(userAgent);\n  var ie_11up = /Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(userAgent);\n  var edge = /Edge\\/(\\d+)/.exec(userAgent);\n  var ie = ie_upto10 || ie_11up || edge;\n  var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : +(edge || ie_11up)[1]);\n  var webkit = !edge && /WebKit\\//.test(userAgent);\n  var qtwebkit = webkit && /Qt\\/\\d+\\.\\d+/.test(userAgent);\n  var chrome = !edge && /Chrome\\//.test(userAgent);\n  var presto = /Opera\\//.test(userAgent);\n  var safari = /Apple Computer/.test(navigator.vendor);\n  var mac_geMountainLion = /Mac OS X 1\\d\\D([8-9]|\\d\\d)\\D/.test(userAgent);\n  var phantom = /PhantomJS/.test(userAgent);\n\n  var ios = !edge && /AppleWebKit/.test(userAgent) && (/Mobile\\/\\w+/.test(userAgent) || navigator.maxTouchPoints > 2);\n  var android = /Android/.test(userAgent);\n  // This is woefully incomplete. Suggestions for alternative methods welcome.\n  var mobile = ios || android || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);\n  var mac = ios || /Mac/.test(platform);\n  var chromeOS = /\\bCrOS\\b/.test(userAgent);\n  var windows = /win/i.test(platform);\n\n  var presto_version = presto && userAgent.match(/Version\\/(\\d*\\.\\d*)/);\n  if (presto_version) { presto_version = Number(presto_version[1]); }\n  if (presto_version && presto_version >= 15) { presto = false; webkit = true; }\n  // Some browsers use the wrong event properties to signal cmd/ctrl on OS X\n  var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));\n  var captureRightClick = gecko || (ie && ie_version >= 9);\n\n  function classTest(cls) { return new RegExp(\"(^|\\\\s)\" + cls + \"(?:$|\\\\s)\\\\s*\") }\n\n  var rmClass = function(node, cls) {\n    var current = node.className;\n    var match = classTest(cls).exec(current);\n    if (match) {\n      var after = current.slice(match.index + match[0].length);\n      node.className = current.slice(0, match.index) + (after ? match[1] + after : \"\");\n    }\n  };\n\n  function removeChildren(e) {\n    for (var count = e.childNodes.length; count > 0; --count)\n      { e.removeChild(e.firstChild); }\n    return e\n  }\n\n  function removeChildrenAndAdd(parent, e) {\n    return removeChildren(parent).appendChild(e)\n  }\n\n  function elt(tag, content, className, style) {\n    var e = document.createElement(tag);\n    if (className) { e.className = className; }\n    if (style) { e.style.cssText = style; }\n    if (typeof content == \"string\") { e.appendChild(document.createTextNode(content)); }\n    else if (content) { for (var i = 0; i < content.length; ++i) { e.appendChild(content[i]); } }\n    return e\n  }\n  // wrapper for elt, which removes the elt from the accessibility tree\n  function eltP(tag, content, className, style) {\n    var e = elt(tag, content, className, style);\n    e.setAttribute(\"role\", \"presentation\");\n    return e\n  }\n\n  var range;\n  if (document.createRange) { range = function(node, start, end, endNode) {\n    var r = document.createRange();\n    r.setEnd(endNode || node, end);\n    r.setStart(node, start);\n    return r\n  }; }\n  else { range = function(node, start, end) {\n    var r = document.body.createTextRange();\n    try { r.moveToElementText(node.parentNode); }\n    catch(e) { return r }\n    r.collapse(true);\n    r.moveEnd(\"character\", end);\n    r.moveStart(\"character\", start);\n    return r\n  }; }\n\n  function contains(parent, child) {\n    if (child.nodeType == 3) // Android browser always returns false when child is a textnode\n      { child = child.parentNode; }\n    if (parent.contains)\n      { return parent.contains(child) }\n    do {\n      if (child.nodeType == 11) { child = child.host; }\n      if (child == parent) { return true }\n    } while (child = child.parentNode)\n  }\n\n  function activeElt() {\n    // IE and Edge may throw an \"Unspecified Error\" when accessing document.activeElement.\n    // IE < 10 will throw when accessed while the page is loading or in an iframe.\n    // IE > 9 and Edge will throw when accessed in an iframe if document.body is unavailable.\n    var activeElement;\n    try {\n      activeElement = document.activeElement;\n    } catch(e) {\n      activeElement = document.body || null;\n    }\n    while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement)\n      { activeElement = activeElement.shadowRoot.activeElement; }\n    return activeElement\n  }\n\n  function addClass(node, cls) {\n    var current = node.className;\n    if (!classTest(cls).test(current)) { node.className += (current ? \" \" : \"\") + cls; }\n  }\n  function joinClasses(a, b) {\n    var as = a.split(\" \");\n    for (var i = 0; i < as.length; i++)\n      { if (as[i] && !classTest(as[i]).test(b)) { b += \" \" + as[i]; } }\n    return b\n  }\n\n  var selectInput = function(node) { node.select(); };\n  if (ios) // Mobile Safari apparently has a bug where select() is broken.\n    { selectInput = function(node) { node.selectionStart = 0; node.selectionEnd = node.value.length; }; }\n  else if (ie) // Suppress mysterious IE10 errors\n    { selectInput = function(node) { try { node.select(); } catch(_e) {} }; }\n\n  function bind(f) {\n    var args = Array.prototype.slice.call(arguments, 1);\n    return function(){return f.apply(null, args)}\n  }\n\n  function copyObj(obj, target, overwrite) {\n    if (!target) { target = {}; }\n    for (var prop in obj)\n      { if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))\n        { target[prop] = obj[prop]; } }\n    return target\n  }\n\n  // Counts the column offset in a string, taking tabs into account.\n  // Used mostly to find indentation.\n  function countColumn(string, end, tabSize, startIndex, startValue) {\n    if (end == null) {\n      end = string.search(/[^\\s\\u00a0]/);\n      if (end == -1) { end = string.length; }\n    }\n    for (var i = startIndex || 0, n = startValue || 0;;) {\n      var nextTab = string.indexOf(\"\\t\", i);\n      if (nextTab < 0 || nextTab >= end)\n        { return n + (end - i) }\n      n += nextTab - i;\n      n += tabSize - (n % tabSize);\n      i = nextTab + 1;\n    }\n  }\n\n  var Delayed = function() {\n    this.id = null;\n    this.f = null;\n    this.time = 0;\n    this.handler = bind(this.onTimeout, this);\n  };\n  Delayed.prototype.onTimeout = function (self) {\n    self.id = 0;\n    if (self.time <= +new Date) {\n      self.f();\n    } else {\n      setTimeout(self.handler, self.time - +new Date);\n    }\n  };\n  Delayed.prototype.set = function (ms, f) {\n    this.f = f;\n    var time = +new Date + ms;\n    if (!this.id || time < this.time) {\n      clearTimeout(this.id);\n      this.id = setTimeout(this.handler, ms);\n      this.time = time;\n    }\n  };\n\n  function indexOf(array, elt) {\n    for (var i = 0; i < array.length; ++i)\n      { if (array[i] == elt) { return i } }\n    return -1\n  }\n\n  // Number of pixels added to scroller and sizer to hide scrollbar\n  var scrollerGap = 50;\n\n  // Returned or thrown by various protocols to signal 'I'm not\n  // handling this'.\n  var Pass = {toString: function(){return \"CodeMirror.Pass\"}};\n\n  // Reused option objects for setSelection & friends\n  var sel_dontScroll = {scroll: false}, sel_mouse = {origin: \"*mouse\"}, sel_move = {origin: \"+move\"};\n\n  // The inverse of countColumn -- find the offset that corresponds to\n  // a particular column.\n  function findColumn(string, goal, tabSize) {\n    for (var pos = 0, col = 0;;) {\n      var nextTab = string.indexOf(\"\\t\", pos);\n      if (nextTab == -1) { nextTab = string.length; }\n      var skipped = nextTab - pos;\n      if (nextTab == string.length || col + skipped >= goal)\n        { return pos + Math.min(skipped, goal - col) }\n      col += nextTab - pos;\n      col += tabSize - (col % tabSize);\n      pos = nextTab + 1;\n      if (col >= goal) { return pos }\n    }\n  }\n\n  var spaceStrs = [\"\"];\n  function spaceStr(n) {\n    while (spaceStrs.length <= n)\n      { spaceStrs.push(lst(spaceStrs) + \" \"); }\n    return spaceStrs[n]\n  }\n\n  function lst(arr) { return arr[arr.length-1] }\n\n  function map(array, f) {\n    var out = [];\n    for (var i = 0; i < array.length; i++) { out[i] = f(array[i], i); }\n    return out\n  }\n\n  function insertSorted(array, value, score) {\n    var pos = 0, priority = score(value);\n    while (pos < array.length && score(array[pos]) <= priority) { pos++; }\n    array.splice(pos, 0, value);\n  }\n\n  function nothing() {}\n\n  function createObj(base, props) {\n    var inst;\n    if (Object.create) {\n      inst = Object.create(base);\n    } else {\n      nothing.prototype = base;\n      inst = new nothing();\n    }\n    if (props) { copyObj(props, inst); }\n    return inst\n  }\n\n  var nonASCIISingleCaseWordChar = /[\\u00df\\u0587\\u0590-\\u05f4\\u0600-\\u06ff\\u3040-\\u309f\\u30a0-\\u30ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\uac00-\\ud7af]/;\n  function isWordCharBasic(ch) {\n    return /\\w/.test(ch) || ch > \"\\x80\" &&\n      (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch))\n  }\n  function isWordChar(ch, helper) {\n    if (!helper) { return isWordCharBasic(ch) }\n    if (helper.source.indexOf(\"\\\\w\") > -1 && isWordCharBasic(ch)) { return true }\n    return helper.test(ch)\n  }\n\n  function isEmpty(obj) {\n    for (var n in obj) { if (obj.hasOwnProperty(n) && obj[n]) { return false } }\n    return true\n  }\n\n  // Extending unicode characters. A series of a non-extending char +\n  // any number of extending chars is treated as a single unit as far\n  // as editing and measuring is concerned. This is not fully correct,\n  // since some scripts/fonts/browsers also treat other configurations\n  // of code points as a group.\n  var extendingChars = /[\\u0300-\\u036f\\u0483-\\u0489\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u065e\\u0670\\u06d6-\\u06dc\\u06de-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07eb-\\u07f3\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0900-\\u0902\\u093c\\u0941-\\u0948\\u094d\\u0951-\\u0955\\u0962\\u0963\\u0981\\u09bc\\u09be\\u09c1-\\u09c4\\u09cd\\u09d7\\u09e2\\u09e3\\u0a01\\u0a02\\u0a3c\\u0a41\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a70\\u0a71\\u0a75\\u0a81\\u0a82\\u0abc\\u0ac1-\\u0ac5\\u0ac7\\u0ac8\\u0acd\\u0ae2\\u0ae3\\u0b01\\u0b3c\\u0b3e\\u0b3f\\u0b41-\\u0b44\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b82\\u0bbe\\u0bc0\\u0bcd\\u0bd7\\u0c3e-\\u0c40\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0cbc\\u0cbf\\u0cc2\\u0cc6\\u0ccc\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0d3e\\u0d41-\\u0d44\\u0d4d\\u0d57\\u0d62\\u0d63\\u0dca\\u0dcf\\u0dd2-\\u0dd4\\u0dd6\\u0ddf\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0eb1\\u0eb4-\\u0eb9\\u0ebb\\u0ebc\\u0ec8-\\u0ecd\\u0f18\\u0f19\\u0f35\\u0f37\\u0f39\\u0f71-\\u0f7e\\u0f80-\\u0f84\\u0f86\\u0f87\\u0f90-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102d-\\u1030\\u1032-\\u1037\\u1039\\u103a\\u103d\\u103e\\u1058\\u1059\\u105e-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108d\\u109d\\u135f\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b7-\\u17bd\\u17c6\\u17c9-\\u17d3\\u17dd\\u180b-\\u180d\\u18a9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193b\\u1a17\\u1a18\\u1a56\\u1a58-\\u1a5e\\u1a60\\u1a62\\u1a65-\\u1a6c\\u1a73-\\u1a7c\\u1a7f\\u1b00-\\u1b03\\u1b34\\u1b36-\\u1b3a\\u1b3c\\u1b42\\u1b6b-\\u1b73\\u1b80\\u1b81\\u1ba2-\\u1ba5\\u1ba8\\u1ba9\\u1c2c-\\u1c33\\u1c36\\u1c37\\u1cd0-\\u1cd2\\u1cd4-\\u1ce0\\u1ce2-\\u1ce8\\u1ced\\u1dc0-\\u1de6\\u1dfd-\\u1dff\\u200c\\u200d\\u20d0-\\u20f0\\u2cef-\\u2cf1\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua66f-\\ua672\\ua67c\\ua67d\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua825\\ua826\\ua8c4\\ua8e0-\\ua8f1\\ua926-\\ua92d\\ua947-\\ua951\\ua980-\\ua982\\ua9b3\\ua9b6-\\ua9b9\\ua9bc\\uaa29-\\uaa2e\\uaa31\\uaa32\\uaa35\\uaa36\\uaa43\\uaa4c\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uabe5\\uabe8\\uabed\\udc00-\\udfff\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe26\\uff9e\\uff9f]/;\n  function isExtendingChar(ch) { return ch.charCodeAt(0) >= 768 && extendingChars.test(ch) }\n\n  // Returns a number from the range [`0`; `str.length`] unless `pos` is outside that range.\n  function skipExtendingChars(str, pos, dir) {\n    while ((dir < 0 ? pos > 0 : pos < str.length) && isExtendingChar(str.charAt(pos))) { pos += dir; }\n    return pos\n  }\n\n  // Returns the value from the range [`from`; `to`] that satisfies\n  // `pred` and is closest to `from`. Assumes that at least `to`\n  // satisfies `pred`. Supports `from` being greater than `to`.\n  function findFirst(pred, from, to) {\n    // At any point we are certain `to` satisfies `pred`, don't know\n    // whether `from` does.\n    var dir = from > to ? -1 : 1;\n    for (;;) {\n      if (from == to) { return from }\n      var midF = (from + to) / 2, mid = dir < 0 ? Math.ceil(midF) : Math.floor(midF);\n      if (mid == from) { return pred(mid) ? from : to }\n      if (pred(mid)) { to = mid; }\n      else { from = mid + dir; }\n    }\n  }\n\n  // BIDI HELPERS\n\n  function iterateBidiSections(order, from, to, f) {\n    if (!order) { return f(from, to, \"ltr\", 0) }\n    var found = false;\n    for (var i = 0; i < order.length; ++i) {\n      var part = order[i];\n      if (part.from < to && part.to > from || from == to && part.to == from) {\n        f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? \"rtl\" : \"ltr\", i);\n        found = true;\n      }\n    }\n    if (!found) { f(from, to, \"ltr\"); }\n  }\n\n  var bidiOther = null;\n  function getBidiPartAt(order, ch, sticky) {\n    var found;\n    bidiOther = null;\n    for (var i = 0; i < order.length; ++i) {\n      var cur = order[i];\n      if (cur.from < ch && cur.to > ch) { return i }\n      if (cur.to == ch) {\n        if (cur.from != cur.to && sticky == \"before\") { found = i; }\n        else { bidiOther = i; }\n      }\n      if (cur.from == ch) {\n        if (cur.from != cur.to && sticky != \"before\") { found = i; }\n        else { bidiOther = i; }\n      }\n    }\n    return found != null ? found : bidiOther\n  }\n\n  // Bidirectional ordering algorithm\n  // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm\n  // that this (partially) implements.\n\n  // One-char codes used for character types:\n  // L (L):   Left-to-Right\n  // R (R):   Right-to-Left\n  // r (AL):  Right-to-Left Arabic\n  // 1 (EN):  European Number\n  // + (ES):  European Number Separator\n  // % (ET):  European Number Terminator\n  // n (AN):  Arabic Number\n  // , (CS):  Common Number Separator\n  // m (NSM): Non-Spacing Mark\n  // b (BN):  Boundary Neutral\n  // s (B):   Paragraph Separator\n  // t (S):   Segment Separator\n  // w (WS):  Whitespace\n  // N (ON):  Other Neutrals\n\n  // Returns null if characters are ordered as they appear\n  // (left-to-right), or an array of sections ({from, to, level}\n  // objects) in the order in which they occur visually.\n  var bidiOrdering = (function() {\n    // Character types for codepoints 0 to 0xff\n    var lowTypes = \"bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN\";\n    // Character types for codepoints 0x600 to 0x6f9\n    var arabicTypes = \"nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111\";\n    function charType(code) {\n      if (code <= 0xf7) { return lowTypes.charAt(code) }\n      else if (0x590 <= code && code <= 0x5f4) { return \"R\" }\n      else if (0x600 <= code && code <= 0x6f9) { return arabicTypes.charAt(code - 0x600) }\n      else if (0x6ee <= code && code <= 0x8ac) { return \"r\" }\n      else if (0x2000 <= code && code <= 0x200b) { return \"w\" }\n      else if (code == 0x200c) { return \"b\" }\n      else { return \"L\" }\n    }\n\n    var bidiRE = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac]/;\n    var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;\n\n    function BidiSpan(level, from, to) {\n      this.level = level;\n      this.from = from; this.to = to;\n    }\n\n    return function(str, direction) {\n      var outerType = direction == \"ltr\" ? \"L\" : \"R\";\n\n      if (str.length == 0 || direction == \"ltr\" && !bidiRE.test(str)) { return false }\n      var len = str.length, types = [];\n      for (var i = 0; i < len; ++i)\n        { types.push(charType(str.charCodeAt(i))); }\n\n      // W1. Examine each non-spacing mark (NSM) in the level run, and\n      // change the type of the NSM to the type of the previous\n      // character. If the NSM is at the start of the level run, it will\n      // get the type of sor.\n      for (var i$1 = 0, prev = outerType; i$1 < len; ++i$1) {\n        var type = types[i$1];\n        if (type == \"m\") { types[i$1] = prev; }\n        else { prev = type; }\n      }\n\n      // W2. Search backwards from each instance of a European number\n      // until the first strong type (R, L, AL, or sor) is found. If an\n      // AL is found, change the type of the European number to Arabic\n      // number.\n      // W3. Change all ALs to R.\n      for (var i$2 = 0, cur = outerType; i$2 < len; ++i$2) {\n        var type$1 = types[i$2];\n        if (type$1 == \"1\" && cur == \"r\") { types[i$2] = \"n\"; }\n        else if (isStrong.test(type$1)) { cur = type$1; if (type$1 == \"r\") { types[i$2] = \"R\"; } }\n      }\n\n      // W4. A single European separator between two European numbers\n      // changes to a European number. A single common separator between\n      // two numbers of the same type changes to that type.\n      for (var i$3 = 1, prev$1 = types[0]; i$3 < len - 1; ++i$3) {\n        var type$2 = types[i$3];\n        if (type$2 == \"+\" && prev$1 == \"1\" && types[i$3+1] == \"1\") { types[i$3] = \"1\"; }\n        else if (type$2 == \",\" && prev$1 == types[i$3+1] &&\n                 (prev$1 == \"1\" || prev$1 == \"n\")) { types[i$3] = prev$1; }\n        prev$1 = type$2;\n      }\n\n      // W5. A sequence of European terminators adjacent to European\n      // numbers changes to all European numbers.\n      // W6. Otherwise, separators and terminators change to Other\n      // Neutral.\n      for (var i$4 = 0; i$4 < len; ++i$4) {\n        var type$3 = types[i$4];\n        if (type$3 == \",\") { types[i$4] = \"N\"; }\n        else if (type$3 == \"%\") {\n          var end = (void 0);\n          for (end = i$4 + 1; end < len && types[end] == \"%\"; ++end) {}\n          var replace = (i$4 && types[i$4-1] == \"!\") || (end < len && types[end] == \"1\") ? \"1\" : \"N\";\n          for (var j = i$4; j < end; ++j) { types[j] = replace; }\n          i$4 = end - 1;\n        }\n      }\n\n      // W7. Search backwards from each instance of a European number\n      // until the first strong type (R, L, or sor) is found. If an L is\n      // found, then change the type of the European number to L.\n      for (var i$5 = 0, cur$1 = outerType; i$5 < len; ++i$5) {\n        var type$4 = types[i$5];\n        if (cur$1 == \"L\" && type$4 == \"1\") { types[i$5] = \"L\"; }\n        else if (isStrong.test(type$4)) { cur$1 = type$4; }\n      }\n\n      // N1. A sequence of neutrals takes the direction of the\n      // surrounding strong text if the text on both sides has the same\n      // direction. European and Arabic numbers act as if they were R in\n      // terms of their influence on neutrals. Start-of-level-run (sor)\n      // and end-of-level-run (eor) are used at level run boundaries.\n      // N2. Any remaining neutrals take the embedding direction.\n      for (var i$6 = 0; i$6 < len; ++i$6) {\n        if (isNeutral.test(types[i$6])) {\n          var end$1 = (void 0);\n          for (end$1 = i$6 + 1; end$1 < len && isNeutral.test(types[end$1]); ++end$1) {}\n          var before = (i$6 ? types[i$6-1] : outerType) == \"L\";\n          var after = (end$1 < len ? types[end$1] : outerType) == \"L\";\n          var replace$1 = before == after ? (before ? \"L\" : \"R\") : outerType;\n          for (var j$1 = i$6; j$1 < end$1; ++j$1) { types[j$1] = replace$1; }\n          i$6 = end$1 - 1;\n        }\n      }\n\n      // Here we depart from the documented algorithm, in order to avoid\n      // building up an actual levels array. Since there are only three\n      // levels (0, 1, 2) in an implementation that doesn't take\n      // explicit embedding into account, we can build up the order on\n      // the fly, without following the level-based algorithm.\n      var order = [], m;\n      for (var i$7 = 0; i$7 < len;) {\n        if (countsAsLeft.test(types[i$7])) {\n          var start = i$7;\n          for (++i$7; i$7 < len && countsAsLeft.test(types[i$7]); ++i$7) {}\n          order.push(new BidiSpan(0, start, i$7));\n        } else {\n          var pos = i$7, at = order.length, isRTL = direction == \"rtl\" ? 1 : 0;\n          for (++i$7; i$7 < len && types[i$7] != \"L\"; ++i$7) {}\n          for (var j$2 = pos; j$2 < i$7;) {\n            if (countsAsNum.test(types[j$2])) {\n              if (pos < j$2) { order.splice(at, 0, new BidiSpan(1, pos, j$2)); at += isRTL; }\n              var nstart = j$2;\n              for (++j$2; j$2 < i$7 && countsAsNum.test(types[j$2]); ++j$2) {}\n              order.splice(at, 0, new BidiSpan(2, nstart, j$2));\n              at += isRTL;\n              pos = j$2;\n            } else { ++j$2; }\n          }\n          if (pos < i$7) { order.splice(at, 0, new BidiSpan(1, pos, i$7)); }\n        }\n      }\n      if (direction == \"ltr\") {\n        if (order[0].level == 1 && (m = str.match(/^\\s+/))) {\n          order[0].from = m[0].length;\n          order.unshift(new BidiSpan(0, 0, m[0].length));\n        }\n        if (lst(order).level == 1 && (m = str.match(/\\s+$/))) {\n          lst(order).to -= m[0].length;\n          order.push(new BidiSpan(0, len - m[0].length, len));\n        }\n      }\n\n      return direction == \"rtl\" ? order.reverse() : order\n    }\n  })();\n\n  // Get the bidi ordering for the given line (and cache it). Returns\n  // false for lines that are fully left-to-right, and an array of\n  // BidiSpan objects otherwise.\n  function getOrder(line, direction) {\n    var order = line.order;\n    if (order == null) { order = line.order = bidiOrdering(line.text, direction); }\n    return order\n  }\n\n  // EVENT HANDLING\n\n  // Lightweight event framework. on/off also work on DOM nodes,\n  // registering native DOM handlers.\n\n  var noHandlers = [];\n\n  var on = function(emitter, type, f) {\n    if (emitter.addEventListener) {\n      emitter.addEventListener(type, f, false);\n    } else if (emitter.attachEvent) {\n      emitter.attachEvent(\"on\" + type, f);\n    } else {\n      var map = emitter._handlers || (emitter._handlers = {});\n      map[type] = (map[type] || noHandlers).concat(f);\n    }\n  };\n\n  function getHandlers(emitter, type) {\n    return emitter._handlers && emitter._handlers[type] || noHandlers\n  }\n\n  function off(emitter, type, f) {\n    if (emitter.removeEventListener) {\n      emitter.removeEventListener(type, f, false);\n    } else if (emitter.detachEvent) {\n      emitter.detachEvent(\"on\" + type, f);\n    } else {\n      var map = emitter._handlers, arr = map && map[type];\n      if (arr) {\n        var index = indexOf(arr, f);\n        if (index > -1)\n          { map[type] = arr.slice(0, index).concat(arr.slice(index + 1)); }\n      }\n    }\n  }\n\n  function signal(emitter, type /*, values...*/) {\n    var handlers = getHandlers(emitter, type);\n    if (!handlers.length) { return }\n    var args = Array.prototype.slice.call(arguments, 2);\n    for (var i = 0; i < handlers.length; ++i) { handlers[i].apply(null, args); }\n  }\n\n  // The DOM events that CodeMirror handles can be overridden by\n  // registering a (non-DOM) handler on the editor for the event name,\n  // and preventDefault-ing the event in that handler.\n  function signalDOMEvent(cm, e, override) {\n    if (typeof e == \"string\")\n      { e = {type: e, preventDefault: function() { this.defaultPrevented = true; }}; }\n    signal(cm, override || e.type, cm, e);\n    return e_defaultPrevented(e) || e.codemirrorIgnore\n  }\n\n  function signalCursorActivity(cm) {\n    var arr = cm._handlers && cm._handlers.cursorActivity;\n    if (!arr) { return }\n    var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);\n    for (var i = 0; i < arr.length; ++i) { if (indexOf(set, arr[i]) == -1)\n      { set.push(arr[i]); } }\n  }\n\n  function hasHandler(emitter, type) {\n    return getHandlers(emitter, type).length > 0\n  }\n\n  // Add on and off methods to a constructor's prototype, to make\n  // registering events on such objects more convenient.\n  function eventMixin(ctor) {\n    ctor.prototype.on = function(type, f) {on(this, type, f);};\n    ctor.prototype.off = function(type, f) {off(this, type, f);};\n  }\n\n  // Due to the fact that we still support jurassic IE versions, some\n  // compatibility wrappers are needed.\n\n  function e_preventDefault(e) {\n    if (e.preventDefault) { e.preventDefault(); }\n    else { e.returnValue = false; }\n  }\n  function e_stopPropagation(e) {\n    if (e.stopPropagation) { e.stopPropagation(); }\n    else { e.cancelBubble = true; }\n  }\n  function e_defaultPrevented(e) {\n    return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false\n  }\n  function e_stop(e) {e_preventDefault(e); e_stopPropagation(e);}\n\n  function e_target(e) {return e.target || e.srcElement}\n  function e_button(e) {\n    var b = e.which;\n    if (b == null) {\n      if (e.button & 1) { b = 1; }\n      else if (e.button & 2) { b = 3; }\n      else if (e.button & 4) { b = 2; }\n    }\n    if (mac && e.ctrlKey && b == 1) { b = 3; }\n    return b\n  }\n\n  // Detect drag-and-drop\n  var dragAndDrop = function() {\n    // There is *some* kind of drag-and-drop support in IE6-8, but I\n    // couldn't get it to work yet.\n    if (ie && ie_version < 9) { return false }\n    var div = elt('div');\n    return \"draggable\" in div || \"dragDrop\" in div\n  }();\n\n  var zwspSupported;\n  function zeroWidthElement(measure) {\n    if (zwspSupported == null) {\n      var test = elt(\"span\", \"\\u200b\");\n      removeChildrenAndAdd(measure, elt(\"span\", [test, document.createTextNode(\"x\")]));\n      if (measure.firstChild.offsetHeight != 0)\n        { zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8); }\n    }\n    var node = zwspSupported ? elt(\"span\", \"\\u200b\") :\n      elt(\"span\", \"\\u00a0\", null, \"display: inline-block; width: 1px; margin-right: -1px\");\n    node.setAttribute(\"cm-text\", \"\");\n    return node\n  }\n\n  // Feature-detect IE's crummy client rect reporting for bidi text\n  var badBidiRects;\n  function hasBadBidiRects(measure) {\n    if (badBidiRects != null) { return badBidiRects }\n    var txt = removeChildrenAndAdd(measure, document.createTextNode(\"A\\u062eA\"));\n    var r0 = range(txt, 0, 1).getBoundingClientRect();\n    var r1 = range(txt, 1, 2).getBoundingClientRect();\n    removeChildren(measure);\n    if (!r0 || r0.left == r0.right) { return false } // Safari returns null in some cases (#2780)\n    return badBidiRects = (r1.right - r0.right < 3)\n  }\n\n  // See if \"\".split is the broken IE version, if so, provide an\n  // alternative way to split lines.\n  var splitLinesAuto = \"\\n\\nb\".split(/\\n/).length != 3 ? function (string) {\n    var pos = 0, result = [], l = string.length;\n    while (pos <= l) {\n      var nl = string.indexOf(\"\\n\", pos);\n      if (nl == -1) { nl = string.length; }\n      var line = string.slice(pos, string.charAt(nl - 1) == \"\\r\" ? nl - 1 : nl);\n      var rt = line.indexOf(\"\\r\");\n      if (rt != -1) {\n        result.push(line.slice(0, rt));\n        pos += rt + 1;\n      } else {\n        result.push(line);\n        pos = nl + 1;\n      }\n    }\n    return result\n  } : function (string) { return string.split(/\\r\\n?|\\n/); };\n\n  var hasSelection = window.getSelection ? function (te) {\n    try { return te.selectionStart != te.selectionEnd }\n    catch(e) { return false }\n  } : function (te) {\n    var range;\n    try {range = te.ownerDocument.selection.createRange();}\n    catch(e) {}\n    if (!range || range.parentElement() != te) { return false }\n    return range.compareEndPoints(\"StartToEnd\", range) != 0\n  };\n\n  var hasCopyEvent = (function () {\n    var e = elt(\"div\");\n    if (\"oncopy\" in e) { return true }\n    e.setAttribute(\"oncopy\", \"return;\");\n    return typeof e.oncopy == \"function\"\n  })();\n\n  var badZoomedRects = null;\n  function hasBadZoomedRects(measure) {\n    if (badZoomedRects != null) { return badZoomedRects }\n    var node = removeChildrenAndAdd(measure, elt(\"span\", \"x\"));\n    var normal = node.getBoundingClientRect();\n    var fromRange = range(node, 0, 1).getBoundingClientRect();\n    return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1\n  }\n\n  // Known modes, by name and by MIME\n  var modes = {}, mimeModes = {};\n\n  // Extra arguments are stored as the mode's dependencies, which is\n  // used by (legacy) mechanisms like loadmode.js to automatically\n  // load a mode. (Preferred mechanism is the require/define calls.)\n  function defineMode(name, mode) {\n    if (arguments.length > 2)\n      { mode.dependencies = Array.prototype.slice.call(arguments, 2); }\n    modes[name] = mode;\n  }\n\n  function defineMIME(mime, spec) {\n    mimeModes[mime] = spec;\n  }\n\n  // Given a MIME type, a {name, ...options} config object, or a name\n  // string, return a mode config object.\n  function resolveMode(spec) {\n    if (typeof spec == \"string\" && mimeModes.hasOwnProperty(spec)) {\n      spec = mimeModes[spec];\n    } else if (spec && typeof spec.name == \"string\" && mimeModes.hasOwnProperty(spec.name)) {\n      var found = mimeModes[spec.name];\n      if (typeof found == \"string\") { found = {name: found}; }\n      spec = createObj(found, spec);\n      spec.name = found.name;\n    } else if (typeof spec == \"string\" && /^[\\w\\-]+\\/[\\w\\-]+\\+xml$/.test(spec)) {\n      return resolveMode(\"application/xml\")\n    } else if (typeof spec == \"string\" && /^[\\w\\-]+\\/[\\w\\-]+\\+json$/.test(spec)) {\n      return resolveMode(\"application/json\")\n    }\n    if (typeof spec == \"string\") { return {name: spec} }\n    else { return spec || {name: \"null\"} }\n  }\n\n  // Given a mode spec (anything that resolveMode accepts), find and\n  // initialize an actual mode object.\n  function getMode(options, spec) {\n    spec = resolveMode(spec);\n    var mfactory = modes[spec.name];\n    if (!mfactory) { return getMode(options, \"text/plain\") }\n    var modeObj = mfactory(options, spec);\n    if (modeExtensions.hasOwnProperty(spec.name)) {\n      var exts = modeExtensions[spec.name];\n      for (var prop in exts) {\n        if (!exts.hasOwnProperty(prop)) { continue }\n        if (modeObj.hasOwnProperty(prop)) { modeObj[\"_\" + prop] = modeObj[prop]; }\n        modeObj[prop] = exts[prop];\n      }\n    }\n    modeObj.name = spec.name;\n    if (spec.helperType) { modeObj.helperType = spec.helperType; }\n    if (spec.modeProps) { for (var prop$1 in spec.modeProps)\n      { modeObj[prop$1] = spec.modeProps[prop$1]; } }\n\n    return modeObj\n  }\n\n  // This can be used to attach properties to mode objects from\n  // outside the actual mode definition.\n  var modeExtensions = {};\n  function extendMode(mode, properties) {\n    var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});\n    copyObj(properties, exts);\n  }\n\n  function copyState(mode, state) {\n    if (state === true) { return state }\n    if (mode.copyState) { return mode.copyState(state) }\n    var nstate = {};\n    for (var n in state) {\n      var val = state[n];\n      if (val instanceof Array) { val = val.concat([]); }\n      nstate[n] = val;\n    }\n    return nstate\n  }\n\n  // Given a mode and a state (for that mode), find the inner mode and\n  // state at the position that the state refers to.\n  function innerMode(mode, state) {\n    var info;\n    while (mode.innerMode) {\n      info = mode.innerMode(state);\n      if (!info || info.mode == mode) { break }\n      state = info.state;\n      mode = info.mode;\n    }\n    return info || {mode: mode, state: state}\n  }\n\n  function startState(mode, a1, a2) {\n    return mode.startState ? mode.startState(a1, a2) : true\n  }\n\n  // STRING STREAM\n\n  // Fed to the mode parsers, provides helper functions to make\n  // parsers more succinct.\n\n  var StringStream = function(string, tabSize, lineOracle) {\n    this.pos = this.start = 0;\n    this.string = string;\n    this.tabSize = tabSize || 8;\n    this.lastColumnPos = this.lastColumnValue = 0;\n    this.lineStart = 0;\n    this.lineOracle = lineOracle;\n  };\n\n  StringStream.prototype.eol = function () {return this.pos >= this.string.length};\n  StringStream.prototype.sol = function () {return this.pos == this.lineStart};\n  StringStream.prototype.peek = function () {return this.string.charAt(this.pos) || undefined};\n  StringStream.prototype.next = function () {\n    if (this.pos < this.string.length)\n      { return this.string.charAt(this.pos++) }\n  };\n  StringStream.prototype.eat = function (match) {\n    var ch = this.string.charAt(this.pos);\n    var ok;\n    if (typeof match == \"string\") { ok = ch == match; }\n    else { ok = ch && (match.test ? match.test(ch) : match(ch)); }\n    if (ok) {++this.pos; return ch}\n  };\n  StringStream.prototype.eatWhile = function (match) {\n    var start = this.pos;\n    while (this.eat(match)){}\n    return this.pos > start\n  };\n  StringStream.prototype.eatSpace = function () {\n    var start = this.pos;\n    while (/[\\s\\u00a0]/.test(this.string.charAt(this.pos))) { ++this.pos; }\n    return this.pos > start\n  };\n  StringStream.prototype.skipToEnd = function () {this.pos = this.string.length;};\n  StringStream.prototype.skipTo = function (ch) {\n    var found = this.string.indexOf(ch, this.pos);\n    if (found > -1) {this.pos = found; return true}\n  };\n  StringStream.prototype.backUp = function (n) {this.pos -= n;};\n  StringStream.prototype.column = function () {\n    if (this.lastColumnPos < this.start) {\n      this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);\n      this.lastColumnPos = this.start;\n    }\n    return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)\n  };\n  StringStream.prototype.indentation = function () {\n    return countColumn(this.string, null, this.tabSize) -\n      (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)\n  };\n  StringStream.prototype.match = function (pattern, consume, caseInsensitive) {\n    if (typeof pattern == \"string\") {\n      var cased = function (str) { return caseInsensitive ? str.toLowerCase() : str; };\n      var substr = this.string.substr(this.pos, pattern.length);\n      if (cased(substr) == cased(pattern)) {\n        if (consume !== false) { this.pos += pattern.length; }\n        return true\n      }\n    } else {\n      var match = this.string.slice(this.pos).match(pattern);\n      if (match && match.index > 0) { return null }\n      if (match && consume !== false) { this.pos += match[0].length; }\n      return match\n    }\n  };\n  StringStream.prototype.current = function (){return this.string.slice(this.start, this.pos)};\n  StringStream.prototype.hideFirstChars = function (n, inner) {\n    this.lineStart += n;\n    try { return inner() }\n    finally { this.lineStart -= n; }\n  };\n  StringStream.prototype.lookAhead = function (n) {\n    var oracle = this.lineOracle;\n    return oracle && oracle.lookAhead(n)\n  };\n  StringStream.prototype.baseToken = function () {\n    var oracle = this.lineOracle;\n    return oracle && oracle.baseToken(this.pos)\n  };\n\n  // Find the line object corresponding to the given line number.\n  function getLine(doc, n) {\n    n -= doc.first;\n    if (n < 0 || n >= doc.size) { throw new Error(\"There is no line \" + (n + doc.first) + \" in the document.\") }\n    var chunk = doc;\n    while (!chunk.lines) {\n      for (var i = 0;; ++i) {\n        var child = chunk.children[i], sz = child.chunkSize();\n        if (n < sz) { chunk = child; break }\n        n -= sz;\n      }\n    }\n    return chunk.lines[n]\n  }\n\n  // Get the part of a document between two positions, as an array of\n  // strings.\n  function getBetween(doc, start, end) {\n    var out = [], n = start.line;\n    doc.iter(start.line, end.line + 1, function (line) {\n      var text = line.text;\n      if (n == end.line) { text = text.slice(0, end.ch); }\n      if (n == start.line) { text = text.slice(start.ch); }\n      out.push(text);\n      ++n;\n    });\n    return out\n  }\n  // Get the lines between from and to, as array of strings.\n  function getLines(doc, from, to) {\n    var out = [];\n    doc.iter(from, to, function (line) { out.push(line.text); }); // iter aborts when callback returns truthy value\n    return out\n  }\n\n  // Update the height of a line, propagating the height change\n  // upwards to parent nodes.\n  function updateLineHeight(line, height) {\n    var diff = height - line.height;\n    if (diff) { for (var n = line; n; n = n.parent) { n.height += diff; } }\n  }\n\n  // Given a line object, find its line number by walking up through\n  // its parent links.\n  function lineNo(line) {\n    if (line.parent == null) { return null }\n    var cur = line.parent, no = indexOf(cur.lines, line);\n    for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {\n      for (var i = 0;; ++i) {\n        if (chunk.children[i] == cur) { break }\n        no += chunk.children[i].chunkSize();\n      }\n    }\n    return no + cur.first\n  }\n\n  // Find the line at the given vertical position, using the height\n  // information in the document tree.\n  function lineAtHeight(chunk, h) {\n    var n = chunk.first;\n    outer: do {\n      for (var i$1 = 0; i$1 < chunk.children.length; ++i$1) {\n        var child = chunk.children[i$1], ch = child.height;\n        if (h < ch) { chunk = child; continue outer }\n        h -= ch;\n        n += child.chunkSize();\n      }\n      return n\n    } while (!chunk.lines)\n    var i = 0;\n    for (; i < chunk.lines.length; ++i) {\n      var line = chunk.lines[i], lh = line.height;\n      if (h < lh) { break }\n      h -= lh;\n    }\n    return n + i\n  }\n\n  function isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size}\n\n  function lineNumberFor(options, i) {\n    return String(options.lineNumberFormatter(i + options.firstLineNumber))\n  }\n\n  // A Pos instance represents a position within the text.\n  function Pos(line, ch, sticky) {\n    if ( sticky === void 0 ) sticky = null;\n\n    if (!(this instanceof Pos)) { return new Pos(line, ch, sticky) }\n    this.line = line;\n    this.ch = ch;\n    this.sticky = sticky;\n  }\n\n  // Compare two positions, return 0 if they are the same, a negative\n  // number when a is less, and a positive number otherwise.\n  function cmp(a, b) { return a.line - b.line || a.ch - b.ch }\n\n  function equalCursorPos(a, b) { return a.sticky == b.sticky && cmp(a, b) == 0 }\n\n  function copyPos(x) {return Pos(x.line, x.ch)}\n  function maxPos(a, b) { return cmp(a, b) < 0 ? b : a }\n  function minPos(a, b) { return cmp(a, b) < 0 ? a : b }\n\n  // Most of the external API clips given positions to make sure they\n  // actually exist within the document.\n  function clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1))}\n  function clipPos(doc, pos) {\n    if (pos.line < doc.first) { return Pos(doc.first, 0) }\n    var last = doc.first + doc.size - 1;\n    if (pos.line > last) { return Pos(last, getLine(doc, last).text.length) }\n    return clipToLen(pos, getLine(doc, pos.line).text.length)\n  }\n  function clipToLen(pos, linelen) {\n    var ch = pos.ch;\n    if (ch == null || ch > linelen) { return Pos(pos.line, linelen) }\n    else if (ch < 0) { return Pos(pos.line, 0) }\n    else { return pos }\n  }\n  function clipPosArray(doc, array) {\n    var out = [];\n    for (var i = 0; i < array.length; i++) { out[i] = clipPos(doc, array[i]); }\n    return out\n  }\n\n  var SavedContext = function(state, lookAhead) {\n    this.state = state;\n    this.lookAhead = lookAhead;\n  };\n\n  var Context = function(doc, state, line, lookAhead) {\n    this.state = state;\n    this.doc = doc;\n    this.line = line;\n    this.maxLookAhead = lookAhead || 0;\n    this.baseTokens = null;\n    this.baseTokenPos = 1;\n  };\n\n  Context.prototype.lookAhead = function (n) {\n    var line = this.doc.getLine(this.line + n);\n    if (line != null && n > this.maxLookAhead) { this.maxLookAhead = n; }\n    return line\n  };\n\n  Context.prototype.baseToken = function (n) {\n    if (!this.baseTokens) { return null }\n    while (this.baseTokens[this.baseTokenPos] <= n)\n      { this.baseTokenPos += 2; }\n    var type = this.baseTokens[this.baseTokenPos + 1];\n    return {type: type && type.replace(/( |^)overlay .*/, \"\"),\n            size: this.baseTokens[this.baseTokenPos] - n}\n  };\n\n  Context.prototype.nextLine = function () {\n    this.line++;\n    if (this.maxLookAhead > 0) { this.maxLookAhead--; }\n  };\n\n  Context.fromSaved = function (doc, saved, line) {\n    if (saved instanceof SavedContext)\n      { return new Context(doc, copyState(doc.mode, saved.state), line, saved.lookAhead) }\n    else\n      { return new Context(doc, copyState(doc.mode, saved), line) }\n  };\n\n  Context.prototype.save = function (copy) {\n    var state = copy !== false ? copyState(this.doc.mode, this.state) : this.state;\n    return this.maxLookAhead > 0 ? new SavedContext(state, this.maxLookAhead) : state\n  };\n\n\n  // Compute a style array (an array starting with a mode generation\n  // -- for invalidation -- followed by pairs of end positions and\n  // style strings), which is used to highlight the tokens on the\n  // line.\n  function highlightLine(cm, line, context, forceToEnd) {\n    // A styles array always starts with a number identifying the\n    // mode/overlays that it is based on (for easy invalidation).\n    var st = [cm.state.modeGen], lineClasses = {};\n    // Compute the base array of styles\n    runMode(cm, line.text, cm.doc.mode, context, function (end, style) { return st.push(end, style); },\n            lineClasses, forceToEnd);\n    var state = context.state;\n\n    // Run overlays, adjust style array.\n    var loop = function ( o ) {\n      context.baseTokens = st;\n      var overlay = cm.state.overlays[o], i = 1, at = 0;\n      context.state = true;\n      runMode(cm, line.text, overlay.mode, context, function (end, style) {\n        var start = i;\n        // Ensure there's a token end at the current position, and that i points at it\n        while (at < end) {\n          var i_end = st[i];\n          if (i_end > end)\n            { st.splice(i, 1, end, st[i+1], i_end); }\n          i += 2;\n          at = Math.min(end, i_end);\n        }\n        if (!style) { return }\n        if (overlay.opaque) {\n          st.splice(start, i - start, end, \"overlay \" + style);\n          i = start + 2;\n        } else {\n          for (; start < i; start += 2) {\n            var cur = st[start+1];\n            st[start+1] = (cur ? cur + \" \" : \"\") + \"overlay \" + style;\n          }\n        }\n      }, lineClasses);\n      context.state = state;\n      context.baseTokens = null;\n      context.baseTokenPos = 1;\n    };\n\n    for (var o = 0; o < cm.state.overlays.length; ++o) loop( o );\n\n    return {styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null}\n  }\n\n  function getLineStyles(cm, line, updateFrontier) {\n    if (!line.styles || line.styles[0] != cm.state.modeGen) {\n      var context = getContextBefore(cm, lineNo(line));\n      var resetState = line.text.length > cm.options.maxHighlightLength && copyState(cm.doc.mode, context.state);\n      var result = highlightLine(cm, line, context);\n      if (resetState) { context.state = resetState; }\n      line.stateAfter = context.save(!resetState);\n      line.styles = result.styles;\n      if (result.classes) { line.styleClasses = result.classes; }\n      else if (line.styleClasses) { line.styleClasses = null; }\n      if (updateFrontier === cm.doc.highlightFrontier)\n        { cm.doc.modeFrontier = Math.max(cm.doc.modeFrontier, ++cm.doc.highlightFrontier); }\n    }\n    return line.styles\n  }\n\n  function getContextBefore(cm, n, precise) {\n    var doc = cm.doc, display = cm.display;\n    if (!doc.mode.startState) { return new Context(doc, true, n) }\n    var start = findStartLine(cm, n, precise);\n    var saved = start > doc.first && getLine(doc, start - 1).stateAfter;\n    var context = saved ? Context.fromSaved(doc, saved, start) : new Context(doc, startState(doc.mode), start);\n\n    doc.iter(start, n, function (line) {\n      processLine(cm, line.text, context);\n      var pos = context.line;\n      line.stateAfter = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo ? context.save() : null;\n      context.nextLine();\n    });\n    if (precise) { doc.modeFrontier = context.line; }\n    return context\n  }\n\n  // Lightweight form of highlight -- proceed over this line and\n  // update state, but don't save a style array. Used for lines that\n  // aren't currently visible.\n  function processLine(cm, text, context, startAt) {\n    var mode = cm.doc.mode;\n    var stream = new StringStream(text, cm.options.tabSize, context);\n    stream.start = stream.pos = startAt || 0;\n    if (text == \"\") { callBlankLine(mode, context.state); }\n    while (!stream.eol()) {\n      readToken(mode, stream, context.state);\n      stream.start = stream.pos;\n    }\n  }\n\n  function callBlankLine(mode, state) {\n    if (mode.blankLine) { return mode.blankLine(state) }\n    if (!mode.innerMode) { return }\n    var inner = innerMode(mode, state);\n    if (inner.mode.blankLine) { return inner.mode.blankLine(inner.state) }\n  }\n\n  function readToken(mode, stream, state, inner) {\n    for (var i = 0; i < 10; i++) {\n      if (inner) { inner[0] = innerMode(mode, state).mode; }\n      var style = mode.token(stream, state);\n      if (stream.pos > stream.start) { return style }\n    }\n    throw new Error(\"Mode \" + mode.name + \" failed to advance stream.\")\n  }\n\n  var Token = function(stream, type, state) {\n    this.start = stream.start; this.end = stream.pos;\n    this.string = stream.current();\n    this.type = type || null;\n    this.state = state;\n  };\n\n  // Utility for getTokenAt and getLineTokens\n  function takeToken(cm, pos, precise, asArray) {\n    var doc = cm.doc, mode = doc.mode, style;\n    pos = clipPos(doc, pos);\n    var line = getLine(doc, pos.line), context = getContextBefore(cm, pos.line, precise);\n    var stream = new StringStream(line.text, cm.options.tabSize, context), tokens;\n    if (asArray) { tokens = []; }\n    while ((asArray || stream.pos < pos.ch) && !stream.eol()) {\n      stream.start = stream.pos;\n      style = readToken(mode, stream, context.state);\n      if (asArray) { tokens.push(new Token(stream, style, copyState(doc.mode, context.state))); }\n    }\n    return asArray ? tokens : new Token(stream, style, context.state)\n  }\n\n  function extractLineClasses(type, output) {\n    if (type) { for (;;) {\n      var lineClass = type.match(/(?:^|\\s+)line-(background-)?(\\S+)/);\n      if (!lineClass) { break }\n      type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);\n      var prop = lineClass[1] ? \"bgClass\" : \"textClass\";\n      if (output[prop] == null)\n        { output[prop] = lineClass[2]; }\n      else if (!(new RegExp(\"(?:^|\\\\s)\" + lineClass[2] + \"(?:$|\\\\s)\")).test(output[prop]))\n        { output[prop] += \" \" + lineClass[2]; }\n    } }\n    return type\n  }\n\n  // Run the given mode's parser over a line, calling f for each token.\n  function runMode(cm, text, mode, context, f, lineClasses, forceToEnd) {\n    var flattenSpans = mode.flattenSpans;\n    if (flattenSpans == null) { flattenSpans = cm.options.flattenSpans; }\n    var curStart = 0, curStyle = null;\n    var stream = new StringStream(text, cm.options.tabSize, context), style;\n    var inner = cm.options.addModeClass && [null];\n    if (text == \"\") { extractLineClasses(callBlankLine(mode, context.state), lineClasses); }\n    while (!stream.eol()) {\n      if (stream.pos > cm.options.maxHighlightLength) {\n        flattenSpans = false;\n        if (forceToEnd) { processLine(cm, text, context, stream.pos); }\n        stream.pos = text.length;\n        style = null;\n      } else {\n        style = extractLineClasses(readToken(mode, stream, context.state, inner), lineClasses);\n      }\n      if (inner) {\n        var mName = inner[0].name;\n        if (mName) { style = \"m-\" + (style ? mName + \" \" + style : mName); }\n      }\n      if (!flattenSpans || curStyle != style) {\n        while (curStart < stream.start) {\n          curStart = Math.min(stream.start, curStart + 5000);\n          f(curStart, curStyle);\n        }\n        curStyle = style;\n      }\n      stream.start = stream.pos;\n    }\n    while (curStart < stream.pos) {\n      // Webkit seems to refuse to render text nodes longer than 57444\n      // characters, and returns inaccurate measurements in nodes\n      // starting around 5000 chars.\n      var pos = Math.min(stream.pos, curStart + 5000);\n      f(pos, curStyle);\n      curStart = pos;\n    }\n  }\n\n  // Finds the line to start with when starting a parse. Tries to\n  // find a line with a stateAfter, so that it can start with a\n  // valid state. If that fails, it returns the line with the\n  // smallest indentation, which tends to need the least context to\n  // parse correctly.\n  function findStartLine(cm, n, precise) {\n    var minindent, minline, doc = cm.doc;\n    var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);\n    for (var search = n; search > lim; --search) {\n      if (search <= doc.first) { return doc.first }\n      var line = getLine(doc, search - 1), after = line.stateAfter;\n      if (after && (!precise || search + (after instanceof SavedContext ? after.lookAhead : 0) <= doc.modeFrontier))\n        { return search }\n      var indented = countColumn(line.text, null, cm.options.tabSize);\n      if (minline == null || minindent > indented) {\n        minline = search - 1;\n        minindent = indented;\n      }\n    }\n    return minline\n  }\n\n  function retreatFrontier(doc, n) {\n    doc.modeFrontier = Math.min(doc.modeFrontier, n);\n    if (doc.highlightFrontier < n - 10) { return }\n    var start = doc.first;\n    for (var line = n - 1; line > start; line--) {\n      var saved = getLine(doc, line).stateAfter;\n      // change is on 3\n      // state on line 1 looked ahead 2 -- so saw 3\n      // test 1 + 2 < 3 should cover this\n      if (saved && (!(saved instanceof SavedContext) || line + saved.lookAhead < n)) {\n        start = line + 1;\n        break\n      }\n    }\n    doc.highlightFrontier = Math.min(doc.highlightFrontier, start);\n  }\n\n  // Optimize some code when these features are not used.\n  var sawReadOnlySpans = false, sawCollapsedSpans = false;\n\n  function seeReadOnlySpans() {\n    sawReadOnlySpans = true;\n  }\n\n  function seeCollapsedSpans() {\n    sawCollapsedSpans = true;\n  }\n\n  // TEXTMARKER SPANS\n\n  function MarkedSpan(marker, from, to) {\n    this.marker = marker;\n    this.from = from; this.to = to;\n  }\n\n  // Search an array of spans for a span matching the given marker.\n  function getMarkedSpanFor(spans, marker) {\n    if (spans) { for (var i = 0; i < spans.length; ++i) {\n      var span = spans[i];\n      if (span.marker == marker) { return span }\n    } }\n  }\n  // Remove a span from an array, returning undefined if no spans are\n  // left (we don't store arrays for lines without spans).\n  function removeMarkedSpan(spans, span) {\n    var r;\n    for (var i = 0; i < spans.length; ++i)\n      { if (spans[i] != span) { (r || (r = [])).push(spans[i]); } }\n    return r\n  }\n  // Add a span to a line.\n  function addMarkedSpan(line, span) {\n    line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];\n    span.marker.attachLine(line);\n  }\n\n  // Used for the algorithm that adjusts markers for a change in the\n  // document. These functions cut an array of spans at a given\n  // character position, returning an array of remaining chunks (or\n  // undefined if nothing remains).\n  function markedSpansBefore(old, startCh, isInsert) {\n    var nw;\n    if (old) { for (var i = 0; i < old.length; ++i) {\n      var span = old[i], marker = span.marker;\n      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);\n      if (startsBefore || span.from == startCh && marker.type == \"bookmark\" && (!isInsert || !span.marker.insertLeft)) {\n        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh)\n        ;(nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));\n      }\n    } }\n    return nw\n  }\n  function markedSpansAfter(old, endCh, isInsert) {\n    var nw;\n    if (old) { for (var i = 0; i < old.length; ++i) {\n      var span = old[i], marker = span.marker;\n      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);\n      if (endsAfter || span.from == endCh && marker.type == \"bookmark\" && (!isInsert || span.marker.insertLeft)) {\n        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh)\n        ;(nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh,\n                                              span.to == null ? null : span.to - endCh));\n      }\n    } }\n    return nw\n  }\n\n  // Given a change object, compute the new set of marker spans that\n  // cover the line in which the change took place. Removes spans\n  // entirely within the change, reconnects spans belonging to the\n  // same marker that appear on both sides of the change, and cuts off\n  // spans partially within the change. Returns an array of span\n  // arrays with one element for each line in (after) the change.\n  function stretchSpansOverChange(doc, change) {\n    if (change.full) { return null }\n    var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;\n    var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;\n    if (!oldFirst && !oldLast) { return null }\n\n    var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;\n    // Get the spans that 'stick out' on both sides\n    var first = markedSpansBefore(oldFirst, startCh, isInsert);\n    var last = markedSpansAfter(oldLast, endCh, isInsert);\n\n    // Next, merge those two ends\n    var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);\n    if (first) {\n      // Fix up .to properties of first\n      for (var i = 0; i < first.length; ++i) {\n        var span = first[i];\n        if (span.to == null) {\n          var found = getMarkedSpanFor(last, span.marker);\n          if (!found) { span.to = startCh; }\n          else if (sameLine) { span.to = found.to == null ? null : found.to + offset; }\n        }\n      }\n    }\n    if (last) {\n      // Fix up .from in last (or move them into first in case of sameLine)\n      for (var i$1 = 0; i$1 < last.length; ++i$1) {\n        var span$1 = last[i$1];\n        if (span$1.to != null) { span$1.to += offset; }\n        if (span$1.from == null) {\n          var found$1 = getMarkedSpanFor(first, span$1.marker);\n          if (!found$1) {\n            span$1.from = offset;\n            if (sameLine) { (first || (first = [])).push(span$1); }\n          }\n        } else {\n          span$1.from += offset;\n          if (sameLine) { (first || (first = [])).push(span$1); }\n        }\n      }\n    }\n    // Make sure we didn't create any zero-length spans\n    if (first) { first = clearEmptySpans(first); }\n    if (last && last != first) { last = clearEmptySpans(last); }\n\n    var newMarkers = [first];\n    if (!sameLine) {\n      // Fill gap with whole-line-spans\n      var gap = change.text.length - 2, gapMarkers;\n      if (gap > 0 && first)\n        { for (var i$2 = 0; i$2 < first.length; ++i$2)\n          { if (first[i$2].to == null)\n            { (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i$2].marker, null, null)); } } }\n      for (var i$3 = 0; i$3 < gap; ++i$3)\n        { newMarkers.push(gapMarkers); }\n      newMarkers.push(last);\n    }\n    return newMarkers\n  }\n\n  // Remove spans that are empty and don't have a clearWhenEmpty\n  // option of false.\n  function clearEmptySpans(spans) {\n    for (var i = 0; i < spans.length; ++i) {\n      var span = spans[i];\n      if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)\n        { spans.splice(i--, 1); }\n    }\n    if (!spans.length) { return null }\n    return spans\n  }\n\n  // Used to 'clip' out readOnly ranges when making a change.\n  function removeReadOnlyRanges(doc, from, to) {\n    var markers = null;\n    doc.iter(from.line, to.line + 1, function (line) {\n      if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {\n        var mark = line.markedSpans[i].marker;\n        if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))\n          { (markers || (markers = [])).push(mark); }\n      } }\n    });\n    if (!markers) { return null }\n    var parts = [{from: from, to: to}];\n    for (var i = 0; i < markers.length; ++i) {\n      var mk = markers[i], m = mk.find(0);\n      for (var j = 0; j < parts.length; ++j) {\n        var p = parts[j];\n        if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) { continue }\n        var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);\n        if (dfrom < 0 || !mk.inclusiveLeft && !dfrom)\n          { newParts.push({from: p.from, to: m.from}); }\n        if (dto > 0 || !mk.inclusiveRight && !dto)\n          { newParts.push({from: m.to, to: p.to}); }\n        parts.splice.apply(parts, newParts);\n        j += newParts.length - 3;\n      }\n    }\n    return parts\n  }\n\n  // Connect or disconnect spans from a line.\n  function detachMarkedSpans(line) {\n    var spans = line.markedSpans;\n    if (!spans) { return }\n    for (var i = 0; i < spans.length; ++i)\n      { spans[i].marker.detachLine(line); }\n    line.markedSpans = null;\n  }\n  function attachMarkedSpans(line, spans) {\n    if (!spans) { return }\n    for (var i = 0; i < spans.length; ++i)\n      { spans[i].marker.attachLine(line); }\n    line.markedSpans = spans;\n  }\n\n  // Helpers used when computing which overlapping collapsed span\n  // counts as the larger one.\n  function extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0 }\n  function extraRight(marker) { return marker.inclusiveRight ? 1 : 0 }\n\n  // Returns a number indicating which of two overlapping collapsed\n  // spans is larger (and thus includes the other). Falls back to\n  // comparing ids when the spans cover exactly the same range.\n  function compareCollapsedMarkers(a, b) {\n    var lenDiff = a.lines.length - b.lines.length;\n    if (lenDiff != 0) { return lenDiff }\n    var aPos = a.find(), bPos = b.find();\n    var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);\n    if (fromCmp) { return -fromCmp }\n    var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);\n    if (toCmp) { return toCmp }\n    return b.id - a.id\n  }\n\n  // Find out whether a line ends or starts in a collapsed span. If\n  // so, return the marker for that span.\n  function collapsedSpanAtSide(line, start) {\n    var sps = sawCollapsedSpans && line.markedSpans, found;\n    if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {\n      sp = sps[i];\n      if (sp.marker.collapsed && (start ? sp.from : sp.to) == null &&\n          (!found || compareCollapsedMarkers(found, sp.marker) < 0))\n        { found = sp.marker; }\n    } }\n    return found\n  }\n  function collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true) }\n  function collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false) }\n\n  function collapsedSpanAround(line, ch) {\n    var sps = sawCollapsedSpans && line.markedSpans, found;\n    if (sps) { for (var i = 0; i < sps.length; ++i) {\n      var sp = sps[i];\n      if (sp.marker.collapsed && (sp.from == null || sp.from < ch) && (sp.to == null || sp.to > ch) &&\n          (!found || compareCollapsedMarkers(found, sp.marker) < 0)) { found = sp.marker; }\n    } }\n    return found\n  }\n\n  // Test whether there exists a collapsed span that partially\n  // overlaps (covers the start or end, but not both) of a new span.\n  // Such overlap is not allowed.\n  function conflictingCollapsedRange(doc, lineNo, from, to, marker) {\n    var line = getLine(doc, lineNo);\n    var sps = sawCollapsedSpans && line.markedSpans;\n    if (sps) { for (var i = 0; i < sps.length; ++i) {\n      var sp = sps[i];\n      if (!sp.marker.collapsed) { continue }\n      var found = sp.marker.find(0);\n      var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);\n      var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);\n      if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) { continue }\n      if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) ||\n          fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0))\n        { return true }\n    } }\n  }\n\n  // A visual line is a line as drawn on the screen. Folding, for\n  // example, can cause multiple logical lines to appear on the same\n  // visual line. This finds the start of the visual line that the\n  // given line is part of (usually that is the line itself).\n  function visualLine(line) {\n    var merged;\n    while (merged = collapsedSpanAtStart(line))\n      { line = merged.find(-1, true).line; }\n    return line\n  }\n\n  function visualLineEnd(line) {\n    var merged;\n    while (merged = collapsedSpanAtEnd(line))\n      { line = merged.find(1, true).line; }\n    return line\n  }\n\n  // Returns an array of logical lines that continue the visual line\n  // started by the argument, or undefined if there are no such lines.\n  function visualLineContinued(line) {\n    var merged, lines;\n    while (merged = collapsedSpanAtEnd(line)) {\n      line = merged.find(1, true).line\n      ;(lines || (lines = [])).push(line);\n    }\n    return lines\n  }\n\n  // Get the line number of the start of the visual line that the\n  // given line number is part of.\n  function visualLineNo(doc, lineN) {\n    var line = getLine(doc, lineN), vis = visualLine(line);\n    if (line == vis) { return lineN }\n    return lineNo(vis)\n  }\n\n  // Get the line number of the start of the next visual line after\n  // the given line.\n  function visualLineEndNo(doc, lineN) {\n    if (lineN > doc.lastLine()) { return lineN }\n    var line = getLine(doc, lineN), merged;\n    if (!lineIsHidden(doc, line)) { return lineN }\n    while (merged = collapsedSpanAtEnd(line))\n      { line = merged.find(1, true).line; }\n    return lineNo(line) + 1\n  }\n\n  // Compute whether a line is hidden. Lines count as hidden when they\n  // are part of a visual line that starts with another line, or when\n  // they are entirely covered by collapsed, non-widget span.\n  function lineIsHidden(doc, line) {\n    var sps = sawCollapsedSpans && line.markedSpans;\n    if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {\n      sp = sps[i];\n      if (!sp.marker.collapsed) { continue }\n      if (sp.from == null) { return true }\n      if (sp.marker.widgetNode) { continue }\n      if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))\n        { return true }\n    } }\n  }\n  function lineIsHiddenInner(doc, line, span) {\n    if (span.to == null) {\n      var end = span.marker.find(1, true);\n      return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker))\n    }\n    if (span.marker.inclusiveRight && span.to == line.text.length)\n      { return true }\n    for (var sp = (void 0), i = 0; i < line.markedSpans.length; ++i) {\n      sp = line.markedSpans[i];\n      if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to &&\n          (sp.to == null || sp.to != span.from) &&\n          (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&\n          lineIsHiddenInner(doc, line, sp)) { return true }\n    }\n  }\n\n  // Find the height above the given line.\n  function heightAtLine(lineObj) {\n    lineObj = visualLine(lineObj);\n\n    var h = 0, chunk = lineObj.parent;\n    for (var i = 0; i < chunk.lines.length; ++i) {\n      var line = chunk.lines[i];\n      if (line == lineObj) { break }\n      else { h += line.height; }\n    }\n    for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {\n      for (var i$1 = 0; i$1 < p.children.length; ++i$1) {\n        var cur = p.children[i$1];\n        if (cur == chunk) { break }\n        else { h += cur.height; }\n      }\n    }\n    return h\n  }\n\n  // Compute the character length of a line, taking into account\n  // collapsed ranges (see markText) that might hide parts, and join\n  // other lines onto it.\n  function lineLength(line) {\n    if (line.height == 0) { return 0 }\n    var len = line.text.length, merged, cur = line;\n    while (merged = collapsedSpanAtStart(cur)) {\n      var found = merged.find(0, true);\n      cur = found.from.line;\n      len += found.from.ch - found.to.ch;\n    }\n    cur = line;\n    while (merged = collapsedSpanAtEnd(cur)) {\n      var found$1 = merged.find(0, true);\n      len -= cur.text.length - found$1.from.ch;\n      cur = found$1.to.line;\n      len += cur.text.length - found$1.to.ch;\n    }\n    return len\n  }\n\n  // Find the longest line in the document.\n  function findMaxLine(cm) {\n    var d = cm.display, doc = cm.doc;\n    d.maxLine = getLine(doc, doc.first);\n    d.maxLineLength = lineLength(d.maxLine);\n    d.maxLineChanged = true;\n    doc.iter(function (line) {\n      var len = lineLength(line);\n      if (len > d.maxLineLength) {\n        d.maxLineLength = len;\n        d.maxLine = line;\n      }\n    });\n  }\n\n  // LINE DATA STRUCTURE\n\n  // Line objects. These hold state related to a line, including\n  // highlighting info (the styles array).\n  var Line = function(text, markedSpans, estimateHeight) {\n    this.text = text;\n    attachMarkedSpans(this, markedSpans);\n    this.height = estimateHeight ? estimateHeight(this) : 1;\n  };\n\n  Line.prototype.lineNo = function () { return lineNo(this) };\n  eventMixin(Line);\n\n  // Change the content (text, markers) of a line. Automatically\n  // invalidates cached information and tries to re-estimate the\n  // line's height.\n  function updateLine(line, text, markedSpans, estimateHeight) {\n    line.text = text;\n    if (line.stateAfter) { line.stateAfter = null; }\n    if (line.styles) { line.styles = null; }\n    if (line.order != null) { line.order = null; }\n    detachMarkedSpans(line);\n    attachMarkedSpans(line, markedSpans);\n    var estHeight = estimateHeight ? estimateHeight(line) : 1;\n    if (estHeight != line.height) { updateLineHeight(line, estHeight); }\n  }\n\n  // Detach a line from the document tree and its markers.\n  function cleanUpLine(line) {\n    line.parent = null;\n    detachMarkedSpans(line);\n  }\n\n  // Convert a style as returned by a mode (either null, or a string\n  // containing one or more styles) to a CSS style. This is cached,\n  // and also looks for line-wide styles.\n  var styleToClassCache = {}, styleToClassCacheWithMode = {};\n  function interpretTokenStyle(style, options) {\n    if (!style || /^\\s*$/.test(style)) { return null }\n    var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;\n    return cache[style] ||\n      (cache[style] = style.replace(/\\S+/g, \"cm-$&\"))\n  }\n\n  // Render the DOM representation of the text of a line. Also builds\n  // up a 'line map', which points at the DOM nodes that represent\n  // specific stretches of text, and is used by the measuring code.\n  // The returned object contains the DOM node, this map, and\n  // information about line-wide styles that were set by the mode.\n  function buildLineContent(cm, lineView) {\n    // The padding-right forces the element to have a 'border', which\n    // is needed on Webkit to be able to get line-level bounding\n    // rectangles for it (in measureChar).\n    var content = eltP(\"span\", null, null, webkit ? \"padding-right: .1px\" : null);\n    var builder = {pre: eltP(\"pre\", [content], \"CodeMirror-line\"), content: content,\n                   col: 0, pos: 0, cm: cm,\n                   trailingSpace: false,\n                   splitSpaces: cm.getOption(\"lineWrapping\")};\n    lineView.measure = {};\n\n    // Iterate over the logical lines that make up this visual line.\n    for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {\n      var line = i ? lineView.rest[i - 1] : lineView.line, order = (void 0);\n      builder.pos = 0;\n      builder.addToken = buildToken;\n      // Optionally wire in some hacks into the token-rendering\n      // algorithm, to deal with browser quirks.\n      if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line, cm.doc.direction)))\n        { builder.addToken = buildTokenBadBidi(builder.addToken, order); }\n      builder.map = [];\n      var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);\n      insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));\n      if (line.styleClasses) {\n        if (line.styleClasses.bgClass)\n          { builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || \"\"); }\n        if (line.styleClasses.textClass)\n          { builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || \"\"); }\n      }\n\n      // Ensure at least a single node is present, for measuring.\n      if (builder.map.length == 0)\n        { builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure))); }\n\n      // Store the map and a cache object for the current logical line\n      if (i == 0) {\n        lineView.measure.map = builder.map;\n        lineView.measure.cache = {};\n      } else {\n  (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map)\n        ;(lineView.measure.caches || (lineView.measure.caches = [])).push({});\n      }\n    }\n\n    // See issue #2901\n    if (webkit) {\n      var last = builder.content.lastChild;\n      if (/\\bcm-tab\\b/.test(last.className) || (last.querySelector && last.querySelector(\".cm-tab\")))\n        { builder.content.className = \"cm-tab-wrap-hack\"; }\n    }\n\n    signal(cm, \"renderLine\", cm, lineView.line, builder.pre);\n    if (builder.pre.className)\n      { builder.textClass = joinClasses(builder.pre.className, builder.textClass || \"\"); }\n\n    return builder\n  }\n\n  function defaultSpecialCharPlaceholder(ch) {\n    var token = elt(\"span\", \"\\u2022\", \"cm-invalidchar\");\n    token.title = \"\\\\u\" + ch.charCodeAt(0).toString(16);\n    token.setAttribute(\"aria-label\", token.title);\n    return token\n  }\n\n  // Build up the DOM representation for a single token, and add it to\n  // the line map. Takes care to render special characters separately.\n  function buildToken(builder, text, style, startStyle, endStyle, css, attributes) {\n    if (!text) { return }\n    var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text;\n    var special = builder.cm.state.specialChars, mustWrap = false;\n    var content;\n    if (!special.test(text)) {\n      builder.col += text.length;\n      content = document.createTextNode(displayText);\n      builder.map.push(builder.pos, builder.pos + text.length, content);\n      if (ie && ie_version < 9) { mustWrap = true; }\n      builder.pos += text.length;\n    } else {\n      content = document.createDocumentFragment();\n      var pos = 0;\n      while (true) {\n        special.lastIndex = pos;\n        var m = special.exec(text);\n        var skipped = m ? m.index - pos : text.length - pos;\n        if (skipped) {\n          var txt = document.createTextNode(displayText.slice(pos, pos + skipped));\n          if (ie && ie_version < 9) { content.appendChild(elt(\"span\", [txt])); }\n          else { content.appendChild(txt); }\n          builder.map.push(builder.pos, builder.pos + skipped, txt);\n          builder.col += skipped;\n          builder.pos += skipped;\n        }\n        if (!m) { break }\n        pos += skipped + 1;\n        var txt$1 = (void 0);\n        if (m[0] == \"\\t\") {\n          var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;\n          txt$1 = content.appendChild(elt(\"span\", spaceStr(tabWidth), \"cm-tab\"));\n          txt$1.setAttribute(\"role\", \"presentation\");\n          txt$1.setAttribute(\"cm-text\", \"\\t\");\n          builder.col += tabWidth;\n        } else if (m[0] == \"\\r\" || m[0] == \"\\n\") {\n          txt$1 = content.appendChild(elt(\"span\", m[0] == \"\\r\" ? \"\\u240d\" : \"\\u2424\", \"cm-invalidchar\"));\n          txt$1.setAttribute(\"cm-text\", m[0]);\n          builder.col += 1;\n        } else {\n          txt$1 = builder.cm.options.specialCharPlaceholder(m[0]);\n          txt$1.setAttribute(\"cm-text\", m[0]);\n          if (ie && ie_version < 9) { content.appendChild(elt(\"span\", [txt$1])); }\n          else { content.appendChild(txt$1); }\n          builder.col += 1;\n        }\n        builder.map.push(builder.pos, builder.pos + 1, txt$1);\n        builder.pos++;\n      }\n    }\n    builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32;\n    if (style || startStyle || endStyle || mustWrap || css || attributes) {\n      var fullStyle = style || \"\";\n      if (startStyle) { fullStyle += startStyle; }\n      if (endStyle) { fullStyle += endStyle; }\n      var token = elt(\"span\", [content], fullStyle, css);\n      if (attributes) {\n        for (var attr in attributes) { if (attributes.hasOwnProperty(attr) && attr != \"style\" && attr != \"class\")\n          { token.setAttribute(attr, attributes[attr]); } }\n      }\n      return builder.content.appendChild(token)\n    }\n    builder.content.appendChild(content);\n  }\n\n  // Change some spaces to NBSP to prevent the browser from collapsing\n  // trailing spaces at the end of a line when rendering text (issue #1362).\n  function splitSpaces(text, trailingBefore) {\n    if (text.length > 1 && !/  /.test(text)) { return text }\n    var spaceBefore = trailingBefore, result = \"\";\n    for (var i = 0; i < text.length; i++) {\n      var ch = text.charAt(i);\n      if (ch == \" \" && spaceBefore && (i == text.length - 1 || text.charCodeAt(i + 1) == 32))\n        { ch = \"\\u00a0\"; }\n      result += ch;\n      spaceBefore = ch == \" \";\n    }\n    return result\n  }\n\n  // Work around nonsense dimensions being reported for stretches of\n  // right-to-left text.\n  function buildTokenBadBidi(inner, order) {\n    return function (builder, text, style, startStyle, endStyle, css, attributes) {\n      style = style ? style + \" cm-force-border\" : \"cm-force-border\";\n      var start = builder.pos, end = start + text.length;\n      for (;;) {\n        // Find the part that overlaps with the start of this text\n        var part = (void 0);\n        for (var i = 0; i < order.length; i++) {\n          part = order[i];\n          if (part.to > start && part.from <= start) { break }\n        }\n        if (part.to >= end) { return inner(builder, text, style, startStyle, endStyle, css, attributes) }\n        inner(builder, text.slice(0, part.to - start), style, startStyle, null, css, attributes);\n        startStyle = null;\n        text = text.slice(part.to - start);\n        start = part.to;\n      }\n    }\n  }\n\n  function buildCollapsedSpan(builder, size, marker, ignoreWidget) {\n    var widget = !ignoreWidget && marker.widgetNode;\n    if (widget) { builder.map.push(builder.pos, builder.pos + size, widget); }\n    if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {\n      if (!widget)\n        { widget = builder.content.appendChild(document.createElement(\"span\")); }\n      widget.setAttribute(\"cm-marker\", marker.id);\n    }\n    if (widget) {\n      builder.cm.display.input.setUneditable(widget);\n      builder.content.appendChild(widget);\n    }\n    builder.pos += size;\n    builder.trailingSpace = false;\n  }\n\n  // Outputs a number of spans to make up a line, taking highlighting\n  // and marked text into account.\n  function insertLineContent(line, builder, styles) {\n    var spans = line.markedSpans, allText = line.text, at = 0;\n    if (!spans) {\n      for (var i$1 = 1; i$1 < styles.length; i$1+=2)\n        { builder.addToken(builder, allText.slice(at, at = styles[i$1]), interpretTokenStyle(styles[i$1+1], builder.cm.options)); }\n      return\n    }\n\n    var len = allText.length, pos = 0, i = 1, text = \"\", style, css;\n    var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, collapsed, attributes;\n    for (;;) {\n      if (nextChange == pos) { // Update current marker set\n        spanStyle = spanEndStyle = spanStartStyle = css = \"\";\n        attributes = null;\n        collapsed = null; nextChange = Infinity;\n        var foundBookmarks = [], endStyles = (void 0);\n        for (var j = 0; j < spans.length; ++j) {\n          var sp = spans[j], m = sp.marker;\n          if (m.type == \"bookmark\" && sp.from == pos && m.widgetNode) {\n            foundBookmarks.push(m);\n          } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {\n            if (sp.to != null && sp.to != pos && nextChange > sp.to) {\n              nextChange = sp.to;\n              spanEndStyle = \"\";\n            }\n            if (m.className) { spanStyle += \" \" + m.className; }\n            if (m.css) { css = (css ? css + \";\" : \"\") + m.css; }\n            if (m.startStyle && sp.from == pos) { spanStartStyle += \" \" + m.startStyle; }\n            if (m.endStyle && sp.to == nextChange) { (endStyles || (endStyles = [])).push(m.endStyle, sp.to); }\n            // support for the old title property\n            // https://github.com/codemirror/CodeMirror/pull/5673\n            if (m.title) { (attributes || (attributes = {})).title = m.title; }\n            if (m.attributes) {\n              for (var attr in m.attributes)\n                { (attributes || (attributes = {}))[attr] = m.attributes[attr]; }\n            }\n            if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))\n              { collapsed = sp; }\n          } else if (sp.from > pos && nextChange > sp.from) {\n            nextChange = sp.from;\n          }\n        }\n        if (endStyles) { for (var j$1 = 0; j$1 < endStyles.length; j$1 += 2)\n          { if (endStyles[j$1 + 1] == nextChange) { spanEndStyle += \" \" + endStyles[j$1]; } } }\n\n        if (!collapsed || collapsed.from == pos) { for (var j$2 = 0; j$2 < foundBookmarks.length; ++j$2)\n          { buildCollapsedSpan(builder, 0, foundBookmarks[j$2]); } }\n        if (collapsed && (collapsed.from || 0) == pos) {\n          buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos,\n                             collapsed.marker, collapsed.from == null);\n          if (collapsed.to == null) { return }\n          if (collapsed.to == pos) { collapsed = false; }\n        }\n      }\n      if (pos >= len) { break }\n\n      var upto = Math.min(len, nextChange);\n      while (true) {\n        if (text) {\n          var end = pos + text.length;\n          if (!collapsed) {\n            var tokenText = end > upto ? text.slice(0, upto - pos) : text;\n            builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,\n                             spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : \"\", css, attributes);\n          }\n          if (end >= upto) {text = text.slice(upto - pos); pos = upto; break}\n          pos = end;\n          spanStartStyle = \"\";\n        }\n        text = allText.slice(at, at = styles[i++]);\n        style = interpretTokenStyle(styles[i++], builder.cm.options);\n      }\n    }\n  }\n\n\n  // These objects are used to represent the visible (currently drawn)\n  // part of the document. A LineView may correspond to multiple\n  // logical lines, if those are connected by collapsed ranges.\n  function LineView(doc, line, lineN) {\n    // The starting line\n    this.line = line;\n    // Continuing lines, if any\n    this.rest = visualLineContinued(line);\n    // Number of logical lines in this visual line\n    this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;\n    this.node = this.text = null;\n    this.hidden = lineIsHidden(doc, line);\n  }\n\n  // Create a range of LineView objects for the given lines.\n  function buildViewArray(cm, from, to) {\n    var array = [], nextPos;\n    for (var pos = from; pos < to; pos = nextPos) {\n      var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);\n      nextPos = pos + view.size;\n      array.push(view);\n    }\n    return array\n  }\n\n  var operationGroup = null;\n\n  function pushOperation(op) {\n    if (operationGroup) {\n      operationGroup.ops.push(op);\n    } else {\n      op.ownsGroup = operationGroup = {\n        ops: [op],\n        delayedCallbacks: []\n      };\n    }\n  }\n\n  function fireCallbacksForOps(group) {\n    // Calls delayed callbacks and cursorActivity handlers until no\n    // new ones appear\n    var callbacks = group.delayedCallbacks, i = 0;\n    do {\n      for (; i < callbacks.length; i++)\n        { callbacks[i].call(null); }\n      for (var j = 0; j < group.ops.length; j++) {\n        var op = group.ops[j];\n        if (op.cursorActivityHandlers)\n          { while (op.cursorActivityCalled < op.cursorActivityHandlers.length)\n            { op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm); } }\n      }\n    } while (i < callbacks.length)\n  }\n\n  function finishOperation(op, endCb) {\n    var group = op.ownsGroup;\n    if (!group) { return }\n\n    try { fireCallbacksForOps(group); }\n    finally {\n      operationGroup = null;\n      endCb(group);\n    }\n  }\n\n  var orphanDelayedCallbacks = null;\n\n  // Often, we want to signal events at a point where we are in the\n  // middle of some work, but don't want the handler to start calling\n  // other methods on the editor, which might be in an inconsistent\n  // state or simply not expect any other events to happen.\n  // signalLater looks whether there are any handlers, and schedules\n  // them to be executed when the last operation ends, or, if no\n  // operation is active, when a timeout fires.\n  function signalLater(emitter, type /*, values...*/) {\n    var arr = getHandlers(emitter, type);\n    if (!arr.length) { return }\n    var args = Array.prototype.slice.call(arguments, 2), list;\n    if (operationGroup) {\n      list = operationGroup.delayedCallbacks;\n    } else if (orphanDelayedCallbacks) {\n      list = orphanDelayedCallbacks;\n    } else {\n      list = orphanDelayedCallbacks = [];\n      setTimeout(fireOrphanDelayed, 0);\n    }\n    var loop = function ( i ) {\n      list.push(function () { return arr[i].apply(null, args); });\n    };\n\n    for (var i = 0; i < arr.length; ++i)\n      loop( i );\n  }\n\n  function fireOrphanDelayed() {\n    var delayed = orphanDelayedCallbacks;\n    orphanDelayedCallbacks = null;\n    for (var i = 0; i < delayed.length; ++i) { delayed[i](); }\n  }\n\n  // When an aspect of a line changes, a string is added to\n  // lineView.changes. This updates the relevant part of the line's\n  // DOM structure.\n  function updateLineForChanges(cm, lineView, lineN, dims) {\n    for (var j = 0; j < lineView.changes.length; j++) {\n      var type = lineView.changes[j];\n      if (type == \"text\") { updateLineText(cm, lineView); }\n      else if (type == \"gutter\") { updateLineGutter(cm, lineView, lineN, dims); }\n      else if (type == \"class\") { updateLineClasses(cm, lineView); }\n      else if (type == \"widget\") { updateLineWidgets(cm, lineView, dims); }\n    }\n    lineView.changes = null;\n  }\n\n  // Lines with gutter elements, widgets or a background class need to\n  // be wrapped, and have the extra elements added to the wrapper div\n  function ensureLineWrapped(lineView) {\n    if (lineView.node == lineView.text) {\n      lineView.node = elt(\"div\", null, null, \"position: relative\");\n      if (lineView.text.parentNode)\n        { lineView.text.parentNode.replaceChild(lineView.node, lineView.text); }\n      lineView.node.appendChild(lineView.text);\n      if (ie && ie_version < 8) { lineView.node.style.zIndex = 2; }\n    }\n    return lineView.node\n  }\n\n  function updateLineBackground(cm, lineView) {\n    var cls = lineView.bgClass ? lineView.bgClass + \" \" + (lineView.line.bgClass || \"\") : lineView.line.bgClass;\n    if (cls) { cls += \" CodeMirror-linebackground\"; }\n    if (lineView.background) {\n      if (cls) { lineView.background.className = cls; }\n      else { lineView.background.parentNode.removeChild(lineView.background); lineView.background = null; }\n    } else if (cls) {\n      var wrap = ensureLineWrapped(lineView);\n      lineView.background = wrap.insertBefore(elt(\"div\", null, cls), wrap.firstChild);\n      cm.display.input.setUneditable(lineView.background);\n    }\n  }\n\n  // Wrapper around buildLineContent which will reuse the structure\n  // in display.externalMeasured when possible.\n  function getLineContent(cm, lineView) {\n    var ext = cm.display.externalMeasured;\n    if (ext && ext.line == lineView.line) {\n      cm.display.externalMeasured = null;\n      lineView.measure = ext.measure;\n      return ext.built\n    }\n    return buildLineContent(cm, lineView)\n  }\n\n  // Redraw the line's text. Interacts with the background and text\n  // classes because the mode may output tokens that influence these\n  // classes.\n  function updateLineText(cm, lineView) {\n    var cls = lineView.text.className;\n    var built = getLineContent(cm, lineView);\n    if (lineView.text == lineView.node) { lineView.node = built.pre; }\n    lineView.text.parentNode.replaceChild(built.pre, lineView.text);\n    lineView.text = built.pre;\n    if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {\n      lineView.bgClass = built.bgClass;\n      lineView.textClass = built.textClass;\n      updateLineClasses(cm, lineView);\n    } else if (cls) {\n      lineView.text.className = cls;\n    }\n  }\n\n  function updateLineClasses(cm, lineView) {\n    updateLineBackground(cm, lineView);\n    if (lineView.line.wrapClass)\n      { ensureLineWrapped(lineView).className = lineView.line.wrapClass; }\n    else if (lineView.node != lineView.text)\n      { lineView.node.className = \"\"; }\n    var textClass = lineView.textClass ? lineView.textClass + \" \" + (lineView.line.textClass || \"\") : lineView.line.textClass;\n    lineView.text.className = textClass || \"\";\n  }\n\n  function updateLineGutter(cm, lineView, lineN, dims) {\n    if (lineView.gutter) {\n      lineView.node.removeChild(lineView.gutter);\n      lineView.gutter = null;\n    }\n    if (lineView.gutterBackground) {\n      lineView.node.removeChild(lineView.gutterBackground);\n      lineView.gutterBackground = null;\n    }\n    if (lineView.line.gutterClass) {\n      var wrap = ensureLineWrapped(lineView);\n      lineView.gutterBackground = elt(\"div\", null, \"CodeMirror-gutter-background \" + lineView.line.gutterClass,\n                                      (\"left: \" + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + \"px; width: \" + (dims.gutterTotalWidth) + \"px\"));\n      cm.display.input.setUneditable(lineView.gutterBackground);\n      wrap.insertBefore(lineView.gutterBackground, lineView.text);\n    }\n    var markers = lineView.line.gutterMarkers;\n    if (cm.options.lineNumbers || markers) {\n      var wrap$1 = ensureLineWrapped(lineView);\n      var gutterWrap = lineView.gutter = elt(\"div\", null, \"CodeMirror-gutter-wrapper\", (\"left: \" + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + \"px\"));\n      cm.display.input.setUneditable(gutterWrap);\n      wrap$1.insertBefore(gutterWrap, lineView.text);\n      if (lineView.line.gutterClass)\n        { gutterWrap.className += \" \" + lineView.line.gutterClass; }\n      if (cm.options.lineNumbers && (!markers || !markers[\"CodeMirror-linenumbers\"]))\n        { lineView.lineNumber = gutterWrap.appendChild(\n          elt(\"div\", lineNumberFor(cm.options, lineN),\n              \"CodeMirror-linenumber CodeMirror-gutter-elt\",\n              (\"left: \" + (dims.gutterLeft[\"CodeMirror-linenumbers\"]) + \"px; width: \" + (cm.display.lineNumInnerWidth) + \"px\"))); }\n      if (markers) { for (var k = 0; k < cm.display.gutterSpecs.length; ++k) {\n        var id = cm.display.gutterSpecs[k].className, found = markers.hasOwnProperty(id) && markers[id];\n        if (found)\n          { gutterWrap.appendChild(elt(\"div\", [found], \"CodeMirror-gutter-elt\",\n                                     (\"left: \" + (dims.gutterLeft[id]) + \"px; width: \" + (dims.gutterWidth[id]) + \"px\"))); }\n      } }\n    }\n  }\n\n  function updateLineWidgets(cm, lineView, dims) {\n    if (lineView.alignable) { lineView.alignable = null; }\n    var isWidget = classTest(\"CodeMirror-linewidget\");\n    for (var node = lineView.node.firstChild, next = (void 0); node; node = next) {\n      next = node.nextSibling;\n      if (isWidget.test(node.className)) { lineView.node.removeChild(node); }\n    }\n    insertLineWidgets(cm, lineView, dims);\n  }\n\n  // Build a line's DOM representation from scratch\n  function buildLineElement(cm, lineView, lineN, dims) {\n    var built = getLineContent(cm, lineView);\n    lineView.text = lineView.node = built.pre;\n    if (built.bgClass) { lineView.bgClass = built.bgClass; }\n    if (built.textClass) { lineView.textClass = built.textClass; }\n\n    updateLineClasses(cm, lineView);\n    updateLineGutter(cm, lineView, lineN, dims);\n    insertLineWidgets(cm, lineView, dims);\n    return lineView.node\n  }\n\n  // A lineView may contain multiple logical lines (when merged by\n  // collapsed spans). The widgets for all of them need to be drawn.\n  function insertLineWidgets(cm, lineView, dims) {\n    insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);\n    if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)\n      { insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false); } }\n  }\n\n  function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {\n    if (!line.widgets) { return }\n    var wrap = ensureLineWrapped(lineView);\n    for (var i = 0, ws = line.widgets; i < ws.length; ++i) {\n      var widget = ws[i], node = elt(\"div\", [widget.node], \"CodeMirror-linewidget\" + (widget.className ? \" \" + widget.className : \"\"));\n      if (!widget.handleMouseEvents) { node.setAttribute(\"cm-ignore-events\", \"true\"); }\n      positionLineWidget(widget, node, lineView, dims);\n      cm.display.input.setUneditable(node);\n      if (allowAbove && widget.above)\n        { wrap.insertBefore(node, lineView.gutter || lineView.text); }\n      else\n        { wrap.appendChild(node); }\n      signalLater(widget, \"redraw\");\n    }\n  }\n\n  function positionLineWidget(widget, node, lineView, dims) {\n    if (widget.noHScroll) {\n  (lineView.alignable || (lineView.alignable = [])).push(node);\n      var width = dims.wrapperWidth;\n      node.style.left = dims.fixedPos + \"px\";\n      if (!widget.coverGutter) {\n        width -= dims.gutterTotalWidth;\n        node.style.paddingLeft = dims.gutterTotalWidth + \"px\";\n      }\n      node.style.width = width + \"px\";\n    }\n    if (widget.coverGutter) {\n      node.style.zIndex = 5;\n      node.style.position = \"relative\";\n      if (!widget.noHScroll) { node.style.marginLeft = -dims.gutterTotalWidth + \"px\"; }\n    }\n  }\n\n  function widgetHeight(widget) {\n    if (widget.height != null) { return widget.height }\n    var cm = widget.doc.cm;\n    if (!cm) { return 0 }\n    if (!contains(document.body, widget.node)) {\n      var parentStyle = \"position: relative;\";\n      if (widget.coverGutter)\n        { parentStyle += \"margin-left: -\" + cm.display.gutters.offsetWidth + \"px;\"; }\n      if (widget.noHScroll)\n        { parentStyle += \"width: \" + cm.display.wrapper.clientWidth + \"px;\"; }\n      removeChildrenAndAdd(cm.display.measure, elt(\"div\", [widget.node], null, parentStyle));\n    }\n    return widget.height = widget.node.parentNode.offsetHeight\n  }\n\n  // Return true when the given mouse event happened in a widget\n  function eventInWidget(display, e) {\n    for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {\n      if (!n || (n.nodeType == 1 && n.getAttribute(\"cm-ignore-events\") == \"true\") ||\n          (n.parentNode == display.sizer && n != display.mover))\n        { return true }\n    }\n  }\n\n  // POSITION MEASUREMENT\n\n  function paddingTop(display) {return display.lineSpace.offsetTop}\n  function paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight}\n  function paddingH(display) {\n    if (display.cachedPaddingH) { return display.cachedPaddingH }\n    var e = removeChildrenAndAdd(display.measure, elt(\"pre\", \"x\", \"CodeMirror-line-like\"));\n    var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;\n    var data = {left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight)};\n    if (!isNaN(data.left) && !isNaN(data.right)) { display.cachedPaddingH = data; }\n    return data\n  }\n\n  function scrollGap(cm) { return scrollerGap - cm.display.nativeBarWidth }\n  function displayWidth(cm) {\n    return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth\n  }\n  function displayHeight(cm) {\n    return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight\n  }\n\n  // Ensure the lineView.wrapping.heights array is populated. This is\n  // an array of bottom offsets for the lines that make up a drawn\n  // line. When lineWrapping is on, there might be more than one\n  // height.\n  function ensureLineHeights(cm, lineView, rect) {\n    var wrapping = cm.options.lineWrapping;\n    var curWidth = wrapping && displayWidth(cm);\n    if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {\n      var heights = lineView.measure.heights = [];\n      if (wrapping) {\n        lineView.measure.width = curWidth;\n        var rects = lineView.text.firstChild.getClientRects();\n        for (var i = 0; i < rects.length - 1; i++) {\n          var cur = rects[i], next = rects[i + 1];\n          if (Math.abs(cur.bottom - next.bottom) > 2)\n            { heights.push((cur.bottom + next.top) / 2 - rect.top); }\n        }\n      }\n      heights.push(rect.bottom - rect.top);\n    }\n  }\n\n  // Find a line map (mapping character offsets to text nodes) and a\n  // measurement cache for the given line number. (A line view might\n  // contain multiple lines when collapsed ranges are present.)\n  function mapFromLineView(lineView, line, lineN) {\n    if (lineView.line == line)\n      { return {map: lineView.measure.map, cache: lineView.measure.cache} }\n    for (var i = 0; i < lineView.rest.length; i++)\n      { if (lineView.rest[i] == line)\n        { return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i]} } }\n    for (var i$1 = 0; i$1 < lineView.rest.length; i$1++)\n      { if (lineNo(lineView.rest[i$1]) > lineN)\n        { return {map: lineView.measure.maps[i$1], cache: lineView.measure.caches[i$1], before: true} } }\n  }\n\n  // Render a line into the hidden node display.externalMeasured. Used\n  // when measurement is needed for a line that's not in the viewport.\n  function updateExternalMeasurement(cm, line) {\n    line = visualLine(line);\n    var lineN = lineNo(line);\n    var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);\n    view.lineN = lineN;\n    var built = view.built = buildLineContent(cm, view);\n    view.text = built.pre;\n    removeChildrenAndAdd(cm.display.lineMeasure, built.pre);\n    return view\n  }\n\n  // Get a {top, bottom, left, right} box (in line-local coordinates)\n  // for a given character.\n  function measureChar(cm, line, ch, bias) {\n    return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias)\n  }\n\n  // Find a line view that corresponds to the given line number.\n  function findViewForLine(cm, lineN) {\n    if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)\n      { return cm.display.view[findViewIndex(cm, lineN)] }\n    var ext = cm.display.externalMeasured;\n    if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size)\n      { return ext }\n  }\n\n  // Measurement can be split in two steps, the set-up work that\n  // applies to the whole line, and the measurement of the actual\n  // character. Functions like coordsChar, that need to do a lot of\n  // measurements in a row, can thus ensure that the set-up work is\n  // only done once.\n  function prepareMeasureForLine(cm, line) {\n    var lineN = lineNo(line);\n    var view = findViewForLine(cm, lineN);\n    if (view && !view.text) {\n      view = null;\n    } else if (view && view.changes) {\n      updateLineForChanges(cm, view, lineN, getDimensions(cm));\n      cm.curOp.forceUpdate = true;\n    }\n    if (!view)\n      { view = updateExternalMeasurement(cm, line); }\n\n    var info = mapFromLineView(view, line, lineN);\n    return {\n      line: line, view: view, rect: null,\n      map: info.map, cache: info.cache, before: info.before,\n      hasHeights: false\n    }\n  }\n\n  // Given a prepared measurement object, measures the position of an\n  // actual character (or fetches it from the cache).\n  function measureCharPrepared(cm, prepared, ch, bias, varHeight) {\n    if (prepared.before) { ch = -1; }\n    var key = ch + (bias || \"\"), found;\n    if (prepared.cache.hasOwnProperty(key)) {\n      found = prepared.cache[key];\n    } else {\n      if (!prepared.rect)\n        { prepared.rect = prepared.view.text.getBoundingClientRect(); }\n      if (!prepared.hasHeights) {\n        ensureLineHeights(cm, prepared.view, prepared.rect);\n        prepared.hasHeights = true;\n      }\n      found = measureCharInner(cm, prepared, ch, bias);\n      if (!found.bogus) { prepared.cache[key] = found; }\n    }\n    return {left: found.left, right: found.right,\n            top: varHeight ? found.rtop : found.top,\n            bottom: varHeight ? found.rbottom : found.bottom}\n  }\n\n  var nullRect = {left: 0, right: 0, top: 0, bottom: 0};\n\n  function nodeAndOffsetInLineMap(map, ch, bias) {\n    var node, start, end, collapse, mStart, mEnd;\n    // First, search the line map for the text node corresponding to,\n    // or closest to, the target character.\n    for (var i = 0; i < map.length; i += 3) {\n      mStart = map[i];\n      mEnd = map[i + 1];\n      if (ch < mStart) {\n        start = 0; end = 1;\n        collapse = \"left\";\n      } else if (ch < mEnd) {\n        start = ch - mStart;\n        end = start + 1;\n      } else if (i == map.length - 3 || ch == mEnd && map[i + 3] > ch) {\n        end = mEnd - mStart;\n        start = end - 1;\n        if (ch >= mEnd) { collapse = \"right\"; }\n      }\n      if (start != null) {\n        node = map[i + 2];\n        if (mStart == mEnd && bias == (node.insertLeft ? \"left\" : \"right\"))\n          { collapse = bias; }\n        if (bias == \"left\" && start == 0)\n          { while (i && map[i - 2] == map[i - 3] && map[i - 1].insertLeft) {\n            node = map[(i -= 3) + 2];\n            collapse = \"left\";\n          } }\n        if (bias == \"right\" && start == mEnd - mStart)\n          { while (i < map.length - 3 && map[i + 3] == map[i + 4] && !map[i + 5].insertLeft) {\n            node = map[(i += 3) + 2];\n            collapse = \"right\";\n          } }\n        break\n      }\n    }\n    return {node: node, start: start, end: end, collapse: collapse, coverStart: mStart, coverEnd: mEnd}\n  }\n\n  function getUsefulRect(rects, bias) {\n    var rect = nullRect;\n    if (bias == \"left\") { for (var i = 0; i < rects.length; i++) {\n      if ((rect = rects[i]).left != rect.right) { break }\n    } } else { for (var i$1 = rects.length - 1; i$1 >= 0; i$1--) {\n      if ((rect = rects[i$1]).left != rect.right) { break }\n    } }\n    return rect\n  }\n\n  function measureCharInner(cm, prepared, ch, bias) {\n    var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);\n    var node = place.node, start = place.start, end = place.end, collapse = place.collapse;\n\n    var rect;\n    if (node.nodeType == 3) { // If it is a text node, use a range to retrieve the coordinates.\n      for (var i$1 = 0; i$1 < 4; i$1++) { // Retry a maximum of 4 times when nonsense rectangles are returned\n        while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) { --start; }\n        while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) { ++end; }\n        if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart)\n          { rect = node.parentNode.getBoundingClientRect(); }\n        else\n          { rect = getUsefulRect(range(node, start, end).getClientRects(), bias); }\n        if (rect.left || rect.right || start == 0) { break }\n        end = start;\n        start = start - 1;\n        collapse = \"right\";\n      }\n      if (ie && ie_version < 11) { rect = maybeUpdateRectForZooming(cm.display.measure, rect); }\n    } else { // If it is a widget, simply get the box for the whole widget.\n      if (start > 0) { collapse = bias = \"right\"; }\n      var rects;\n      if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1)\n        { rect = rects[bias == \"right\" ? rects.length - 1 : 0]; }\n      else\n        { rect = node.getBoundingClientRect(); }\n    }\n    if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {\n      var rSpan = node.parentNode.getClientRects()[0];\n      if (rSpan)\n        { rect = {left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom}; }\n      else\n        { rect = nullRect; }\n    }\n\n    var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;\n    var mid = (rtop + rbot) / 2;\n    var heights = prepared.view.measure.heights;\n    var i = 0;\n    for (; i < heights.length - 1; i++)\n      { if (mid < heights[i]) { break } }\n    var top = i ? heights[i - 1] : 0, bot = heights[i];\n    var result = {left: (collapse == \"right\" ? rect.right : rect.left) - prepared.rect.left,\n                  right: (collapse == \"left\" ? rect.left : rect.right) - prepared.rect.left,\n                  top: top, bottom: bot};\n    if (!rect.left && !rect.right) { result.bogus = true; }\n    if (!cm.options.singleCursorHeightPerLine) { result.rtop = rtop; result.rbottom = rbot; }\n\n    return result\n  }\n\n  // Work around problem with bounding client rects on ranges being\n  // returned incorrectly when zoomed on IE10 and below.\n  function maybeUpdateRectForZooming(measure, rect) {\n    if (!window.screen || screen.logicalXDPI == null ||\n        screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))\n      { return rect }\n    var scaleX = screen.logicalXDPI / screen.deviceXDPI;\n    var scaleY = screen.logicalYDPI / screen.deviceYDPI;\n    return {left: rect.left * scaleX, right: rect.right * scaleX,\n            top: rect.top * scaleY, bottom: rect.bottom * scaleY}\n  }\n\n  function clearLineMeasurementCacheFor(lineView) {\n    if (lineView.measure) {\n      lineView.measure.cache = {};\n      lineView.measure.heights = null;\n      if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)\n        { lineView.measure.caches[i] = {}; } }\n    }\n  }\n\n  function clearLineMeasurementCache(cm) {\n    cm.display.externalMeasure = null;\n    removeChildren(cm.display.lineMeasure);\n    for (var i = 0; i < cm.display.view.length; i++)\n      { clearLineMeasurementCacheFor(cm.display.view[i]); }\n  }\n\n  function clearCaches(cm) {\n    clearLineMeasurementCache(cm);\n    cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;\n    if (!cm.options.lineWrapping) { cm.display.maxLineChanged = true; }\n    cm.display.lineNumChars = null;\n  }\n\n  function pageScrollX() {\n    // Work around https://bugs.chromium.org/p/chromium/issues/detail?id=489206\n    // which causes page_Offset and bounding client rects to use\n    // different reference viewports and invalidate our calculations.\n    if (chrome && android) { return -(document.body.getBoundingClientRect().left - parseInt(getComputedStyle(document.body).marginLeft)) }\n    return window.pageXOffset || (document.documentElement || document.body).scrollLeft\n  }\n  function pageScrollY() {\n    if (chrome && android) { return -(document.body.getBoundingClientRect().top - parseInt(getComputedStyle(document.body).marginTop)) }\n    return window.pageYOffset || (document.documentElement || document.body).scrollTop\n  }\n\n  function widgetTopHeight(lineObj) {\n    var height = 0;\n    if (lineObj.widgets) { for (var i = 0; i < lineObj.widgets.length; ++i) { if (lineObj.widgets[i].above)\n      { height += widgetHeight(lineObj.widgets[i]); } } }\n    return height\n  }\n\n  // Converts a {top, bottom, left, right} box from line-local\n  // coordinates into another coordinate system. Context may be one of\n  // \"line\", \"div\" (display.lineDiv), \"local\"./null (editor), \"window\",\n  // or \"page\".\n  function intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {\n    if (!includeWidgets) {\n      var height = widgetTopHeight(lineObj);\n      rect.top += height; rect.bottom += height;\n    }\n    if (context == \"line\") { return rect }\n    if (!context) { context = \"local\"; }\n    var yOff = heightAtLine(lineObj);\n    if (context == \"local\") { yOff += paddingTop(cm.display); }\n    else { yOff -= cm.display.viewOffset; }\n    if (context == \"page\" || context == \"window\") {\n      var lOff = cm.display.lineSpace.getBoundingClientRect();\n      yOff += lOff.top + (context == \"window\" ? 0 : pageScrollY());\n      var xOff = lOff.left + (context == \"window\" ? 0 : pageScrollX());\n      rect.left += xOff; rect.right += xOff;\n    }\n    rect.top += yOff; rect.bottom += yOff;\n    return rect\n  }\n\n  // Coverts a box from \"div\" coords to another coordinate system.\n  // Context may be \"window\", \"page\", \"div\", or \"local\"./null.\n  function fromCoordSystem(cm, coords, context) {\n    if (context == \"div\") { return coords }\n    var left = coords.left, top = coords.top;\n    // First move into \"page\" coordinate system\n    if (context == \"page\") {\n      left -= pageScrollX();\n      top -= pageScrollY();\n    } else if (context == \"local\" || !context) {\n      var localBox = cm.display.sizer.getBoundingClientRect();\n      left += localBox.left;\n      top += localBox.top;\n    }\n\n    var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();\n    return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top}\n  }\n\n  function charCoords(cm, pos, context, lineObj, bias) {\n    if (!lineObj) { lineObj = getLine(cm.doc, pos.line); }\n    return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context)\n  }\n\n  // Returns a box for a given cursor position, which may have an\n  // 'other' property containing the position of the secondary cursor\n  // on a bidi boundary.\n  // A cursor Pos(line, char, \"before\") is on the same visual line as `char - 1`\n  // and after `char - 1` in writing order of `char - 1`\n  // A cursor Pos(line, char, \"after\") is on the same visual line as `char`\n  // and before `char` in writing order of `char`\n  // Examples (upper-case letters are RTL, lower-case are LTR):\n  //     Pos(0, 1, ...)\n  //     before   after\n  // ab     a|b     a|b\n  // aB     a|B     aB|\n  // Ab     |Ab     A|b\n  // AB     B|A     B|A\n  // Every position after the last character on a line is considered to stick\n  // to the last character on the line.\n  function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {\n    lineObj = lineObj || getLine(cm.doc, pos.line);\n    if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj); }\n    function get(ch, right) {\n      var m = measureCharPrepared(cm, preparedMeasure, ch, right ? \"right\" : \"left\", varHeight);\n      if (right) { m.left = m.right; } else { m.right = m.left; }\n      return intoCoordSystem(cm, lineObj, m, context)\n    }\n    var order = getOrder(lineObj, cm.doc.direction), ch = pos.ch, sticky = pos.sticky;\n    if (ch >= lineObj.text.length) {\n      ch = lineObj.text.length;\n      sticky = \"before\";\n    } else if (ch <= 0) {\n      ch = 0;\n      sticky = \"after\";\n    }\n    if (!order) { return get(sticky == \"before\" ? ch - 1 : ch, sticky == \"before\") }\n\n    function getBidi(ch, partPos, invert) {\n      var part = order[partPos], right = part.level == 1;\n      return get(invert ? ch - 1 : ch, right != invert)\n    }\n    var partPos = getBidiPartAt(order, ch, sticky);\n    var other = bidiOther;\n    var val = getBidi(ch, partPos, sticky == \"before\");\n    if (other != null) { val.other = getBidi(ch, other, sticky != \"before\"); }\n    return val\n  }\n\n  // Used to cheaply estimate the coordinates for a position. Used for\n  // intermediate scroll updates.\n  function estimateCoords(cm, pos) {\n    var left = 0;\n    pos = clipPos(cm.doc, pos);\n    if (!cm.options.lineWrapping) { left = charWidth(cm.display) * pos.ch; }\n    var lineObj = getLine(cm.doc, pos.line);\n    var top = heightAtLine(lineObj) + paddingTop(cm.display);\n    return {left: left, right: left, top: top, bottom: top + lineObj.height}\n  }\n\n  // Positions returned by coordsChar contain some extra information.\n  // xRel is the relative x position of the input coordinates compared\n  // to the found position (so xRel > 0 means the coordinates are to\n  // the right of the character position, for example). When outside\n  // is true, that means the coordinates lie outside the line's\n  // vertical range.\n  function PosWithInfo(line, ch, sticky, outside, xRel) {\n    var pos = Pos(line, ch, sticky);\n    pos.xRel = xRel;\n    if (outside) { pos.outside = outside; }\n    return pos\n  }\n\n  // Compute the character position closest to the given coordinates.\n  // Input must be lineSpace-local (\"div\" coordinate system).\n  function coordsChar(cm, x, y) {\n    var doc = cm.doc;\n    y += cm.display.viewOffset;\n    if (y < 0) { return PosWithInfo(doc.first, 0, null, -1, -1) }\n    var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;\n    if (lineN > last)\n      { return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, null, 1, 1) }\n    if (x < 0) { x = 0; }\n\n    var lineObj = getLine(doc, lineN);\n    for (;;) {\n      var found = coordsCharInner(cm, lineObj, lineN, x, y);\n      var collapsed = collapsedSpanAround(lineObj, found.ch + (found.xRel > 0 || found.outside > 0 ? 1 : 0));\n      if (!collapsed) { return found }\n      var rangeEnd = collapsed.find(1);\n      if (rangeEnd.line == lineN) { return rangeEnd }\n      lineObj = getLine(doc, lineN = rangeEnd.line);\n    }\n  }\n\n  function wrappedLineExtent(cm, lineObj, preparedMeasure, y) {\n    y -= widgetTopHeight(lineObj);\n    var end = lineObj.text.length;\n    var begin = findFirst(function (ch) { return measureCharPrepared(cm, preparedMeasure, ch - 1).bottom <= y; }, end, 0);\n    end = findFirst(function (ch) { return measureCharPrepared(cm, preparedMeasure, ch).top > y; }, begin, end);\n    return {begin: begin, end: end}\n  }\n\n  function wrappedLineExtentChar(cm, lineObj, preparedMeasure, target) {\n    if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj); }\n    var targetTop = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, target), \"line\").top;\n    return wrappedLineExtent(cm, lineObj, preparedMeasure, targetTop)\n  }\n\n  // Returns true if the given side of a box is after the given\n  // coordinates, in top-to-bottom, left-to-right order.\n  function boxIsAfter(box, x, y, left) {\n    return box.bottom <= y ? false : box.top > y ? true : (left ? box.left : box.right) > x\n  }\n\n  function coordsCharInner(cm, lineObj, lineNo, x, y) {\n    // Move y into line-local coordinate space\n    y -= heightAtLine(lineObj);\n    var preparedMeasure = prepareMeasureForLine(cm, lineObj);\n    // When directly calling `measureCharPrepared`, we have to adjust\n    // for the widgets at this line.\n    var widgetHeight = widgetTopHeight(lineObj);\n    var begin = 0, end = lineObj.text.length, ltr = true;\n\n    var order = getOrder(lineObj, cm.doc.direction);\n    // If the line isn't plain left-to-right text, first figure out\n    // which bidi section the coordinates fall into.\n    if (order) {\n      var part = (cm.options.lineWrapping ? coordsBidiPartWrapped : coordsBidiPart)\n                   (cm, lineObj, lineNo, preparedMeasure, order, x, y);\n      ltr = part.level != 1;\n      // The awkward -1 offsets are needed because findFirst (called\n      // on these below) will treat its first bound as inclusive,\n      // second as exclusive, but we want to actually address the\n      // characters in the part's range\n      begin = ltr ? part.from : part.to - 1;\n      end = ltr ? part.to : part.from - 1;\n    }\n\n    // A binary search to find the first character whose bounding box\n    // starts after the coordinates. If we run across any whose box wrap\n    // the coordinates, store that.\n    var chAround = null, boxAround = null;\n    var ch = findFirst(function (ch) {\n      var box = measureCharPrepared(cm, preparedMeasure, ch);\n      box.top += widgetHeight; box.bottom += widgetHeight;\n      if (!boxIsAfter(box, x, y, false)) { return false }\n      if (box.top <= y && box.left <= x) {\n        chAround = ch;\n        boxAround = box;\n      }\n      return true\n    }, begin, end);\n\n    var baseX, sticky, outside = false;\n    // If a box around the coordinates was found, use that\n    if (boxAround) {\n      // Distinguish coordinates nearer to the left or right side of the box\n      var atLeft = x - boxAround.left < boxAround.right - x, atStart = atLeft == ltr;\n      ch = chAround + (atStart ? 0 : 1);\n      sticky = atStart ? \"after\" : \"before\";\n      baseX = atLeft ? boxAround.left : boxAround.right;\n    } else {\n      // (Adjust for extended bound, if necessary.)\n      if (!ltr && (ch == end || ch == begin)) { ch++; }\n      // To determine which side to associate with, get the box to the\n      // left of the character and compare it's vertical position to the\n      // coordinates\n      sticky = ch == 0 ? \"after\" : ch == lineObj.text.length ? \"before\" :\n        (measureCharPrepared(cm, preparedMeasure, ch - (ltr ? 1 : 0)).bottom + widgetHeight <= y) == ltr ?\n        \"after\" : \"before\";\n      // Now get accurate coordinates for this place, in order to get a\n      // base X position\n      var coords = cursorCoords(cm, Pos(lineNo, ch, sticky), \"line\", lineObj, preparedMeasure);\n      baseX = coords.left;\n      outside = y < coords.top ? -1 : y >= coords.bottom ? 1 : 0;\n    }\n\n    ch = skipExtendingChars(lineObj.text, ch, 1);\n    return PosWithInfo(lineNo, ch, sticky, outside, x - baseX)\n  }\n\n  function coordsBidiPart(cm, lineObj, lineNo, preparedMeasure, order, x, y) {\n    // Bidi parts are sorted left-to-right, and in a non-line-wrapping\n    // situation, we can take this ordering to correspond to the visual\n    // ordering. This finds the first part whose end is after the given\n    // coordinates.\n    var index = findFirst(function (i) {\n      var part = order[i], ltr = part.level != 1;\n      return boxIsAfter(cursorCoords(cm, Pos(lineNo, ltr ? part.to : part.from, ltr ? \"before\" : \"after\"),\n                                     \"line\", lineObj, preparedMeasure), x, y, true)\n    }, 0, order.length - 1);\n    var part = order[index];\n    // If this isn't the first part, the part's start is also after\n    // the coordinates, and the coordinates aren't on the same line as\n    // that start, move one part back.\n    if (index > 0) {\n      var ltr = part.level != 1;\n      var start = cursorCoords(cm, Pos(lineNo, ltr ? part.from : part.to, ltr ? \"after\" : \"before\"),\n                               \"line\", lineObj, preparedMeasure);\n      if (boxIsAfter(start, x, y, true) && start.top > y)\n        { part = order[index - 1]; }\n    }\n    return part\n  }\n\n  function coordsBidiPartWrapped(cm, lineObj, _lineNo, preparedMeasure, order, x, y) {\n    // In a wrapped line, rtl text on wrapping boundaries can do things\n    // that don't correspond to the ordering in our `order` array at\n    // all, so a binary search doesn't work, and we want to return a\n    // part that only spans one line so that the binary search in\n    // coordsCharInner is safe. As such, we first find the extent of the\n    // wrapped line, and then do a flat search in which we discard any\n    // spans that aren't on the line.\n    var ref = wrappedLineExtent(cm, lineObj, preparedMeasure, y);\n    var begin = ref.begin;\n    var end = ref.end;\n    if (/\\s/.test(lineObj.text.charAt(end - 1))) { end--; }\n    var part = null, closestDist = null;\n    for (var i = 0; i < order.length; i++) {\n      var p = order[i];\n      if (p.from >= end || p.to <= begin) { continue }\n      var ltr = p.level != 1;\n      var endX = measureCharPrepared(cm, preparedMeasure, ltr ? Math.min(end, p.to) - 1 : Math.max(begin, p.from)).right;\n      // Weigh against spans ending before this, so that they are only\n      // picked if nothing ends after\n      var dist = endX < x ? x - endX + 1e9 : endX - x;\n      if (!part || closestDist > dist) {\n        part = p;\n        closestDist = dist;\n      }\n    }\n    if (!part) { part = order[order.length - 1]; }\n    // Clip the part to the wrapped line.\n    if (part.from < begin) { part = {from: begin, to: part.to, level: part.level}; }\n    if (part.to > end) { part = {from: part.from, to: end, level: part.level}; }\n    return part\n  }\n\n  var measureText;\n  // Compute the default text height.\n  function textHeight(display) {\n    if (display.cachedTextHeight != null) { return display.cachedTextHeight }\n    if (measureText == null) {\n      measureText = elt(\"pre\", null, \"CodeMirror-line-like\");\n      // Measure a bunch of lines, for browsers that compute\n      // fractional heights.\n      for (var i = 0; i < 49; ++i) {\n        measureText.appendChild(document.createTextNode(\"x\"));\n        measureText.appendChild(elt(\"br\"));\n      }\n      measureText.appendChild(document.createTextNode(\"x\"));\n    }\n    removeChildrenAndAdd(display.measure, measureText);\n    var height = measureText.offsetHeight / 50;\n    if (height > 3) { display.cachedTextHeight = height; }\n    removeChildren(display.measure);\n    return height || 1\n  }\n\n  // Compute the default character width.\n  function charWidth(display) {\n    if (display.cachedCharWidth != null) { return display.cachedCharWidth }\n    var anchor = elt(\"span\", \"xxxxxxxxxx\");\n    var pre = elt(\"pre\", [anchor], \"CodeMirror-line-like\");\n    removeChildrenAndAdd(display.measure, pre);\n    var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;\n    if (width > 2) { display.cachedCharWidth = width; }\n    return width || 10\n  }\n\n  // Do a bulk-read of the DOM positions and sizes needed to draw the\n  // view, so that we don't interleave reading and writing to the DOM.\n  function getDimensions(cm) {\n    var d = cm.display, left = {}, width = {};\n    var gutterLeft = d.gutters.clientLeft;\n    for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {\n      var id = cm.display.gutterSpecs[i].className;\n      left[id] = n.offsetLeft + n.clientLeft + gutterLeft;\n      width[id] = n.clientWidth;\n    }\n    return {fixedPos: compensateForHScroll(d),\n            gutterTotalWidth: d.gutters.offsetWidth,\n            gutterLeft: left,\n            gutterWidth: width,\n            wrapperWidth: d.wrapper.clientWidth}\n  }\n\n  // Computes display.scroller.scrollLeft + display.gutters.offsetWidth,\n  // but using getBoundingClientRect to get a sub-pixel-accurate\n  // result.\n  function compensateForHScroll(display) {\n    return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left\n  }\n\n  // Returns a function that estimates the height of a line, to use as\n  // first approximation until the line becomes visible (and is thus\n  // properly measurable).\n  function estimateHeight(cm) {\n    var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;\n    var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);\n    return function (line) {\n      if (lineIsHidden(cm.doc, line)) { return 0 }\n\n      var widgetsHeight = 0;\n      if (line.widgets) { for (var i = 0; i < line.widgets.length; i++) {\n        if (line.widgets[i].height) { widgetsHeight += line.widgets[i].height; }\n      } }\n\n      if (wrapping)\n        { return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th }\n      else\n        { return widgetsHeight + th }\n    }\n  }\n\n  function estimateLineHeights(cm) {\n    var doc = cm.doc, est = estimateHeight(cm);\n    doc.iter(function (line) {\n      var estHeight = est(line);\n      if (estHeight != line.height) { updateLineHeight(line, estHeight); }\n    });\n  }\n\n  // Given a mouse event, find the corresponding position. If liberal\n  // is false, it checks whether a gutter or scrollbar was clicked,\n  // and returns null if it was. forRect is used by rectangular\n  // selections, and tries to estimate a character position even for\n  // coordinates beyond the right of the text.\n  function posFromMouse(cm, e, liberal, forRect) {\n    var display = cm.display;\n    if (!liberal && e_target(e).getAttribute(\"cm-not-content\") == \"true\") { return null }\n\n    var x, y, space = display.lineSpace.getBoundingClientRect();\n    // Fails unpredictably on IE[67] when mouse is dragged around quickly.\n    try { x = e.clientX - space.left; y = e.clientY - space.top; }\n    catch (e$1) { return null }\n    var coords = coordsChar(cm, x, y), line;\n    if (forRect && coords.xRel > 0 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {\n      var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;\n      coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));\n    }\n    return coords\n  }\n\n  // Find the view element corresponding to a given line. Return null\n  // when the line isn't visible.\n  function findViewIndex(cm, n) {\n    if (n >= cm.display.viewTo) { return null }\n    n -= cm.display.viewFrom;\n    if (n < 0) { return null }\n    var view = cm.display.view;\n    for (var i = 0; i < view.length; i++) {\n      n -= view[i].size;\n      if (n < 0) { return i }\n    }\n  }\n\n  // Updates the display.view data structure for a given change to the\n  // document. From and to are in pre-change coordinates. Lendiff is\n  // the amount of lines added or subtracted by the change. This is\n  // used for changes that span multiple lines, or change the way\n  // lines are divided into visual lines. regLineChange (below)\n  // registers single-line changes.\n  function regChange(cm, from, to, lendiff) {\n    if (from == null) { from = cm.doc.first; }\n    if (to == null) { to = cm.doc.first + cm.doc.size; }\n    if (!lendiff) { lendiff = 0; }\n\n    var display = cm.display;\n    if (lendiff && to < display.viewTo &&\n        (display.updateLineNumbers == null || display.updateLineNumbers > from))\n      { display.updateLineNumbers = from; }\n\n    cm.curOp.viewChanged = true;\n\n    if (from >= display.viewTo) { // Change after\n      if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo)\n        { resetView(cm); }\n    } else if (to <= display.viewFrom) { // Change before\n      if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {\n        resetView(cm);\n      } else {\n        display.viewFrom += lendiff;\n        display.viewTo += lendiff;\n      }\n    } else if (from <= display.viewFrom && to >= display.viewTo) { // Full overlap\n      resetView(cm);\n    } else if (from <= display.viewFrom) { // Top overlap\n      var cut = viewCuttingPoint(cm, to, to + lendiff, 1);\n      if (cut) {\n        display.view = display.view.slice(cut.index);\n        display.viewFrom = cut.lineN;\n        display.viewTo += lendiff;\n      } else {\n        resetView(cm);\n      }\n    } else if (to >= display.viewTo) { // Bottom overlap\n      var cut$1 = viewCuttingPoint(cm, from, from, -1);\n      if (cut$1) {\n        display.view = display.view.slice(0, cut$1.index);\n        display.viewTo = cut$1.lineN;\n      } else {\n        resetView(cm);\n      }\n    } else { // Gap in the middle\n      var cutTop = viewCuttingPoint(cm, from, from, -1);\n      var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);\n      if (cutTop && cutBot) {\n        display.view = display.view.slice(0, cutTop.index)\n          .concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN))\n          .concat(display.view.slice(cutBot.index));\n        display.viewTo += lendiff;\n      } else {\n        resetView(cm);\n      }\n    }\n\n    var ext = display.externalMeasured;\n    if (ext) {\n      if (to < ext.lineN)\n        { ext.lineN += lendiff; }\n      else if (from < ext.lineN + ext.size)\n        { display.externalMeasured = null; }\n    }\n  }\n\n  // Register a change to a single line. Type must be one of \"text\",\n  // \"gutter\", \"class\", \"widget\"\n  function regLineChange(cm, line, type) {\n    cm.curOp.viewChanged = true;\n    var display = cm.display, ext = cm.display.externalMeasured;\n    if (ext && line >= ext.lineN && line < ext.lineN + ext.size)\n      { display.externalMeasured = null; }\n\n    if (line < display.viewFrom || line >= display.viewTo) { return }\n    var lineView = display.view[findViewIndex(cm, line)];\n    if (lineView.node == null) { return }\n    var arr = lineView.changes || (lineView.changes = []);\n    if (indexOf(arr, type) == -1) { arr.push(type); }\n  }\n\n  // Clear the view.\n  function resetView(cm) {\n    cm.display.viewFrom = cm.display.viewTo = cm.doc.first;\n    cm.display.view = [];\n    cm.display.viewOffset = 0;\n  }\n\n  function viewCuttingPoint(cm, oldN, newN, dir) {\n    var index = findViewIndex(cm, oldN), diff, view = cm.display.view;\n    if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)\n      { return {index: index, lineN: newN} }\n    var n = cm.display.viewFrom;\n    for (var i = 0; i < index; i++)\n      { n += view[i].size; }\n    if (n != oldN) {\n      if (dir > 0) {\n        if (index == view.length - 1) { return null }\n        diff = (n + view[index].size) - oldN;\n        index++;\n      } else {\n        diff = n - oldN;\n      }\n      oldN += diff; newN += diff;\n    }\n    while (visualLineNo(cm.doc, newN) != newN) {\n      if (index == (dir < 0 ? 0 : view.length - 1)) { return null }\n      newN += dir * view[index - (dir < 0 ? 1 : 0)].size;\n      index += dir;\n    }\n    return {index: index, lineN: newN}\n  }\n\n  // Force the view to cover a given range, adding empty view element\n  // or clipping off existing ones as needed.\n  function adjustView(cm, from, to) {\n    var display = cm.display, view = display.view;\n    if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {\n      display.view = buildViewArray(cm, from, to);\n      display.viewFrom = from;\n    } else {\n      if (display.viewFrom > from)\n        { display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view); }\n      else if (display.viewFrom < from)\n        { display.view = display.view.slice(findViewIndex(cm, from)); }\n      display.viewFrom = from;\n      if (display.viewTo < to)\n        { display.view = display.view.concat(buildViewArray(cm, display.viewTo, to)); }\n      else if (display.viewTo > to)\n        { display.view = display.view.slice(0, findViewIndex(cm, to)); }\n    }\n    display.viewTo = to;\n  }\n\n  // Count the number of lines in the view whose DOM representation is\n  // out of date (or nonexistent).\n  function countDirtyView(cm) {\n    var view = cm.display.view, dirty = 0;\n    for (var i = 0; i < view.length; i++) {\n      var lineView = view[i];\n      if (!lineView.hidden && (!lineView.node || lineView.changes)) { ++dirty; }\n    }\n    return dirty\n  }\n\n  function updateSelection(cm) {\n    cm.display.input.showSelection(cm.display.input.prepareSelection());\n  }\n\n  function prepareSelection(cm, primary) {\n    if ( primary === void 0 ) primary = true;\n\n    var doc = cm.doc, result = {};\n    var curFragment = result.cursors = document.createDocumentFragment();\n    var selFragment = result.selection = document.createDocumentFragment();\n\n    for (var i = 0; i < doc.sel.ranges.length; i++) {\n      if (!primary && i == doc.sel.primIndex) { continue }\n      var range = doc.sel.ranges[i];\n      if (range.from().line >= cm.display.viewTo || range.to().line < cm.display.viewFrom) { continue }\n      var collapsed = range.empty();\n      if (collapsed || cm.options.showCursorWhenSelecting)\n        { drawSelectionCursor(cm, range.head, curFragment); }\n      if (!collapsed)\n        { drawSelectionRange(cm, range, selFragment); }\n    }\n    return result\n  }\n\n  // Draws a cursor for the given range\n  function drawSelectionCursor(cm, head, output) {\n    var pos = cursorCoords(cm, head, \"div\", null, null, !cm.options.singleCursorHeightPerLine);\n\n    var cursor = output.appendChild(elt(\"div\", \"\\u00a0\", \"CodeMirror-cursor\"));\n    cursor.style.left = pos.left + \"px\";\n    cursor.style.top = pos.top + \"px\";\n    cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + \"px\";\n\n    if (pos.other) {\n      // Secondary cursor, shown when on a 'jump' in bi-directional text\n      var otherCursor = output.appendChild(elt(\"div\", \"\\u00a0\", \"CodeMirror-cursor CodeMirror-secondarycursor\"));\n      otherCursor.style.display = \"\";\n      otherCursor.style.left = pos.other.left + \"px\";\n      otherCursor.style.top = pos.other.top + \"px\";\n      otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + \"px\";\n    }\n  }\n\n  function cmpCoords(a, b) { return a.top - b.top || a.left - b.left }\n\n  // Draws the given range as a highlighted selection\n  function drawSelectionRange(cm, range, output) {\n    var display = cm.display, doc = cm.doc;\n    var fragment = document.createDocumentFragment();\n    var padding = paddingH(cm.display), leftSide = padding.left;\n    var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;\n    var docLTR = doc.direction == \"ltr\";\n\n    function add(left, top, width, bottom) {\n      if (top < 0) { top = 0; }\n      top = Math.round(top);\n      bottom = Math.round(bottom);\n      fragment.appendChild(elt(\"div\", null, \"CodeMirror-selected\", (\"position: absolute; left: \" + left + \"px;\\n                             top: \" + top + \"px; width: \" + (width == null ? rightSide - left : width) + \"px;\\n                             height: \" + (bottom - top) + \"px\")));\n    }\n\n    function drawForLine(line, fromArg, toArg) {\n      var lineObj = getLine(doc, line);\n      var lineLen = lineObj.text.length;\n      var start, end;\n      function coords(ch, bias) {\n        return charCoords(cm, Pos(line, ch), \"div\", lineObj, bias)\n      }\n\n      function wrapX(pos, dir, side) {\n        var extent = wrappedLineExtentChar(cm, lineObj, null, pos);\n        var prop = (dir == \"ltr\") == (side == \"after\") ? \"left\" : \"right\";\n        var ch = side == \"after\" ? extent.begin : extent.end - (/\\s/.test(lineObj.text.charAt(extent.end - 1)) ? 2 : 1);\n        return coords(ch, prop)[prop]\n      }\n\n      var order = getOrder(lineObj, doc.direction);\n      iterateBidiSections(order, fromArg || 0, toArg == null ? lineLen : toArg, function (from, to, dir, i) {\n        var ltr = dir == \"ltr\";\n        var fromPos = coords(from, ltr ? \"left\" : \"right\");\n        var toPos = coords(to - 1, ltr ? \"right\" : \"left\");\n\n        var openStart = fromArg == null && from == 0, openEnd = toArg == null && to == lineLen;\n        var first = i == 0, last = !order || i == order.length - 1;\n        if (toPos.top - fromPos.top <= 3) { // Single line\n          var openLeft = (docLTR ? openStart : openEnd) && first;\n          var openRight = (docLTR ? openEnd : openStart) && last;\n          var left = openLeft ? leftSide : (ltr ? fromPos : toPos).left;\n          var right = openRight ? rightSide : (ltr ? toPos : fromPos).right;\n          add(left, fromPos.top, right - left, fromPos.bottom);\n        } else { // Multiple lines\n          var topLeft, topRight, botLeft, botRight;\n          if (ltr) {\n            topLeft = docLTR && openStart && first ? leftSide : fromPos.left;\n            topRight = docLTR ? rightSide : wrapX(from, dir, \"before\");\n            botLeft = docLTR ? leftSide : wrapX(to, dir, \"after\");\n            botRight = docLTR && openEnd && last ? rightSide : toPos.right;\n          } else {\n            topLeft = !docLTR ? leftSide : wrapX(from, dir, \"before\");\n            topRight = !docLTR && openStart && first ? rightSide : fromPos.right;\n            botLeft = !docLTR && openEnd && last ? leftSide : toPos.left;\n            botRight = !docLTR ? rightSide : wrapX(to, dir, \"after\");\n          }\n          add(topLeft, fromPos.top, topRight - topLeft, fromPos.bottom);\n          if (fromPos.bottom < toPos.top) { add(leftSide, fromPos.bottom, null, toPos.top); }\n          add(botLeft, toPos.top, botRight - botLeft, toPos.bottom);\n        }\n\n        if (!start || cmpCoords(fromPos, start) < 0) { start = fromPos; }\n        if (cmpCoords(toPos, start) < 0) { start = toPos; }\n        if (!end || cmpCoords(fromPos, end) < 0) { end = fromPos; }\n        if (cmpCoords(toPos, end) < 0) { end = toPos; }\n      });\n      return {start: start, end: end}\n    }\n\n    var sFrom = range.from(), sTo = range.to();\n    if (sFrom.line == sTo.line) {\n      drawForLine(sFrom.line, sFrom.ch, sTo.ch);\n    } else {\n      var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);\n      var singleVLine = visualLine(fromLine) == visualLine(toLine);\n      var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;\n      var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;\n      if (singleVLine) {\n        if (leftEnd.top < rightStart.top - 2) {\n          add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);\n          add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);\n        } else {\n          add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);\n        }\n      }\n      if (leftEnd.bottom < rightStart.top)\n        { add(leftSide, leftEnd.bottom, null, rightStart.top); }\n    }\n\n    output.appendChild(fragment);\n  }\n\n  // Cursor-blinking\n  function restartBlink(cm) {\n    if (!cm.state.focused) { return }\n    var display = cm.display;\n    clearInterval(display.blinker);\n    var on = true;\n    display.cursorDiv.style.visibility = \"\";\n    if (cm.options.cursorBlinkRate > 0)\n      { display.blinker = setInterval(function () {\n        if (!cm.hasFocus()) { onBlur(cm); }\n        display.cursorDiv.style.visibility = (on = !on) ? \"\" : \"hidden\";\n      }, cm.options.cursorBlinkRate); }\n    else if (cm.options.cursorBlinkRate < 0)\n      { display.cursorDiv.style.visibility = \"hidden\"; }\n  }\n\n  function ensureFocus(cm) {\n    if (!cm.hasFocus()) {\n      cm.display.input.focus();\n      if (!cm.state.focused) { onFocus(cm); }\n    }\n  }\n\n  function delayBlurEvent(cm) {\n    cm.state.delayingBlurEvent = true;\n    setTimeout(function () { if (cm.state.delayingBlurEvent) {\n      cm.state.delayingBlurEvent = false;\n      if (cm.state.focused) { onBlur(cm); }\n    } }, 100);\n  }\n\n  function onFocus(cm, e) {\n    if (cm.state.delayingBlurEvent && !cm.state.draggingText) { cm.state.delayingBlurEvent = false; }\n\n    if (cm.options.readOnly == \"nocursor\") { return }\n    if (!cm.state.focused) {\n      signal(cm, \"focus\", cm, e);\n      cm.state.focused = true;\n      addClass(cm.display.wrapper, \"CodeMirror-focused\");\n      // This test prevents this from firing when a context\n      // menu is closed (since the input reset would kill the\n      // select-all detection hack)\n      if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {\n        cm.display.input.reset();\n        if (webkit) { setTimeout(function () { return cm.display.input.reset(true); }, 20); } // Issue #1730\n      }\n      cm.display.input.receivedFocus();\n    }\n    restartBlink(cm);\n  }\n  function onBlur(cm, e) {\n    if (cm.state.delayingBlurEvent) { return }\n\n    if (cm.state.focused) {\n      signal(cm, \"blur\", cm, e);\n      cm.state.focused = false;\n      rmClass(cm.display.wrapper, \"CodeMirror-focused\");\n    }\n    clearInterval(cm.display.blinker);\n    setTimeout(function () { if (!cm.state.focused) { cm.display.shift = false; } }, 150);\n  }\n\n  // Read the actual heights of the rendered lines, and update their\n  // stored heights to match.\n  function updateHeightsInViewport(cm) {\n    var display = cm.display;\n    var prevBottom = display.lineDiv.offsetTop;\n    for (var i = 0; i < display.view.length; i++) {\n      var cur = display.view[i], wrapping = cm.options.lineWrapping;\n      var height = (void 0), width = 0;\n      if (cur.hidden) { continue }\n      if (ie && ie_version < 8) {\n        var bot = cur.node.offsetTop + cur.node.offsetHeight;\n        height = bot - prevBottom;\n        prevBottom = bot;\n      } else {\n        var box = cur.node.getBoundingClientRect();\n        height = box.bottom - box.top;\n        // Check that lines don't extend past the right of the current\n        // editor width\n        if (!wrapping && cur.text.firstChild)\n          { width = cur.text.firstChild.getBoundingClientRect().right - box.left - 1; }\n      }\n      var diff = cur.line.height - height;\n      if (diff > .005 || diff < -.005) {\n        updateLineHeight(cur.line, height);\n        updateWidgetHeight(cur.line);\n        if (cur.rest) { for (var j = 0; j < cur.rest.length; j++)\n          { updateWidgetHeight(cur.rest[j]); } }\n      }\n      if (width > cm.display.sizerWidth) {\n        var chWidth = Math.ceil(width / charWidth(cm.display));\n        if (chWidth > cm.display.maxLineLength) {\n          cm.display.maxLineLength = chWidth;\n          cm.display.maxLine = cur.line;\n          cm.display.maxLineChanged = true;\n        }\n      }\n    }\n  }\n\n  // Read and store the height of line widgets associated with the\n  // given line.\n  function updateWidgetHeight(line) {\n    if (line.widgets) { for (var i = 0; i < line.widgets.length; ++i) {\n      var w = line.widgets[i], parent = w.node.parentNode;\n      if (parent) { w.height = parent.offsetHeight; }\n    } }\n  }\n\n  // Compute the lines that are visible in a given viewport (defaults\n  // the the current scroll position). viewport may contain top,\n  // height, and ensure (see op.scrollToPos) properties.\n  function visibleLines(display, doc, viewport) {\n    var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;\n    top = Math.floor(top - paddingTop(display));\n    var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;\n\n    var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);\n    // Ensure is a {from: {line, ch}, to: {line, ch}} object, and\n    // forces those lines into the viewport (if possible).\n    if (viewport && viewport.ensure) {\n      var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;\n      if (ensureFrom < from) {\n        from = ensureFrom;\n        to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);\n      } else if (Math.min(ensureTo, doc.lastLine()) >= to) {\n        from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);\n        to = ensureTo;\n      }\n    }\n    return {from: from, to: Math.max(to, from + 1)}\n  }\n\n  // SCROLLING THINGS INTO VIEW\n\n  // If an editor sits on the top or bottom of the window, partially\n  // scrolled out of view, this ensures that the cursor is visible.\n  function maybeScrollWindow(cm, rect) {\n    if (signalDOMEvent(cm, \"scrollCursorIntoView\")) { return }\n\n    var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;\n    if (rect.top + box.top < 0) { doScroll = true; }\n    else if (rect.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) { doScroll = false; }\n    if (doScroll != null && !phantom) {\n      var scrollNode = elt(\"div\", \"\\u200b\", null, (\"position: absolute;\\n                         top: \" + (rect.top - display.viewOffset - paddingTop(cm.display)) + \"px;\\n                         height: \" + (rect.bottom - rect.top + scrollGap(cm) + display.barHeight) + \"px;\\n                         left: \" + (rect.left) + \"px; width: \" + (Math.max(2, rect.right - rect.left)) + \"px;\"));\n      cm.display.lineSpace.appendChild(scrollNode);\n      scrollNode.scrollIntoView(doScroll);\n      cm.display.lineSpace.removeChild(scrollNode);\n    }\n  }\n\n  // Scroll a given position into view (immediately), verifying that\n  // it actually became visible (as line heights are accurately\n  // measured, the position of something may 'drift' during drawing).\n  function scrollPosIntoView(cm, pos, end, margin) {\n    if (margin == null) { margin = 0; }\n    var rect;\n    if (!cm.options.lineWrapping && pos == end) {\n      // Set pos and end to the cursor positions around the character pos sticks to\n      // If pos.sticky == \"before\", that is around pos.ch - 1, otherwise around pos.ch\n      // If pos == Pos(_, 0, \"before\"), pos and end are unchanged\n      pos = pos.ch ? Pos(pos.line, pos.sticky == \"before\" ? pos.ch - 1 : pos.ch, \"after\") : pos;\n      end = pos.sticky == \"before\" ? Pos(pos.line, pos.ch + 1, \"before\") : pos;\n    }\n    for (var limit = 0; limit < 5; limit++) {\n      var changed = false;\n      var coords = cursorCoords(cm, pos);\n      var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);\n      rect = {left: Math.min(coords.left, endCoords.left),\n              top: Math.min(coords.top, endCoords.top) - margin,\n              right: Math.max(coords.left, endCoords.left),\n              bottom: Math.max(coords.bottom, endCoords.bottom) + margin};\n      var scrollPos = calculateScrollPos(cm, rect);\n      var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;\n      if (scrollPos.scrollTop != null) {\n        updateScrollTop(cm, scrollPos.scrollTop);\n        if (Math.abs(cm.doc.scrollTop - startTop) > 1) { changed = true; }\n      }\n      if (scrollPos.scrollLeft != null) {\n        setScrollLeft(cm, scrollPos.scrollLeft);\n        if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) { changed = true; }\n      }\n      if (!changed) { break }\n    }\n    return rect\n  }\n\n  // Scroll a given set of coordinates into view (immediately).\n  function scrollIntoView(cm, rect) {\n    var scrollPos = calculateScrollPos(cm, rect);\n    if (scrollPos.scrollTop != null) { updateScrollTop(cm, scrollPos.scrollTop); }\n    if (scrollPos.scrollLeft != null) { setScrollLeft(cm, scrollPos.scrollLeft); }\n  }\n\n  // Calculate a new scroll position needed to scroll the given\n  // rectangle into view. Returns an object with scrollTop and\n  // scrollLeft properties. When these are undefined, the\n  // vertical/horizontal position does not need to be adjusted.\n  function calculateScrollPos(cm, rect) {\n    var display = cm.display, snapMargin = textHeight(cm.display);\n    if (rect.top < 0) { rect.top = 0; }\n    var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;\n    var screen = displayHeight(cm), result = {};\n    if (rect.bottom - rect.top > screen) { rect.bottom = rect.top + screen; }\n    var docBottom = cm.doc.height + paddingVert(display);\n    var atTop = rect.top < snapMargin, atBottom = rect.bottom > docBottom - snapMargin;\n    if (rect.top < screentop) {\n      result.scrollTop = atTop ? 0 : rect.top;\n    } else if (rect.bottom > screentop + screen) {\n      var newTop = Math.min(rect.top, (atBottom ? docBottom : rect.bottom) - screen);\n      if (newTop != screentop) { result.scrollTop = newTop; }\n    }\n\n    var gutterSpace = cm.options.fixedGutter ? 0 : display.gutters.offsetWidth;\n    var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft - gutterSpace;\n    var screenw = displayWidth(cm) - display.gutters.offsetWidth;\n    var tooWide = rect.right - rect.left > screenw;\n    if (tooWide) { rect.right = rect.left + screenw; }\n    if (rect.left < 10)\n      { result.scrollLeft = 0; }\n    else if (rect.left < screenleft)\n      { result.scrollLeft = Math.max(0, rect.left + gutterSpace - (tooWide ? 0 : 10)); }\n    else if (rect.right > screenw + screenleft - 3)\n      { result.scrollLeft = rect.right + (tooWide ? 0 : 10) - screenw; }\n    return result\n  }\n\n  // Store a relative adjustment to the scroll position in the current\n  // operation (to be applied when the operation finishes).\n  function addToScrollTop(cm, top) {\n    if (top == null) { return }\n    resolveScrollToPos(cm);\n    cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;\n  }\n\n  // Make sure that at the end of the operation the current cursor is\n  // shown.\n  function ensureCursorVisible(cm) {\n    resolveScrollToPos(cm);\n    var cur = cm.getCursor();\n    cm.curOp.scrollToPos = {from: cur, to: cur, margin: cm.options.cursorScrollMargin};\n  }\n\n  function scrollToCoords(cm, x, y) {\n    if (x != null || y != null) { resolveScrollToPos(cm); }\n    if (x != null) { cm.curOp.scrollLeft = x; }\n    if (y != null) { cm.curOp.scrollTop = y; }\n  }\n\n  function scrollToRange(cm, range) {\n    resolveScrollToPos(cm);\n    cm.curOp.scrollToPos = range;\n  }\n\n  // When an operation has its scrollToPos property set, and another\n  // scroll action is applied before the end of the operation, this\n  // 'simulates' scrolling that position into view in a cheap way, so\n  // that the effect of intermediate scroll commands is not ignored.\n  function resolveScrollToPos(cm) {\n    var range = cm.curOp.scrollToPos;\n    if (range) {\n      cm.curOp.scrollToPos = null;\n      var from = estimateCoords(cm, range.from), to = estimateCoords(cm, range.to);\n      scrollToCoordsRange(cm, from, to, range.margin);\n    }\n  }\n\n  function scrollToCoordsRange(cm, from, to, margin) {\n    var sPos = calculateScrollPos(cm, {\n      left: Math.min(from.left, to.left),\n      top: Math.min(from.top, to.top) - margin,\n      right: Math.max(from.right, to.right),\n      bottom: Math.max(from.bottom, to.bottom) + margin\n    });\n    scrollToCoords(cm, sPos.scrollLeft, sPos.scrollTop);\n  }\n\n  // Sync the scrollable area and scrollbars, ensure the viewport\n  // covers the visible area.\n  function updateScrollTop(cm, val) {\n    if (Math.abs(cm.doc.scrollTop - val) < 2) { return }\n    if (!gecko) { updateDisplaySimple(cm, {top: val}); }\n    setScrollTop(cm, val, true);\n    if (gecko) { updateDisplaySimple(cm); }\n    startWorker(cm, 100);\n  }\n\n  function setScrollTop(cm, val, forceScroll) {\n    val = Math.max(0, Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, val));\n    if (cm.display.scroller.scrollTop == val && !forceScroll) { return }\n    cm.doc.scrollTop = val;\n    cm.display.scrollbars.setScrollTop(val);\n    if (cm.display.scroller.scrollTop != val) { cm.display.scroller.scrollTop = val; }\n  }\n\n  // Sync scroller and scrollbar, ensure the gutter elements are\n  // aligned.\n  function setScrollLeft(cm, val, isScroller, forceScroll) {\n    val = Math.max(0, Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth));\n    if ((isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) && !forceScroll) { return }\n    cm.doc.scrollLeft = val;\n    alignHorizontally(cm);\n    if (cm.display.scroller.scrollLeft != val) { cm.display.scroller.scrollLeft = val; }\n    cm.display.scrollbars.setScrollLeft(val);\n  }\n\n  // SCROLLBARS\n\n  // Prepare DOM reads needed to update the scrollbars. Done in one\n  // shot to minimize update/measure roundtrips.\n  function measureForScrollbars(cm) {\n    var d = cm.display, gutterW = d.gutters.offsetWidth;\n    var docH = Math.round(cm.doc.height + paddingVert(cm.display));\n    return {\n      clientHeight: d.scroller.clientHeight,\n      viewHeight: d.wrapper.clientHeight,\n      scrollWidth: d.scroller.scrollWidth, clientWidth: d.scroller.clientWidth,\n      viewWidth: d.wrapper.clientWidth,\n      barLeft: cm.options.fixedGutter ? gutterW : 0,\n      docHeight: docH,\n      scrollHeight: docH + scrollGap(cm) + d.barHeight,\n      nativeBarWidth: d.nativeBarWidth,\n      gutterWidth: gutterW\n    }\n  }\n\n  var NativeScrollbars = function(place, scroll, cm) {\n    this.cm = cm;\n    var vert = this.vert = elt(\"div\", [elt(\"div\", null, null, \"min-width: 1px\")], \"CodeMirror-vscrollbar\");\n    var horiz = this.horiz = elt(\"div\", [elt(\"div\", null, null, \"height: 100%; min-height: 1px\")], \"CodeMirror-hscrollbar\");\n    vert.tabIndex = horiz.tabIndex = -1;\n    place(vert); place(horiz);\n\n    on(vert, \"scroll\", function () {\n      if (vert.clientHeight) { scroll(vert.scrollTop, \"vertical\"); }\n    });\n    on(horiz, \"scroll\", function () {\n      if (horiz.clientWidth) { scroll(horiz.scrollLeft, \"horizontal\"); }\n    });\n\n    this.checkedZeroWidth = false;\n    // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).\n    if (ie && ie_version < 8) { this.horiz.style.minHeight = this.vert.style.minWidth = \"18px\"; }\n  };\n\n  NativeScrollbars.prototype.update = function (measure) {\n    var needsH = measure.scrollWidth > measure.clientWidth + 1;\n    var needsV = measure.scrollHeight > measure.clientHeight + 1;\n    var sWidth = measure.nativeBarWidth;\n\n    if (needsV) {\n      this.vert.style.display = \"block\";\n      this.vert.style.bottom = needsH ? sWidth + \"px\" : \"0\";\n      var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);\n      // A bug in IE8 can cause this value to be negative, so guard it.\n      this.vert.firstChild.style.height =\n        Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + \"px\";\n    } else {\n      this.vert.style.display = \"\";\n      this.vert.firstChild.style.height = \"0\";\n    }\n\n    if (needsH) {\n      this.horiz.style.display = \"block\";\n      this.horiz.style.right = needsV ? sWidth + \"px\" : \"0\";\n      this.horiz.style.left = measure.barLeft + \"px\";\n      var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);\n      this.horiz.firstChild.style.width =\n        Math.max(0, measure.scrollWidth - measure.clientWidth + totalWidth) + \"px\";\n    } else {\n      this.horiz.style.display = \"\";\n      this.horiz.firstChild.style.width = \"0\";\n    }\n\n    if (!this.checkedZeroWidth && measure.clientHeight > 0) {\n      if (sWidth == 0) { this.zeroWidthHack(); }\n      this.checkedZeroWidth = true;\n    }\n\n    return {right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0}\n  };\n\n  NativeScrollbars.prototype.setScrollLeft = function (pos) {\n    if (this.horiz.scrollLeft != pos) { this.horiz.scrollLeft = pos; }\n    if (this.disableHoriz) { this.enableZeroWidthBar(this.horiz, this.disableHoriz, \"horiz\"); }\n  };\n\n  NativeScrollbars.prototype.setScrollTop = function (pos) {\n    if (this.vert.scrollTop != pos) { this.vert.scrollTop = pos; }\n    if (this.disableVert) { this.enableZeroWidthBar(this.vert, this.disableVert, \"vert\"); }\n  };\n\n  NativeScrollbars.prototype.zeroWidthHack = function () {\n    var w = mac && !mac_geMountainLion ? \"12px\" : \"18px\";\n    this.horiz.style.height = this.vert.style.width = w;\n    this.horiz.style.pointerEvents = this.vert.style.pointerEvents = \"none\";\n    this.disableHoriz = new Delayed;\n    this.disableVert = new Delayed;\n  };\n\n  NativeScrollbars.prototype.enableZeroWidthBar = function (bar, delay, type) {\n    bar.style.pointerEvents = \"auto\";\n    function maybeDisable() {\n      // To find out whether the scrollbar is still visible, we\n      // check whether the element under the pixel in the bottom\n      // right corner of the scrollbar box is the scrollbar box\n      // itself (when the bar is still visible) or its filler child\n      // (when the bar is hidden). If it is still visible, we keep\n      // it enabled, if it's hidden, we disable pointer events.\n      var box = bar.getBoundingClientRect();\n      var elt = type == \"vert\" ? document.elementFromPoint(box.right - 1, (box.top + box.bottom) / 2)\n          : document.elementFromPoint((box.right + box.left) / 2, box.bottom - 1);\n      if (elt != bar) { bar.style.pointerEvents = \"none\"; }\n      else { delay.set(1000, maybeDisable); }\n    }\n    delay.set(1000, maybeDisable);\n  };\n\n  NativeScrollbars.prototype.clear = function () {\n    var parent = this.horiz.parentNode;\n    parent.removeChild(this.horiz);\n    parent.removeChild(this.vert);\n  };\n\n  var NullScrollbars = function () {};\n\n  NullScrollbars.prototype.update = function () { return {bottom: 0, right: 0} };\n  NullScrollbars.prototype.setScrollLeft = function () {};\n  NullScrollbars.prototype.setScrollTop = function () {};\n  NullScrollbars.prototype.clear = function () {};\n\n  function updateScrollbars(cm, measure) {\n    if (!measure) { measure = measureForScrollbars(cm); }\n    var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;\n    updateScrollbarsInner(cm, measure);\n    for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {\n      if (startWidth != cm.display.barWidth && cm.options.lineWrapping)\n        { updateHeightsInViewport(cm); }\n      updateScrollbarsInner(cm, measureForScrollbars(cm));\n      startWidth = cm.display.barWidth; startHeight = cm.display.barHeight;\n    }\n  }\n\n  // Re-synchronize the fake scrollbars with the actual size of the\n  // content.\n  function updateScrollbarsInner(cm, measure) {\n    var d = cm.display;\n    var sizes = d.scrollbars.update(measure);\n\n    d.sizer.style.paddingRight = (d.barWidth = sizes.right) + \"px\";\n    d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + \"px\";\n    d.heightForcer.style.borderBottom = sizes.bottom + \"px solid transparent\";\n\n    if (sizes.right && sizes.bottom) {\n      d.scrollbarFiller.style.display = \"block\";\n      d.scrollbarFiller.style.height = sizes.bottom + \"px\";\n      d.scrollbarFiller.style.width = sizes.right + \"px\";\n    } else { d.scrollbarFiller.style.display = \"\"; }\n    if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {\n      d.gutterFiller.style.display = \"block\";\n      d.gutterFiller.style.height = sizes.bottom + \"px\";\n      d.gutterFiller.style.width = measure.gutterWidth + \"px\";\n    } else { d.gutterFiller.style.display = \"\"; }\n  }\n\n  var scrollbarModel = {\"native\": NativeScrollbars, \"null\": NullScrollbars};\n\n  function initScrollbars(cm) {\n    if (cm.display.scrollbars) {\n      cm.display.scrollbars.clear();\n      if (cm.display.scrollbars.addClass)\n        { rmClass(cm.display.wrapper, cm.display.scrollbars.addClass); }\n    }\n\n    cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function (node) {\n      cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);\n      // Prevent clicks in the scrollbars from killing focus\n      on(node, \"mousedown\", function () {\n        if (cm.state.focused) { setTimeout(function () { return cm.display.input.focus(); }, 0); }\n      });\n      node.setAttribute(\"cm-not-content\", \"true\");\n    }, function (pos, axis) {\n      if (axis == \"horizontal\") { setScrollLeft(cm, pos); }\n      else { updateScrollTop(cm, pos); }\n    }, cm);\n    if (cm.display.scrollbars.addClass)\n      { addClass(cm.display.wrapper, cm.display.scrollbars.addClass); }\n  }\n\n  // Operations are used to wrap a series of changes to the editor\n  // state in such a way that each change won't have to update the\n  // cursor and display (which would be awkward, slow, and\n  // error-prone). Instead, display updates are batched and then all\n  // combined and executed at once.\n\n  var nextOpId = 0;\n  // Start a new operation.\n  function startOperation(cm) {\n    cm.curOp = {\n      cm: cm,\n      viewChanged: false,      // Flag that indicates that lines might need to be redrawn\n      startHeight: cm.doc.height, // Used to detect need to update scrollbar\n      forceUpdate: false,      // Used to force a redraw\n      updateInput: 0,       // Whether to reset the input textarea\n      typing: false,           // Whether this reset should be careful to leave existing text (for compositing)\n      changeObjs: null,        // Accumulated changes, for firing change events\n      cursorActivityHandlers: null, // Set of handlers to fire cursorActivity on\n      cursorActivityCalled: 0, // Tracks which cursorActivity handlers have been called already\n      selectionChanged: false, // Whether the selection needs to be redrawn\n      updateMaxLine: false,    // Set when the widest line needs to be determined anew\n      scrollLeft: null, scrollTop: null, // Intermediate scroll position, not pushed to DOM yet\n      scrollToPos: null,       // Used to scroll to a specific position\n      focus: false,\n      id: ++nextOpId           // Unique ID\n    };\n    pushOperation(cm.curOp);\n  }\n\n  // Finish an operation, updating the display and signalling delayed events\n  function endOperation(cm) {\n    var op = cm.curOp;\n    if (op) { finishOperation(op, function (group) {\n      for (var i = 0; i < group.ops.length; i++)\n        { group.ops[i].cm.curOp = null; }\n      endOperations(group);\n    }); }\n  }\n\n  // The DOM updates done when an operation finishes are batched so\n  // that the minimum number of relayouts are required.\n  function endOperations(group) {\n    var ops = group.ops;\n    for (var i = 0; i < ops.length; i++) // Read DOM\n      { endOperation_R1(ops[i]); }\n    for (var i$1 = 0; i$1 < ops.length; i$1++) // Write DOM (maybe)\n      { endOperation_W1(ops[i$1]); }\n    for (var i$2 = 0; i$2 < ops.length; i$2++) // Read DOM\n      { endOperation_R2(ops[i$2]); }\n    for (var i$3 = 0; i$3 < ops.length; i$3++) // Write DOM (maybe)\n      { endOperation_W2(ops[i$3]); }\n    for (var i$4 = 0; i$4 < ops.length; i$4++) // Read DOM\n      { endOperation_finish(ops[i$4]); }\n  }\n\n  function endOperation_R1(op) {\n    var cm = op.cm, display = cm.display;\n    maybeClipScrollbars(cm);\n    if (op.updateMaxLine) { findMaxLine(cm); }\n\n    op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null ||\n      op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom ||\n                         op.scrollToPos.to.line >= display.viewTo) ||\n      display.maxLineChanged && cm.options.lineWrapping;\n    op.update = op.mustUpdate &&\n      new DisplayUpdate(cm, op.mustUpdate && {top: op.scrollTop, ensure: op.scrollToPos}, op.forceUpdate);\n  }\n\n  function endOperation_W1(op) {\n    op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);\n  }\n\n  function endOperation_R2(op) {\n    var cm = op.cm, display = cm.display;\n    if (op.updatedDisplay) { updateHeightsInViewport(cm); }\n\n    op.barMeasure = measureForScrollbars(cm);\n\n    // If the max line changed since it was last measured, measure it,\n    // and ensure the document's width matches it.\n    // updateDisplay_W2 will use these properties to do the actual resizing\n    if (display.maxLineChanged && !cm.options.lineWrapping) {\n      op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;\n      cm.display.sizerWidth = op.adjustWidthTo;\n      op.barMeasure.scrollWidth =\n        Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);\n      op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));\n    }\n\n    if (op.updatedDisplay || op.selectionChanged)\n      { op.preparedSelection = display.input.prepareSelection(); }\n  }\n\n  function endOperation_W2(op) {\n    var cm = op.cm;\n\n    if (op.adjustWidthTo != null) {\n      cm.display.sizer.style.minWidth = op.adjustWidthTo + \"px\";\n      if (op.maxScrollLeft < cm.doc.scrollLeft)\n        { setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true); }\n      cm.display.maxLineChanged = false;\n    }\n\n    var takeFocus = op.focus && op.focus == activeElt();\n    if (op.preparedSelection)\n      { cm.display.input.showSelection(op.preparedSelection, takeFocus); }\n    if (op.updatedDisplay || op.startHeight != cm.doc.height)\n      { updateScrollbars(cm, op.barMeasure); }\n    if (op.updatedDisplay)\n      { setDocumentHeight(cm, op.barMeasure); }\n\n    if (op.selectionChanged) { restartBlink(cm); }\n\n    if (cm.state.focused && op.updateInput)\n      { cm.display.input.reset(op.typing); }\n    if (takeFocus) { ensureFocus(op.cm); }\n  }\n\n  function endOperation_finish(op) {\n    var cm = op.cm, display = cm.display, doc = cm.doc;\n\n    if (op.updatedDisplay) { postUpdateDisplay(cm, op.update); }\n\n    // Abort mouse wheel delta measurement, when scrolling explicitly\n    if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos))\n      { display.wheelStartX = display.wheelStartY = null; }\n\n    // Propagate the scroll position to the actual DOM scroller\n    if (op.scrollTop != null) { setScrollTop(cm, op.scrollTop, op.forceScroll); }\n\n    if (op.scrollLeft != null) { setScrollLeft(cm, op.scrollLeft, true, true); }\n    // If we need to scroll a specific position into view, do so.\n    if (op.scrollToPos) {\n      var rect = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from),\n                                   clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);\n      maybeScrollWindow(cm, rect);\n    }\n\n    // Fire events for markers that are hidden/unidden by editing or\n    // undoing\n    var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;\n    if (hidden) { for (var i = 0; i < hidden.length; ++i)\n      { if (!hidden[i].lines.length) { signal(hidden[i], \"hide\"); } } }\n    if (unhidden) { for (var i$1 = 0; i$1 < unhidden.length; ++i$1)\n      { if (unhidden[i$1].lines.length) { signal(unhidden[i$1], \"unhide\"); } } }\n\n    if (display.wrapper.offsetHeight)\n      { doc.scrollTop = cm.display.scroller.scrollTop; }\n\n    // Fire change events, and delayed event handlers\n    if (op.changeObjs)\n      { signal(cm, \"changes\", cm, op.changeObjs); }\n    if (op.update)\n      { op.update.finish(); }\n  }\n\n  // Run the given function in an operation\n  function runInOp(cm, f) {\n    if (cm.curOp) { return f() }\n    startOperation(cm);\n    try { return f() }\n    finally { endOperation(cm); }\n  }\n  // Wraps a function in an operation. Returns the wrapped function.\n  function operation(cm, f) {\n    return function() {\n      if (cm.curOp) { return f.apply(cm, arguments) }\n      startOperation(cm);\n      try { return f.apply(cm, arguments) }\n      finally { endOperation(cm); }\n    }\n  }\n  // Used to add methods to editor and doc instances, wrapping them in\n  // operations.\n  function methodOp(f) {\n    return function() {\n      if (this.curOp) { return f.apply(this, arguments) }\n      startOperation(this);\n      try { return f.apply(this, arguments) }\n      finally { endOperation(this); }\n    }\n  }\n  function docMethodOp(f) {\n    return function() {\n      var cm = this.cm;\n      if (!cm || cm.curOp) { return f.apply(this, arguments) }\n      startOperation(cm);\n      try { return f.apply(this, arguments) }\n      finally { endOperation(cm); }\n    }\n  }\n\n  // HIGHLIGHT WORKER\n\n  function startWorker(cm, time) {\n    if (cm.doc.highlightFrontier < cm.display.viewTo)\n      { cm.state.highlight.set(time, bind(highlightWorker, cm)); }\n  }\n\n  function highlightWorker(cm) {\n    var doc = cm.doc;\n    if (doc.highlightFrontier >= cm.display.viewTo) { return }\n    var end = +new Date + cm.options.workTime;\n    var context = getContextBefore(cm, doc.highlightFrontier);\n    var changedLines = [];\n\n    doc.iter(context.line, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function (line) {\n      if (context.line >= cm.display.viewFrom) { // Visible\n        var oldStyles = line.styles;\n        var resetState = line.text.length > cm.options.maxHighlightLength ? copyState(doc.mode, context.state) : null;\n        var highlighted = highlightLine(cm, line, context, true);\n        if (resetState) { context.state = resetState; }\n        line.styles = highlighted.styles;\n        var oldCls = line.styleClasses, newCls = highlighted.classes;\n        if (newCls) { line.styleClasses = newCls; }\n        else if (oldCls) { line.styleClasses = null; }\n        var ischange = !oldStyles || oldStyles.length != line.styles.length ||\n          oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);\n        for (var i = 0; !ischange && i < oldStyles.length; ++i) { ischange = oldStyles[i] != line.styles[i]; }\n        if (ischange) { changedLines.push(context.line); }\n        line.stateAfter = context.save();\n        context.nextLine();\n      } else {\n        if (line.text.length <= cm.options.maxHighlightLength)\n          { processLine(cm, line.text, context); }\n        line.stateAfter = context.line % 5 == 0 ? context.save() : null;\n        context.nextLine();\n      }\n      if (+new Date > end) {\n        startWorker(cm, cm.options.workDelay);\n        return true\n      }\n    });\n    doc.highlightFrontier = context.line;\n    doc.modeFrontier = Math.max(doc.modeFrontier, context.line);\n    if (changedLines.length) { runInOp(cm, function () {\n      for (var i = 0; i < changedLines.length; i++)\n        { regLineChange(cm, changedLines[i], \"text\"); }\n    }); }\n  }\n\n  // DISPLAY DRAWING\n\n  var DisplayUpdate = function(cm, viewport, force) {\n    var display = cm.display;\n\n    this.viewport = viewport;\n    // Store some values that we'll need later (but don't want to force a relayout for)\n    this.visible = visibleLines(display, cm.doc, viewport);\n    this.editorIsHidden = !display.wrapper.offsetWidth;\n    this.wrapperHeight = display.wrapper.clientHeight;\n    this.wrapperWidth = display.wrapper.clientWidth;\n    this.oldDisplayWidth = displayWidth(cm);\n    this.force = force;\n    this.dims = getDimensions(cm);\n    this.events = [];\n  };\n\n  DisplayUpdate.prototype.signal = function (emitter, type) {\n    if (hasHandler(emitter, type))\n      { this.events.push(arguments); }\n  };\n  DisplayUpdate.prototype.finish = function () {\n    for (var i = 0; i < this.events.length; i++)\n      { signal.apply(null, this.events[i]); }\n  };\n\n  function maybeClipScrollbars(cm) {\n    var display = cm.display;\n    if (!display.scrollbarsClipped && display.scroller.offsetWidth) {\n      display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;\n      display.heightForcer.style.height = scrollGap(cm) + \"px\";\n      display.sizer.style.marginBottom = -display.nativeBarWidth + \"px\";\n      display.sizer.style.borderRightWidth = scrollGap(cm) + \"px\";\n      display.scrollbarsClipped = true;\n    }\n  }\n\n  function selectionSnapshot(cm) {\n    if (cm.hasFocus()) { return null }\n    var active = activeElt();\n    if (!active || !contains(cm.display.lineDiv, active)) { return null }\n    var result = {activeElt: active};\n    if (window.getSelection) {\n      var sel = window.getSelection();\n      if (sel.anchorNode && sel.extend && contains(cm.display.lineDiv, sel.anchorNode)) {\n        result.anchorNode = sel.anchorNode;\n        result.anchorOffset = sel.anchorOffset;\n        result.focusNode = sel.focusNode;\n        result.focusOffset = sel.focusOffset;\n      }\n    }\n    return result\n  }\n\n  function restoreSelection(snapshot) {\n    if (!snapshot || !snapshot.activeElt || snapshot.activeElt == activeElt()) { return }\n    snapshot.activeElt.focus();\n    if (!/^(INPUT|TEXTAREA)$/.test(snapshot.activeElt.nodeName) &&\n        snapshot.anchorNode && contains(document.body, snapshot.anchorNode) && contains(document.body, snapshot.focusNode)) {\n      var sel = window.getSelection(), range = document.createRange();\n      range.setEnd(snapshot.anchorNode, snapshot.anchorOffset);\n      range.collapse(false);\n      sel.removeAllRanges();\n      sel.addRange(range);\n      sel.extend(snapshot.focusNode, snapshot.focusOffset);\n    }\n  }\n\n  // Does the actual updating of the line display. Bails out\n  // (returning false) when there is nothing to be done and forced is\n  // false.\n  function updateDisplayIfNeeded(cm, update) {\n    var display = cm.display, doc = cm.doc;\n\n    if (update.editorIsHidden) {\n      resetView(cm);\n      return false\n    }\n\n    // Bail out if the visible area is already rendered and nothing changed.\n    if (!update.force &&\n        update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo &&\n        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) &&\n        display.renderedView == display.view && countDirtyView(cm) == 0)\n      { return false }\n\n    if (maybeUpdateLineNumberWidth(cm)) {\n      resetView(cm);\n      update.dims = getDimensions(cm);\n    }\n\n    // Compute a suitable new viewport (from & to)\n    var end = doc.first + doc.size;\n    var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);\n    var to = Math.min(end, update.visible.to + cm.options.viewportMargin);\n    if (display.viewFrom < from && from - display.viewFrom < 20) { from = Math.max(doc.first, display.viewFrom); }\n    if (display.viewTo > to && display.viewTo - to < 20) { to = Math.min(end, display.viewTo); }\n    if (sawCollapsedSpans) {\n      from = visualLineNo(cm.doc, from);\n      to = visualLineEndNo(cm.doc, to);\n    }\n\n    var different = from != display.viewFrom || to != display.viewTo ||\n      display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;\n    adjustView(cm, from, to);\n\n    display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));\n    // Position the mover div to align with the current scroll position\n    cm.display.mover.style.top = display.viewOffset + \"px\";\n\n    var toUpdate = countDirtyView(cm);\n    if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view &&\n        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo))\n      { return false }\n\n    // For big changes, we hide the enclosing element during the\n    // update, since that speeds up the operations on most browsers.\n    var selSnapshot = selectionSnapshot(cm);\n    if (toUpdate > 4) { display.lineDiv.style.display = \"none\"; }\n    patchDisplay(cm, display.updateLineNumbers, update.dims);\n    if (toUpdate > 4) { display.lineDiv.style.display = \"\"; }\n    display.renderedView = display.view;\n    // There might have been a widget with a focused element that got\n    // hidden or updated, if so re-focus it.\n    restoreSelection(selSnapshot);\n\n    // Prevent selection and cursors from interfering with the scroll\n    // width and height.\n    removeChildren(display.cursorDiv);\n    removeChildren(display.selectionDiv);\n    display.gutters.style.height = display.sizer.style.minHeight = 0;\n\n    if (different) {\n      display.lastWrapHeight = update.wrapperHeight;\n      display.lastWrapWidth = update.wrapperWidth;\n      startWorker(cm, 400);\n    }\n\n    display.updateLineNumbers = null;\n\n    return true\n  }\n\n  function postUpdateDisplay(cm, update) {\n    var viewport = update.viewport;\n\n    for (var first = true;; first = false) {\n      if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {\n        // Clip forced viewport to actual scrollable area.\n        if (viewport && viewport.top != null)\n          { viewport = {top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)}; }\n        // Updated line heights might result in the drawn area not\n        // actually covering the viewport. Keep looping until it does.\n        update.visible = visibleLines(cm.display, cm.doc, viewport);\n        if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo)\n          { break }\n      } else if (first) {\n        update.visible = visibleLines(cm.display, cm.doc, viewport);\n      }\n      if (!updateDisplayIfNeeded(cm, update)) { break }\n      updateHeightsInViewport(cm);\n      var barMeasure = measureForScrollbars(cm);\n      updateSelection(cm);\n      updateScrollbars(cm, barMeasure);\n      setDocumentHeight(cm, barMeasure);\n      update.force = false;\n    }\n\n    update.signal(cm, \"update\", cm);\n    if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {\n      update.signal(cm, \"viewportChange\", cm, cm.display.viewFrom, cm.display.viewTo);\n      cm.display.reportedViewFrom = cm.display.viewFrom; cm.display.reportedViewTo = cm.display.viewTo;\n    }\n  }\n\n  function updateDisplaySimple(cm, viewport) {\n    var update = new DisplayUpdate(cm, viewport);\n    if (updateDisplayIfNeeded(cm, update)) {\n      updateHeightsInViewport(cm);\n      postUpdateDisplay(cm, update);\n      var barMeasure = measureForScrollbars(cm);\n      updateSelection(cm);\n      updateScrollbars(cm, barMeasure);\n      setDocumentHeight(cm, barMeasure);\n      update.finish();\n    }\n  }\n\n  // Sync the actual display DOM structure with display.view, removing\n  // nodes for lines that are no longer in view, and creating the ones\n  // that are not there yet, and updating the ones that are out of\n  // date.\n  function patchDisplay(cm, updateNumbersFrom, dims) {\n    var display = cm.display, lineNumbers = cm.options.lineNumbers;\n    var container = display.lineDiv, cur = container.firstChild;\n\n    function rm(node) {\n      var next = node.nextSibling;\n      // Works around a throw-scroll bug in OS X Webkit\n      if (webkit && mac && cm.display.currentWheelTarget == node)\n        { node.style.display = \"none\"; }\n      else\n        { node.parentNode.removeChild(node); }\n      return next\n    }\n\n    var view = display.view, lineN = display.viewFrom;\n    // Loop over the elements in the view, syncing cur (the DOM nodes\n    // in display.lineDiv) with the view as we go.\n    for (var i = 0; i < view.length; i++) {\n      var lineView = view[i];\n      if (lineView.hidden) ; else if (!lineView.node || lineView.node.parentNode != container) { // Not drawn yet\n        var node = buildLineElement(cm, lineView, lineN, dims);\n        container.insertBefore(node, cur);\n      } else { // Already drawn\n        while (cur != lineView.node) { cur = rm(cur); }\n        var updateNumber = lineNumbers && updateNumbersFrom != null &&\n          updateNumbersFrom <= lineN && lineView.lineNumber;\n        if (lineView.changes) {\n          if (indexOf(lineView.changes, \"gutter\") > -1) { updateNumber = false; }\n          updateLineForChanges(cm, lineView, lineN, dims);\n        }\n        if (updateNumber) {\n          removeChildren(lineView.lineNumber);\n          lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));\n        }\n        cur = lineView.node.nextSibling;\n      }\n      lineN += lineView.size;\n    }\n    while (cur) { cur = rm(cur); }\n  }\n\n  function updateGutterSpace(display) {\n    var width = display.gutters.offsetWidth;\n    display.sizer.style.marginLeft = width + \"px\";\n  }\n\n  function setDocumentHeight(cm, measure) {\n    cm.display.sizer.style.minHeight = measure.docHeight + \"px\";\n    cm.display.heightForcer.style.top = measure.docHeight + \"px\";\n    cm.display.gutters.style.height = (measure.docHeight + cm.display.barHeight + scrollGap(cm)) + \"px\";\n  }\n\n  // Re-align line numbers and gutter marks to compensate for\n  // horizontal scrolling.\n  function alignHorizontally(cm) {\n    var display = cm.display, view = display.view;\n    if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) { return }\n    var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;\n    var gutterW = display.gutters.offsetWidth, left = comp + \"px\";\n    for (var i = 0; i < view.length; i++) { if (!view[i].hidden) {\n      if (cm.options.fixedGutter) {\n        if (view[i].gutter)\n          { view[i].gutter.style.left = left; }\n        if (view[i].gutterBackground)\n          { view[i].gutterBackground.style.left = left; }\n      }\n      var align = view[i].alignable;\n      if (align) { for (var j = 0; j < align.length; j++)\n        { align[j].style.left = left; } }\n    } }\n    if (cm.options.fixedGutter)\n      { display.gutters.style.left = (comp + gutterW) + \"px\"; }\n  }\n\n  // Used to ensure that the line number gutter is still the right\n  // size for the current document size. Returns true when an update\n  // is needed.\n  function maybeUpdateLineNumberWidth(cm) {\n    if (!cm.options.lineNumbers) { return false }\n    var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;\n    if (last.length != display.lineNumChars) {\n      var test = display.measure.appendChild(elt(\"div\", [elt(\"div\", last)],\n                                                 \"CodeMirror-linenumber CodeMirror-gutter-elt\"));\n      var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;\n      display.lineGutter.style.width = \"\";\n      display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;\n      display.lineNumWidth = display.lineNumInnerWidth + padding;\n      display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;\n      display.lineGutter.style.width = display.lineNumWidth + \"px\";\n      updateGutterSpace(cm.display);\n      return true\n    }\n    return false\n  }\n\n  function getGutters(gutters, lineNumbers) {\n    var result = [], sawLineNumbers = false;\n    for (var i = 0; i < gutters.length; i++) {\n      var name = gutters[i], style = null;\n      if (typeof name != \"string\") { style = name.style; name = name.className; }\n      if (name == \"CodeMirror-linenumbers\") {\n        if (!lineNumbers) { continue }\n        else { sawLineNumbers = true; }\n      }\n      result.push({className: name, style: style});\n    }\n    if (lineNumbers && !sawLineNumbers) { result.push({className: \"CodeMirror-linenumbers\", style: null}); }\n    return result\n  }\n\n  // Rebuild the gutter elements, ensure the margin to the left of the\n  // code matches their width.\n  function renderGutters(display) {\n    var gutters = display.gutters, specs = display.gutterSpecs;\n    removeChildren(gutters);\n    display.lineGutter = null;\n    for (var i = 0; i < specs.length; ++i) {\n      var ref = specs[i];\n      var className = ref.className;\n      var style = ref.style;\n      var gElt = gutters.appendChild(elt(\"div\", null, \"CodeMirror-gutter \" + className));\n      if (style) { gElt.style.cssText = style; }\n      if (className == \"CodeMirror-linenumbers\") {\n        display.lineGutter = gElt;\n        gElt.style.width = (display.lineNumWidth || 1) + \"px\";\n      }\n    }\n    gutters.style.display = specs.length ? \"\" : \"none\";\n    updateGutterSpace(display);\n  }\n\n  function updateGutters(cm) {\n    renderGutters(cm.display);\n    regChange(cm);\n    alignHorizontally(cm);\n  }\n\n  // The display handles the DOM integration, both for input reading\n  // and content drawing. It holds references to DOM nodes and\n  // display-related state.\n\n  function Display(place, doc, input, options) {\n    var d = this;\n    this.input = input;\n\n    // Covers bottom-right square when both scrollbars are present.\n    d.scrollbarFiller = elt(\"div\", null, \"CodeMirror-scrollbar-filler\");\n    d.scrollbarFiller.setAttribute(\"cm-not-content\", \"true\");\n    // Covers bottom of gutter when coverGutterNextToScrollbar is on\n    // and h scrollbar is present.\n    d.gutterFiller = elt(\"div\", null, \"CodeMirror-gutter-filler\");\n    d.gutterFiller.setAttribute(\"cm-not-content\", \"true\");\n    // Will contain the actual code, positioned to cover the viewport.\n    d.lineDiv = eltP(\"div\", null, \"CodeMirror-code\");\n    // Elements are added to these to represent selection and cursors.\n    d.selectionDiv = elt(\"div\", null, null, \"position: relative; z-index: 1\");\n    d.cursorDiv = elt(\"div\", null, \"CodeMirror-cursors\");\n    // A visibility: hidden element used to find the size of things.\n    d.measure = elt(\"div\", null, \"CodeMirror-measure\");\n    // When lines outside of the viewport are measured, they are drawn in this.\n    d.lineMeasure = elt(\"div\", null, \"CodeMirror-measure\");\n    // Wraps everything that needs to exist inside the vertically-padded coordinate system\n    d.lineSpace = eltP(\"div\", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],\n                      null, \"position: relative; outline: none\");\n    var lines = eltP(\"div\", [d.lineSpace], \"CodeMirror-lines\");\n    // Moved around its parent to cover visible view.\n    d.mover = elt(\"div\", [lines], null, \"position: relative\");\n    // Set to the height of the document, allowing scrolling.\n    d.sizer = elt(\"div\", [d.mover], \"CodeMirror-sizer\");\n    d.sizerWidth = null;\n    // Behavior of elts with overflow: auto and padding is\n    // inconsistent across browsers. This is used to ensure the\n    // scrollable area is big enough.\n    d.heightForcer = elt(\"div\", null, null, \"position: absolute; height: \" + scrollerGap + \"px; width: 1px;\");\n    // Will contain the gutters, if any.\n    d.gutters = elt(\"div\", null, \"CodeMirror-gutters\");\n    d.lineGutter = null;\n    // Actual scrollable element.\n    d.scroller = elt(\"div\", [d.sizer, d.heightForcer, d.gutters], \"CodeMirror-scroll\");\n    d.scroller.setAttribute(\"tabIndex\", \"-1\");\n    // The element in which the editor lives.\n    d.wrapper = elt(\"div\", [d.scrollbarFiller, d.gutterFiller, d.scroller], \"CodeMirror\");\n\n    // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)\n    if (ie && ie_version < 8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0; }\n    if (!webkit && !(gecko && mobile)) { d.scroller.draggable = true; }\n\n    if (place) {\n      if (place.appendChild) { place.appendChild(d.wrapper); }\n      else { place(d.wrapper); }\n    }\n\n    // Current rendered range (may be bigger than the view window).\n    d.viewFrom = d.viewTo = doc.first;\n    d.reportedViewFrom = d.reportedViewTo = doc.first;\n    // Information about the rendered lines.\n    d.view = [];\n    d.renderedView = null;\n    // Holds info about a single rendered line when it was rendered\n    // for measurement, while not in view.\n    d.externalMeasured = null;\n    // Empty space (in pixels) above the view\n    d.viewOffset = 0;\n    d.lastWrapHeight = d.lastWrapWidth = 0;\n    d.updateLineNumbers = null;\n\n    d.nativeBarWidth = d.barHeight = d.barWidth = 0;\n    d.scrollbarsClipped = false;\n\n    // Used to only resize the line number gutter when necessary (when\n    // the amount of lines crosses a boundary that makes its width change)\n    d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;\n    // Set to true when a non-horizontal-scrolling line widget is\n    // added. As an optimization, line widget aligning is skipped when\n    // this is false.\n    d.alignWidgets = false;\n\n    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\n\n    // Tracks the maximum line length so that the horizontal scrollbar\n    // can be kept static when scrolling.\n    d.maxLine = null;\n    d.maxLineLength = 0;\n    d.maxLineChanged = false;\n\n    // Used for measuring wheel scrolling granularity\n    d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;\n\n    // True when shift is held down.\n    d.shift = false;\n\n    // Used to track whether anything happened since the context menu\n    // was opened.\n    d.selForContextMenu = null;\n\n    d.activeTouch = null;\n\n    d.gutterSpecs = getGutters(options.gutters, options.lineNumbers);\n    renderGutters(d);\n\n    input.init(d);\n  }\n\n  // Since the delta values reported on mouse wheel events are\n  // unstandardized between browsers and even browser versions, and\n  // generally horribly unpredictable, this code starts by measuring\n  // the scroll effect that the first few mouse wheel events have,\n  // and, from that, detects the way it can convert deltas to pixel\n  // offsets afterwards.\n  //\n  // The reason we want to know the amount a wheel event will scroll\n  // is that it gives us a chance to update the display before the\n  // actual scrolling happens, reducing flickering.\n\n  var wheelSamples = 0, wheelPixelsPerUnit = null;\n  // Fill in a browser-detected starting value on browsers where we\n  // know one. These don't have to be accurate -- the result of them\n  // being wrong would just be a slight flicker on the first wheel\n  // scroll (if it is large enough).\n  if (ie) { wheelPixelsPerUnit = -.53; }\n  else if (gecko) { wheelPixelsPerUnit = 15; }\n  else if (chrome) { wheelPixelsPerUnit = -.7; }\n  else if (safari) { wheelPixelsPerUnit = -1/3; }\n\n  function wheelEventDelta(e) {\n    var dx = e.wheelDeltaX, dy = e.wheelDeltaY;\n    if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) { dx = e.detail; }\n    if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) { dy = e.detail; }\n    else if (dy == null) { dy = e.wheelDelta; }\n    return {x: dx, y: dy}\n  }\n  function wheelEventPixels(e) {\n    var delta = wheelEventDelta(e);\n    delta.x *= wheelPixelsPerUnit;\n    delta.y *= wheelPixelsPerUnit;\n    return delta\n  }\n\n  function onScrollWheel(cm, e) {\n    var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y;\n\n    var display = cm.display, scroll = display.scroller;\n    // Quit if there's nothing to scroll here\n    var canScrollX = scroll.scrollWidth > scroll.clientWidth;\n    var canScrollY = scroll.scrollHeight > scroll.clientHeight;\n    if (!(dx && canScrollX || dy && canScrollY)) { return }\n\n    // Webkit browsers on OS X abort momentum scrolls when the target\n    // of the scroll event is removed from the scrollable element.\n    // This hack (see related code in patchDisplay) makes sure the\n    // element is kept around.\n    if (dy && mac && webkit) {\n      outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {\n        for (var i = 0; i < view.length; i++) {\n          if (view[i].node == cur) {\n            cm.display.currentWheelTarget = cur;\n            break outer\n          }\n        }\n      }\n    }\n\n    // On some browsers, horizontal scrolling will cause redraws to\n    // happen before the gutter has been realigned, causing it to\n    // wriggle around in a most unseemly way. When we have an\n    // estimated pixels/delta value, we just handle horizontal\n    // scrolling entirely here. It'll be slightly off from native, but\n    // better than glitching out.\n    if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {\n      if (dy && canScrollY)\n        { updateScrollTop(cm, Math.max(0, scroll.scrollTop + dy * wheelPixelsPerUnit)); }\n      setScrollLeft(cm, Math.max(0, scroll.scrollLeft + dx * wheelPixelsPerUnit));\n      // Only prevent default scrolling if vertical scrolling is\n      // actually possible. Otherwise, it causes vertical scroll\n      // jitter on OSX trackpads when deltaX is small and deltaY\n      // is large (issue #3579)\n      if (!dy || (dy && canScrollY))\n        { e_preventDefault(e); }\n      display.wheelStartX = null; // Abort measurement, if in progress\n      return\n    }\n\n    // 'Project' the visible viewport to cover the area that is being\n    // scrolled into view (if we know enough to estimate it).\n    if (dy && wheelPixelsPerUnit != null) {\n      var pixels = dy * wheelPixelsPerUnit;\n      var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;\n      if (pixels < 0) { top = Math.max(0, top + pixels - 50); }\n      else { bot = Math.min(cm.doc.height, bot + pixels + 50); }\n      updateDisplaySimple(cm, {top: top, bottom: bot});\n    }\n\n    if (wheelSamples < 20) {\n      if (display.wheelStartX == null) {\n        display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;\n        display.wheelDX = dx; display.wheelDY = dy;\n        setTimeout(function () {\n          if (display.wheelStartX == null) { return }\n          var movedX = scroll.scrollLeft - display.wheelStartX;\n          var movedY = scroll.scrollTop - display.wheelStartY;\n          var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||\n            (movedX && display.wheelDX && movedX / display.wheelDX);\n          display.wheelStartX = display.wheelStartY = null;\n          if (!sample) { return }\n          wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);\n          ++wheelSamples;\n        }, 200);\n      } else {\n        display.wheelDX += dx; display.wheelDY += dy;\n      }\n    }\n  }\n\n  // Selection objects are immutable. A new one is created every time\n  // the selection changes. A selection is one or more non-overlapping\n  // (and non-touching) ranges, sorted, and an integer that indicates\n  // which one is the primary selection (the one that's scrolled into\n  // view, that getCursor returns, etc).\n  var Selection = function(ranges, primIndex) {\n    this.ranges = ranges;\n    this.primIndex = primIndex;\n  };\n\n  Selection.prototype.primary = function () { return this.ranges[this.primIndex] };\n\n  Selection.prototype.equals = function (other) {\n    if (other == this) { return true }\n    if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) { return false }\n    for (var i = 0; i < this.ranges.length; i++) {\n      var here = this.ranges[i], there = other.ranges[i];\n      if (!equalCursorPos(here.anchor, there.anchor) || !equalCursorPos(here.head, there.head)) { return false }\n    }\n    return true\n  };\n\n  Selection.prototype.deepCopy = function () {\n    var out = [];\n    for (var i = 0; i < this.ranges.length; i++)\n      { out[i] = new Range(copyPos(this.ranges[i].anchor), copyPos(this.ranges[i].head)); }\n    return new Selection(out, this.primIndex)\n  };\n\n  Selection.prototype.somethingSelected = function () {\n    for (var i = 0; i < this.ranges.length; i++)\n      { if (!this.ranges[i].empty()) { return true } }\n    return false\n  };\n\n  Selection.prototype.contains = function (pos, end) {\n    if (!end) { end = pos; }\n    for (var i = 0; i < this.ranges.length; i++) {\n      var range = this.ranges[i];\n      if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0)\n        { return i }\n    }\n    return -1\n  };\n\n  var Range = function(anchor, head) {\n    this.anchor = anchor; this.head = head;\n  };\n\n  Range.prototype.from = function () { return minPos(this.anchor, this.head) };\n  Range.prototype.to = function () { return maxPos(this.anchor, this.head) };\n  Range.prototype.empty = function () { return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch };\n\n  // Take an unsorted, potentially overlapping set of ranges, and\n  // build a selection out of it. 'Consumes' ranges array (modifying\n  // it).\n  function normalizeSelection(cm, ranges, primIndex) {\n    var mayTouch = cm && cm.options.selectionsMayTouch;\n    var prim = ranges[primIndex];\n    ranges.sort(function (a, b) { return cmp(a.from(), b.from()); });\n    primIndex = indexOf(ranges, prim);\n    for (var i = 1; i < ranges.length; i++) {\n      var cur = ranges[i], prev = ranges[i - 1];\n      var diff = cmp(prev.to(), cur.from());\n      if (mayTouch && !cur.empty() ? diff > 0 : diff >= 0) {\n        var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());\n        var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;\n        if (i <= primIndex) { --primIndex; }\n        ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));\n      }\n    }\n    return new Selection(ranges, primIndex)\n  }\n\n  function simpleSelection(anchor, head) {\n    return new Selection([new Range(anchor, head || anchor)], 0)\n  }\n\n  // Compute the position of the end of a change (its 'to' property\n  // refers to the pre-change end).\n  function changeEnd(change) {\n    if (!change.text) { return change.to }\n    return Pos(change.from.line + change.text.length - 1,\n               lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0))\n  }\n\n  // Adjust a position to refer to the post-change position of the\n  // same text, or the end of the change if the change covers it.\n  function adjustForChange(pos, change) {\n    if (cmp(pos, change.from) < 0) { return pos }\n    if (cmp(pos, change.to) <= 0) { return changeEnd(change) }\n\n    var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;\n    if (pos.line == change.to.line) { ch += changeEnd(change).ch - change.to.ch; }\n    return Pos(line, ch)\n  }\n\n  function computeSelAfterChange(doc, change) {\n    var out = [];\n    for (var i = 0; i < doc.sel.ranges.length; i++) {\n      var range = doc.sel.ranges[i];\n      out.push(new Range(adjustForChange(range.anchor, change),\n                         adjustForChange(range.head, change)));\n    }\n    return normalizeSelection(doc.cm, out, doc.sel.primIndex)\n  }\n\n  function offsetPos(pos, old, nw) {\n    if (pos.line == old.line)\n      { return Pos(nw.line, pos.ch - old.ch + nw.ch) }\n    else\n      { return Pos(nw.line + (pos.line - old.line), pos.ch) }\n  }\n\n  // Used by replaceSelections to allow moving the selection to the\n  // start or around the replaced test. Hint may be \"start\" or \"around\".\n  function computeReplacedSel(doc, changes, hint) {\n    var out = [];\n    var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;\n    for (var i = 0; i < changes.length; i++) {\n      var change = changes[i];\n      var from = offsetPos(change.from, oldPrev, newPrev);\n      var to = offsetPos(changeEnd(change), oldPrev, newPrev);\n      oldPrev = change.to;\n      newPrev = to;\n      if (hint == \"around\") {\n        var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0;\n        out[i] = new Range(inv ? to : from, inv ? from : to);\n      } else {\n        out[i] = new Range(from, from);\n      }\n    }\n    return new Selection(out, doc.sel.primIndex)\n  }\n\n  // Used to get the editor into a consistent state again when options change.\n\n  function loadMode(cm) {\n    cm.doc.mode = getMode(cm.options, cm.doc.modeOption);\n    resetModeState(cm);\n  }\n\n  function resetModeState(cm) {\n    cm.doc.iter(function (line) {\n      if (line.stateAfter) { line.stateAfter = null; }\n      if (line.styles) { line.styles = null; }\n    });\n    cm.doc.modeFrontier = cm.doc.highlightFrontier = cm.doc.first;\n    startWorker(cm, 100);\n    cm.state.modeGen++;\n    if (cm.curOp) { regChange(cm); }\n  }\n\n  // DOCUMENT DATA STRUCTURE\n\n  // By default, updates that start and end at the beginning of a line\n  // are treated specially, in order to make the association of line\n  // widgets and marker elements with the text behave more intuitive.\n  function isWholeLineUpdate(doc, change) {\n    return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == \"\" &&\n      (!doc.cm || doc.cm.options.wholeLineUpdateBefore)\n  }\n\n  // Perform a change on the document data structure.\n  function updateDoc(doc, change, markedSpans, estimateHeight) {\n    function spansFor(n) {return markedSpans ? markedSpans[n] : null}\n    function update(line, text, spans) {\n      updateLine(line, text, spans, estimateHeight);\n      signalLater(line, \"change\", line, change);\n    }\n    function linesFor(start, end) {\n      var result = [];\n      for (var i = start; i < end; ++i)\n        { result.push(new Line(text[i], spansFor(i), estimateHeight)); }\n      return result\n    }\n\n    var from = change.from, to = change.to, text = change.text;\n    var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);\n    var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;\n\n    // Adjust the line structure\n    if (change.full) {\n      doc.insert(0, linesFor(0, text.length));\n      doc.remove(text.length, doc.size - text.length);\n    } else if (isWholeLineUpdate(doc, change)) {\n      // This is a whole-line replace. Treated specially to make\n      // sure line objects move the way they are supposed to.\n      var added = linesFor(0, text.length - 1);\n      update(lastLine, lastLine.text, lastSpans);\n      if (nlines) { doc.remove(from.line, nlines); }\n      if (added.length) { doc.insert(from.line, added); }\n    } else if (firstLine == lastLine) {\n      if (text.length == 1) {\n        update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);\n      } else {\n        var added$1 = linesFor(1, text.length - 1);\n        added$1.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight));\n        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\n        doc.insert(from.line + 1, added$1);\n      }\n    } else if (text.length == 1) {\n      update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));\n      doc.remove(from.line + 1, nlines);\n    } else {\n      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\n      update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);\n      var added$2 = linesFor(1, text.length - 1);\n      if (nlines > 1) { doc.remove(from.line + 1, nlines - 1); }\n      doc.insert(from.line + 1, added$2);\n    }\n\n    signalLater(doc, \"change\", doc, change);\n  }\n\n  // Call f for all linked documents.\n  function linkedDocs(doc, f, sharedHistOnly) {\n    function propagate(doc, skip, sharedHist) {\n      if (doc.linked) { for (var i = 0; i < doc.linked.length; ++i) {\n        var rel = doc.linked[i];\n        if (rel.doc == skip) { continue }\n        var shared = sharedHist && rel.sharedHist;\n        if (sharedHistOnly && !shared) { continue }\n        f(rel.doc, shared);\n        propagate(rel.doc, doc, shared);\n      } }\n    }\n    propagate(doc, null, true);\n  }\n\n  // Attach a document to an editor.\n  function attachDoc(cm, doc) {\n    if (doc.cm) { throw new Error(\"This document is already in use.\") }\n    cm.doc = doc;\n    doc.cm = cm;\n    estimateLineHeights(cm);\n    loadMode(cm);\n    setDirectionClass(cm);\n    if (!cm.options.lineWrapping) { findMaxLine(cm); }\n    cm.options.mode = doc.modeOption;\n    regChange(cm);\n  }\n\n  function setDirectionClass(cm) {\n  (cm.doc.direction == \"rtl\" ? addClass : rmClass)(cm.display.lineDiv, \"CodeMirror-rtl\");\n  }\n\n  function directionChanged(cm) {\n    runInOp(cm, function () {\n      setDirectionClass(cm);\n      regChange(cm);\n    });\n  }\n\n  function History(startGen) {\n    // Arrays of change events and selections. Doing something adds an\n    // event to done and clears undo. Undoing moves events from done\n    // to undone, redoing moves them in the other direction.\n    this.done = []; this.undone = [];\n    this.undoDepth = Infinity;\n    // Used to track when changes can be merged into a single undo\n    // event\n    this.lastModTime = this.lastSelTime = 0;\n    this.lastOp = this.lastSelOp = null;\n    this.lastOrigin = this.lastSelOrigin = null;\n    // Used by the isClean() method\n    this.generation = this.maxGeneration = startGen || 1;\n  }\n\n  // Create a history change event from an updateDoc-style change\n  // object.\n  function historyChangeFromChange(doc, change) {\n    var histChange = {from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to)};\n    attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);\n    linkedDocs(doc, function (doc) { return attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1); }, true);\n    return histChange\n  }\n\n  // Pop all selection events off the end of a history array. Stop at\n  // a change event.\n  function clearSelectionEvents(array) {\n    while (array.length) {\n      var last = lst(array);\n      if (last.ranges) { array.pop(); }\n      else { break }\n    }\n  }\n\n  // Find the top change event in the history. Pop off selection\n  // events that are in the way.\n  function lastChangeEvent(hist, force) {\n    if (force) {\n      clearSelectionEvents(hist.done);\n      return lst(hist.done)\n    } else if (hist.done.length && !lst(hist.done).ranges) {\n      return lst(hist.done)\n    } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {\n      hist.done.pop();\n      return lst(hist.done)\n    }\n  }\n\n  // Register a change in the history. Merges changes that are within\n  // a single operation, or are close together with an origin that\n  // allows merging (starting with \"+\") into a single event.\n  function addChangeToHistory(doc, change, selAfter, opId) {\n    var hist = doc.history;\n    hist.undone.length = 0;\n    var time = +new Date, cur;\n    var last;\n\n    if ((hist.lastOp == opId ||\n         hist.lastOrigin == change.origin && change.origin &&\n         ((change.origin.charAt(0) == \"+\" && hist.lastModTime > time - (doc.cm ? doc.cm.options.historyEventDelay : 500)) ||\n          change.origin.charAt(0) == \"*\")) &&\n        (cur = lastChangeEvent(hist, hist.lastOp == opId))) {\n      // Merge this change into the last event\n      last = lst(cur.changes);\n      if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {\n        // Optimized case for simple insertion -- don't want to add\n        // new changesets for every character typed\n        last.to = changeEnd(change);\n      } else {\n        // Add new sub-event\n        cur.changes.push(historyChangeFromChange(doc, change));\n      }\n    } else {\n      // Can not be merged, start a new event.\n      var before = lst(hist.done);\n      if (!before || !before.ranges)\n        { pushSelectionToHistory(doc.sel, hist.done); }\n      cur = {changes: [historyChangeFromChange(doc, change)],\n             generation: hist.generation};\n      hist.done.push(cur);\n      while (hist.done.length > hist.undoDepth) {\n        hist.done.shift();\n        if (!hist.done[0].ranges) { hist.done.shift(); }\n      }\n    }\n    hist.done.push(selAfter);\n    hist.generation = ++hist.maxGeneration;\n    hist.lastModTime = hist.lastSelTime = time;\n    hist.lastOp = hist.lastSelOp = opId;\n    hist.lastOrigin = hist.lastSelOrigin = change.origin;\n\n    if (!last) { signal(doc, \"historyAdded\"); }\n  }\n\n  function selectionEventCanBeMerged(doc, origin, prev, sel) {\n    var ch = origin.charAt(0);\n    return ch == \"*\" ||\n      ch == \"+\" &&\n      prev.ranges.length == sel.ranges.length &&\n      prev.somethingSelected() == sel.somethingSelected() &&\n      new Date - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500)\n  }\n\n  // Called whenever the selection changes, sets the new selection as\n  // the pending selection in the history, and pushes the old pending\n  // selection into the 'done' array when it was significantly\n  // different (in number of selected ranges, emptiness, or time).\n  function addSelectionToHistory(doc, sel, opId, options) {\n    var hist = doc.history, origin = options && options.origin;\n\n    // A new event is started when the previous origin does not match\n    // the current, or the origins don't allow matching. Origins\n    // starting with * are always merged, those starting with + are\n    // merged when similar and close together in time.\n    if (opId == hist.lastSelOp ||\n        (origin && hist.lastSelOrigin == origin &&\n         (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin ||\n          selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))))\n      { hist.done[hist.done.length - 1] = sel; }\n    else\n      { pushSelectionToHistory(sel, hist.done); }\n\n    hist.lastSelTime = +new Date;\n    hist.lastSelOrigin = origin;\n    hist.lastSelOp = opId;\n    if (options && options.clearRedo !== false)\n      { clearSelectionEvents(hist.undone); }\n  }\n\n  function pushSelectionToHistory(sel, dest) {\n    var top = lst(dest);\n    if (!(top && top.ranges && top.equals(sel)))\n      { dest.push(sel); }\n  }\n\n  // Used to store marked span information in the history.\n  function attachLocalSpans(doc, change, from, to) {\n    var existing = change[\"spans_\" + doc.id], n = 0;\n    doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function (line) {\n      if (line.markedSpans)\n        { (existing || (existing = change[\"spans_\" + doc.id] = {}))[n] = line.markedSpans; }\n      ++n;\n    });\n  }\n\n  // When un/re-doing restores text containing marked spans, those\n  // that have been explicitly cleared should not be restored.\n  function removeClearedSpans(spans) {\n    if (!spans) { return null }\n    var out;\n    for (var i = 0; i < spans.length; ++i) {\n      if (spans[i].marker.explicitlyCleared) { if (!out) { out = spans.slice(0, i); } }\n      else if (out) { out.push(spans[i]); }\n    }\n    return !out ? spans : out.length ? out : null\n  }\n\n  // Retrieve and filter the old marked spans stored in a change event.\n  function getOldSpans(doc, change) {\n    var found = change[\"spans_\" + doc.id];\n    if (!found) { return null }\n    var nw = [];\n    for (var i = 0; i < change.text.length; ++i)\n      { nw.push(removeClearedSpans(found[i])); }\n    return nw\n  }\n\n  // Used for un/re-doing changes from the history. Combines the\n  // result of computing the existing spans with the set of spans that\n  // existed in the history (so that deleting around a span and then\n  // undoing brings back the span).\n  function mergeOldSpans(doc, change) {\n    var old = getOldSpans(doc, change);\n    var stretched = stretchSpansOverChange(doc, change);\n    if (!old) { return stretched }\n    if (!stretched) { return old }\n\n    for (var i = 0; i < old.length; ++i) {\n      var oldCur = old[i], stretchCur = stretched[i];\n      if (oldCur && stretchCur) {\n        spans: for (var j = 0; j < stretchCur.length; ++j) {\n          var span = stretchCur[j];\n          for (var k = 0; k < oldCur.length; ++k)\n            { if (oldCur[k].marker == span.marker) { continue spans } }\n          oldCur.push(span);\n        }\n      } else if (stretchCur) {\n        old[i] = stretchCur;\n      }\n    }\n    return old\n  }\n\n  // Used both to provide a JSON-safe object in .getHistory, and, when\n  // detaching a document, to split the history in two\n  function copyHistoryArray(events, newGroup, instantiateSel) {\n    var copy = [];\n    for (var i = 0; i < events.length; ++i) {\n      var event = events[i];\n      if (event.ranges) {\n        copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);\n        continue\n      }\n      var changes = event.changes, newChanges = [];\n      copy.push({changes: newChanges});\n      for (var j = 0; j < changes.length; ++j) {\n        var change = changes[j], m = (void 0);\n        newChanges.push({from: change.from, to: change.to, text: change.text});\n        if (newGroup) { for (var prop in change) { if (m = prop.match(/^spans_(\\d+)$/)) {\n          if (indexOf(newGroup, Number(m[1])) > -1) {\n            lst(newChanges)[prop] = change[prop];\n            delete change[prop];\n          }\n        } } }\n      }\n    }\n    return copy\n  }\n\n  // The 'scroll' parameter given to many of these indicated whether\n  // the new cursor position should be scrolled into view after\n  // modifying the selection.\n\n  // If shift is held or the extend flag is set, extends a range to\n  // include a given position (and optionally a second position).\n  // Otherwise, simply returns the range between the given positions.\n  // Used for cursor motion and such.\n  function extendRange(range, head, other, extend) {\n    if (extend) {\n      var anchor = range.anchor;\n      if (other) {\n        var posBefore = cmp(head, anchor) < 0;\n        if (posBefore != (cmp(other, anchor) < 0)) {\n          anchor = head;\n          head = other;\n        } else if (posBefore != (cmp(head, other) < 0)) {\n          head = other;\n        }\n      }\n      return new Range(anchor, head)\n    } else {\n      return new Range(other || head, head)\n    }\n  }\n\n  // Extend the primary selection range, discard the rest.\n  function extendSelection(doc, head, other, options, extend) {\n    if (extend == null) { extend = doc.cm && (doc.cm.display.shift || doc.extend); }\n    setSelection(doc, new Selection([extendRange(doc.sel.primary(), head, other, extend)], 0), options);\n  }\n\n  // Extend all selections (pos is an array of selections with length\n  // equal the number of selections)\n  function extendSelections(doc, heads, options) {\n    var out = [];\n    var extend = doc.cm && (doc.cm.display.shift || doc.extend);\n    for (var i = 0; i < doc.sel.ranges.length; i++)\n      { out[i] = extendRange(doc.sel.ranges[i], heads[i], null, extend); }\n    var newSel = normalizeSelection(doc.cm, out, doc.sel.primIndex);\n    setSelection(doc, newSel, options);\n  }\n\n  // Updates a single range in the selection.\n  function replaceOneSelection(doc, i, range, options) {\n    var ranges = doc.sel.ranges.slice(0);\n    ranges[i] = range;\n    setSelection(doc, normalizeSelection(doc.cm, ranges, doc.sel.primIndex), options);\n  }\n\n  // Reset the selection to a single range.\n  function setSimpleSelection(doc, anchor, head, options) {\n    setSelection(doc, simpleSelection(anchor, head), options);\n  }\n\n  // Give beforeSelectionChange handlers a change to influence a\n  // selection update.\n  function filterSelectionChange(doc, sel, options) {\n    var obj = {\n      ranges: sel.ranges,\n      update: function(ranges) {\n        this.ranges = [];\n        for (var i = 0; i < ranges.length; i++)\n          { this.ranges[i] = new Range(clipPos(doc, ranges[i].anchor),\n                                     clipPos(doc, ranges[i].head)); }\n      },\n      origin: options && options.origin\n    };\n    signal(doc, \"beforeSelectionChange\", doc, obj);\n    if (doc.cm) { signal(doc.cm, \"beforeSelectionChange\", doc.cm, obj); }\n    if (obj.ranges != sel.ranges) { return normalizeSelection(doc.cm, obj.ranges, obj.ranges.length - 1) }\n    else { return sel }\n  }\n\n  function setSelectionReplaceHistory(doc, sel, options) {\n    var done = doc.history.done, last = lst(done);\n    if (last && last.ranges) {\n      done[done.length - 1] = sel;\n      setSelectionNoUndo(doc, sel, options);\n    } else {\n      setSelection(doc, sel, options);\n    }\n  }\n\n  // Set a new selection.\n  function setSelection(doc, sel, options) {\n    setSelectionNoUndo(doc, sel, options);\n    addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);\n  }\n\n  function setSelectionNoUndo(doc, sel, options) {\n    if (hasHandler(doc, \"beforeSelectionChange\") || doc.cm && hasHandler(doc.cm, \"beforeSelectionChange\"))\n      { sel = filterSelectionChange(doc, sel, options); }\n\n    var bias = options && options.bias ||\n      (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);\n    setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));\n\n    if (!(options && options.scroll === false) && doc.cm)\n      { ensureCursorVisible(doc.cm); }\n  }\n\n  function setSelectionInner(doc, sel) {\n    if (sel.equals(doc.sel)) { return }\n\n    doc.sel = sel;\n\n    if (doc.cm) {\n      doc.cm.curOp.updateInput = 1;\n      doc.cm.curOp.selectionChanged = true;\n      signalCursorActivity(doc.cm);\n    }\n    signalLater(doc, \"cursorActivity\", doc);\n  }\n\n  // Verify that the selection does not partially select any atomic\n  // marked ranges.\n  function reCheckSelection(doc) {\n    setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false));\n  }\n\n  // Return a selection that does not partially select any atomic\n  // ranges.\n  function skipAtomicInSelection(doc, sel, bias, mayClear) {\n    var out;\n    for (var i = 0; i < sel.ranges.length; i++) {\n      var range = sel.ranges[i];\n      var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i];\n      var newAnchor = skipAtomic(doc, range.anchor, old && old.anchor, bias, mayClear);\n      var newHead = skipAtomic(doc, range.head, old && old.head, bias, mayClear);\n      if (out || newAnchor != range.anchor || newHead != range.head) {\n        if (!out) { out = sel.ranges.slice(0, i); }\n        out[i] = new Range(newAnchor, newHead);\n      }\n    }\n    return out ? normalizeSelection(doc.cm, out, sel.primIndex) : sel\n  }\n\n  function skipAtomicInner(doc, pos, oldPos, dir, mayClear) {\n    var line = getLine(doc, pos.line);\n    if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {\n      var sp = line.markedSpans[i], m = sp.marker;\n\n      // Determine if we should prevent the cursor being placed to the left/right of an atomic marker\n      // Historically this was determined using the inclusiveLeft/Right option, but the new way to control it\n      // is with selectLeft/Right\n      var preventCursorLeft = (\"selectLeft\" in m) ? !m.selectLeft : m.inclusiveLeft;\n      var preventCursorRight = (\"selectRight\" in m) ? !m.selectRight : m.inclusiveRight;\n\n      if ((sp.from == null || (preventCursorLeft ? sp.from <= pos.ch : sp.from < pos.ch)) &&\n          (sp.to == null || (preventCursorRight ? sp.to >= pos.ch : sp.to > pos.ch))) {\n        if (mayClear) {\n          signal(m, \"beforeCursorEnter\");\n          if (m.explicitlyCleared) {\n            if (!line.markedSpans) { break }\n            else {--i; continue}\n          }\n        }\n        if (!m.atomic) { continue }\n\n        if (oldPos) {\n          var near = m.find(dir < 0 ? 1 : -1), diff = (void 0);\n          if (dir < 0 ? preventCursorRight : preventCursorLeft)\n            { near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null); }\n          if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0))\n            { return skipAtomicInner(doc, near, pos, dir, mayClear) }\n        }\n\n        var far = m.find(dir < 0 ? -1 : 1);\n        if (dir < 0 ? preventCursorLeft : preventCursorRight)\n          { far = movePos(doc, far, dir, far.line == pos.line ? line : null); }\n        return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null\n      }\n    } }\n    return pos\n  }\n\n  // Ensure a given position is not inside an atomic range.\n  function skipAtomic(doc, pos, oldPos, bias, mayClear) {\n    var dir = bias || 1;\n    var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) ||\n        (!mayClear && skipAtomicInner(doc, pos, oldPos, dir, true)) ||\n        skipAtomicInner(doc, pos, oldPos, -dir, mayClear) ||\n        (!mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true));\n    if (!found) {\n      doc.cantEdit = true;\n      return Pos(doc.first, 0)\n    }\n    return found\n  }\n\n  function movePos(doc, pos, dir, line) {\n    if (dir < 0 && pos.ch == 0) {\n      if (pos.line > doc.first) { return clipPos(doc, Pos(pos.line - 1)) }\n      else { return null }\n    } else if (dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length) {\n      if (pos.line < doc.first + doc.size - 1) { return Pos(pos.line + 1, 0) }\n      else { return null }\n    } else {\n      return new Pos(pos.line, pos.ch + dir)\n    }\n  }\n\n  function selectAll(cm) {\n    cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);\n  }\n\n  // UPDATING\n\n  // Allow \"beforeChange\" event handlers to influence a change\n  function filterChange(doc, change, update) {\n    var obj = {\n      canceled: false,\n      from: change.from,\n      to: change.to,\n      text: change.text,\n      origin: change.origin,\n      cancel: function () { return obj.canceled = true; }\n    };\n    if (update) { obj.update = function (from, to, text, origin) {\n      if (from) { obj.from = clipPos(doc, from); }\n      if (to) { obj.to = clipPos(doc, to); }\n      if (text) { obj.text = text; }\n      if (origin !== undefined) { obj.origin = origin; }\n    }; }\n    signal(doc, \"beforeChange\", doc, obj);\n    if (doc.cm) { signal(doc.cm, \"beforeChange\", doc.cm, obj); }\n\n    if (obj.canceled) {\n      if (doc.cm) { doc.cm.curOp.updateInput = 2; }\n      return null\n    }\n    return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin}\n  }\n\n  // Apply a change to a document, and add it to the document's\n  // history, and propagating it to all linked documents.\n  function makeChange(doc, change, ignoreReadOnly) {\n    if (doc.cm) {\n      if (!doc.cm.curOp) { return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly) }\n      if (doc.cm.state.suppressEdits) { return }\n    }\n\n    if (hasHandler(doc, \"beforeChange\") || doc.cm && hasHandler(doc.cm, \"beforeChange\")) {\n      change = filterChange(doc, change, true);\n      if (!change) { return }\n    }\n\n    // Possibly split or suppress the update based on the presence\n    // of read-only spans in its range.\n    var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);\n    if (split) {\n      for (var i = split.length - 1; i >= 0; --i)\n        { makeChangeInner(doc, {from: split[i].from, to: split[i].to, text: i ? [\"\"] : change.text, origin: change.origin}); }\n    } else {\n      makeChangeInner(doc, change);\n    }\n  }\n\n  function makeChangeInner(doc, change) {\n    if (change.text.length == 1 && change.text[0] == \"\" && cmp(change.from, change.to) == 0) { return }\n    var selAfter = computeSelAfterChange(doc, change);\n    addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);\n\n    makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));\n    var rebased = [];\n\n    linkedDocs(doc, function (doc, sharedHist) {\n      if (!sharedHist && indexOf(rebased, doc.history) == -1) {\n        rebaseHist(doc.history, change);\n        rebased.push(doc.history);\n      }\n      makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));\n    });\n  }\n\n  // Revert a change stored in a document's history.\n  function makeChangeFromHistory(doc, type, allowSelectionOnly) {\n    var suppress = doc.cm && doc.cm.state.suppressEdits;\n    if (suppress && !allowSelectionOnly) { return }\n\n    var hist = doc.history, event, selAfter = doc.sel;\n    var source = type == \"undo\" ? hist.done : hist.undone, dest = type == \"undo\" ? hist.undone : hist.done;\n\n    // Verify that there is a useable event (so that ctrl-z won't\n    // needlessly clear selection events)\n    var i = 0;\n    for (; i < source.length; i++) {\n      event = source[i];\n      if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges)\n        { break }\n    }\n    if (i == source.length) { return }\n    hist.lastOrigin = hist.lastSelOrigin = null;\n\n    for (;;) {\n      event = source.pop();\n      if (event.ranges) {\n        pushSelectionToHistory(event, dest);\n        if (allowSelectionOnly && !event.equals(doc.sel)) {\n          setSelection(doc, event, {clearRedo: false});\n          return\n        }\n        selAfter = event;\n      } else if (suppress) {\n        source.push(event);\n        return\n      } else { break }\n    }\n\n    // Build up a reverse change object to add to the opposite history\n    // stack (redo when undoing, and vice versa).\n    var antiChanges = [];\n    pushSelectionToHistory(selAfter, dest);\n    dest.push({changes: antiChanges, generation: hist.generation});\n    hist.generation = event.generation || ++hist.maxGeneration;\n\n    var filter = hasHandler(doc, \"beforeChange\") || doc.cm && hasHandler(doc.cm, \"beforeChange\");\n\n    var loop = function ( i ) {\n      var change = event.changes[i];\n      change.origin = type;\n      if (filter && !filterChange(doc, change, false)) {\n        source.length = 0;\n        return {}\n      }\n\n      antiChanges.push(historyChangeFromChange(doc, change));\n\n      var after = i ? computeSelAfterChange(doc, change) : lst(source);\n      makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));\n      if (!i && doc.cm) { doc.cm.scrollIntoView({from: change.from, to: changeEnd(change)}); }\n      var rebased = [];\n\n      // Propagate to the linked documents\n      linkedDocs(doc, function (doc, sharedHist) {\n        if (!sharedHist && indexOf(rebased, doc.history) == -1) {\n          rebaseHist(doc.history, change);\n          rebased.push(doc.history);\n        }\n        makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));\n      });\n    };\n\n    for (var i$1 = event.changes.length - 1; i$1 >= 0; --i$1) {\n      var returned = loop( i$1 );\n\n      if ( returned ) return returned.v;\n    }\n  }\n\n  // Sub-views need their line numbers shifted when text is added\n  // above or below them in the parent document.\n  function shiftDoc(doc, distance) {\n    if (distance == 0) { return }\n    doc.first += distance;\n    doc.sel = new Selection(map(doc.sel.ranges, function (range) { return new Range(\n      Pos(range.anchor.line + distance, range.anchor.ch),\n      Pos(range.head.line + distance, range.head.ch)\n    ); }), doc.sel.primIndex);\n    if (doc.cm) {\n      regChange(doc.cm, doc.first, doc.first - distance, distance);\n      for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++)\n        { regLineChange(doc.cm, l, \"gutter\"); }\n    }\n  }\n\n  // More lower-level change function, handling only a single document\n  // (not linked ones).\n  function makeChangeSingleDoc(doc, change, selAfter, spans) {\n    if (doc.cm && !doc.cm.curOp)\n      { return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans) }\n\n    if (change.to.line < doc.first) {\n      shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));\n      return\n    }\n    if (change.from.line > doc.lastLine()) { return }\n\n    // Clip the change to the size of this doc\n    if (change.from.line < doc.first) {\n      var shift = change.text.length - 1 - (doc.first - change.from.line);\n      shiftDoc(doc, shift);\n      change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),\n                text: [lst(change.text)], origin: change.origin};\n    }\n    var last = doc.lastLine();\n    if (change.to.line > last) {\n      change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),\n                text: [change.text[0]], origin: change.origin};\n    }\n\n    change.removed = getBetween(doc, change.from, change.to);\n\n    if (!selAfter) { selAfter = computeSelAfterChange(doc, change); }\n    if (doc.cm) { makeChangeSingleDocInEditor(doc.cm, change, spans); }\n    else { updateDoc(doc, change, spans); }\n    setSelectionNoUndo(doc, selAfter, sel_dontScroll);\n\n    if (doc.cantEdit && skipAtomic(doc, Pos(doc.firstLine(), 0)))\n      { doc.cantEdit = false; }\n  }\n\n  // Handle the interaction of a change to a document with the editor\n  // that this document is part of.\n  function makeChangeSingleDocInEditor(cm, change, spans) {\n    var doc = cm.doc, display = cm.display, from = change.from, to = change.to;\n\n    var recomputeMaxLength = false, checkWidthStart = from.line;\n    if (!cm.options.lineWrapping) {\n      checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));\n      doc.iter(checkWidthStart, to.line + 1, function (line) {\n        if (line == display.maxLine) {\n          recomputeMaxLength = true;\n          return true\n        }\n      });\n    }\n\n    if (doc.sel.contains(change.from, change.to) > -1)\n      { signalCursorActivity(cm); }\n\n    updateDoc(doc, change, spans, estimateHeight(cm));\n\n    if (!cm.options.lineWrapping) {\n      doc.iter(checkWidthStart, from.line + change.text.length, function (line) {\n        var len = lineLength(line);\n        if (len > display.maxLineLength) {\n          display.maxLine = line;\n          display.maxLineLength = len;\n          display.maxLineChanged = true;\n          recomputeMaxLength = false;\n        }\n      });\n      if (recomputeMaxLength) { cm.curOp.updateMaxLine = true; }\n    }\n\n    retreatFrontier(doc, from.line);\n    startWorker(cm, 400);\n\n    var lendiff = change.text.length - (to.line - from.line) - 1;\n    // Remember that these lines changed, for updating the display\n    if (change.full)\n      { regChange(cm); }\n    else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change))\n      { regLineChange(cm, from.line, \"text\"); }\n    else\n      { regChange(cm, from.line, to.line + 1, lendiff); }\n\n    var changesHandler = hasHandler(cm, \"changes\"), changeHandler = hasHandler(cm, \"change\");\n    if (changeHandler || changesHandler) {\n      var obj = {\n        from: from, to: to,\n        text: change.text,\n        removed: change.removed,\n        origin: change.origin\n      };\n      if (changeHandler) { signalLater(cm, \"change\", cm, obj); }\n      if (changesHandler) { (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj); }\n    }\n    cm.display.selForContextMenu = null;\n  }\n\n  function replaceRange(doc, code, from, to, origin) {\n    var assign;\n\n    if (!to) { to = from; }\n    if (cmp(to, from) < 0) { (assign = [to, from], from = assign[0], to = assign[1]); }\n    if (typeof code == \"string\") { code = doc.splitLines(code); }\n    makeChange(doc, {from: from, to: to, text: code, origin: origin});\n  }\n\n  // Rebasing/resetting history to deal with externally-sourced changes\n\n  function rebaseHistSelSingle(pos, from, to, diff) {\n    if (to < pos.line) {\n      pos.line += diff;\n    } else if (from < pos.line) {\n      pos.line = from;\n      pos.ch = 0;\n    }\n  }\n\n  // Tries to rebase an array of history events given a change in the\n  // document. If the change touches the same lines as the event, the\n  // event, and everything 'behind' it, is discarded. If the change is\n  // before the event, the event's positions are updated. Uses a\n  // copy-on-write scheme for the positions, to avoid having to\n  // reallocate them all on every rebase, but also avoid problems with\n  // shared position objects being unsafely updated.\n  function rebaseHistArray(array, from, to, diff) {\n    for (var i = 0; i < array.length; ++i) {\n      var sub = array[i], ok = true;\n      if (sub.ranges) {\n        if (!sub.copied) { sub = array[i] = sub.deepCopy(); sub.copied = true; }\n        for (var j = 0; j < sub.ranges.length; j++) {\n          rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);\n          rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);\n        }\n        continue\n      }\n      for (var j$1 = 0; j$1 < sub.changes.length; ++j$1) {\n        var cur = sub.changes[j$1];\n        if (to < cur.from.line) {\n          cur.from = Pos(cur.from.line + diff, cur.from.ch);\n          cur.to = Pos(cur.to.line + diff, cur.to.ch);\n        } else if (from <= cur.to.line) {\n          ok = false;\n          break\n        }\n      }\n      if (!ok) {\n        array.splice(0, i + 1);\n        i = 0;\n      }\n    }\n  }\n\n  function rebaseHist(hist, change) {\n    var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;\n    rebaseHistArray(hist.done, from, to, diff);\n    rebaseHistArray(hist.undone, from, to, diff);\n  }\n\n  // Utility for applying a change to a line by handle or number,\n  // returning the number and optionally registering the line as\n  // changed.\n  function changeLine(doc, handle, changeType, op) {\n    var no = handle, line = handle;\n    if (typeof handle == \"number\") { line = getLine(doc, clipLine(doc, handle)); }\n    else { no = lineNo(handle); }\n    if (no == null) { return null }\n    if (op(line, no) && doc.cm) { regLineChange(doc.cm, no, changeType); }\n    return line\n  }\n\n  // The document is represented as a BTree consisting of leaves, with\n  // chunk of lines in them, and branches, with up to ten leaves or\n  // other branch nodes below them. The top node is always a branch\n  // node, and is the document object itself (meaning it has\n  // additional methods and properties).\n  //\n  // All nodes have parent links. The tree is used both to go from\n  // line numbers to line objects, and to go from objects to numbers.\n  // It also indexes by height, and is used to convert between height\n  // and line object, and to find the total height of the document.\n  //\n  // See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html\n\n  function LeafChunk(lines) {\n    this.lines = lines;\n    this.parent = null;\n    var height = 0;\n    for (var i = 0; i < lines.length; ++i) {\n      lines[i].parent = this;\n      height += lines[i].height;\n    }\n    this.height = height;\n  }\n\n  LeafChunk.prototype = {\n    chunkSize: function() { return this.lines.length },\n\n    // Remove the n lines at offset 'at'.\n    removeInner: function(at, n) {\n      for (var i = at, e = at + n; i < e; ++i) {\n        var line = this.lines[i];\n        this.height -= line.height;\n        cleanUpLine(line);\n        signalLater(line, \"delete\");\n      }\n      this.lines.splice(at, n);\n    },\n\n    // Helper used to collapse a small branch into a single leaf.\n    collapse: function(lines) {\n      lines.push.apply(lines, this.lines);\n    },\n\n    // Insert the given array of lines at offset 'at', count them as\n    // having the given height.\n    insertInner: function(at, lines, height) {\n      this.height += height;\n      this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));\n      for (var i = 0; i < lines.length; ++i) { lines[i].parent = this; }\n    },\n\n    // Used to iterate over a part of the tree.\n    iterN: function(at, n, op) {\n      for (var e = at + n; at < e; ++at)\n        { if (op(this.lines[at])) { return true } }\n    }\n  };\n\n  function BranchChunk(children) {\n    this.children = children;\n    var size = 0, height = 0;\n    for (var i = 0; i < children.length; ++i) {\n      var ch = children[i];\n      size += ch.chunkSize(); height += ch.height;\n      ch.parent = this;\n    }\n    this.size = size;\n    this.height = height;\n    this.parent = null;\n  }\n\n  BranchChunk.prototype = {\n    chunkSize: function() { return this.size },\n\n    removeInner: function(at, n) {\n      this.size -= n;\n      for (var i = 0; i < this.children.length; ++i) {\n        var child = this.children[i], sz = child.chunkSize();\n        if (at < sz) {\n          var rm = Math.min(n, sz - at), oldHeight = child.height;\n          child.removeInner(at, rm);\n          this.height -= oldHeight - child.height;\n          if (sz == rm) { this.children.splice(i--, 1); child.parent = null; }\n          if ((n -= rm) == 0) { break }\n          at = 0;\n        } else { at -= sz; }\n      }\n      // If the result is smaller than 25 lines, ensure that it is a\n      // single leaf node.\n      if (this.size - n < 25 &&\n          (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {\n        var lines = [];\n        this.collapse(lines);\n        this.children = [new LeafChunk(lines)];\n        this.children[0].parent = this;\n      }\n    },\n\n    collapse: function(lines) {\n      for (var i = 0; i < this.children.length; ++i) { this.children[i].collapse(lines); }\n    },\n\n    insertInner: function(at, lines, height) {\n      this.size += lines.length;\n      this.height += height;\n      for (var i = 0; i < this.children.length; ++i) {\n        var child = this.children[i], sz = child.chunkSize();\n        if (at <= sz) {\n          child.insertInner(at, lines, height);\n          if (child.lines && child.lines.length > 50) {\n            // To avoid memory thrashing when child.lines is huge (e.g. first view of a large file), it's never spliced.\n            // Instead, small slices are taken. They're taken in order because sequential memory accesses are fastest.\n            var remaining = child.lines.length % 25 + 25;\n            for (var pos = remaining; pos < child.lines.length;) {\n              var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));\n              child.height -= leaf.height;\n              this.children.splice(++i, 0, leaf);\n              leaf.parent = this;\n            }\n            child.lines = child.lines.slice(0, remaining);\n            this.maybeSpill();\n          }\n          break\n        }\n        at -= sz;\n      }\n    },\n\n    // When a node has grown, check whether it should be split.\n    maybeSpill: function() {\n      if (this.children.length <= 10) { return }\n      var me = this;\n      do {\n        var spilled = me.children.splice(me.children.length - 5, 5);\n        var sibling = new BranchChunk(spilled);\n        if (!me.parent) { // Become the parent node\n          var copy = new BranchChunk(me.children);\n          copy.parent = me;\n          me.children = [copy, sibling];\n          me = copy;\n       } else {\n          me.size -= sibling.size;\n          me.height -= sibling.height;\n          var myIndex = indexOf(me.parent.children, me);\n          me.parent.children.splice(myIndex + 1, 0, sibling);\n        }\n        sibling.parent = me.parent;\n      } while (me.children.length > 10)\n      me.parent.maybeSpill();\n    },\n\n    iterN: function(at, n, op) {\n      for (var i = 0; i < this.children.length; ++i) {\n        var child = this.children[i], sz = child.chunkSize();\n        if (at < sz) {\n          var used = Math.min(n, sz - at);\n          if (child.iterN(at, used, op)) { return true }\n          if ((n -= used) == 0) { break }\n          at = 0;\n        } else { at -= sz; }\n      }\n    }\n  };\n\n  // Line widgets are block elements displayed above or below a line.\n\n  var LineWidget = function(doc, node, options) {\n    if (options) { for (var opt in options) { if (options.hasOwnProperty(opt))\n      { this[opt] = options[opt]; } } }\n    this.doc = doc;\n    this.node = node;\n  };\n\n  LineWidget.prototype.clear = function () {\n    var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);\n    if (no == null || !ws) { return }\n    for (var i = 0; i < ws.length; ++i) { if (ws[i] == this) { ws.splice(i--, 1); } }\n    if (!ws.length) { line.widgets = null; }\n    var height = widgetHeight(this);\n    updateLineHeight(line, Math.max(0, line.height - height));\n    if (cm) {\n      runInOp(cm, function () {\n        adjustScrollWhenAboveVisible(cm, line, -height);\n        regLineChange(cm, no, \"widget\");\n      });\n      signalLater(cm, \"lineWidgetCleared\", cm, this, no);\n    }\n  };\n\n  LineWidget.prototype.changed = function () {\n      var this$1 = this;\n\n    var oldH = this.height, cm = this.doc.cm, line = this.line;\n    this.height = null;\n    var diff = widgetHeight(this) - oldH;\n    if (!diff) { return }\n    if (!lineIsHidden(this.doc, line)) { updateLineHeight(line, line.height + diff); }\n    if (cm) {\n      runInOp(cm, function () {\n        cm.curOp.forceUpdate = true;\n        adjustScrollWhenAboveVisible(cm, line, diff);\n        signalLater(cm, \"lineWidgetChanged\", cm, this$1, lineNo(line));\n      });\n    }\n  };\n  eventMixin(LineWidget);\n\n  function adjustScrollWhenAboveVisible(cm, line, diff) {\n    if (heightAtLine(line) < ((cm.curOp && cm.curOp.scrollTop) || cm.doc.scrollTop))\n      { addToScrollTop(cm, diff); }\n  }\n\n  function addLineWidget(doc, handle, node, options) {\n    var widget = new LineWidget(doc, node, options);\n    var cm = doc.cm;\n    if (cm && widget.noHScroll) { cm.display.alignWidgets = true; }\n    changeLine(doc, handle, \"widget\", function (line) {\n      var widgets = line.widgets || (line.widgets = []);\n      if (widget.insertAt == null) { widgets.push(widget); }\n      else { widgets.splice(Math.min(widgets.length, Math.max(0, widget.insertAt)), 0, widget); }\n      widget.line = line;\n      if (cm && !lineIsHidden(doc, line)) {\n        var aboveVisible = heightAtLine(line) < doc.scrollTop;\n        updateLineHeight(line, line.height + widgetHeight(widget));\n        if (aboveVisible) { addToScrollTop(cm, widget.height); }\n        cm.curOp.forceUpdate = true;\n      }\n      return true\n    });\n    if (cm) { signalLater(cm, \"lineWidgetAdded\", cm, widget, typeof handle == \"number\" ? handle : lineNo(handle)); }\n    return widget\n  }\n\n  // TEXTMARKERS\n\n  // Created with markText and setBookmark methods. A TextMarker is a\n  // handle that can be used to clear or find a marked position in the\n  // document. Line objects hold arrays (markedSpans) containing\n  // {from, to, marker} object pointing to such marker objects, and\n  // indicating that such a marker is present on that line. Multiple\n  // lines may point to the same marker when it spans across lines.\n  // The spans will have null for their from/to properties when the\n  // marker continues beyond the start/end of the line. Markers have\n  // links back to the lines they currently touch.\n\n  // Collapsed markers have unique ids, in order to be able to order\n  // them, which is needed for uniquely determining an outer marker\n  // when they overlap (they may nest, but not partially overlap).\n  var nextMarkerId = 0;\n\n  var TextMarker = function(doc, type) {\n    this.lines = [];\n    this.type = type;\n    this.doc = doc;\n    this.id = ++nextMarkerId;\n  };\n\n  // Clear the marker.\n  TextMarker.prototype.clear = function () {\n    if (this.explicitlyCleared) { return }\n    var cm = this.doc.cm, withOp = cm && !cm.curOp;\n    if (withOp) { startOperation(cm); }\n    if (hasHandler(this, \"clear\")) {\n      var found = this.find();\n      if (found) { signalLater(this, \"clear\", found.from, found.to); }\n    }\n    var min = null, max = null;\n    for (var i = 0; i < this.lines.length; ++i) {\n      var line = this.lines[i];\n      var span = getMarkedSpanFor(line.markedSpans, this);\n      if (cm && !this.collapsed) { regLineChange(cm, lineNo(line), \"text\"); }\n      else if (cm) {\n        if (span.to != null) { max = lineNo(line); }\n        if (span.from != null) { min = lineNo(line); }\n      }\n      line.markedSpans = removeMarkedSpan(line.markedSpans, span);\n      if (span.from == null && this.collapsed && !lineIsHidden(this.doc, line) && cm)\n        { updateLineHeight(line, textHeight(cm.display)); }\n    }\n    if (cm && this.collapsed && !cm.options.lineWrapping) { for (var i$1 = 0; i$1 < this.lines.length; ++i$1) {\n      var visual = visualLine(this.lines[i$1]), len = lineLength(visual);\n      if (len > cm.display.maxLineLength) {\n        cm.display.maxLine = visual;\n        cm.display.maxLineLength = len;\n        cm.display.maxLineChanged = true;\n      }\n    } }\n\n    if (min != null && cm && this.collapsed) { regChange(cm, min, max + 1); }\n    this.lines.length = 0;\n    this.explicitlyCleared = true;\n    if (this.atomic && this.doc.cantEdit) {\n      this.doc.cantEdit = false;\n      if (cm) { reCheckSelection(cm.doc); }\n    }\n    if (cm) { signalLater(cm, \"markerCleared\", cm, this, min, max); }\n    if (withOp) { endOperation(cm); }\n    if (this.parent) { this.parent.clear(); }\n  };\n\n  // Find the position of the marker in the document. Returns a {from,\n  // to} object by default. Side can be passed to get a specific side\n  // -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the\n  // Pos objects returned contain a line object, rather than a line\n  // number (used to prevent looking up the same line twice).\n  TextMarker.prototype.find = function (side, lineObj) {\n    if (side == null && this.type == \"bookmark\") { side = 1; }\n    var from, to;\n    for (var i = 0; i < this.lines.length; ++i) {\n      var line = this.lines[i];\n      var span = getMarkedSpanFor(line.markedSpans, this);\n      if (span.from != null) {\n        from = Pos(lineObj ? line : lineNo(line), span.from);\n        if (side == -1) { return from }\n      }\n      if (span.to != null) {\n        to = Pos(lineObj ? line : lineNo(line), span.to);\n        if (side == 1) { return to }\n      }\n    }\n    return from && {from: from, to: to}\n  };\n\n  // Signals that the marker's widget changed, and surrounding layout\n  // should be recomputed.\n  TextMarker.prototype.changed = function () {\n      var this$1 = this;\n\n    var pos = this.find(-1, true), widget = this, cm = this.doc.cm;\n    if (!pos || !cm) { return }\n    runInOp(cm, function () {\n      var line = pos.line, lineN = lineNo(pos.line);\n      var view = findViewForLine(cm, lineN);\n      if (view) {\n        clearLineMeasurementCacheFor(view);\n        cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;\n      }\n      cm.curOp.updateMaxLine = true;\n      if (!lineIsHidden(widget.doc, line) && widget.height != null) {\n        var oldHeight = widget.height;\n        widget.height = null;\n        var dHeight = widgetHeight(widget) - oldHeight;\n        if (dHeight)\n          { updateLineHeight(line, line.height + dHeight); }\n      }\n      signalLater(cm, \"markerChanged\", cm, this$1);\n    });\n  };\n\n  TextMarker.prototype.attachLine = function (line) {\n    if (!this.lines.length && this.doc.cm) {\n      var op = this.doc.cm.curOp;\n      if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)\n        { (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this); }\n    }\n    this.lines.push(line);\n  };\n\n  TextMarker.prototype.detachLine = function (line) {\n    this.lines.splice(indexOf(this.lines, line), 1);\n    if (!this.lines.length && this.doc.cm) {\n      var op = this.doc.cm.curOp\n      ;(op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);\n    }\n  };\n  eventMixin(TextMarker);\n\n  // Create a marker, wire it up to the right lines, and\n  function markText(doc, from, to, options, type) {\n    // Shared markers (across linked documents) are handled separately\n    // (markTextShared will call out to this again, once per\n    // document).\n    if (options && options.shared) { return markTextShared(doc, from, to, options, type) }\n    // Ensure we are in an operation.\n    if (doc.cm && !doc.cm.curOp) { return operation(doc.cm, markText)(doc, from, to, options, type) }\n\n    var marker = new TextMarker(doc, type), diff = cmp(from, to);\n    if (options) { copyObj(options, marker, false); }\n    // Don't connect empty markers unless clearWhenEmpty is false\n    if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false)\n      { return marker }\n    if (marker.replacedWith) {\n      // Showing up as a widget implies collapsed (widget replaces text)\n      marker.collapsed = true;\n      marker.widgetNode = eltP(\"span\", [marker.replacedWith], \"CodeMirror-widget\");\n      if (!options.handleMouseEvents) { marker.widgetNode.setAttribute(\"cm-ignore-events\", \"true\"); }\n      if (options.insertLeft) { marker.widgetNode.insertLeft = true; }\n    }\n    if (marker.collapsed) {\n      if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||\n          from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))\n        { throw new Error(\"Inserting collapsed marker partially overlapping an existing one\") }\n      seeCollapsedSpans();\n    }\n\n    if (marker.addToHistory)\n      { addChangeToHistory(doc, {from: from, to: to, origin: \"markText\"}, doc.sel, NaN); }\n\n    var curLine = from.line, cm = doc.cm, updateMaxLine;\n    doc.iter(curLine, to.line + 1, function (line) {\n      if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine)\n        { updateMaxLine = true; }\n      if (marker.collapsed && curLine != from.line) { updateLineHeight(line, 0); }\n      addMarkedSpan(line, new MarkedSpan(marker,\n                                         curLine == from.line ? from.ch : null,\n                                         curLine == to.line ? to.ch : null));\n      ++curLine;\n    });\n    // lineIsHidden depends on the presence of the spans, so needs a second pass\n    if (marker.collapsed) { doc.iter(from.line, to.line + 1, function (line) {\n      if (lineIsHidden(doc, line)) { updateLineHeight(line, 0); }\n    }); }\n\n    if (marker.clearOnEnter) { on(marker, \"beforeCursorEnter\", function () { return marker.clear(); }); }\n\n    if (marker.readOnly) {\n      seeReadOnlySpans();\n      if (doc.history.done.length || doc.history.undone.length)\n        { doc.clearHistory(); }\n    }\n    if (marker.collapsed) {\n      marker.id = ++nextMarkerId;\n      marker.atomic = true;\n    }\n    if (cm) {\n      // Sync editor state\n      if (updateMaxLine) { cm.curOp.updateMaxLine = true; }\n      if (marker.collapsed)\n        { regChange(cm, from.line, to.line + 1); }\n      else if (marker.className || marker.startStyle || marker.endStyle || marker.css ||\n               marker.attributes || marker.title)\n        { for (var i = from.line; i <= to.line; i++) { regLineChange(cm, i, \"text\"); } }\n      if (marker.atomic) { reCheckSelection(cm.doc); }\n      signalLater(cm, \"markerAdded\", cm, marker);\n    }\n    return marker\n  }\n\n  // SHARED TEXTMARKERS\n\n  // A shared marker spans multiple linked documents. It is\n  // implemented as a meta-marker-object controlling multiple normal\n  // markers.\n  var SharedTextMarker = function(markers, primary) {\n    this.markers = markers;\n    this.primary = primary;\n    for (var i = 0; i < markers.length; ++i)\n      { markers[i].parent = this; }\n  };\n\n  SharedTextMarker.prototype.clear = function () {\n    if (this.explicitlyCleared) { return }\n    this.explicitlyCleared = true;\n    for (var i = 0; i < this.markers.length; ++i)\n      { this.markers[i].clear(); }\n    signalLater(this, \"clear\");\n  };\n\n  SharedTextMarker.prototype.find = function (side, lineObj) {\n    return this.primary.find(side, lineObj)\n  };\n  eventMixin(SharedTextMarker);\n\n  function markTextShared(doc, from, to, options, type) {\n    options = copyObj(options);\n    options.shared = false;\n    var markers = [markText(doc, from, to, options, type)], primary = markers[0];\n    var widget = options.widgetNode;\n    linkedDocs(doc, function (doc) {\n      if (widget) { options.widgetNode = widget.cloneNode(true); }\n      markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));\n      for (var i = 0; i < doc.linked.length; ++i)\n        { if (doc.linked[i].isParent) { return } }\n      primary = lst(markers);\n    });\n    return new SharedTextMarker(markers, primary)\n  }\n\n  function findSharedMarkers(doc) {\n    return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())), function (m) { return m.parent; })\n  }\n\n  function copySharedMarkers(doc, markers) {\n    for (var i = 0; i < markers.length; i++) {\n      var marker = markers[i], pos = marker.find();\n      var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);\n      if (cmp(mFrom, mTo)) {\n        var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);\n        marker.markers.push(subMark);\n        subMark.parent = marker;\n      }\n    }\n  }\n\n  function detachSharedMarkers(markers) {\n    var loop = function ( i ) {\n      var marker = markers[i], linked = [marker.primary.doc];\n      linkedDocs(marker.primary.doc, function (d) { return linked.push(d); });\n      for (var j = 0; j < marker.markers.length; j++) {\n        var subMarker = marker.markers[j];\n        if (indexOf(linked, subMarker.doc) == -1) {\n          subMarker.parent = null;\n          marker.markers.splice(j--, 1);\n        }\n      }\n    };\n\n    for (var i = 0; i < markers.length; i++) loop( i );\n  }\n\n  var nextDocId = 0;\n  var Doc = function(text, mode, firstLine, lineSep, direction) {\n    if (!(this instanceof Doc)) { return new Doc(text, mode, firstLine, lineSep, direction) }\n    if (firstLine == null) { firstLine = 0; }\n\n    BranchChunk.call(this, [new LeafChunk([new Line(\"\", null)])]);\n    this.first = firstLine;\n    this.scrollTop = this.scrollLeft = 0;\n    this.cantEdit = false;\n    this.cleanGeneration = 1;\n    this.modeFrontier = this.highlightFrontier = firstLine;\n    var start = Pos(firstLine, 0);\n    this.sel = simpleSelection(start);\n    this.history = new History(null);\n    this.id = ++nextDocId;\n    this.modeOption = mode;\n    this.lineSep = lineSep;\n    this.direction = (direction == \"rtl\") ? \"rtl\" : \"ltr\";\n    this.extend = false;\n\n    if (typeof text == \"string\") { text = this.splitLines(text); }\n    updateDoc(this, {from: start, to: start, text: text});\n    setSelection(this, simpleSelection(start), sel_dontScroll);\n  };\n\n  Doc.prototype = createObj(BranchChunk.prototype, {\n    constructor: Doc,\n    // Iterate over the document. Supports two forms -- with only one\n    // argument, it calls that for each line in the document. With\n    // three, it iterates over the range given by the first two (with\n    // the second being non-inclusive).\n    iter: function(from, to, op) {\n      if (op) { this.iterN(from - this.first, to - from, op); }\n      else { this.iterN(this.first, this.first + this.size, from); }\n    },\n\n    // Non-public interface for adding and removing lines.\n    insert: function(at, lines) {\n      var height = 0;\n      for (var i = 0; i < lines.length; ++i) { height += lines[i].height; }\n      this.insertInner(at - this.first, lines, height);\n    },\n    remove: function(at, n) { this.removeInner(at - this.first, n); },\n\n    // From here, the methods are part of the public interface. Most\n    // are also available from CodeMirror (editor) instances.\n\n    getValue: function(lineSep) {\n      var lines = getLines(this, this.first, this.first + this.size);\n      if (lineSep === false) { return lines }\n      return lines.join(lineSep || this.lineSeparator())\n    },\n    setValue: docMethodOp(function(code) {\n      var top = Pos(this.first, 0), last = this.first + this.size - 1;\n      makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),\n                        text: this.splitLines(code), origin: \"setValue\", full: true}, true);\n      if (this.cm) { scrollToCoords(this.cm, 0, 0); }\n      setSelection(this, simpleSelection(top), sel_dontScroll);\n    }),\n    replaceRange: function(code, from, to, origin) {\n      from = clipPos(this, from);\n      to = to ? clipPos(this, to) : from;\n      replaceRange(this, code, from, to, origin);\n    },\n    getRange: function(from, to, lineSep) {\n      var lines = getBetween(this, clipPos(this, from), clipPos(this, to));\n      if (lineSep === false) { return lines }\n      return lines.join(lineSep || this.lineSeparator())\n    },\n\n    getLine: function(line) {var l = this.getLineHandle(line); return l && l.text},\n\n    getLineHandle: function(line) {if (isLine(this, line)) { return getLine(this, line) }},\n    getLineNumber: function(line) {return lineNo(line)},\n\n    getLineHandleVisualStart: function(line) {\n      if (typeof line == \"number\") { line = getLine(this, line); }\n      return visualLine(line)\n    },\n\n    lineCount: function() {return this.size},\n    firstLine: function() {return this.first},\n    lastLine: function() {return this.first + this.size - 1},\n\n    clipPos: function(pos) {return clipPos(this, pos)},\n\n    getCursor: function(start) {\n      var range = this.sel.primary(), pos;\n      if (start == null || start == \"head\") { pos = range.head; }\n      else if (start == \"anchor\") { pos = range.anchor; }\n      else if (start == \"end\" || start == \"to\" || start === false) { pos = range.to(); }\n      else { pos = range.from(); }\n      return pos\n    },\n    listSelections: function() { return this.sel.ranges },\n    somethingSelected: function() {return this.sel.somethingSelected()},\n\n    setCursor: docMethodOp(function(line, ch, options) {\n      setSimpleSelection(this, clipPos(this, typeof line == \"number\" ? Pos(line, ch || 0) : line), null, options);\n    }),\n    setSelection: docMethodOp(function(anchor, head, options) {\n      setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);\n    }),\n    extendSelection: docMethodOp(function(head, other, options) {\n      extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);\n    }),\n    extendSelections: docMethodOp(function(heads, options) {\n      extendSelections(this, clipPosArray(this, heads), options);\n    }),\n    extendSelectionsBy: docMethodOp(function(f, options) {\n      var heads = map(this.sel.ranges, f);\n      extendSelections(this, clipPosArray(this, heads), options);\n    }),\n    setSelections: docMethodOp(function(ranges, primary, options) {\n      if (!ranges.length) { return }\n      var out = [];\n      for (var i = 0; i < ranges.length; i++)\n        { out[i] = new Range(clipPos(this, ranges[i].anchor),\n                           clipPos(this, ranges[i].head)); }\n      if (primary == null) { primary = Math.min(ranges.length - 1, this.sel.primIndex); }\n      setSelection(this, normalizeSelection(this.cm, out, primary), options);\n    }),\n    addSelection: docMethodOp(function(anchor, head, options) {\n      var ranges = this.sel.ranges.slice(0);\n      ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));\n      setSelection(this, normalizeSelection(this.cm, ranges, ranges.length - 1), options);\n    }),\n\n    getSelection: function(lineSep) {\n      var ranges = this.sel.ranges, lines;\n      for (var i = 0; i < ranges.length; i++) {\n        var sel = getBetween(this, ranges[i].from(), ranges[i].to());\n        lines = lines ? lines.concat(sel) : sel;\n      }\n      if (lineSep === false) { return lines }\n      else { return lines.join(lineSep || this.lineSeparator()) }\n    },\n    getSelections: function(lineSep) {\n      var parts = [], ranges = this.sel.ranges;\n      for (var i = 0; i < ranges.length; i++) {\n        var sel = getBetween(this, ranges[i].from(), ranges[i].to());\n        if (lineSep !== false) { sel = sel.join(lineSep || this.lineSeparator()); }\n        parts[i] = sel;\n      }\n      return parts\n    },\n    replaceSelection: function(code, collapse, origin) {\n      var dup = [];\n      for (var i = 0; i < this.sel.ranges.length; i++)\n        { dup[i] = code; }\n      this.replaceSelections(dup, collapse, origin || \"+input\");\n    },\n    replaceSelections: docMethodOp(function(code, collapse, origin) {\n      var changes = [], sel = this.sel;\n      for (var i = 0; i < sel.ranges.length; i++) {\n        var range = sel.ranges[i];\n        changes[i] = {from: range.from(), to: range.to(), text: this.splitLines(code[i]), origin: origin};\n      }\n      var newSel = collapse && collapse != \"end\" && computeReplacedSel(this, changes, collapse);\n      for (var i$1 = changes.length - 1; i$1 >= 0; i$1--)\n        { makeChange(this, changes[i$1]); }\n      if (newSel) { setSelectionReplaceHistory(this, newSel); }\n      else if (this.cm) { ensureCursorVisible(this.cm); }\n    }),\n    undo: docMethodOp(function() {makeChangeFromHistory(this, \"undo\");}),\n    redo: docMethodOp(function() {makeChangeFromHistory(this, \"redo\");}),\n    undoSelection: docMethodOp(function() {makeChangeFromHistory(this, \"undo\", true);}),\n    redoSelection: docMethodOp(function() {makeChangeFromHistory(this, \"redo\", true);}),\n\n    setExtending: function(val) {this.extend = val;},\n    getExtending: function() {return this.extend},\n\n    historySize: function() {\n      var hist = this.history, done = 0, undone = 0;\n      for (var i = 0; i < hist.done.length; i++) { if (!hist.done[i].ranges) { ++done; } }\n      for (var i$1 = 0; i$1 < hist.undone.length; i$1++) { if (!hist.undone[i$1].ranges) { ++undone; } }\n      return {undo: done, redo: undone}\n    },\n    clearHistory: function() {\n      var this$1 = this;\n\n      this.history = new History(this.history.maxGeneration);\n      linkedDocs(this, function (doc) { return doc.history = this$1.history; }, true);\n    },\n\n    markClean: function() {\n      this.cleanGeneration = this.changeGeneration(true);\n    },\n    changeGeneration: function(forceSplit) {\n      if (forceSplit)\n        { this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null; }\n      return this.history.generation\n    },\n    isClean: function (gen) {\n      return this.history.generation == (gen || this.cleanGeneration)\n    },\n\n    getHistory: function() {\n      return {done: copyHistoryArray(this.history.done),\n              undone: copyHistoryArray(this.history.undone)}\n    },\n    setHistory: function(histData) {\n      var hist = this.history = new History(this.history.maxGeneration);\n      hist.done = copyHistoryArray(histData.done.slice(0), null, true);\n      hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);\n    },\n\n    setGutterMarker: docMethodOp(function(line, gutterID, value) {\n      return changeLine(this, line, \"gutter\", function (line) {\n        var markers = line.gutterMarkers || (line.gutterMarkers = {});\n        markers[gutterID] = value;\n        if (!value && isEmpty(markers)) { line.gutterMarkers = null; }\n        return true\n      })\n    }),\n\n    clearGutter: docMethodOp(function(gutterID) {\n      var this$1 = this;\n\n      this.iter(function (line) {\n        if (line.gutterMarkers && line.gutterMarkers[gutterID]) {\n          changeLine(this$1, line, \"gutter\", function () {\n            line.gutterMarkers[gutterID] = null;\n            if (isEmpty(line.gutterMarkers)) { line.gutterMarkers = null; }\n            return true\n          });\n        }\n      });\n    }),\n\n    lineInfo: function(line) {\n      var n;\n      if (typeof line == \"number\") {\n        if (!isLine(this, line)) { return null }\n        n = line;\n        line = getLine(this, line);\n        if (!line) { return null }\n      } else {\n        n = lineNo(line);\n        if (n == null) { return null }\n      }\n      return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,\n              textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,\n              widgets: line.widgets}\n    },\n\n    addLineClass: docMethodOp(function(handle, where, cls) {\n      return changeLine(this, handle, where == \"gutter\" ? \"gutter\" : \"class\", function (line) {\n        var prop = where == \"text\" ? \"textClass\"\n                 : where == \"background\" ? \"bgClass\"\n                 : where == \"gutter\" ? \"gutterClass\" : \"wrapClass\";\n        if (!line[prop]) { line[prop] = cls; }\n        else if (classTest(cls).test(line[prop])) { return false }\n        else { line[prop] += \" \" + cls; }\n        return true\n      })\n    }),\n    removeLineClass: docMethodOp(function(handle, where, cls) {\n      return changeLine(this, handle, where == \"gutter\" ? \"gutter\" : \"class\", function (line) {\n        var prop = where == \"text\" ? \"textClass\"\n                 : where == \"background\" ? \"bgClass\"\n                 : where == \"gutter\" ? \"gutterClass\" : \"wrapClass\";\n        var cur = line[prop];\n        if (!cur) { return false }\n        else if (cls == null) { line[prop] = null; }\n        else {\n          var found = cur.match(classTest(cls));\n          if (!found) { return false }\n          var end = found.index + found[0].length;\n          line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? \"\" : \" \") + cur.slice(end) || null;\n        }\n        return true\n      })\n    }),\n\n    addLineWidget: docMethodOp(function(handle, node, options) {\n      return addLineWidget(this, handle, node, options)\n    }),\n    removeLineWidget: function(widget) { widget.clear(); },\n\n    markText: function(from, to, options) {\n      return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || \"range\")\n    },\n    setBookmark: function(pos, options) {\n      var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),\n                      insertLeft: options && options.insertLeft,\n                      clearWhenEmpty: false, shared: options && options.shared,\n                      handleMouseEvents: options && options.handleMouseEvents};\n      pos = clipPos(this, pos);\n      return markText(this, pos, pos, realOpts, \"bookmark\")\n    },\n    findMarksAt: function(pos) {\n      pos = clipPos(this, pos);\n      var markers = [], spans = getLine(this, pos.line).markedSpans;\n      if (spans) { for (var i = 0; i < spans.length; ++i) {\n        var span = spans[i];\n        if ((span.from == null || span.from <= pos.ch) &&\n            (span.to == null || span.to >= pos.ch))\n          { markers.push(span.marker.parent || span.marker); }\n      } }\n      return markers\n    },\n    findMarks: function(from, to, filter) {\n      from = clipPos(this, from); to = clipPos(this, to);\n      var found = [], lineNo = from.line;\n      this.iter(from.line, to.line + 1, function (line) {\n        var spans = line.markedSpans;\n        if (spans) { for (var i = 0; i < spans.length; i++) {\n          var span = spans[i];\n          if (!(span.to != null && lineNo == from.line && from.ch >= span.to ||\n                span.from == null && lineNo != from.line ||\n                span.from != null && lineNo == to.line && span.from >= to.ch) &&\n              (!filter || filter(span.marker)))\n            { found.push(span.marker.parent || span.marker); }\n        } }\n        ++lineNo;\n      });\n      return found\n    },\n    getAllMarks: function() {\n      var markers = [];\n      this.iter(function (line) {\n        var sps = line.markedSpans;\n        if (sps) { for (var i = 0; i < sps.length; ++i)\n          { if (sps[i].from != null) { markers.push(sps[i].marker); } } }\n      });\n      return markers\n    },\n\n    posFromIndex: function(off) {\n      var ch, lineNo = this.first, sepSize = this.lineSeparator().length;\n      this.iter(function (line) {\n        var sz = line.text.length + sepSize;\n        if (sz > off) { ch = off; return true }\n        off -= sz;\n        ++lineNo;\n      });\n      return clipPos(this, Pos(lineNo, ch))\n    },\n    indexFromPos: function (coords) {\n      coords = clipPos(this, coords);\n      var index = coords.ch;\n      if (coords.line < this.first || coords.ch < 0) { return 0 }\n      var sepSize = this.lineSeparator().length;\n      this.iter(this.first, coords.line, function (line) { // iter aborts when callback returns a truthy value\n        index += line.text.length + sepSize;\n      });\n      return index\n    },\n\n    copy: function(copyHistory) {\n      var doc = new Doc(getLines(this, this.first, this.first + this.size),\n                        this.modeOption, this.first, this.lineSep, this.direction);\n      doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft;\n      doc.sel = this.sel;\n      doc.extend = false;\n      if (copyHistory) {\n        doc.history.undoDepth = this.history.undoDepth;\n        doc.setHistory(this.getHistory());\n      }\n      return doc\n    },\n\n    linkedDoc: function(options) {\n      if (!options) { options = {}; }\n      var from = this.first, to = this.first + this.size;\n      if (options.from != null && options.from > from) { from = options.from; }\n      if (options.to != null && options.to < to) { to = options.to; }\n      var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep, this.direction);\n      if (options.sharedHist) { copy.history = this.history\n      ; }(this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist});\n      copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}];\n      copySharedMarkers(copy, findSharedMarkers(this));\n      return copy\n    },\n    unlinkDoc: function(other) {\n      if (other instanceof CodeMirror) { other = other.doc; }\n      if (this.linked) { for (var i = 0; i < this.linked.length; ++i) {\n        var link = this.linked[i];\n        if (link.doc != other) { continue }\n        this.linked.splice(i, 1);\n        other.unlinkDoc(this);\n        detachSharedMarkers(findSharedMarkers(this));\n        break\n      } }\n      // If the histories were shared, split them again\n      if (other.history == this.history) {\n        var splitIds = [other.id];\n        linkedDocs(other, function (doc) { return splitIds.push(doc.id); }, true);\n        other.history = new History(null);\n        other.history.done = copyHistoryArray(this.history.done, splitIds);\n        other.history.undone = copyHistoryArray(this.history.undone, splitIds);\n      }\n    },\n    iterLinkedDocs: function(f) {linkedDocs(this, f);},\n\n    getMode: function() {return this.mode},\n    getEditor: function() {return this.cm},\n\n    splitLines: function(str) {\n      if (this.lineSep) { return str.split(this.lineSep) }\n      return splitLinesAuto(str)\n    },\n    lineSeparator: function() { return this.lineSep || \"\\n\" },\n\n    setDirection: docMethodOp(function (dir) {\n      if (dir != \"rtl\") { dir = \"ltr\"; }\n      if (dir == this.direction) { return }\n      this.direction = dir;\n      this.iter(function (line) { return line.order = null; });\n      if (this.cm) { directionChanged(this.cm); }\n    })\n  });\n\n  // Public alias.\n  Doc.prototype.eachLine = Doc.prototype.iter;\n\n  // Kludge to work around strange IE behavior where it'll sometimes\n  // re-fire a series of drag-related events right after the drop (#1551)\n  var lastDrop = 0;\n\n  function onDrop(e) {\n    var cm = this;\n    clearDragCursor(cm);\n    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))\n      { return }\n    e_preventDefault(e);\n    if (ie) { lastDrop = +new Date; }\n    var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;\n    if (!pos || cm.isReadOnly()) { return }\n    // Might be a file drop, in which case we simply extract the text\n    // and insert it.\n    if (files && files.length && window.FileReader && window.File) {\n      var n = files.length, text = Array(n), read = 0;\n      var markAsReadAndPasteIfAllFilesAreRead = function () {\n        if (++read == n) {\n          operation(cm, function () {\n            pos = clipPos(cm.doc, pos);\n            var change = {from: pos, to: pos,\n                          text: cm.doc.splitLines(\n                              text.filter(function (t) { return t != null; }).join(cm.doc.lineSeparator())),\n                          origin: \"paste\"};\n            makeChange(cm.doc, change);\n            setSelectionReplaceHistory(cm.doc, simpleSelection(clipPos(cm.doc, pos), clipPos(cm.doc, changeEnd(change))));\n          })();\n        }\n      };\n      var readTextFromFile = function (file, i) {\n        if (cm.options.allowDropFileTypes &&\n            indexOf(cm.options.allowDropFileTypes, file.type) == -1) {\n          markAsReadAndPasteIfAllFilesAreRead();\n          return\n        }\n        var reader = new FileReader;\n        reader.onerror = function () { return markAsReadAndPasteIfAllFilesAreRead(); };\n        reader.onload = function () {\n          var content = reader.result;\n          if (/[\\x00-\\x08\\x0e-\\x1f]{2}/.test(content)) {\n            markAsReadAndPasteIfAllFilesAreRead();\n            return\n          }\n          text[i] = content;\n          markAsReadAndPasteIfAllFilesAreRead();\n        };\n        reader.readAsText(file);\n      };\n      for (var i = 0; i < files.length; i++) { readTextFromFile(files[i], i); }\n    } else { // Normal drop\n      // Don't do a replace if the drop happened inside of the selected text.\n      if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {\n        cm.state.draggingText(e);\n        // Ensure the editor is re-focused\n        setTimeout(function () { return cm.display.input.focus(); }, 20);\n        return\n      }\n      try {\n        var text$1 = e.dataTransfer.getData(\"Text\");\n        if (text$1) {\n          var selected;\n          if (cm.state.draggingText && !cm.state.draggingText.copy)\n            { selected = cm.listSelections(); }\n          setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));\n          if (selected) { for (var i$1 = 0; i$1 < selected.length; ++i$1)\n            { replaceRange(cm.doc, \"\", selected[i$1].anchor, selected[i$1].head, \"drag\"); } }\n          cm.replaceSelection(text$1, \"around\", \"paste\");\n          cm.display.input.focus();\n        }\n      }\n      catch(e$1){}\n    }\n  }\n\n  function onDragStart(cm, e) {\n    if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return }\n    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) { return }\n\n    e.dataTransfer.setData(\"Text\", cm.getSelection());\n    e.dataTransfer.effectAllowed = \"copyMove\";\n\n    // Use dummy image instead of default browsers image.\n    // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.\n    if (e.dataTransfer.setDragImage && !safari) {\n      var img = elt(\"img\", null, null, \"position: fixed; left: 0; top: 0;\");\n      img.src = \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\";\n      if (presto) {\n        img.width = img.height = 1;\n        cm.display.wrapper.appendChild(img);\n        // Force a relayout, or Opera won't use our image for some obscure reason\n        img._top = img.offsetTop;\n      }\n      e.dataTransfer.setDragImage(img, 0, 0);\n      if (presto) { img.parentNode.removeChild(img); }\n    }\n  }\n\n  function onDragOver(cm, e) {\n    var pos = posFromMouse(cm, e);\n    if (!pos) { return }\n    var frag = document.createDocumentFragment();\n    drawSelectionCursor(cm, pos, frag);\n    if (!cm.display.dragCursor) {\n      cm.display.dragCursor = elt(\"div\", null, \"CodeMirror-cursors CodeMirror-dragcursors\");\n      cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);\n    }\n    removeChildrenAndAdd(cm.display.dragCursor, frag);\n  }\n\n  function clearDragCursor(cm) {\n    if (cm.display.dragCursor) {\n      cm.display.lineSpace.removeChild(cm.display.dragCursor);\n      cm.display.dragCursor = null;\n    }\n  }\n\n  // These must be handled carefully, because naively registering a\n  // handler for each editor will cause the editors to never be\n  // garbage collected.\n\n  function forEachCodeMirror(f) {\n    if (!document.getElementsByClassName) { return }\n    var byClass = document.getElementsByClassName(\"CodeMirror\"), editors = [];\n    for (var i = 0; i < byClass.length; i++) {\n      var cm = byClass[i].CodeMirror;\n      if (cm) { editors.push(cm); }\n    }\n    if (editors.length) { editors[0].operation(function () {\n      for (var i = 0; i < editors.length; i++) { f(editors[i]); }\n    }); }\n  }\n\n  var globalsRegistered = false;\n  function ensureGlobalHandlers() {\n    if (globalsRegistered) { return }\n    registerGlobalHandlers();\n    globalsRegistered = true;\n  }\n  function registerGlobalHandlers() {\n    // When the window resizes, we need to refresh active editors.\n    var resizeTimer;\n    on(window, \"resize\", function () {\n      if (resizeTimer == null) { resizeTimer = setTimeout(function () {\n        resizeTimer = null;\n        forEachCodeMirror(onResize);\n      }, 100); }\n    });\n    // When the window loses focus, we want to show the editor as blurred\n    on(window, \"blur\", function () { return forEachCodeMirror(onBlur); });\n  }\n  // Called when the window resizes\n  function onResize(cm) {\n    var d = cm.display;\n    // Might be a text scaling operation, clear size caches.\n    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\n    d.scrollbarsClipped = false;\n    cm.setSize();\n  }\n\n  var keyNames = {\n    3: \"Pause\", 8: \"Backspace\", 9: \"Tab\", 13: \"Enter\", 16: \"Shift\", 17: \"Ctrl\", 18: \"Alt\",\n    19: \"Pause\", 20: \"CapsLock\", 27: \"Esc\", 32: \"Space\", 33: \"PageUp\", 34: \"PageDown\", 35: \"End\",\n    36: \"Home\", 37: \"Left\", 38: \"Up\", 39: \"Right\", 40: \"Down\", 44: \"PrintScrn\", 45: \"Insert\",\n    46: \"Delete\", 59: \";\", 61: \"=\", 91: \"Mod\", 92: \"Mod\", 93: \"Mod\",\n    106: \"*\", 107: \"=\", 109: \"-\", 110: \".\", 111: \"/\", 145: \"ScrollLock\",\n    173: \"-\", 186: \";\", 187: \"=\", 188: \",\", 189: \"-\", 190: \".\", 191: \"/\", 192: \"`\", 219: \"[\", 220: \"\\\\\",\n    221: \"]\", 222: \"'\", 224: \"Mod\", 63232: \"Up\", 63233: \"Down\", 63234: \"Left\", 63235: \"Right\", 63272: \"Delete\",\n    63273: \"Home\", 63275: \"End\", 63276: \"PageUp\", 63277: \"PageDown\", 63302: \"Insert\"\n  };\n\n  // Number keys\n  for (var i = 0; i < 10; i++) { keyNames[i + 48] = keyNames[i + 96] = String(i); }\n  // Alphabetic keys\n  for (var i$1 = 65; i$1 <= 90; i$1++) { keyNames[i$1] = String.fromCharCode(i$1); }\n  // Function keys\n  for (var i$2 = 1; i$2 <= 12; i$2++) { keyNames[i$2 + 111] = keyNames[i$2 + 63235] = \"F\" + i$2; }\n\n  var keyMap = {};\n\n  keyMap.basic = {\n    \"Left\": \"goCharLeft\", \"Right\": \"goCharRight\", \"Up\": \"goLineUp\", \"Down\": \"goLineDown\",\n    \"End\": \"goLineEnd\", \"Home\": \"goLineStartSmart\", \"PageUp\": \"goPageUp\", \"PageDown\": \"goPageDown\",\n    \"Delete\": \"delCharAfter\", \"Backspace\": \"delCharBefore\", \"Shift-Backspace\": \"delCharBefore\",\n    \"Tab\": \"defaultTab\", \"Shift-Tab\": \"indentAuto\",\n    \"Enter\": \"newlineAndIndent\", \"Insert\": \"toggleOverwrite\",\n    \"Esc\": \"singleSelection\"\n  };\n  // Note that the save and find-related commands aren't defined by\n  // default. User code or addons can define them. Unknown commands\n  // are simply ignored.\n  keyMap.pcDefault = {\n    \"Ctrl-A\": \"selectAll\", \"Ctrl-D\": \"deleteLine\", \"Ctrl-Z\": \"undo\", \"Shift-Ctrl-Z\": \"redo\", \"Ctrl-Y\": \"redo\",\n    \"Ctrl-Home\": \"goDocStart\", \"Ctrl-End\": \"goDocEnd\", \"Ctrl-Up\": \"goLineUp\", \"Ctrl-Down\": \"goLineDown\",\n    \"Ctrl-Left\": \"goGroupLeft\", \"Ctrl-Right\": \"goGroupRight\", \"Alt-Left\": \"goLineStart\", \"Alt-Right\": \"goLineEnd\",\n    \"Ctrl-Backspace\": \"delGroupBefore\", \"Ctrl-Delete\": \"delGroupAfter\", \"Ctrl-S\": \"save\", \"Ctrl-F\": \"find\",\n    \"Ctrl-G\": \"findNext\", \"Shift-Ctrl-G\": \"findPrev\", \"Shift-Ctrl-F\": \"replace\", \"Shift-Ctrl-R\": \"replaceAll\",\n    \"Ctrl-[\": \"indentLess\", \"Ctrl-]\": \"indentMore\",\n    \"Ctrl-U\": \"undoSelection\", \"Shift-Ctrl-U\": \"redoSelection\", \"Alt-U\": \"redoSelection\",\n    \"fallthrough\": \"basic\"\n  };\n  // Very basic readline/emacs-style bindings, which are standard on Mac.\n  keyMap.emacsy = {\n    \"Ctrl-F\": \"goCharRight\", \"Ctrl-B\": \"goCharLeft\", \"Ctrl-P\": \"goLineUp\", \"Ctrl-N\": \"goLineDown\",\n    \"Alt-F\": \"goWordRight\", \"Alt-B\": \"goWordLeft\", \"Ctrl-A\": \"goLineStart\", \"Ctrl-E\": \"goLineEnd\",\n    \"Ctrl-V\": \"goPageDown\", \"Shift-Ctrl-V\": \"goPageUp\", \"Ctrl-D\": \"delCharAfter\", \"Ctrl-H\": \"delCharBefore\",\n    \"Alt-D\": \"delWordAfter\", \"Alt-Backspace\": \"delWordBefore\", \"Ctrl-K\": \"killLine\", \"Ctrl-T\": \"transposeChars\",\n    \"Ctrl-O\": \"openLine\"\n  };\n  keyMap.macDefault = {\n    \"Cmd-A\": \"selectAll\", \"Cmd-D\": \"deleteLine\", \"Cmd-Z\": \"undo\", \"Shift-Cmd-Z\": \"redo\", \"Cmd-Y\": \"redo\",\n    \"Cmd-Home\": \"goDocStart\", \"Cmd-Up\": \"goDocStart\", \"Cmd-End\": \"goDocEnd\", \"Cmd-Down\": \"goDocEnd\", \"Alt-Left\": \"goGroupLeft\",\n    \"Alt-Right\": \"goGroupRight\", \"Cmd-Left\": \"goLineLeft\", \"Cmd-Right\": \"goLineRight\", \"Alt-Backspace\": \"delGroupBefore\",\n    \"Ctrl-Alt-Backspace\": \"delGroupAfter\", \"Alt-Delete\": \"delGroupAfter\", \"Cmd-S\": \"save\", \"Cmd-F\": \"find\",\n    \"Cmd-G\": \"findNext\", \"Shift-Cmd-G\": \"findPrev\", \"Cmd-Alt-F\": \"replace\", \"Shift-Cmd-Alt-F\": \"replaceAll\",\n    \"Cmd-[\": \"indentLess\", \"Cmd-]\": \"indentMore\", \"Cmd-Backspace\": \"delWrappedLineLeft\", \"Cmd-Delete\": \"delWrappedLineRight\",\n    \"Cmd-U\": \"undoSelection\", \"Shift-Cmd-U\": \"redoSelection\", \"Ctrl-Up\": \"goDocStart\", \"Ctrl-Down\": \"goDocEnd\",\n    \"fallthrough\": [\"basic\", \"emacsy\"]\n  };\n  keyMap[\"default\"] = mac ? keyMap.macDefault : keyMap.pcDefault;\n\n  // KEYMAP DISPATCH\n\n  function normalizeKeyName(name) {\n    var parts = name.split(/-(?!$)/);\n    name = parts[parts.length - 1];\n    var alt, ctrl, shift, cmd;\n    for (var i = 0; i < parts.length - 1; i++) {\n      var mod = parts[i];\n      if (/^(cmd|meta|m)$/i.test(mod)) { cmd = true; }\n      else if (/^a(lt)?$/i.test(mod)) { alt = true; }\n      else if (/^(c|ctrl|control)$/i.test(mod)) { ctrl = true; }\n      else if (/^s(hift)?$/i.test(mod)) { shift = true; }\n      else { throw new Error(\"Unrecognized modifier name: \" + mod) }\n    }\n    if (alt) { name = \"Alt-\" + name; }\n    if (ctrl) { name = \"Ctrl-\" + name; }\n    if (cmd) { name = \"Cmd-\" + name; }\n    if (shift) { name = \"Shift-\" + name; }\n    return name\n  }\n\n  // This is a kludge to keep keymaps mostly working as raw objects\n  // (backwards compatibility) while at the same time support features\n  // like normalization and multi-stroke key bindings. It compiles a\n  // new normalized keymap, and then updates the old object to reflect\n  // this.\n  function normalizeKeyMap(keymap) {\n    var copy = {};\n    for (var keyname in keymap) { if (keymap.hasOwnProperty(keyname)) {\n      var value = keymap[keyname];\n      if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) { continue }\n      if (value == \"...\") { delete keymap[keyname]; continue }\n\n      var keys = map(keyname.split(\" \"), normalizeKeyName);\n      for (var i = 0; i < keys.length; i++) {\n        var val = (void 0), name = (void 0);\n        if (i == keys.length - 1) {\n          name = keys.join(\" \");\n          val = value;\n        } else {\n          name = keys.slice(0, i + 1).join(\" \");\n          val = \"...\";\n        }\n        var prev = copy[name];\n        if (!prev) { copy[name] = val; }\n        else if (prev != val) { throw new Error(\"Inconsistent bindings for \" + name) }\n      }\n      delete keymap[keyname];\n    } }\n    for (var prop in copy) { keymap[prop] = copy[prop]; }\n    return keymap\n  }\n\n  function lookupKey(key, map, handle, context) {\n    map = getKeyMap(map);\n    var found = map.call ? map.call(key, context) : map[key];\n    if (found === false) { return \"nothing\" }\n    if (found === \"...\") { return \"multi\" }\n    if (found != null && handle(found)) { return \"handled\" }\n\n    if (map.fallthrough) {\n      if (Object.prototype.toString.call(map.fallthrough) != \"[object Array]\")\n        { return lookupKey(key, map.fallthrough, handle, context) }\n      for (var i = 0; i < map.fallthrough.length; i++) {\n        var result = lookupKey(key, map.fallthrough[i], handle, context);\n        if (result) { return result }\n      }\n    }\n  }\n\n  // Modifier key presses don't count as 'real' key presses for the\n  // purpose of keymap fallthrough.\n  function isModifierKey(value) {\n    var name = typeof value == \"string\" ? value : keyNames[value.keyCode];\n    return name == \"Ctrl\" || name == \"Alt\" || name == \"Shift\" || name == \"Mod\"\n  }\n\n  function addModifierNames(name, event, noShift) {\n    var base = name;\n    if (event.altKey && base != \"Alt\") { name = \"Alt-\" + name; }\n    if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != \"Ctrl\") { name = \"Ctrl-\" + name; }\n    if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != \"Mod\") { name = \"Cmd-\" + name; }\n    if (!noShift && event.shiftKey && base != \"Shift\") { name = \"Shift-\" + name; }\n    return name\n  }\n\n  // Look up the name of a key as indicated by an event object.\n  function keyName(event, noShift) {\n    if (presto && event.keyCode == 34 && event[\"char\"]) { return false }\n    var name = keyNames[event.keyCode];\n    if (name == null || event.altGraphKey) { return false }\n    // Ctrl-ScrollLock has keyCode 3, same as Ctrl-Pause,\n    // so we'll use event.code when available (Chrome 48+, FF 38+, Safari 10.1+)\n    if (event.keyCode == 3 && event.code) { name = event.code; }\n    return addModifierNames(name, event, noShift)\n  }\n\n  function getKeyMap(val) {\n    return typeof val == \"string\" ? keyMap[val] : val\n  }\n\n  // Helper for deleting text near the selection(s), used to implement\n  // backspace, delete, and similar functionality.\n  function deleteNearSelection(cm, compute) {\n    var ranges = cm.doc.sel.ranges, kill = [];\n    // Build up a set of ranges to kill first, merging overlapping\n    // ranges.\n    for (var i = 0; i < ranges.length; i++) {\n      var toKill = compute(ranges[i]);\n      while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {\n        var replaced = kill.pop();\n        if (cmp(replaced.from, toKill.from) < 0) {\n          toKill.from = replaced.from;\n          break\n        }\n      }\n      kill.push(toKill);\n    }\n    // Next, remove those actual ranges.\n    runInOp(cm, function () {\n      for (var i = kill.length - 1; i >= 0; i--)\n        { replaceRange(cm.doc, \"\", kill[i].from, kill[i].to, \"+delete\"); }\n      ensureCursorVisible(cm);\n    });\n  }\n\n  function moveCharLogically(line, ch, dir) {\n    var target = skipExtendingChars(line.text, ch + dir, dir);\n    return target < 0 || target > line.text.length ? null : target\n  }\n\n  function moveLogically(line, start, dir) {\n    var ch = moveCharLogically(line, start.ch, dir);\n    return ch == null ? null : new Pos(start.line, ch, dir < 0 ? \"after\" : \"before\")\n  }\n\n  function endOfLine(visually, cm, lineObj, lineNo, dir) {\n    if (visually) {\n      if (cm.doc.direction == \"rtl\") { dir = -dir; }\n      var order = getOrder(lineObj, cm.doc.direction);\n      if (order) {\n        var part = dir < 0 ? lst(order) : order[0];\n        var moveInStorageOrder = (dir < 0) == (part.level == 1);\n        var sticky = moveInStorageOrder ? \"after\" : \"before\";\n        var ch;\n        // With a wrapped rtl chunk (possibly spanning multiple bidi parts),\n        // it could be that the last bidi part is not on the last visual line,\n        // since visual lines contain content order-consecutive chunks.\n        // Thus, in rtl, we are looking for the first (content-order) character\n        // in the rtl chunk that is on the last line (that is, the same line\n        // as the last (content-order) character).\n        if (part.level > 0 || cm.doc.direction == \"rtl\") {\n          var prep = prepareMeasureForLine(cm, lineObj);\n          ch = dir < 0 ? lineObj.text.length - 1 : 0;\n          var targetTop = measureCharPrepared(cm, prep, ch).top;\n          ch = findFirst(function (ch) { return measureCharPrepared(cm, prep, ch).top == targetTop; }, (dir < 0) == (part.level == 1) ? part.from : part.to - 1, ch);\n          if (sticky == \"before\") { ch = moveCharLogically(lineObj, ch, 1); }\n        } else { ch = dir < 0 ? part.to : part.from; }\n        return new Pos(lineNo, ch, sticky)\n      }\n    }\n    return new Pos(lineNo, dir < 0 ? lineObj.text.length : 0, dir < 0 ? \"before\" : \"after\")\n  }\n\n  function moveVisually(cm, line, start, dir) {\n    var bidi = getOrder(line, cm.doc.direction);\n    if (!bidi) { return moveLogically(line, start, dir) }\n    if (start.ch >= line.text.length) {\n      start.ch = line.text.length;\n      start.sticky = \"before\";\n    } else if (start.ch <= 0) {\n      start.ch = 0;\n      start.sticky = \"after\";\n    }\n    var partPos = getBidiPartAt(bidi, start.ch, start.sticky), part = bidi[partPos];\n    if (cm.doc.direction == \"ltr\" && part.level % 2 == 0 && (dir > 0 ? part.to > start.ch : part.from < start.ch)) {\n      // Case 1: We move within an ltr part in an ltr editor. Even with wrapped lines,\n      // nothing interesting happens.\n      return moveLogically(line, start, dir)\n    }\n\n    var mv = function (pos, dir) { return moveCharLogically(line, pos instanceof Pos ? pos.ch : pos, dir); };\n    var prep;\n    var getWrappedLineExtent = function (ch) {\n      if (!cm.options.lineWrapping) { return {begin: 0, end: line.text.length} }\n      prep = prep || prepareMeasureForLine(cm, line);\n      return wrappedLineExtentChar(cm, line, prep, ch)\n    };\n    var wrappedLineExtent = getWrappedLineExtent(start.sticky == \"before\" ? mv(start, -1) : start.ch);\n\n    if (cm.doc.direction == \"rtl\" || part.level == 1) {\n      var moveInStorageOrder = (part.level == 1) == (dir < 0);\n      var ch = mv(start, moveInStorageOrder ? 1 : -1);\n      if (ch != null && (!moveInStorageOrder ? ch >= part.from && ch >= wrappedLineExtent.begin : ch <= part.to && ch <= wrappedLineExtent.end)) {\n        // Case 2: We move within an rtl part or in an rtl editor on the same visual line\n        var sticky = moveInStorageOrder ? \"before\" : \"after\";\n        return new Pos(start.line, ch, sticky)\n      }\n    }\n\n    // Case 3: Could not move within this bidi part in this visual line, so leave\n    // the current bidi part\n\n    var searchInVisualLine = function (partPos, dir, wrappedLineExtent) {\n      var getRes = function (ch, moveInStorageOrder) { return moveInStorageOrder\n        ? new Pos(start.line, mv(ch, 1), \"before\")\n        : new Pos(start.line, ch, \"after\"); };\n\n      for (; partPos >= 0 && partPos < bidi.length; partPos += dir) {\n        var part = bidi[partPos];\n        var moveInStorageOrder = (dir > 0) == (part.level != 1);\n        var ch = moveInStorageOrder ? wrappedLineExtent.begin : mv(wrappedLineExtent.end, -1);\n        if (part.from <= ch && ch < part.to) { return getRes(ch, moveInStorageOrder) }\n        ch = moveInStorageOrder ? part.from : mv(part.to, -1);\n        if (wrappedLineExtent.begin <= ch && ch < wrappedLineExtent.end) { return getRes(ch, moveInStorageOrder) }\n      }\n    };\n\n    // Case 3a: Look for other bidi parts on the same visual line\n    var res = searchInVisualLine(partPos + dir, dir, wrappedLineExtent);\n    if (res) { return res }\n\n    // Case 3b: Look for other bidi parts on the next visual line\n    var nextCh = dir > 0 ? wrappedLineExtent.end : mv(wrappedLineExtent.begin, -1);\n    if (nextCh != null && !(dir > 0 && nextCh == line.text.length)) {\n      res = searchInVisualLine(dir > 0 ? 0 : bidi.length - 1, dir, getWrappedLineExtent(nextCh));\n      if (res) { return res }\n    }\n\n    // Case 4: Nowhere to move\n    return null\n  }\n\n  // Commands are parameter-less actions that can be performed on an\n  // editor, mostly used for keybindings.\n  var commands = {\n    selectAll: selectAll,\n    singleSelection: function (cm) { return cm.setSelection(cm.getCursor(\"anchor\"), cm.getCursor(\"head\"), sel_dontScroll); },\n    killLine: function (cm) { return deleteNearSelection(cm, function (range) {\n      if (range.empty()) {\n        var len = getLine(cm.doc, range.head.line).text.length;\n        if (range.head.ch == len && range.head.line < cm.lastLine())\n          { return {from: range.head, to: Pos(range.head.line + 1, 0)} }\n        else\n          { return {from: range.head, to: Pos(range.head.line, len)} }\n      } else {\n        return {from: range.from(), to: range.to()}\n      }\n    }); },\n    deleteLine: function (cm) { return deleteNearSelection(cm, function (range) { return ({\n      from: Pos(range.from().line, 0),\n      to: clipPos(cm.doc, Pos(range.to().line + 1, 0))\n    }); }); },\n    delLineLeft: function (cm) { return deleteNearSelection(cm, function (range) { return ({\n      from: Pos(range.from().line, 0), to: range.from()\n    }); }); },\n    delWrappedLineLeft: function (cm) { return deleteNearSelection(cm, function (range) {\n      var top = cm.charCoords(range.head, \"div\").top + 5;\n      var leftPos = cm.coordsChar({left: 0, top: top}, \"div\");\n      return {from: leftPos, to: range.from()}\n    }); },\n    delWrappedLineRight: function (cm) { return deleteNearSelection(cm, function (range) {\n      var top = cm.charCoords(range.head, \"div\").top + 5;\n      var rightPos = cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, \"div\");\n      return {from: range.from(), to: rightPos }\n    }); },\n    undo: function (cm) { return cm.undo(); },\n    redo: function (cm) { return cm.redo(); },\n    undoSelection: function (cm) { return cm.undoSelection(); },\n    redoSelection: function (cm) { return cm.redoSelection(); },\n    goDocStart: function (cm) { return cm.extendSelection(Pos(cm.firstLine(), 0)); },\n    goDocEnd: function (cm) { return cm.extendSelection(Pos(cm.lastLine())); },\n    goLineStart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStart(cm, range.head.line); },\n      {origin: \"+move\", bias: 1}\n    ); },\n    goLineStartSmart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStartSmart(cm, range.head); },\n      {origin: \"+move\", bias: 1}\n    ); },\n    goLineEnd: function (cm) { return cm.extendSelectionsBy(function (range) { return lineEnd(cm, range.head.line); },\n      {origin: \"+move\", bias: -1}\n    ); },\n    goLineRight: function (cm) { return cm.extendSelectionsBy(function (range) {\n      var top = cm.cursorCoords(range.head, \"div\").top + 5;\n      return cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, \"div\")\n    }, sel_move); },\n    goLineLeft: function (cm) { return cm.extendSelectionsBy(function (range) {\n      var top = cm.cursorCoords(range.head, \"div\").top + 5;\n      return cm.coordsChar({left: 0, top: top}, \"div\")\n    }, sel_move); },\n    goLineLeftSmart: function (cm) { return cm.extendSelectionsBy(function (range) {\n      var top = cm.cursorCoords(range.head, \"div\").top + 5;\n      var pos = cm.coordsChar({left: 0, top: top}, \"div\");\n      if (pos.ch < cm.getLine(pos.line).search(/\\S/)) { return lineStartSmart(cm, range.head) }\n      return pos\n    }, sel_move); },\n    goLineUp: function (cm) { return cm.moveV(-1, \"line\"); },\n    goLineDown: function (cm) { return cm.moveV(1, \"line\"); },\n    goPageUp: function (cm) { return cm.moveV(-1, \"page\"); },\n    goPageDown: function (cm) { return cm.moveV(1, \"page\"); },\n    goCharLeft: function (cm) { return cm.moveH(-1, \"char\"); },\n    goCharRight: function (cm) { return cm.moveH(1, \"char\"); },\n    goColumnLeft: function (cm) { return cm.moveH(-1, \"column\"); },\n    goColumnRight: function (cm) { return cm.moveH(1, \"column\"); },\n    goWordLeft: function (cm) { return cm.moveH(-1, \"word\"); },\n    goGroupRight: function (cm) { return cm.moveH(1, \"group\"); },\n    goGroupLeft: function (cm) { return cm.moveH(-1, \"group\"); },\n    goWordRight: function (cm) { return cm.moveH(1, \"word\"); },\n    delCharBefore: function (cm) { return cm.deleteH(-1, \"codepoint\"); },\n    delCharAfter: function (cm) { return cm.deleteH(1, \"char\"); },\n    delWordBefore: function (cm) { return cm.deleteH(-1, \"word\"); },\n    delWordAfter: function (cm) { return cm.deleteH(1, \"word\"); },\n    delGroupBefore: function (cm) { return cm.deleteH(-1, \"group\"); },\n    delGroupAfter: function (cm) { return cm.deleteH(1, \"group\"); },\n    indentAuto: function (cm) { return cm.indentSelection(\"smart\"); },\n    indentMore: function (cm) { return cm.indentSelection(\"add\"); },\n    indentLess: function (cm) { return cm.indentSelection(\"subtract\"); },\n    insertTab: function (cm) { return cm.replaceSelection(\"\\t\"); },\n    insertSoftTab: function (cm) {\n      var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;\n      for (var i = 0; i < ranges.length; i++) {\n        var pos = ranges[i].from();\n        var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);\n        spaces.push(spaceStr(tabSize - col % tabSize));\n      }\n      cm.replaceSelections(spaces);\n    },\n    defaultTab: function (cm) {\n      if (cm.somethingSelected()) { cm.indentSelection(\"add\"); }\n      else { cm.execCommand(\"insertTab\"); }\n    },\n    // Swap the two chars left and right of each selection's head.\n    // Move cursor behind the two swapped characters afterwards.\n    //\n    // Doesn't consider line feeds a character.\n    // Doesn't scan more than one line above to find a character.\n    // Doesn't do anything on an empty line.\n    // Doesn't do anything with non-empty selections.\n    transposeChars: function (cm) { return runInOp(cm, function () {\n      var ranges = cm.listSelections(), newSel = [];\n      for (var i = 0; i < ranges.length; i++) {\n        if (!ranges[i].empty()) { continue }\n        var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;\n        if (line) {\n          if (cur.ch == line.length) { cur = new Pos(cur.line, cur.ch - 1); }\n          if (cur.ch > 0) {\n            cur = new Pos(cur.line, cur.ch + 1);\n            cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),\n                            Pos(cur.line, cur.ch - 2), cur, \"+transpose\");\n          } else if (cur.line > cm.doc.first) {\n            var prev = getLine(cm.doc, cur.line - 1).text;\n            if (prev) {\n              cur = new Pos(cur.line, 1);\n              cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() +\n                              prev.charAt(prev.length - 1),\n                              Pos(cur.line - 1, prev.length - 1), cur, \"+transpose\");\n            }\n          }\n        }\n        newSel.push(new Range(cur, cur));\n      }\n      cm.setSelections(newSel);\n    }); },\n    newlineAndIndent: function (cm) { return runInOp(cm, function () {\n      var sels = cm.listSelections();\n      for (var i = sels.length - 1; i >= 0; i--)\n        { cm.replaceRange(cm.doc.lineSeparator(), sels[i].anchor, sels[i].head, \"+input\"); }\n      sels = cm.listSelections();\n      for (var i$1 = 0; i$1 < sels.length; i$1++)\n        { cm.indentLine(sels[i$1].from().line, null, true); }\n      ensureCursorVisible(cm);\n    }); },\n    openLine: function (cm) { return cm.replaceSelection(\"\\n\", \"start\"); },\n    toggleOverwrite: function (cm) { return cm.toggleOverwrite(); }\n  };\n\n\n  function lineStart(cm, lineN) {\n    var line = getLine(cm.doc, lineN);\n    var visual = visualLine(line);\n    if (visual != line) { lineN = lineNo(visual); }\n    return endOfLine(true, cm, visual, lineN, 1)\n  }\n  function lineEnd(cm, lineN) {\n    var line = getLine(cm.doc, lineN);\n    var visual = visualLineEnd(line);\n    if (visual != line) { lineN = lineNo(visual); }\n    return endOfLine(true, cm, line, lineN, -1)\n  }\n  function lineStartSmart(cm, pos) {\n    var start = lineStart(cm, pos.line);\n    var line = getLine(cm.doc, start.line);\n    var order = getOrder(line, cm.doc.direction);\n    if (!order || order[0].level == 0) {\n      var firstNonWS = Math.max(start.ch, line.text.search(/\\S/));\n      var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;\n      return Pos(start.line, inWS ? 0 : firstNonWS, start.sticky)\n    }\n    return start\n  }\n\n  // Run a handler that was bound to a key.\n  function doHandleBinding(cm, bound, dropShift) {\n    if (typeof bound == \"string\") {\n      bound = commands[bound];\n      if (!bound) { return false }\n    }\n    // Ensure previous input has been read, so that the handler sees a\n    // consistent view of the document\n    cm.display.input.ensurePolled();\n    var prevShift = cm.display.shift, done = false;\n    try {\n      if (cm.isReadOnly()) { cm.state.suppressEdits = true; }\n      if (dropShift) { cm.display.shift = false; }\n      done = bound(cm) != Pass;\n    } finally {\n      cm.display.shift = prevShift;\n      cm.state.suppressEdits = false;\n    }\n    return done\n  }\n\n  function lookupKeyForEditor(cm, name, handle) {\n    for (var i = 0; i < cm.state.keyMaps.length; i++) {\n      var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);\n      if (result) { return result }\n    }\n    return (cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm))\n      || lookupKey(name, cm.options.keyMap, handle, cm)\n  }\n\n  // Note that, despite the name, this function is also used to check\n  // for bound mouse clicks.\n\n  var stopSeq = new Delayed;\n\n  function dispatchKey(cm, name, e, handle) {\n    var seq = cm.state.keySeq;\n    if (seq) {\n      if (isModifierKey(name)) { return \"handled\" }\n      if (/\\'$/.test(name))\n        { cm.state.keySeq = null; }\n      else\n        { stopSeq.set(50, function () {\n          if (cm.state.keySeq == seq) {\n            cm.state.keySeq = null;\n            cm.display.input.reset();\n          }\n        }); }\n      if (dispatchKeyInner(cm, seq + \" \" + name, e, handle)) { return true }\n    }\n    return dispatchKeyInner(cm, name, e, handle)\n  }\n\n  function dispatchKeyInner(cm, name, e, handle) {\n    var result = lookupKeyForEditor(cm, name, handle);\n\n    if (result == \"multi\")\n      { cm.state.keySeq = name; }\n    if (result == \"handled\")\n      { signalLater(cm, \"keyHandled\", cm, name, e); }\n\n    if (result == \"handled\" || result == \"multi\") {\n      e_preventDefault(e);\n      restartBlink(cm);\n    }\n\n    return !!result\n  }\n\n  // Handle a key from the keydown event.\n  function handleKeyBinding(cm, e) {\n    var name = keyName(e, true);\n    if (!name) { return false }\n\n    if (e.shiftKey && !cm.state.keySeq) {\n      // First try to resolve full name (including 'Shift-'). Failing\n      // that, see if there is a cursor-motion command (starting with\n      // 'go') bound to the keyname without 'Shift-'.\n      return dispatchKey(cm, \"Shift-\" + name, e, function (b) { return doHandleBinding(cm, b, true); })\n          || dispatchKey(cm, name, e, function (b) {\n               if (typeof b == \"string\" ? /^go[A-Z]/.test(b) : b.motion)\n                 { return doHandleBinding(cm, b) }\n             })\n    } else {\n      return dispatchKey(cm, name, e, function (b) { return doHandleBinding(cm, b); })\n    }\n  }\n\n  // Handle a key from the keypress event\n  function handleCharBinding(cm, e, ch) {\n    return dispatchKey(cm, \"'\" + ch + \"'\", e, function (b) { return doHandleBinding(cm, b, true); })\n  }\n\n  var lastStoppedKey = null;\n  function onKeyDown(e) {\n    var cm = this;\n    if (e.target && e.target != cm.display.input.getField()) { return }\n    cm.curOp.focus = activeElt();\n    if (signalDOMEvent(cm, e)) { return }\n    // IE does strange things with escape.\n    if (ie && ie_version < 11 && e.keyCode == 27) { e.returnValue = false; }\n    var code = e.keyCode;\n    cm.display.shift = code == 16 || e.shiftKey;\n    var handled = handleKeyBinding(cm, e);\n    if (presto) {\n      lastStoppedKey = handled ? code : null;\n      // Opera has no cut event... we try to at least catch the key combo\n      if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))\n        { cm.replaceSelection(\"\", null, \"cut\"); }\n    }\n    if (gecko && !mac && !handled && code == 46 && e.shiftKey && !e.ctrlKey && document.execCommand)\n      { document.execCommand(\"cut\"); }\n\n    // Turn mouse into crosshair when Alt is held on Mac.\n    if (code == 18 && !/\\bCodeMirror-crosshair\\b/.test(cm.display.lineDiv.className))\n      { showCrossHair(cm); }\n  }\n\n  function showCrossHair(cm) {\n    var lineDiv = cm.display.lineDiv;\n    addClass(lineDiv, \"CodeMirror-crosshair\");\n\n    function up(e) {\n      if (e.keyCode == 18 || !e.altKey) {\n        rmClass(lineDiv, \"CodeMirror-crosshair\");\n        off(document, \"keyup\", up);\n        off(document, \"mouseover\", up);\n      }\n    }\n    on(document, \"keyup\", up);\n    on(document, \"mouseover\", up);\n  }\n\n  function onKeyUp(e) {\n    if (e.keyCode == 16) { this.doc.sel.shift = false; }\n    signalDOMEvent(this, e);\n  }\n\n  function onKeyPress(e) {\n    var cm = this;\n    if (e.target && e.target != cm.display.input.getField()) { return }\n    if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) { return }\n    var keyCode = e.keyCode, charCode = e.charCode;\n    if (presto && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return}\n    if ((presto && (!e.which || e.which < 10)) && handleKeyBinding(cm, e)) { return }\n    var ch = String.fromCharCode(charCode == null ? keyCode : charCode);\n    // Some browsers fire keypress events for backspace\n    if (ch == \"\\x08\") { return }\n    if (handleCharBinding(cm, e, ch)) { return }\n    cm.display.input.onKeyPress(e);\n  }\n\n  var DOUBLECLICK_DELAY = 400;\n\n  var PastClick = function(time, pos, button) {\n    this.time = time;\n    this.pos = pos;\n    this.button = button;\n  };\n\n  PastClick.prototype.compare = function (time, pos, button) {\n    return this.time + DOUBLECLICK_DELAY > time &&\n      cmp(pos, this.pos) == 0 && button == this.button\n  };\n\n  var lastClick, lastDoubleClick;\n  function clickRepeat(pos, button) {\n    var now = +new Date;\n    if (lastDoubleClick && lastDoubleClick.compare(now, pos, button)) {\n      lastClick = lastDoubleClick = null;\n      return \"triple\"\n    } else if (lastClick && lastClick.compare(now, pos, button)) {\n      lastDoubleClick = new PastClick(now, pos, button);\n      lastClick = null;\n      return \"double\"\n    } else {\n      lastClick = new PastClick(now, pos, button);\n      lastDoubleClick = null;\n      return \"single\"\n    }\n  }\n\n  // A mouse down can be a single click, double click, triple click,\n  // start of selection drag, start of text drag, new cursor\n  // (ctrl-click), rectangle drag (alt-drag), or xwin\n  // middle-click-paste. Or it might be a click on something we should\n  // not interfere with, such as a scrollbar or widget.\n  function onMouseDown(e) {\n    var cm = this, display = cm.display;\n    if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) { return }\n    display.input.ensurePolled();\n    display.shift = e.shiftKey;\n\n    if (eventInWidget(display, e)) {\n      if (!webkit) {\n        // Briefly turn off draggability, to allow widgets to do\n        // normal dragging things.\n        display.scroller.draggable = false;\n        setTimeout(function () { return display.scroller.draggable = true; }, 100);\n      }\n      return\n    }\n    if (clickInGutter(cm, e)) { return }\n    var pos = posFromMouse(cm, e), button = e_button(e), repeat = pos ? clickRepeat(pos, button) : \"single\";\n    window.focus();\n\n    // #3261: make sure, that we're not starting a second selection\n    if (button == 1 && cm.state.selectingText)\n      { cm.state.selectingText(e); }\n\n    if (pos && handleMappedButton(cm, button, pos, repeat, e)) { return }\n\n    if (button == 1) {\n      if (pos) { leftButtonDown(cm, pos, repeat, e); }\n      else if (e_target(e) == display.scroller) { e_preventDefault(e); }\n    } else if (button == 2) {\n      if (pos) { extendSelection(cm.doc, pos); }\n      setTimeout(function () { return display.input.focus(); }, 20);\n    } else if (button == 3) {\n      if (captureRightClick) { cm.display.input.onContextMenu(e); }\n      else { delayBlurEvent(cm); }\n    }\n  }\n\n  function handleMappedButton(cm, button, pos, repeat, event) {\n    var name = \"Click\";\n    if (repeat == \"double\") { name = \"Double\" + name; }\n    else if (repeat == \"triple\") { name = \"Triple\" + name; }\n    name = (button == 1 ? \"Left\" : button == 2 ? \"Middle\" : \"Right\") + name;\n\n    return dispatchKey(cm,  addModifierNames(name, event), event, function (bound) {\n      if (typeof bound == \"string\") { bound = commands[bound]; }\n      if (!bound) { return false }\n      var done = false;\n      try {\n        if (cm.isReadOnly()) { cm.state.suppressEdits = true; }\n        done = bound(cm, pos) != Pass;\n      } finally {\n        cm.state.suppressEdits = false;\n      }\n      return done\n    })\n  }\n\n  function configureMouse(cm, repeat, event) {\n    var option = cm.getOption(\"configureMouse\");\n    var value = option ? option(cm, repeat, event) : {};\n    if (value.unit == null) {\n      var rect = chromeOS ? event.shiftKey && event.metaKey : event.altKey;\n      value.unit = rect ? \"rectangle\" : repeat == \"single\" ? \"char\" : repeat == \"double\" ? \"word\" : \"line\";\n    }\n    if (value.extend == null || cm.doc.extend) { value.extend = cm.doc.extend || event.shiftKey; }\n    if (value.addNew == null) { value.addNew = mac ? event.metaKey : event.ctrlKey; }\n    if (value.moveOnDrag == null) { value.moveOnDrag = !(mac ? event.altKey : event.ctrlKey); }\n    return value\n  }\n\n  function leftButtonDown(cm, pos, repeat, event) {\n    if (ie) { setTimeout(bind(ensureFocus, cm), 0); }\n    else { cm.curOp.focus = activeElt(); }\n\n    var behavior = configureMouse(cm, repeat, event);\n\n    var sel = cm.doc.sel, contained;\n    if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() &&\n        repeat == \"single\" && (contained = sel.contains(pos)) > -1 &&\n        (cmp((contained = sel.ranges[contained]).from(), pos) < 0 || pos.xRel > 0) &&\n        (cmp(contained.to(), pos) > 0 || pos.xRel < 0))\n      { leftButtonStartDrag(cm, event, pos, behavior); }\n    else\n      { leftButtonSelect(cm, event, pos, behavior); }\n  }\n\n  // Start a text drag. When it ends, see if any dragging actually\n  // happen, and treat as a click if it didn't.\n  function leftButtonStartDrag(cm, event, pos, behavior) {\n    var display = cm.display, moved = false;\n    var dragEnd = operation(cm, function (e) {\n      if (webkit) { display.scroller.draggable = false; }\n      cm.state.draggingText = false;\n      if (cm.state.delayingBlurEvent) {\n        if (cm.hasFocus()) { cm.state.delayingBlurEvent = false; }\n        else { delayBlurEvent(cm); }\n      }\n      off(display.wrapper.ownerDocument, \"mouseup\", dragEnd);\n      off(display.wrapper.ownerDocument, \"mousemove\", mouseMove);\n      off(display.scroller, \"dragstart\", dragStart);\n      off(display.scroller, \"drop\", dragEnd);\n      if (!moved) {\n        e_preventDefault(e);\n        if (!behavior.addNew)\n          { extendSelection(cm.doc, pos, null, null, behavior.extend); }\n        // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)\n        if ((webkit && !safari) || ie && ie_version == 9)\n          { setTimeout(function () {display.wrapper.ownerDocument.body.focus({preventScroll: true}); display.input.focus();}, 20); }\n        else\n          { display.input.focus(); }\n      }\n    });\n    var mouseMove = function(e2) {\n      moved = moved || Math.abs(event.clientX - e2.clientX) + Math.abs(event.clientY - e2.clientY) >= 10;\n    };\n    var dragStart = function () { return moved = true; };\n    // Let the drag handler handle this.\n    if (webkit) { display.scroller.draggable = true; }\n    cm.state.draggingText = dragEnd;\n    dragEnd.copy = !behavior.moveOnDrag;\n    on(display.wrapper.ownerDocument, \"mouseup\", dragEnd);\n    on(display.wrapper.ownerDocument, \"mousemove\", mouseMove);\n    on(display.scroller, \"dragstart\", dragStart);\n    on(display.scroller, \"drop\", dragEnd);\n\n    cm.state.delayingBlurEvent = true;\n    setTimeout(function () { return display.input.focus(); }, 20);\n    // IE's approach to draggable\n    if (display.scroller.dragDrop) { display.scroller.dragDrop(); }\n  }\n\n  function rangeForUnit(cm, pos, unit) {\n    if (unit == \"char\") { return new Range(pos, pos) }\n    if (unit == \"word\") { return cm.findWordAt(pos) }\n    if (unit == \"line\") { return new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))) }\n    var result = unit(cm, pos);\n    return new Range(result.from, result.to)\n  }\n\n  // Normal selection, as opposed to text dragging.\n  function leftButtonSelect(cm, event, start, behavior) {\n    if (ie) { delayBlurEvent(cm); }\n    var display = cm.display, doc = cm.doc;\n    e_preventDefault(event);\n\n    var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;\n    if (behavior.addNew && !behavior.extend) {\n      ourIndex = doc.sel.contains(start);\n      if (ourIndex > -1)\n        { ourRange = ranges[ourIndex]; }\n      else\n        { ourRange = new Range(start, start); }\n    } else {\n      ourRange = doc.sel.primary();\n      ourIndex = doc.sel.primIndex;\n    }\n\n    if (behavior.unit == \"rectangle\") {\n      if (!behavior.addNew) { ourRange = new Range(start, start); }\n      start = posFromMouse(cm, event, true, true);\n      ourIndex = -1;\n    } else {\n      var range = rangeForUnit(cm, start, behavior.unit);\n      if (behavior.extend)\n        { ourRange = extendRange(ourRange, range.anchor, range.head, behavior.extend); }\n      else\n        { ourRange = range; }\n    }\n\n    if (!behavior.addNew) {\n      ourIndex = 0;\n      setSelection(doc, new Selection([ourRange], 0), sel_mouse);\n      startSel = doc.sel;\n    } else if (ourIndex == -1) {\n      ourIndex = ranges.length;\n      setSelection(doc, normalizeSelection(cm, ranges.concat([ourRange]), ourIndex),\n                   {scroll: false, origin: \"*mouse\"});\n    } else if (ranges.length > 1 && ranges[ourIndex].empty() && behavior.unit == \"char\" && !behavior.extend) {\n      setSelection(doc, normalizeSelection(cm, ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0),\n                   {scroll: false, origin: \"*mouse\"});\n      startSel = doc.sel;\n    } else {\n      replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);\n    }\n\n    var lastPos = start;\n    function extendTo(pos) {\n      if (cmp(lastPos, pos) == 0) { return }\n      lastPos = pos;\n\n      if (behavior.unit == \"rectangle\") {\n        var ranges = [], tabSize = cm.options.tabSize;\n        var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);\n        var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);\n        var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);\n        for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line));\n             line <= end; line++) {\n          var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);\n          if (left == right)\n            { ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos))); }\n          else if (text.length > leftPos)\n            { ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize)))); }\n        }\n        if (!ranges.length) { ranges.push(new Range(start, start)); }\n        setSelection(doc, normalizeSelection(cm, startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex),\n                     {origin: \"*mouse\", scroll: false});\n        cm.scrollIntoView(pos);\n      } else {\n        var oldRange = ourRange;\n        var range = rangeForUnit(cm, pos, behavior.unit);\n        var anchor = oldRange.anchor, head;\n        if (cmp(range.anchor, anchor) > 0) {\n          head = range.head;\n          anchor = minPos(oldRange.from(), range.anchor);\n        } else {\n          head = range.anchor;\n          anchor = maxPos(oldRange.to(), range.head);\n        }\n        var ranges$1 = startSel.ranges.slice(0);\n        ranges$1[ourIndex] = bidiSimplify(cm, new Range(clipPos(doc, anchor), head));\n        setSelection(doc, normalizeSelection(cm, ranges$1, ourIndex), sel_mouse);\n      }\n    }\n\n    var editorSize = display.wrapper.getBoundingClientRect();\n    // Used to ensure timeout re-tries don't fire when another extend\n    // happened in the meantime (clearTimeout isn't reliable -- at\n    // least on Chrome, the timeouts still happen even when cleared,\n    // if the clear happens after their scheduled firing time).\n    var counter = 0;\n\n    function extend(e) {\n      var curCount = ++counter;\n      var cur = posFromMouse(cm, e, true, behavior.unit == \"rectangle\");\n      if (!cur) { return }\n      if (cmp(cur, lastPos) != 0) {\n        cm.curOp.focus = activeElt();\n        extendTo(cur);\n        var visible = visibleLines(display, doc);\n        if (cur.line >= visible.to || cur.line < visible.from)\n          { setTimeout(operation(cm, function () {if (counter == curCount) { extend(e); }}), 150); }\n      } else {\n        var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;\n        if (outside) { setTimeout(operation(cm, function () {\n          if (counter != curCount) { return }\n          display.scroller.scrollTop += outside;\n          extend(e);\n        }), 50); }\n      }\n    }\n\n    function done(e) {\n      cm.state.selectingText = false;\n      counter = Infinity;\n      // If e is null or undefined we interpret this as someone trying\n      // to explicitly cancel the selection rather than the user\n      // letting go of the mouse button.\n      if (e) {\n        e_preventDefault(e);\n        display.input.focus();\n      }\n      off(display.wrapper.ownerDocument, \"mousemove\", move);\n      off(display.wrapper.ownerDocument, \"mouseup\", up);\n      doc.history.lastSelOrigin = null;\n    }\n\n    var move = operation(cm, function (e) {\n      if (e.buttons === 0 || !e_button(e)) { done(e); }\n      else { extend(e); }\n    });\n    var up = operation(cm, done);\n    cm.state.selectingText = up;\n    on(display.wrapper.ownerDocument, \"mousemove\", move);\n    on(display.wrapper.ownerDocument, \"mouseup\", up);\n  }\n\n  // Used when mouse-selecting to adjust the anchor to the proper side\n  // of a bidi jump depending on the visual position of the head.\n  function bidiSimplify(cm, range) {\n    var anchor = range.anchor;\n    var head = range.head;\n    var anchorLine = getLine(cm.doc, anchor.line);\n    if (cmp(anchor, head) == 0 && anchor.sticky == head.sticky) { return range }\n    var order = getOrder(anchorLine);\n    if (!order) { return range }\n    var index = getBidiPartAt(order, anchor.ch, anchor.sticky), part = order[index];\n    if (part.from != anchor.ch && part.to != anchor.ch) { return range }\n    var boundary = index + ((part.from == anchor.ch) == (part.level != 1) ? 0 : 1);\n    if (boundary == 0 || boundary == order.length) { return range }\n\n    // Compute the relative visual position of the head compared to the\n    // anchor (<0 is to the left, >0 to the right)\n    var leftSide;\n    if (head.line != anchor.line) {\n      leftSide = (head.line - anchor.line) * (cm.doc.direction == \"ltr\" ? 1 : -1) > 0;\n    } else {\n      var headIndex = getBidiPartAt(order, head.ch, head.sticky);\n      var dir = headIndex - index || (head.ch - anchor.ch) * (part.level == 1 ? -1 : 1);\n      if (headIndex == boundary - 1 || headIndex == boundary)\n        { leftSide = dir < 0; }\n      else\n        { leftSide = dir > 0; }\n    }\n\n    var usePart = order[boundary + (leftSide ? -1 : 0)];\n    var from = leftSide == (usePart.level == 1);\n    var ch = from ? usePart.from : usePart.to, sticky = from ? \"after\" : \"before\";\n    return anchor.ch == ch && anchor.sticky == sticky ? range : new Range(new Pos(anchor.line, ch, sticky), head)\n  }\n\n\n  // Determines whether an event happened in the gutter, and fires the\n  // handlers for the corresponding event.\n  function gutterEvent(cm, e, type, prevent) {\n    var mX, mY;\n    if (e.touches) {\n      mX = e.touches[0].clientX;\n      mY = e.touches[0].clientY;\n    } else {\n      try { mX = e.clientX; mY = e.clientY; }\n      catch(e$1) { return false }\n    }\n    if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) { return false }\n    if (prevent) { e_preventDefault(e); }\n\n    var display = cm.display;\n    var lineBox = display.lineDiv.getBoundingClientRect();\n\n    if (mY > lineBox.bottom || !hasHandler(cm, type)) { return e_defaultPrevented(e) }\n    mY -= lineBox.top - display.viewOffset;\n\n    for (var i = 0; i < cm.display.gutterSpecs.length; ++i) {\n      var g = display.gutters.childNodes[i];\n      if (g && g.getBoundingClientRect().right >= mX) {\n        var line = lineAtHeight(cm.doc, mY);\n        var gutter = cm.display.gutterSpecs[i];\n        signal(cm, type, cm, line, gutter.className, e);\n        return e_defaultPrevented(e)\n      }\n    }\n  }\n\n  function clickInGutter(cm, e) {\n    return gutterEvent(cm, e, \"gutterClick\", true)\n  }\n\n  // CONTEXT MENU HANDLING\n\n  // To make the context menu work, we need to briefly unhide the\n  // textarea (making it as unobtrusive as possible) to let the\n  // right-click take effect on it.\n  function onContextMenu(cm, e) {\n    if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) { return }\n    if (signalDOMEvent(cm, e, \"contextmenu\")) { return }\n    if (!captureRightClick) { cm.display.input.onContextMenu(e); }\n  }\n\n  function contextMenuInGutter(cm, e) {\n    if (!hasHandler(cm, \"gutterContextMenu\")) { return false }\n    return gutterEvent(cm, e, \"gutterContextMenu\", false)\n  }\n\n  function themeChanged(cm) {\n    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\\s*cm-s-\\S+/g, \"\") +\n      cm.options.theme.replace(/(^|\\s)\\s*/g, \" cm-s-\");\n    clearCaches(cm);\n  }\n\n  var Init = {toString: function(){return \"CodeMirror.Init\"}};\n\n  var defaults = {};\n  var optionHandlers = {};\n\n  function defineOptions(CodeMirror) {\n    var optionHandlers = CodeMirror.optionHandlers;\n\n    function option(name, deflt, handle, notOnInit) {\n      CodeMirror.defaults[name] = deflt;\n      if (handle) { optionHandlers[name] =\n        notOnInit ? function (cm, val, old) {if (old != Init) { handle(cm, val, old); }} : handle; }\n    }\n\n    CodeMirror.defineOption = option;\n\n    // Passed to option handlers when there is no old value.\n    CodeMirror.Init = Init;\n\n    // These two are, on init, called from the constructor because they\n    // have to be initialized before the editor can start at all.\n    option(\"value\", \"\", function (cm, val) { return cm.setValue(val); }, true);\n    option(\"mode\", null, function (cm, val) {\n      cm.doc.modeOption = val;\n      loadMode(cm);\n    }, true);\n\n    option(\"indentUnit\", 2, loadMode, true);\n    option(\"indentWithTabs\", false);\n    option(\"smartIndent\", true);\n    option(\"tabSize\", 4, function (cm) {\n      resetModeState(cm);\n      clearCaches(cm);\n      regChange(cm);\n    }, true);\n\n    option(\"lineSeparator\", null, function (cm, val) {\n      cm.doc.lineSep = val;\n      if (!val) { return }\n      var newBreaks = [], lineNo = cm.doc.first;\n      cm.doc.iter(function (line) {\n        for (var pos = 0;;) {\n          var found = line.text.indexOf(val, pos);\n          if (found == -1) { break }\n          pos = found + val.length;\n          newBreaks.push(Pos(lineNo, found));\n        }\n        lineNo++;\n      });\n      for (var i = newBreaks.length - 1; i >= 0; i--)\n        { replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length)); }\n    });\n    option(\"specialChars\", /[\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u061c\\u200b-\\u200c\\u200e\\u200f\\u2028\\u2029\\ufeff\\ufff9-\\ufffc]/g, function (cm, val, old) {\n      cm.state.specialChars = new RegExp(val.source + (val.test(\"\\t\") ? \"\" : \"|\\t\"), \"g\");\n      if (old != Init) { cm.refresh(); }\n    });\n    option(\"specialCharPlaceholder\", defaultSpecialCharPlaceholder, function (cm) { return cm.refresh(); }, true);\n    option(\"electricChars\", true);\n    option(\"inputStyle\", mobile ? \"contenteditable\" : \"textarea\", function () {\n      throw new Error(\"inputStyle can not (yet) be changed in a running editor\") // FIXME\n    }, true);\n    option(\"spellcheck\", false, function (cm, val) { return cm.getInputField().spellcheck = val; }, true);\n    option(\"autocorrect\", false, function (cm, val) { return cm.getInputField().autocorrect = val; }, true);\n    option(\"autocapitalize\", false, function (cm, val) { return cm.getInputField().autocapitalize = val; }, true);\n    option(\"rtlMoveVisually\", !windows);\n    option(\"wholeLineUpdateBefore\", true);\n\n    option(\"theme\", \"default\", function (cm) {\n      themeChanged(cm);\n      updateGutters(cm);\n    }, true);\n    option(\"keyMap\", \"default\", function (cm, val, old) {\n      var next = getKeyMap(val);\n      var prev = old != Init && getKeyMap(old);\n      if (prev && prev.detach) { prev.detach(cm, next); }\n      if (next.attach) { next.attach(cm, prev || null); }\n    });\n    option(\"extraKeys\", null);\n    option(\"configureMouse\", null);\n\n    option(\"lineWrapping\", false, wrappingChanged, true);\n    option(\"gutters\", [], function (cm, val) {\n      cm.display.gutterSpecs = getGutters(val, cm.options.lineNumbers);\n      updateGutters(cm);\n    }, true);\n    option(\"fixedGutter\", true, function (cm, val) {\n      cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + \"px\" : \"0\";\n      cm.refresh();\n    }, true);\n    option(\"coverGutterNextToScrollbar\", false, function (cm) { return updateScrollbars(cm); }, true);\n    option(\"scrollbarStyle\", \"native\", function (cm) {\n      initScrollbars(cm);\n      updateScrollbars(cm);\n      cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);\n      cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);\n    }, true);\n    option(\"lineNumbers\", false, function (cm, val) {\n      cm.display.gutterSpecs = getGutters(cm.options.gutters, val);\n      updateGutters(cm);\n    }, true);\n    option(\"firstLineNumber\", 1, updateGutters, true);\n    option(\"lineNumberFormatter\", function (integer) { return integer; }, updateGutters, true);\n    option(\"showCursorWhenSelecting\", false, updateSelection, true);\n\n    option(\"resetSelectionOnContextMenu\", true);\n    option(\"lineWiseCopyCut\", true);\n    option(\"pasteLinesPerSelection\", true);\n    option(\"selectionsMayTouch\", false);\n\n    option(\"readOnly\", false, function (cm, val) {\n      if (val == \"nocursor\") {\n        onBlur(cm);\n        cm.display.input.blur();\n      }\n      cm.display.input.readOnlyChanged(val);\n    });\n\n    option(\"screenReaderLabel\", null, function (cm, val) {\n      val = (val === '') ? null : val;\n      cm.display.input.screenReaderLabelChanged(val);\n    });\n\n    option(\"disableInput\", false, function (cm, val) {if (!val) { cm.display.input.reset(); }}, true);\n    option(\"dragDrop\", true, dragDropChanged);\n    option(\"allowDropFileTypes\", null);\n\n    option(\"cursorBlinkRate\", 530);\n    option(\"cursorScrollMargin\", 0);\n    option(\"cursorHeight\", 1, updateSelection, true);\n    option(\"singleCursorHeightPerLine\", true, updateSelection, true);\n    option(\"workTime\", 100);\n    option(\"workDelay\", 100);\n    option(\"flattenSpans\", true, resetModeState, true);\n    option(\"addModeClass\", false, resetModeState, true);\n    option(\"pollInterval\", 100);\n    option(\"undoDepth\", 200, function (cm, val) { return cm.doc.history.undoDepth = val; });\n    option(\"historyEventDelay\", 1250);\n    option(\"viewportMargin\", 10, function (cm) { return cm.refresh(); }, true);\n    option(\"maxHighlightLength\", 10000, resetModeState, true);\n    option(\"moveInputWithCursor\", true, function (cm, val) {\n      if (!val) { cm.display.input.resetPosition(); }\n    });\n\n    option(\"tabindex\", null, function (cm, val) { return cm.display.input.getField().tabIndex = val || \"\"; });\n    option(\"autofocus\", null);\n    option(\"direction\", \"ltr\", function (cm, val) { return cm.doc.setDirection(val); }, true);\n    option(\"phrases\", null);\n  }\n\n  function dragDropChanged(cm, value, old) {\n    var wasOn = old && old != Init;\n    if (!value != !wasOn) {\n      var funcs = cm.display.dragFunctions;\n      var toggle = value ? on : off;\n      toggle(cm.display.scroller, \"dragstart\", funcs.start);\n      toggle(cm.display.scroller, \"dragenter\", funcs.enter);\n      toggle(cm.display.scroller, \"dragover\", funcs.over);\n      toggle(cm.display.scroller, \"dragleave\", funcs.leave);\n      toggle(cm.display.scroller, \"drop\", funcs.drop);\n    }\n  }\n\n  function wrappingChanged(cm) {\n    if (cm.options.lineWrapping) {\n      addClass(cm.display.wrapper, \"CodeMirror-wrap\");\n      cm.display.sizer.style.minWidth = \"\";\n      cm.display.sizerWidth = null;\n    } else {\n      rmClass(cm.display.wrapper, \"CodeMirror-wrap\");\n      findMaxLine(cm);\n    }\n    estimateLineHeights(cm);\n    regChange(cm);\n    clearCaches(cm);\n    setTimeout(function () { return updateScrollbars(cm); }, 100);\n  }\n\n  // A CodeMirror instance represents an editor. This is the object\n  // that user code is usually dealing with.\n\n  function CodeMirror(place, options) {\n    var this$1 = this;\n\n    if (!(this instanceof CodeMirror)) { return new CodeMirror(place, options) }\n\n    this.options = options = options ? copyObj(options) : {};\n    // Determine effective options based on given values and defaults.\n    copyObj(defaults, options, false);\n\n    var doc = options.value;\n    if (typeof doc == \"string\") { doc = new Doc(doc, options.mode, null, options.lineSeparator, options.direction); }\n    else if (options.mode) { doc.modeOption = options.mode; }\n    this.doc = doc;\n\n    var input = new CodeMirror.inputStyles[options.inputStyle](this);\n    var display = this.display = new Display(place, doc, input, options);\n    display.wrapper.CodeMirror = this;\n    themeChanged(this);\n    if (options.lineWrapping)\n      { this.display.wrapper.className += \" CodeMirror-wrap\"; }\n    initScrollbars(this);\n\n    this.state = {\n      keyMaps: [],  // stores maps added by addKeyMap\n      overlays: [], // highlighting overlays, as added by addOverlay\n      modeGen: 0,   // bumped when mode/overlay changes, used to invalidate highlighting info\n      overwrite: false,\n      delayingBlurEvent: false,\n      focused: false,\n      suppressEdits: false, // used to disable editing during key handlers when in readOnly mode\n      pasteIncoming: -1, cutIncoming: -1, // help recognize paste/cut edits in input.poll\n      selectingText: false,\n      draggingText: false,\n      highlight: new Delayed(), // stores highlight worker timeout\n      keySeq: null,  // Unfinished key sequence\n      specialChars: null\n    };\n\n    if (options.autofocus && !mobile) { display.input.focus(); }\n\n    // Override magic textarea content restore that IE sometimes does\n    // on our hidden textarea on reload\n    if (ie && ie_version < 11) { setTimeout(function () { return this$1.display.input.reset(true); }, 20); }\n\n    registerEventHandlers(this);\n    ensureGlobalHandlers();\n\n    startOperation(this);\n    this.curOp.forceUpdate = true;\n    attachDoc(this, doc);\n\n    if ((options.autofocus && !mobile) || this.hasFocus())\n      { setTimeout(function () {\n        if (this$1.hasFocus() && !this$1.state.focused) { onFocus(this$1); }\n      }, 20); }\n    else\n      { onBlur(this); }\n\n    for (var opt in optionHandlers) { if (optionHandlers.hasOwnProperty(opt))\n      { optionHandlers[opt](this, options[opt], Init); } }\n    maybeUpdateLineNumberWidth(this);\n    if (options.finishInit) { options.finishInit(this); }\n    for (var i = 0; i < initHooks.length; ++i) { initHooks[i](this); }\n    endOperation(this);\n    // Suppress optimizelegibility in Webkit, since it breaks text\n    // measuring on line wrapping boundaries.\n    if (webkit && options.lineWrapping &&\n        getComputedStyle(display.lineDiv).textRendering == \"optimizelegibility\")\n      { display.lineDiv.style.textRendering = \"auto\"; }\n  }\n\n  // The default configuration options.\n  CodeMirror.defaults = defaults;\n  // Functions to run when options are changed.\n  CodeMirror.optionHandlers = optionHandlers;\n\n  // Attach the necessary event handlers when initializing the editor\n  function registerEventHandlers(cm) {\n    var d = cm.display;\n    on(d.scroller, \"mousedown\", operation(cm, onMouseDown));\n    // Older IE's will not fire a second mousedown for a double click\n    if (ie && ie_version < 11)\n      { on(d.scroller, \"dblclick\", operation(cm, function (e) {\n        if (signalDOMEvent(cm, e)) { return }\n        var pos = posFromMouse(cm, e);\n        if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) { return }\n        e_preventDefault(e);\n        var word = cm.findWordAt(pos);\n        extendSelection(cm.doc, word.anchor, word.head);\n      })); }\n    else\n      { on(d.scroller, \"dblclick\", function (e) { return signalDOMEvent(cm, e) || e_preventDefault(e); }); }\n    // Some browsers fire contextmenu *after* opening the menu, at\n    // which point we can't mess with it anymore. Context menu is\n    // handled in onMouseDown for these browsers.\n    on(d.scroller, \"contextmenu\", function (e) { return onContextMenu(cm, e); });\n    on(d.input.getField(), \"contextmenu\", function (e) {\n      if (!d.scroller.contains(e.target)) { onContextMenu(cm, e); }\n    });\n\n    // Used to suppress mouse event handling when a touch happens\n    var touchFinished, prevTouch = {end: 0};\n    function finishTouch() {\n      if (d.activeTouch) {\n        touchFinished = setTimeout(function () { return d.activeTouch = null; }, 1000);\n        prevTouch = d.activeTouch;\n        prevTouch.end = +new Date;\n      }\n    }\n    function isMouseLikeTouchEvent(e) {\n      if (e.touches.length != 1) { return false }\n      var touch = e.touches[0];\n      return touch.radiusX <= 1 && touch.radiusY <= 1\n    }\n    function farAway(touch, other) {\n      if (other.left == null) { return true }\n      var dx = other.left - touch.left, dy = other.top - touch.top;\n      return dx * dx + dy * dy > 20 * 20\n    }\n    on(d.scroller, \"touchstart\", function (e) {\n      if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e) && !clickInGutter(cm, e)) {\n        d.input.ensurePolled();\n        clearTimeout(touchFinished);\n        var now = +new Date;\n        d.activeTouch = {start: now, moved: false,\n                         prev: now - prevTouch.end <= 300 ? prevTouch : null};\n        if (e.touches.length == 1) {\n          d.activeTouch.left = e.touches[0].pageX;\n          d.activeTouch.top = e.touches[0].pageY;\n        }\n      }\n    });\n    on(d.scroller, \"touchmove\", function () {\n      if (d.activeTouch) { d.activeTouch.moved = true; }\n    });\n    on(d.scroller, \"touchend\", function (e) {\n      var touch = d.activeTouch;\n      if (touch && !eventInWidget(d, e) && touch.left != null &&\n          !touch.moved && new Date - touch.start < 300) {\n        var pos = cm.coordsChar(d.activeTouch, \"page\"), range;\n        if (!touch.prev || farAway(touch, touch.prev)) // Single tap\n          { range = new Range(pos, pos); }\n        else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) // Double tap\n          { range = cm.findWordAt(pos); }\n        else // Triple tap\n          { range = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))); }\n        cm.setSelection(range.anchor, range.head);\n        cm.focus();\n        e_preventDefault(e);\n      }\n      finishTouch();\n    });\n    on(d.scroller, \"touchcancel\", finishTouch);\n\n    // Sync scrolling between fake scrollbars and real scrollable\n    // area, ensure viewport is updated when scrolling.\n    on(d.scroller, \"scroll\", function () {\n      if (d.scroller.clientHeight) {\n        updateScrollTop(cm, d.scroller.scrollTop);\n        setScrollLeft(cm, d.scroller.scrollLeft, true);\n        signal(cm, \"scroll\", cm);\n      }\n    });\n\n    // Listen to wheel events in order to try and update the viewport on time.\n    on(d.scroller, \"mousewheel\", function (e) { return onScrollWheel(cm, e); });\n    on(d.scroller, \"DOMMouseScroll\", function (e) { return onScrollWheel(cm, e); });\n\n    // Prevent wrapper from ever scrolling\n    on(d.wrapper, \"scroll\", function () { return d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; });\n\n    d.dragFunctions = {\n      enter: function (e) {if (!signalDOMEvent(cm, e)) { e_stop(e); }},\n      over: function (e) {if (!signalDOMEvent(cm, e)) { onDragOver(cm, e); e_stop(e); }},\n      start: function (e) { return onDragStart(cm, e); },\n      drop: operation(cm, onDrop),\n      leave: function (e) {if (!signalDOMEvent(cm, e)) { clearDragCursor(cm); }}\n    };\n\n    var inp = d.input.getField();\n    on(inp, \"keyup\", function (e) { return onKeyUp.call(cm, e); });\n    on(inp, \"keydown\", operation(cm, onKeyDown));\n    on(inp, \"keypress\", operation(cm, onKeyPress));\n    on(inp, \"focus\", function (e) { return onFocus(cm, e); });\n    on(inp, \"blur\", function (e) { return onBlur(cm, e); });\n  }\n\n  var initHooks = [];\n  CodeMirror.defineInitHook = function (f) { return initHooks.push(f); };\n\n  // Indent the given line. The how parameter can be \"smart\",\n  // \"add\"/null, \"subtract\", or \"prev\". When aggressive is false\n  // (typically set to true for forced single-line indents), empty\n  // lines are not indented, and places where the mode returns Pass\n  // are left alone.\n  function indentLine(cm, n, how, aggressive) {\n    var doc = cm.doc, state;\n    if (how == null) { how = \"add\"; }\n    if (how == \"smart\") {\n      // Fall back to \"prev\" when the mode doesn't have an indentation\n      // method.\n      if (!doc.mode.indent) { how = \"prev\"; }\n      else { state = getContextBefore(cm, n).state; }\n    }\n\n    var tabSize = cm.options.tabSize;\n    var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);\n    if (line.stateAfter) { line.stateAfter = null; }\n    var curSpaceString = line.text.match(/^\\s*/)[0], indentation;\n    if (!aggressive && !/\\S/.test(line.text)) {\n      indentation = 0;\n      how = \"not\";\n    } else if (how == \"smart\") {\n      indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);\n      if (indentation == Pass || indentation > 150) {\n        if (!aggressive) { return }\n        how = \"prev\";\n      }\n    }\n    if (how == \"prev\") {\n      if (n > doc.first) { indentation = countColumn(getLine(doc, n-1).text, null, tabSize); }\n      else { indentation = 0; }\n    } else if (how == \"add\") {\n      indentation = curSpace + cm.options.indentUnit;\n    } else if (how == \"subtract\") {\n      indentation = curSpace - cm.options.indentUnit;\n    } else if (typeof how == \"number\") {\n      indentation = curSpace + how;\n    }\n    indentation = Math.max(0, indentation);\n\n    var indentString = \"\", pos = 0;\n    if (cm.options.indentWithTabs)\n      { for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += \"\\t\";} }\n    if (pos < indentation) { indentString += spaceStr(indentation - pos); }\n\n    if (indentString != curSpaceString) {\n      replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), \"+input\");\n      line.stateAfter = null;\n      return true\n    } else {\n      // Ensure that, if the cursor was in the whitespace at the start\n      // of the line, it is moved to the end of that space.\n      for (var i$1 = 0; i$1 < doc.sel.ranges.length; i$1++) {\n        var range = doc.sel.ranges[i$1];\n        if (range.head.line == n && range.head.ch < curSpaceString.length) {\n          var pos$1 = Pos(n, curSpaceString.length);\n          replaceOneSelection(doc, i$1, new Range(pos$1, pos$1));\n          break\n        }\n      }\n    }\n  }\n\n  // This will be set to a {lineWise: bool, text: [string]} object, so\n  // that, when pasting, we know what kind of selections the copied\n  // text was made out of.\n  var lastCopied = null;\n\n  function setLastCopied(newLastCopied) {\n    lastCopied = newLastCopied;\n  }\n\n  function applyTextInput(cm, inserted, deleted, sel, origin) {\n    var doc = cm.doc;\n    cm.display.shift = false;\n    if (!sel) { sel = doc.sel; }\n\n    var recent = +new Date - 200;\n    var paste = origin == \"paste\" || cm.state.pasteIncoming > recent;\n    var textLines = splitLinesAuto(inserted), multiPaste = null;\n    // When pasting N lines into N selections, insert one line per selection\n    if (paste && sel.ranges.length > 1) {\n      if (lastCopied && lastCopied.text.join(\"\\n\") == inserted) {\n        if (sel.ranges.length % lastCopied.text.length == 0) {\n          multiPaste = [];\n          for (var i = 0; i < lastCopied.text.length; i++)\n            { multiPaste.push(doc.splitLines(lastCopied.text[i])); }\n        }\n      } else if (textLines.length == sel.ranges.length && cm.options.pasteLinesPerSelection) {\n        multiPaste = map(textLines, function (l) { return [l]; });\n      }\n    }\n\n    var updateInput = cm.curOp.updateInput;\n    // Normal behavior is to insert the new text into every selection\n    for (var i$1 = sel.ranges.length - 1; i$1 >= 0; i$1--) {\n      var range = sel.ranges[i$1];\n      var from = range.from(), to = range.to();\n      if (range.empty()) {\n        if (deleted && deleted > 0) // Handle deletion\n          { from = Pos(from.line, from.ch - deleted); }\n        else if (cm.state.overwrite && !paste) // Handle overwrite\n          { to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length)); }\n        else if (paste && lastCopied && lastCopied.lineWise && lastCopied.text.join(\"\\n\") == textLines.join(\"\\n\"))\n          { from = to = Pos(from.line, 0); }\n      }\n      var changeEvent = {from: from, to: to, text: multiPaste ? multiPaste[i$1 % multiPaste.length] : textLines,\n                         origin: origin || (paste ? \"paste\" : cm.state.cutIncoming > recent ? \"cut\" : \"+input\")};\n      makeChange(cm.doc, changeEvent);\n      signalLater(cm, \"inputRead\", cm, changeEvent);\n    }\n    if (inserted && !paste)\n      { triggerElectric(cm, inserted); }\n\n    ensureCursorVisible(cm);\n    if (cm.curOp.updateInput < 2) { cm.curOp.updateInput = updateInput; }\n    cm.curOp.typing = true;\n    cm.state.pasteIncoming = cm.state.cutIncoming = -1;\n  }\n\n  function handlePaste(e, cm) {\n    var pasted = e.clipboardData && e.clipboardData.getData(\"Text\");\n    if (pasted) {\n      e.preventDefault();\n      if (!cm.isReadOnly() && !cm.options.disableInput)\n        { runInOp(cm, function () { return applyTextInput(cm, pasted, 0, null, \"paste\"); }); }\n      return true\n    }\n  }\n\n  function triggerElectric(cm, inserted) {\n    // When an 'electric' character is inserted, immediately trigger a reindent\n    if (!cm.options.electricChars || !cm.options.smartIndent) { return }\n    var sel = cm.doc.sel;\n\n    for (var i = sel.ranges.length - 1; i >= 0; i--) {\n      var range = sel.ranges[i];\n      if (range.head.ch > 100 || (i && sel.ranges[i - 1].head.line == range.head.line)) { continue }\n      var mode = cm.getModeAt(range.head);\n      var indented = false;\n      if (mode.electricChars) {\n        for (var j = 0; j < mode.electricChars.length; j++)\n          { if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {\n            indented = indentLine(cm, range.head.line, \"smart\");\n            break\n          } }\n      } else if (mode.electricInput) {\n        if (mode.electricInput.test(getLine(cm.doc, range.head.line).text.slice(0, range.head.ch)))\n          { indented = indentLine(cm, range.head.line, \"smart\"); }\n      }\n      if (indented) { signalLater(cm, \"electricInput\", cm, range.head.line); }\n    }\n  }\n\n  function copyableRanges(cm) {\n    var text = [], ranges = [];\n    for (var i = 0; i < cm.doc.sel.ranges.length; i++) {\n      var line = cm.doc.sel.ranges[i].head.line;\n      var lineRange = {anchor: Pos(line, 0), head: Pos(line + 1, 0)};\n      ranges.push(lineRange);\n      text.push(cm.getRange(lineRange.anchor, lineRange.head));\n    }\n    return {text: text, ranges: ranges}\n  }\n\n  function disableBrowserMagic(field, spellcheck, autocorrect, autocapitalize) {\n    field.setAttribute(\"autocorrect\", autocorrect ? \"\" : \"off\");\n    field.setAttribute(\"autocapitalize\", autocapitalize ? \"\" : \"off\");\n    field.setAttribute(\"spellcheck\", !!spellcheck);\n  }\n\n  function hiddenTextarea() {\n    var te = elt(\"textarea\", null, null, \"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none\");\n    var div = elt(\"div\", [te], null, \"overflow: hidden; position: relative; width: 3px; height: 0px;\");\n    // The textarea is kept positioned near the cursor to prevent the\n    // fact that it'll be scrolled into view on input from scrolling\n    // our fake cursor out of view. On webkit, when wrap=off, paste is\n    // very slow. So make the area wide instead.\n    if (webkit) { te.style.width = \"1000px\"; }\n    else { te.setAttribute(\"wrap\", \"off\"); }\n    // If border: 0; -- iOS fails to open keyboard (issue #1287)\n    if (ios) { te.style.border = \"1px solid black\"; }\n    disableBrowserMagic(te);\n    return div\n  }\n\n  // The publicly visible API. Note that methodOp(f) means\n  // 'wrap f in an operation, performed on its `this` parameter'.\n\n  // This is not the complete set of editor methods. Most of the\n  // methods defined on the Doc type are also injected into\n  // CodeMirror.prototype, for backwards compatibility and\n  // convenience.\n\n  function addEditorMethods(CodeMirror) {\n    var optionHandlers = CodeMirror.optionHandlers;\n\n    var helpers = CodeMirror.helpers = {};\n\n    CodeMirror.prototype = {\n      constructor: CodeMirror,\n      focus: function(){window.focus(); this.display.input.focus();},\n\n      setOption: function(option, value) {\n        var options = this.options, old = options[option];\n        if (options[option] == value && option != \"mode\") { return }\n        options[option] = value;\n        if (optionHandlers.hasOwnProperty(option))\n          { operation(this, optionHandlers[option])(this, value, old); }\n        signal(this, \"optionChange\", this, option);\n      },\n\n      getOption: function(option) {return this.options[option]},\n      getDoc: function() {return this.doc},\n\n      addKeyMap: function(map, bottom) {\n        this.state.keyMaps[bottom ? \"push\" : \"unshift\"](getKeyMap(map));\n      },\n      removeKeyMap: function(map) {\n        var maps = this.state.keyMaps;\n        for (var i = 0; i < maps.length; ++i)\n          { if (maps[i] == map || maps[i].name == map) {\n            maps.splice(i, 1);\n            return true\n          } }\n      },\n\n      addOverlay: methodOp(function(spec, options) {\n        var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);\n        if (mode.startState) { throw new Error(\"Overlays may not be stateful.\") }\n        insertSorted(this.state.overlays,\n                     {mode: mode, modeSpec: spec, opaque: options && options.opaque,\n                      priority: (options && options.priority) || 0},\n                     function (overlay) { return overlay.priority; });\n        this.state.modeGen++;\n        regChange(this);\n      }),\n      removeOverlay: methodOp(function(spec) {\n        var overlays = this.state.overlays;\n        for (var i = 0; i < overlays.length; ++i) {\n          var cur = overlays[i].modeSpec;\n          if (cur == spec || typeof spec == \"string\" && cur.name == spec) {\n            overlays.splice(i, 1);\n            this.state.modeGen++;\n            regChange(this);\n            return\n          }\n        }\n      }),\n\n      indentLine: methodOp(function(n, dir, aggressive) {\n        if (typeof dir != \"string\" && typeof dir != \"number\") {\n          if (dir == null) { dir = this.options.smartIndent ? \"smart\" : \"prev\"; }\n          else { dir = dir ? \"add\" : \"subtract\"; }\n        }\n        if (isLine(this.doc, n)) { indentLine(this, n, dir, aggressive); }\n      }),\n      indentSelection: methodOp(function(how) {\n        var ranges = this.doc.sel.ranges, end = -1;\n        for (var i = 0; i < ranges.length; i++) {\n          var range = ranges[i];\n          if (!range.empty()) {\n            var from = range.from(), to = range.to();\n            var start = Math.max(end, from.line);\n            end = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;\n            for (var j = start; j < end; ++j)\n              { indentLine(this, j, how); }\n            var newRanges = this.doc.sel.ranges;\n            if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0)\n              { replaceOneSelection(this.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll); }\n          } else if (range.head.line > end) {\n            indentLine(this, range.head.line, how, true);\n            end = range.head.line;\n            if (i == this.doc.sel.primIndex) { ensureCursorVisible(this); }\n          }\n        }\n      }),\n\n      // Fetch the parser token for a given character. Useful for hacks\n      // that want to inspect the mode state (say, for completion).\n      getTokenAt: function(pos, precise) {\n        return takeToken(this, pos, precise)\n      },\n\n      getLineTokens: function(line, precise) {\n        return takeToken(this, Pos(line), precise, true)\n      },\n\n      getTokenTypeAt: function(pos) {\n        pos = clipPos(this.doc, pos);\n        var styles = getLineStyles(this, getLine(this.doc, pos.line));\n        var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;\n        var type;\n        if (ch == 0) { type = styles[2]; }\n        else { for (;;) {\n          var mid = (before + after) >> 1;\n          if ((mid ? styles[mid * 2 - 1] : 0) >= ch) { after = mid; }\n          else if (styles[mid * 2 + 1] < ch) { before = mid + 1; }\n          else { type = styles[mid * 2 + 2]; break }\n        } }\n        var cut = type ? type.indexOf(\"overlay \") : -1;\n        return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1)\n      },\n\n      getModeAt: function(pos) {\n        var mode = this.doc.mode;\n        if (!mode.innerMode) { return mode }\n        return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode\n      },\n\n      getHelper: function(pos, type) {\n        return this.getHelpers(pos, type)[0]\n      },\n\n      getHelpers: function(pos, type) {\n        var found = [];\n        if (!helpers.hasOwnProperty(type)) { return found }\n        var help = helpers[type], mode = this.getModeAt(pos);\n        if (typeof mode[type] == \"string\") {\n          if (help[mode[type]]) { found.push(help[mode[type]]); }\n        } else if (mode[type]) {\n          for (var i = 0; i < mode[type].length; i++) {\n            var val = help[mode[type][i]];\n            if (val) { found.push(val); }\n          }\n        } else if (mode.helperType && help[mode.helperType]) {\n          found.push(help[mode.helperType]);\n        } else if (help[mode.name]) {\n          found.push(help[mode.name]);\n        }\n        for (var i$1 = 0; i$1 < help._global.length; i$1++) {\n          var cur = help._global[i$1];\n          if (cur.pred(mode, this) && indexOf(found, cur.val) == -1)\n            { found.push(cur.val); }\n        }\n        return found\n      },\n\n      getStateAfter: function(line, precise) {\n        var doc = this.doc;\n        line = clipLine(doc, line == null ? doc.first + doc.size - 1: line);\n        return getContextBefore(this, line + 1, precise).state\n      },\n\n      cursorCoords: function(start, mode) {\n        var pos, range = this.doc.sel.primary();\n        if (start == null) { pos = range.head; }\n        else if (typeof start == \"object\") { pos = clipPos(this.doc, start); }\n        else { pos = start ? range.from() : range.to(); }\n        return cursorCoords(this, pos, mode || \"page\")\n      },\n\n      charCoords: function(pos, mode) {\n        return charCoords(this, clipPos(this.doc, pos), mode || \"page\")\n      },\n\n      coordsChar: function(coords, mode) {\n        coords = fromCoordSystem(this, coords, mode || \"page\");\n        return coordsChar(this, coords.left, coords.top)\n      },\n\n      lineAtHeight: function(height, mode) {\n        height = fromCoordSystem(this, {top: height, left: 0}, mode || \"page\").top;\n        return lineAtHeight(this.doc, height + this.display.viewOffset)\n      },\n      heightAtLine: function(line, mode, includeWidgets) {\n        var end = false, lineObj;\n        if (typeof line == \"number\") {\n          var last = this.doc.first + this.doc.size - 1;\n          if (line < this.doc.first) { line = this.doc.first; }\n          else if (line > last) { line = last; end = true; }\n          lineObj = getLine(this.doc, line);\n        } else {\n          lineObj = line;\n        }\n        return intoCoordSystem(this, lineObj, {top: 0, left: 0}, mode || \"page\", includeWidgets || end).top +\n          (end ? this.doc.height - heightAtLine(lineObj) : 0)\n      },\n\n      defaultTextHeight: function() { return textHeight(this.display) },\n      defaultCharWidth: function() { return charWidth(this.display) },\n\n      getViewport: function() { return {from: this.display.viewFrom, to: this.display.viewTo}},\n\n      addWidget: function(pos, node, scroll, vert, horiz) {\n        var display = this.display;\n        pos = cursorCoords(this, clipPos(this.doc, pos));\n        var top = pos.bottom, left = pos.left;\n        node.style.position = \"absolute\";\n        node.setAttribute(\"cm-ignore-events\", \"true\");\n        this.display.input.setUneditable(node);\n        display.sizer.appendChild(node);\n        if (vert == \"over\") {\n          top = pos.top;\n        } else if (vert == \"above\" || vert == \"near\") {\n          var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),\n          hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);\n          // Default to positioning above (if specified and possible); otherwise default to positioning below\n          if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)\n            { top = pos.top - node.offsetHeight; }\n          else if (pos.bottom + node.offsetHeight <= vspace)\n            { top = pos.bottom; }\n          if (left + node.offsetWidth > hspace)\n            { left = hspace - node.offsetWidth; }\n        }\n        node.style.top = top + \"px\";\n        node.style.left = node.style.right = \"\";\n        if (horiz == \"right\") {\n          left = display.sizer.clientWidth - node.offsetWidth;\n          node.style.right = \"0px\";\n        } else {\n          if (horiz == \"left\") { left = 0; }\n          else if (horiz == \"middle\") { left = (display.sizer.clientWidth - node.offsetWidth) / 2; }\n          node.style.left = left + \"px\";\n        }\n        if (scroll)\n          { scrollIntoView(this, {left: left, top: top, right: left + node.offsetWidth, bottom: top + node.offsetHeight}); }\n      },\n\n      triggerOnKeyDown: methodOp(onKeyDown),\n      triggerOnKeyPress: methodOp(onKeyPress),\n      triggerOnKeyUp: onKeyUp,\n      triggerOnMouseDown: methodOp(onMouseDown),\n\n      execCommand: function(cmd) {\n        if (commands.hasOwnProperty(cmd))\n          { return commands[cmd].call(null, this) }\n      },\n\n      triggerElectric: methodOp(function(text) { triggerElectric(this, text); }),\n\n      findPosH: function(from, amount, unit, visually) {\n        var dir = 1;\n        if (amount < 0) { dir = -1; amount = -amount; }\n        var cur = clipPos(this.doc, from);\n        for (var i = 0; i < amount; ++i) {\n          cur = findPosH(this.doc, cur, dir, unit, visually);\n          if (cur.hitSide) { break }\n        }\n        return cur\n      },\n\n      moveH: methodOp(function(dir, unit) {\n        var this$1 = this;\n\n        this.extendSelectionsBy(function (range) {\n          if (this$1.display.shift || this$1.doc.extend || range.empty())\n            { return findPosH(this$1.doc, range.head, dir, unit, this$1.options.rtlMoveVisually) }\n          else\n            { return dir < 0 ? range.from() : range.to() }\n        }, sel_move);\n      }),\n\n      deleteH: methodOp(function(dir, unit) {\n        var sel = this.doc.sel, doc = this.doc;\n        if (sel.somethingSelected())\n          { doc.replaceSelection(\"\", null, \"+delete\"); }\n        else\n          { deleteNearSelection(this, function (range) {\n            var other = findPosH(doc, range.head, dir, unit, false);\n            return dir < 0 ? {from: other, to: range.head} : {from: range.head, to: other}\n          }); }\n      }),\n\n      findPosV: function(from, amount, unit, goalColumn) {\n        var dir = 1, x = goalColumn;\n        if (amount < 0) { dir = -1; amount = -amount; }\n        var cur = clipPos(this.doc, from);\n        for (var i = 0; i < amount; ++i) {\n          var coords = cursorCoords(this, cur, \"div\");\n          if (x == null) { x = coords.left; }\n          else { coords.left = x; }\n          cur = findPosV(this, coords, dir, unit);\n          if (cur.hitSide) { break }\n        }\n        return cur\n      },\n\n      moveV: methodOp(function(dir, unit) {\n        var this$1 = this;\n\n        var doc = this.doc, goals = [];\n        var collapse = !this.display.shift && !doc.extend && doc.sel.somethingSelected();\n        doc.extendSelectionsBy(function (range) {\n          if (collapse)\n            { return dir < 0 ? range.from() : range.to() }\n          var headPos = cursorCoords(this$1, range.head, \"div\");\n          if (range.goalColumn != null) { headPos.left = range.goalColumn; }\n          goals.push(headPos.left);\n          var pos = findPosV(this$1, headPos, dir, unit);\n          if (unit == \"page\" && range == doc.sel.primary())\n            { addToScrollTop(this$1, charCoords(this$1, pos, \"div\").top - headPos.top); }\n          return pos\n        }, sel_move);\n        if (goals.length) { for (var i = 0; i < doc.sel.ranges.length; i++)\n          { doc.sel.ranges[i].goalColumn = goals[i]; } }\n      }),\n\n      // Find the word at the given position (as returned by coordsChar).\n      findWordAt: function(pos) {\n        var doc = this.doc, line = getLine(doc, pos.line).text;\n        var start = pos.ch, end = pos.ch;\n        if (line) {\n          var helper = this.getHelper(pos, \"wordChars\");\n          if ((pos.sticky == \"before\" || end == line.length) && start) { --start; } else { ++end; }\n          var startChar = line.charAt(start);\n          var check = isWordChar(startChar, helper)\n            ? function (ch) { return isWordChar(ch, helper); }\n            : /\\s/.test(startChar) ? function (ch) { return /\\s/.test(ch); }\n            : function (ch) { return (!/\\s/.test(ch) && !isWordChar(ch)); };\n          while (start > 0 && check(line.charAt(start - 1))) { --start; }\n          while (end < line.length && check(line.charAt(end))) { ++end; }\n        }\n        return new Range(Pos(pos.line, start), Pos(pos.line, end))\n      },\n\n      toggleOverwrite: function(value) {\n        if (value != null && value == this.state.overwrite) { return }\n        if (this.state.overwrite = !this.state.overwrite)\n          { addClass(this.display.cursorDiv, \"CodeMirror-overwrite\"); }\n        else\n          { rmClass(this.display.cursorDiv, \"CodeMirror-overwrite\"); }\n\n        signal(this, \"overwriteToggle\", this, this.state.overwrite);\n      },\n      hasFocus: function() { return this.display.input.getField() == activeElt() },\n      isReadOnly: function() { return !!(this.options.readOnly || this.doc.cantEdit) },\n\n      scrollTo: methodOp(function (x, y) { scrollToCoords(this, x, y); }),\n      getScrollInfo: function() {\n        var scroller = this.display.scroller;\n        return {left: scroller.scrollLeft, top: scroller.scrollTop,\n                height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,\n                width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,\n                clientHeight: displayHeight(this), clientWidth: displayWidth(this)}\n      },\n\n      scrollIntoView: methodOp(function(range, margin) {\n        if (range == null) {\n          range = {from: this.doc.sel.primary().head, to: null};\n          if (margin == null) { margin = this.options.cursorScrollMargin; }\n        } else if (typeof range == \"number\") {\n          range = {from: Pos(range, 0), to: null};\n        } else if (range.from == null) {\n          range = {from: range, to: null};\n        }\n        if (!range.to) { range.to = range.from; }\n        range.margin = margin || 0;\n\n        if (range.from.line != null) {\n          scrollToRange(this, range);\n        } else {\n          scrollToCoordsRange(this, range.from, range.to, range.margin);\n        }\n      }),\n\n      setSize: methodOp(function(width, height) {\n        var this$1 = this;\n\n        var interpret = function (val) { return typeof val == \"number\" || /^\\d+$/.test(String(val)) ? val + \"px\" : val; };\n        if (width != null) { this.display.wrapper.style.width = interpret(width); }\n        if (height != null) { this.display.wrapper.style.height = interpret(height); }\n        if (this.options.lineWrapping) { clearLineMeasurementCache(this); }\n        var lineNo = this.display.viewFrom;\n        this.doc.iter(lineNo, this.display.viewTo, function (line) {\n          if (line.widgets) { for (var i = 0; i < line.widgets.length; i++)\n            { if (line.widgets[i].noHScroll) { regLineChange(this$1, lineNo, \"widget\"); break } } }\n          ++lineNo;\n        });\n        this.curOp.forceUpdate = true;\n        signal(this, \"refresh\", this);\n      }),\n\n      operation: function(f){return runInOp(this, f)},\n      startOperation: function(){return startOperation(this)},\n      endOperation: function(){return endOperation(this)},\n\n      refresh: methodOp(function() {\n        var oldHeight = this.display.cachedTextHeight;\n        regChange(this);\n        this.curOp.forceUpdate = true;\n        clearCaches(this);\n        scrollToCoords(this, this.doc.scrollLeft, this.doc.scrollTop);\n        updateGutterSpace(this.display);\n        if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5 || this.options.lineWrapping)\n          { estimateLineHeights(this); }\n        signal(this, \"refresh\", this);\n      }),\n\n      swapDoc: methodOp(function(doc) {\n        var old = this.doc;\n        old.cm = null;\n        // Cancel the current text selection if any (#5821)\n        if (this.state.selectingText) { this.state.selectingText(); }\n        attachDoc(this, doc);\n        clearCaches(this);\n        this.display.input.reset();\n        scrollToCoords(this, doc.scrollLeft, doc.scrollTop);\n        this.curOp.forceScroll = true;\n        signalLater(this, \"swapDoc\", this, old);\n        return old\n      }),\n\n      phrase: function(phraseText) {\n        var phrases = this.options.phrases;\n        return phrases && Object.prototype.hasOwnProperty.call(phrases, phraseText) ? phrases[phraseText] : phraseText\n      },\n\n      getInputField: function(){return this.display.input.getField()},\n      getWrapperElement: function(){return this.display.wrapper},\n      getScrollerElement: function(){return this.display.scroller},\n      getGutterElement: function(){return this.display.gutters}\n    };\n    eventMixin(CodeMirror);\n\n    CodeMirror.registerHelper = function(type, name, value) {\n      if (!helpers.hasOwnProperty(type)) { helpers[type] = CodeMirror[type] = {_global: []}; }\n      helpers[type][name] = value;\n    };\n    CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {\n      CodeMirror.registerHelper(type, name, value);\n      helpers[type]._global.push({pred: predicate, val: value});\n    };\n  }\n\n  // Used for horizontal relative motion. Dir is -1 or 1 (left or\n  // right), unit can be \"codepoint\", \"char\", \"column\" (like char, but\n  // doesn't cross line boundaries), \"word\" (across next word), or\n  // \"group\" (to the start of next group of word or\n  // non-word-non-whitespace chars). The visually param controls\n  // whether, in right-to-left text, direction 1 means to move towards\n  // the next index in the string, or towards the character to the right\n  // of the current position. The resulting position will have a\n  // hitSide=true property if it reached the end of the document.\n  function findPosH(doc, pos, dir, unit, visually) {\n    var oldPos = pos;\n    var origDir = dir;\n    var lineObj = getLine(doc, pos.line);\n    var lineDir = visually && doc.direction == \"rtl\" ? -dir : dir;\n    function findNextLine() {\n      var l = pos.line + lineDir;\n      if (l < doc.first || l >= doc.first + doc.size) { return false }\n      pos = new Pos(l, pos.ch, pos.sticky);\n      return lineObj = getLine(doc, l)\n    }\n    function moveOnce(boundToLine) {\n      var next;\n      if (unit == \"codepoint\") {\n        var ch = lineObj.text.charCodeAt(pos.ch + (unit > 0 ? 0 : -1));\n        if (isNaN(ch)) { next = null; }\n        else { next = new Pos(pos.line, Math.max(0, Math.min(lineObj.text.length, pos.ch + dir * (ch >= 0xD800 && ch < 0xDC00 ? 2 : 1))),\n                            -dir); }\n      } else if (visually) {\n        next = moveVisually(doc.cm, lineObj, pos, dir);\n      } else {\n        next = moveLogically(lineObj, pos, dir);\n      }\n      if (next == null) {\n        if (!boundToLine && findNextLine())\n          { pos = endOfLine(visually, doc.cm, lineObj, pos.line, lineDir); }\n        else\n          { return false }\n      } else {\n        pos = next;\n      }\n      return true\n    }\n\n    if (unit == \"char\" || unit == \"codepoint\") {\n      moveOnce();\n    } else if (unit == \"column\") {\n      moveOnce(true);\n    } else if (unit == \"word\" || unit == \"group\") {\n      var sawType = null, group = unit == \"group\";\n      var helper = doc.cm && doc.cm.getHelper(pos, \"wordChars\");\n      for (var first = true;; first = false) {\n        if (dir < 0 && !moveOnce(!first)) { break }\n        var cur = lineObj.text.charAt(pos.ch) || \"\\n\";\n        var type = isWordChar(cur, helper) ? \"w\"\n          : group && cur == \"\\n\" ? \"n\"\n          : !group || /\\s/.test(cur) ? null\n          : \"p\";\n        if (group && !first && !type) { type = \"s\"; }\n        if (sawType && sawType != type) {\n          if (dir < 0) {dir = 1; moveOnce(); pos.sticky = \"after\";}\n          break\n        }\n\n        if (type) { sawType = type; }\n        if (dir > 0 && !moveOnce(!first)) { break }\n      }\n    }\n    var result = skipAtomic(doc, pos, oldPos, origDir, true);\n    if (equalCursorPos(oldPos, result)) { result.hitSide = true; }\n    return result\n  }\n\n  // For relative vertical movement. Dir may be -1 or 1. Unit can be\n  // \"page\" or \"line\". The resulting position will have a hitSide=true\n  // property if it reached the end of the document.\n  function findPosV(cm, pos, dir, unit) {\n    var doc = cm.doc, x = pos.left, y;\n    if (unit == \"page\") {\n      var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);\n      var moveAmount = Math.max(pageSize - .5 * textHeight(cm.display), 3);\n      y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount;\n\n    } else if (unit == \"line\") {\n      y = dir > 0 ? pos.bottom + 3 : pos.top - 3;\n    }\n    var target;\n    for (;;) {\n      target = coordsChar(cm, x, y);\n      if (!target.outside) { break }\n      if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break }\n      y += dir * 5;\n    }\n    return target\n  }\n\n  // CONTENTEDITABLE INPUT STYLE\n\n  var ContentEditableInput = function(cm) {\n    this.cm = cm;\n    this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;\n    this.polling = new Delayed();\n    this.composing = null;\n    this.gracePeriod = false;\n    this.readDOMTimeout = null;\n  };\n\n  ContentEditableInput.prototype.init = function (display) {\n      var this$1 = this;\n\n    var input = this, cm = input.cm;\n    var div = input.div = display.lineDiv;\n    disableBrowserMagic(div, cm.options.spellcheck, cm.options.autocorrect, cm.options.autocapitalize);\n\n    function belongsToInput(e) {\n      for (var t = e.target; t; t = t.parentNode) {\n        if (t == div) { return true }\n        if (/\\bCodeMirror-(?:line)?widget\\b/.test(t.className)) { break }\n      }\n      return false\n    }\n\n    on(div, \"paste\", function (e) {\n      if (!belongsToInput(e) || signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }\n      // IE doesn't fire input events, so we schedule a read for the pasted content in this way\n      if (ie_version <= 11) { setTimeout(operation(cm, function () { return this$1.updateFromDOM(); }), 20); }\n    });\n\n    on(div, \"compositionstart\", function (e) {\n      this$1.composing = {data: e.data, done: false};\n    });\n    on(div, \"compositionupdate\", function (e) {\n      if (!this$1.composing) { this$1.composing = {data: e.data, done: false}; }\n    });\n    on(div, \"compositionend\", function (e) {\n      if (this$1.composing) {\n        if (e.data != this$1.composing.data) { this$1.readFromDOMSoon(); }\n        this$1.composing.done = true;\n      }\n    });\n\n    on(div, \"touchstart\", function () { return input.forceCompositionEnd(); });\n\n    on(div, \"input\", function () {\n      if (!this$1.composing) { this$1.readFromDOMSoon(); }\n    });\n\n    function onCopyCut(e) {\n      if (!belongsToInput(e) || signalDOMEvent(cm, e)) { return }\n      if (cm.somethingSelected()) {\n        setLastCopied({lineWise: false, text: cm.getSelections()});\n        if (e.type == \"cut\") { cm.replaceSelection(\"\", null, \"cut\"); }\n      } else if (!cm.options.lineWiseCopyCut) {\n        return\n      } else {\n        var ranges = copyableRanges(cm);\n        setLastCopied({lineWise: true, text: ranges.text});\n        if (e.type == \"cut\") {\n          cm.operation(function () {\n            cm.setSelections(ranges.ranges, 0, sel_dontScroll);\n            cm.replaceSelection(\"\", null, \"cut\");\n          });\n        }\n      }\n      if (e.clipboardData) {\n        e.clipboardData.clearData();\n        var content = lastCopied.text.join(\"\\n\");\n        // iOS exposes the clipboard API, but seems to discard content inserted into it\n        e.clipboardData.setData(\"Text\", content);\n        if (e.clipboardData.getData(\"Text\") == content) {\n          e.preventDefault();\n          return\n        }\n      }\n      // Old-fashioned briefly-focus-a-textarea hack\n      var kludge = hiddenTextarea(), te = kludge.firstChild;\n      cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);\n      te.value = lastCopied.text.join(\"\\n\");\n      var hadFocus = document.activeElement;\n      selectInput(te);\n      setTimeout(function () {\n        cm.display.lineSpace.removeChild(kludge);\n        hadFocus.focus();\n        if (hadFocus == div) { input.showPrimarySelection(); }\n      }, 50);\n    }\n    on(div, \"copy\", onCopyCut);\n    on(div, \"cut\", onCopyCut);\n  };\n\n  ContentEditableInput.prototype.screenReaderLabelChanged = function (label) {\n    // Label for screenreaders, accessibility\n    if(label) {\n      this.div.setAttribute('aria-label', label);\n    } else {\n      this.div.removeAttribute('aria-label');\n    }\n  };\n\n  ContentEditableInput.prototype.prepareSelection = function () {\n    var result = prepareSelection(this.cm, false);\n    result.focus = document.activeElement == this.div;\n    return result\n  };\n\n  ContentEditableInput.prototype.showSelection = function (info, takeFocus) {\n    if (!info || !this.cm.display.view.length) { return }\n    if (info.focus || takeFocus) { this.showPrimarySelection(); }\n    this.showMultipleSelections(info);\n  };\n\n  ContentEditableInput.prototype.getSelection = function () {\n    return this.cm.display.wrapper.ownerDocument.getSelection()\n  };\n\n  ContentEditableInput.prototype.showPrimarySelection = function () {\n    var sel = this.getSelection(), cm = this.cm, prim = cm.doc.sel.primary();\n    var from = prim.from(), to = prim.to();\n\n    if (cm.display.viewTo == cm.display.viewFrom || from.line >= cm.display.viewTo || to.line < cm.display.viewFrom) {\n      sel.removeAllRanges();\n      return\n    }\n\n    var curAnchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);\n    var curFocus = domToPos(cm, sel.focusNode, sel.focusOffset);\n    if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad &&\n        cmp(minPos(curAnchor, curFocus), from) == 0 &&\n        cmp(maxPos(curAnchor, curFocus), to) == 0)\n      { return }\n\n    var view = cm.display.view;\n    var start = (from.line >= cm.display.viewFrom && posToDOM(cm, from)) ||\n        {node: view[0].measure.map[2], offset: 0};\n    var end = to.line < cm.display.viewTo && posToDOM(cm, to);\n    if (!end) {\n      var measure = view[view.length - 1].measure;\n      var map = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;\n      end = {node: map[map.length - 1], offset: map[map.length - 2] - map[map.length - 3]};\n    }\n\n    if (!start || !end) {\n      sel.removeAllRanges();\n      return\n    }\n\n    var old = sel.rangeCount && sel.getRangeAt(0), rng;\n    try { rng = range(start.node, start.offset, end.offset, end.node); }\n    catch(e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible\n    if (rng) {\n      if (!gecko && cm.state.focused) {\n        sel.collapse(start.node, start.offset);\n        if (!rng.collapsed) {\n          sel.removeAllRanges();\n          sel.addRange(rng);\n        }\n      } else {\n        sel.removeAllRanges();\n        sel.addRange(rng);\n      }\n      if (old && sel.anchorNode == null) { sel.addRange(old); }\n      else if (gecko) { this.startGracePeriod(); }\n    }\n    this.rememberSelection();\n  };\n\n  ContentEditableInput.prototype.startGracePeriod = function () {\n      var this$1 = this;\n\n    clearTimeout(this.gracePeriod);\n    this.gracePeriod = setTimeout(function () {\n      this$1.gracePeriod = false;\n      if (this$1.selectionChanged())\n        { this$1.cm.operation(function () { return this$1.cm.curOp.selectionChanged = true; }); }\n    }, 20);\n  };\n\n  ContentEditableInput.prototype.showMultipleSelections = function (info) {\n    removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);\n    removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);\n  };\n\n  ContentEditableInput.prototype.rememberSelection = function () {\n    var sel = this.getSelection();\n    this.lastAnchorNode = sel.anchorNode; this.lastAnchorOffset = sel.anchorOffset;\n    this.lastFocusNode = sel.focusNode; this.lastFocusOffset = sel.focusOffset;\n  };\n\n  ContentEditableInput.prototype.selectionInEditor = function () {\n    var sel = this.getSelection();\n    if (!sel.rangeCount) { return false }\n    var node = sel.getRangeAt(0).commonAncestorContainer;\n    return contains(this.div, node)\n  };\n\n  ContentEditableInput.prototype.focus = function () {\n    if (this.cm.options.readOnly != \"nocursor\") {\n      if (!this.selectionInEditor() || document.activeElement != this.div)\n        { this.showSelection(this.prepareSelection(), true); }\n      this.div.focus();\n    }\n  };\n  ContentEditableInput.prototype.blur = function () { this.div.blur(); };\n  ContentEditableInput.prototype.getField = function () { return this.div };\n\n  ContentEditableInput.prototype.supportsTouch = function () { return true };\n\n  ContentEditableInput.prototype.receivedFocus = function () {\n    var input = this;\n    if (this.selectionInEditor())\n      { this.pollSelection(); }\n    else\n      { runInOp(this.cm, function () { return input.cm.curOp.selectionChanged = true; }); }\n\n    function poll() {\n      if (input.cm.state.focused) {\n        input.pollSelection();\n        input.polling.set(input.cm.options.pollInterval, poll);\n      }\n    }\n    this.polling.set(this.cm.options.pollInterval, poll);\n  };\n\n  ContentEditableInput.prototype.selectionChanged = function () {\n    var sel = this.getSelection();\n    return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset ||\n      sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset\n  };\n\n  ContentEditableInput.prototype.pollSelection = function () {\n    if (this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged()) { return }\n    var sel = this.getSelection(), cm = this.cm;\n    // On Android Chrome (version 56, at least), backspacing into an\n    // uneditable block element will put the cursor in that element,\n    // and then, because it's not editable, hide the virtual keyboard.\n    // Because Android doesn't allow us to actually detect backspace\n    // presses in a sane way, this code checks for when that happens\n    // and simulates a backspace press in this case.\n    if (android && chrome && this.cm.display.gutterSpecs.length && isInGutter(sel.anchorNode)) {\n      this.cm.triggerOnKeyDown({type: \"keydown\", keyCode: 8, preventDefault: Math.abs});\n      this.blur();\n      this.focus();\n      return\n    }\n    if (this.composing) { return }\n    this.rememberSelection();\n    var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);\n    var head = domToPos(cm, sel.focusNode, sel.focusOffset);\n    if (anchor && head) { runInOp(cm, function () {\n      setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);\n      if (anchor.bad || head.bad) { cm.curOp.selectionChanged = true; }\n    }); }\n  };\n\n  ContentEditableInput.prototype.pollContent = function () {\n    if (this.readDOMTimeout != null) {\n      clearTimeout(this.readDOMTimeout);\n      this.readDOMTimeout = null;\n    }\n\n    var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();\n    var from = sel.from(), to = sel.to();\n    if (from.ch == 0 && from.line > cm.firstLine())\n      { from = Pos(from.line - 1, getLine(cm.doc, from.line - 1).length); }\n    if (to.ch == getLine(cm.doc, to.line).text.length && to.line < cm.lastLine())\n      { to = Pos(to.line + 1, 0); }\n    if (from.line < display.viewFrom || to.line > display.viewTo - 1) { return false }\n\n    var fromIndex, fromLine, fromNode;\n    if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {\n      fromLine = lineNo(display.view[0].line);\n      fromNode = display.view[0].node;\n    } else {\n      fromLine = lineNo(display.view[fromIndex].line);\n      fromNode = display.view[fromIndex - 1].node.nextSibling;\n    }\n    var toIndex = findViewIndex(cm, to.line);\n    var toLine, toNode;\n    if (toIndex == display.view.length - 1) {\n      toLine = display.viewTo - 1;\n      toNode = display.lineDiv.lastChild;\n    } else {\n      toLine = lineNo(display.view[toIndex + 1].line) - 1;\n      toNode = display.view[toIndex + 1].node.previousSibling;\n    }\n\n    if (!fromNode) { return false }\n    var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));\n    var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));\n    while (newText.length > 1 && oldText.length > 1) {\n      if (lst(newText) == lst(oldText)) { newText.pop(); oldText.pop(); toLine--; }\n      else if (newText[0] == oldText[0]) { newText.shift(); oldText.shift(); fromLine++; }\n      else { break }\n    }\n\n    var cutFront = 0, cutEnd = 0;\n    var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);\n    while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront))\n      { ++cutFront; }\n    var newBot = lst(newText), oldBot = lst(oldText);\n    var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0),\n                             oldBot.length - (oldText.length == 1 ? cutFront : 0));\n    while (cutEnd < maxCutEnd &&\n           newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1))\n      { ++cutEnd; }\n    // Try to move start of change to start of selection if ambiguous\n    if (newText.length == 1 && oldText.length == 1 && fromLine == from.line) {\n      while (cutFront && cutFront > from.ch &&\n             newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {\n        cutFront--;\n        cutEnd++;\n      }\n    }\n\n    newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\\u200b+/, \"\");\n    newText[0] = newText[0].slice(cutFront).replace(/\\u200b+$/, \"\");\n\n    var chFrom = Pos(fromLine, cutFront);\n    var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);\n    if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {\n      replaceRange(cm.doc, newText, chFrom, chTo, \"+input\");\n      return true\n    }\n  };\n\n  ContentEditableInput.prototype.ensurePolled = function () {\n    this.forceCompositionEnd();\n  };\n  ContentEditableInput.prototype.reset = function () {\n    this.forceCompositionEnd();\n  };\n  ContentEditableInput.prototype.forceCompositionEnd = function () {\n    if (!this.composing) { return }\n    clearTimeout(this.readDOMTimeout);\n    this.composing = null;\n    this.updateFromDOM();\n    this.div.blur();\n    this.div.focus();\n  };\n  ContentEditableInput.prototype.readFromDOMSoon = function () {\n      var this$1 = this;\n\n    if (this.readDOMTimeout != null) { return }\n    this.readDOMTimeout = setTimeout(function () {\n      this$1.readDOMTimeout = null;\n      if (this$1.composing) {\n        if (this$1.composing.done) { this$1.composing = null; }\n        else { return }\n      }\n      this$1.updateFromDOM();\n    }, 80);\n  };\n\n  ContentEditableInput.prototype.updateFromDOM = function () {\n      var this$1 = this;\n\n    if (this.cm.isReadOnly() || !this.pollContent())\n      { runInOp(this.cm, function () { return regChange(this$1.cm); }); }\n  };\n\n  ContentEditableInput.prototype.setUneditable = function (node) {\n    node.contentEditable = \"false\";\n  };\n\n  ContentEditableInput.prototype.onKeyPress = function (e) {\n    if (e.charCode == 0 || this.composing) { return }\n    e.preventDefault();\n    if (!this.cm.isReadOnly())\n      { operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0); }\n  };\n\n  ContentEditableInput.prototype.readOnlyChanged = function (val) {\n    this.div.contentEditable = String(val != \"nocursor\");\n  };\n\n  ContentEditableInput.prototype.onContextMenu = function () {};\n  ContentEditableInput.prototype.resetPosition = function () {};\n\n  ContentEditableInput.prototype.needsContentAttribute = true;\n\n  function posToDOM(cm, pos) {\n    var view = findViewForLine(cm, pos.line);\n    if (!view || view.hidden) { return null }\n    var line = getLine(cm.doc, pos.line);\n    var info = mapFromLineView(view, line, pos.line);\n\n    var order = getOrder(line, cm.doc.direction), side = \"left\";\n    if (order) {\n      var partPos = getBidiPartAt(order, pos.ch);\n      side = partPos % 2 ? \"right\" : \"left\";\n    }\n    var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);\n    result.offset = result.collapse == \"right\" ? result.end : result.start;\n    return result\n  }\n\n  function isInGutter(node) {\n    for (var scan = node; scan; scan = scan.parentNode)\n      { if (/CodeMirror-gutter-wrapper/.test(scan.className)) { return true } }\n    return false\n  }\n\n  function badPos(pos, bad) { if (bad) { pos.bad = true; } return pos }\n\n  function domTextBetween(cm, from, to, fromLine, toLine) {\n    var text = \"\", closing = false, lineSep = cm.doc.lineSeparator(), extraLinebreak = false;\n    function recognizeMarker(id) { return function (marker) { return marker.id == id; } }\n    function close() {\n      if (closing) {\n        text += lineSep;\n        if (extraLinebreak) { text += lineSep; }\n        closing = extraLinebreak = false;\n      }\n    }\n    function addText(str) {\n      if (str) {\n        close();\n        text += str;\n      }\n    }\n    function walk(node) {\n      if (node.nodeType == 1) {\n        var cmText = node.getAttribute(\"cm-text\");\n        if (cmText) {\n          addText(cmText);\n          return\n        }\n        var markerID = node.getAttribute(\"cm-marker\"), range;\n        if (markerID) {\n          var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));\n          if (found.length && (range = found[0].find(0)))\n            { addText(getBetween(cm.doc, range.from, range.to).join(lineSep)); }\n          return\n        }\n        if (node.getAttribute(\"contenteditable\") == \"false\") { return }\n        var isBlock = /^(pre|div|p|li|table|br)$/i.test(node.nodeName);\n        if (!/^br$/i.test(node.nodeName) && node.textContent.length == 0) { return }\n\n        if (isBlock) { close(); }\n        for (var i = 0; i < node.childNodes.length; i++)\n          { walk(node.childNodes[i]); }\n\n        if (/^(pre|p)$/i.test(node.nodeName)) { extraLinebreak = true; }\n        if (isBlock) { closing = true; }\n      } else if (node.nodeType == 3) {\n        addText(node.nodeValue.replace(/\\u200b/g, \"\").replace(/\\u00a0/g, \" \"));\n      }\n    }\n    for (;;) {\n      walk(from);\n      if (from == to) { break }\n      from = from.nextSibling;\n      extraLinebreak = false;\n    }\n    return text\n  }\n\n  function domToPos(cm, node, offset) {\n    var lineNode;\n    if (node == cm.display.lineDiv) {\n      lineNode = cm.display.lineDiv.childNodes[offset];\n      if (!lineNode) { return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true) }\n      node = null; offset = 0;\n    } else {\n      for (lineNode = node;; lineNode = lineNode.parentNode) {\n        if (!lineNode || lineNode == cm.display.lineDiv) { return null }\n        if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) { break }\n      }\n    }\n    for (var i = 0; i < cm.display.view.length; i++) {\n      var lineView = cm.display.view[i];\n      if (lineView.node == lineNode)\n        { return locateNodeInLineView(lineView, node, offset) }\n    }\n  }\n\n  function locateNodeInLineView(lineView, node, offset) {\n    var wrapper = lineView.text.firstChild, bad = false;\n    if (!node || !contains(wrapper, node)) { return badPos(Pos(lineNo(lineView.line), 0), true) }\n    if (node == wrapper) {\n      bad = true;\n      node = wrapper.childNodes[offset];\n      offset = 0;\n      if (!node) {\n        var line = lineView.rest ? lst(lineView.rest) : lineView.line;\n        return badPos(Pos(lineNo(line), line.text.length), bad)\n      }\n    }\n\n    var textNode = node.nodeType == 3 ? node : null, topNode = node;\n    if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {\n      textNode = node.firstChild;\n      if (offset) { offset = textNode.nodeValue.length; }\n    }\n    while (topNode.parentNode != wrapper) { topNode = topNode.parentNode; }\n    var measure = lineView.measure, maps = measure.maps;\n\n    function find(textNode, topNode, offset) {\n      for (var i = -1; i < (maps ? maps.length : 0); i++) {\n        var map = i < 0 ? measure.map : maps[i];\n        for (var j = 0; j < map.length; j += 3) {\n          var curNode = map[j + 2];\n          if (curNode == textNode || curNode == topNode) {\n            var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]);\n            var ch = map[j] + offset;\n            if (offset < 0 || curNode != textNode) { ch = map[j + (offset ? 1 : 0)]; }\n            return Pos(line, ch)\n          }\n        }\n      }\n    }\n    var found = find(textNode, topNode, offset);\n    if (found) { return badPos(found, bad) }\n\n    // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems\n    for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {\n      found = find(after, after.firstChild, 0);\n      if (found)\n        { return badPos(Pos(found.line, found.ch - dist), bad) }\n      else\n        { dist += after.textContent.length; }\n    }\n    for (var before = topNode.previousSibling, dist$1 = offset; before; before = before.previousSibling) {\n      found = find(before, before.firstChild, -1);\n      if (found)\n        { return badPos(Pos(found.line, found.ch + dist$1), bad) }\n      else\n        { dist$1 += before.textContent.length; }\n    }\n  }\n\n  // TEXTAREA INPUT STYLE\n\n  var TextareaInput = function(cm) {\n    this.cm = cm;\n    // See input.poll and input.reset\n    this.prevInput = \"\";\n\n    // Flag that indicates whether we expect input to appear real soon\n    // now (after some event like 'keypress' or 'input') and are\n    // polling intensively.\n    this.pollingFast = false;\n    // Self-resetting timeout for the poller\n    this.polling = new Delayed();\n    // Used to work around IE issue with selection being forgotten when focus moves away from textarea\n    this.hasSelection = false;\n    this.composing = null;\n  };\n\n  TextareaInput.prototype.init = function (display) {\n      var this$1 = this;\n\n    var input = this, cm = this.cm;\n    this.createField(display);\n    var te = this.textarea;\n\n    display.wrapper.insertBefore(this.wrapper, display.wrapper.firstChild);\n\n    // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)\n    if (ios) { te.style.width = \"0px\"; }\n\n    on(te, \"input\", function () {\n      if (ie && ie_version >= 9 && this$1.hasSelection) { this$1.hasSelection = null; }\n      input.poll();\n    });\n\n    on(te, \"paste\", function (e) {\n      if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }\n\n      cm.state.pasteIncoming = +new Date;\n      input.fastPoll();\n    });\n\n    function prepareCopyCut(e) {\n      if (signalDOMEvent(cm, e)) { return }\n      if (cm.somethingSelected()) {\n        setLastCopied({lineWise: false, text: cm.getSelections()});\n      } else if (!cm.options.lineWiseCopyCut) {\n        return\n      } else {\n        var ranges = copyableRanges(cm);\n        setLastCopied({lineWise: true, text: ranges.text});\n        if (e.type == \"cut\") {\n          cm.setSelections(ranges.ranges, null, sel_dontScroll);\n        } else {\n          input.prevInput = \"\";\n          te.value = ranges.text.join(\"\\n\");\n          selectInput(te);\n        }\n      }\n      if (e.type == \"cut\") { cm.state.cutIncoming = +new Date; }\n    }\n    on(te, \"cut\", prepareCopyCut);\n    on(te, \"copy\", prepareCopyCut);\n\n    on(display.scroller, \"paste\", function (e) {\n      if (eventInWidget(display, e) || signalDOMEvent(cm, e)) { return }\n      if (!te.dispatchEvent) {\n        cm.state.pasteIncoming = +new Date;\n        input.focus();\n        return\n      }\n\n      // Pass the `paste` event to the textarea so it's handled by its event listener.\n      var event = new Event(\"paste\");\n      event.clipboardData = e.clipboardData;\n      te.dispatchEvent(event);\n    });\n\n    // Prevent normal selection in the editor (we handle our own)\n    on(display.lineSpace, \"selectstart\", function (e) {\n      if (!eventInWidget(display, e)) { e_preventDefault(e); }\n    });\n\n    on(te, \"compositionstart\", function () {\n      var start = cm.getCursor(\"from\");\n      if (input.composing) { input.composing.range.clear(); }\n      input.composing = {\n        start: start,\n        range: cm.markText(start, cm.getCursor(\"to\"), {className: \"CodeMirror-composing\"})\n      };\n    });\n    on(te, \"compositionend\", function () {\n      if (input.composing) {\n        input.poll();\n        input.composing.range.clear();\n        input.composing = null;\n      }\n    });\n  };\n\n  TextareaInput.prototype.createField = function (_display) {\n    // Wraps and hides input textarea\n    this.wrapper = hiddenTextarea();\n    // The semihidden textarea that is focused when the editor is\n    // focused, and receives input.\n    this.textarea = this.wrapper.firstChild;\n  };\n\n  TextareaInput.prototype.screenReaderLabelChanged = function (label) {\n    // Label for screenreaders, accessibility\n    if(label) {\n      this.textarea.setAttribute('aria-label', label);\n    } else {\n      this.textarea.removeAttribute('aria-label');\n    }\n  };\n\n  TextareaInput.prototype.prepareSelection = function () {\n    // Redraw the selection and/or cursor\n    var cm = this.cm, display = cm.display, doc = cm.doc;\n    var result = prepareSelection(cm);\n\n    // Move the hidden textarea near the cursor to prevent scrolling artifacts\n    if (cm.options.moveInputWithCursor) {\n      var headPos = cursorCoords(cm, doc.sel.primary().head, \"div\");\n      var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();\n      result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10,\n                                          headPos.top + lineOff.top - wrapOff.top));\n      result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10,\n                                           headPos.left + lineOff.left - wrapOff.left));\n    }\n\n    return result\n  };\n\n  TextareaInput.prototype.showSelection = function (drawn) {\n    var cm = this.cm, display = cm.display;\n    removeChildrenAndAdd(display.cursorDiv, drawn.cursors);\n    removeChildrenAndAdd(display.selectionDiv, drawn.selection);\n    if (drawn.teTop != null) {\n      this.wrapper.style.top = drawn.teTop + \"px\";\n      this.wrapper.style.left = drawn.teLeft + \"px\";\n    }\n  };\n\n  // Reset the input to correspond to the selection (or to be empty,\n  // when not typing and nothing is selected)\n  TextareaInput.prototype.reset = function (typing) {\n    if (this.contextMenuPending || this.composing) { return }\n    var cm = this.cm;\n    if (cm.somethingSelected()) {\n      this.prevInput = \"\";\n      var content = cm.getSelection();\n      this.textarea.value = content;\n      if (cm.state.focused) { selectInput(this.textarea); }\n      if (ie && ie_version >= 9) { this.hasSelection = content; }\n    } else if (!typing) {\n      this.prevInput = this.textarea.value = \"\";\n      if (ie && ie_version >= 9) { this.hasSelection = null; }\n    }\n  };\n\n  TextareaInput.prototype.getField = function () { return this.textarea };\n\n  TextareaInput.prototype.supportsTouch = function () { return false };\n\n  TextareaInput.prototype.focus = function () {\n    if (this.cm.options.readOnly != \"nocursor\" && (!mobile || activeElt() != this.textarea)) {\n      try { this.textarea.focus(); }\n      catch (e) {} // IE8 will throw if the textarea is display: none or not in DOM\n    }\n  };\n\n  TextareaInput.prototype.blur = function () { this.textarea.blur(); };\n\n  TextareaInput.prototype.resetPosition = function () {\n    this.wrapper.style.top = this.wrapper.style.left = 0;\n  };\n\n  TextareaInput.prototype.receivedFocus = function () { this.slowPoll(); };\n\n  // Poll for input changes, using the normal rate of polling. This\n  // runs as long as the editor is focused.\n  TextareaInput.prototype.slowPoll = function () {\n      var this$1 = this;\n\n    if (this.pollingFast) { return }\n    this.polling.set(this.cm.options.pollInterval, function () {\n      this$1.poll();\n      if (this$1.cm.state.focused) { this$1.slowPoll(); }\n    });\n  };\n\n  // When an event has just come in that is likely to add or change\n  // something in the input textarea, we poll faster, to ensure that\n  // the change appears on the screen quickly.\n  TextareaInput.prototype.fastPoll = function () {\n    var missed = false, input = this;\n    input.pollingFast = true;\n    function p() {\n      var changed = input.poll();\n      if (!changed && !missed) {missed = true; input.polling.set(60, p);}\n      else {input.pollingFast = false; input.slowPoll();}\n    }\n    input.polling.set(20, p);\n  };\n\n  // Read input from the textarea, and update the document to match.\n  // When something is selected, it is present in the textarea, and\n  // selected (unless it is huge, in which case a placeholder is\n  // used). When nothing is selected, the cursor sits after previously\n  // seen text (can be empty), which is stored in prevInput (we must\n  // not reset the textarea when typing, because that breaks IME).\n  TextareaInput.prototype.poll = function () {\n      var this$1 = this;\n\n    var cm = this.cm, input = this.textarea, prevInput = this.prevInput;\n    // Since this is called a *lot*, try to bail out as cheaply as\n    // possible when it is clear that nothing happened. hasSelection\n    // will be the case when there is a lot of text in the textarea,\n    // in which case reading its value would be expensive.\n    if (this.contextMenuPending || !cm.state.focused ||\n        (hasSelection(input) && !prevInput && !this.composing) ||\n        cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq)\n      { return false }\n\n    var text = input.value;\n    // If nothing changed, bail.\n    if (text == prevInput && !cm.somethingSelected()) { return false }\n    // Work around nonsensical selection resetting in IE9/10, and\n    // inexplicable appearance of private area unicode characters on\n    // some key combos in Mac (#2689).\n    if (ie && ie_version >= 9 && this.hasSelection === text ||\n        mac && /[\\uf700-\\uf7ff]/.test(text)) {\n      cm.display.input.reset();\n      return false\n    }\n\n    if (cm.doc.sel == cm.display.selForContextMenu) {\n      var first = text.charCodeAt(0);\n      if (first == 0x200b && !prevInput) { prevInput = \"\\u200b\"; }\n      if (first == 0x21da) { this.reset(); return this.cm.execCommand(\"undo\") }\n    }\n    // Find the part of the input that is actually new\n    var same = 0, l = Math.min(prevInput.length, text.length);\n    while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) { ++same; }\n\n    runInOp(cm, function () {\n      applyTextInput(cm, text.slice(same), prevInput.length - same,\n                     null, this$1.composing ? \"*compose\" : null);\n\n      // Don't leave long text in the textarea, since it makes further polling slow\n      if (text.length > 1000 || text.indexOf(\"\\n\") > -1) { input.value = this$1.prevInput = \"\"; }\n      else { this$1.prevInput = text; }\n\n      if (this$1.composing) {\n        this$1.composing.range.clear();\n        this$1.composing.range = cm.markText(this$1.composing.start, cm.getCursor(\"to\"),\n                                           {className: \"CodeMirror-composing\"});\n      }\n    });\n    return true\n  };\n\n  TextareaInput.prototype.ensurePolled = function () {\n    if (this.pollingFast && this.poll()) { this.pollingFast = false; }\n  };\n\n  TextareaInput.prototype.onKeyPress = function () {\n    if (ie && ie_version >= 9) { this.hasSelection = null; }\n    this.fastPoll();\n  };\n\n  TextareaInput.prototype.onContextMenu = function (e) {\n    var input = this, cm = input.cm, display = cm.display, te = input.textarea;\n    if (input.contextMenuPending) { input.contextMenuPending(); }\n    var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;\n    if (!pos || presto) { return } // Opera is difficult.\n\n    // Reset the current text selection only if the click is done outside of the selection\n    // and 'resetSelectionOnContextMenu' option is true.\n    var reset = cm.options.resetSelectionOnContextMenu;\n    if (reset && cm.doc.sel.contains(pos) == -1)\n      { operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll); }\n\n    var oldCSS = te.style.cssText, oldWrapperCSS = input.wrapper.style.cssText;\n    var wrapperBox = input.wrapper.offsetParent.getBoundingClientRect();\n    input.wrapper.style.cssText = \"position: static\";\n    te.style.cssText = \"position: absolute; width: 30px; height: 30px;\\n      top: \" + (e.clientY - wrapperBox.top - 5) + \"px; left: \" + (e.clientX - wrapperBox.left - 5) + \"px;\\n      z-index: 1000; background: \" + (ie ? \"rgba(255, 255, 255, .05)\" : \"transparent\") + \";\\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);\";\n    var oldScrollY;\n    if (webkit) { oldScrollY = window.scrollY; } // Work around Chrome issue (#2712)\n    display.input.focus();\n    if (webkit) { window.scrollTo(null, oldScrollY); }\n    display.input.reset();\n    // Adds \"Select all\" to context menu in FF\n    if (!cm.somethingSelected()) { te.value = input.prevInput = \" \"; }\n    input.contextMenuPending = rehide;\n    display.selForContextMenu = cm.doc.sel;\n    clearTimeout(display.detectingSelectAll);\n\n    // Select-all will be greyed out if there's nothing to select, so\n    // this adds a zero-width space so that we can later check whether\n    // it got selected.\n    function prepareSelectAllHack() {\n      if (te.selectionStart != null) {\n        var selected = cm.somethingSelected();\n        var extval = \"\\u200b\" + (selected ? te.value : \"\");\n        te.value = \"\\u21da\"; // Used to catch context-menu undo\n        te.value = extval;\n        input.prevInput = selected ? \"\" : \"\\u200b\";\n        te.selectionStart = 1; te.selectionEnd = extval.length;\n        // Re-set this, in case some other handler touched the\n        // selection in the meantime.\n        display.selForContextMenu = cm.doc.sel;\n      }\n    }\n    function rehide() {\n      if (input.contextMenuPending != rehide) { return }\n      input.contextMenuPending = false;\n      input.wrapper.style.cssText = oldWrapperCSS;\n      te.style.cssText = oldCSS;\n      if (ie && ie_version < 9) { display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos); }\n\n      // Try to detect the user choosing select-all\n      if (te.selectionStart != null) {\n        if (!ie || (ie && ie_version < 9)) { prepareSelectAllHack(); }\n        var i = 0, poll = function () {\n          if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 &&\n              te.selectionEnd > 0 && input.prevInput == \"\\u200b\") {\n            operation(cm, selectAll)(cm);\n          } else if (i++ < 10) {\n            display.detectingSelectAll = setTimeout(poll, 500);\n          } else {\n            display.selForContextMenu = null;\n            display.input.reset();\n          }\n        };\n        display.detectingSelectAll = setTimeout(poll, 200);\n      }\n    }\n\n    if (ie && ie_version >= 9) { prepareSelectAllHack(); }\n    if (captureRightClick) {\n      e_stop(e);\n      var mouseup = function () {\n        off(window, \"mouseup\", mouseup);\n        setTimeout(rehide, 20);\n      };\n      on(window, \"mouseup\", mouseup);\n    } else {\n      setTimeout(rehide, 50);\n    }\n  };\n\n  TextareaInput.prototype.readOnlyChanged = function (val) {\n    if (!val) { this.reset(); }\n    this.textarea.disabled = val == \"nocursor\";\n    this.textarea.readOnly = !!val;\n  };\n\n  TextareaInput.prototype.setUneditable = function () {};\n\n  TextareaInput.prototype.needsContentAttribute = false;\n\n  function fromTextArea(textarea, options) {\n    options = options ? copyObj(options) : {};\n    options.value = textarea.value;\n    if (!options.tabindex && textarea.tabIndex)\n      { options.tabindex = textarea.tabIndex; }\n    if (!options.placeholder && textarea.placeholder)\n      { options.placeholder = textarea.placeholder; }\n    // Set autofocus to true if this textarea is focused, or if it has\n    // autofocus and no other element is focused.\n    if (options.autofocus == null) {\n      var hasFocus = activeElt();\n      options.autofocus = hasFocus == textarea ||\n        textarea.getAttribute(\"autofocus\") != null && hasFocus == document.body;\n    }\n\n    function save() {textarea.value = cm.getValue();}\n\n    var realSubmit;\n    if (textarea.form) {\n      on(textarea.form, \"submit\", save);\n      // Deplorable hack to make the submit method do the right thing.\n      if (!options.leaveSubmitMethodAlone) {\n        var form = textarea.form;\n        realSubmit = form.submit;\n        try {\n          var wrappedSubmit = form.submit = function () {\n            save();\n            form.submit = realSubmit;\n            form.submit();\n            form.submit = wrappedSubmit;\n          };\n        } catch(e) {}\n      }\n    }\n\n    options.finishInit = function (cm) {\n      cm.save = save;\n      cm.getTextArea = function () { return textarea; };\n      cm.toTextArea = function () {\n        cm.toTextArea = isNaN; // Prevent this from being ran twice\n        save();\n        textarea.parentNode.removeChild(cm.getWrapperElement());\n        textarea.style.display = \"\";\n        if (textarea.form) {\n          off(textarea.form, \"submit\", save);\n          if (!options.leaveSubmitMethodAlone && typeof textarea.form.submit == \"function\")\n            { textarea.form.submit = realSubmit; }\n        }\n      };\n    };\n\n    textarea.style.display = \"none\";\n    var cm = CodeMirror(function (node) { return textarea.parentNode.insertBefore(node, textarea.nextSibling); },\n      options);\n    return cm\n  }\n\n  function addLegacyProps(CodeMirror) {\n    CodeMirror.off = off;\n    CodeMirror.on = on;\n    CodeMirror.wheelEventPixels = wheelEventPixels;\n    CodeMirror.Doc = Doc;\n    CodeMirror.splitLines = splitLinesAuto;\n    CodeMirror.countColumn = countColumn;\n    CodeMirror.findColumn = findColumn;\n    CodeMirror.isWordChar = isWordCharBasic;\n    CodeMirror.Pass = Pass;\n    CodeMirror.signal = signal;\n    CodeMirror.Line = Line;\n    CodeMirror.changeEnd = changeEnd;\n    CodeMirror.scrollbarModel = scrollbarModel;\n    CodeMirror.Pos = Pos;\n    CodeMirror.cmpPos = cmp;\n    CodeMirror.modes = modes;\n    CodeMirror.mimeModes = mimeModes;\n    CodeMirror.resolveMode = resolveMode;\n    CodeMirror.getMode = getMode;\n    CodeMirror.modeExtensions = modeExtensions;\n    CodeMirror.extendMode = extendMode;\n    CodeMirror.copyState = copyState;\n    CodeMirror.startState = startState;\n    CodeMirror.innerMode = innerMode;\n    CodeMirror.commands = commands;\n    CodeMirror.keyMap = keyMap;\n    CodeMirror.keyName = keyName;\n    CodeMirror.isModifierKey = isModifierKey;\n    CodeMirror.lookupKey = lookupKey;\n    CodeMirror.normalizeKeyMap = normalizeKeyMap;\n    CodeMirror.StringStream = StringStream;\n    CodeMirror.SharedTextMarker = SharedTextMarker;\n    CodeMirror.TextMarker = TextMarker;\n    CodeMirror.LineWidget = LineWidget;\n    CodeMirror.e_preventDefault = e_preventDefault;\n    CodeMirror.e_stopPropagation = e_stopPropagation;\n    CodeMirror.e_stop = e_stop;\n    CodeMirror.addClass = addClass;\n    CodeMirror.contains = contains;\n    CodeMirror.rmClass = rmClass;\n    CodeMirror.keyNames = keyNames;\n  }\n\n  // EDITOR CONSTRUCTOR\n\n  defineOptions(CodeMirror);\n\n  addEditorMethods(CodeMirror);\n\n  // Set up methods on CodeMirror's prototype to redirect to the editor's document.\n  var dontDelegate = \"iter insert remove copy getEditor constructor\".split(\" \");\n  for (var prop in Doc.prototype) { if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)\n    { CodeMirror.prototype[prop] = (function(method) {\n      return function() {return method.apply(this.doc, arguments)}\n    })(Doc.prototype[prop]); } }\n\n  eventMixin(Doc);\n  CodeMirror.inputStyles = {\"textarea\": TextareaInput, \"contenteditable\": ContentEditableInput};\n\n  // Extra arguments are stored as the mode's dependencies, which is\n  // used by (legacy) mechanisms like loadmode.js to automatically\n  // load a mode. (Preferred mechanism is the require/define calls.)\n  CodeMirror.defineMode = function(name/*, mode, …*/) {\n    if (!CodeMirror.defaults.mode && name != \"null\") { CodeMirror.defaults.mode = name; }\n    defineMode.apply(this, arguments);\n  };\n\n  CodeMirror.defineMIME = defineMIME;\n\n  // Minimal default mode.\n  CodeMirror.defineMode(\"null\", function () { return ({token: function (stream) { return stream.skipToEnd(); }}); });\n  CodeMirror.defineMIME(\"text/plain\", \"null\");\n\n  // EXTENSIONS\n\n  CodeMirror.defineExtension = function (name, func) {\n    CodeMirror.prototype[name] = func;\n  };\n  CodeMirror.defineDocExtension = function (name, func) {\n    Doc.prototype[name] = func;\n  };\n\n  CodeMirror.fromTextArea = fromTextArea;\n\n  addLegacyProps(CodeMirror);\n\n  CodeMirror.version = \"5.59.0\";\n\n  return CodeMirror;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29kZW1pcnJvci9saWIvY29kZW1pcnJvci5qcz81NmIzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUUsS0FBNEQ7QUFDOUQsRUFBRSxTQUN3RDtBQUMxRCxDQUFDLHFCQUFxQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQyxHQUFHO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLDRDQUE0QztBQUNuRSwrQ0FBK0MsZ0JBQWdCLGVBQWU7QUFDOUU7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlDQUF5QyxXQUFXO0FBQ3BELE9BQU8sNkJBQTZCO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IseUJBQXlCO0FBQzdDLGdCQUFnQix5QkFBeUI7QUFDekMscUNBQXFDLGlEQUFpRDtBQUN0Rix1QkFBdUIsZ0JBQWdCLG9CQUFvQixPQUFPLDJCQUEyQixFQUFFO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osUUFBUTtBQUNSO0FBQ0EsU0FBUyxzQ0FBc0M7QUFDL0MsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsT0FBTywwQkFBMEI7QUFDakM7QUFDQSxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsb0JBQW9CO0FBQ3JELDRCQUE0QjtBQUM1QixLQUFLO0FB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QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxDQUFDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2NvZGVtaXJyb3IvbGliL2NvZGVtaXJyb3IuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb2RlTWlycm9yLCBjb3B5cmlnaHQgKGMpIGJ5IE1hcmlqbiBIYXZlcmJla2UgYW5kIG90aGVyc1xuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgYW4gTUlUIGxpY2Vuc2U6IGh0dHBzOi8vY29kZW1pcnJvci5uZXQvTElDRU5TRVxuXG4vLyBUaGlzIGlzIENvZGVNaXJyb3IgKGh0dHBzOi8vY29kZW1pcnJvci5uZXQpLCBhIGNvZGUgZWRpdG9yXG4vLyBpbXBsZW1lbnRlZCBpbiBKYXZhU2NyaXB0IG9uIHRvcCBvZiB0aGUgYnJvd3NlcidzIERPTS5cbi8vXG4vLyBZb3UgY2FuIGZpbmQgc29tZSB0ZWNobmljYWwgYmFja2dyb3VuZCBmb3Igc29tZSBvZiB0aGUgY29kZSBiZWxvd1xuLy8gYXQgaHR0cDovL21hcmlqbmhhdmVyYmVrZS5ubC9ibG9nLyNjbS1pbnRlcm5hbHMgLlxuXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG4gIChnbG9iYWwgPSBnbG9iYWwgfHwgc2VsZiwgZ2xvYmFsLkNvZGVNaXJyb3IgPSBmYWN0b3J5KCkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbiAgLy8gS2x1ZGdlcyBmb3IgYnVncyBhbmQgYmVoYXZpb3IgZGlmZmVyZW5jZXMgdGhhdCBjYW4ndCBiZSBmZWF0dXJlXG4gIC8vIGRldGVjdGVkIGFyZSBlbmFibGVkIGJhc2VkIG9uIHVzZXJBZ2VudCBldGMgc25pZmZpbmcuXG4gIHZhciB1c2VyQWdlbnQgPSBuYXZpZ2F0b3IudXNlckFnZW50O1xuICB2YXIgcGxhdGZvcm0gPSBuYXZpZ2F0b3IucGxhdGZvcm07XG5cbiAgdmFyIGdlY2tvID0gL2dlY2tvXFwvXFxkL2kudGVzdCh1c2VyQWdlbnQpO1xuICB2YXIgaWVfdXB0bzEwID0gL01TSUUgXFxkLy50ZXN0KHVzZXJBZ2VudCk7XG4gIHZhciBpZV8xMXVwID0gL1RyaWRlbnRcXC8oPzpbNy05XXxcXGR7Mix9KVxcLi4qcnY6KFxcZCspLy5leGVjKHVzZXJBZ2VudCk7XG4gIHZhciBlZGdlID0gL0VkZ2VcXC8oXFxkKykvLmV4ZWModXNlckFnZW50KTtcbiAgdmFyIGllID0gaWVfdXB0bzEwIHx8IGllXzExdXAgfHwgZWRnZTtcbiAgdmFyIGllX3ZlcnNpb24gPSBpZSAmJiAoaWVfdXB0bzEwID8gZG9jdW1lbnQuZG9jdW1lbnRNb2RlIHx8IDYgOiArKGVkZ2UgfHwgaWVfMTF1cClbMV0pO1xuICB2YXIgd2Via2l0ID0gIWVkZ2UgJiYgL1dlYktpdFxcLy8udGVzdCh1c2VyQWdlbnQpO1xuICB2YXIgcXR3ZWJraXQgPSB3ZWJraXQgJiYgL1F0XFwvXFxkK1xcLlxcZCsvLnRlc3QodXNlckFnZW50KTtcbiAgdmFyIGNocm9tZSA9ICFlZGdlICYmIC9DaHJvbWVcXC8vLnRlc3QodXNlckFnZW50KTtcbiAgdmFyIHByZXN0byA9IC9PcGVyYVxcLy8udGVzdCh1c2VyQWdlbnQpO1xuICB2YXIgc2FmYXJpID0gL0FwcGxlIENvbXB1dGVyLy50ZXN0KG5hdmlnYXRvci52ZW5kb3IpO1xuICB2YXIgbWFjX2dlTW91bnRhaW5MaW9uID0gL01hYyBPUyBYIDFcXGRcXEQoWzgtOV18XFxkXFxkKVxcRC8udGVzdCh1c2VyQWdlbnQpO1xuICB2YXIgcGhhbnRvbSA9IC9QaGFudG9tSlMvLnRlc3QodXNlckFnZW50KTtcblxuICB2YXIgaW9zID0gIWVkZ2UgJiYgL0FwcGxlV2ViS2l0Ly50ZXN0KHVzZXJBZ2VudCkgJiYgKC9Nb2JpbGVcXC9cXHcrLy50ZXN0KHVzZXJBZ2VudCkgfHwgbmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzID4gMik7XG4gIHZhciBhbmRyb2lkID0gL0FuZHJvaWQvLnRlc3QodXNlckFnZW50KTtcbiAgLy8gVGhpcyBpcyB3b2VmdWxseSBpbmNvbXBsZXRlLiBTdWdnZXN0aW9ucyBmb3IgYWx0ZXJuYXRpdmUgbWV0aG9kcyB3ZWxjb21lLlxuICB2YXIgbW9iaWxlID0gaW9zIHx8IGFuZHJvaWQgfHwgL3dlYk9TfEJsYWNrQmVycnl8T3BlcmEgTWluaXxPcGVyYSBNb2JpfElFTW9iaWxlL2kudGVzdCh1c2VyQWdlbnQpO1xuICB2YXIgbWFjID0gaW9zIHx8IC9NYWMvLnRlc3QocGxhdGZvcm0pO1xuICB2YXIgY2hyb21lT1MgPSAvXFxiQ3JPU1xcYi8udGVzdCh1c2VyQWdlbnQpO1xuICB2YXIgd2luZG93cyA9IC93aW4vaS50ZXN0KHBsYXRmb3JtKTtcblxuICB2YXIgcHJlc3RvX3ZlcnNpb24gPSBwcmVzdG8gJiYgdXNlckFnZW50Lm1hdGNoKC9WZXJzaW9uXFwvKFxcZCpcXC5cXGQqKS8pO1xuICBpZiAocHJlc3RvX3ZlcnNpb24pIHsgcHJlc3RvX3ZlcnNpb24gPSBOdW1iZXIocHJlc3RvX3ZlcnNpb25bMV0pOyB9XG4gIGlmIChwcmVzdG9fdmVyc2lvbiAmJiBwcmVzdG9fdmVyc2lvbiA+PSAxNSkgeyBwcmVzdG8gPSBmYWxzZTsgd2Via2l0ID0gdHJ1ZTsgfVxuICAvLyBTb21lIGJyb3dzZXJzIHVzZSB0aGUgd3JvbmcgZXZlbnQgcHJvcGVydGllcyB0byBzaWduYWwgY21kL2N0cmwgb24gT1MgWFxuICB2YXIgZmxpcEN0cmxDbWQgPSBtYWMgJiYgKHF0d2Via2l0IHx8IHByZXN0byAmJiAocHJlc3RvX3ZlcnNpb24gPT0gbnVsbCB8fCBwcmVzdG9fdmVyc2lvbiA8IDEyLjExKSk7XG4gIHZhciBjYXB0dXJlUmlnaHRDbGljayA9IGdlY2tvIHx8IChpZSAmJiBpZV92ZXJzaW9uID49IDkpO1xuXG4gIGZ1bmN0aW9uIGNsYXNzVGVzdChjbHMpIHsgcmV0dXJuIG5ldyBSZWdFeHAoXCIoXnxcXFxccylcIiArIGNscyArIFwiKD86JHxcXFxccylcXFxccypcIikgfVxuXG4gIHZhciBybUNsYXNzID0gZnVuY3Rpb24obm9kZSwgY2xzKSB7XG4gICAgdmFyIGN1cnJlbnQgPSBub2RlLmNsYXNzTmFtZTtcbiAgICB2YXIgbWF0Y2ggPSBjbGFzc1Rlc3QoY2xzKS5leGVjKGN1cnJlbnQpO1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgdmFyIGFmdGVyID0gY3VycmVudC5zbGljZShtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCk7XG4gICAgICBub2RlLmNsYXNzTmFtZSA9IGN1cnJlbnQuc2xpY2UoMCwgbWF0Y2guaW5kZXgpICsgKGFmdGVyID8gbWF0Y2hbMV0gKyBhZnRlciA6IFwiXCIpO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiByZW1vdmVDaGlsZHJlbihlKSB7XG4gICAgZm9yICh2YXIgY291bnQgPSBlLmNoaWxkTm9kZXMubGVuZ3RoOyBjb3VudCA+IDA7IC0tY291bnQpXG4gICAgICB7IGUucmVtb3ZlQ2hpbGQoZS5maXJzdENoaWxkKTsgfVxuICAgIHJldHVybiBlXG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVDaGlsZHJlbkFuZEFkZChwYXJlbnQsIGUpIHtcbiAgICByZXR1cm4gcmVtb3ZlQ2hpbGRyZW4ocGFyZW50KS5hcHBlbmRDaGlsZChlKVxuICB9XG5cbiAgZnVuY3Rpb24gZWx0KHRhZywgY29udGVudCwgY2xhc3NOYW1lLCBzdHlsZSkge1xuICAgIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgIGlmIChjbGFzc05hbWUpIHsgZS5jbGFzc05hbWUgPSBjbGFzc05hbWU7IH1cbiAgICBpZiAoc3R5bGUpIHsgZS5zdHlsZS5jc3NUZXh0ID0gc3R5bGU7IH1cbiAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT0gXCJzdHJpbmdcIikgeyBlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNvbnRlbnQpKTsgfVxuICAgIGVsc2UgaWYgKGNvbnRlbnQpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBjb250ZW50Lmxlbmd0aDsgKytpKSB7IGUuYXBwZW5kQ2hpbGQoY29udGVudFtpXSk7IH0gfVxuICAgIHJldHVybiBlXG4gIH1cbiAgLy8gd3JhcHBlciBmb3IgZWx0LCB3aGljaCByZW1vdmVzIHRoZSBlbHQgZnJvbSB0aGUgYWNjZXNzaWJpbGl0eSB0cmVlXG4gIGZ1bmN0aW9uIGVsdFAodGFnLCBjb250ZW50LCBjbGFzc05hbWUsIHN0eWxlKSB7XG4gICAgdmFyIGUgPSBlbHQodGFnLCBjb250ZW50LCBjbGFzc05hbWUsIHN0eWxlKTtcbiAgICBlLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJwcmVzZW50YXRpb25cIik7XG4gICAgcmV0dXJuIGVcbiAgfVxuXG4gIHZhciByYW5nZTtcbiAgaWYgKGRvY3VtZW50LmNyZWF0ZVJhbmdlKSB7IHJhbmdlID0gZnVuY3Rpb24obm9kZSwgc3RhcnQsIGVuZCwgZW5kTm9kZSkge1xuICAgIHZhciByID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICByLnNldEVuZChlbmROb2RlIHx8IG5vZGUsIGVuZCk7XG4gICAgci5zZXRTdGFydChub2RlLCBzdGFydCk7XG4gICAgcmV0dXJuIHJcbiAgfTsgfVxuICBlbHNlIHsgcmFuZ2UgPSBmdW5jdGlvbihub2RlLCBzdGFydCwgZW5kKSB7XG4gICAgdmFyIHIgPSBkb2N1bWVudC5ib2R5LmNyZWF0ZVRleHRSYW5nZSgpO1xuICAgIHRyeSB7IHIubW92ZVRvRWxlbWVudFRleHQobm9kZS5wYXJlbnROb2RlKTsgfVxuICAgIGNhdGNoKGUpIHsgcmV0dXJuIHIgfVxuICAgIHIuY29sbGFwc2UodHJ1ZSk7XG4gICAgci5tb3ZlRW5kKFwiY2hhcmFjdGVyXCIsIGVuZCk7XG4gICAgci5tb3ZlU3RhcnQoXCJjaGFyYWN0ZXJcIiwgc3RhcnQpO1xuICAgIHJldHVybiByXG4gIH07IH1cblxuICBmdW5jdGlvbiBjb250YWlucyhwYXJlbnQsIGNoaWxkKSB7XG4gICAgaWYgKGNoaWxkLm5vZGVUeXBlID09IDMpIC8vIEFuZHJvaWQgYnJvd3NlciBhbHdheXMgcmV0dXJucyBmYWxzZSB3aGVuIGNoaWxkIGlzIGEgdGV4dG5vZGVcbiAgICAgIHsgY2hpbGQgPSBjaGlsZC5wYXJlbnROb2RlOyB9XG4gICAgaWYgKHBhcmVudC5jb250YWlucylcbiAgICAgIHsgcmV0dXJuIHBhcmVudC5jb250YWlucyhjaGlsZCkgfVxuICAgIGRvIHtcbiAgICAgIGlmIChjaGlsZC5ub2RlVHlwZSA9PSAxMSkgeyBjaGlsZCA9IGNoaWxkLmhvc3Q7IH1cbiAgICAgIGlmIChjaGlsZCA9PSBwYXJlbnQpIHsgcmV0dXJuIHRydWUgfVxuICAgIH0gd2hpbGUgKGNoaWxkID0gY2hpbGQucGFyZW50Tm9kZSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGFjdGl2ZUVsdCgpIHtcbiAgICAvLyBJRSBhbmQgRWRnZSBtYXkgdGhyb3cgYW4gXCJVbnNwZWNpZmllZCBFcnJvclwiIHdoZW4gYWNjZXNzaW5nIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuXG4gICAgLy8gSUUgPCAxMCB3aWxsIHRocm93IHdoZW4gYWNjZXNzZWQgd2hpbGUgdGhlIHBhZ2UgaXMgbG9hZGluZyBvciBpbiBhbiBpZnJhbWUuXG4gICAgLy8gSUUgPiA5IGFuZCBFZGdlIHdpbGwgdGhyb3cgd2hlbiBhY2Nlc3NlZCBpbiBhbiBpZnJhbWUgaWYgZG9jdW1lbnQuYm9keSBpcyB1bmF2YWlsYWJsZS5cbiAgICB2YXIgYWN0aXZlRWxlbWVudDtcbiAgICB0cnkge1xuICAgICAgYWN0aXZlRWxlbWVudCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgfSBjYXRjaChlKSB7XG4gICAgICBhY3RpdmVFbGVtZW50ID0gZG9jdW1lbnQuYm9keSB8fCBudWxsO1xuICAgIH1cbiAgICB3aGlsZSAoYWN0aXZlRWxlbWVudCAmJiBhY3RpdmVFbGVtZW50LnNoYWRvd1Jvb3QgJiYgYWN0aXZlRWxlbWVudC5zaGFkb3dSb290LmFjdGl2ZUVsZW1lbnQpXG4gICAgICB7IGFjdGl2ZUVsZW1lbnQgPSBhY3RpdmVFbGVtZW50LnNoYWRvd1Jvb3QuYWN0aXZlRWxlbWVudDsgfVxuICAgIHJldHVybiBhY3RpdmVFbGVtZW50XG4gIH1cblxuICBmdW5jdGlvbiBhZGRDbGFzcyhub2RlLCBjbHMpIHtcbiAgICB2YXIgY3VycmVudCA9IG5vZGUuY2xhc3NOYW1lO1xuICAgIGlmICghY2xhc3NUZXN0KGNscykudGVzdChjdXJyZW50KSkgeyBub2RlLmNsYXNzTmFtZSArPSAoY3VycmVudCA/IFwiIFwiIDogXCJcIikgKyBjbHM7IH1cbiAgfVxuICBmdW5jdGlvbiBqb2luQ2xhc3NlcyhhLCBiKSB7XG4gICAgdmFyIGFzID0gYS5zcGxpdChcIiBcIik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcy5sZW5ndGg7IGkrKylcbiAgICAgIHsgaWYgKGFzW2ldICYmICFjbGFzc1Rlc3QoYXNbaV0pLnRlc3QoYikpIHsgYiArPSBcIiBcIiArIGFzW2ldOyB9IH1cbiAgICByZXR1cm4gYlxuICB9XG5cbiAgdmFyIHNlbGVjdElucHV0ID0gZnVuY3Rpb24obm9kZSkgeyBub2RlLnNlbGVjdCgpOyB9O1xuICBpZiAoaW9zKSAvLyBNb2JpbGUgU2FmYXJpIGFwcGFyZW50bHkgaGFzIGEgYnVnIHdoZXJlIHNlbGVjdCgpIGlzIGJyb2tlbi5cbiAgICB7IHNlbGVjdElucHV0ID0gZnVuY3Rpb24obm9kZSkgeyBub2RlLnNlbGVjdGlvblN0YXJ0ID0gMDsgbm9kZS5zZWxlY3Rpb25FbmQgPSBub2RlLnZhbHVlLmxlbmd0aDsgfTsgfVxuICBlbHNlIGlmIChpZSkgLy8gU3VwcHJlc3MgbXlzdGVyaW91cyBJRTEwIGVycm9yc1xuICAgIHsgc2VsZWN0SW5wdXQgPSBmdW5jdGlvbihub2RlKSB7IHRyeSB7IG5vZGUuc2VsZWN0KCk7IH0gY2F0Y2goX2UpIHt9IH07IH1cblxuICBmdW5jdGlvbiBiaW5kKGYpIHtcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIGYuYXBwbHkobnVsbCwgYXJncyl9XG4gIH1cblxuICBmdW5jdGlvbiBjb3B5T2JqKG9iaiwgdGFyZ2V0LCBvdmVyd3JpdGUpIHtcbiAgICBpZiAoIXRhcmdldCkgeyB0YXJnZXQgPSB7fTsgfVxuICAgIGZvciAodmFyIHByb3AgaW4gb2JqKVxuICAgICAgeyBpZiAob2JqLmhhc093blByb3BlcnR5KHByb3ApICYmIChvdmVyd3JpdGUgIT09IGZhbHNlIHx8ICF0YXJnZXQuaGFzT3duUHJvcGVydHkocHJvcCkpKVxuICAgICAgICB7IHRhcmdldFtwcm9wXSA9IG9ialtwcm9wXTsgfSB9XG4gICAgcmV0dXJuIHRhcmdldFxuICB9XG5cbiAgLy8gQ291bnRzIHRoZSBjb2x1bW4gb2Zmc2V0IGluIGEgc3RyaW5nLCB0YWtpbmcgdGFicyBpbnRvIGFjY291bnQuXG4gIC8vIFVzZWQgbW9zdGx5IHRvIGZpbmQgaW5kZW50YXRpb24uXG4gIGZ1bmN0aW9uIGNvdW50Q29sdW1uKHN0cmluZywgZW5kLCB0YWJTaXplLCBzdGFydEluZGV4LCBzdGFydFZhbHVlKSB7XG4gICAgaWYgKGVuZCA9PSBudWxsKSB7XG4gICAgICBlbmQgPSBzdHJpbmcuc2VhcmNoKC9bXlxcc1xcdTAwYTBdLyk7XG4gICAgICBpZiAoZW5kID09IC0xKSB7IGVuZCA9IHN0cmluZy5sZW5ndGg7IH1cbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXggfHwgMCwgbiA9IHN0YXJ0VmFsdWUgfHwgMDs7KSB7XG4gICAgICB2YXIgbmV4dFRhYiA9IHN0cmluZy5pbmRleE9mKFwiXFx0XCIsIGkpO1xuICAgICAgaWYgKG5leHRUYWIgPCAwIHx8IG5leHRUYWIgPj0gZW5kKVxuICAgICAgICB7IHJldHVybiBuICsgKGVuZCAtIGkpIH1cbiAgICAgIG4gKz0gbmV4dFRhYiAtIGk7XG4gICAgICBuICs9IHRhYlNpemUgLSAobiAlIHRhYlNpemUpO1xuICAgICAgaSA9IG5leHRUYWIgKyAxO1xuICAgIH1cbiAgfVxuXG4gIHZhciBEZWxheWVkID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5pZCA9IG51bGw7XG4gICAgdGhpcy5mID0gbnVsbDtcbiAgICB0aGlzLnRpbWUgPSAwO1xuICAgIHRoaXMuaGFuZGxlciA9IGJpbmQodGhpcy5vblRpbWVvdXQsIHRoaXMpO1xuICB9O1xuICBEZWxheWVkLnByb3RvdHlwZS5vblRpbWVvdXQgPSBmdW5jdGlvbiAoc2VsZikge1xuICAgIHNlbGYuaWQgPSAwO1xuICAgIGlmIChzZWxmLnRpbWUgPD0gK25ldyBEYXRlKSB7XG4gICAgICBzZWxmLmYoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0VGltZW91dChzZWxmLmhhbmRsZXIsIHNlbGYudGltZSAtICtuZXcgRGF0ZSk7XG4gICAgfVxuICB9O1xuICBEZWxheWVkLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAobXMsIGYpIHtcbiAgICB0aGlzLmYgPSBmO1xuICAgIHZhciB0aW1lID0gK25ldyBEYXRlICsgbXM7XG4gICAgaWYgKCF0aGlzLmlkIHx8IHRpbWUgPCB0aGlzLnRpbWUpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLmlkKTtcbiAgICAgIHRoaXMuaWQgPSBzZXRUaW1lb3V0KHRoaXMuaGFuZGxlciwgbXMpO1xuICAgICAgdGhpcy50aW1lID0gdGltZTtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gaW5kZXhPZihhcnJheSwgZWx0KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7ICsraSlcbiAgICAgIHsgaWYgKGFycmF5W2ldID09IGVsdCkgeyByZXR1cm4gaSB9IH1cbiAgICByZXR1cm4gLTFcbiAgfVxuXG4gIC8vIE51bWJlciBvZiBwaXhlbHMgYWRkZWQgdG8gc2Nyb2xsZXIgYW5kIHNpemVyIHRvIGhpZGUgc2Nyb2xsYmFyXG4gIHZhciBzY3JvbGxlckdhcCA9IDUwO1xuXG4gIC8vIFJldHVybmVkIG9yIHRocm93biBieSB2YXJpb3VzIHByb3RvY29scyB0byBzaWduYWwgJ0knbSBub3RcbiAgLy8gaGFuZGxpbmcgdGhpcycuXG4gIHZhciBQYXNzID0ge3RvU3RyaW5nOiBmdW5jdGlvbigpe3JldHVybiBcIkNvZGVNaXJyb3IuUGFzc1wifX07XG5cbiAgLy8gUmV1c2VkIG9wdGlvbiBvYmplY3RzIGZvciBzZXRTZWxlY3Rpb24gJiBmcmllbmRzXG4gIHZhciBzZWxfZG9udFNjcm9sbCA9IHtzY3JvbGw6IGZhbHNlfSwgc2VsX21vdXNlID0ge29yaWdpbjogXCIqbW91c2VcIn0sIHNlbF9tb3ZlID0ge29yaWdpbjogXCIrbW92ZVwifTtcblxuICAvLyBUaGUgaW52ZXJzZSBvZiBjb3VudENvbHVtbiAtLSBmaW5kIHRoZSBvZmZzZXQgdGhhdCBjb3JyZXNwb25kcyB0b1xuICAvLyBhIHBhcnRpY3VsYXIgY29sdW1uLlxuICBmdW5jdGlvbiBmaW5kQ29sdW1uKHN0cmluZywgZ29hbCwgdGFiU2l6ZSkge1xuICAgIGZvciAodmFyIHBvcyA9IDAsIGNvbCA9IDA7Oykge1xuICAgICAgdmFyIG5leHRUYWIgPSBzdHJpbmcuaW5kZXhPZihcIlxcdFwiLCBwb3MpO1xuICAgICAgaWYgKG5leHRUYWIgPT0gLTEpIHsgbmV4dFRhYiA9IHN0cmluZy5sZW5ndGg7IH1cbiAgICAgIHZhciBza2lwcGVkID0gbmV4dFRhYiAtIHBvcztcbiAgICAgIGlmIChuZXh0VGFiID09IHN0cmluZy5sZW5ndGggfHwgY29sICsgc2tpcHBlZCA+PSBnb2FsKVxuICAgICAgICB7IHJldHVybiBwb3MgKyBNYXRoLm1pbihza2lwcGVkLCBnb2FsIC0gY29sKSB9XG4gICAgICBjb2wgKz0gbmV4dFRhYiAtIHBvcztcbiAgICAgIGNvbCArPSB0YWJTaXplIC0gKGNvbCAlIHRhYlNpemUpO1xuICAgICAgcG9zID0gbmV4dFRhYiArIDE7XG4gICAgICBpZiAoY29sID49IGdvYWwpIHsgcmV0dXJuIHBvcyB9XG4gICAgfVxuICB9XG5cbiAgdmFyIHNwYWNlU3RycyA9IFtcIlwiXTtcbiAgZnVuY3Rpb24gc3BhY2VTdHIobikge1xuICAgIHdoaWxlIChzcGFjZVN0cnMubGVuZ3RoIDw9IG4pXG4gICAgICB7IHNwYWNlU3Rycy5wdXNoKGxzdChzcGFjZVN0cnMpICsgXCIgXCIpOyB9XG4gICAgcmV0dXJuIHNwYWNlU3Ryc1tuXVxuICB9XG5cbiAgZnVuY3Rpb24gbHN0KGFycikgeyByZXR1cm4gYXJyW2Fyci5sZW5ndGgtMV0gfVxuXG4gIGZ1bmN0aW9uIG1hcChhcnJheSwgZikge1xuICAgIHZhciBvdXQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7IG91dFtpXSA9IGYoYXJyYXlbaV0sIGkpOyB9XG4gICAgcmV0dXJuIG91dFxuICB9XG5cbiAgZnVuY3Rpb24gaW5zZXJ0U29ydGVkKGFycmF5LCB2YWx1ZSwgc2NvcmUpIHtcbiAgICB2YXIgcG9zID0gMCwgcHJpb3JpdHkgPSBzY29yZSh2YWx1ZSk7XG4gICAgd2hpbGUgKHBvcyA8IGFycmF5Lmxlbmd0aCAmJiBzY29yZShhcnJheVtwb3NdKSA8PSBwcmlvcml0eSkgeyBwb3MrKzsgfVxuICAgIGFycmF5LnNwbGljZShwb3MsIDAsIHZhbHVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vdGhpbmcoKSB7fVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU9iaihiYXNlLCBwcm9wcykge1xuICAgIHZhciBpbnN0O1xuICAgIGlmIChPYmplY3QuY3JlYXRlKSB7XG4gICAgICBpbnN0ID0gT2JqZWN0LmNyZWF0ZShiYXNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm90aGluZy5wcm90b3R5cGUgPSBiYXNlO1xuICAgICAgaW5zdCA9IG5ldyBub3RoaW5nKCk7XG4gICAgfVxuICAgIGlmIChwcm9wcykgeyBjb3B5T2JqKHByb3BzLCBpbnN0KTsgfVxuICAgIHJldHVybiBpbnN0XG4gIH1cblxuICB2YXIgbm9uQVNDSUlTaW5nbGVDYXNlV29yZENoYXIgPSAvW1xcdTAwZGZcXHUwNTg3XFx1MDU5MC1cXHUwNWY0XFx1MDYwMC1cXHUwNmZmXFx1MzA0MC1cXHUzMDlmXFx1MzBhMC1cXHUzMGZmXFx1MzQwMC1cXHU0ZGI1XFx1NGUwMC1cXHU5ZmNjXFx1YWMwMC1cXHVkN2FmXS87XG4gIGZ1bmN0aW9uIGlzV29yZENoYXJCYXNpYyhjaCkge1xuICAgIHJldHVybiAvXFx3Ly50ZXN0KGNoKSB8fCBjaCA+IFwiXFx4ODBcIiAmJlxuICAgICAgKGNoLnRvVXBwZXJDYXNlKCkgIT0gY2gudG9Mb3dlckNhc2UoKSB8fCBub25BU0NJSVNpbmdsZUNhc2VXb3JkQ2hhci50ZXN0KGNoKSlcbiAgfVxuICBmdW5jdGlvbiBpc1dvcmRDaGFyKGNoLCBoZWxwZXIpIHtcbiAgICBpZiAoIWhlbHBlcikgeyByZXR1cm4gaXNXb3JkQ2hhckJhc2ljKGNoKSB9XG4gICAgaWYgKGhlbHBlci5zb3VyY2UuaW5kZXhPZihcIlxcXFx3XCIpID4gLTEgJiYgaXNXb3JkQ2hhckJhc2ljKGNoKSkgeyByZXR1cm4gdHJ1ZSB9XG4gICAgcmV0dXJuIGhlbHBlci50ZXN0KGNoKVxuICB9XG5cbiAgZnVuY3Rpb24gaXNFbXB0eShvYmopIHtcbiAgICBmb3IgKHZhciBuIGluIG9iaikgeyBpZiAob2JqLmhhc093blByb3BlcnR5KG4pICYmIG9ialtuXSkgeyByZXR1cm4gZmFsc2UgfSB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8vIEV4dGVuZGluZyB1bmljb2RlIGNoYXJhY3RlcnMuIEEgc2VyaWVzIG9mIGEgbm9uLWV4dGVuZGluZyBjaGFyICtcbiAgLy8gYW55IG51bWJlciBvZiBleHRlbmRpbmcgY2hhcnMgaXMgdHJlYXRlZCBhcyBhIHNpbmdsZSB1bml0IGFzIGZhclxuICAvLyBhcyBlZGl0aW5nIGFuZCBtZWFzdXJpbmcgaXMgY29uY2VybmVkLiBUaGlzIGlzIG5vdCBmdWxseSBjb3JyZWN0LFxuICAvLyBzaW5jZSBzb21lIHNjcmlwdHMvZm9udHMvYnJvd3NlcnMgYWxzbyB0cmVhdCBvdGhlciBjb25maWd1cmF0aW9uc1xuICAvLyBvZiBjb2RlIHBvaW50cyBhcyBhIGdyb3VwLlxuICB2YXIgZXh0ZW5kaW5nQ2hhcnMgPSAvW1xcdTAzMDAtXFx1MDM2ZlxcdTA0ODMtXFx1MDQ4OVxcdTA1OTEtXFx1MDViZFxcdTA1YmZcXHUwNWMxXFx1MDVjMlxcdTA1YzRcXHUwNWM1XFx1MDVjN1xcdTA2MTAtXFx1MDYxYVxcdTA2NGItXFx1MDY1ZVxcdTA2NzBcXHUwNmQ2LVxcdTA2ZGNcXHUwNmRlLVxcdTA2ZTRcXHUwNmU3XFx1MDZlOFxcdTA2ZWEtXFx1MDZlZFxcdTA3MTFcXHUwNzMwLVxcdTA3NGFcXHUwN2E2LVxcdTA3YjBcXHUwN2ViLVxcdTA3ZjNcXHUwODE2LVxcdTA4MTlcXHUwODFiLVxcdTA4MjNcXHUwODI1LVxcdTA4MjdcXHUwODI5LVxcdTA4MmRcXHUwOTAwLVxcdTA5MDJcXHUwOTNjXFx1MDk0MS1cXHUwOTQ4XFx1MDk0ZFxcdTA5NTEtXFx1MDk1NVxcdTA5NjJcXHUwOTYzXFx1MDk4MVxcdTA5YmNcXHUwOWJlXFx1MDljMS1cXHUwOWM0XFx1MDljZFxcdTA5ZDdcXHUwOWUyXFx1MDllM1xcdTBhMDFcXHUwYTAyXFx1MGEzY1xcdTBhNDFcXHUwYTQyXFx1MGE0N1xcdTBhNDhcXHUwYTRiLVxcdTBhNGRcXHUwYTUxXFx1MGE3MFxcdTBhNzFcXHUwYTc1XFx1MGE4MVxcdTBhODJcXHUwYWJjXFx1MGFjMS1cXHUwYWM1XFx1MGFjN1xcdTBhYzhcXHUwYWNkXFx1MGFlMlxcdTBhZTNcXHUwYjAxXFx1MGIzY1xcdTBiM2VcXHUwYjNmXFx1MGI0MS1cXHUwYjQ0XFx1MGI0ZFxcdTBiNTZcXHUwYjU3XFx1MGI2MlxcdTBiNjNcXHUwYjgyXFx1MGJiZVxcdTBiYzBcXHUwYmNkXFx1MGJkN1xcdTBjM2UtXFx1MGM0MFxcdTBjNDYtXFx1MGM0OFxcdTBjNGEtXFx1MGM0ZFxcdTBjNTVcXHUwYzU2XFx1MGM2MlxcdTBjNjNcXHUwY2JjXFx1MGNiZlxcdTBjYzJcXHUwY2M2XFx1MGNjY1xcdTBjY2RcXHUwY2Q1XFx1MGNkNlxcdTBjZTJcXHUwY2UzXFx1MGQzZVxcdTBkNDEtXFx1MGQ0NFxcdTBkNGRcXHUwZDU3XFx1MGQ2MlxcdTBkNjNcXHUwZGNhXFx1MGRjZlxcdTBkZDItXFx1MGRkNFxcdTBkZDZcXHUwZGRmXFx1MGUzMVxcdTBlMzQtXFx1MGUzYVxcdTBlNDctXFx1MGU0ZVxcdTBlYjFcXHUwZWI0LVxcdTBlYjlcXHUwZWJiXFx1MGViY1xcdTBlYzgtXFx1MGVjZFxcdTBmMThcXHUwZjE5XFx1MGYzNVxcdTBmMzdcXHUwZjM5XFx1MGY3MS1cXHUwZjdlXFx1MGY4MC1cXHUwZjg0XFx1MGY4NlxcdTBmODdcXHUwZjkwLVxcdTBmOTdcXHUwZjk5LVxcdTBmYmNcXHUwZmM2XFx1MTAyZC1cXHUxMDMwXFx1MTAzMi1cXHUxMDM3XFx1MTAzOVxcdTEwM2FcXHUxMDNkXFx1MTAzZVxcdTEwNThcXHUxMDU5XFx1MTA1ZS1cXHUxMDYwXFx1MTA3MS1cXHUxMDc0XFx1MTA4MlxcdTEwODVcXHUxMDg2XFx1MTA4ZFxcdTEwOWRcXHUxMzVmXFx1MTcxMi1cXHUxNzE0XFx1MTczMi1cXHUxNzM0XFx1MTc1MlxcdTE3NTNcXHUxNzcyXFx1MTc3M1xcdTE3YjctXFx1MTdiZFxcdTE3YzZcXHUxN2M5LVxcdTE3ZDNcXHUxN2RkXFx1MTgwYi1cXHUxODBkXFx1MThhOVxcdTE5MjAtXFx1MTkyMlxcdTE5MjdcXHUxOTI4XFx1MTkzMlxcdTE5MzktXFx1MTkzYlxcdTFhMTdcXHUxYTE4XFx1MWE1NlxcdTFhNTgtXFx1MWE1ZVxcdTFhNjBcXHUxYTYyXFx1MWE2NS1cXHUxYTZjXFx1MWE3My1cXHUxYTdjXFx1MWE3ZlxcdTFiMDAtXFx1MWIwM1xcdTFiMzRcXHUxYjM2LVxcdTFiM2FcXHUxYjNjXFx1MWI0MlxcdTFiNmItXFx1MWI3M1xcdTFiODBcXHUxYjgxXFx1MWJhMi1cXHUxYmE1XFx1MWJhOFxcdTFiYTlcXHUxYzJjLVxcdTFjMzNcXHUxYzM2XFx1MWMzN1xcdTFjZDAtXFx1MWNkMlxcdTFjZDQtXFx1MWNlMFxcdTFjZTItXFx1MWNlOFxcdTFjZWRcXHUxZGMwLVxcdTFkZTZcXHUxZGZkLVxcdTFkZmZcXHUyMDBjXFx1MjAwZFxcdTIwZDAtXFx1MjBmMFxcdTJjZWYtXFx1MmNmMVxcdTJkZTAtXFx1MmRmZlxcdTMwMmEtXFx1MzAyZlxcdTMwOTlcXHUzMDlhXFx1YTY2Zi1cXHVhNjcyXFx1YTY3Y1xcdWE2N2RcXHVhNmYwXFx1YTZmMVxcdWE4MDJcXHVhODA2XFx1YTgwYlxcdWE4MjVcXHVhODI2XFx1YThjNFxcdWE4ZTAtXFx1YThmMVxcdWE5MjYtXFx1YTkyZFxcdWE5NDctXFx1YTk1MVxcdWE5ODAtXFx1YTk4MlxcdWE5YjNcXHVhOWI2LVxcdWE5YjlcXHVhOWJjXFx1YWEyOS1cXHVhYTJlXFx1YWEzMVxcdWFhMzJcXHVhYTM1XFx1YWEzNlxcdWFhNDNcXHVhYTRjXFx1YWFiMFxcdWFhYjItXFx1YWFiNFxcdWFhYjdcXHVhYWI4XFx1YWFiZVxcdWFhYmZcXHVhYWMxXFx1YWJlNVxcdWFiZThcXHVhYmVkXFx1ZGMwMC1cXHVkZmZmXFx1ZmIxZVxcdWZlMDAtXFx1ZmUwZlxcdWZlMjAtXFx1ZmUyNlxcdWZmOWVcXHVmZjlmXS87XG4gIGZ1bmN0aW9uIGlzRXh0ZW5kaW5nQ2hhcihjaCkgeyByZXR1cm4gY2guY2hhckNvZGVBdCgwKSA+PSA3NjggJiYgZXh0ZW5kaW5nQ2hhcnMudGVzdChjaCkgfVxuXG4gIC8vIFJldHVybnMgYSBudW1iZXIgZnJvbSB0aGUgcmFuZ2UgW2AwYDsgYHN0ci5sZW5ndGhgXSB1bmxlc3MgYHBvc2AgaXMgb3V0c2lkZSB0aGF0IHJhbmdlLlxuICBmdW5jdGlvbiBza2lwRXh0ZW5kaW5nQ2hhcnMoc3RyLCBwb3MsIGRpcikge1xuICAgIHdoaWxlICgoZGlyIDwgMCA/IHBvcyA+IDAgOiBwb3MgPCBzdHIubGVuZ3RoKSAmJiBpc0V4dGVuZGluZ0NoYXIoc3RyLmNoYXJBdChwb3MpKSkgeyBwb3MgKz0gZGlyOyB9XG4gICAgcmV0dXJuIHBvc1xuICB9XG5cbiAgLy8gUmV0dXJucyB0aGUgdmFsdWUgZnJvbSB0aGUgcmFuZ2UgW2Bmcm9tYDsgYHRvYF0gdGhhdCBzYXRpc2ZpZXNcbiAgLy8gYHByZWRgIGFuZCBpcyBjbG9zZXN0IHRvIGBmcm9tYC4gQXNzdW1lcyB0aGF0IGF0IGxlYXN0IGB0b2BcbiAgLy8gc2F0aXNmaWVzIGBwcmVkYC4gU3VwcG9ydHMgYGZyb21gIGJlaW5nIGdyZWF0ZXIgdGhhbiBgdG9gLlxuICBmdW5jdGlvbiBmaW5kRmlyc3QocHJlZCwgZnJvbSwgdG8pIHtcbiAgICAvLyBBdCBhbnkgcG9pbnQgd2UgYXJlIGNlcnRhaW4gYHRvYCBzYXRpc2ZpZXMgYHByZWRgLCBkb24ndCBrbm93XG4gICAgLy8gd2hldGhlciBgZnJvbWAgZG9lcy5cbiAgICB2YXIgZGlyID0gZnJvbSA+IHRvID8gLTEgOiAxO1xuICAgIGZvciAoOzspIHtcbiAgICAgIGlmIChmcm9tID09IHRvKSB7IHJldHVybiBmcm9tIH1cbiAgICAgIHZhciBtaWRGID0gKGZyb20gKyB0bykgLyAyLCBtaWQgPSBkaXIgPCAwID8gTWF0aC5jZWlsKG1pZEYpIDogTWF0aC5mbG9vcihtaWRGKTtcbiAgICAgIGlmIChtaWQgPT0gZnJvbSkgeyByZXR1cm4gcHJlZChtaWQpID8gZnJvbSA6IHRvIH1cbiAgICAgIGlmIChwcmVkKG1pZCkpIHsgdG8gPSBtaWQ7IH1cbiAgICAgIGVsc2UgeyBmcm9tID0gbWlkICsgZGlyOyB9XG4gICAgfVxuICB9XG5cbiAgLy8gQklESSBIRUxQRVJTXG5cbiAgZnVuY3Rpb24gaXRlcmF0ZUJpZGlTZWN0aW9ucyhvcmRlciwgZnJvbSwgdG8sIGYpIHtcbiAgICBpZiAoIW9yZGVyKSB7IHJldHVybiBmKGZyb20sIHRvLCBcImx0clwiLCAwKSB9XG4gICAgdmFyIGZvdW5kID0gZmFsc2U7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcmRlci5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIHBhcnQgPSBvcmRlcltpXTtcbiAgICAgIGlmIChwYXJ0LmZyb20gPCB0byAmJiBwYXJ0LnRvID4gZnJvbSB8fCBmcm9tID09IHRvICYmIHBhcnQudG8gPT0gZnJvbSkge1xuICAgICAgICBmKE1hdGgubWF4KHBhcnQuZnJvbSwgZnJvbSksIE1hdGgubWluKHBhcnQudG8sIHRvKSwgcGFydC5sZXZlbCA9PSAxID8gXCJydGxcIiA6IFwibHRyXCIsIGkpO1xuICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghZm91bmQpIHsgZihmcm9tLCB0bywgXCJsdHJcIik7IH1cbiAgfVxuXG4gIHZhciBiaWRpT3RoZXIgPSBudWxsO1xuICBmdW5jdGlvbiBnZXRCaWRpUGFydEF0KG9yZGVyLCBjaCwgc3RpY2t5KSB7XG4gICAgdmFyIGZvdW5kO1xuICAgIGJpZGlPdGhlciA9IG51bGw7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcmRlci5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGN1ciA9IG9yZGVyW2ldO1xuICAgICAgaWYgKGN1ci5mcm9tIDwgY2ggJiYgY3VyLnRvID4gY2gpIHsgcmV0dXJuIGkgfVxuICAgICAgaWYgKGN1ci50byA9PSBjaCkge1xuICAgICAgICBpZiAoY3VyLmZyb20gIT0gY3VyLnRvICYmIHN0aWNreSA9PSBcImJlZm9yZVwiKSB7IGZvdW5kID0gaTsgfVxuICAgICAgICBlbHNlIHsgYmlkaU90aGVyID0gaTsgfVxuICAgICAgfVxuICAgICAgaWYgKGN1ci5mcm9tID09IGNoKSB7XG4gICAgICAgIGlmIChjdXIuZnJvbSAhPSBjdXIudG8gJiYgc3RpY2t5ICE9IFwiYmVmb3JlXCIpIHsgZm91bmQgPSBpOyB9XG4gICAgICAgIGVsc2UgeyBiaWRpT3RoZXIgPSBpOyB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmb3VuZCAhPSBudWxsID8gZm91bmQgOiBiaWRpT3RoZXJcbiAgfVxuXG4gIC8vIEJpZGlyZWN0aW9uYWwgb3JkZXJpbmcgYWxnb3JpdGhtXG4gIC8vIFNlZSBodHRwOi8vdW5pY29kZS5vcmcvcmVwb3J0cy90cjkvdHI5LTEzLmh0bWwgZm9yIHRoZSBhbGdvcml0aG1cbiAgLy8gdGhhdCB0aGlzIChwYXJ0aWFsbHkpIGltcGxlbWVudHMuXG5cbiAgLy8gT25lLWNoYXIgY29kZXMgdXNlZCBmb3IgY2hhcmFjdGVyIHR5cGVzOlxuICAvLyBMIChMKTogICBMZWZ0LXRvLVJpZ2h0XG4gIC8vIFIgKFIpOiAgIFJpZ2h0LXRvLUxlZnRcbiAgLy8gciAoQUwpOiAgUmlnaHQtdG8tTGVmdCBBcmFiaWNcbiAgLy8gMSAoRU4pOiAgRXVyb3BlYW4gTnVtYmVyXG4gIC8vICsgKEVTKTogIEV1cm9wZWFuIE51bWJlciBTZXBhcmF0b3JcbiAgLy8gJSAoRVQpOiAgRXVyb3BlYW4gTnVtYmVyIFRlcm1pbmF0b3JcbiAgLy8gbiAoQU4pOiAgQXJhYmljIE51bWJlclxuICAvLyAsIChDUyk6ICBDb21tb24gTnVtYmVyIFNlcGFyYXRvclxuICAvLyBtIChOU00pOiBOb24tU3BhY2luZyBNYXJrXG4gIC8vIGIgKEJOKTogIEJvdW5kYXJ5IE5ldXRyYWxcbiAgLy8gcyAoQik6ICAgUGFyYWdyYXBoIFNlcGFyYXRvclxuICAvLyB0IChTKTogICBTZWdtZW50IFNlcGFyYXRvclxuICAvLyB3IChXUyk6ICBXaGl0ZXNwYWNlXG4gIC8vIE4gKE9OKTogIE90aGVyIE5ldXRyYWxzXG5cbiAgLy8gUmV0dXJucyBudWxsIGlmIGNoYXJhY3RlcnMgYXJlIG9yZGVyZWQgYXMgdGhleSBhcHBlYXJcbiAgLy8gKGxlZnQtdG8tcmlnaHQpLCBvciBhbiBhcnJheSBvZiBzZWN0aW9ucyAoe2Zyb20sIHRvLCBsZXZlbH1cbiAgLy8gb2JqZWN0cykgaW4gdGhlIG9yZGVyIGluIHdoaWNoIHRoZXkgb2NjdXIgdmlzdWFsbHkuXG4gIHZhciBiaWRpT3JkZXJpbmcgPSAoZnVuY3Rpb24oKSB7XG4gICAgLy8gQ2hhcmFjdGVyIHR5cGVzIGZvciBjb2RlcG9pbnRzIDAgdG8gMHhmZlxuICAgIHZhciBsb3dUeXBlcyA9IFwiYmJiYmJiYmJidHN0d3NiYmJiYmJiYmJiYmJiYnNzc3R3Tk4lJSVOTk5OTk4sTixOMTExMTExMTExMU5OTk5OTk5MTExMTExMTExMTExMTExMTExMTExMTExMTE5OTk5OTkxMTExMTExMTExMTExMTExMTExMTExMTExMTk5OTmJiYmJiYnNiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYixOJSUlJU5OTk5MTk5OTk4lJTExTkxOTk4xTE5OTk5OTExMTExMTExMTExMTExMTExMTExMTExOTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTE5cIjtcbiAgICAvLyBDaGFyYWN0ZXIgdHlwZXMgZm9yIGNvZGVwb2ludHMgMHg2MDAgdG8gMHg2ZjlcbiAgICB2YXIgYXJhYmljVHlwZXMgPSBcIm5ubm5ubk5OciUlcixyTk5tbW1tbW1tbW1tbXJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycm1tbW1tbW1tbW1tbW1tbW1tbW1tbW5ubm5ubm5ubm4lbm5ycnJtcnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJtbW1tbW1tbk5tbW1tbW1ycm1tTm1tbW1ycjExMTExMTExMTFcIjtcbiAgICBmdW5jdGlvbiBjaGFyVHlwZShjb2RlKSB7XG4gICAgICBpZiAoY29kZSA8PSAweGY3KSB7IHJldHVybiBsb3dUeXBlcy5jaGFyQXQoY29kZSkgfVxuICAgICAgZWxzZSBpZiAoMHg1OTAgPD0gY29kZSAmJiBjb2RlIDw9IDB4NWY0KSB7IHJldHVybiBcIlJcIiB9XG4gICAgICBlbHNlIGlmICgweDYwMCA8PSBjb2RlICYmIGNvZGUgPD0gMHg2ZjkpIHsgcmV0dXJuIGFyYWJpY1R5cGVzLmNoYXJBdChjb2RlIC0gMHg2MDApIH1cbiAgICAgIGVsc2UgaWYgKDB4NmVlIDw9IGNvZGUgJiYgY29kZSA8PSAweDhhYykgeyByZXR1cm4gXCJyXCIgfVxuICAgICAgZWxzZSBpZiAoMHgyMDAwIDw9IGNvZGUgJiYgY29kZSA8PSAweDIwMGIpIHsgcmV0dXJuIFwid1wiIH1cbiAgICAgIGVsc2UgaWYgKGNvZGUgPT0gMHgyMDBjKSB7IHJldHVybiBcImJcIiB9XG4gICAgICBlbHNlIHsgcmV0dXJuIFwiTFwiIH1cbiAgICB9XG5cbiAgICB2YXIgYmlkaVJFID0gL1tcXHUwNTkwLVxcdTA1ZjRcXHUwNjAwLVxcdTA2ZmZcXHUwNzAwLVxcdTA4YWNdLztcbiAgICB2YXIgaXNOZXV0cmFsID0gL1tzdHdOXS8sIGlzU3Ryb25nID0gL1tMUnJdLywgY291bnRzQXNMZWZ0ID0gL1tMYjFuXS8sIGNvdW50c0FzTnVtID0gL1sxbl0vO1xuXG4gICAgZnVuY3Rpb24gQmlkaVNwYW4obGV2ZWwsIGZyb20sIHRvKSB7XG4gICAgICB0aGlzLmxldmVsID0gbGV2ZWw7XG4gICAgICB0aGlzLmZyb20gPSBmcm9tOyB0aGlzLnRvID0gdG87XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKHN0ciwgZGlyZWN0aW9uKSB7XG4gICAgICB2YXIgb3V0ZXJUeXBlID0gZGlyZWN0aW9uID09IFwibHRyXCIgPyBcIkxcIiA6IFwiUlwiO1xuXG4gICAgICBpZiAoc3RyLmxlbmd0aCA9PSAwIHx8IGRpcmVjdGlvbiA9PSBcImx0clwiICYmICFiaWRpUkUudGVzdChzdHIpKSB7IHJldHVybiBmYWxzZSB9XG4gICAgICB2YXIgbGVuID0gc3RyLmxlbmd0aCwgdHlwZXMgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICAgIHsgdHlwZXMucHVzaChjaGFyVHlwZShzdHIuY2hhckNvZGVBdChpKSkpOyB9XG5cbiAgICAgIC8vIFcxLiBFeGFtaW5lIGVhY2ggbm9uLXNwYWNpbmcgbWFyayAoTlNNKSBpbiB0aGUgbGV2ZWwgcnVuLCBhbmRcbiAgICAgIC8vIGNoYW5nZSB0aGUgdHlwZSBvZiB0aGUgTlNNIHRvIHRoZSB0eXBlIG9mIHRoZSBwcmV2aW91c1xuICAgICAgLy8gY2hhcmFjdGVyLiBJZiB0aGUgTlNNIGlzIGF0IHRoZSBzdGFydCBvZiB0aGUgbGV2ZWwgcnVuLCBpdCB3aWxsXG4gICAgICAvLyBnZXQgdGhlIHR5cGUgb2Ygc29yLlxuICAgICAgZm9yICh2YXIgaSQxID0gMCwgcHJldiA9IG91dGVyVHlwZTsgaSQxIDwgbGVuOyArK2kkMSkge1xuICAgICAgICB2YXIgdHlwZSA9IHR5cGVzW2kkMV07XG4gICAgICAgIGlmICh0eXBlID09IFwibVwiKSB7IHR5cGVzW2kkMV0gPSBwcmV2OyB9XG4gICAgICAgIGVsc2UgeyBwcmV2ID0gdHlwZTsgfVxuICAgICAgfVxuXG4gICAgICAvLyBXMi4gU2VhcmNoIGJhY2t3YXJkcyBmcm9tIGVhY2ggaW5zdGFuY2Ugb2YgYSBFdXJvcGVhbiBudW1iZXJcbiAgICAgIC8vIHVudGlsIHRoZSBmaXJzdCBzdHJvbmcgdHlwZSAoUiwgTCwgQUwsIG9yIHNvcikgaXMgZm91bmQuIElmIGFuXG4gICAgICAvLyBBTCBpcyBmb3VuZCwgY2hhbmdlIHRoZSB0eXBlIG9mIHRoZSBFdXJvcGVhbiBudW1iZXIgdG8gQXJhYmljXG4gICAgICAvLyBudW1iZXIuXG4gICAgICAvLyBXMy4gQ2hhbmdlIGFsbCBBTHMgdG8gUi5cbiAgICAgIGZvciAodmFyIGkkMiA9IDAsIGN1ciA9IG91dGVyVHlwZTsgaSQyIDwgbGVuOyArK2kkMikge1xuICAgICAgICB2YXIgdHlwZSQxID0gdHlwZXNbaSQyXTtcbiAgICAgICAgaWYgKHR5cGUkMSA9PSBcIjFcIiAmJiBjdXIgPT0gXCJyXCIpIHsgdHlwZXNbaSQyXSA9IFwiblwiOyB9XG4gICAgICAgIGVsc2UgaWYgKGlzU3Ryb25nLnRlc3QodHlwZSQxKSkgeyBjdXIgPSB0eXBlJDE7IGlmICh0eXBlJDEgPT0gXCJyXCIpIHsgdHlwZXNbaSQyXSA9IFwiUlwiOyB9IH1cbiAgICAgIH1cblxuICAgICAgLy8gVzQuIEEgc2luZ2xlIEV1cm9wZWFuIHNlcGFyYXRvciBiZXR3ZWVuIHR3byBFdXJvcGVhbiBudW1iZXJzXG4gICAgICAvLyBjaGFuZ2VzIHRvIGEgRXVyb3BlYW4gbnVtYmVyLiBBIHNpbmdsZSBjb21tb24gc2VwYXJhdG9yIGJldHdlZW5cbiAgICAgIC8vIHR3byBudW1iZXJzIG9mIHRoZSBzYW1lIHR5cGUgY2hhbmdlcyB0byB0aGF0IHR5cGUuXG4gICAgICBmb3IgKHZhciBpJDMgPSAxLCBwcmV2JDEgPSB0eXBlc1swXTsgaSQzIDwgbGVuIC0gMTsgKytpJDMpIHtcbiAgICAgICAgdmFyIHR5cGUkMiA9IHR5cGVzW2kkM107XG4gICAgICAgIGlmICh0eXBlJDIgPT0gXCIrXCIgJiYgcHJldiQxID09IFwiMVwiICYmIHR5cGVzW2kkMysxXSA9PSBcIjFcIikgeyB0eXBlc1tpJDNdID0gXCIxXCI7IH1cbiAgICAgICAgZWxzZSBpZiAodHlwZSQyID09IFwiLFwiICYmIHByZXYkMSA9PSB0eXBlc1tpJDMrMV0gJiZcbiAgICAgICAgICAgICAgICAgKHByZXYkMSA9PSBcIjFcIiB8fCBwcmV2JDEgPT0gXCJuXCIpKSB7IHR5cGVzW2kkM10gPSBwcmV2JDE7IH1cbiAgICAgICAgcHJldiQxID0gdHlwZSQyO1xuICAgICAgfVxuXG4gICAgICAvLyBXNS4gQSBzZXF1ZW5jZSBvZiBFdXJvcGVhbiB0ZXJtaW5hdG9ycyBhZGphY2VudCB0byBFdXJvcGVhblxuICAgICAgLy8gbnVtYmVycyBjaGFuZ2VzIHRvIGFsbCBFdXJvcGVhbiBudW1iZXJzLlxuICAgICAgLy8gVzYuIE90aGVyd2lzZSwgc2VwYXJhdG9ycyBhbmQgdGVybWluYXRvcnMgY2hhbmdlIHRvIE90aGVyXG4gICAgICAvLyBOZXV0cmFsLlxuICAgICAgZm9yICh2YXIgaSQ0ID0gMDsgaSQ0IDwgbGVuOyArK2kkNCkge1xuICAgICAgICB2YXIgdHlwZSQzID0gdHlwZXNbaSQ0XTtcbiAgICAgICAgaWYgKHR5cGUkMyA9PSBcIixcIikgeyB0eXBlc1tpJDRdID0gXCJOXCI7IH1cbiAgICAgICAgZWxzZSBpZiAodHlwZSQzID09IFwiJVwiKSB7XG4gICAgICAgICAgdmFyIGVuZCA9ICh2b2lkIDApO1xuICAgICAgICAgIGZvciAoZW5kID0gaSQ0ICsgMTsgZW5kIDwgbGVuICYmIHR5cGVzW2VuZF0gPT0gXCIlXCI7ICsrZW5kKSB7fVxuICAgICAgICAgIHZhciByZXBsYWNlID0gKGkkNCAmJiB0eXBlc1tpJDQtMV0gPT0gXCIhXCIpIHx8IChlbmQgPCBsZW4gJiYgdHlwZXNbZW5kXSA9PSBcIjFcIikgPyBcIjFcIiA6IFwiTlwiO1xuICAgICAgICAgIGZvciAodmFyIGogPSBpJDQ7IGogPCBlbmQ7ICsraikgeyB0eXBlc1tqXSA9IHJlcGxhY2U7IH1cbiAgICAgICAgICBpJDQgPSBlbmQgLSAxO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFc3LiBTZWFyY2ggYmFja3dhcmRzIGZyb20gZWFjaCBpbnN0YW5jZSBvZiBhIEV1cm9wZWFuIG51bWJlclxuICAgICAgLy8gdW50aWwgdGhlIGZpcnN0IHN0cm9uZyB0eXBlIChSLCBMLCBvciBzb3IpIGlzIGZvdW5kLiBJZiBhbiBMIGlzXG4gICAgICAvLyBmb3VuZCwgdGhlbiBjaGFuZ2UgdGhlIHR5cGUgb2YgdGhlIEV1cm9wZWFuIG51bWJlciB0byBMLlxuICAgICAgZm9yICh2YXIgaSQ1ID0gMCwgY3VyJDEgPSBvdXRlclR5cGU7IGkkNSA8IGxlbjsgKytpJDUpIHtcbiAgICAgICAgdmFyIHR5cGUkNCA9IHR5cGVzW2kkNV07XG4gICAgICAgIGlmIChjdXIkMSA9PSBcIkxcIiAmJiB0eXBlJDQgPT0gXCIxXCIpIHsgdHlwZXNbaSQ1XSA9IFwiTFwiOyB9XG4gICAgICAgIGVsc2UgaWYgKGlzU3Ryb25nLnRlc3QodHlwZSQ0KSkgeyBjdXIkMSA9IHR5cGUkNDsgfVxuICAgICAgfVxuXG4gICAgICAvLyBOMS4gQSBzZXF1ZW5jZSBvZiBuZXV0cmFscyB0YWtlcyB0aGUgZGlyZWN0aW9uIG9mIHRoZVxuICAgICAgLy8gc3Vycm91bmRpbmcgc3Ryb25nIHRleHQgaWYgdGhlIHRleHQgb24gYm90aCBzaWRlcyBoYXMgdGhlIHNhbWVcbiAgICAgIC8vIGRpcmVjdGlvbi4gRXVyb3BlYW4gYW5kIEFyYWJpYyBudW1iZXJzIGFjdCBhcyBpZiB0aGV5IHdlcmUgUiBpblxuICAgICAgLy8gdGVybXMgb2YgdGhlaXIgaW5mbHVlbmNlIG9uIG5ldXRyYWxzLiBTdGFydC1vZi1sZXZlbC1ydW4gKHNvcilcbiAgICAgIC8vIGFuZCBlbmQtb2YtbGV2ZWwtcnVuIChlb3IpIGFyZSB1c2VkIGF0IGxldmVsIHJ1biBib3VuZGFyaWVzLlxuICAgICAgLy8gTjIuIEFueSByZW1haW5pbmcgbmV1dHJhbHMgdGFrZSB0aGUgZW1iZWRkaW5nIGRpcmVjdGlvbi5cbiAgICAgIGZvciAodmFyIGkkNiA9IDA7IGkkNiA8IGxlbjsgKytpJDYpIHtcbiAgICAgICAgaWYgKGlzTmV1dHJhbC50ZXN0KHR5cGVzW2kkNl0pKSB7XG4gICAgICAgICAgdmFyIGVuZCQxID0gKHZvaWQgMCk7XG4gICAgICAgICAgZm9yIChlbmQkMSA9IGkkNiArIDE7IGVuZCQxIDwgbGVuICYmIGlzTmV1dHJhbC50ZXN0KHR5cGVzW2VuZCQxXSk7ICsrZW5kJDEpIHt9XG4gICAgICAgICAgdmFyIGJlZm9yZSA9IChpJDYgPyB0eXBlc1tpJDYtMV0gOiBvdXRlclR5cGUpID09IFwiTFwiO1xuICAgICAgICAgIHZhciBhZnRlciA9IChlbmQkMSA8IGxlbiA/IHR5cGVzW2VuZCQxXSA6IG91dGVyVHlwZSkgPT0gXCJMXCI7XG4gICAgICAgICAgdmFyIHJlcGxhY2UkMSA9IGJlZm9yZSA9PSBhZnRlciA/IChiZWZvcmUgPyBcIkxcIiA6IFwiUlwiKSA6IG91dGVyVHlwZTtcbiAgICAgICAgICBmb3IgKHZhciBqJDEgPSBpJDY7IGokMSA8IGVuZCQxOyArK2okMSkgeyB0eXBlc1tqJDFdID0gcmVwbGFjZSQxOyB9XG4gICAgICAgICAgaSQ2ID0gZW5kJDEgLSAxO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEhlcmUgd2UgZGVwYXJ0IGZyb20gdGhlIGRvY3VtZW50ZWQgYWxnb3JpdGhtLCBpbiBvcmRlciB0byBhdm9pZFxuICAgICAgLy8gYnVpbGRpbmcgdXAgYW4gYWN0dWFsIGxldmVscyBhcnJheS4gU2luY2UgdGhlcmUgYXJlIG9ubHkgdGhyZWVcbiAgICAgIC8vIGxldmVscyAoMCwgMSwgMikgaW4gYW4gaW1wbGVtZW50YXRpb24gdGhhdCBkb2Vzbid0IHRha2VcbiAgICAgIC8vIGV4cGxpY2l0IGVtYmVkZGluZyBpbnRvIGFjY291bnQsIHdlIGNhbiBidWlsZCB1cCB0aGUgb3JkZXIgb25cbiAgICAgIC8vIHRoZSBmbHksIHdpdGhvdXQgZm9sbG93aW5nIHRoZSBsZXZlbC1iYXNlZCBhbGdvcml0aG0uXG4gICAgICB2YXIgb3JkZXIgPSBbXSwgbTtcbiAgICAgIGZvciAodmFyIGkkNyA9IDA7IGkkNyA8IGxlbjspIHtcbiAgICAgICAgaWYgKGNvdW50c0FzTGVmdC50ZXN0KHR5cGVzW2kkN10pKSB7XG4gICAgICAgICAgdmFyIHN0YXJ0ID0gaSQ3O1xuICAgICAgICAgIGZvciAoKytpJDc7IGkkNyA8IGxlbiAmJiBjb3VudHNBc0xlZnQudGVzdCh0eXBlc1tpJDddKTsgKytpJDcpIHt9XG4gICAgICAgICAgb3JkZXIucHVzaChuZXcgQmlkaVNwYW4oMCwgc3RhcnQsIGkkNykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBwb3MgPSBpJDcsIGF0ID0gb3JkZXIubGVuZ3RoLCBpc1JUTCA9IGRpcmVjdGlvbiA9PSBcInJ0bFwiID8gMSA6IDA7XG4gICAgICAgICAgZm9yICgrK2kkNzsgaSQ3IDwgbGVuICYmIHR5cGVzW2kkN10gIT0gXCJMXCI7ICsraSQ3KSB7fVxuICAgICAgICAgIGZvciAodmFyIGokMiA9IHBvczsgaiQyIDwgaSQ3Oykge1xuICAgICAgICAgICAgaWYgKGNvdW50c0FzTnVtLnRlc3QodHlwZXNbaiQyXSkpIHtcbiAgICAgICAgICAgICAgaWYgKHBvcyA8IGokMikgeyBvcmRlci5zcGxpY2UoYXQsIDAsIG5ldyBCaWRpU3BhbigxLCBwb3MsIGokMikpOyBhdCArPSBpc1JUTDsgfVxuICAgICAgICAgICAgICB2YXIgbnN0YXJ0ID0gaiQyO1xuICAgICAgICAgICAgICBmb3IgKCsraiQyOyBqJDIgPCBpJDcgJiYgY291bnRzQXNOdW0udGVzdCh0eXBlc1tqJDJdKTsgKytqJDIpIHt9XG4gICAgICAgICAgICAgIG9yZGVyLnNwbGljZShhdCwgMCwgbmV3IEJpZGlTcGFuKDIsIG5zdGFydCwgaiQyKSk7XG4gICAgICAgICAgICAgIGF0ICs9IGlzUlRMO1xuICAgICAgICAgICAgICBwb3MgPSBqJDI7XG4gICAgICAgICAgICB9IGVsc2UgeyArK2okMjsgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocG9zIDwgaSQ3KSB7IG9yZGVyLnNwbGljZShhdCwgMCwgbmV3IEJpZGlTcGFuKDEsIHBvcywgaSQ3KSk7IH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGRpcmVjdGlvbiA9PSBcImx0clwiKSB7XG4gICAgICAgIGlmIChvcmRlclswXS5sZXZlbCA9PSAxICYmIChtID0gc3RyLm1hdGNoKC9eXFxzKy8pKSkge1xuICAgICAgICAgIG9yZGVyWzBdLmZyb20gPSBtWzBdLmxlbmd0aDtcbiAgICAgICAgICBvcmRlci51bnNoaWZ0KG5ldyBCaWRpU3BhbigwLCAwLCBtWzBdLmxlbmd0aCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsc3Qob3JkZXIpLmxldmVsID09IDEgJiYgKG0gPSBzdHIubWF0Y2goL1xccyskLykpKSB7XG4gICAgICAgICAgbHN0KG9yZGVyKS50byAtPSBtWzBdLmxlbmd0aDtcbiAgICAgICAgICBvcmRlci5wdXNoKG5ldyBCaWRpU3BhbigwLCBsZW4gLSBtWzBdLmxlbmd0aCwgbGVuKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRpcmVjdGlvbiA9PSBcInJ0bFwiID8gb3JkZXIucmV2ZXJzZSgpIDogb3JkZXJcbiAgICB9XG4gIH0pKCk7XG5cbiAgLy8gR2V0IHRoZSBiaWRpIG9yZGVyaW5nIGZvciB0aGUgZ2l2ZW4gbGluZSAoYW5kIGNhY2hlIGl0KS4gUmV0dXJuc1xuICAvLyBmYWxzZSBmb3IgbGluZXMgdGhhdCBhcmUgZnVsbHkgbGVmdC10by1yaWdodCwgYW5kIGFuIGFycmF5IG9mXG4gIC8vIEJpZGlTcGFuIG9iamVjdHMgb3RoZXJ3aXNlLlxuICBmdW5jdGlvbiBnZXRPcmRlcihsaW5lLCBkaXJlY3Rpb24pIHtcbiAgICB2YXIgb3JkZXIgPSBsaW5lLm9yZGVyO1xuICAgIGlmIChvcmRlciA9PSBudWxsKSB7IG9yZGVyID0gbGluZS5vcmRlciA9IGJpZGlPcmRlcmluZyhsaW5lLnRleHQsIGRpcmVjdGlvbik7IH1cbiAgICByZXR1cm4gb3JkZXJcbiAgfVxuXG4gIC8vIEVWRU5UIEhBTkRMSU5HXG5cbiAgLy8gTGlnaHR3ZWlnaHQgZXZlbnQgZnJhbWV3b3JrLiBvbi9vZmYgYWxzbyB3b3JrIG9uIERPTSBub2RlcyxcbiAgLy8gcmVnaXN0ZXJpbmcgbmF0aXZlIERPTSBoYW5kbGVycy5cblxuICB2YXIgbm9IYW5kbGVycyA9IFtdO1xuXG4gIHZhciBvbiA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUsIGYpIHtcbiAgICBpZiAoZW1pdHRlci5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICBlbWl0dGVyLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgZiwgZmFsc2UpO1xuICAgIH0gZWxzZSBpZiAoZW1pdHRlci5hdHRhY2hFdmVudCkge1xuICAgICAgZW1pdHRlci5hdHRhY2hFdmVudChcIm9uXCIgKyB0eXBlLCBmKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG1hcCA9IGVtaXR0ZXIuX2hhbmRsZXJzIHx8IChlbWl0dGVyLl9oYW5kbGVycyA9IHt9KTtcbiAgICAgIG1hcFt0eXBlXSA9IChtYXBbdHlwZV0gfHwgbm9IYW5kbGVycykuY29uY2F0KGYpO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBnZXRIYW5kbGVycyhlbWl0dGVyLCB0eXBlKSB7XG4gICAgcmV0dXJuIGVtaXR0ZXIuX2hhbmRsZXJzICYmIGVtaXR0ZXIuX2hhbmRsZXJzW3R5cGVdIHx8IG5vSGFuZGxlcnNcbiAgfVxuXG4gIGZ1bmN0aW9uIG9mZihlbWl0dGVyLCB0eXBlLCBmKSB7XG4gICAgaWYgKGVtaXR0ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xuICAgICAgZW1pdHRlci5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGYsIGZhbHNlKTtcbiAgICB9IGVsc2UgaWYgKGVtaXR0ZXIuZGV0YWNoRXZlbnQpIHtcbiAgICAgIGVtaXR0ZXIuZGV0YWNoRXZlbnQoXCJvblwiICsgdHlwZSwgZik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBtYXAgPSBlbWl0dGVyLl9oYW5kbGVycywgYXJyID0gbWFwICYmIG1hcFt0eXBlXTtcbiAgICAgIGlmIChhcnIpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gaW5kZXhPZihhcnIsIGYpO1xuICAgICAgICBpZiAoaW5kZXggPiAtMSlcbiAgICAgICAgICB7IG1hcFt0eXBlXSA9IGFyci5zbGljZSgwLCBpbmRleCkuY29uY2F0KGFyci5zbGljZShpbmRleCArIDEpKTsgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNpZ25hbChlbWl0dGVyLCB0eXBlIC8qLCB2YWx1ZXMuLi4qLykge1xuICAgIHZhciBoYW5kbGVycyA9IGdldEhhbmRsZXJzKGVtaXR0ZXIsIHR5cGUpO1xuICAgIGlmICghaGFuZGxlcnMubGVuZ3RoKSB7IHJldHVybiB9XG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGFuZGxlcnMubGVuZ3RoOyArK2kpIHsgaGFuZGxlcnNbaV0uYXBwbHkobnVsbCwgYXJncyk7IH1cbiAgfVxuXG4gIC8vIFRoZSBET00gZXZlbnRzIHRoYXQgQ29kZU1pcnJvciBoYW5kbGVzIGNhbiBiZSBvdmVycmlkZGVuIGJ5XG4gIC8vIHJlZ2lzdGVyaW5nIGEgKG5vbi1ET00pIGhhbmRsZXIgb24gdGhlIGVkaXRvciBmb3IgdGhlIGV2ZW50IG5hbWUsXG4gIC8vIGFuZCBwcmV2ZW50RGVmYXVsdC1pbmcgdGhlIGV2ZW50IGluIHRoYXQgaGFuZGxlci5cbiAgZnVuY3Rpb24gc2lnbmFsRE9NRXZlbnQoY20sIGUsIG92ZXJyaWRlKSB7XG4gICAgaWYgKHR5cGVvZiBlID09IFwic3RyaW5nXCIpXG4gICAgICB7IGUgPSB7dHlwZTogZSwgcHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uKCkgeyB0aGlzLmRlZmF1bHRQcmV2ZW50ZWQgPSB0cnVlOyB9fTsgfVxuICAgIHNpZ25hbChjbSwgb3ZlcnJpZGUgfHwgZS50eXBlLCBjbSwgZSk7XG4gICAgcmV0dXJuIGVfZGVmYXVsdFByZXZlbnRlZChlKSB8fCBlLmNvZGVtaXJyb3JJZ25vcmVcbiAgfVxuXG4gIGZ1bmN0aW9uIHNpZ25hbEN1cnNvckFjdGl2aXR5KGNtKSB7XG4gICAgdmFyIGFyciA9IGNtLl9oYW5kbGVycyAmJiBjbS5faGFuZGxlcnMuY3Vyc29yQWN0aXZpdHk7XG4gICAgaWYgKCFhcnIpIHsgcmV0dXJuIH1cbiAgICB2YXIgc2V0ID0gY20uY3VyT3AuY3Vyc29yQWN0aXZpdHlIYW5kbGVycyB8fCAoY20uY3VyT3AuY3Vyc29yQWN0aXZpdHlIYW5kbGVycyA9IFtdKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7ICsraSkgeyBpZiAoaW5kZXhPZihzZXQsIGFycltpXSkgPT0gLTEpXG4gICAgICB7IHNldC5wdXNoKGFycltpXSk7IH0gfVxuICB9XG5cbiAgZnVuY3Rpb24gaGFzSGFuZGxlcihlbWl0dGVyLCB0eXBlKSB7XG4gICAgcmV0dXJuIGdldEhhbmRsZXJzKGVtaXR0ZXIsIHR5cGUpLmxlbmd0aCA+IDBcbiAgfVxuXG4gIC8vIEFkZCBvbiBhbmQgb2ZmIG1ldGhvZHMgdG8gYSBjb25zdHJ1Y3RvcidzIHByb3RvdHlwZSwgdG8gbWFrZVxuICAvLyByZWdpc3RlcmluZyBldmVudHMgb24gc3VjaCBvYmplY3RzIG1vcmUgY29udmVuaWVudC5cbiAgZnVuY3Rpb24gZXZlbnRNaXhpbihjdG9yKSB7XG4gICAgY3Rvci5wcm90b3R5cGUub24gPSBmdW5jdGlvbih0eXBlLCBmKSB7b24odGhpcywgdHlwZSwgZik7fTtcbiAgICBjdG9yLnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbih0eXBlLCBmKSB7b2ZmKHRoaXMsIHR5cGUsIGYpO307XG4gIH1cblxuICAvLyBEdWUgdG8gdGhlIGZhY3QgdGhhdCB3ZSBzdGlsbCBzdXBwb3J0IGp1cmFzc2ljIElFIHZlcnNpb25zLCBzb21lXG4gIC8vIGNvbXBhdGliaWxpdHkgd3JhcHBlcnMgYXJlIG5lZWRlZC5cblxuICBmdW5jdGlvbiBlX3ByZXZlbnREZWZhdWx0KGUpIHtcbiAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkgeyBlLnByZXZlbnREZWZhdWx0KCk7IH1cbiAgICBlbHNlIHsgZS5yZXR1cm5WYWx1ZSA9IGZhbHNlOyB9XG4gIH1cbiAgZnVuY3Rpb24gZV9zdG9wUHJvcGFnYXRpb24oZSkge1xuICAgIGlmIChlLnN0b3BQcm9wYWdhdGlvbikgeyBlLnN0b3BQcm9wYWdhdGlvbigpOyB9XG4gICAgZWxzZSB7IGUuY2FuY2VsQnViYmxlID0gdHJ1ZTsgfVxuICB9XG4gIGZ1bmN0aW9uIGVfZGVmYXVsdFByZXZlbnRlZChlKSB7XG4gICAgcmV0dXJuIGUuZGVmYXVsdFByZXZlbnRlZCAhPSBudWxsID8gZS5kZWZhdWx0UHJldmVudGVkIDogZS5yZXR1cm5WYWx1ZSA9PSBmYWxzZVxuICB9XG4gIGZ1bmN0aW9uIGVfc3RvcChlKSB7ZV9wcmV2ZW50RGVmYXVsdChlKTsgZV9zdG9wUHJvcGFnYXRpb24oZSk7fVxuXG4gIGZ1bmN0aW9uIGVfdGFyZ2V0KGUpIHtyZXR1cm4gZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50fVxuICBmdW5jdGlvbiBlX2J1dHRvbihlKSB7XG4gICAgdmFyIGIgPSBlLndoaWNoO1xuICAgIGlmIChiID09IG51bGwpIHtcbiAgICAgIGlmIChlLmJ1dHRvbiAmIDEpIHsgYiA9IDE7IH1cbiAgICAgIGVsc2UgaWYgKGUuYnV0dG9uICYgMikgeyBiID0gMzsgfVxuICAgICAgZWxzZSBpZiAoZS5idXR0b24gJiA0KSB7IGIgPSAyOyB9XG4gICAgfVxuICAgIGlmIChtYWMgJiYgZS5jdHJsS2V5ICYmIGIgPT0gMSkgeyBiID0gMzsgfVxuICAgIHJldHVybiBiXG4gIH1cblxuICAvLyBEZXRlY3QgZHJhZy1hbmQtZHJvcFxuICB2YXIgZHJhZ0FuZERyb3AgPSBmdW5jdGlvbigpIHtcbiAgICAvLyBUaGVyZSBpcyAqc29tZSoga2luZCBvZiBkcmFnLWFuZC1kcm9wIHN1cHBvcnQgaW4gSUU2LTgsIGJ1dCBJXG4gICAgLy8gY291bGRuJ3QgZ2V0IGl0IHRvIHdvcmsgeWV0LlxuICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDwgOSkgeyByZXR1cm4gZmFsc2UgfVxuICAgIHZhciBkaXYgPSBlbHQoJ2RpdicpO1xuICAgIHJldHVybiBcImRyYWdnYWJsZVwiIGluIGRpdiB8fCBcImRyYWdEcm9wXCIgaW4gZGl2XG4gIH0oKTtcblxuICB2YXIgendzcFN1cHBvcnRlZDtcbiAgZnVuY3Rpb24gemVyb1dpZHRoRWxlbWVudChtZWFzdXJlKSB7XG4gICAgaWYgKHp3c3BTdXBwb3J0ZWQgPT0gbnVsbCkge1xuICAgICAgdmFyIHRlc3QgPSBlbHQoXCJzcGFuXCIsIFwiXFx1MjAwYlwiKTtcbiAgICAgIHJlbW92ZUNoaWxkcmVuQW5kQWRkKG1lYXN1cmUsIGVsdChcInNwYW5cIiwgW3Rlc3QsIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwieFwiKV0pKTtcbiAgICAgIGlmIChtZWFzdXJlLmZpcnN0Q2hpbGQub2Zmc2V0SGVpZ2h0ICE9IDApXG4gICAgICAgIHsgendzcFN1cHBvcnRlZCA9IHRlc3Qub2Zmc2V0V2lkdGggPD0gMSAmJiB0ZXN0Lm9mZnNldEhlaWdodCA+IDIgJiYgIShpZSAmJiBpZV92ZXJzaW9uIDwgOCk7IH1cbiAgICB9XG4gICAgdmFyIG5vZGUgPSB6d3NwU3VwcG9ydGVkID8gZWx0KFwic3BhblwiLCBcIlxcdTIwMGJcIikgOlxuICAgICAgZWx0KFwic3BhblwiLCBcIlxcdTAwYTBcIiwgbnVsbCwgXCJkaXNwbGF5OiBpbmxpbmUtYmxvY2s7IHdpZHRoOiAxcHg7IG1hcmdpbi1yaWdodDogLTFweFwiKTtcbiAgICBub2RlLnNldEF0dHJpYnV0ZShcImNtLXRleHRcIiwgXCJcIik7XG4gICAgcmV0dXJuIG5vZGVcbiAgfVxuXG4gIC8vIEZlYXR1cmUtZGV0ZWN0IElFJ3MgY3J1bW15IGNsaWVudCByZWN0IHJlcG9ydGluZyBmb3IgYmlkaSB0ZXh0XG4gIHZhciBiYWRCaWRpUmVjdHM7XG4gIGZ1bmN0aW9uIGhhc0JhZEJpZGlSZWN0cyhtZWFzdXJlKSB7XG4gICAgaWYgKGJhZEJpZGlSZWN0cyAhPSBudWxsKSB7IHJldHVybiBiYWRCaWRpUmVjdHMgfVxuICAgIHZhciB0eHQgPSByZW1vdmVDaGlsZHJlbkFuZEFkZChtZWFzdXJlLCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIkFcXHUwNjJlQVwiKSk7XG4gICAgdmFyIHIwID0gcmFuZ2UodHh0LCAwLCAxKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB2YXIgcjEgPSByYW5nZSh0eHQsIDEsIDIpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJlbW92ZUNoaWxkcmVuKG1lYXN1cmUpO1xuICAgIGlmICghcjAgfHwgcjAubGVmdCA9PSByMC5yaWdodCkgeyByZXR1cm4gZmFsc2UgfSAvLyBTYWZhcmkgcmV0dXJucyBudWxsIGluIHNvbWUgY2FzZXMgKCMyNzgwKVxuICAgIHJldHVybiBiYWRCaWRpUmVjdHMgPSAocjEucmlnaHQgLSByMC5yaWdodCA8IDMpXG4gIH1cblxuICAvLyBTZWUgaWYgXCJcIi5zcGxpdCBpcyB0aGUgYnJva2VuIElFIHZlcnNpb24sIGlmIHNvLCBwcm92aWRlIGFuXG4gIC8vIGFsdGVybmF0aXZlIHdheSB0byBzcGxpdCBsaW5lcy5cbiAgdmFyIHNwbGl0TGluZXNBdXRvID0gXCJcXG5cXG5iXCIuc3BsaXQoL1xcbi8pLmxlbmd0aCAhPSAzID8gZnVuY3Rpb24gKHN0cmluZykge1xuICAgIHZhciBwb3MgPSAwLCByZXN1bHQgPSBbXSwgbCA9IHN0cmluZy5sZW5ndGg7XG4gICAgd2hpbGUgKHBvcyA8PSBsKSB7XG4gICAgICB2YXIgbmwgPSBzdHJpbmcuaW5kZXhPZihcIlxcblwiLCBwb3MpO1xuICAgICAgaWYgKG5sID09IC0xKSB7IG5sID0gc3RyaW5nLmxlbmd0aDsgfVxuICAgICAgdmFyIGxpbmUgPSBzdHJpbmcuc2xpY2UocG9zLCBzdHJpbmcuY2hhckF0KG5sIC0gMSkgPT0gXCJcXHJcIiA/IG5sIC0gMSA6IG5sKTtcbiAgICAgIHZhciBydCA9IGxpbmUuaW5kZXhPZihcIlxcclwiKTtcbiAgICAgIGlmIChydCAhPSAtMSkge1xuICAgICAgICByZXN1bHQucHVzaChsaW5lLnNsaWNlKDAsIHJ0KSk7XG4gICAgICAgIHBvcyArPSBydCArIDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQucHVzaChsaW5lKTtcbiAgICAgICAgcG9zID0gbmwgKyAxO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0XG4gIH0gOiBmdW5jdGlvbiAoc3RyaW5nKSB7IHJldHVybiBzdHJpbmcuc3BsaXQoL1xcclxcbj98XFxuLyk7IH07XG5cbiAgdmFyIGhhc1NlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24gPyBmdW5jdGlvbiAodGUpIHtcbiAgICB0cnkgeyByZXR1cm4gdGUuc2VsZWN0aW9uU3RhcnQgIT0gdGUuc2VsZWN0aW9uRW5kIH1cbiAgICBjYXRjaChlKSB7IHJldHVybiBmYWxzZSB9XG4gIH0gOiBmdW5jdGlvbiAodGUpIHtcbiAgICB2YXIgcmFuZ2U7XG4gICAgdHJ5IHtyYW5nZSA9IHRlLm93bmVyRG9jdW1lbnQuc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCk7fVxuICAgIGNhdGNoKGUpIHt9XG4gICAgaWYgKCFyYW5nZSB8fCByYW5nZS5wYXJlbnRFbGVtZW50KCkgIT0gdGUpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICByZXR1cm4gcmFuZ2UuY29tcGFyZUVuZFBvaW50cyhcIlN0YXJ0VG9FbmRcIiwgcmFuZ2UpICE9IDBcbiAgfTtcblxuICB2YXIgaGFzQ29weUV2ZW50ID0gKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZSA9IGVsdChcImRpdlwiKTtcbiAgICBpZiAoXCJvbmNvcHlcIiBpbiBlKSB7IHJldHVybiB0cnVlIH1cbiAgICBlLnNldEF0dHJpYnV0ZShcIm9uY29weVwiLCBcInJldHVybjtcIik7XG4gICAgcmV0dXJuIHR5cGVvZiBlLm9uY29weSA9PSBcImZ1bmN0aW9uXCJcbiAgfSkoKTtcblxuICB2YXIgYmFkWm9vbWVkUmVjdHMgPSBudWxsO1xuICBmdW5jdGlvbiBoYXNCYWRab29tZWRSZWN0cyhtZWFzdXJlKSB7XG4gICAgaWYgKGJhZFpvb21lZFJlY3RzICE9IG51bGwpIHsgcmV0dXJuIGJhZFpvb21lZFJlY3RzIH1cbiAgICB2YXIgbm9kZSA9IHJlbW92ZUNoaWxkcmVuQW5kQWRkKG1lYXN1cmUsIGVsdChcInNwYW5cIiwgXCJ4XCIpKTtcbiAgICB2YXIgbm9ybWFsID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB2YXIgZnJvbVJhbmdlID0gcmFuZ2Uobm9kZSwgMCwgMSkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgcmV0dXJuIGJhZFpvb21lZFJlY3RzID0gTWF0aC5hYnMobm9ybWFsLmxlZnQgLSBmcm9tUmFuZ2UubGVmdCkgPiAxXG4gIH1cblxuICAvLyBLbm93biBtb2RlcywgYnkgbmFtZSBhbmQgYnkgTUlNRVxuICB2YXIgbW9kZXMgPSB7fSwgbWltZU1vZGVzID0ge307XG5cbiAgLy8gRXh0cmEgYXJndW1lbnRzIGFyZSBzdG9yZWQgYXMgdGhlIG1vZGUncyBkZXBlbmRlbmNpZXMsIHdoaWNoIGlzXG4gIC8vIHVzZWQgYnkgKGxlZ2FjeSkgbWVjaGFuaXNtcyBsaWtlIGxvYWRtb2RlLmpzIHRvIGF1dG9tYXRpY2FsbHlcbiAgLy8gbG9hZCBhIG1vZGUuIChQcmVmZXJyZWQgbWVjaGFuaXNtIGlzIHRoZSByZXF1aXJlL2RlZmluZSBjYWxscy4pXG4gIGZ1bmN0aW9uIGRlZmluZU1vZGUobmFtZSwgbW9kZSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMilcbiAgICAgIHsgbW9kZS5kZXBlbmRlbmNpZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpOyB9XG4gICAgbW9kZXNbbmFtZV0gPSBtb2RlO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVmaW5lTUlNRShtaW1lLCBzcGVjKSB7XG4gICAgbWltZU1vZGVzW21pbWVdID0gc3BlYztcbiAgfVxuXG4gIC8vIEdpdmVuIGEgTUlNRSB0eXBlLCBhIHtuYW1lLCAuLi5vcHRpb25zfSBjb25maWcgb2JqZWN0LCBvciBhIG5hbWVcbiAgLy8gc3RyaW5nLCByZXR1cm4gYSBtb2RlIGNvbmZpZyBvYmplY3QuXG4gIGZ1bmN0aW9uIHJlc29sdmVNb2RlKHNwZWMpIHtcbiAgICBpZiAodHlwZW9mIHNwZWMgPT0gXCJzdHJpbmdcIiAmJiBtaW1lTW9kZXMuaGFzT3duUHJvcGVydHkoc3BlYykpIHtcbiAgICAgIHNwZWMgPSBtaW1lTW9kZXNbc3BlY107XG4gICAgfSBlbHNlIGlmIChzcGVjICYmIHR5cGVvZiBzcGVjLm5hbWUgPT0gXCJzdHJpbmdcIiAmJiBtaW1lTW9kZXMuaGFzT3duUHJvcGVydHkoc3BlYy5uYW1lKSkge1xuICAgICAgdmFyIGZvdW5kID0gbWltZU1vZGVzW3NwZWMubmFtZV07XG4gICAgICBpZiAodHlwZW9mIGZvdW5kID09IFwic3RyaW5nXCIpIHsgZm91bmQgPSB7bmFtZTogZm91bmR9OyB9XG4gICAgICBzcGVjID0gY3JlYXRlT2JqKGZvdW5kLCBzcGVjKTtcbiAgICAgIHNwZWMubmFtZSA9IGZvdW5kLm5hbWU7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygc3BlYyA9PSBcInN0cmluZ1wiICYmIC9eW1xcd1xcLV0rXFwvW1xcd1xcLV0rXFwreG1sJC8udGVzdChzcGVjKSkge1xuICAgICAgcmV0dXJuIHJlc29sdmVNb2RlKFwiYXBwbGljYXRpb24veG1sXCIpXG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygc3BlYyA9PSBcInN0cmluZ1wiICYmIC9eW1xcd1xcLV0rXFwvW1xcd1xcLV0rXFwranNvbiQvLnRlc3Qoc3BlYykpIHtcbiAgICAgIHJldHVybiByZXNvbHZlTW9kZShcImFwcGxpY2F0aW9uL2pzb25cIilcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBzcGVjID09IFwic3RyaW5nXCIpIHsgcmV0dXJuIHtuYW1lOiBzcGVjfSB9XG4gICAgZWxzZSB7IHJldHVybiBzcGVjIHx8IHtuYW1lOiBcIm51bGxcIn0gfVxuICB9XG5cbiAgLy8gR2l2ZW4gYSBtb2RlIHNwZWMgKGFueXRoaW5nIHRoYXQgcmVzb2x2ZU1vZGUgYWNjZXB0cyksIGZpbmQgYW5kXG4gIC8vIGluaXRpYWxpemUgYW4gYWN0dWFsIG1vZGUgb2JqZWN0LlxuICBmdW5jdGlvbiBnZXRNb2RlKG9wdGlvbnMsIHNwZWMpIHtcbiAgICBzcGVjID0gcmVzb2x2ZU1vZGUoc3BlYyk7XG4gICAgdmFyIG1mYWN0b3J5ID0gbW9kZXNbc3BlYy5uYW1lXTtcbiAgICBpZiAoIW1mYWN0b3J5KSB7IHJldHVybiBnZXRNb2RlKG9wdGlvbnMsIFwidGV4dC9wbGFpblwiKSB9XG4gICAgdmFyIG1vZGVPYmogPSBtZmFjdG9yeShvcHRpb25zLCBzcGVjKTtcbiAgICBpZiAobW9kZUV4dGVuc2lvbnMuaGFzT3duUHJvcGVydHkoc3BlYy5uYW1lKSkge1xuICAgICAgdmFyIGV4dHMgPSBtb2RlRXh0ZW5zaW9uc1tzcGVjLm5hbWVdO1xuICAgICAgZm9yICh2YXIgcHJvcCBpbiBleHRzKSB7XG4gICAgICAgIGlmICghZXh0cy5oYXNPd25Qcm9wZXJ0eShwcm9wKSkgeyBjb250aW51ZSB9XG4gICAgICAgIGlmIChtb2RlT2JqLmhhc093blByb3BlcnR5KHByb3ApKSB7IG1vZGVPYmpbXCJfXCIgKyBwcm9wXSA9IG1vZGVPYmpbcHJvcF07IH1cbiAgICAgICAgbW9kZU9ialtwcm9wXSA9IGV4dHNbcHJvcF07XG4gICAgICB9XG4gICAgfVxuICAgIG1vZGVPYmoubmFtZSA9IHNwZWMubmFtZTtcbiAgICBpZiAoc3BlYy5oZWxwZXJUeXBlKSB7IG1vZGVPYmouaGVscGVyVHlwZSA9IHNwZWMuaGVscGVyVHlwZTsgfVxuICAgIGlmIChzcGVjLm1vZGVQcm9wcykgeyBmb3IgKHZhciBwcm9wJDEgaW4gc3BlYy5tb2RlUHJvcHMpXG4gICAgICB7IG1vZGVPYmpbcHJvcCQxXSA9IHNwZWMubW9kZVByb3BzW3Byb3AkMV07IH0gfVxuXG4gICAgcmV0dXJuIG1vZGVPYmpcbiAgfVxuXG4gIC8vIFRoaXMgY2FuIGJlIHVzZWQgdG8gYXR0YWNoIHByb3BlcnRpZXMgdG8gbW9kZSBvYmplY3RzIGZyb21cbiAgLy8gb3V0c2lkZSB0aGUgYWN0dWFsIG1vZGUgZGVmaW5pdGlvbi5cbiAgdmFyIG1vZGVFeHRlbnNpb25zID0ge307XG4gIGZ1bmN0aW9uIGV4dGVuZE1vZGUobW9kZSwgcHJvcGVydGllcykge1xuICAgIHZhciBleHRzID0gbW9kZUV4dGVuc2lvbnMuaGFzT3duUHJvcGVydHkobW9kZSkgPyBtb2RlRXh0ZW5zaW9uc1ttb2RlXSA6IChtb2RlRXh0ZW5zaW9uc1ttb2RlXSA9IHt9KTtcbiAgICBjb3B5T2JqKHByb3BlcnRpZXMsIGV4dHMpO1xuICB9XG5cbiAgZnVuY3Rpb24gY29weVN0YXRlKG1vZGUsIHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlID09PSB0cnVlKSB7IHJldHVybiBzdGF0ZSB9XG4gICAgaWYgKG1vZGUuY29weVN0YXRlKSB7IHJldHVybiBtb2RlLmNvcHlTdGF0ZShzdGF0ZSkgfVxuICAgIHZhciBuc3RhdGUgPSB7fTtcbiAgICBmb3IgKHZhciBuIGluIHN0YXRlKSB7XG4gICAgICB2YXIgdmFsID0gc3RhdGVbbl07XG4gICAgICBpZiAodmFsIGluc3RhbmNlb2YgQXJyYXkpIHsgdmFsID0gdmFsLmNvbmNhdChbXSk7IH1cbiAgICAgIG5zdGF0ZVtuXSA9IHZhbDtcbiAgICB9XG4gICAgcmV0dXJuIG5zdGF0ZVxuICB9XG5cbiAgLy8gR2l2ZW4gYSBtb2RlIGFuZCBhIHN0YXRlIChmb3IgdGhhdCBtb2RlKSwgZmluZCB0aGUgaW5uZXIgbW9kZSBhbmRcbiAgLy8gc3RhdGUgYXQgdGhlIHBvc2l0aW9uIHRoYXQgdGhlIHN0YXRlIHJlZmVycyB0by5cbiAgZnVuY3Rpb24gaW5uZXJNb2RlKG1vZGUsIHN0YXRlKSB7XG4gICAgdmFyIGluZm87XG4gICAgd2hpbGUgKG1vZGUuaW5uZXJNb2RlKSB7XG4gICAgICBpbmZvID0gbW9kZS5pbm5lck1vZGUoc3RhdGUpO1xuICAgICAgaWYgKCFpbmZvIHx8IGluZm8ubW9kZSA9PSBtb2RlKSB7IGJyZWFrIH1cbiAgICAgIHN0YXRlID0gaW5mby5zdGF0ZTtcbiAgICAgIG1vZGUgPSBpbmZvLm1vZGU7XG4gICAgfVxuICAgIHJldHVybiBpbmZvIHx8IHttb2RlOiBtb2RlLCBzdGF0ZTogc3RhdGV9XG4gIH1cblxuICBmdW5jdGlvbiBzdGFydFN0YXRlKG1vZGUsIGExLCBhMikge1xuICAgIHJldHVybiBtb2RlLnN0YXJ0U3RhdGUgPyBtb2RlLnN0YXJ0U3RhdGUoYTEsIGEyKSA6IHRydWVcbiAgfVxuXG4gIC8vIFNUUklORyBTVFJFQU1cblxuICAvLyBGZWQgdG8gdGhlIG1vZGUgcGFyc2VycywgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byBtYWtlXG4gIC8vIHBhcnNlcnMgbW9yZSBzdWNjaW5jdC5cblxuICB2YXIgU3RyaW5nU3RyZWFtID0gZnVuY3Rpb24oc3RyaW5nLCB0YWJTaXplLCBsaW5lT3JhY2xlKSB7XG4gICAgdGhpcy5wb3MgPSB0aGlzLnN0YXJ0ID0gMDtcbiAgICB0aGlzLnN0cmluZyA9IHN0cmluZztcbiAgICB0aGlzLnRhYlNpemUgPSB0YWJTaXplIHx8IDg7XG4gICAgdGhpcy5sYXN0Q29sdW1uUG9zID0gdGhpcy5sYXN0Q29sdW1uVmFsdWUgPSAwO1xuICAgIHRoaXMubGluZVN0YXJ0ID0gMDtcbiAgICB0aGlzLmxpbmVPcmFjbGUgPSBsaW5lT3JhY2xlO1xuICB9O1xuXG4gIFN0cmluZ1N0cmVhbS5wcm90b3R5cGUuZW9sID0gZnVuY3Rpb24gKCkge3JldHVybiB0aGlzLnBvcyA+PSB0aGlzLnN0cmluZy5sZW5ndGh9O1xuICBTdHJpbmdTdHJlYW0ucHJvdG90eXBlLnNvbCA9IGZ1bmN0aW9uICgpIHtyZXR1cm4gdGhpcy5wb3MgPT0gdGhpcy5saW5lU3RhcnR9O1xuICBTdHJpbmdTdHJlYW0ucHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbiAoKSB7cmV0dXJuIHRoaXMuc3RyaW5nLmNoYXJBdCh0aGlzLnBvcykgfHwgdW5kZWZpbmVkfTtcbiAgU3RyaW5nU3RyZWFtLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnBvcyA8IHRoaXMuc3RyaW5nLmxlbmd0aClcbiAgICAgIHsgcmV0dXJuIHRoaXMuc3RyaW5nLmNoYXJBdCh0aGlzLnBvcysrKSB9XG4gIH07XG4gIFN0cmluZ1N0cmVhbS5wcm90b3R5cGUuZWF0ID0gZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgdmFyIGNoID0gdGhpcy5zdHJpbmcuY2hhckF0KHRoaXMucG9zKTtcbiAgICB2YXIgb2s7XG4gICAgaWYgKHR5cGVvZiBtYXRjaCA9PSBcInN0cmluZ1wiKSB7IG9rID0gY2ggPT0gbWF0Y2g7IH1cbiAgICBlbHNlIHsgb2sgPSBjaCAmJiAobWF0Y2gudGVzdCA/IG1hdGNoLnRlc3QoY2gpIDogbWF0Y2goY2gpKTsgfVxuICAgIGlmIChvaykgeysrdGhpcy5wb3M7IHJldHVybiBjaH1cbiAgfTtcbiAgU3RyaW5nU3RyZWFtLnByb3RvdHlwZS5lYXRXaGlsZSA9IGZ1bmN0aW9uIChtYXRjaCkge1xuICAgIHZhciBzdGFydCA9IHRoaXMucG9zO1xuICAgIHdoaWxlICh0aGlzLmVhdChtYXRjaCkpe31cbiAgICByZXR1cm4gdGhpcy5wb3MgPiBzdGFydFxuICB9O1xuICBTdHJpbmdTdHJlYW0ucHJvdG90eXBlLmVhdFNwYWNlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdGFydCA9IHRoaXMucG9zO1xuICAgIHdoaWxlICgvW1xcc1xcdTAwYTBdLy50ZXN0KHRoaXMuc3RyaW5nLmNoYXJBdCh0aGlzLnBvcykpKSB7ICsrdGhpcy5wb3M7IH1cbiAgICByZXR1cm4gdGhpcy5wb3MgPiBzdGFydFxuICB9O1xuICBTdHJpbmdTdHJlYW0ucHJvdG90eXBlLnNraXBUb0VuZCA9IGZ1bmN0aW9uICgpIHt0aGlzLnBvcyA9IHRoaXMuc3RyaW5nLmxlbmd0aDt9O1xuICBTdHJpbmdTdHJlYW0ucHJvdG90eXBlLnNraXBUbyA9IGZ1bmN0aW9uIChjaCkge1xuICAgIHZhciBmb3VuZCA9IHRoaXMuc3RyaW5nLmluZGV4T2YoY2gsIHRoaXMucG9zKTtcbiAgICBpZiAoZm91bmQgPiAtMSkge3RoaXMucG9zID0gZm91bmQ7IHJldHVybiB0cnVlfVxuICB9O1xuICBTdHJpbmdTdHJlYW0ucHJvdG90eXBlLmJhY2tVcCA9IGZ1bmN0aW9uIChuKSB7dGhpcy5wb3MgLT0gbjt9O1xuICBTdHJpbmdTdHJlYW0ucHJvdG90eXBlLmNvbHVtbiA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5sYXN0Q29sdW1uUG9zIDwgdGhpcy5zdGFydCkge1xuICAgICAgdGhpcy5sYXN0Q29sdW1uVmFsdWUgPSBjb3VudENvbHVtbih0aGlzLnN0cmluZywgdGhpcy5zdGFydCwgdGhpcy50YWJTaXplLCB0aGlzLmxhc3RDb2x1bW5Qb3MsIHRoaXMubGFzdENvbHVtblZhbHVlKTtcbiAgICAgIHRoaXMubGFzdENvbHVtblBvcyA9IHRoaXMuc3RhcnQ7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmxhc3RDb2x1bW5WYWx1ZSAtICh0aGlzLmxpbmVTdGFydCA/IGNvdW50Q29sdW1uKHRoaXMuc3RyaW5nLCB0aGlzLmxpbmVTdGFydCwgdGhpcy50YWJTaXplKSA6IDApXG4gIH07XG4gIFN0cmluZ1N0cmVhbS5wcm90b3R5cGUuaW5kZW50YXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNvdW50Q29sdW1uKHRoaXMuc3RyaW5nLCBudWxsLCB0aGlzLnRhYlNpemUpIC1cbiAgICAgICh0aGlzLmxpbmVTdGFydCA/IGNvdW50Q29sdW1uKHRoaXMuc3RyaW5nLCB0aGlzLmxpbmVTdGFydCwgdGhpcy50YWJTaXplKSA6IDApXG4gIH07XG4gIFN0cmluZ1N0cmVhbS5wcm90b3R5cGUubWF0Y2ggPSBmdW5jdGlvbiAocGF0dGVybiwgY29uc3VtZSwgY2FzZUluc2Vuc2l0aXZlKSB7XG4gICAgaWYgKHR5cGVvZiBwYXR0ZXJuID09IFwic3RyaW5nXCIpIHtcbiAgICAgIHZhciBjYXNlZCA9IGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIGNhc2VJbnNlbnNpdGl2ZSA/IHN0ci50b0xvd2VyQ2FzZSgpIDogc3RyOyB9O1xuICAgICAgdmFyIHN1YnN0ciA9IHRoaXMuc3RyaW5nLnN1YnN0cih0aGlzLnBvcywgcGF0dGVybi5sZW5ndGgpO1xuICAgICAgaWYgKGNhc2VkKHN1YnN0cikgPT0gY2FzZWQocGF0dGVybikpIHtcbiAgICAgICAgaWYgKGNvbnN1bWUgIT09IGZhbHNlKSB7IHRoaXMucG9zICs9IHBhdHRlcm4ubGVuZ3RoOyB9XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBtYXRjaCA9IHRoaXMuc3RyaW5nLnNsaWNlKHRoaXMucG9zKS5tYXRjaChwYXR0ZXJuKTtcbiAgICAgIGlmIChtYXRjaCAmJiBtYXRjaC5pbmRleCA+IDApIHsgcmV0dXJuIG51bGwgfVxuICAgICAgaWYgKG1hdGNoICYmIGNvbnN1bWUgIT09IGZhbHNlKSB7IHRoaXMucG9zICs9IG1hdGNoWzBdLmxlbmd0aDsgfVxuICAgICAgcmV0dXJuIG1hdGNoXG4gICAgfVxuICB9O1xuICBTdHJpbmdTdHJlYW0ucHJvdG90eXBlLmN1cnJlbnQgPSBmdW5jdGlvbiAoKXtyZXR1cm4gdGhpcy5zdHJpbmcuc2xpY2UodGhpcy5zdGFydCwgdGhpcy5wb3MpfTtcbiAgU3RyaW5nU3RyZWFtLnByb3RvdHlwZS5oaWRlRmlyc3RDaGFycyA9IGZ1bmN0aW9uIChuLCBpbm5lcikge1xuICAgIHRoaXMubGluZVN0YXJ0ICs9IG47XG4gICAgdHJ5IHsgcmV0dXJuIGlubmVyKCkgfVxuICAgIGZpbmFsbHkgeyB0aGlzLmxpbmVTdGFydCAtPSBuOyB9XG4gIH07XG4gIFN0cmluZ1N0cmVhbS5wcm90b3R5cGUubG9va0FoZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgICB2YXIgb3JhY2xlID0gdGhpcy5saW5lT3JhY2xlO1xuICAgIHJldHVybiBvcmFjbGUgJiYgb3JhY2xlLmxvb2tBaGVhZChuKVxuICB9O1xuICBTdHJpbmdTdHJlYW0ucHJvdG90eXBlLmJhc2VUb2tlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3JhY2xlID0gdGhpcy5saW5lT3JhY2xlO1xuICAgIHJldHVybiBvcmFjbGUgJiYgb3JhY2xlLmJhc2VUb2tlbih0aGlzLnBvcylcbiAgfTtcblxuICAvLyBGaW5kIHRoZSBsaW5lIG9iamVjdCBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlbiBsaW5lIG51bWJlci5cbiAgZnVuY3Rpb24gZ2V0TGluZShkb2MsIG4pIHtcbiAgICBuIC09IGRvYy5maXJzdDtcbiAgICBpZiAobiA8IDAgfHwgbiA+PSBkb2Muc2l6ZSkgeyB0aHJvdyBuZXcgRXJyb3IoXCJUaGVyZSBpcyBubyBsaW5lIFwiICsgKG4gKyBkb2MuZmlyc3QpICsgXCIgaW4gdGhlIGRvY3VtZW50LlwiKSB9XG4gICAgdmFyIGNodW5rID0gZG9jO1xuICAgIHdoaWxlICghY2h1bmsubGluZXMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOzsgKytpKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IGNodW5rLmNoaWxkcmVuW2ldLCBzeiA9IGNoaWxkLmNodW5rU2l6ZSgpO1xuICAgICAgICBpZiAobiA8IHN6KSB7IGNodW5rID0gY2hpbGQ7IGJyZWFrIH1cbiAgICAgICAgbiAtPSBzejtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNodW5rLmxpbmVzW25dXG4gIH1cblxuICAvLyBHZXQgdGhlIHBhcnQgb2YgYSBkb2N1bWVudCBiZXR3ZWVuIHR3byBwb3NpdGlvbnMsIGFzIGFuIGFycmF5IG9mXG4gIC8vIHN0cmluZ3MuXG4gIGZ1bmN0aW9uIGdldEJldHdlZW4oZG9jLCBzdGFydCwgZW5kKSB7XG4gICAgdmFyIG91dCA9IFtdLCBuID0gc3RhcnQubGluZTtcbiAgICBkb2MuaXRlcihzdGFydC5saW5lLCBlbmQubGluZSArIDEsIGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICB2YXIgdGV4dCA9IGxpbmUudGV4dDtcbiAgICAgIGlmIChuID09IGVuZC5saW5lKSB7IHRleHQgPSB0ZXh0LnNsaWNlKDAsIGVuZC5jaCk7IH1cbiAgICAgIGlmIChuID09IHN0YXJ0LmxpbmUpIHsgdGV4dCA9IHRleHQuc2xpY2Uoc3RhcnQuY2gpOyB9XG4gICAgICBvdXQucHVzaCh0ZXh0KTtcbiAgICAgICsrbjtcbiAgICB9KTtcbiAgICByZXR1cm4gb3V0XG4gIH1cbiAgLy8gR2V0IHRoZSBsaW5lcyBiZXR3ZWVuIGZyb20gYW5kIHRvLCBhcyBhcnJheSBvZiBzdHJpbmdzLlxuICBmdW5jdGlvbiBnZXRMaW5lcyhkb2MsIGZyb20sIHRvKSB7XG4gICAgdmFyIG91dCA9IFtdO1xuICAgIGRvYy5pdGVyKGZyb20sIHRvLCBmdW5jdGlvbiAobGluZSkgeyBvdXQucHVzaChsaW5lLnRleHQpOyB9KTsgLy8gaXRlciBhYm9ydHMgd2hlbiBjYWxsYmFjayByZXR1cm5zIHRydXRoeSB2YWx1ZVxuICAgIHJldHVybiBvdXRcbiAgfVxuXG4gIC8vIFVwZGF0ZSB0aGUgaGVpZ2h0IG9mIGEgbGluZSwgcHJvcGFnYXRpbmcgdGhlIGhlaWdodCBjaGFuZ2VcbiAgLy8gdXB3YXJkcyB0byBwYXJlbnQgbm9kZXMuXG4gIGZ1bmN0aW9uIHVwZGF0ZUxpbmVIZWlnaHQobGluZSwgaGVpZ2h0KSB7XG4gICAgdmFyIGRpZmYgPSBoZWlnaHQgLSBsaW5lLmhlaWdodDtcbiAgICBpZiAoZGlmZikgeyBmb3IgKHZhciBuID0gbGluZTsgbjsgbiA9IG4ucGFyZW50KSB7IG4uaGVpZ2h0ICs9IGRpZmY7IH0gfVxuICB9XG5cbiAgLy8gR2l2ZW4gYSBsaW5lIG9iamVjdCwgZmluZCBpdHMgbGluZSBudW1iZXIgYnkgd2Fsa2luZyB1cCB0aHJvdWdoXG4gIC8vIGl0cyBwYXJlbnQgbGlua3MuXG4gIGZ1bmN0aW9uIGxpbmVObyhsaW5lKSB7XG4gICAgaWYgKGxpbmUucGFyZW50ID09IG51bGwpIHsgcmV0dXJuIG51bGwgfVxuICAgIHZhciBjdXIgPSBsaW5lLnBhcmVudCwgbm8gPSBpbmRleE9mKGN1ci5saW5lcywgbGluZSk7XG4gICAgZm9yICh2YXIgY2h1bmsgPSBjdXIucGFyZW50OyBjaHVuazsgY3VyID0gY2h1bmssIGNodW5rID0gY2h1bmsucGFyZW50KSB7XG4gICAgICBmb3IgKHZhciBpID0gMDs7ICsraSkge1xuICAgICAgICBpZiAoY2h1bmsuY2hpbGRyZW5baV0gPT0gY3VyKSB7IGJyZWFrIH1cbiAgICAgICAgbm8gKz0gY2h1bmsuY2hpbGRyZW5baV0uY2h1bmtTaXplKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBubyArIGN1ci5maXJzdFxuICB9XG5cbiAgLy8gRmluZCB0aGUgbGluZSBhdCB0aGUgZ2l2ZW4gdmVydGljYWwgcG9zaXRpb24sIHVzaW5nIHRoZSBoZWlnaHRcbiAgLy8gaW5mb3JtYXRpb24gaW4gdGhlIGRvY3VtZW50IHRyZWUuXG4gIGZ1bmN0aW9uIGxpbmVBdEhlaWdodChjaHVuaywgaCkge1xuICAgIHZhciBuID0gY2h1bmsuZmlyc3Q7XG4gICAgb3V0ZXI6IGRvIHtcbiAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGNodW5rLmNoaWxkcmVuLmxlbmd0aDsgKytpJDEpIHtcbiAgICAgICAgdmFyIGNoaWxkID0gY2h1bmsuY2hpbGRyZW5baSQxXSwgY2ggPSBjaGlsZC5oZWlnaHQ7XG4gICAgICAgIGlmIChoIDwgY2gpIHsgY2h1bmsgPSBjaGlsZDsgY29udGludWUgb3V0ZXIgfVxuICAgICAgICBoIC09IGNoO1xuICAgICAgICBuICs9IGNoaWxkLmNodW5rU2l6ZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5cbiAgICB9IHdoaWxlICghY2h1bmsubGluZXMpXG4gICAgdmFyIGkgPSAwO1xuICAgIGZvciAoOyBpIDwgY2h1bmsubGluZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBsaW5lID0gY2h1bmsubGluZXNbaV0sIGxoID0gbGluZS5oZWlnaHQ7XG4gICAgICBpZiAoaCA8IGxoKSB7IGJyZWFrIH1cbiAgICAgIGggLT0gbGg7XG4gICAgfVxuICAgIHJldHVybiBuICsgaVxuICB9XG5cbiAgZnVuY3Rpb24gaXNMaW5lKGRvYywgbCkge3JldHVybiBsID49IGRvYy5maXJzdCAmJiBsIDwgZG9jLmZpcnN0ICsgZG9jLnNpemV9XG5cbiAgZnVuY3Rpb24gbGluZU51bWJlckZvcihvcHRpb25zLCBpKSB7XG4gICAgcmV0dXJuIFN0cmluZyhvcHRpb25zLmxpbmVOdW1iZXJGb3JtYXR0ZXIoaSArIG9wdGlvbnMuZmlyc3RMaW5lTnVtYmVyKSlcbiAgfVxuXG4gIC8vIEEgUG9zIGluc3RhbmNlIHJlcHJlc2VudHMgYSBwb3NpdGlvbiB3aXRoaW4gdGhlIHRleHQuXG4gIGZ1bmN0aW9uIFBvcyhsaW5lLCBjaCwgc3RpY2t5KSB7XG4gICAgaWYgKCBzdGlja3kgPT09IHZvaWQgMCApIHN0aWNreSA9IG51bGw7XG5cbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUG9zKSkgeyByZXR1cm4gbmV3IFBvcyhsaW5lLCBjaCwgc3RpY2t5KSB9XG4gICAgdGhpcy5saW5lID0gbGluZTtcbiAgICB0aGlzLmNoID0gY2g7XG4gICAgdGhpcy5zdGlja3kgPSBzdGlja3k7XG4gIH1cblxuICAvLyBDb21wYXJlIHR3byBwb3NpdGlvbnMsIHJldHVybiAwIGlmIHRoZXkgYXJlIHRoZSBzYW1lLCBhIG5lZ2F0aXZlXG4gIC8vIG51bWJlciB3aGVuIGEgaXMgbGVzcywgYW5kIGEgcG9zaXRpdmUgbnVtYmVyIG90aGVyd2lzZS5cbiAgZnVuY3Rpb24gY21wKGEsIGIpIHsgcmV0dXJuIGEubGluZSAtIGIubGluZSB8fCBhLmNoIC0gYi5jaCB9XG5cbiAgZnVuY3Rpb24gZXF1YWxDdXJzb3JQb3MoYSwgYikgeyByZXR1cm4gYS5zdGlja3kgPT0gYi5zdGlja3kgJiYgY21wKGEsIGIpID09IDAgfVxuXG4gIGZ1bmN0aW9uIGNvcHlQb3MoeCkge3JldHVybiBQb3MoeC5saW5lLCB4LmNoKX1cbiAgZnVuY3Rpb24gbWF4UG9zKGEsIGIpIHsgcmV0dXJuIGNtcChhLCBiKSA8IDAgPyBiIDogYSB9XG4gIGZ1bmN0aW9uIG1pblBvcyhhLCBiKSB7IHJldHVybiBjbXAoYSwgYikgPCAwID8gYSA6IGIgfVxuXG4gIC8vIE1vc3Qgb2YgdGhlIGV4dGVybmFsIEFQSSBjbGlwcyBnaXZlbiBwb3NpdGlvbnMgdG8gbWFrZSBzdXJlIHRoZXlcbiAgLy8gYWN0dWFsbHkgZXhpc3Qgd2l0aGluIHRoZSBkb2N1bWVudC5cbiAgZnVuY3Rpb24gY2xpcExpbmUoZG9jLCBuKSB7cmV0dXJuIE1hdGgubWF4KGRvYy5maXJzdCwgTWF0aC5taW4obiwgZG9jLmZpcnN0ICsgZG9jLnNpemUgLSAxKSl9XG4gIGZ1bmN0aW9uIGNsaXBQb3MoZG9jLCBwb3MpIHtcbiAgICBpZiAocG9zLmxpbmUgPCBkb2MuZmlyc3QpIHsgcmV0dXJuIFBvcyhkb2MuZmlyc3QsIDApIH1cbiAgICB2YXIgbGFzdCA9IGRvYy5maXJzdCArIGRvYy5zaXplIC0gMTtcbiAgICBpZiAocG9zLmxpbmUgPiBsYXN0KSB7IHJldHVybiBQb3MobGFzdCwgZ2V0TGluZShkb2MsIGxhc3QpLnRleHQubGVuZ3RoKSB9XG4gICAgcmV0dXJuIGNsaXBUb0xlbihwb3MsIGdldExpbmUoZG9jLCBwb3MubGluZSkudGV4dC5sZW5ndGgpXG4gIH1cbiAgZnVuY3Rpb24gY2xpcFRvTGVuKHBvcywgbGluZWxlbikge1xuICAgIHZhciBjaCA9IHBvcy5jaDtcbiAgICBpZiAoY2ggPT0gbnVsbCB8fCBjaCA+IGxpbmVsZW4pIHsgcmV0dXJuIFBvcyhwb3MubGluZSwgbGluZWxlbikgfVxuICAgIGVsc2UgaWYgKGNoIDwgMCkgeyByZXR1cm4gUG9zKHBvcy5saW5lLCAwKSB9XG4gICAgZWxzZSB7IHJldHVybiBwb3MgfVxuICB9XG4gIGZ1bmN0aW9uIGNsaXBQb3NBcnJheShkb2MsIGFycmF5KSB7XG4gICAgdmFyIG91dCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHsgb3V0W2ldID0gY2xpcFBvcyhkb2MsIGFycmF5W2ldKTsgfVxuICAgIHJldHVybiBvdXRcbiAgfVxuXG4gIHZhciBTYXZlZENvbnRleHQgPSBmdW5jdGlvbihzdGF0ZSwgbG9va0FoZWFkKSB7XG4gICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgIHRoaXMubG9va0FoZWFkID0gbG9va0FoZWFkO1xuICB9O1xuXG4gIHZhciBDb250ZXh0ID0gZnVuY3Rpb24oZG9jLCBzdGF0ZSwgbGluZSwgbG9va0FoZWFkKSB7XG4gICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgIHRoaXMuZG9jID0gZG9jO1xuICAgIHRoaXMubGluZSA9IGxpbmU7XG4gICAgdGhpcy5tYXhMb29rQWhlYWQgPSBsb29rQWhlYWQgfHwgMDtcbiAgICB0aGlzLmJhc2VUb2tlbnMgPSBudWxsO1xuICAgIHRoaXMuYmFzZVRva2VuUG9zID0gMTtcbiAgfTtcblxuICBDb250ZXh0LnByb3RvdHlwZS5sb29rQWhlYWQgPSBmdW5jdGlvbiAobikge1xuICAgIHZhciBsaW5lID0gdGhpcy5kb2MuZ2V0TGluZSh0aGlzLmxpbmUgKyBuKTtcbiAgICBpZiAobGluZSAhPSBudWxsICYmIG4gPiB0aGlzLm1heExvb2tBaGVhZCkgeyB0aGlzLm1heExvb2tBaGVhZCA9IG47IH1cbiAgICByZXR1cm4gbGluZVxuICB9O1xuXG4gIENvbnRleHQucHJvdG90eXBlLmJhc2VUb2tlbiA9IGZ1bmN0aW9uIChuKSB7XG4gICAgaWYgKCF0aGlzLmJhc2VUb2tlbnMpIHsgcmV0dXJuIG51bGwgfVxuICAgIHdoaWxlICh0aGlzLmJhc2VUb2tlbnNbdGhpcy5iYXNlVG9rZW5Qb3NdIDw9IG4pXG4gICAgICB7IHRoaXMuYmFzZVRva2VuUG9zICs9IDI7IH1cbiAgICB2YXIgdHlwZSA9IHRoaXMuYmFzZVRva2Vuc1t0aGlzLmJhc2VUb2tlblBvcyArIDFdO1xuICAgIHJldHVybiB7dHlwZTogdHlwZSAmJiB0eXBlLnJlcGxhY2UoLyggfF4pb3ZlcmxheSAuKi8sIFwiXCIpLFxuICAgICAgICAgICAgc2l6ZTogdGhpcy5iYXNlVG9rZW5zW3RoaXMuYmFzZVRva2VuUG9zXSAtIG59XG4gIH07XG5cbiAgQ29udGV4dC5wcm90b3R5cGUubmV4dExpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5saW5lKys7XG4gICAgaWYgKHRoaXMubWF4TG9va0FoZWFkID4gMCkgeyB0aGlzLm1heExvb2tBaGVhZC0tOyB9XG4gIH07XG5cbiAgQ29udGV4dC5mcm9tU2F2ZWQgPSBmdW5jdGlvbiAoZG9jLCBzYXZlZCwgbGluZSkge1xuICAgIGlmIChzYXZlZCBpbnN0YW5jZW9mIFNhdmVkQ29udGV4dClcbiAgICAgIHsgcmV0dXJuIG5ldyBDb250ZXh0KGRvYywgY29weVN0YXRlKGRvYy5tb2RlLCBzYXZlZC5zdGF0ZSksIGxpbmUsIHNhdmVkLmxvb2tBaGVhZCkgfVxuICAgIGVsc2VcbiAgICAgIHsgcmV0dXJuIG5ldyBDb250ZXh0KGRvYywgY29weVN0YXRlKGRvYy5tb2RlLCBzYXZlZCksIGxpbmUpIH1cbiAgfTtcblxuICBDb250ZXh0LnByb3RvdHlwZS5zYXZlID0gZnVuY3Rpb24gKGNvcHkpIHtcbiAgICB2YXIgc3RhdGUgPSBjb3B5ICE9PSBmYWxzZSA/IGNvcHlTdGF0ZSh0aGlzLmRvYy5tb2RlLCB0aGlzLnN0YXRlKSA6IHRoaXMuc3RhdGU7XG4gICAgcmV0dXJuIHRoaXMubWF4TG9va0FoZWFkID4gMCA/IG5ldyBTYXZlZENvbnRleHQoc3RhdGUsIHRoaXMubWF4TG9va0FoZWFkKSA6IHN0YXRlXG4gIH07XG5cblxuICAvLyBDb21wdXRlIGEgc3R5bGUgYXJyYXkgKGFuIGFycmF5IHN0YXJ0aW5nIHdpdGggYSBtb2RlIGdlbmVyYXRpb25cbiAgLy8gLS0gZm9yIGludmFsaWRhdGlvbiAtLSBmb2xsb3dlZCBieSBwYWlycyBvZiBlbmQgcG9zaXRpb25zIGFuZFxuICAvLyBzdHlsZSBzdHJpbmdzKSwgd2hpY2ggaXMgdXNlZCB0byBoaWdobGlnaHQgdGhlIHRva2VucyBvbiB0aGVcbiAgLy8gbGluZS5cbiAgZnVuY3Rpb24gaGlnaGxpZ2h0TGluZShjbSwgbGluZSwgY29udGV4dCwgZm9yY2VUb0VuZCkge1xuICAgIC8vIEEgc3R5bGVzIGFycmF5IGFsd2F5cyBzdGFydHMgd2l0aCBhIG51bWJlciBpZGVudGlmeWluZyB0aGVcbiAgICAvLyBtb2RlL292ZXJsYXlzIHRoYXQgaXQgaXMgYmFzZWQgb24gKGZvciBlYXN5IGludmFsaWRhdGlvbikuXG4gICAgdmFyIHN0ID0gW2NtLnN0YXRlLm1vZGVHZW5dLCBsaW5lQ2xhc3NlcyA9IHt9O1xuICAgIC8vIENvbXB1dGUgdGhlIGJhc2UgYXJyYXkgb2Ygc3R5bGVzXG4gICAgcnVuTW9kZShjbSwgbGluZS50ZXh0LCBjbS5kb2MubW9kZSwgY29udGV4dCwgZnVuY3Rpb24gKGVuZCwgc3R5bGUpIHsgcmV0dXJuIHN0LnB1c2goZW5kLCBzdHlsZSk7IH0sXG4gICAgICAgICAgICBsaW5lQ2xhc3NlcywgZm9yY2VUb0VuZCk7XG4gICAgdmFyIHN0YXRlID0gY29udGV4dC5zdGF0ZTtcblxuICAgIC8vIFJ1biBvdmVybGF5cywgYWRqdXN0IHN0eWxlIGFycmF5LlxuICAgIHZhciBsb29wID0gZnVuY3Rpb24gKCBvICkge1xuICAgICAgY29udGV4dC5iYXNlVG9rZW5zID0gc3Q7XG4gICAgICB2YXIgb3ZlcmxheSA9IGNtLnN0YXRlLm92ZXJsYXlzW29dLCBpID0gMSwgYXQgPSAwO1xuICAgICAgY29udGV4dC5zdGF0ZSA9IHRydWU7XG4gICAgICBydW5Nb2RlKGNtLCBsaW5lLnRleHQsIG92ZXJsYXkubW9kZSwgY29udGV4dCwgZnVuY3Rpb24gKGVuZCwgc3R5bGUpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gaTtcbiAgICAgICAgLy8gRW5zdXJlIHRoZXJlJ3MgYSB0b2tlbiBlbmQgYXQgdGhlIGN1cnJlbnQgcG9zaXRpb24sIGFuZCB0aGF0IGkgcG9pbnRzIGF0IGl0XG4gICAgICAgIHdoaWxlIChhdCA8IGVuZCkge1xuICAgICAgICAgIHZhciBpX2VuZCA9IHN0W2ldO1xuICAgICAgICAgIGlmIChpX2VuZCA+IGVuZClcbiAgICAgICAgICAgIHsgc3Quc3BsaWNlKGksIDEsIGVuZCwgc3RbaSsxXSwgaV9lbmQpOyB9XG4gICAgICAgICAgaSArPSAyO1xuICAgICAgICAgIGF0ID0gTWF0aC5taW4oZW5kLCBpX2VuZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzdHlsZSkgeyByZXR1cm4gfVxuICAgICAgICBpZiAob3ZlcmxheS5vcGFxdWUpIHtcbiAgICAgICAgICBzdC5zcGxpY2Uoc3RhcnQsIGkgLSBzdGFydCwgZW5kLCBcIm92ZXJsYXkgXCIgKyBzdHlsZSk7XG4gICAgICAgICAgaSA9IHN0YXJ0ICsgMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKDsgc3RhcnQgPCBpOyBzdGFydCArPSAyKSB7XG4gICAgICAgICAgICB2YXIgY3VyID0gc3Rbc3RhcnQrMV07XG4gICAgICAgICAgICBzdFtzdGFydCsxXSA9IChjdXIgPyBjdXIgKyBcIiBcIiA6IFwiXCIpICsgXCJvdmVybGF5IFwiICsgc3R5bGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCBsaW5lQ2xhc3Nlcyk7XG4gICAgICBjb250ZXh0LnN0YXRlID0gc3RhdGU7XG4gICAgICBjb250ZXh0LmJhc2VUb2tlbnMgPSBudWxsO1xuICAgICAgY29udGV4dC5iYXNlVG9rZW5Qb3MgPSAxO1xuICAgIH07XG5cbiAgICBmb3IgKHZhciBvID0gMDsgbyA8IGNtLnN0YXRlLm92ZXJsYXlzLmxlbmd0aDsgKytvKSBsb29wKCBvICk7XG5cbiAgICByZXR1cm4ge3N0eWxlczogc3QsIGNsYXNzZXM6IGxpbmVDbGFzc2VzLmJnQ2xhc3MgfHwgbGluZUNsYXNzZXMudGV4dENsYXNzID8gbGluZUNsYXNzZXMgOiBudWxsfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0TGluZVN0eWxlcyhjbSwgbGluZSwgdXBkYXRlRnJvbnRpZXIpIHtcbiAgICBpZiAoIWxpbmUuc3R5bGVzIHx8IGxpbmUuc3R5bGVzWzBdICE9IGNtLnN0YXRlLm1vZGVHZW4pIHtcbiAgICAgIHZhciBjb250ZXh0ID0gZ2V0Q29udGV4dEJlZm9yZShjbSwgbGluZU5vKGxpbmUpKTtcbiAgICAgIHZhciByZXNldFN0YXRlID0gbGluZS50ZXh0Lmxlbmd0aCA+IGNtLm9wdGlvbnMubWF4SGlnaGxpZ2h0TGVuZ3RoICYmIGNvcHlTdGF0ZShjbS5kb2MubW9kZSwgY29udGV4dC5zdGF0ZSk7XG4gICAgICB2YXIgcmVzdWx0ID0gaGlnaGxpZ2h0TGluZShjbSwgbGluZSwgY29udGV4dCk7XG4gICAgICBpZiAocmVzZXRTdGF0ZSkgeyBjb250ZXh0LnN0YXRlID0gcmVzZXRTdGF0ZTsgfVxuICAgICAgbGluZS5zdGF0ZUFmdGVyID0gY29udGV4dC5zYXZlKCFyZXNldFN0YXRlKTtcbiAgICAgIGxpbmUuc3R5bGVzID0gcmVzdWx0LnN0eWxlcztcbiAgICAgIGlmIChyZXN1bHQuY2xhc3NlcykgeyBsaW5lLnN0eWxlQ2xhc3NlcyA9IHJlc3VsdC5jbGFzc2VzOyB9XG4gICAgICBlbHNlIGlmIChsaW5lLnN0eWxlQ2xhc3NlcykgeyBsaW5lLnN0eWxlQ2xhc3NlcyA9IG51bGw7IH1cbiAgICAgIGlmICh1cGRhdGVGcm9udGllciA9PT0gY20uZG9jLmhpZ2hsaWdodEZyb250aWVyKVxuICAgICAgICB7IGNtLmRvYy5tb2RlRnJvbnRpZXIgPSBNYXRoLm1heChjbS5kb2MubW9kZUZyb250aWVyLCArK2NtLmRvYy5oaWdobGlnaHRGcm9udGllcik7IH1cbiAgICB9XG4gICAgcmV0dXJuIGxpbmUuc3R5bGVzXG4gIH1cblxuICBmdW5jdGlvbiBnZXRDb250ZXh0QmVmb3JlKGNtLCBuLCBwcmVjaXNlKSB7XG4gICAgdmFyIGRvYyA9IGNtLmRvYywgZGlzcGxheSA9IGNtLmRpc3BsYXk7XG4gICAgaWYgKCFkb2MubW9kZS5zdGFydFN0YXRlKSB7IHJldHVybiBuZXcgQ29udGV4dChkb2MsIHRydWUsIG4pIH1cbiAgICB2YXIgc3RhcnQgPSBmaW5kU3RhcnRMaW5lKGNtLCBuLCBwcmVjaXNlKTtcbiAgICB2YXIgc2F2ZWQgPSBzdGFydCA+IGRvYy5maXJzdCAmJiBnZXRMaW5lKGRvYywgc3RhcnQgLSAxKS5zdGF0ZUFmdGVyO1xuICAgIHZhciBjb250ZXh0ID0gc2F2ZWQgPyBDb250ZXh0LmZyb21TYXZlZChkb2MsIHNhdmVkLCBzdGFydCkgOiBuZXcgQ29udGV4dChkb2MsIHN0YXJ0U3RhdGUoZG9jLm1vZGUpLCBzdGFydCk7XG5cbiAgICBkb2MuaXRlcihzdGFydCwgbiwgZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgIHByb2Nlc3NMaW5lKGNtLCBsaW5lLnRleHQsIGNvbnRleHQpO1xuICAgICAgdmFyIHBvcyA9IGNvbnRleHQubGluZTtcbiAgICAgIGxpbmUuc3RhdGVBZnRlciA9IHBvcyA9PSBuIC0gMSB8fCBwb3MgJSA1ID09IDAgfHwgcG9zID49IGRpc3BsYXkudmlld0Zyb20gJiYgcG9zIDwgZGlzcGxheS52aWV3VG8gPyBjb250ZXh0LnNhdmUoKSA6IG51bGw7XG4gICAgICBjb250ZXh0Lm5leHRMaW5lKCk7XG4gICAgfSk7XG4gICAgaWYgKHByZWNpc2UpIHsgZG9jLm1vZGVGcm9udGllciA9IGNvbnRleHQubGluZTsgfVxuICAgIHJldHVybiBjb250ZXh0XG4gIH1cblxuICAvLyBMaWdodHdlaWdodCBmb3JtIG9mIGhpZ2hsaWdodCAtLSBwcm9jZWVkIG92ZXIgdGhpcyBsaW5lIGFuZFxuICAvLyB1cGRhdGUgc3RhdGUsIGJ1dCBkb24ndCBzYXZlIGEgc3R5bGUgYXJyYXkuIFVzZWQgZm9yIGxpbmVzIHRoYXRcbiAgLy8gYXJlbid0IGN1cnJlbnRseSB2aXNpYmxlLlxuICBmdW5jdGlvbiBwcm9jZXNzTGluZShjbSwgdGV4dCwgY29udGV4dCwgc3RhcnRBdCkge1xuICAgIHZhciBtb2RlID0gY20uZG9jLm1vZGU7XG4gICAgdmFyIHN0cmVhbSA9IG5ldyBTdHJpbmdTdHJlYW0odGV4dCwgY20ub3B0aW9ucy50YWJTaXplLCBjb250ZXh0KTtcbiAgICBzdHJlYW0uc3RhcnQgPSBzdHJlYW0ucG9zID0gc3RhcnRBdCB8fCAwO1xuICAgIGlmICh0ZXh0ID09IFwiXCIpIHsgY2FsbEJsYW5rTGluZShtb2RlLCBjb250ZXh0LnN0YXRlKTsgfVxuICAgIHdoaWxlICghc3RyZWFtLmVvbCgpKSB7XG4gICAgICByZWFkVG9rZW4obW9kZSwgc3RyZWFtLCBjb250ZXh0LnN0YXRlKTtcbiAgICAgIHN0cmVhbS5zdGFydCA9IHN0cmVhbS5wb3M7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2FsbEJsYW5rTGluZShtb2RlLCBzdGF0ZSkge1xuICAgIGlmIChtb2RlLmJsYW5rTGluZSkgeyByZXR1cm4gbW9kZS5ibGFua0xpbmUoc3RhdGUpIH1cbiAgICBpZiAoIW1vZGUuaW5uZXJNb2RlKSB7IHJldHVybiB9XG4gICAgdmFyIGlubmVyID0gaW5uZXJNb2RlKG1vZGUsIHN0YXRlKTtcbiAgICBpZiAoaW5uZXIubW9kZS5ibGFua0xpbmUpIHsgcmV0dXJuIGlubmVyLm1vZGUuYmxhbmtMaW5lKGlubmVyLnN0YXRlKSB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkVG9rZW4obW9kZSwgc3RyZWFtLCBzdGF0ZSwgaW5uZXIpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDEwOyBpKyspIHtcbiAgICAgIGlmIChpbm5lcikgeyBpbm5lclswXSA9IGlubmVyTW9kZShtb2RlLCBzdGF0ZSkubW9kZTsgfVxuICAgICAgdmFyIHN0eWxlID0gbW9kZS50b2tlbihzdHJlYW0sIHN0YXRlKTtcbiAgICAgIGlmIChzdHJlYW0ucG9zID4gc3RyZWFtLnN0YXJ0KSB7IHJldHVybiBzdHlsZSB9XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIk1vZGUgXCIgKyBtb2RlLm5hbWUgKyBcIiBmYWlsZWQgdG8gYWR2YW5jZSBzdHJlYW0uXCIpXG4gIH1cblxuICB2YXIgVG9rZW4gPSBmdW5jdGlvbihzdHJlYW0sIHR5cGUsIHN0YXRlKSB7XG4gICAgdGhpcy5zdGFydCA9IHN0cmVhbS5zdGFydDsgdGhpcy5lbmQgPSBzdHJlYW0ucG9zO1xuICAgIHRoaXMuc3RyaW5nID0gc3RyZWFtLmN1cnJlbnQoKTtcbiAgICB0aGlzLnR5cGUgPSB0eXBlIHx8IG51bGw7XG4gICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICB9O1xuXG4gIC8vIFV0aWxpdHkgZm9yIGdldFRva2VuQXQgYW5kIGdldExpbmVUb2tlbnNcbiAgZnVuY3Rpb24gdGFrZVRva2VuKGNtLCBwb3MsIHByZWNpc2UsIGFzQXJyYXkpIHtcbiAgICB2YXIgZG9jID0gY20uZG9jLCBtb2RlID0gZG9jLm1vZGUsIHN0eWxlO1xuICAgIHBvcyA9IGNsaXBQb3MoZG9jLCBwb3MpO1xuICAgIHZhciBsaW5lID0gZ2V0TGluZShkb2MsIHBvcy5saW5lKSwgY29udGV4dCA9IGdldENvbnRleHRCZWZvcmUoY20sIHBvcy5saW5lLCBwcmVjaXNlKTtcbiAgICB2YXIgc3RyZWFtID0gbmV3IFN0cmluZ1N0cmVhbShsaW5lLnRleHQsIGNtLm9wdGlvbnMudGFiU2l6ZSwgY29udGV4dCksIHRva2VucztcbiAgICBpZiAoYXNBcnJheSkgeyB0b2tlbnMgPSBbXTsgfVxuICAgIHdoaWxlICgoYXNBcnJheSB8fCBzdHJlYW0ucG9zIDwgcG9zLmNoKSAmJiAhc3RyZWFtLmVvbCgpKSB7XG4gICAgICBzdHJlYW0uc3RhcnQgPSBzdHJlYW0ucG9zO1xuICAgICAgc3R5bGUgPSByZWFkVG9rZW4obW9kZSwgc3RyZWFtLCBjb250ZXh0LnN0YXRlKTtcbiAgICAgIGlmIChhc0FycmF5KSB7IHRva2Vucy5wdXNoKG5ldyBUb2tlbihzdHJlYW0sIHN0eWxlLCBjb3B5U3RhdGUoZG9jLm1vZGUsIGNvbnRleHQuc3RhdGUpKSk7IH1cbiAgICB9XG4gICAgcmV0dXJuIGFzQXJyYXkgPyB0b2tlbnMgOiBuZXcgVG9rZW4oc3RyZWFtLCBzdHlsZSwgY29udGV4dC5zdGF0ZSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGV4dHJhY3RMaW5lQ2xhc3Nlcyh0eXBlLCBvdXRwdXQpIHtcbiAgICBpZiAodHlwZSkgeyBmb3IgKDs7KSB7XG4gICAgICB2YXIgbGluZUNsYXNzID0gdHlwZS5tYXRjaCgvKD86XnxcXHMrKWxpbmUtKGJhY2tncm91bmQtKT8oXFxTKykvKTtcbiAgICAgIGlmICghbGluZUNsYXNzKSB7IGJyZWFrIH1cbiAgICAgIHR5cGUgPSB0eXBlLnNsaWNlKDAsIGxpbmVDbGFzcy5pbmRleCkgKyB0eXBlLnNsaWNlKGxpbmVDbGFzcy5pbmRleCArIGxpbmVDbGFzc1swXS5sZW5ndGgpO1xuICAgICAgdmFyIHByb3AgPSBsaW5lQ2xhc3NbMV0gPyBcImJnQ2xhc3NcIiA6IFwidGV4dENsYXNzXCI7XG4gICAgICBpZiAob3V0cHV0W3Byb3BdID09IG51bGwpXG4gICAgICAgIHsgb3V0cHV0W3Byb3BdID0gbGluZUNsYXNzWzJdOyB9XG4gICAgICBlbHNlIGlmICghKG5ldyBSZWdFeHAoXCIoPzpefFxcXFxzKVwiICsgbGluZUNsYXNzWzJdICsgXCIoPzokfFxcXFxzKVwiKSkudGVzdChvdXRwdXRbcHJvcF0pKVxuICAgICAgICB7IG91dHB1dFtwcm9wXSArPSBcIiBcIiArIGxpbmVDbGFzc1syXTsgfVxuICAgIH0gfVxuICAgIHJldHVybiB0eXBlXG4gIH1cblxuICAvLyBSdW4gdGhlIGdpdmVuIG1vZGUncyBwYXJzZXIgb3ZlciBhIGxpbmUsIGNhbGxpbmcgZiBmb3IgZWFjaCB0b2tlbi5cbiAgZnVuY3Rpb24gcnVuTW9kZShjbSwgdGV4dCwgbW9kZSwgY29udGV4dCwgZiwgbGluZUNsYXNzZXMsIGZvcmNlVG9FbmQpIHtcbiAgICB2YXIgZmxhdHRlblNwYW5zID0gbW9kZS5mbGF0dGVuU3BhbnM7XG4gICAgaWYgKGZsYXR0ZW5TcGFucyA9PSBudWxsKSB7IGZsYXR0ZW5TcGFucyA9IGNtLm9wdGlvbnMuZmxhdHRlblNwYW5zOyB9XG4gICAgdmFyIGN1clN0YXJ0ID0gMCwgY3VyU3R5bGUgPSBudWxsO1xuICAgIHZhciBzdHJlYW0gPSBuZXcgU3RyaW5nU3RyZWFtKHRleHQsIGNtLm9wdGlvbnMudGFiU2l6ZSwgY29udGV4dCksIHN0eWxlO1xuICAgIHZhciBpbm5lciA9IGNtLm9wdGlvbnMuYWRkTW9kZUNsYXNzICYmIFtudWxsXTtcbiAgICBpZiAodGV4dCA9PSBcIlwiKSB7IGV4dHJhY3RMaW5lQ2xhc3NlcyhjYWxsQmxhbmtMaW5lKG1vZGUsIGNvbnRleHQuc3RhdGUpLCBsaW5lQ2xhc3Nlcyk7IH1cbiAgICB3aGlsZSAoIXN0cmVhbS5lb2woKSkge1xuICAgICAgaWYgKHN0cmVhbS5wb3MgPiBjbS5vcHRpb25zLm1heEhpZ2hsaWdodExlbmd0aCkge1xuICAgICAgICBmbGF0dGVuU3BhbnMgPSBmYWxzZTtcbiAgICAgICAgaWYgKGZvcmNlVG9FbmQpIHsgcHJvY2Vzc0xpbmUoY20sIHRleHQsIGNvbnRleHQsIHN0cmVhbS5wb3MpOyB9XG4gICAgICAgIHN0cmVhbS5wb3MgPSB0ZXh0Lmxlbmd0aDtcbiAgICAgICAgc3R5bGUgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3R5bGUgPSBleHRyYWN0TGluZUNsYXNzZXMocmVhZFRva2VuKG1vZGUsIHN0cmVhbSwgY29udGV4dC5zdGF0ZSwgaW5uZXIpLCBsaW5lQ2xhc3Nlcyk7XG4gICAgICB9XG4gICAgICBpZiAoaW5uZXIpIHtcbiAgICAgICAgdmFyIG1OYW1lID0gaW5uZXJbMF0ubmFtZTtcbiAgICAgICAgaWYgKG1OYW1lKSB7IHN0eWxlID0gXCJtLVwiICsgKHN0eWxlID8gbU5hbWUgKyBcIiBcIiArIHN0eWxlIDogbU5hbWUpOyB9XG4gICAgICB9XG4gICAgICBpZiAoIWZsYXR0ZW5TcGFucyB8fCBjdXJTdHlsZSAhPSBzdHlsZSkge1xuICAgICAgICB3aGlsZSAoY3VyU3RhcnQgPCBzdHJlYW0uc3RhcnQpIHtcbiAgICAgICAgICBjdXJTdGFydCA9IE1hdGgubWluKHN0cmVhbS5zdGFydCwgY3VyU3RhcnQgKyA1MDAwKTtcbiAgICAgICAgICBmKGN1clN0YXJ0LCBjdXJTdHlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgY3VyU3R5bGUgPSBzdHlsZTtcbiAgICAgIH1cbiAgICAgIHN0cmVhbS5zdGFydCA9IHN0cmVhbS5wb3M7XG4gICAgfVxuICAgIHdoaWxlIChjdXJTdGFydCA8IHN0cmVhbS5wb3MpIHtcbiAgICAgIC8vIFdlYmtpdCBzZWVtcyB0byByZWZ1c2UgdG8gcmVuZGVyIHRleHQgbm9kZXMgbG9uZ2VyIHRoYW4gNTc0NDRcbiAgICAgIC8vIGNoYXJhY3RlcnMsIGFuZCByZXR1cm5zIGluYWNjdXJhdGUgbWVhc3VyZW1lbnRzIGluIG5vZGVzXG4gICAgICAvLyBzdGFydGluZyBhcm91bmQgNTAwMCBjaGFycy5cbiAgICAgIHZhciBwb3MgPSBNYXRoLm1pbihzdHJlYW0ucG9zLCBjdXJTdGFydCArIDUwMDApO1xuICAgICAgZihwb3MsIGN1clN0eWxlKTtcbiAgICAgIGN1clN0YXJ0ID0gcG9zO1xuICAgIH1cbiAgfVxuXG4gIC8vIEZpbmRzIHRoZSBsaW5lIHRvIHN0YXJ0IHdpdGggd2hlbiBzdGFydGluZyBhIHBhcnNlLiBUcmllcyB0b1xuICAvLyBmaW5kIGEgbGluZSB3aXRoIGEgc3RhdGVBZnRlciwgc28gdGhhdCBpdCBjYW4gc3RhcnQgd2l0aCBhXG4gIC8vIHZhbGlkIHN0YXRlLiBJZiB0aGF0IGZhaWxzLCBpdCByZXR1cm5zIHRoZSBsaW5lIHdpdGggdGhlXG4gIC8vIHNtYWxsZXN0IGluZGVudGF0aW9uLCB3aGljaCB0ZW5kcyB0byBuZWVkIHRoZSBsZWFzdCBjb250ZXh0IHRvXG4gIC8vIHBhcnNlIGNvcnJlY3RseS5cbiAgZnVuY3Rpb24gZmluZFN0YXJ0TGluZShjbSwgbiwgcHJlY2lzZSkge1xuICAgIHZhciBtaW5pbmRlbnQsIG1pbmxpbmUsIGRvYyA9IGNtLmRvYztcbiAgICB2YXIgbGltID0gcHJlY2lzZSA/IC0xIDogbiAtIChjbS5kb2MubW9kZS5pbm5lck1vZGUgPyAxMDAwIDogMTAwKTtcbiAgICBmb3IgKHZhciBzZWFyY2ggPSBuOyBzZWFyY2ggPiBsaW07IC0tc2VhcmNoKSB7XG4gICAgICBpZiAoc2VhcmNoIDw9IGRvYy5maXJzdCkgeyByZXR1cm4gZG9jLmZpcnN0IH1cbiAgICAgIHZhciBsaW5lID0gZ2V0TGluZShkb2MsIHNlYXJjaCAtIDEpLCBhZnRlciA9IGxpbmUuc3RhdGVBZnRlcjtcbiAgICAgIGlmIChhZnRlciAmJiAoIXByZWNpc2UgfHwgc2VhcmNoICsgKGFmdGVyIGluc3RhbmNlb2YgU2F2ZWRDb250ZXh0ID8gYWZ0ZXIubG9va0FoZWFkIDogMCkgPD0gZG9jLm1vZGVGcm9udGllcikpXG4gICAgICAgIHsgcmV0dXJuIHNlYXJjaCB9XG4gICAgICB2YXIgaW5kZW50ZWQgPSBjb3VudENvbHVtbihsaW5lLnRleHQsIG51bGwsIGNtLm9wdGlvbnMudGFiU2l6ZSk7XG4gICAgICBpZiAobWlubGluZSA9PSBudWxsIHx8IG1pbmluZGVudCA+IGluZGVudGVkKSB7XG4gICAgICAgIG1pbmxpbmUgPSBzZWFyY2ggLSAxO1xuICAgICAgICBtaW5pbmRlbnQgPSBpbmRlbnRlZDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1pbmxpbmVcbiAgfVxuXG4gIGZ1bmN0aW9uIHJldHJlYXRGcm9udGllcihkb2MsIG4pIHtcbiAgICBkb2MubW9kZUZyb250aWVyID0gTWF0aC5taW4oZG9jLm1vZGVGcm9udGllciwgbik7XG4gICAgaWYgKGRvYy5oaWdobGlnaHRGcm9udGllciA8IG4gLSAxMCkgeyByZXR1cm4gfVxuICAgIHZhciBzdGFydCA9IGRvYy5maXJzdDtcbiAgICBmb3IgKHZhciBsaW5lID0gbiAtIDE7IGxpbmUgPiBzdGFydDsgbGluZS0tKSB7XG4gICAgICB2YXIgc2F2ZWQgPSBnZXRMaW5lKGRvYywgbGluZSkuc3RhdGVBZnRlcjtcbiAgICAgIC8vIGNoYW5nZSBpcyBvbiAzXG4gICAgICAvLyBzdGF0ZSBvbiBsaW5lIDEgbG9va2VkIGFoZWFkIDIgLS0gc28gc2F3IDNcbiAgICAgIC8vIHRlc3QgMSArIDIgPCAzIHNob3VsZCBjb3ZlciB0aGlzXG4gICAgICBpZiAoc2F2ZWQgJiYgKCEoc2F2ZWQgaW5zdGFuY2VvZiBTYXZlZENvbnRleHQpIHx8IGxpbmUgKyBzYXZlZC5sb29rQWhlYWQgPCBuKSkge1xuICAgICAgICBzdGFydCA9IGxpbmUgKyAxO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgICBkb2MuaGlnaGxpZ2h0RnJvbnRpZXIgPSBNYXRoLm1pbihkb2MuaGlnaGxpZ2h0RnJvbnRpZXIsIHN0YXJ0KTtcbiAgfVxuXG4gIC8vIE9wdGltaXplIHNvbWUgY29kZSB3aGVuIHRoZXNlIGZlYXR1cmVzIGFyZSBub3QgdXNlZC5cbiAgdmFyIHNhd1JlYWRPbmx5U3BhbnMgPSBmYWxzZSwgc2F3Q29sbGFwc2VkU3BhbnMgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBzZWVSZWFkT25seVNwYW5zKCkge1xuICAgIHNhd1JlYWRPbmx5U3BhbnMgPSB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gc2VlQ29sbGFwc2VkU3BhbnMoKSB7XG4gICAgc2F3Q29sbGFwc2VkU3BhbnMgPSB0cnVlO1xuICB9XG5cbiAgLy8gVEVYVE1BUktFUiBTUEFOU1xuXG4gIGZ1bmN0aW9uIE1hcmtlZFNwYW4obWFya2VyLCBmcm9tLCB0bykge1xuICAgIHRoaXMubWFya2VyID0gbWFya2VyO1xuICAgIHRoaXMuZnJvbSA9IGZyb207IHRoaXMudG8gPSB0bztcbiAgfVxuXG4gIC8vIFNlYXJjaCBhbiBhcnJheSBvZiBzcGFucyBmb3IgYSBzcGFuIG1hdGNoaW5nIHRoZSBnaXZlbiBtYXJrZXIuXG4gIGZ1bmN0aW9uIGdldE1hcmtlZFNwYW5Gb3Ioc3BhbnMsIG1hcmtlcikge1xuICAgIGlmIChzcGFucykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHNwYW5zLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgc3BhbiA9IHNwYW5zW2ldO1xuICAgICAgaWYgKHNwYW4ubWFya2VyID09IG1hcmtlcikgeyByZXR1cm4gc3BhbiB9XG4gICAgfSB9XG4gIH1cbiAgLy8gUmVtb3ZlIGEgc3BhbiBmcm9tIGFuIGFycmF5LCByZXR1cm5pbmcgdW5kZWZpbmVkIGlmIG5vIHNwYW5zIGFyZVxuICAvLyBsZWZ0ICh3ZSBkb24ndCBzdG9yZSBhcnJheXMgZm9yIGxpbmVzIHdpdGhvdXQgc3BhbnMpLlxuICBmdW5jdGlvbiByZW1vdmVNYXJrZWRTcGFuKHNwYW5zLCBzcGFuKSB7XG4gICAgdmFyIHI7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzcGFucy5sZW5ndGg7ICsraSlcbiAgICAgIHsgaWYgKHNwYW5zW2ldICE9IHNwYW4pIHsgKHIgfHwgKHIgPSBbXSkpLnB1c2goc3BhbnNbaV0pOyB9IH1cbiAgICByZXR1cm4gclxuICB9XG4gIC8vIEFkZCBhIHNwYW4gdG8gYSBsaW5lLlxuICBmdW5jdGlvbiBhZGRNYXJrZWRTcGFuKGxpbmUsIHNwYW4pIHtcbiAgICBsaW5lLm1hcmtlZFNwYW5zID0gbGluZS5tYXJrZWRTcGFucyA/IGxpbmUubWFya2VkU3BhbnMuY29uY2F0KFtzcGFuXSkgOiBbc3Bhbl07XG4gICAgc3Bhbi5tYXJrZXIuYXR0YWNoTGluZShsaW5lKTtcbiAgfVxuXG4gIC8vIFVzZWQgZm9yIHRoZSBhbGdvcml0aG0gdGhhdCBhZGp1c3RzIG1hcmtlcnMgZm9yIGEgY2hhbmdlIGluIHRoZVxuICAvLyBkb2N1bWVudC4gVGhlc2UgZnVuY3Rpb25zIGN1dCBhbiBhcnJheSBvZiBzcGFucyBhdCBhIGdpdmVuXG4gIC8vIGNoYXJhY3RlciBwb3NpdGlvbiwgcmV0dXJuaW5nIGFuIGFycmF5IG9mIHJlbWFpbmluZyBjaHVua3MgKG9yXG4gIC8vIHVuZGVmaW5lZCBpZiBub3RoaW5nIHJlbWFpbnMpLlxuICBmdW5jdGlvbiBtYXJrZWRTcGFuc0JlZm9yZShvbGQsIHN0YXJ0Q2gsIGlzSW5zZXJ0KSB7XG4gICAgdmFyIG53O1xuICAgIGlmIChvbGQpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBvbGQubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBzcGFuID0gb2xkW2ldLCBtYXJrZXIgPSBzcGFuLm1hcmtlcjtcbiAgICAgIHZhciBzdGFydHNCZWZvcmUgPSBzcGFuLmZyb20gPT0gbnVsbCB8fCAobWFya2VyLmluY2x1c2l2ZUxlZnQgPyBzcGFuLmZyb20gPD0gc3RhcnRDaCA6IHNwYW4uZnJvbSA8IHN0YXJ0Q2gpO1xuICAgICAgaWYgKHN0YXJ0c0JlZm9yZSB8fCBzcGFuLmZyb20gPT0gc3RhcnRDaCAmJiBtYXJrZXIudHlwZSA9PSBcImJvb2ttYXJrXCIgJiYgKCFpc0luc2VydCB8fCAhc3Bhbi5tYXJrZXIuaW5zZXJ0TGVmdCkpIHtcbiAgICAgICAgdmFyIGVuZHNBZnRlciA9IHNwYW4udG8gPT0gbnVsbCB8fCAobWFya2VyLmluY2x1c2l2ZVJpZ2h0ID8gc3Bhbi50byA+PSBzdGFydENoIDogc3Bhbi50byA+IHN0YXJ0Q2gpXG4gICAgICAgIDsobncgfHwgKG53ID0gW10pKS5wdXNoKG5ldyBNYXJrZWRTcGFuKG1hcmtlciwgc3Bhbi5mcm9tLCBlbmRzQWZ0ZXIgPyBudWxsIDogc3Bhbi50bykpO1xuICAgICAgfVxuICAgIH0gfVxuICAgIHJldHVybiBud1xuICB9XG4gIGZ1bmN0aW9uIG1hcmtlZFNwYW5zQWZ0ZXIob2xkLCBlbmRDaCwgaXNJbnNlcnQpIHtcbiAgICB2YXIgbnc7XG4gICAgaWYgKG9sZCkgeyBmb3IgKHZhciBpID0gMDsgaSA8IG9sZC5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIHNwYW4gPSBvbGRbaV0sIG1hcmtlciA9IHNwYW4ubWFya2VyO1xuICAgICAgdmFyIGVuZHNBZnRlciA9IHNwYW4udG8gPT0gbnVsbCB8fCAobWFya2VyLmluY2x1c2l2ZVJpZ2h0ID8gc3Bhbi50byA+PSBlbmRDaCA6IHNwYW4udG8gPiBlbmRDaCk7XG4gICAgICBpZiAoZW5kc0FmdGVyIHx8IHNwYW4uZnJvbSA9PSBlbmRDaCAmJiBtYXJrZXIudHlwZSA9PSBcImJvb2ttYXJrXCIgJiYgKCFpc0luc2VydCB8fCBzcGFuLm1hcmtlci5pbnNlcnRMZWZ0KSkge1xuICAgICAgICB2YXIgc3RhcnRzQmVmb3JlID0gc3Bhbi5mcm9tID09IG51bGwgfHwgKG1hcmtlci5pbmNsdXNpdmVMZWZ0ID8gc3Bhbi5mcm9tIDw9IGVuZENoIDogc3Bhbi5mcm9tIDwgZW5kQ2gpXG4gICAgICAgIDsobncgfHwgKG53ID0gW10pKS5wdXNoKG5ldyBNYXJrZWRTcGFuKG1hcmtlciwgc3RhcnRzQmVmb3JlID8gbnVsbCA6IHNwYW4uZnJvbSAtIGVuZENoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwYW4udG8gPT0gbnVsbCA/IG51bGwgOiBzcGFuLnRvIC0gZW5kQ2gpKTtcbiAgICAgIH1cbiAgICB9IH1cbiAgICByZXR1cm4gbndcbiAgfVxuXG4gIC8vIEdpdmVuIGEgY2hhbmdlIG9iamVjdCwgY29tcHV0ZSB0aGUgbmV3IHNldCBvZiBtYXJrZXIgc3BhbnMgdGhhdFxuICAvLyBjb3ZlciB0aGUgbGluZSBpbiB3aGljaCB0aGUgY2hhbmdlIHRvb2sgcGxhY2UuIFJlbW92ZXMgc3BhbnNcbiAgLy8gZW50aXJlbHkgd2l0aGluIHRoZSBjaGFuZ2UsIHJlY29ubmVjdHMgc3BhbnMgYmVsb25naW5nIHRvIHRoZVxuICAvLyBzYW1lIG1hcmtlciB0aGF0IGFwcGVhciBvbiBib3RoIHNpZGVzIG9mIHRoZSBjaGFuZ2UsIGFuZCBjdXRzIG9mZlxuICAvLyBzcGFucyBwYXJ0aWFsbHkgd2l0aGluIHRoZSBjaGFuZ2UuIFJldHVybnMgYW4gYXJyYXkgb2Ygc3BhblxuICAvLyBhcnJheXMgd2l0aCBvbmUgZWxlbWVudCBmb3IgZWFjaCBsaW5lIGluIChhZnRlcikgdGhlIGNoYW5nZS5cbiAgZnVuY3Rpb24gc3RyZXRjaFNwYW5zT3ZlckNoYW5nZShkb2MsIGNoYW5nZSkge1xuICAgIGlmIChjaGFuZ2UuZnVsbCkgeyByZXR1cm4gbnVsbCB9XG4gICAgdmFyIG9sZEZpcnN0ID0gaXNMaW5lKGRvYywgY2hhbmdlLmZyb20ubGluZSkgJiYgZ2V0TGluZShkb2MsIGNoYW5nZS5mcm9tLmxpbmUpLm1hcmtlZFNwYW5zO1xuICAgIHZhciBvbGRMYXN0ID0gaXNMaW5lKGRvYywgY2hhbmdlLnRvLmxpbmUpICYmIGdldExpbmUoZG9jLCBjaGFuZ2UudG8ubGluZSkubWFya2VkU3BhbnM7XG4gICAgaWYgKCFvbGRGaXJzdCAmJiAhb2xkTGFzdCkgeyByZXR1cm4gbnVsbCB9XG5cbiAgICB2YXIgc3RhcnRDaCA9IGNoYW5nZS5mcm9tLmNoLCBlbmRDaCA9IGNoYW5nZS50by5jaCwgaXNJbnNlcnQgPSBjbXAoY2hhbmdlLmZyb20sIGNoYW5nZS50bykgPT0gMDtcbiAgICAvLyBHZXQgdGhlIHNwYW5zIHRoYXQgJ3N0aWNrIG91dCcgb24gYm90aCBzaWRlc1xuICAgIHZhciBmaXJzdCA9IG1hcmtlZFNwYW5zQmVmb3JlKG9sZEZpcnN0LCBzdGFydENoLCBpc0luc2VydCk7XG4gICAgdmFyIGxhc3QgPSBtYXJrZWRTcGFuc0FmdGVyKG9sZExhc3QsIGVuZENoLCBpc0luc2VydCk7XG5cbiAgICAvLyBOZXh0LCBtZXJnZSB0aG9zZSB0d28gZW5kc1xuICAgIHZhciBzYW1lTGluZSA9IGNoYW5nZS50ZXh0Lmxlbmd0aCA9PSAxLCBvZmZzZXQgPSBsc3QoY2hhbmdlLnRleHQpLmxlbmd0aCArIChzYW1lTGluZSA/IHN0YXJ0Q2ggOiAwKTtcbiAgICBpZiAoZmlyc3QpIHtcbiAgICAgIC8vIEZpeCB1cCAudG8gcHJvcGVydGllcyBvZiBmaXJzdFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaXJzdC5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgc3BhbiA9IGZpcnN0W2ldO1xuICAgICAgICBpZiAoc3Bhbi50byA9PSBudWxsKSB7XG4gICAgICAgICAgdmFyIGZvdW5kID0gZ2V0TWFya2VkU3BhbkZvcihsYXN0LCBzcGFuLm1hcmtlcik7XG4gICAgICAgICAgaWYgKCFmb3VuZCkgeyBzcGFuLnRvID0gc3RhcnRDaDsgfVxuICAgICAgICAgIGVsc2UgaWYgKHNhbWVMaW5lKSB7IHNwYW4udG8gPSBmb3VuZC50byA9PSBudWxsID8gbnVsbCA6IGZvdW5kLnRvICsgb2Zmc2V0OyB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGxhc3QpIHtcbiAgICAgIC8vIEZpeCB1cCAuZnJvbSBpbiBsYXN0IChvciBtb3ZlIHRoZW0gaW50byBmaXJzdCBpbiBjYXNlIG9mIHNhbWVMaW5lKVxuICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgbGFzdC5sZW5ndGg7ICsraSQxKSB7XG4gICAgICAgIHZhciBzcGFuJDEgPSBsYXN0W2kkMV07XG4gICAgICAgIGlmIChzcGFuJDEudG8gIT0gbnVsbCkgeyBzcGFuJDEudG8gKz0gb2Zmc2V0OyB9XG4gICAgICAgIGlmIChzcGFuJDEuZnJvbSA9PSBudWxsKSB7XG4gICAgICAgICAgdmFyIGZvdW5kJDEgPSBnZXRNYXJrZWRTcGFuRm9yKGZpcnN0LCBzcGFuJDEubWFya2VyKTtcbiAgICAgICAgICBpZiAoIWZvdW5kJDEpIHtcbiAgICAgICAgICAgIHNwYW4kMS5mcm9tID0gb2Zmc2V0O1xuICAgICAgICAgICAgaWYgKHNhbWVMaW5lKSB7IChmaXJzdCB8fCAoZmlyc3QgPSBbXSkpLnB1c2goc3BhbiQxKTsgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzcGFuJDEuZnJvbSArPSBvZmZzZXQ7XG4gICAgICAgICAgaWYgKHNhbWVMaW5lKSB7IChmaXJzdCB8fCAoZmlyc3QgPSBbXSkpLnB1c2goc3BhbiQxKTsgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIE1ha2Ugc3VyZSB3ZSBkaWRuJ3QgY3JlYXRlIGFueSB6ZXJvLWxlbmd0aCBzcGFuc1xuICAgIGlmIChmaXJzdCkgeyBmaXJzdCA9IGNsZWFyRW1wdHlTcGFucyhmaXJzdCk7IH1cbiAgICBpZiAobGFzdCAmJiBsYXN0ICE9IGZpcnN0KSB7IGxhc3QgPSBjbGVhckVtcHR5U3BhbnMobGFzdCk7IH1cblxuICAgIHZhciBuZXdNYXJrZXJzID0gW2ZpcnN0XTtcbiAgICBpZiAoIXNhbWVMaW5lKSB7XG4gICAgICAvLyBGaWxsIGdhcCB3aXRoIHdob2xlLWxpbmUtc3BhbnNcbiAgICAgIHZhciBnYXAgPSBjaGFuZ2UudGV4dC5sZW5ndGggLSAyLCBnYXBNYXJrZXJzO1xuICAgICAgaWYgKGdhcCA+IDAgJiYgZmlyc3QpXG4gICAgICAgIHsgZm9yICh2YXIgaSQyID0gMDsgaSQyIDwgZmlyc3QubGVuZ3RoOyArK2kkMilcbiAgICAgICAgICB7IGlmIChmaXJzdFtpJDJdLnRvID09IG51bGwpXG4gICAgICAgICAgICB7IChnYXBNYXJrZXJzIHx8IChnYXBNYXJrZXJzID0gW10pKS5wdXNoKG5ldyBNYXJrZWRTcGFuKGZpcnN0W2kkMl0ubWFya2VyLCBudWxsLCBudWxsKSk7IH0gfSB9XG4gICAgICBmb3IgKHZhciBpJDMgPSAwOyBpJDMgPCBnYXA7ICsraSQzKVxuICAgICAgICB7IG5ld01hcmtlcnMucHVzaChnYXBNYXJrZXJzKTsgfVxuICAgICAgbmV3TWFya2Vycy5wdXNoKGxhc3QpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3TWFya2Vyc1xuICB9XG5cbiAgLy8gUmVtb3ZlIHNwYW5zIHRoYXQgYXJlIGVtcHR5IGFuZCBkb24ndCBoYXZlIGEgY2xlYXJXaGVuRW1wdHlcbiAgLy8gb3B0aW9uIG9mIGZhbHNlLlxuICBmdW5jdGlvbiBjbGVhckVtcHR5U3BhbnMoc3BhbnMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNwYW5zLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgc3BhbiA9IHNwYW5zW2ldO1xuICAgICAgaWYgKHNwYW4uZnJvbSAhPSBudWxsICYmIHNwYW4uZnJvbSA9PSBzcGFuLnRvICYmIHNwYW4ubWFya2VyLmNsZWFyV2hlbkVtcHR5ICE9PSBmYWxzZSlcbiAgICAgICAgeyBzcGFucy5zcGxpY2UoaS0tLCAxKTsgfVxuICAgIH1cbiAgICBpZiAoIXNwYW5zLmxlbmd0aCkgeyByZXR1cm4gbnVsbCB9XG4gICAgcmV0dXJuIHNwYW5zXG4gIH1cblxuICAvLyBVc2VkIHRvICdjbGlwJyBvdXQgcmVhZE9ubHkgcmFuZ2VzIHdoZW4gbWFraW5nIGEgY2hhbmdlLlxuICBmdW5jdGlvbiByZW1vdmVSZWFkT25seVJhbmdlcyhkb2MsIGZyb20sIHRvKSB7XG4gICAgdmFyIG1hcmtlcnMgPSBudWxsO1xuICAgIGRvYy5pdGVyKGZyb20ubGluZSwgdG8ubGluZSArIDEsIGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICBpZiAobGluZS5tYXJrZWRTcGFucykgeyBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmUubWFya2VkU3BhbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIG1hcmsgPSBsaW5lLm1hcmtlZFNwYW5zW2ldLm1hcmtlcjtcbiAgICAgICAgaWYgKG1hcmsucmVhZE9ubHkgJiYgKCFtYXJrZXJzIHx8IGluZGV4T2YobWFya2VycywgbWFyaykgPT0gLTEpKVxuICAgICAgICAgIHsgKG1hcmtlcnMgfHwgKG1hcmtlcnMgPSBbXSkpLnB1c2gobWFyayk7IH1cbiAgICAgIH0gfVxuICAgIH0pO1xuICAgIGlmICghbWFya2VycykgeyByZXR1cm4gbnVsbCB9XG4gICAgdmFyIHBhcnRzID0gW3tmcm9tOiBmcm9tLCB0bzogdG99XTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hcmtlcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBtayA9IG1hcmtlcnNbaV0sIG0gPSBtay5maW5kKDApO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwYXJ0cy5sZW5ndGg7ICsraikge1xuICAgICAgICB2YXIgcCA9IHBhcnRzW2pdO1xuICAgICAgICBpZiAoY21wKHAudG8sIG0uZnJvbSkgPCAwIHx8IGNtcChwLmZyb20sIG0udG8pID4gMCkgeyBjb250aW51ZSB9XG4gICAgICAgIHZhciBuZXdQYXJ0cyA9IFtqLCAxXSwgZGZyb20gPSBjbXAocC5mcm9tLCBtLmZyb20pLCBkdG8gPSBjbXAocC50bywgbS50byk7XG4gICAgICAgIGlmIChkZnJvbSA8IDAgfHwgIW1rLmluY2x1c2l2ZUxlZnQgJiYgIWRmcm9tKVxuICAgICAgICAgIHsgbmV3UGFydHMucHVzaCh7ZnJvbTogcC5mcm9tLCB0bzogbS5mcm9tfSk7IH1cbiAgICAgICAgaWYgKGR0byA+IDAgfHwgIW1rLmluY2x1c2l2ZVJpZ2h0ICYmICFkdG8pXG4gICAgICAgICAgeyBuZXdQYXJ0cy5wdXNoKHtmcm9tOiBtLnRvLCB0bzogcC50b30pOyB9XG4gICAgICAgIHBhcnRzLnNwbGljZS5hcHBseShwYXJ0cywgbmV3UGFydHMpO1xuICAgICAgICBqICs9IG5ld1BhcnRzLmxlbmd0aCAtIDM7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYXJ0c1xuICB9XG5cbiAgLy8gQ29ubmVjdCBvciBkaXNjb25uZWN0IHNwYW5zIGZyb20gYSBsaW5lLlxuICBmdW5jdGlvbiBkZXRhY2hNYXJrZWRTcGFucyhsaW5lKSB7XG4gICAgdmFyIHNwYW5zID0gbGluZS5tYXJrZWRTcGFucztcbiAgICBpZiAoIXNwYW5zKSB7IHJldHVybiB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzcGFucy5sZW5ndGg7ICsraSlcbiAgICAgIHsgc3BhbnNbaV0ubWFya2VyLmRldGFjaExpbmUobGluZSk7IH1cbiAgICBsaW5lLm1hcmtlZFNwYW5zID0gbnVsbDtcbiAgfVxuICBmdW5jdGlvbiBhdHRhY2hNYXJrZWRTcGFucyhsaW5lLCBzcGFucykge1xuICAgIGlmICghc3BhbnMpIHsgcmV0dXJuIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNwYW5zLmxlbmd0aDsgKytpKVxuICAgICAgeyBzcGFuc1tpXS5tYXJrZXIuYXR0YWNoTGluZShsaW5lKTsgfVxuICAgIGxpbmUubWFya2VkU3BhbnMgPSBzcGFucztcbiAgfVxuXG4gIC8vIEhlbHBlcnMgdXNlZCB3aGVuIGNvbXB1dGluZyB3aGljaCBvdmVybGFwcGluZyBjb2xsYXBzZWQgc3BhblxuICAvLyBjb3VudHMgYXMgdGhlIGxhcmdlciBvbmUuXG4gIGZ1bmN0aW9uIGV4dHJhTGVmdChtYXJrZXIpIHsgcmV0dXJuIG1hcmtlci5pbmNsdXNpdmVMZWZ0ID8gLTEgOiAwIH1cbiAgZnVuY3Rpb24gZXh0cmFSaWdodChtYXJrZXIpIHsgcmV0dXJuIG1hcmtlci5pbmNsdXNpdmVSaWdodCA/IDEgOiAwIH1cblxuICAvLyBSZXR1cm5zIGEgbnVtYmVyIGluZGljYXRpbmcgd2hpY2ggb2YgdHdvIG92ZXJsYXBwaW5nIGNvbGxhcHNlZFxuICAvLyBzcGFucyBpcyBsYXJnZXIgKGFuZCB0aHVzIGluY2x1ZGVzIHRoZSBvdGhlcikuIEZhbGxzIGJhY2sgdG9cbiAgLy8gY29tcGFyaW5nIGlkcyB3aGVuIHRoZSBzcGFucyBjb3ZlciBleGFjdGx5IHRoZSBzYW1lIHJhbmdlLlxuICBmdW5jdGlvbiBjb21wYXJlQ29sbGFwc2VkTWFya2VycyhhLCBiKSB7XG4gICAgdmFyIGxlbkRpZmYgPSBhLmxpbmVzLmxlbmd0aCAtIGIubGluZXMubGVuZ3RoO1xuICAgIGlmIChsZW5EaWZmICE9IDApIHsgcmV0dXJuIGxlbkRpZmYgfVxuICAgIHZhciBhUG9zID0gYS5maW5kKCksIGJQb3MgPSBiLmZpbmQoKTtcbiAgICB2YXIgZnJvbUNtcCA9IGNtcChhUG9zLmZyb20sIGJQb3MuZnJvbSkgfHwgZXh0cmFMZWZ0KGEpIC0gZXh0cmFMZWZ0KGIpO1xuICAgIGlmIChmcm9tQ21wKSB7IHJldHVybiAtZnJvbUNtcCB9XG4gICAgdmFyIHRvQ21wID0gY21wKGFQb3MudG8sIGJQb3MudG8pIHx8IGV4dHJhUmlnaHQoYSkgLSBleHRyYVJpZ2h0KGIpO1xuICAgIGlmICh0b0NtcCkgeyByZXR1cm4gdG9DbXAgfVxuICAgIHJldHVybiBiLmlkIC0gYS5pZFxuICB9XG5cbiAgLy8gRmluZCBvdXQgd2hldGhlciBhIGxpbmUgZW5kcyBvciBzdGFydHMgaW4gYSBjb2xsYXBzZWQgc3Bhbi4gSWZcbiAgLy8gc28sIHJldHVybiB0aGUgbWFya2VyIGZvciB0aGF0IHNwYW4uXG4gIGZ1bmN0aW9uIGNvbGxhcHNlZFNwYW5BdFNpZGUobGluZSwgc3RhcnQpIHtcbiAgICB2YXIgc3BzID0gc2F3Q29sbGFwc2VkU3BhbnMgJiYgbGluZS5tYXJrZWRTcGFucywgZm91bmQ7XG4gICAgaWYgKHNwcykgeyBmb3IgKHZhciBzcCA9ICh2b2lkIDApLCBpID0gMDsgaSA8IHNwcy5sZW5ndGg7ICsraSkge1xuICAgICAgc3AgPSBzcHNbaV07XG4gICAgICBpZiAoc3AubWFya2VyLmNvbGxhcHNlZCAmJiAoc3RhcnQgPyBzcC5mcm9tIDogc3AudG8pID09IG51bGwgJiZcbiAgICAgICAgICAoIWZvdW5kIHx8IGNvbXBhcmVDb2xsYXBzZWRNYXJrZXJzKGZvdW5kLCBzcC5tYXJrZXIpIDwgMCkpXG4gICAgICAgIHsgZm91bmQgPSBzcC5tYXJrZXI7IH1cbiAgICB9IH1cbiAgICByZXR1cm4gZm91bmRcbiAgfVxuICBmdW5jdGlvbiBjb2xsYXBzZWRTcGFuQXRTdGFydChsaW5lKSB7IHJldHVybiBjb2xsYXBzZWRTcGFuQXRTaWRlKGxpbmUsIHRydWUpIH1cbiAgZnVuY3Rpb24gY29sbGFwc2VkU3BhbkF0RW5kKGxpbmUpIHsgcmV0dXJuIGNvbGxhcHNlZFNwYW5BdFNpZGUobGluZSwgZmFsc2UpIH1cblxuICBmdW5jdGlvbiBjb2xsYXBzZWRTcGFuQXJvdW5kKGxpbmUsIGNoKSB7XG4gICAgdmFyIHNwcyA9IHNhd0NvbGxhcHNlZFNwYW5zICYmIGxpbmUubWFya2VkU3BhbnMsIGZvdW5kO1xuICAgIGlmIChzcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBzcHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBzcCA9IHNwc1tpXTtcbiAgICAgIGlmIChzcC5tYXJrZXIuY29sbGFwc2VkICYmIChzcC5mcm9tID09IG51bGwgfHwgc3AuZnJvbSA8IGNoKSAmJiAoc3AudG8gPT0gbnVsbCB8fCBzcC50byA+IGNoKSAmJlxuICAgICAgICAgICghZm91bmQgfHwgY29tcGFyZUNvbGxhcHNlZE1hcmtlcnMoZm91bmQsIHNwLm1hcmtlcikgPCAwKSkgeyBmb3VuZCA9IHNwLm1hcmtlcjsgfVxuICAgIH0gfVxuICAgIHJldHVybiBmb3VuZFxuICB9XG5cbiAgLy8gVGVzdCB3aGV0aGVyIHRoZXJlIGV4aXN0cyBhIGNvbGxhcHNlZCBzcGFuIHRoYXQgcGFydGlhbGx5XG4gIC8vIG92ZXJsYXBzIChjb3ZlcnMgdGhlIHN0YXJ0IG9yIGVuZCwgYnV0IG5vdCBib3RoKSBvZiBhIG5ldyBzcGFuLlxuICAvLyBTdWNoIG92ZXJsYXAgaXMgbm90IGFsbG93ZWQuXG4gIGZ1bmN0aW9uIGNvbmZsaWN0aW5nQ29sbGFwc2VkUmFuZ2UoZG9jLCBsaW5lTm8sIGZyb20sIHRvLCBtYXJrZXIpIHtcbiAgICB2YXIgbGluZSA9IGdldExpbmUoZG9jLCBsaW5lTm8pO1xuICAgIHZhciBzcHMgPSBzYXdDb2xsYXBzZWRTcGFucyAmJiBsaW5lLm1hcmtlZFNwYW5zO1xuICAgIGlmIChzcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBzcHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBzcCA9IHNwc1tpXTtcbiAgICAgIGlmICghc3AubWFya2VyLmNvbGxhcHNlZCkgeyBjb250aW51ZSB9XG4gICAgICB2YXIgZm91bmQgPSBzcC5tYXJrZXIuZmluZCgwKTtcbiAgICAgIHZhciBmcm9tQ21wID0gY21wKGZvdW5kLmZyb20sIGZyb20pIHx8IGV4dHJhTGVmdChzcC5tYXJrZXIpIC0gZXh0cmFMZWZ0KG1hcmtlcik7XG4gICAgICB2YXIgdG9DbXAgPSBjbXAoZm91bmQudG8sIHRvKSB8fCBleHRyYVJpZ2h0KHNwLm1hcmtlcikgLSBleHRyYVJpZ2h0KG1hcmtlcik7XG4gICAgICBpZiAoZnJvbUNtcCA+PSAwICYmIHRvQ21wIDw9IDAgfHwgZnJvbUNtcCA8PSAwICYmIHRvQ21wID49IDApIHsgY29udGludWUgfVxuICAgICAgaWYgKGZyb21DbXAgPD0gMCAmJiAoc3AubWFya2VyLmluY2x1c2l2ZVJpZ2h0ICYmIG1hcmtlci5pbmNsdXNpdmVMZWZ0ID8gY21wKGZvdW5kLnRvLCBmcm9tKSA+PSAwIDogY21wKGZvdW5kLnRvLCBmcm9tKSA+IDApIHx8XG4gICAgICAgICAgZnJvbUNtcCA+PSAwICYmIChzcC5tYXJrZXIuaW5jbHVzaXZlUmlnaHQgJiYgbWFya2VyLmluY2x1c2l2ZUxlZnQgPyBjbXAoZm91bmQuZnJvbSwgdG8pIDw9IDAgOiBjbXAoZm91bmQuZnJvbSwgdG8pIDwgMCkpXG4gICAgICAgIHsgcmV0dXJuIHRydWUgfVxuICAgIH0gfVxuICB9XG5cbiAgLy8gQSB2aXN1YWwgbGluZSBpcyBhIGxpbmUgYXMgZHJhd24gb24gdGhlIHNjcmVlbi4gRm9sZGluZywgZm9yXG4gIC8vIGV4YW1wbGUsIGNhbiBjYXVzZSBtdWx0aXBsZSBsb2dpY2FsIGxpbmVzIHRvIGFwcGVhciBvbiB0aGUgc2FtZVxuICAvLyB2aXN1YWwgbGluZS4gVGhpcyBmaW5kcyB0aGUgc3RhcnQgb2YgdGhlIHZpc3VhbCBsaW5lIHRoYXQgdGhlXG4gIC8vIGdpdmVuIGxpbmUgaXMgcGFydCBvZiAodXN1YWxseSB0aGF0IGlzIHRoZSBsaW5lIGl0c2VsZikuXG4gIGZ1bmN0aW9uIHZpc3VhbExpbmUobGluZSkge1xuICAgIHZhciBtZXJnZWQ7XG4gICAgd2hpbGUgKG1lcmdlZCA9IGNvbGxhcHNlZFNwYW5BdFN0YXJ0KGxpbmUpKVxuICAgICAgeyBsaW5lID0gbWVyZ2VkLmZpbmQoLTEsIHRydWUpLmxpbmU7IH1cbiAgICByZXR1cm4gbGluZVxuICB9XG5cbiAgZnVuY3Rpb24gdmlzdWFsTGluZUVuZChsaW5lKSB7XG4gICAgdmFyIG1lcmdlZDtcbiAgICB3aGlsZSAobWVyZ2VkID0gY29sbGFwc2VkU3BhbkF0RW5kKGxpbmUpKVxuICAgICAgeyBsaW5lID0gbWVyZ2VkLmZpbmQoMSwgdHJ1ZSkubGluZTsgfVxuICAgIHJldHVybiBsaW5lXG4gIH1cblxuICAvLyBSZXR1cm5zIGFuIGFycmF5IG9mIGxvZ2ljYWwgbGluZXMgdGhhdCBjb250aW51ZSB0aGUgdmlzdWFsIGxpbmVcbiAgLy8gc3RhcnRlZCBieSB0aGUgYXJndW1lbnQsIG9yIHVuZGVmaW5lZCBpZiB0aGVyZSBhcmUgbm8gc3VjaCBsaW5lcy5cbiAgZnVuY3Rpb24gdmlzdWFsTGluZUNvbnRpbnVlZChsaW5lKSB7XG4gICAgdmFyIG1lcmdlZCwgbGluZXM7XG4gICAgd2hpbGUgKG1lcmdlZCA9IGNvbGxhcHNlZFNwYW5BdEVuZChsaW5lKSkge1xuICAgICAgbGluZSA9IG1lcmdlZC5maW5kKDEsIHRydWUpLmxpbmVcbiAgICAgIDsobGluZXMgfHwgKGxpbmVzID0gW10pKS5wdXNoKGxpbmUpO1xuICAgIH1cbiAgICByZXR1cm4gbGluZXNcbiAgfVxuXG4gIC8vIEdldCB0aGUgbGluZSBudW1iZXIgb2YgdGhlIHN0YXJ0IG9mIHRoZSB2aXN1YWwgbGluZSB0aGF0IHRoZVxuICAvLyBnaXZlbiBsaW5lIG51bWJlciBpcyBwYXJ0IG9mLlxuICBmdW5jdGlvbiB2aXN1YWxMaW5lTm8oZG9jLCBsaW5lTikge1xuICAgIHZhciBsaW5lID0gZ2V0TGluZShkb2MsIGxpbmVOKSwgdmlzID0gdmlzdWFsTGluZShsaW5lKTtcbiAgICBpZiAobGluZSA9PSB2aXMpIHsgcmV0dXJuIGxpbmVOIH1cbiAgICByZXR1cm4gbGluZU5vKHZpcylcbiAgfVxuXG4gIC8vIEdldCB0aGUgbGluZSBudW1iZXIgb2YgdGhlIHN0YXJ0IG9mIHRoZSBuZXh0IHZpc3VhbCBsaW5lIGFmdGVyXG4gIC8vIHRoZSBnaXZlbiBsaW5lLlxuICBmdW5jdGlvbiB2aXN1YWxMaW5lRW5kTm8oZG9jLCBsaW5lTikge1xuICAgIGlmIChsaW5lTiA+IGRvYy5sYXN0TGluZSgpKSB7IHJldHVybiBsaW5lTiB9XG4gICAgdmFyIGxpbmUgPSBnZXRMaW5lKGRvYywgbGluZU4pLCBtZXJnZWQ7XG4gICAgaWYgKCFsaW5lSXNIaWRkZW4oZG9jLCBsaW5lKSkgeyByZXR1cm4gbGluZU4gfVxuICAgIHdoaWxlIChtZXJnZWQgPSBjb2xsYXBzZWRTcGFuQXRFbmQobGluZSkpXG4gICAgICB7IGxpbmUgPSBtZXJnZWQuZmluZCgxLCB0cnVlKS5saW5lOyB9XG4gICAgcmV0dXJuIGxpbmVObyhsaW5lKSArIDFcbiAgfVxuXG4gIC8vIENvbXB1dGUgd2hldGhlciBhIGxpbmUgaXMgaGlkZGVuLiBMaW5lcyBjb3VudCBhcyBoaWRkZW4gd2hlbiB0aGV5XG4gIC8vIGFyZSBwYXJ0IG9mIGEgdmlzdWFsIGxpbmUgdGhhdCBzdGFydHMgd2l0aCBhbm90aGVyIGxpbmUsIG9yIHdoZW5cbiAgLy8gdGhleSBhcmUgZW50aXJlbHkgY292ZXJlZCBieSBjb2xsYXBzZWQsIG5vbi13aWRnZXQgc3Bhbi5cbiAgZnVuY3Rpb24gbGluZUlzSGlkZGVuKGRvYywgbGluZSkge1xuICAgIHZhciBzcHMgPSBzYXdDb2xsYXBzZWRTcGFucyAmJiBsaW5lLm1hcmtlZFNwYW5zO1xuICAgIGlmIChzcHMpIHsgZm9yICh2YXIgc3AgPSAodm9pZCAwKSwgaSA9IDA7IGkgPCBzcHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHNwID0gc3BzW2ldO1xuICAgICAgaWYgKCFzcC5tYXJrZXIuY29sbGFwc2VkKSB7IGNvbnRpbnVlIH1cbiAgICAgIGlmIChzcC5mcm9tID09IG51bGwpIHsgcmV0dXJuIHRydWUgfVxuICAgICAgaWYgKHNwLm1hcmtlci53aWRnZXROb2RlKSB7IGNvbnRpbnVlIH1cbiAgICAgIGlmIChzcC5mcm9tID09IDAgJiYgc3AubWFya2VyLmluY2x1c2l2ZUxlZnQgJiYgbGluZUlzSGlkZGVuSW5uZXIoZG9jLCBsaW5lLCBzcCkpXG4gICAgICAgIHsgcmV0dXJuIHRydWUgfVxuICAgIH0gfVxuICB9XG4gIGZ1bmN0aW9uIGxpbmVJc0hpZGRlbklubmVyKGRvYywgbGluZSwgc3Bhbikge1xuICAgIGlmIChzcGFuLnRvID09IG51bGwpIHtcbiAgICAgIHZhciBlbmQgPSBzcGFuLm1hcmtlci5maW5kKDEsIHRydWUpO1xuICAgICAgcmV0dXJuIGxpbmVJc0hpZGRlbklubmVyKGRvYywgZW5kLmxpbmUsIGdldE1hcmtlZFNwYW5Gb3IoZW5kLmxpbmUubWFya2VkU3BhbnMsIHNwYW4ubWFya2VyKSlcbiAgICB9XG4gICAgaWYgKHNwYW4ubWFya2VyLmluY2x1c2l2ZVJpZ2h0ICYmIHNwYW4udG8gPT0gbGluZS50ZXh0Lmxlbmd0aClcbiAgICAgIHsgcmV0dXJuIHRydWUgfVxuICAgIGZvciAodmFyIHNwID0gKHZvaWQgMCksIGkgPSAwOyBpIDwgbGluZS5tYXJrZWRTcGFucy5sZW5ndGg7ICsraSkge1xuICAgICAgc3AgPSBsaW5lLm1hcmtlZFNwYW5zW2ldO1xuICAgICAgaWYgKHNwLm1hcmtlci5jb2xsYXBzZWQgJiYgIXNwLm1hcmtlci53aWRnZXROb2RlICYmIHNwLmZyb20gPT0gc3Bhbi50byAmJlxuICAgICAgICAgIChzcC50byA9PSBudWxsIHx8IHNwLnRvICE9IHNwYW4uZnJvbSkgJiZcbiAgICAgICAgICAoc3AubWFya2VyLmluY2x1c2l2ZUxlZnQgfHwgc3Bhbi5tYXJrZXIuaW5jbHVzaXZlUmlnaHQpICYmXG4gICAgICAgICAgbGluZUlzSGlkZGVuSW5uZXIoZG9jLCBsaW5lLCBzcCkpIHsgcmV0dXJuIHRydWUgfVxuICAgIH1cbiAgfVxuXG4gIC8vIEZpbmQgdGhlIGhlaWdodCBhYm92ZSB0aGUgZ2l2ZW4gbGluZS5cbiAgZnVuY3Rpb24gaGVpZ2h0QXRMaW5lKGxpbmVPYmopIHtcbiAgICBsaW5lT2JqID0gdmlzdWFsTGluZShsaW5lT2JqKTtcblxuICAgIHZhciBoID0gMCwgY2h1bmsgPSBsaW5lT2JqLnBhcmVudDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNodW5rLmxpbmVzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgbGluZSA9IGNodW5rLmxpbmVzW2ldO1xuICAgICAgaWYgKGxpbmUgPT0gbGluZU9iaikgeyBicmVhayB9XG4gICAgICBlbHNlIHsgaCArPSBsaW5lLmhlaWdodDsgfVxuICAgIH1cbiAgICBmb3IgKHZhciBwID0gY2h1bmsucGFyZW50OyBwOyBjaHVuayA9IHAsIHAgPSBjaHVuay5wYXJlbnQpIHtcbiAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHAuY2hpbGRyZW4ubGVuZ3RoOyArK2kkMSkge1xuICAgICAgICB2YXIgY3VyID0gcC5jaGlsZHJlbltpJDFdO1xuICAgICAgICBpZiAoY3VyID09IGNodW5rKSB7IGJyZWFrIH1cbiAgICAgICAgZWxzZSB7IGggKz0gY3VyLmhlaWdodDsgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaFxuICB9XG5cbiAgLy8gQ29tcHV0ZSB0aGUgY2hhcmFjdGVyIGxlbmd0aCBvZiBhIGxpbmUsIHRha2luZyBpbnRvIGFjY291bnRcbiAgLy8gY29sbGFwc2VkIHJhbmdlcyAoc2VlIG1hcmtUZXh0KSB0aGF0IG1pZ2h0IGhpZGUgcGFydHMsIGFuZCBqb2luXG4gIC8vIG90aGVyIGxpbmVzIG9udG8gaXQuXG4gIGZ1bmN0aW9uIGxpbmVMZW5ndGgobGluZSkge1xuICAgIGlmIChsaW5lLmhlaWdodCA9PSAwKSB7IHJldHVybiAwIH1cbiAgICB2YXIgbGVuID0gbGluZS50ZXh0Lmxlbmd0aCwgbWVyZ2VkLCBjdXIgPSBsaW5lO1xuICAgIHdoaWxlIChtZXJnZWQgPSBjb2xsYXBzZWRTcGFuQXRTdGFydChjdXIpKSB7XG4gICAgICB2YXIgZm91bmQgPSBtZXJnZWQuZmluZCgwLCB0cnVlKTtcbiAgICAgIGN1ciA9IGZvdW5kLmZyb20ubGluZTtcbiAgICAgIGxlbiArPSBmb3VuZC5mcm9tLmNoIC0gZm91bmQudG8uY2g7XG4gICAgfVxuICAgIGN1ciA9IGxpbmU7XG4gICAgd2hpbGUgKG1lcmdlZCA9IGNvbGxhcHNlZFNwYW5BdEVuZChjdXIpKSB7XG4gICAgICB2YXIgZm91bmQkMSA9IG1lcmdlZC5maW5kKDAsIHRydWUpO1xuICAgICAgbGVuIC09IGN1ci50ZXh0Lmxlbmd0aCAtIGZvdW5kJDEuZnJvbS5jaDtcbiAgICAgIGN1ciA9IGZvdW5kJDEudG8ubGluZTtcbiAgICAgIGxlbiArPSBjdXIudGV4dC5sZW5ndGggLSBmb3VuZCQxLnRvLmNoO1xuICAgIH1cbiAgICByZXR1cm4gbGVuXG4gIH1cblxuICAvLyBGaW5kIHRoZSBsb25nZXN0IGxpbmUgaW4gdGhlIGRvY3VtZW50LlxuICBmdW5jdGlvbiBmaW5kTWF4TGluZShjbSkge1xuICAgIHZhciBkID0gY20uZGlzcGxheSwgZG9jID0gY20uZG9jO1xuICAgIGQubWF4TGluZSA9IGdldExpbmUoZG9jLCBkb2MuZmlyc3QpO1xuICAgIGQubWF4TGluZUxlbmd0aCA9IGxpbmVMZW5ndGgoZC5tYXhMaW5lKTtcbiAgICBkLm1heExpbmVDaGFuZ2VkID0gdHJ1ZTtcbiAgICBkb2MuaXRlcihmdW5jdGlvbiAobGluZSkge1xuICAgICAgdmFyIGxlbiA9IGxpbmVMZW5ndGgobGluZSk7XG4gICAgICBpZiAobGVuID4gZC5tYXhMaW5lTGVuZ3RoKSB7XG4gICAgICAgIGQubWF4TGluZUxlbmd0aCA9IGxlbjtcbiAgICAgICAgZC5tYXhMaW5lID0gbGluZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8vIExJTkUgREFUQSBTVFJVQ1RVUkVcblxuICAvLyBMaW5lIG9iamVjdHMuIFRoZXNlIGhvbGQgc3RhdGUgcmVsYXRlZCB0byBhIGxpbmUsIGluY2x1ZGluZ1xuICAvLyBoaWdobGlnaHRpbmcgaW5mbyAodGhlIHN0eWxlcyBhcnJheSkuXG4gIHZhciBMaW5lID0gZnVuY3Rpb24odGV4dCwgbWFya2VkU3BhbnMsIGVzdGltYXRlSGVpZ2h0KSB7XG4gICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICBhdHRhY2hNYXJrZWRTcGFucyh0aGlzLCBtYXJrZWRTcGFucyk7XG4gICAgdGhpcy5oZWlnaHQgPSBlc3RpbWF0ZUhlaWdodCA/IGVzdGltYXRlSGVpZ2h0KHRoaXMpIDogMTtcbiAgfTtcblxuICBMaW5lLnByb3RvdHlwZS5saW5lTm8gPSBmdW5jdGlvbiAoKSB7IHJldHVybiBsaW5lTm8odGhpcykgfTtcbiAgZXZlbnRNaXhpbihMaW5lKTtcblxuICAvLyBDaGFuZ2UgdGhlIGNvbnRlbnQgKHRleHQsIG1hcmtlcnMpIG9mIGEgbGluZS4gQXV0b21hdGljYWxseVxuICAvLyBpbnZhbGlkYXRlcyBjYWNoZWQgaW5mb3JtYXRpb24gYW5kIHRyaWVzIHRvIHJlLWVzdGltYXRlIHRoZVxuICAvLyBsaW5lJ3MgaGVpZ2h0LlxuICBmdW5jdGlvbiB1cGRhdGVMaW5lKGxpbmUsIHRleHQsIG1hcmtlZFNwYW5zLCBlc3RpbWF0ZUhlaWdodCkge1xuICAgIGxpbmUudGV4dCA9IHRleHQ7XG4gICAgaWYgKGxpbmUuc3RhdGVBZnRlcikgeyBsaW5lLnN0YXRlQWZ0ZXIgPSBudWxsOyB9XG4gICAgaWYgKGxpbmUuc3R5bGVzKSB7IGxpbmUuc3R5bGVzID0gbnVsbDsgfVxuICAgIGlmIChsaW5lLm9yZGVyICE9IG51bGwpIHsgbGluZS5vcmRlciA9IG51bGw7IH1cbiAgICBkZXRhY2hNYXJrZWRTcGFucyhsaW5lKTtcbiAgICBhdHRhY2hNYXJrZWRTcGFucyhsaW5lLCBtYXJrZWRTcGFucyk7XG4gICAgdmFyIGVzdEhlaWdodCA9IGVzdGltYXRlSGVpZ2h0ID8gZXN0aW1hdGVIZWlnaHQobGluZSkgOiAxO1xuICAgIGlmIChlc3RIZWlnaHQgIT0gbGluZS5oZWlnaHQpIHsgdXBkYXRlTGluZUhlaWdodChsaW5lLCBlc3RIZWlnaHQpOyB9XG4gIH1cblxuICAvLyBEZXRhY2ggYSBsaW5lIGZyb20gdGhlIGRvY3VtZW50IHRyZWUgYW5kIGl0cyBtYXJrZXJzLlxuICBmdW5jdGlvbiBjbGVhblVwTGluZShsaW5lKSB7XG4gICAgbGluZS5wYXJlbnQgPSBudWxsO1xuICAgIGRldGFjaE1hcmtlZFNwYW5zKGxpbmUpO1xuICB9XG5cbiAgLy8gQ29udmVydCBhIHN0eWxlIGFzIHJldHVybmVkIGJ5IGEgbW9kZSAoZWl0aGVyIG51bGwsIG9yIGEgc3RyaW5nXG4gIC8vIGNvbnRhaW5pbmcgb25lIG9yIG1vcmUgc3R5bGVzKSB0byBhIENTUyBzdHlsZS4gVGhpcyBpcyBjYWNoZWQsXG4gIC8vIGFuZCBhbHNvIGxvb2tzIGZvciBsaW5lLXdpZGUgc3R5bGVzLlxuICB2YXIgc3R5bGVUb0NsYXNzQ2FjaGUgPSB7fSwgc3R5bGVUb0NsYXNzQ2FjaGVXaXRoTW9kZSA9IHt9O1xuICBmdW5jdGlvbiBpbnRlcnByZXRUb2tlblN0eWxlKHN0eWxlLCBvcHRpb25zKSB7XG4gICAgaWYgKCFzdHlsZSB8fCAvXlxccyokLy50ZXN0KHN0eWxlKSkgeyByZXR1cm4gbnVsbCB9XG4gICAgdmFyIGNhY2hlID0gb3B0aW9ucy5hZGRNb2RlQ2xhc3MgPyBzdHlsZVRvQ2xhc3NDYWNoZVdpdGhNb2RlIDogc3R5bGVUb0NsYXNzQ2FjaGU7XG4gICAgcmV0dXJuIGNhY2hlW3N0eWxlXSB8fFxuICAgICAgKGNhY2hlW3N0eWxlXSA9IHN0eWxlLnJlcGxhY2UoL1xcUysvZywgXCJjbS0kJlwiKSlcbiAgfVxuXG4gIC8vIFJlbmRlciB0aGUgRE9NIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB0ZXh0IG9mIGEgbGluZS4gQWxzbyBidWlsZHNcbiAgLy8gdXAgYSAnbGluZSBtYXAnLCB3aGljaCBwb2ludHMgYXQgdGhlIERPTSBub2RlcyB0aGF0IHJlcHJlc2VudFxuICAvLyBzcGVjaWZpYyBzdHJldGNoZXMgb2YgdGV4dCwgYW5kIGlzIHVzZWQgYnkgdGhlIG1lYXN1cmluZyBjb2RlLlxuICAvLyBUaGUgcmV0dXJuZWQgb2JqZWN0IGNvbnRhaW5zIHRoZSBET00gbm9kZSwgdGhpcyBtYXAsIGFuZFxuICAvLyBpbmZvcm1hdGlvbiBhYm91dCBsaW5lLXdpZGUgc3R5bGVzIHRoYXQgd2VyZSBzZXQgYnkgdGhlIG1vZGUuXG4gIGZ1bmN0aW9uIGJ1aWxkTGluZUNvbnRlbnQoY20sIGxpbmVWaWV3KSB7XG4gICAgLy8gVGhlIHBhZGRpbmctcmlnaHQgZm9yY2VzIHRoZSBlbGVtZW50IHRvIGhhdmUgYSAnYm9yZGVyJywgd2hpY2hcbiAgICAvLyBpcyBuZWVkZWQgb24gV2Via2l0IHRvIGJlIGFibGUgdG8gZ2V0IGxpbmUtbGV2ZWwgYm91bmRpbmdcbiAgICAvLyByZWN0YW5nbGVzIGZvciBpdCAoaW4gbWVhc3VyZUNoYXIpLlxuICAgIHZhciBjb250ZW50ID0gZWx0UChcInNwYW5cIiwgbnVsbCwgbnVsbCwgd2Via2l0ID8gXCJwYWRkaW5nLXJpZ2h0OiAuMXB4XCIgOiBudWxsKTtcbiAgICB2YXIgYnVpbGRlciA9IHtwcmU6IGVsdFAoXCJwcmVcIiwgW2NvbnRlbnRdLCBcIkNvZGVNaXJyb3ItbGluZVwiKSwgY29udGVudDogY29udGVudCxcbiAgICAgICAgICAgICAgICAgICBjb2w6IDAsIHBvczogMCwgY206IGNtLFxuICAgICAgICAgICAgICAgICAgIHRyYWlsaW5nU3BhY2U6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgIHNwbGl0U3BhY2VzOiBjbS5nZXRPcHRpb24oXCJsaW5lV3JhcHBpbmdcIil9O1xuICAgIGxpbmVWaWV3Lm1lYXN1cmUgPSB7fTtcblxuICAgIC8vIEl0ZXJhdGUgb3ZlciB0aGUgbG9naWNhbCBsaW5lcyB0aGF0IG1ha2UgdXAgdGhpcyB2aXN1YWwgbGluZS5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8PSAobGluZVZpZXcucmVzdCA/IGxpbmVWaWV3LnJlc3QubGVuZ3RoIDogMCk7IGkrKykge1xuICAgICAgdmFyIGxpbmUgPSBpID8gbGluZVZpZXcucmVzdFtpIC0gMV0gOiBsaW5lVmlldy5saW5lLCBvcmRlciA9ICh2b2lkIDApO1xuICAgICAgYnVpbGRlci5wb3MgPSAwO1xuICAgICAgYnVpbGRlci5hZGRUb2tlbiA9IGJ1aWxkVG9rZW47XG4gICAgICAvLyBPcHRpb25hbGx5IHdpcmUgaW4gc29tZSBoYWNrcyBpbnRvIHRoZSB0b2tlbi1yZW5kZXJpbmdcbiAgICAgIC8vIGFsZ29yaXRobSwgdG8gZGVhbCB3aXRoIGJyb3dzZXIgcXVpcmtzLlxuICAgICAgaWYgKGhhc0JhZEJpZGlSZWN0cyhjbS5kaXNwbGF5Lm1lYXN1cmUpICYmIChvcmRlciA9IGdldE9yZGVyKGxpbmUsIGNtLmRvYy5kaXJlY3Rpb24pKSlcbiAgICAgICAgeyBidWlsZGVyLmFkZFRva2VuID0gYnVpbGRUb2tlbkJhZEJpZGkoYnVpbGRlci5hZGRUb2tlbiwgb3JkZXIpOyB9XG4gICAgICBidWlsZGVyLm1hcCA9IFtdO1xuICAgICAgdmFyIGFsbG93RnJvbnRpZXJVcGRhdGUgPSBsaW5lVmlldyAhPSBjbS5kaXNwbGF5LmV4dGVybmFsTWVhc3VyZWQgJiYgbGluZU5vKGxpbmUpO1xuICAgICAgaW5zZXJ0TGluZUNvbnRlbnQobGluZSwgYnVpbGRlciwgZ2V0TGluZVN0eWxlcyhjbSwgbGluZSwgYWxsb3dGcm9udGllclVwZGF0ZSkpO1xuICAgICAgaWYgKGxpbmUuc3R5bGVDbGFzc2VzKSB7XG4gICAgICAgIGlmIChsaW5lLnN0eWxlQ2xhc3Nlcy5iZ0NsYXNzKVxuICAgICAgICAgIHsgYnVpbGRlci5iZ0NsYXNzID0gam9pbkNsYXNzZXMobGluZS5zdHlsZUNsYXNzZXMuYmdDbGFzcywgYnVpbGRlci5iZ0NsYXNzIHx8IFwiXCIpOyB9XG4gICAgICAgIGlmIChsaW5lLnN0eWxlQ2xhc3Nlcy50ZXh0Q2xhc3MpXG4gICAgICAgICAgeyBidWlsZGVyLnRleHRDbGFzcyA9IGpvaW5DbGFzc2VzKGxpbmUuc3R5bGVDbGFzc2VzLnRleHRDbGFzcywgYnVpbGRlci50ZXh0Q2xhc3MgfHwgXCJcIik7IH1cbiAgICAgIH1cblxuICAgICAgLy8gRW5zdXJlIGF0IGxlYXN0IGEgc2luZ2xlIG5vZGUgaXMgcHJlc2VudCwgZm9yIG1lYXN1cmluZy5cbiAgICAgIGlmIChidWlsZGVyLm1hcC5sZW5ndGggPT0gMClcbiAgICAgICAgeyBidWlsZGVyLm1hcC5wdXNoKDAsIDAsIGJ1aWxkZXIuY29udGVudC5hcHBlbmRDaGlsZCh6ZXJvV2lkdGhFbGVtZW50KGNtLmRpc3BsYXkubWVhc3VyZSkpKTsgfVxuXG4gICAgICAvLyBTdG9yZSB0aGUgbWFwIGFuZCBhIGNhY2hlIG9iamVjdCBmb3IgdGhlIGN1cnJlbnQgbG9naWNhbCBsaW5lXG4gICAgICBpZiAoaSA9PSAwKSB7XG4gICAgICAgIGxpbmVWaWV3Lm1lYXN1cmUubWFwID0gYnVpbGRlci5tYXA7XG4gICAgICAgIGxpbmVWaWV3Lm1lYXN1cmUuY2FjaGUgPSB7fTtcbiAgICAgIH0gZWxzZSB7XG4gIChsaW5lVmlldy5tZWFzdXJlLm1hcHMgfHwgKGxpbmVWaWV3Lm1lYXN1cmUubWFwcyA9IFtdKSkucHVzaChidWlsZGVyLm1hcClcbiAgICAgICAgOyhsaW5lVmlldy5tZWFzdXJlLmNhY2hlcyB8fCAobGluZVZpZXcubWVhc3VyZS5jYWNoZXMgPSBbXSkpLnB1c2goe30pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNlZSBpc3N1ZSAjMjkwMVxuICAgIGlmICh3ZWJraXQpIHtcbiAgICAgIHZhciBsYXN0ID0gYnVpbGRlci5jb250ZW50Lmxhc3RDaGlsZDtcbiAgICAgIGlmICgvXFxiY20tdGFiXFxiLy50ZXN0KGxhc3QuY2xhc3NOYW1lKSB8fCAobGFzdC5xdWVyeVNlbGVjdG9yICYmIGxhc3QucXVlcnlTZWxlY3RvcihcIi5jbS10YWJcIikpKVxuICAgICAgICB7IGJ1aWxkZXIuY29udGVudC5jbGFzc05hbWUgPSBcImNtLXRhYi13cmFwLWhhY2tcIjsgfVxuICAgIH1cblxuICAgIHNpZ25hbChjbSwgXCJyZW5kZXJMaW5lXCIsIGNtLCBsaW5lVmlldy5saW5lLCBidWlsZGVyLnByZSk7XG4gICAgaWYgKGJ1aWxkZXIucHJlLmNsYXNzTmFtZSlcbiAgICAgIHsgYnVpbGRlci50ZXh0Q2xhc3MgPSBqb2luQ2xhc3NlcyhidWlsZGVyLnByZS5jbGFzc05hbWUsIGJ1aWxkZXIudGV4dENsYXNzIHx8IFwiXCIpOyB9XG5cbiAgICByZXR1cm4gYnVpbGRlclxuICB9XG5cbiAgZnVuY3Rpb24gZGVmYXVsdFNwZWNpYWxDaGFyUGxhY2Vob2xkZXIoY2gpIHtcbiAgICB2YXIgdG9rZW4gPSBlbHQoXCJzcGFuXCIsIFwiXFx1MjAyMlwiLCBcImNtLWludmFsaWRjaGFyXCIpO1xuICAgIHRva2VuLnRpdGxlID0gXCJcXFxcdVwiICsgY2guY2hhckNvZGVBdCgwKS50b1N0cmluZygxNik7XG4gICAgdG9rZW4uc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCB0b2tlbi50aXRsZSk7XG4gICAgcmV0dXJuIHRva2VuXG4gIH1cblxuICAvLyBCdWlsZCB1cCB0aGUgRE9NIHJlcHJlc2VudGF0aW9uIGZvciBhIHNpbmdsZSB0b2tlbiwgYW5kIGFkZCBpdCB0b1xuICAvLyB0aGUgbGluZSBtYXAuIFRha2VzIGNhcmUgdG8gcmVuZGVyIHNwZWNpYWwgY2hhcmFjdGVycyBzZXBhcmF0ZWx5LlxuICBmdW5jdGlvbiBidWlsZFRva2VuKGJ1aWxkZXIsIHRleHQsIHN0eWxlLCBzdGFydFN0eWxlLCBlbmRTdHlsZSwgY3NzLCBhdHRyaWJ1dGVzKSB7XG4gICAgaWYgKCF0ZXh0KSB7IHJldHVybiB9XG4gICAgdmFyIGRpc3BsYXlUZXh0ID0gYnVpbGRlci5zcGxpdFNwYWNlcyA/IHNwbGl0U3BhY2VzKHRleHQsIGJ1aWxkZXIudHJhaWxpbmdTcGFjZSkgOiB0ZXh0O1xuICAgIHZhciBzcGVjaWFsID0gYnVpbGRlci5jbS5zdGF0ZS5zcGVjaWFsQ2hhcnMsIG11c3RXcmFwID0gZmFsc2U7XG4gICAgdmFyIGNvbnRlbnQ7XG4gICAgaWYgKCFzcGVjaWFsLnRlc3QodGV4dCkpIHtcbiAgICAgIGJ1aWxkZXIuY29sICs9IHRleHQubGVuZ3RoO1xuICAgICAgY29udGVudCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGRpc3BsYXlUZXh0KTtcbiAgICAgIGJ1aWxkZXIubWFwLnB1c2goYnVpbGRlci5wb3MsIGJ1aWxkZXIucG9zICsgdGV4dC5sZW5ndGgsIGNvbnRlbnQpO1xuICAgICAgaWYgKGllICYmIGllX3ZlcnNpb24gPCA5KSB7IG11c3RXcmFwID0gdHJ1ZTsgfVxuICAgICAgYnVpbGRlci5wb3MgKz0gdGV4dC5sZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgICB2YXIgcG9zID0gMDtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHNwZWNpYWwubGFzdEluZGV4ID0gcG9zO1xuICAgICAgICB2YXIgbSA9IHNwZWNpYWwuZXhlYyh0ZXh0KTtcbiAgICAgICAgdmFyIHNraXBwZWQgPSBtID8gbS5pbmRleCAtIHBvcyA6IHRleHQubGVuZ3RoIC0gcG9zO1xuICAgICAgICBpZiAoc2tpcHBlZCkge1xuICAgICAgICAgIHZhciB0eHQgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShkaXNwbGF5VGV4dC5zbGljZShwb3MsIHBvcyArIHNraXBwZWQpKTtcbiAgICAgICAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8IDkpIHsgY29udGVudC5hcHBlbmRDaGlsZChlbHQoXCJzcGFuXCIsIFt0eHRdKSk7IH1cbiAgICAgICAgICBlbHNlIHsgY29udGVudC5hcHBlbmRDaGlsZCh0eHQpOyB9XG4gICAgICAgICAgYnVpbGRlci5tYXAucHVzaChidWlsZGVyLnBvcywgYnVpbGRlci5wb3MgKyBza2lwcGVkLCB0eHQpO1xuICAgICAgICAgIGJ1aWxkZXIuY29sICs9IHNraXBwZWQ7XG4gICAgICAgICAgYnVpbGRlci5wb3MgKz0gc2tpcHBlZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW0pIHsgYnJlYWsgfVxuICAgICAgICBwb3MgKz0gc2tpcHBlZCArIDE7XG4gICAgICAgIHZhciB0eHQkMSA9ICh2b2lkIDApO1xuICAgICAgICBpZiAobVswXSA9PSBcIlxcdFwiKSB7XG4gICAgICAgICAgdmFyIHRhYlNpemUgPSBidWlsZGVyLmNtLm9wdGlvbnMudGFiU2l6ZSwgdGFiV2lkdGggPSB0YWJTaXplIC0gYnVpbGRlci5jb2wgJSB0YWJTaXplO1xuICAgICAgICAgIHR4dCQxID0gY29udGVudC5hcHBlbmRDaGlsZChlbHQoXCJzcGFuXCIsIHNwYWNlU3RyKHRhYldpZHRoKSwgXCJjbS10YWJcIikpO1xuICAgICAgICAgIHR4dCQxLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJwcmVzZW50YXRpb25cIik7XG4gICAgICAgICAgdHh0JDEuc2V0QXR0cmlidXRlKFwiY20tdGV4dFwiLCBcIlxcdFwiKTtcbiAgICAgICAgICBidWlsZGVyLmNvbCArPSB0YWJXaWR0aDtcbiAgICAgICAgfSBlbHNlIGlmIChtWzBdID09IFwiXFxyXCIgfHwgbVswXSA9PSBcIlxcblwiKSB7XG4gICAgICAgICAgdHh0JDEgPSBjb250ZW50LmFwcGVuZENoaWxkKGVsdChcInNwYW5cIiwgbVswXSA9PSBcIlxcclwiID8gXCJcXHUyNDBkXCIgOiBcIlxcdTI0MjRcIiwgXCJjbS1pbnZhbGlkY2hhclwiKSk7XG4gICAgICAgICAgdHh0JDEuc2V0QXR0cmlidXRlKFwiY20tdGV4dFwiLCBtWzBdKTtcbiAgICAgICAgICBidWlsZGVyLmNvbCArPSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHR4dCQxID0gYnVpbGRlci5jbS5vcHRpb25zLnNwZWNpYWxDaGFyUGxhY2Vob2xkZXIobVswXSk7XG4gICAgICAgICAgdHh0JDEuc2V0QXR0cmlidXRlKFwiY20tdGV4dFwiLCBtWzBdKTtcbiAgICAgICAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8IDkpIHsgY29udGVudC5hcHBlbmRDaGlsZChlbHQoXCJzcGFuXCIsIFt0eHQkMV0pKTsgfVxuICAgICAgICAgIGVsc2UgeyBjb250ZW50LmFwcGVuZENoaWxkKHR4dCQxKTsgfVxuICAgICAgICAgIGJ1aWxkZXIuY29sICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgYnVpbGRlci5tYXAucHVzaChidWlsZGVyLnBvcywgYnVpbGRlci5wb3MgKyAxLCB0eHQkMSk7XG4gICAgICAgIGJ1aWxkZXIucG9zKys7XG4gICAgICB9XG4gICAgfVxuICAgIGJ1aWxkZXIudHJhaWxpbmdTcGFjZSA9IGRpc3BsYXlUZXh0LmNoYXJDb2RlQXQodGV4dC5sZW5ndGggLSAxKSA9PSAzMjtcbiAgICBpZiAoc3R5bGUgfHwgc3RhcnRTdHlsZSB8fCBlbmRTdHlsZSB8fCBtdXN0V3JhcCB8fCBjc3MgfHwgYXR0cmlidXRlcykge1xuICAgICAgdmFyIGZ1bGxTdHlsZSA9IHN0eWxlIHx8IFwiXCI7XG4gICAgICBpZiAoc3RhcnRTdHlsZSkgeyBmdWxsU3R5bGUgKz0gc3RhcnRTdHlsZTsgfVxuICAgICAgaWYgKGVuZFN0eWxlKSB7IGZ1bGxTdHlsZSArPSBlbmRTdHlsZTsgfVxuICAgICAgdmFyIHRva2VuID0gZWx0KFwic3BhblwiLCBbY29udGVudF0sIGZ1bGxTdHlsZSwgY3NzKTtcbiAgICAgIGlmIChhdHRyaWJ1dGVzKSB7XG4gICAgICAgIGZvciAodmFyIGF0dHIgaW4gYXR0cmlidXRlcykgeyBpZiAoYXR0cmlidXRlcy5oYXNPd25Qcm9wZXJ0eShhdHRyKSAmJiBhdHRyICE9IFwic3R5bGVcIiAmJiBhdHRyICE9IFwiY2xhc3NcIilcbiAgICAgICAgICB7IHRva2VuLnNldEF0dHJpYnV0ZShhdHRyLCBhdHRyaWJ1dGVzW2F0dHJdKTsgfSB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYnVpbGRlci5jb250ZW50LmFwcGVuZENoaWxkKHRva2VuKVxuICAgIH1cbiAgICBidWlsZGVyLmNvbnRlbnQuYXBwZW5kQ2hpbGQoY29udGVudCk7XG4gIH1cblxuICAvLyBDaGFuZ2Ugc29tZSBzcGFjZXMgdG8gTkJTUCB0byBwcmV2ZW50IHRoZSBicm93c2VyIGZyb20gY29sbGFwc2luZ1xuICAvLyB0cmFpbGluZyBzcGFjZXMgYXQgdGhlIGVuZCBvZiBhIGxpbmUgd2hlbiByZW5kZXJpbmcgdGV4dCAoaXNzdWUgIzEzNjIpLlxuICBmdW5jdGlvbiBzcGxpdFNwYWNlcyh0ZXh0LCB0cmFpbGluZ0JlZm9yZSkge1xuICAgIGlmICh0ZXh0Lmxlbmd0aCA+IDEgJiYgIS8gIC8udGVzdCh0ZXh0KSkgeyByZXR1cm4gdGV4dCB9XG4gICAgdmFyIHNwYWNlQmVmb3JlID0gdHJhaWxpbmdCZWZvcmUsIHJlc3VsdCA9IFwiXCI7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2ggPSB0ZXh0LmNoYXJBdChpKTtcbiAgICAgIGlmIChjaCA9PSBcIiBcIiAmJiBzcGFjZUJlZm9yZSAmJiAoaSA9PSB0ZXh0Lmxlbmd0aCAtIDEgfHwgdGV4dC5jaGFyQ29kZUF0KGkgKyAxKSA9PSAzMikpXG4gICAgICAgIHsgY2ggPSBcIlxcdTAwYTBcIjsgfVxuICAgICAgcmVzdWx0ICs9IGNoO1xuICAgICAgc3BhY2VCZWZvcmUgPSBjaCA9PSBcIiBcIjtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgLy8gV29yayBhcm91bmQgbm9uc2Vuc2UgZGltZW5zaW9ucyBiZWluZyByZXBvcnRlZCBmb3Igc3RyZXRjaGVzIG9mXG4gIC8vIHJpZ2h0LXRvLWxlZnQgdGV4dC5cbiAgZnVuY3Rpb24gYnVpbGRUb2tlbkJhZEJpZGkoaW5uZXIsIG9yZGVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChidWlsZGVyLCB0ZXh0LCBzdHlsZSwgc3RhcnRTdHlsZSwgZW5kU3R5bGUsIGNzcywgYXR0cmlidXRlcykge1xuICAgICAgc3R5bGUgPSBzdHlsZSA/IHN0eWxlICsgXCIgY20tZm9yY2UtYm9yZGVyXCIgOiBcImNtLWZvcmNlLWJvcmRlclwiO1xuICAgICAgdmFyIHN0YXJ0ID0gYnVpbGRlci5wb3MsIGVuZCA9IHN0YXJ0ICsgdGV4dC5sZW5ndGg7XG4gICAgICBmb3IgKDs7KSB7XG4gICAgICAgIC8vIEZpbmQgdGhlIHBhcnQgdGhhdCBvdmVybGFwcyB3aXRoIHRoZSBzdGFydCBvZiB0aGlzIHRleHRcbiAgICAgICAgdmFyIHBhcnQgPSAodm9pZCAwKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcmRlci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHBhcnQgPSBvcmRlcltpXTtcbiAgICAgICAgICBpZiAocGFydC50byA+IHN0YXJ0ICYmIHBhcnQuZnJvbSA8PSBzdGFydCkgeyBicmVhayB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnQudG8gPj0gZW5kKSB7IHJldHVybiBpbm5lcihidWlsZGVyLCB0ZXh0LCBzdHlsZSwgc3RhcnRTdHlsZSwgZW5kU3R5bGUsIGNzcywgYXR0cmlidXRlcykgfVxuICAgICAgICBpbm5lcihidWlsZGVyLCB0ZXh0LnNsaWNlKDAsIHBhcnQudG8gLSBzdGFydCksIHN0eWxlLCBzdGFydFN0eWxlLCBudWxsLCBjc3MsIGF0dHJpYnV0ZXMpO1xuICAgICAgICBzdGFydFN0eWxlID0gbnVsbDtcbiAgICAgICAgdGV4dCA9IHRleHQuc2xpY2UocGFydC50byAtIHN0YXJ0KTtcbiAgICAgICAgc3RhcnQgPSBwYXJ0LnRvO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGJ1aWxkQ29sbGFwc2VkU3BhbihidWlsZGVyLCBzaXplLCBtYXJrZXIsIGlnbm9yZVdpZGdldCkge1xuICAgIHZhciB3aWRnZXQgPSAhaWdub3JlV2lkZ2V0ICYmIG1hcmtlci53aWRnZXROb2RlO1xuICAgIGlmICh3aWRnZXQpIHsgYnVpbGRlci5tYXAucHVzaChidWlsZGVyLnBvcywgYnVpbGRlci5wb3MgKyBzaXplLCB3aWRnZXQpOyB9XG4gICAgaWYgKCFpZ25vcmVXaWRnZXQgJiYgYnVpbGRlci5jbS5kaXNwbGF5LmlucHV0Lm5lZWRzQ29udGVudEF0dHJpYnV0ZSkge1xuICAgICAgaWYgKCF3aWRnZXQpXG4gICAgICAgIHsgd2lkZ2V0ID0gYnVpbGRlci5jb250ZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpKTsgfVxuICAgICAgd2lkZ2V0LnNldEF0dHJpYnV0ZShcImNtLW1hcmtlclwiLCBtYXJrZXIuaWQpO1xuICAgIH1cbiAgICBpZiAod2lkZ2V0KSB7XG4gICAgICBidWlsZGVyLmNtLmRpc3BsYXkuaW5wdXQuc2V0VW5lZGl0YWJsZSh3aWRnZXQpO1xuICAgICAgYnVpbGRlci5jb250ZW50LmFwcGVuZENoaWxkKHdpZGdldCk7XG4gICAgfVxuICAgIGJ1aWxkZXIucG9zICs9IHNpemU7XG4gICAgYnVpbGRlci50cmFpbGluZ1NwYWNlID0gZmFsc2U7XG4gIH1cblxuICAvLyBPdXRwdXRzIGEgbnVtYmVyIG9mIHNwYW5zIHRvIG1ha2UgdXAgYSBsaW5lLCB0YWtpbmcgaGlnaGxpZ2h0aW5nXG4gIC8vIGFuZCBtYXJrZWQgdGV4dCBpbnRvIGFjY291bnQuXG4gIGZ1bmN0aW9uIGluc2VydExpbmVDb250ZW50KGxpbmUsIGJ1aWxkZXIsIHN0eWxlcykge1xuICAgIHZhciBzcGFucyA9IGxpbmUubWFya2VkU3BhbnMsIGFsbFRleHQgPSBsaW5lLnRleHQsIGF0ID0gMDtcbiAgICBpZiAoIXNwYW5zKSB7XG4gICAgICBmb3IgKHZhciBpJDEgPSAxOyBpJDEgPCBzdHlsZXMubGVuZ3RoOyBpJDErPTIpXG4gICAgICAgIHsgYnVpbGRlci5hZGRUb2tlbihidWlsZGVyLCBhbGxUZXh0LnNsaWNlKGF0LCBhdCA9IHN0eWxlc1tpJDFdKSwgaW50ZXJwcmV0VG9rZW5TdHlsZShzdHlsZXNbaSQxKzFdLCBidWlsZGVyLmNtLm9wdGlvbnMpKTsgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdmFyIGxlbiA9IGFsbFRleHQubGVuZ3RoLCBwb3MgPSAwLCBpID0gMSwgdGV4dCA9IFwiXCIsIHN0eWxlLCBjc3M7XG4gICAgdmFyIG5leHRDaGFuZ2UgPSAwLCBzcGFuU3R5bGUsIHNwYW5FbmRTdHlsZSwgc3BhblN0YXJ0U3R5bGUsIGNvbGxhcHNlZCwgYXR0cmlidXRlcztcbiAgICBmb3IgKDs7KSB7XG4gICAgICBpZiAobmV4dENoYW5nZSA9PSBwb3MpIHsgLy8gVXBkYXRlIGN1cnJlbnQgbWFya2VyIHNldFxuICAgICAgICBzcGFuU3R5bGUgPSBzcGFuRW5kU3R5bGUgPSBzcGFuU3RhcnRTdHlsZSA9IGNzcyA9IFwiXCI7XG4gICAgICAgIGF0dHJpYnV0ZXMgPSBudWxsO1xuICAgICAgICBjb2xsYXBzZWQgPSBudWxsOyBuZXh0Q2hhbmdlID0gSW5maW5pdHk7XG4gICAgICAgIHZhciBmb3VuZEJvb2ttYXJrcyA9IFtdLCBlbmRTdHlsZXMgPSAodm9pZCAwKTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzcGFucy5sZW5ndGg7ICsraikge1xuICAgICAgICAgIHZhciBzcCA9IHNwYW5zW2pdLCBtID0gc3AubWFya2VyO1xuICAgICAgICAgIGlmIChtLnR5cGUgPT0gXCJib29rbWFya1wiICYmIHNwLmZyb20gPT0gcG9zICYmIG0ud2lkZ2V0Tm9kZSkge1xuICAgICAgICAgICAgZm91bmRCb29rbWFya3MucHVzaChtKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHNwLmZyb20gPD0gcG9zICYmIChzcC50byA9PSBudWxsIHx8IHNwLnRvID4gcG9zIHx8IG0uY29sbGFwc2VkICYmIHNwLnRvID09IHBvcyAmJiBzcC5mcm9tID09IHBvcykpIHtcbiAgICAgICAgICAgIGlmIChzcC50byAhPSBudWxsICYmIHNwLnRvICE9IHBvcyAmJiBuZXh0Q2hhbmdlID4gc3AudG8pIHtcbiAgICAgICAgICAgICAgbmV4dENoYW5nZSA9IHNwLnRvO1xuICAgICAgICAgICAgICBzcGFuRW5kU3R5bGUgPSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG0uY2xhc3NOYW1lKSB7IHNwYW5TdHlsZSArPSBcIiBcIiArIG0uY2xhc3NOYW1lOyB9XG4gICAgICAgICAgICBpZiAobS5jc3MpIHsgY3NzID0gKGNzcyA/IGNzcyArIFwiO1wiIDogXCJcIikgKyBtLmNzczsgfVxuICAgICAgICAgICAgaWYgKG0uc3RhcnRTdHlsZSAmJiBzcC5mcm9tID09IHBvcykgeyBzcGFuU3RhcnRTdHlsZSArPSBcIiBcIiArIG0uc3RhcnRTdHlsZTsgfVxuICAgICAgICAgICAgaWYgKG0uZW5kU3R5bGUgJiYgc3AudG8gPT0gbmV4dENoYW5nZSkgeyAoZW5kU3R5bGVzIHx8IChlbmRTdHlsZXMgPSBbXSkpLnB1c2gobS5lbmRTdHlsZSwgc3AudG8pOyB9XG4gICAgICAgICAgICAvLyBzdXBwb3J0IGZvciB0aGUgb2xkIHRpdGxlIHByb3BlcnR5XG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vY29kZW1pcnJvci9Db2RlTWlycm9yL3B1bGwvNTY3M1xuICAgICAgICAgICAgaWYgKG0udGl0bGUpIHsgKGF0dHJpYnV0ZXMgfHwgKGF0dHJpYnV0ZXMgPSB7fSkpLnRpdGxlID0gbS50aXRsZTsgfVxuICAgICAgICAgICAgaWYgKG0uYXR0cmlidXRlcykge1xuICAgICAgICAgICAgICBmb3IgKHZhciBhdHRyIGluIG0uYXR0cmlidXRlcylcbiAgICAgICAgICAgICAgICB7IChhdHRyaWJ1dGVzIHx8IChhdHRyaWJ1dGVzID0ge30pKVthdHRyXSA9IG0uYXR0cmlidXRlc1thdHRyXTsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG0uY29sbGFwc2VkICYmICghY29sbGFwc2VkIHx8IGNvbXBhcmVDb2xsYXBzZWRNYXJrZXJzKGNvbGxhcHNlZC5tYXJrZXIsIG0pIDwgMCkpXG4gICAgICAgICAgICAgIHsgY29sbGFwc2VkID0gc3A7IH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHNwLmZyb20gPiBwb3MgJiYgbmV4dENoYW5nZSA+IHNwLmZyb20pIHtcbiAgICAgICAgICAgIG5leHRDaGFuZ2UgPSBzcC5mcm9tO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5kU3R5bGVzKSB7IGZvciAodmFyIGokMSA9IDA7IGokMSA8IGVuZFN0eWxlcy5sZW5ndGg7IGokMSArPSAyKVxuICAgICAgICAgIHsgaWYgKGVuZFN0eWxlc1tqJDEgKyAxXSA9PSBuZXh0Q2hhbmdlKSB7IHNwYW5FbmRTdHlsZSArPSBcIiBcIiArIGVuZFN0eWxlc1tqJDFdOyB9IH0gfVxuXG4gICAgICAgIGlmICghY29sbGFwc2VkIHx8IGNvbGxhcHNlZC5mcm9tID09IHBvcykgeyBmb3IgKHZhciBqJDIgPSAwOyBqJDIgPCBmb3VuZEJvb2ttYXJrcy5sZW5ndGg7ICsraiQyKVxuICAgICAgICAgIHsgYnVpbGRDb2xsYXBzZWRTcGFuKGJ1aWxkZXIsIDAsIGZvdW5kQm9va21hcmtzW2okMl0pOyB9IH1cbiAgICAgICAgaWYgKGNvbGxhcHNlZCAmJiAoY29sbGFwc2VkLmZyb20gfHwgMCkgPT0gcG9zKSB7XG4gICAgICAgICAgYnVpbGRDb2xsYXBzZWRTcGFuKGJ1aWxkZXIsIChjb2xsYXBzZWQudG8gPT0gbnVsbCA/IGxlbiArIDEgOiBjb2xsYXBzZWQudG8pIC0gcG9zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xsYXBzZWQubWFya2VyLCBjb2xsYXBzZWQuZnJvbSA9PSBudWxsKTtcbiAgICAgICAgICBpZiAoY29sbGFwc2VkLnRvID09IG51bGwpIHsgcmV0dXJuIH1cbiAgICAgICAgICBpZiAoY29sbGFwc2VkLnRvID09IHBvcykgeyBjb2xsYXBzZWQgPSBmYWxzZTsgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocG9zID49IGxlbikgeyBicmVhayB9XG5cbiAgICAgIHZhciB1cHRvID0gTWF0aC5taW4obGVuLCBuZXh0Q2hhbmdlKTtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgICAgdmFyIGVuZCA9IHBvcyArIHRleHQubGVuZ3RoO1xuICAgICAgICAgIGlmICghY29sbGFwc2VkKSB7XG4gICAgICAgICAgICB2YXIgdG9rZW5UZXh0ID0gZW5kID4gdXB0byA/IHRleHQuc2xpY2UoMCwgdXB0byAtIHBvcykgOiB0ZXh0O1xuICAgICAgICAgICAgYnVpbGRlci5hZGRUb2tlbihidWlsZGVyLCB0b2tlblRleHQsIHN0eWxlID8gc3R5bGUgKyBzcGFuU3R5bGUgOiBzcGFuU3R5bGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwYW5TdGFydFN0eWxlLCBwb3MgKyB0b2tlblRleHQubGVuZ3RoID09IG5leHRDaGFuZ2UgPyBzcGFuRW5kU3R5bGUgOiBcIlwiLCBjc3MsIGF0dHJpYnV0ZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZW5kID49IHVwdG8pIHt0ZXh0ID0gdGV4dC5zbGljZSh1cHRvIC0gcG9zKTsgcG9zID0gdXB0bzsgYnJlYWt9XG4gICAgICAgICAgcG9zID0gZW5kO1xuICAgICAgICAgIHNwYW5TdGFydFN0eWxlID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICB0ZXh0ID0gYWxsVGV4dC5zbGljZShhdCwgYXQgPSBzdHlsZXNbaSsrXSk7XG4gICAgICAgIHN0eWxlID0gaW50ZXJwcmV0VG9rZW5TdHlsZShzdHlsZXNbaSsrXSwgYnVpbGRlci5jbS5vcHRpb25zKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuXG4gIC8vIFRoZXNlIG9iamVjdHMgYXJlIHVzZWQgdG8gcmVwcmVzZW50IHRoZSB2aXNpYmxlIChjdXJyZW50bHkgZHJhd24pXG4gIC8vIHBhcnQgb2YgdGhlIGRvY3VtZW50LiBBIExpbmVWaWV3IG1heSBjb3JyZXNwb25kIHRvIG11bHRpcGxlXG4gIC8vIGxvZ2ljYWwgbGluZXMsIGlmIHRob3NlIGFyZSBjb25uZWN0ZWQgYnkgY29sbGFwc2VkIHJhbmdlcy5cbiAgZnVuY3Rpb24gTGluZVZpZXcoZG9jLCBsaW5lLCBsaW5lTikge1xuICAgIC8vIFRoZSBzdGFydGluZyBsaW5lXG4gICAgdGhpcy5saW5lID0gbGluZTtcbiAgICAvLyBDb250aW51aW5nIGxpbmVzLCBpZiBhbnlcbiAgICB0aGlzLnJlc3QgPSB2aXN1YWxMaW5lQ29udGludWVkKGxpbmUpO1xuICAgIC8vIE51bWJlciBvZiBsb2dpY2FsIGxpbmVzIGluIHRoaXMgdmlzdWFsIGxpbmVcbiAgICB0aGlzLnNpemUgPSB0aGlzLnJlc3QgPyBsaW5lTm8obHN0KHRoaXMucmVzdCkpIC0gbGluZU4gKyAxIDogMTtcbiAgICB0aGlzLm5vZGUgPSB0aGlzLnRleHQgPSBudWxsO1xuICAgIHRoaXMuaGlkZGVuID0gbGluZUlzSGlkZGVuKGRvYywgbGluZSk7XG4gIH1cblxuICAvLyBDcmVhdGUgYSByYW5nZSBvZiBMaW5lVmlldyBvYmplY3RzIGZvciB0aGUgZ2l2ZW4gbGluZXMuXG4gIGZ1bmN0aW9uIGJ1aWxkVmlld0FycmF5KGNtLCBmcm9tLCB0bykge1xuICAgIHZhciBhcnJheSA9IFtdLCBuZXh0UG9zO1xuICAgIGZvciAodmFyIHBvcyA9IGZyb207IHBvcyA8IHRvOyBwb3MgPSBuZXh0UG9zKSB7XG4gICAgICB2YXIgdmlldyA9IG5ldyBMaW5lVmlldyhjbS5kb2MsIGdldExpbmUoY20uZG9jLCBwb3MpLCBwb3MpO1xuICAgICAgbmV4dFBvcyA9IHBvcyArIHZpZXcuc2l6ZTtcbiAgICAgIGFycmF5LnB1c2godmlldyk7XG4gICAgfVxuICAgIHJldHVybiBhcnJheVxuICB9XG5cbiAgdmFyIG9wZXJhdGlvbkdyb3VwID0gbnVsbDtcblxuICBmdW5jdGlvbiBwdXNoT3BlcmF0aW9uKG9wKSB7XG4gICAgaWYgKG9wZXJhdGlvbkdyb3VwKSB7XG4gICAgICBvcGVyYXRpb25Hcm91cC5vcHMucHVzaChvcCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wLm93bnNHcm91cCA9IG9wZXJhdGlvbkdyb3VwID0ge1xuICAgICAgICBvcHM6IFtvcF0sXG4gICAgICAgIGRlbGF5ZWRDYWxsYmFja3M6IFtdXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZpcmVDYWxsYmFja3NGb3JPcHMoZ3JvdXApIHtcbiAgICAvLyBDYWxscyBkZWxheWVkIGNhbGxiYWNrcyBhbmQgY3Vyc29yQWN0aXZpdHkgaGFuZGxlcnMgdW50aWwgbm9cbiAgICAvLyBuZXcgb25lcyBhcHBlYXJcbiAgICB2YXIgY2FsbGJhY2tzID0gZ3JvdXAuZGVsYXllZENhbGxiYWNrcywgaSA9IDA7XG4gICAgZG8ge1xuICAgICAgZm9yICg7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspXG4gICAgICAgIHsgY2FsbGJhY2tzW2ldLmNhbGwobnVsbCk7IH1cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZ3JvdXAub3BzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHZhciBvcCA9IGdyb3VwLm9wc1tqXTtcbiAgICAgICAgaWYgKG9wLmN1cnNvckFjdGl2aXR5SGFuZGxlcnMpXG4gICAgICAgICAgeyB3aGlsZSAob3AuY3Vyc29yQWN0aXZpdHlDYWxsZWQgPCBvcC5jdXJzb3JBY3Rpdml0eUhhbmRsZXJzLmxlbmd0aClcbiAgICAgICAgICAgIHsgb3AuY3Vyc29yQWN0aXZpdHlIYW5kbGVyc1tvcC5jdXJzb3JBY3Rpdml0eUNhbGxlZCsrXS5jYWxsKG51bGwsIG9wLmNtKTsgfSB9XG4gICAgICB9XG4gICAgfSB3aGlsZSAoaSA8IGNhbGxiYWNrcy5sZW5ndGgpXG4gIH1cblxuICBmdW5jdGlvbiBmaW5pc2hPcGVyYXRpb24ob3AsIGVuZENiKSB7XG4gICAgdmFyIGdyb3VwID0gb3Aub3duc0dyb3VwO1xuICAgIGlmICghZ3JvdXApIHsgcmV0dXJuIH1cblxuICAgIHRyeSB7IGZpcmVDYWxsYmFja3NGb3JPcHMoZ3JvdXApOyB9XG4gICAgZmluYWxseSB7XG4gICAgICBvcGVyYXRpb25Hcm91cCA9IG51bGw7XG4gICAgICBlbmRDYihncm91cCk7XG4gICAgfVxuICB9XG5cbiAgdmFyIG9ycGhhbkRlbGF5ZWRDYWxsYmFja3MgPSBudWxsO1xuXG4gIC8vIE9mdGVuLCB3ZSB3YW50IHRvIHNpZ25hbCBldmVudHMgYXQgYSBwb2ludCB3aGVyZSB3ZSBhcmUgaW4gdGhlXG4gIC8vIG1pZGRsZSBvZiBzb21lIHdvcmssIGJ1dCBkb24ndCB3YW50IHRoZSBoYW5kbGVyIHRvIHN0YXJ0IGNhbGxpbmdcbiAgLy8gb3RoZXIgbWV0aG9kcyBvbiB0aGUgZWRpdG9yLCB3aGljaCBtaWdodCBiZSBpbiBhbiBpbmNvbnNpc3RlbnRcbiAgLy8gc3RhdGUgb3Igc2ltcGx5IG5vdCBleHBlY3QgYW55IG90aGVyIGV2ZW50cyB0byBoYXBwZW4uXG4gIC8vIHNpZ25hbExhdGVyIGxvb2tzIHdoZXRoZXIgdGhlcmUgYXJlIGFueSBoYW5kbGVycywgYW5kIHNjaGVkdWxlc1xuICAvLyB0aGVtIHRvIGJlIGV4ZWN1dGVkIHdoZW4gdGhlIGxhc3Qgb3BlcmF0aW9uIGVuZHMsIG9yLCBpZiBub1xuICAvLyBvcGVyYXRpb24gaXMgYWN0aXZlLCB3aGVuIGEgdGltZW91dCBmaXJlcy5cbiAgZnVuY3Rpb24gc2lnbmFsTGF0ZXIoZW1pdHRlciwgdHlwZSAvKiwgdmFsdWVzLi4uKi8pIHtcbiAgICB2YXIgYXJyID0gZ2V0SGFuZGxlcnMoZW1pdHRlciwgdHlwZSk7XG4gICAgaWYgKCFhcnIubGVuZ3RoKSB7IHJldHVybiB9XG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpLCBsaXN0O1xuICAgIGlmIChvcGVyYXRpb25Hcm91cCkge1xuICAgICAgbGlzdCA9IG9wZXJhdGlvbkdyb3VwLmRlbGF5ZWRDYWxsYmFja3M7XG4gICAgfSBlbHNlIGlmIChvcnBoYW5EZWxheWVkQ2FsbGJhY2tzKSB7XG4gICAgICBsaXN0ID0gb3JwaGFuRGVsYXllZENhbGxiYWNrcztcbiAgICB9IGVsc2Uge1xuICAgICAgbGlzdCA9IG9ycGhhbkRlbGF5ZWRDYWxsYmFja3MgPSBbXTtcbiAgICAgIHNldFRpbWVvdXQoZmlyZU9ycGhhbkRlbGF5ZWQsIDApO1xuICAgIH1cbiAgICB2YXIgbG9vcCA9IGZ1bmN0aW9uICggaSApIHtcbiAgICAgIGxpc3QucHVzaChmdW5jdGlvbiAoKSB7IHJldHVybiBhcnJbaV0uYXBwbHkobnVsbCwgYXJncyk7IH0pO1xuICAgIH07XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7ICsraSlcbiAgICAgIGxvb3AoIGkgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpcmVPcnBoYW5EZWxheWVkKCkge1xuICAgIHZhciBkZWxheWVkID0gb3JwaGFuRGVsYXllZENhbGxiYWNrcztcbiAgICBvcnBoYW5EZWxheWVkQ2FsbGJhY2tzID0gbnVsbDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlbGF5ZWQubGVuZ3RoOyArK2kpIHsgZGVsYXllZFtpXSgpOyB9XG4gIH1cblxuICAvLyBXaGVuIGFuIGFzcGVjdCBvZiBhIGxpbmUgY2hhbmdlcywgYSBzdHJpbmcgaXMgYWRkZWQgdG9cbiAgLy8gbGluZVZpZXcuY2hhbmdlcy4gVGhpcyB1cGRhdGVzIHRoZSByZWxldmFudCBwYXJ0IG9mIHRoZSBsaW5lJ3NcbiAgLy8gRE9NIHN0cnVjdHVyZS5cbiAgZnVuY3Rpb24gdXBkYXRlTGluZUZvckNoYW5nZXMoY20sIGxpbmVWaWV3LCBsaW5lTiwgZGltcykge1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGluZVZpZXcuY2hhbmdlcy5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIHR5cGUgPSBsaW5lVmlldy5jaGFuZ2VzW2pdO1xuICAgICAgaWYgKHR5cGUgPT0gXCJ0ZXh0XCIpIHsgdXBkYXRlTGluZVRleHQoY20sIGxpbmVWaWV3KTsgfVxuICAgICAgZWxzZSBpZiAodHlwZSA9PSBcImd1dHRlclwiKSB7IHVwZGF0ZUxpbmVHdXR0ZXIoY20sIGxpbmVWaWV3LCBsaW5lTiwgZGltcyk7IH1cbiAgICAgIGVsc2UgaWYgKHR5cGUgPT0gXCJjbGFzc1wiKSB7IHVwZGF0ZUxpbmVDbGFzc2VzKGNtLCBsaW5lVmlldyk7IH1cbiAgICAgIGVsc2UgaWYgKHR5cGUgPT0gXCJ3aWRnZXRcIikgeyB1cGRhdGVMaW5lV2lkZ2V0cyhjbSwgbGluZVZpZXcsIGRpbXMpOyB9XG4gICAgfVxuICAgIGxpbmVWaWV3LmNoYW5nZXMgPSBudWxsO1xuICB9XG5cbiAgLy8gTGluZXMgd2l0aCBndXR0ZXIgZWxlbWVudHMsIHdpZGdldHMgb3IgYSBiYWNrZ3JvdW5kIGNsYXNzIG5lZWQgdG9cbiAgLy8gYmUgd3JhcHBlZCwgYW5kIGhhdmUgdGhlIGV4dHJhIGVsZW1lbnRzIGFkZGVkIHRvIHRoZSB3cmFwcGVyIGRpdlxuICBmdW5jdGlvbiBlbnN1cmVMaW5lV3JhcHBlZChsaW5lVmlldykge1xuICAgIGlmIChsaW5lVmlldy5ub2RlID09IGxpbmVWaWV3LnRleHQpIHtcbiAgICAgIGxpbmVWaWV3Lm5vZGUgPSBlbHQoXCJkaXZcIiwgbnVsbCwgbnVsbCwgXCJwb3NpdGlvbjogcmVsYXRpdmVcIik7XG4gICAgICBpZiAobGluZVZpZXcudGV4dC5wYXJlbnROb2RlKVxuICAgICAgICB7IGxpbmVWaWV3LnRleHQucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQobGluZVZpZXcubm9kZSwgbGluZVZpZXcudGV4dCk7IH1cbiAgICAgIGxpbmVWaWV3Lm5vZGUuYXBwZW5kQ2hpbGQobGluZVZpZXcudGV4dCk7XG4gICAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8IDgpIHsgbGluZVZpZXcubm9kZS5zdHlsZS56SW5kZXggPSAyOyB9XG4gICAgfVxuICAgIHJldHVybiBsaW5lVmlldy5ub2RlXG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVMaW5lQmFja2dyb3VuZChjbSwgbGluZVZpZXcpIHtcbiAgICB2YXIgY2xzID0gbGluZVZpZXcuYmdDbGFzcyA/IGxpbmVWaWV3LmJnQ2xhc3MgKyBcIiBcIiArIChsaW5lVmlldy5saW5lLmJnQ2xhc3MgfHwgXCJcIikgOiBsaW5lVmlldy5saW5lLmJnQ2xhc3M7XG4gICAgaWYgKGNscykgeyBjbHMgKz0gXCIgQ29kZU1pcnJvci1saW5lYmFja2dyb3VuZFwiOyB9XG4gICAgaWYgKGxpbmVWaWV3LmJhY2tncm91bmQpIHtcbiAgICAgIGlmIChjbHMpIHsgbGluZVZpZXcuYmFja2dyb3VuZC5jbGFzc05hbWUgPSBjbHM7IH1cbiAgICAgIGVsc2UgeyBsaW5lVmlldy5iYWNrZ3JvdW5kLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobGluZVZpZXcuYmFja2dyb3VuZCk7IGxpbmVWaWV3LmJhY2tncm91bmQgPSBudWxsOyB9XG4gICAgfSBlbHNlIGlmIChjbHMpIHtcbiAgICAgIHZhciB3cmFwID0gZW5zdXJlTGluZVdyYXBwZWQobGluZVZpZXcpO1xuICAgICAgbGluZVZpZXcuYmFja2dyb3VuZCA9IHdyYXAuaW5zZXJ0QmVmb3JlKGVsdChcImRpdlwiLCBudWxsLCBjbHMpLCB3cmFwLmZpcnN0Q2hpbGQpO1xuICAgICAgY20uZGlzcGxheS5pbnB1dC5zZXRVbmVkaXRhYmxlKGxpbmVWaWV3LmJhY2tncm91bmQpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFdyYXBwZXIgYXJvdW5kIGJ1aWxkTGluZUNvbnRlbnQgd2hpY2ggd2lsbCByZXVzZSB0aGUgc3RydWN0dXJlXG4gIC8vIGluIGRpc3BsYXkuZXh0ZXJuYWxNZWFzdXJlZCB3aGVuIHBvc3NpYmxlLlxuICBmdW5jdGlvbiBnZXRMaW5lQ29udGVudChjbSwgbGluZVZpZXcpIHtcbiAgICB2YXIgZXh0ID0gY20uZGlzcGxheS5leHRlcm5hbE1lYXN1cmVkO1xuICAgIGlmIChleHQgJiYgZXh0LmxpbmUgPT0gbGluZVZpZXcubGluZSkge1xuICAgICAgY20uZGlzcGxheS5leHRlcm5hbE1lYXN1cmVkID0gbnVsbDtcbiAgICAgIGxpbmVWaWV3Lm1lYXN1cmUgPSBleHQubWVhc3VyZTtcbiAgICAgIHJldHVybiBleHQuYnVpbHRcbiAgICB9XG4gICAgcmV0dXJuIGJ1aWxkTGluZUNvbnRlbnQoY20sIGxpbmVWaWV3KVxuICB9XG5cbiAgLy8gUmVkcmF3IHRoZSBsaW5lJ3MgdGV4dC4gSW50ZXJhY3RzIHdpdGggdGhlIGJhY2tncm91bmQgYW5kIHRleHRcbiAgLy8gY2xhc3NlcyBiZWNhdXNlIHRoZSBtb2RlIG1heSBvdXRwdXQgdG9rZW5zIHRoYXQgaW5mbHVlbmNlIHRoZXNlXG4gIC8vIGNsYXNzZXMuXG4gIGZ1bmN0aW9uIHVwZGF0ZUxpbmVUZXh0KGNtLCBsaW5lVmlldykge1xuICAgIHZhciBjbHMgPSBsaW5lVmlldy50ZXh0LmNsYXNzTmFtZTtcbiAgICB2YXIgYnVpbHQgPSBnZXRMaW5lQ29udGVudChjbSwgbGluZVZpZXcpO1xuICAgIGlmIChsaW5lVmlldy50ZXh0ID09IGxpbmVWaWV3Lm5vZGUpIHsgbGluZVZpZXcubm9kZSA9IGJ1aWx0LnByZTsgfVxuICAgIGxpbmVWaWV3LnRleHQucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQoYnVpbHQucHJlLCBsaW5lVmlldy50ZXh0KTtcbiAgICBsaW5lVmlldy50ZXh0ID0gYnVpbHQucHJlO1xuICAgIGlmIChidWlsdC5iZ0NsYXNzICE9IGxpbmVWaWV3LmJnQ2xhc3MgfHwgYnVpbHQudGV4dENsYXNzICE9IGxpbmVWaWV3LnRleHRDbGFzcykge1xuICAgICAgbGluZVZpZXcuYmdDbGFzcyA9IGJ1aWx0LmJnQ2xhc3M7XG4gICAgICBsaW5lVmlldy50ZXh0Q2xhc3MgPSBidWlsdC50ZXh0Q2xhc3M7XG4gICAgICB1cGRhdGVMaW5lQ2xhc3NlcyhjbSwgbGluZVZpZXcpO1xuICAgIH0gZWxzZSBpZiAoY2xzKSB7XG4gICAgICBsaW5lVmlldy50ZXh0LmNsYXNzTmFtZSA9IGNscztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVMaW5lQ2xhc3NlcyhjbSwgbGluZVZpZXcpIHtcbiAgICB1cGRhdGVMaW5lQmFja2dyb3VuZChjbSwgbGluZVZpZXcpO1xuICAgIGlmIChsaW5lVmlldy5saW5lLndyYXBDbGFzcylcbiAgICAgIHsgZW5zdXJlTGluZVdyYXBwZWQobGluZVZpZXcpLmNsYXNzTmFtZSA9IGxpbmVWaWV3LmxpbmUud3JhcENsYXNzOyB9XG4gICAgZWxzZSBpZiAobGluZVZpZXcubm9kZSAhPSBsaW5lVmlldy50ZXh0KVxuICAgICAgeyBsaW5lVmlldy5ub2RlLmNsYXNzTmFtZSA9IFwiXCI7IH1cbiAgICB2YXIgdGV4dENsYXNzID0gbGluZVZpZXcudGV4dENsYXNzID8gbGluZVZpZXcudGV4dENsYXNzICsgXCIgXCIgKyAobGluZVZpZXcubGluZS50ZXh0Q2xhc3MgfHwgXCJcIikgOiBsaW5lVmlldy5saW5lLnRleHRDbGFzcztcbiAgICBsaW5lVmlldy50ZXh0LmNsYXNzTmFtZSA9IHRleHRDbGFzcyB8fCBcIlwiO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlTGluZUd1dHRlcihjbSwgbGluZVZpZXcsIGxpbmVOLCBkaW1zKSB7XG4gICAgaWYgKGxpbmVWaWV3Lmd1dHRlcikge1xuICAgICAgbGluZVZpZXcubm9kZS5yZW1vdmVDaGlsZChsaW5lVmlldy5ndXR0ZXIpO1xuICAgICAgbGluZVZpZXcuZ3V0dGVyID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKGxpbmVWaWV3Lmd1dHRlckJhY2tncm91bmQpIHtcbiAgICAgIGxpbmVWaWV3Lm5vZGUucmVtb3ZlQ2hpbGQobGluZVZpZXcuZ3V0dGVyQmFja2dyb3VuZCk7XG4gICAgICBsaW5lVmlldy5ndXR0ZXJCYWNrZ3JvdW5kID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKGxpbmVWaWV3LmxpbmUuZ3V0dGVyQ2xhc3MpIHtcbiAgICAgIHZhciB3cmFwID0gZW5zdXJlTGluZVdyYXBwZWQobGluZVZpZXcpO1xuICAgICAgbGluZVZpZXcuZ3V0dGVyQmFja2dyb3VuZCA9IGVsdChcImRpdlwiLCBudWxsLCBcIkNvZGVNaXJyb3ItZ3V0dGVyLWJhY2tncm91bmQgXCIgKyBsaW5lVmlldy5saW5lLmd1dHRlckNsYXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoXCJsZWZ0OiBcIiArIChjbS5vcHRpb25zLmZpeGVkR3V0dGVyID8gZGltcy5maXhlZFBvcyA6IC1kaW1zLmd1dHRlclRvdGFsV2lkdGgpICsgXCJweDsgd2lkdGg6IFwiICsgKGRpbXMuZ3V0dGVyVG90YWxXaWR0aCkgKyBcInB4XCIpKTtcbiAgICAgIGNtLmRpc3BsYXkuaW5wdXQuc2V0VW5lZGl0YWJsZShsaW5lVmlldy5ndXR0ZXJCYWNrZ3JvdW5kKTtcbiAgICAgIHdyYXAuaW5zZXJ0QmVmb3JlKGxpbmVWaWV3Lmd1dHRlckJhY2tncm91bmQsIGxpbmVWaWV3LnRleHQpO1xuICAgIH1cbiAgICB2YXIgbWFya2VycyA9IGxpbmVWaWV3LmxpbmUuZ3V0dGVyTWFya2VycztcbiAgICBpZiAoY20ub3B0aW9ucy5saW5lTnVtYmVycyB8fCBtYXJrZXJzKSB7XG4gICAgICB2YXIgd3JhcCQxID0gZW5zdXJlTGluZVdyYXBwZWQobGluZVZpZXcpO1xuICAgICAgdmFyIGd1dHRlcldyYXAgPSBsaW5lVmlldy5ndXR0ZXIgPSBlbHQoXCJkaXZcIiwgbnVsbCwgXCJDb2RlTWlycm9yLWd1dHRlci13cmFwcGVyXCIsIChcImxlZnQ6IFwiICsgKGNtLm9wdGlvbnMuZml4ZWRHdXR0ZXIgPyBkaW1zLmZpeGVkUG9zIDogLWRpbXMuZ3V0dGVyVG90YWxXaWR0aCkgKyBcInB4XCIpKTtcbiAgICAgIGNtLmRpc3BsYXkuaW5wdXQuc2V0VW5lZGl0YWJsZShndXR0ZXJXcmFwKTtcbiAgICAgIHdyYXAkMS5pbnNlcnRCZWZvcmUoZ3V0dGVyV3JhcCwgbGluZVZpZXcudGV4dCk7XG4gICAgICBpZiAobGluZVZpZXcubGluZS5ndXR0ZXJDbGFzcylcbiAgICAgICAgeyBndXR0ZXJXcmFwLmNsYXNzTmFtZSArPSBcIiBcIiArIGxpbmVWaWV3LmxpbmUuZ3V0dGVyQ2xhc3M7IH1cbiAgICAgIGlmIChjbS5vcHRpb25zLmxpbmVOdW1iZXJzICYmICghbWFya2VycyB8fCAhbWFya2Vyc1tcIkNvZGVNaXJyb3ItbGluZW51bWJlcnNcIl0pKVxuICAgICAgICB7IGxpbmVWaWV3LmxpbmVOdW1iZXIgPSBndXR0ZXJXcmFwLmFwcGVuZENoaWxkKFxuICAgICAgICAgIGVsdChcImRpdlwiLCBsaW5lTnVtYmVyRm9yKGNtLm9wdGlvbnMsIGxpbmVOKSxcbiAgICAgICAgICAgICAgXCJDb2RlTWlycm9yLWxpbmVudW1iZXIgQ29kZU1pcnJvci1ndXR0ZXItZWx0XCIsXG4gICAgICAgICAgICAgIChcImxlZnQ6IFwiICsgKGRpbXMuZ3V0dGVyTGVmdFtcIkNvZGVNaXJyb3ItbGluZW51bWJlcnNcIl0pICsgXCJweDsgd2lkdGg6IFwiICsgKGNtLmRpc3BsYXkubGluZU51bUlubmVyV2lkdGgpICsgXCJweFwiKSkpOyB9XG4gICAgICBpZiAobWFya2VycykgeyBmb3IgKHZhciBrID0gMDsgayA8IGNtLmRpc3BsYXkuZ3V0dGVyU3BlY3MubGVuZ3RoOyArK2spIHtcbiAgICAgICAgdmFyIGlkID0gY20uZGlzcGxheS5ndXR0ZXJTcGVjc1trXS5jbGFzc05hbWUsIGZvdW5kID0gbWFya2Vycy5oYXNPd25Qcm9wZXJ0eShpZCkgJiYgbWFya2Vyc1tpZF07XG4gICAgICAgIGlmIChmb3VuZClcbiAgICAgICAgICB7IGd1dHRlcldyYXAuYXBwZW5kQ2hpbGQoZWx0KFwiZGl2XCIsIFtmb3VuZF0sIFwiQ29kZU1pcnJvci1ndXR0ZXItZWx0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKFwibGVmdDogXCIgKyAoZGltcy5ndXR0ZXJMZWZ0W2lkXSkgKyBcInB4OyB3aWR0aDogXCIgKyAoZGltcy5ndXR0ZXJXaWR0aFtpZF0pICsgXCJweFwiKSkpOyB9XG4gICAgICB9IH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVMaW5lV2lkZ2V0cyhjbSwgbGluZVZpZXcsIGRpbXMpIHtcbiAgICBpZiAobGluZVZpZXcuYWxpZ25hYmxlKSB7IGxpbmVWaWV3LmFsaWduYWJsZSA9IG51bGw7IH1cbiAgICB2YXIgaXNXaWRnZXQgPSBjbGFzc1Rlc3QoXCJDb2RlTWlycm9yLWxpbmV3aWRnZXRcIik7XG4gICAgZm9yICh2YXIgbm9kZSA9IGxpbmVWaWV3Lm5vZGUuZmlyc3RDaGlsZCwgbmV4dCA9ICh2b2lkIDApOyBub2RlOyBub2RlID0gbmV4dCkge1xuICAgICAgbmV4dCA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgICBpZiAoaXNXaWRnZXQudGVzdChub2RlLmNsYXNzTmFtZSkpIHsgbGluZVZpZXcubm9kZS5yZW1vdmVDaGlsZChub2RlKTsgfVxuICAgIH1cbiAgICBpbnNlcnRMaW5lV2lkZ2V0cyhjbSwgbGluZVZpZXcsIGRpbXMpO1xuICB9XG5cbiAgLy8gQnVpbGQgYSBsaW5lJ3MgRE9NIHJlcHJlc2VudGF0aW9uIGZyb20gc2NyYXRjaFxuICBmdW5jdGlvbiBidWlsZExpbmVFbGVtZW50KGNtLCBsaW5lVmlldywgbGluZU4sIGRpbXMpIHtcbiAgICB2YXIgYnVpbHQgPSBnZXRMaW5lQ29udGVudChjbSwgbGluZVZpZXcpO1xuICAgIGxpbmVWaWV3LnRleHQgPSBsaW5lVmlldy5ub2RlID0gYnVpbHQucHJlO1xuICAgIGlmIChidWlsdC5iZ0NsYXNzKSB7IGxpbmVWaWV3LmJnQ2xhc3MgPSBidWlsdC5iZ0NsYXNzOyB9XG4gICAgaWYgKGJ1aWx0LnRleHRDbGFzcykgeyBsaW5lVmlldy50ZXh0Q2xhc3MgPSBidWlsdC50ZXh0Q2xhc3M7IH1cblxuICAgIHVwZGF0ZUxpbmVDbGFzc2VzKGNtLCBsaW5lVmlldyk7XG4gICAgdXBkYXRlTGluZUd1dHRlcihjbSwgbGluZVZpZXcsIGxpbmVOLCBkaW1zKTtcbiAgICBpbnNlcnRMaW5lV2lkZ2V0cyhjbSwgbGluZVZpZXcsIGRpbXMpO1xuICAgIHJldHVybiBsaW5lVmlldy5ub2RlXG4gIH1cblxuICAvLyBBIGxpbmVWaWV3IG1heSBjb250YWluIG11bHRpcGxlIGxvZ2ljYWwgbGluZXMgKHdoZW4gbWVyZ2VkIGJ5XG4gIC8vIGNvbGxhcHNlZCBzcGFucykuIFRoZSB3aWRnZXRzIGZvciBhbGwgb2YgdGhlbSBuZWVkIHRvIGJlIGRyYXduLlxuICBmdW5jdGlvbiBpbnNlcnRMaW5lV2lkZ2V0cyhjbSwgbGluZVZpZXcsIGRpbXMpIHtcbiAgICBpbnNlcnRMaW5lV2lkZ2V0c0ZvcihjbSwgbGluZVZpZXcubGluZSwgbGluZVZpZXcsIGRpbXMsIHRydWUpO1xuICAgIGlmIChsaW5lVmlldy5yZXN0KSB7IGZvciAodmFyIGkgPSAwOyBpIDwgbGluZVZpZXcucmVzdC5sZW5ndGg7IGkrKylcbiAgICAgIHsgaW5zZXJ0TGluZVdpZGdldHNGb3IoY20sIGxpbmVWaWV3LnJlc3RbaV0sIGxpbmVWaWV3LCBkaW1zLCBmYWxzZSk7IH0gfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5zZXJ0TGluZVdpZGdldHNGb3IoY20sIGxpbmUsIGxpbmVWaWV3LCBkaW1zLCBhbGxvd0Fib3ZlKSB7XG4gICAgaWYgKCFsaW5lLndpZGdldHMpIHsgcmV0dXJuIH1cbiAgICB2YXIgd3JhcCA9IGVuc3VyZUxpbmVXcmFwcGVkKGxpbmVWaWV3KTtcbiAgICBmb3IgKHZhciBpID0gMCwgd3MgPSBsaW5lLndpZGdldHM7IGkgPCB3cy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIHdpZGdldCA9IHdzW2ldLCBub2RlID0gZWx0KFwiZGl2XCIsIFt3aWRnZXQubm9kZV0sIFwiQ29kZU1pcnJvci1saW5ld2lkZ2V0XCIgKyAod2lkZ2V0LmNsYXNzTmFtZSA/IFwiIFwiICsgd2lkZ2V0LmNsYXNzTmFtZSA6IFwiXCIpKTtcbiAgICAgIGlmICghd2lkZ2V0LmhhbmRsZU1vdXNlRXZlbnRzKSB7IG5vZGUuc2V0QXR0cmlidXRlKFwiY20taWdub3JlLWV2ZW50c1wiLCBcInRydWVcIik7IH1cbiAgICAgIHBvc2l0aW9uTGluZVdpZGdldCh3aWRnZXQsIG5vZGUsIGxpbmVWaWV3LCBkaW1zKTtcbiAgICAgIGNtLmRpc3BsYXkuaW5wdXQuc2V0VW5lZGl0YWJsZShub2RlKTtcbiAgICAgIGlmIChhbGxvd0Fib3ZlICYmIHdpZGdldC5hYm92ZSlcbiAgICAgICAgeyB3cmFwLmluc2VydEJlZm9yZShub2RlLCBsaW5lVmlldy5ndXR0ZXIgfHwgbGluZVZpZXcudGV4dCk7IH1cbiAgICAgIGVsc2VcbiAgICAgICAgeyB3cmFwLmFwcGVuZENoaWxkKG5vZGUpOyB9XG4gICAgICBzaWduYWxMYXRlcih3aWRnZXQsIFwicmVkcmF3XCIpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBvc2l0aW9uTGluZVdpZGdldCh3aWRnZXQsIG5vZGUsIGxpbmVWaWV3LCBkaW1zKSB7XG4gICAgaWYgKHdpZGdldC5ub0hTY3JvbGwpIHtcbiAgKGxpbmVWaWV3LmFsaWduYWJsZSB8fCAobGluZVZpZXcuYWxpZ25hYmxlID0gW10pKS5wdXNoKG5vZGUpO1xuICAgICAgdmFyIHdpZHRoID0gZGltcy53cmFwcGVyV2lkdGg7XG4gICAgICBub2RlLnN0eWxlLmxlZnQgPSBkaW1zLmZpeGVkUG9zICsgXCJweFwiO1xuICAgICAgaWYgKCF3aWRnZXQuY292ZXJHdXR0ZXIpIHtcbiAgICAgICAgd2lkdGggLT0gZGltcy5ndXR0ZXJUb3RhbFdpZHRoO1xuICAgICAgICBub2RlLnN0eWxlLnBhZGRpbmdMZWZ0ID0gZGltcy5ndXR0ZXJUb3RhbFdpZHRoICsgXCJweFwiO1xuICAgICAgfVxuICAgICAgbm9kZS5zdHlsZS53aWR0aCA9IHdpZHRoICsgXCJweFwiO1xuICAgIH1cbiAgICBpZiAod2lkZ2V0LmNvdmVyR3V0dGVyKSB7XG4gICAgICBub2RlLnN0eWxlLnpJbmRleCA9IDU7XG4gICAgICBub2RlLnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xuICAgICAgaWYgKCF3aWRnZXQubm9IU2Nyb2xsKSB7IG5vZGUuc3R5bGUubWFyZ2luTGVmdCA9IC1kaW1zLmd1dHRlclRvdGFsV2lkdGggKyBcInB4XCI7IH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB3aWRnZXRIZWlnaHQod2lkZ2V0KSB7XG4gICAgaWYgKHdpZGdldC5oZWlnaHQgIT0gbnVsbCkgeyByZXR1cm4gd2lkZ2V0LmhlaWdodCB9XG4gICAgdmFyIGNtID0gd2lkZ2V0LmRvYy5jbTtcbiAgICBpZiAoIWNtKSB7IHJldHVybiAwIH1cbiAgICBpZiAoIWNvbnRhaW5zKGRvY3VtZW50LmJvZHksIHdpZGdldC5ub2RlKSkge1xuICAgICAgdmFyIHBhcmVudFN0eWxlID0gXCJwb3NpdGlvbjogcmVsYXRpdmU7XCI7XG4gICAgICBpZiAod2lkZ2V0LmNvdmVyR3V0dGVyKVxuICAgICAgICB7IHBhcmVudFN0eWxlICs9IFwibWFyZ2luLWxlZnQ6IC1cIiArIGNtLmRpc3BsYXkuZ3V0dGVycy5vZmZzZXRXaWR0aCArIFwicHg7XCI7IH1cbiAgICAgIGlmICh3aWRnZXQubm9IU2Nyb2xsKVxuICAgICAgICB7IHBhcmVudFN0eWxlICs9IFwid2lkdGg6IFwiICsgY20uZGlzcGxheS53cmFwcGVyLmNsaWVudFdpZHRoICsgXCJweDtcIjsgfVxuICAgICAgcmVtb3ZlQ2hpbGRyZW5BbmRBZGQoY20uZGlzcGxheS5tZWFzdXJlLCBlbHQoXCJkaXZcIiwgW3dpZGdldC5ub2RlXSwgbnVsbCwgcGFyZW50U3R5bGUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHdpZGdldC5oZWlnaHQgPSB3aWRnZXQubm9kZS5wYXJlbnROb2RlLm9mZnNldEhlaWdodFxuICB9XG5cbiAgLy8gUmV0dXJuIHRydWUgd2hlbiB0aGUgZ2l2ZW4gbW91c2UgZXZlbnQgaGFwcGVuZWQgaW4gYSB3aWRnZXRcbiAgZnVuY3Rpb24gZXZlbnRJbldpZGdldChkaXNwbGF5LCBlKSB7XG4gICAgZm9yICh2YXIgbiA9IGVfdGFyZ2V0KGUpOyBuICE9IGRpc3BsYXkud3JhcHBlcjsgbiA9IG4ucGFyZW50Tm9kZSkge1xuICAgICAgaWYgKCFuIHx8IChuLm5vZGVUeXBlID09IDEgJiYgbi5nZXRBdHRyaWJ1dGUoXCJjbS1pZ25vcmUtZXZlbnRzXCIpID09IFwidHJ1ZVwiKSB8fFxuICAgICAgICAgIChuLnBhcmVudE5vZGUgPT0gZGlzcGxheS5zaXplciAmJiBuICE9IGRpc3BsYXkubW92ZXIpKVxuICAgICAgICB7IHJldHVybiB0cnVlIH1cbiAgICB9XG4gIH1cblxuICAvLyBQT1NJVElPTiBNRUFTVVJFTUVOVFxuXG4gIGZ1bmN0aW9uIHBhZGRpbmdUb3AoZGlzcGxheSkge3JldHVybiBkaXNwbGF5LmxpbmVTcGFjZS5vZmZzZXRUb3B9XG4gIGZ1bmN0aW9uIHBhZGRpbmdWZXJ0KGRpc3BsYXkpIHtyZXR1cm4gZGlzcGxheS5tb3Zlci5vZmZzZXRIZWlnaHQgLSBkaXNwbGF5LmxpbmVTcGFjZS5vZmZzZXRIZWlnaHR9XG4gIGZ1bmN0aW9uIHBhZGRpbmdIKGRpc3BsYXkpIHtcbiAgICBpZiAoZGlzcGxheS5jYWNoZWRQYWRkaW5nSCkgeyByZXR1cm4gZGlzcGxheS5jYWNoZWRQYWRkaW5nSCB9XG4gICAgdmFyIGUgPSByZW1vdmVDaGlsZHJlbkFuZEFkZChkaXNwbGF5Lm1lYXN1cmUsIGVsdChcInByZVwiLCBcInhcIiwgXCJDb2RlTWlycm9yLWxpbmUtbGlrZVwiKSk7XG4gICAgdmFyIHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUgPyB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlKSA6IGUuY3VycmVudFN0eWxlO1xuICAgIHZhciBkYXRhID0ge2xlZnQ6IHBhcnNlSW50KHN0eWxlLnBhZGRpbmdMZWZ0KSwgcmlnaHQ6IHBhcnNlSW50KHN0eWxlLnBhZGRpbmdSaWdodCl9O1xuICAgIGlmICghaXNOYU4oZGF0YS5sZWZ0KSAmJiAhaXNOYU4oZGF0YS5yaWdodCkpIHsgZGlzcGxheS5jYWNoZWRQYWRkaW5nSCA9IGRhdGE7IH1cbiAgICByZXR1cm4gZGF0YVxuICB9XG5cbiAgZnVuY3Rpb24gc2Nyb2xsR2FwKGNtKSB7IHJldHVybiBzY3JvbGxlckdhcCAtIGNtLmRpc3BsYXkubmF0aXZlQmFyV2lkdGggfVxuICBmdW5jdGlvbiBkaXNwbGF5V2lkdGgoY20pIHtcbiAgICByZXR1cm4gY20uZGlzcGxheS5zY3JvbGxlci5jbGllbnRXaWR0aCAtIHNjcm9sbEdhcChjbSkgLSBjbS5kaXNwbGF5LmJhcldpZHRoXG4gIH1cbiAgZnVuY3Rpb24gZGlzcGxheUhlaWdodChjbSkge1xuICAgIHJldHVybiBjbS5kaXNwbGF5LnNjcm9sbGVyLmNsaWVudEhlaWdodCAtIHNjcm9sbEdhcChjbSkgLSBjbS5kaXNwbGF5LmJhckhlaWdodFxuICB9XG5cbiAgLy8gRW5zdXJlIHRoZSBsaW5lVmlldy53cmFwcGluZy5oZWlnaHRzIGFycmF5IGlzIHBvcHVsYXRlZC4gVGhpcyBpc1xuICAvLyBhbiBhcnJheSBvZiBib3R0b20gb2Zmc2V0cyBmb3IgdGhlIGxpbmVzIHRoYXQgbWFrZSB1cCBhIGRyYXduXG4gIC8vIGxpbmUuIFdoZW4gbGluZVdyYXBwaW5nIGlzIG9uLCB0aGVyZSBtaWdodCBiZSBtb3JlIHRoYW4gb25lXG4gIC8vIGhlaWdodC5cbiAgZnVuY3Rpb24gZW5zdXJlTGluZUhlaWdodHMoY20sIGxpbmVWaWV3LCByZWN0KSB7XG4gICAgdmFyIHdyYXBwaW5nID0gY20ub3B0aW9ucy5saW5lV3JhcHBpbmc7XG4gICAgdmFyIGN1cldpZHRoID0gd3JhcHBpbmcgJiYgZGlzcGxheVdpZHRoKGNtKTtcbiAgICBpZiAoIWxpbmVWaWV3Lm1lYXN1cmUuaGVpZ2h0cyB8fCB3cmFwcGluZyAmJiBsaW5lVmlldy5tZWFzdXJlLndpZHRoICE9IGN1cldpZHRoKSB7XG4gICAgICB2YXIgaGVpZ2h0cyA9IGxpbmVWaWV3Lm1lYXN1cmUuaGVpZ2h0cyA9IFtdO1xuICAgICAgaWYgKHdyYXBwaW5nKSB7XG4gICAgICAgIGxpbmVWaWV3Lm1lYXN1cmUud2lkdGggPSBjdXJXaWR0aDtcbiAgICAgICAgdmFyIHJlY3RzID0gbGluZVZpZXcudGV4dC5maXJzdENoaWxkLmdldENsaWVudFJlY3RzKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVjdHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgdmFyIGN1ciA9IHJlY3RzW2ldLCBuZXh0ID0gcmVjdHNbaSArIDFdO1xuICAgICAgICAgIGlmIChNYXRoLmFicyhjdXIuYm90dG9tIC0gbmV4dC5ib3R0b20pID4gMilcbiAgICAgICAgICAgIHsgaGVpZ2h0cy5wdXNoKChjdXIuYm90dG9tICsgbmV4dC50b3ApIC8gMiAtIHJlY3QudG9wKTsgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBoZWlnaHRzLnB1c2gocmVjdC5ib3R0b20gLSByZWN0LnRvcCk7XG4gICAgfVxuICB9XG5cbiAgLy8gRmluZCBhIGxpbmUgbWFwIChtYXBwaW5nIGNoYXJhY3RlciBvZmZzZXRzIHRvIHRleHQgbm9kZXMpIGFuZCBhXG4gIC8vIG1lYXN1cmVtZW50IGNhY2hlIGZvciB0aGUgZ2l2ZW4gbGluZSBudW1iZXIuIChBIGxpbmUgdmlldyBtaWdodFxuICAvLyBjb250YWluIG11bHRpcGxlIGxpbmVzIHdoZW4gY29sbGFwc2VkIHJhbmdlcyBhcmUgcHJlc2VudC4pXG4gIGZ1bmN0aW9uIG1hcEZyb21MaW5lVmlldyhsaW5lVmlldywgbGluZSwgbGluZU4pIHtcbiAgICBpZiAobGluZVZpZXcubGluZSA9PSBsaW5lKVxuICAgICAgeyByZXR1cm4ge21hcDogbGluZVZpZXcubWVhc3VyZS5tYXAsIGNhY2hlOiBsaW5lVmlldy5tZWFzdXJlLmNhY2hlfSB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lVmlldy5yZXN0Lmxlbmd0aDsgaSsrKVxuICAgICAgeyBpZiAobGluZVZpZXcucmVzdFtpXSA9PSBsaW5lKVxuICAgICAgICB7IHJldHVybiB7bWFwOiBsaW5lVmlldy5tZWFzdXJlLm1hcHNbaV0sIGNhY2hlOiBsaW5lVmlldy5tZWFzdXJlLmNhY2hlc1tpXX0gfSB9XG4gICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgbGluZVZpZXcucmVzdC5sZW5ndGg7IGkkMSsrKVxuICAgICAgeyBpZiAobGluZU5vKGxpbmVWaWV3LnJlc3RbaSQxXSkgPiBsaW5lTilcbiAgICAgICAgeyByZXR1cm4ge21hcDogbGluZVZpZXcubWVhc3VyZS5tYXBzW2kkMV0sIGNhY2hlOiBsaW5lVmlldy5tZWFzdXJlLmNhY2hlc1tpJDFdLCBiZWZvcmU6IHRydWV9IH0gfVxuICB9XG5cbiAgLy8gUmVuZGVyIGEgbGluZSBpbnRvIHRoZSBoaWRkZW4gbm9kZSBkaXNwbGF5LmV4dGVybmFsTWVhc3VyZWQuIFVzZWRcbiAgLy8gd2hlbiBtZWFzdXJlbWVudCBpcyBuZWVkZWQgZm9yIGEgbGluZSB0aGF0J3Mgbm90IGluIHRoZSB2aWV3cG9ydC5cbiAgZnVuY3Rpb24gdXBkYXRlRXh0ZXJuYWxNZWFzdXJlbWVudChjbSwgbGluZSkge1xuICAgIGxpbmUgPSB2aXN1YWxMaW5lKGxpbmUpO1xuICAgIHZhciBsaW5lTiA9IGxpbmVObyhsaW5lKTtcbiAgICB2YXIgdmlldyA9IGNtLmRpc3BsYXkuZXh0ZXJuYWxNZWFzdXJlZCA9IG5ldyBMaW5lVmlldyhjbS5kb2MsIGxpbmUsIGxpbmVOKTtcbiAgICB2aWV3LmxpbmVOID0gbGluZU47XG4gICAgdmFyIGJ1aWx0ID0gdmlldy5idWlsdCA9IGJ1aWxkTGluZUNvbnRlbnQoY20sIHZpZXcpO1xuICAgIHZpZXcudGV4dCA9IGJ1aWx0LnByZTtcbiAgICByZW1vdmVDaGlsZHJlbkFuZEFkZChjbS5kaXNwbGF5LmxpbmVNZWFzdXJlLCBidWlsdC5wcmUpO1xuICAgIHJldHVybiB2aWV3XG4gIH1cblxuICAvLyBHZXQgYSB7dG9wLCBib3R0b20sIGxlZnQsIHJpZ2h0fSBib3ggKGluIGxpbmUtbG9jYWwgY29vcmRpbmF0ZXMpXG4gIC8vIGZvciBhIGdpdmVuIGNoYXJhY3Rlci5cbiAgZnVuY3Rpb24gbWVhc3VyZUNoYXIoY20sIGxpbmUsIGNoLCBiaWFzKSB7XG4gICAgcmV0dXJuIG1lYXN1cmVDaGFyUHJlcGFyZWQoY20sIHByZXBhcmVNZWFzdXJlRm9yTGluZShjbSwgbGluZSksIGNoLCBiaWFzKVxuICB9XG5cbiAgLy8gRmluZCBhIGxpbmUgdmlldyB0aGF0IGNvcnJlc3BvbmRzIHRvIHRoZSBnaXZlbiBsaW5lIG51bWJlci5cbiAgZnVuY3Rpb24gZmluZFZpZXdGb3JMaW5lKGNtLCBsaW5lTikge1xuICAgIGlmIChsaW5lTiA+PSBjbS5kaXNwbGF5LnZpZXdGcm9tICYmIGxpbmVOIDwgY20uZGlzcGxheS52aWV3VG8pXG4gICAgICB7IHJldHVybiBjbS5kaXNwbGF5LnZpZXdbZmluZFZpZXdJbmRleChjbSwgbGluZU4pXSB9XG4gICAgdmFyIGV4dCA9IGNtLmRpc3BsYXkuZXh0ZXJuYWxNZWFzdXJlZDtcbiAgICBpZiAoZXh0ICYmIGxpbmVOID49IGV4dC5saW5lTiAmJiBsaW5lTiA8IGV4dC5saW5lTiArIGV4dC5zaXplKVxuICAgICAgeyByZXR1cm4gZXh0IH1cbiAgfVxuXG4gIC8vIE1lYXN1cmVtZW50IGNhbiBiZSBzcGxpdCBpbiB0d28gc3RlcHMsIHRoZSBzZXQtdXAgd29yayB0aGF0XG4gIC8vIGFwcGxpZXMgdG8gdGhlIHdob2xlIGxpbmUsIGFuZCB0aGUgbWVhc3VyZW1lbnQgb2YgdGhlIGFjdHVhbFxuICAvLyBjaGFyYWN0ZXIuIEZ1bmN0aW9ucyBsaWtlIGNvb3Jkc0NoYXIsIHRoYXQgbmVlZCB0byBkbyBhIGxvdCBvZlxuICAvLyBtZWFzdXJlbWVudHMgaW4gYSByb3csIGNhbiB0aHVzIGVuc3VyZSB0aGF0IHRoZSBzZXQtdXAgd29yayBpc1xuICAvLyBvbmx5IGRvbmUgb25jZS5cbiAgZnVuY3Rpb24gcHJlcGFyZU1lYXN1cmVGb3JMaW5lKGNtLCBsaW5lKSB7XG4gICAgdmFyIGxpbmVOID0gbGluZU5vKGxpbmUpO1xuICAgIHZhciB2aWV3ID0gZmluZFZpZXdGb3JMaW5lKGNtLCBsaW5lTik7XG4gICAgaWYgKHZpZXcgJiYgIXZpZXcudGV4dCkge1xuICAgICAgdmlldyA9IG51bGw7XG4gICAgfSBlbHNlIGlmICh2aWV3ICYmIHZpZXcuY2hhbmdlcykge1xuICAgICAgdXBkYXRlTGluZUZvckNoYW5nZXMoY20sIHZpZXcsIGxpbmVOLCBnZXREaW1lbnNpb25zKGNtKSk7XG4gICAgICBjbS5jdXJPcC5mb3JjZVVwZGF0ZSA9IHRydWU7XG4gICAgfVxuICAgIGlmICghdmlldylcbiAgICAgIHsgdmlldyA9IHVwZGF0ZUV4dGVybmFsTWVhc3VyZW1lbnQoY20sIGxpbmUpOyB9XG5cbiAgICB2YXIgaW5mbyA9IG1hcEZyb21MaW5lVmlldyh2aWV3LCBsaW5lLCBsaW5lTik7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxpbmU6IGxpbmUsIHZpZXc6IHZpZXcsIHJlY3Q6IG51bGwsXG4gICAgICBtYXA6IGluZm8ubWFwLCBjYWNoZTogaW5mby5jYWNoZSwgYmVmb3JlOiBpbmZvLmJlZm9yZSxcbiAgICAgIGhhc0hlaWdodHM6IGZhbHNlXG4gICAgfVxuICB9XG5cbiAgLy8gR2l2ZW4gYSBwcmVwYXJlZCBtZWFzdXJlbWVudCBvYmplY3QsIG1lYXN1cmVzIHRoZSBwb3NpdGlvbiBvZiBhblxuICAvLyBhY3R1YWwgY2hhcmFjdGVyIChvciBmZXRjaGVzIGl0IGZyb20gdGhlIGNhY2hlKS5cbiAgZnVuY3Rpb24gbWVhc3VyZUNoYXJQcmVwYXJlZChjbSwgcHJlcGFyZWQsIGNoLCBiaWFzLCB2YXJIZWlnaHQpIHtcbiAgICBpZiAocHJlcGFyZWQuYmVmb3JlKSB7IGNoID0gLTE7IH1cbiAgICB2YXIga2V5ID0gY2ggKyAoYmlhcyB8fCBcIlwiKSwgZm91bmQ7XG4gICAgaWYgKHByZXBhcmVkLmNhY2hlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIGZvdW5kID0gcHJlcGFyZWQuY2FjaGVba2V5XTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFwcmVwYXJlZC5yZWN0KVxuICAgICAgICB7IHByZXBhcmVkLnJlY3QgPSBwcmVwYXJlZC52aWV3LnRleHQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7IH1cbiAgICAgIGlmICghcHJlcGFyZWQuaGFzSGVpZ2h0cykge1xuICAgICAgICBlbnN1cmVMaW5lSGVpZ2h0cyhjbSwgcHJlcGFyZWQudmlldywgcHJlcGFyZWQucmVjdCk7XG4gICAgICAgIHByZXBhcmVkLmhhc0hlaWdodHMgPSB0cnVlO1xuICAgICAgfVxuICAgICAgZm91bmQgPSBtZWFzdXJlQ2hhcklubmVyKGNtLCBwcmVwYXJlZCwgY2gsIGJpYXMpO1xuICAgICAgaWYgKCFmb3VuZC5ib2d1cykgeyBwcmVwYXJlZC5jYWNoZVtrZXldID0gZm91bmQ7IH1cbiAgICB9XG4gICAgcmV0dXJuIHtsZWZ0OiBmb3VuZC5sZWZ0LCByaWdodDogZm91bmQucmlnaHQsXG4gICAgICAgICAgICB0b3A6IHZhckhlaWdodCA/IGZvdW5kLnJ0b3AgOiBmb3VuZC50b3AsXG4gICAgICAgICAgICBib3R0b206IHZhckhlaWdodCA/IGZvdW5kLnJib3R0b20gOiBmb3VuZC5ib3R0b219XG4gIH1cblxuICB2YXIgbnVsbFJlY3QgPSB7bGVmdDogMCwgcmlnaHQ6IDAsIHRvcDogMCwgYm90dG9tOiAwfTtcblxuICBmdW5jdGlvbiBub2RlQW5kT2Zmc2V0SW5MaW5lTWFwKG1hcCwgY2gsIGJpYXMpIHtcbiAgICB2YXIgbm9kZSwgc3RhcnQsIGVuZCwgY29sbGFwc2UsIG1TdGFydCwgbUVuZDtcbiAgICAvLyBGaXJzdCwgc2VhcmNoIHRoZSBsaW5lIG1hcCBmb3IgdGhlIHRleHQgbm9kZSBjb3JyZXNwb25kaW5nIHRvLFxuICAgIC8vIG9yIGNsb3Nlc3QgdG8sIHRoZSB0YXJnZXQgY2hhcmFjdGVyLlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWFwLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICBtU3RhcnQgPSBtYXBbaV07XG4gICAgICBtRW5kID0gbWFwW2kgKyAxXTtcbiAgICAgIGlmIChjaCA8IG1TdGFydCkge1xuICAgICAgICBzdGFydCA9IDA7IGVuZCA9IDE7XG4gICAgICAgIGNvbGxhcHNlID0gXCJsZWZ0XCI7XG4gICAgICB9IGVsc2UgaWYgKGNoIDwgbUVuZCkge1xuICAgICAgICBzdGFydCA9IGNoIC0gbVN0YXJ0O1xuICAgICAgICBlbmQgPSBzdGFydCArIDE7XG4gICAgICB9IGVsc2UgaWYgKGkgPT0gbWFwLmxlbmd0aCAtIDMgfHwgY2ggPT0gbUVuZCAmJiBtYXBbaSArIDNdID4gY2gpIHtcbiAgICAgICAgZW5kID0gbUVuZCAtIG1TdGFydDtcbiAgICAgICAgc3RhcnQgPSBlbmQgLSAxO1xuICAgICAgICBpZiAoY2ggPj0gbUVuZCkgeyBjb2xsYXBzZSA9IFwicmlnaHRcIjsgfVxuICAgICAgfVxuICAgICAgaWYgKHN0YXJ0ICE9IG51bGwpIHtcbiAgICAgICAgbm9kZSA9IG1hcFtpICsgMl07XG4gICAgICAgIGlmIChtU3RhcnQgPT0gbUVuZCAmJiBiaWFzID09IChub2RlLmluc2VydExlZnQgPyBcImxlZnRcIiA6IFwicmlnaHRcIikpXG4gICAgICAgICAgeyBjb2xsYXBzZSA9IGJpYXM7IH1cbiAgICAgICAgaWYgKGJpYXMgPT0gXCJsZWZ0XCIgJiYgc3RhcnQgPT0gMClcbiAgICAgICAgICB7IHdoaWxlIChpICYmIG1hcFtpIC0gMl0gPT0gbWFwW2kgLSAzXSAmJiBtYXBbaSAtIDFdLmluc2VydExlZnQpIHtcbiAgICAgICAgICAgIG5vZGUgPSBtYXBbKGkgLT0gMykgKyAyXTtcbiAgICAgICAgICAgIGNvbGxhcHNlID0gXCJsZWZ0XCI7XG4gICAgICAgICAgfSB9XG4gICAgICAgIGlmIChiaWFzID09IFwicmlnaHRcIiAmJiBzdGFydCA9PSBtRW5kIC0gbVN0YXJ0KVxuICAgICAgICAgIHsgd2hpbGUgKGkgPCBtYXAubGVuZ3RoIC0gMyAmJiBtYXBbaSArIDNdID09IG1hcFtpICsgNF0gJiYgIW1hcFtpICsgNV0uaW5zZXJ0TGVmdCkge1xuICAgICAgICAgICAgbm9kZSA9IG1hcFsoaSArPSAzKSArIDJdO1xuICAgICAgICAgICAgY29sbGFwc2UgPSBcInJpZ2h0XCI7XG4gICAgICAgICAgfSB9XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7bm9kZTogbm9kZSwgc3RhcnQ6IHN0YXJ0LCBlbmQ6IGVuZCwgY29sbGFwc2U6IGNvbGxhcHNlLCBjb3ZlclN0YXJ0OiBtU3RhcnQsIGNvdmVyRW5kOiBtRW5kfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0VXNlZnVsUmVjdChyZWN0cywgYmlhcykge1xuICAgIHZhciByZWN0ID0gbnVsbFJlY3Q7XG4gICAgaWYgKGJpYXMgPT0gXCJsZWZ0XCIpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCByZWN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKChyZWN0ID0gcmVjdHNbaV0pLmxlZnQgIT0gcmVjdC5yaWdodCkgeyBicmVhayB9XG4gICAgfSB9IGVsc2UgeyBmb3IgKHZhciBpJDEgPSByZWN0cy5sZW5ndGggLSAxOyBpJDEgPj0gMDsgaSQxLS0pIHtcbiAgICAgIGlmICgocmVjdCA9IHJlY3RzW2kkMV0pLmxlZnQgIT0gcmVjdC5yaWdodCkgeyBicmVhayB9XG4gICAgfSB9XG4gICAgcmV0dXJuIHJlY3RcbiAgfVxuXG4gIGZ1bmN0aW9uIG1lYXN1cmVDaGFySW5uZXIoY20sIHByZXBhcmVkLCBjaCwgYmlhcykge1xuICAgIHZhciBwbGFjZSA9IG5vZGVBbmRPZmZzZXRJbkxpbmVNYXAocHJlcGFyZWQubWFwLCBjaCwgYmlhcyk7XG4gICAgdmFyIG5vZGUgPSBwbGFjZS5ub2RlLCBzdGFydCA9IHBsYWNlLnN0YXJ0LCBlbmQgPSBwbGFjZS5lbmQsIGNvbGxhcHNlID0gcGxhY2UuY29sbGFwc2U7XG5cbiAgICB2YXIgcmVjdDtcbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAzKSB7IC8vIElmIGl0IGlzIGEgdGV4dCBub2RlLCB1c2UgYSByYW5nZSB0byByZXRyaWV2ZSB0aGUgY29vcmRpbmF0ZXMuXG4gICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCA0OyBpJDErKykgeyAvLyBSZXRyeSBhIG1heGltdW0gb2YgNCB0aW1lcyB3aGVuIG5vbnNlbnNlIHJlY3RhbmdsZXMgYXJlIHJldHVybmVkXG4gICAgICAgIHdoaWxlIChzdGFydCAmJiBpc0V4dGVuZGluZ0NoYXIocHJlcGFyZWQubGluZS50ZXh0LmNoYXJBdChwbGFjZS5jb3ZlclN0YXJ0ICsgc3RhcnQpKSkgeyAtLXN0YXJ0OyB9XG4gICAgICAgIHdoaWxlIChwbGFjZS5jb3ZlclN0YXJ0ICsgZW5kIDwgcGxhY2UuY292ZXJFbmQgJiYgaXNFeHRlbmRpbmdDaGFyKHByZXBhcmVkLmxpbmUudGV4dC5jaGFyQXQocGxhY2UuY292ZXJTdGFydCArIGVuZCkpKSB7ICsrZW5kOyB9XG4gICAgICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDwgOSAmJiBzdGFydCA9PSAwICYmIGVuZCA9PSBwbGFjZS5jb3ZlckVuZCAtIHBsYWNlLmNvdmVyU3RhcnQpXG4gICAgICAgICAgeyByZWN0ID0gbm9kZS5wYXJlbnROb2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpOyB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB7IHJlY3QgPSBnZXRVc2VmdWxSZWN0KHJhbmdlKG5vZGUsIHN0YXJ0LCBlbmQpLmdldENsaWVudFJlY3RzKCksIGJpYXMpOyB9XG4gICAgICAgIGlmIChyZWN0LmxlZnQgfHwgcmVjdC5yaWdodCB8fCBzdGFydCA9PSAwKSB7IGJyZWFrIH1cbiAgICAgICAgZW5kID0gc3RhcnQ7XG4gICAgICAgIHN0YXJ0ID0gc3RhcnQgLSAxO1xuICAgICAgICBjb2xsYXBzZSA9IFwicmlnaHRcIjtcbiAgICAgIH1cbiAgICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDwgMTEpIHsgcmVjdCA9IG1heWJlVXBkYXRlUmVjdEZvclpvb21pbmcoY20uZGlzcGxheS5tZWFzdXJlLCByZWN0KTsgfVxuICAgIH0gZWxzZSB7IC8vIElmIGl0IGlzIGEgd2lkZ2V0LCBzaW1wbHkgZ2V0IHRoZSBib3ggZm9yIHRoZSB3aG9sZSB3aWRnZXQuXG4gICAgICBpZiAoc3RhcnQgPiAwKSB7IGNvbGxhcHNlID0gYmlhcyA9IFwicmlnaHRcIjsgfVxuICAgICAgdmFyIHJlY3RzO1xuICAgICAgaWYgKGNtLm9wdGlvbnMubGluZVdyYXBwaW5nICYmIChyZWN0cyA9IG5vZGUuZ2V0Q2xpZW50UmVjdHMoKSkubGVuZ3RoID4gMSlcbiAgICAgICAgeyByZWN0ID0gcmVjdHNbYmlhcyA9PSBcInJpZ2h0XCIgPyByZWN0cy5sZW5ndGggLSAxIDogMF07IH1cbiAgICAgIGVsc2VcbiAgICAgICAgeyByZWN0ID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTsgfVxuICAgIH1cbiAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8IDkgJiYgIXN0YXJ0ICYmICghcmVjdCB8fCAhcmVjdC5sZWZ0ICYmICFyZWN0LnJpZ2h0KSkge1xuICAgICAgdmFyIHJTcGFuID0gbm9kZS5wYXJlbnROb2RlLmdldENsaWVudFJlY3RzKClbMF07XG4gICAgICBpZiAoclNwYW4pXG4gICAgICAgIHsgcmVjdCA9IHtsZWZ0OiByU3Bhbi5sZWZ0LCByaWdodDogclNwYW4ubGVmdCArIGNoYXJXaWR0aChjbS5kaXNwbGF5KSwgdG9wOiByU3Bhbi50b3AsIGJvdHRvbTogclNwYW4uYm90dG9tfTsgfVxuICAgICAgZWxzZVxuICAgICAgICB7IHJlY3QgPSBudWxsUmVjdDsgfVxuICAgIH1cblxuICAgIHZhciBydG9wID0gcmVjdC50b3AgLSBwcmVwYXJlZC5yZWN0LnRvcCwgcmJvdCA9IHJlY3QuYm90dG9tIC0gcHJlcGFyZWQucmVjdC50b3A7XG4gICAgdmFyIG1pZCA9IChydG9wICsgcmJvdCkgLyAyO1xuICAgIHZhciBoZWlnaHRzID0gcHJlcGFyZWQudmlldy5tZWFzdXJlLmhlaWdodHM7XG4gICAgdmFyIGkgPSAwO1xuICAgIGZvciAoOyBpIDwgaGVpZ2h0cy5sZW5ndGggLSAxOyBpKyspXG4gICAgICB7IGlmIChtaWQgPCBoZWlnaHRzW2ldKSB7IGJyZWFrIH0gfVxuICAgIHZhciB0b3AgPSBpID8gaGVpZ2h0c1tpIC0gMV0gOiAwLCBib3QgPSBoZWlnaHRzW2ldO1xuICAgIHZhciByZXN1bHQgPSB7bGVmdDogKGNvbGxhcHNlID09IFwicmlnaHRcIiA/IHJlY3QucmlnaHQgOiByZWN0LmxlZnQpIC0gcHJlcGFyZWQucmVjdC5sZWZ0LFxuICAgICAgICAgICAgICAgICAgcmlnaHQ6IChjb2xsYXBzZSA9PSBcImxlZnRcIiA/IHJlY3QubGVmdCA6IHJlY3QucmlnaHQpIC0gcHJlcGFyZWQucmVjdC5sZWZ0LFxuICAgICAgICAgICAgICAgICAgdG9wOiB0b3AsIGJvdHRvbTogYm90fTtcbiAgICBpZiAoIXJlY3QubGVmdCAmJiAhcmVjdC5yaWdodCkgeyByZXN1bHQuYm9ndXMgPSB0cnVlOyB9XG4gICAgaWYgKCFjbS5vcHRpb25zLnNpbmdsZUN1cnNvckhlaWdodFBlckxpbmUpIHsgcmVzdWx0LnJ0b3AgPSBydG9wOyByZXN1bHQucmJvdHRvbSA9IHJib3Q7IH1cblxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIC8vIFdvcmsgYXJvdW5kIHByb2JsZW0gd2l0aCBib3VuZGluZyBjbGllbnQgcmVjdHMgb24gcmFuZ2VzIGJlaW5nXG4gIC8vIHJldHVybmVkIGluY29ycmVjdGx5IHdoZW4gem9vbWVkIG9uIElFMTAgYW5kIGJlbG93LlxuICBmdW5jdGlvbiBtYXliZVVwZGF0ZVJlY3RGb3Jab29taW5nKG1lYXN1cmUsIHJlY3QpIHtcbiAgICBpZiAoIXdpbmRvdy5zY3JlZW4gfHwgc2NyZWVuLmxvZ2ljYWxYRFBJID09IG51bGwgfHxcbiAgICAgICAgc2NyZWVuLmxvZ2ljYWxYRFBJID09IHNjcmVlbi5kZXZpY2VYRFBJIHx8ICFoYXNCYWRab29tZWRSZWN0cyhtZWFzdXJlKSlcbiAgICAgIHsgcmV0dXJuIHJlY3QgfVxuICAgIHZhciBzY2FsZVggPSBzY3JlZW4ubG9naWNhbFhEUEkgLyBzY3JlZW4uZGV2aWNlWERQSTtcbiAgICB2YXIgc2NhbGVZID0gc2NyZWVuLmxvZ2ljYWxZRFBJIC8gc2NyZWVuLmRldmljZVlEUEk7XG4gICAgcmV0dXJuIHtsZWZ0OiByZWN0LmxlZnQgKiBzY2FsZVgsIHJpZ2h0OiByZWN0LnJpZ2h0ICogc2NhbGVYLFxuICAgICAgICAgICAgdG9wOiByZWN0LnRvcCAqIHNjYWxlWSwgYm90dG9tOiByZWN0LmJvdHRvbSAqIHNjYWxlWX1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFyTGluZU1lYXN1cmVtZW50Q2FjaGVGb3IobGluZVZpZXcpIHtcbiAgICBpZiAobGluZVZpZXcubWVhc3VyZSkge1xuICAgICAgbGluZVZpZXcubWVhc3VyZS5jYWNoZSA9IHt9O1xuICAgICAgbGluZVZpZXcubWVhc3VyZS5oZWlnaHRzID0gbnVsbDtcbiAgICAgIGlmIChsaW5lVmlldy5yZXN0KSB7IGZvciAodmFyIGkgPSAwOyBpIDwgbGluZVZpZXcucmVzdC5sZW5ndGg7IGkrKylcbiAgICAgICAgeyBsaW5lVmlldy5tZWFzdXJlLmNhY2hlc1tpXSA9IHt9OyB9IH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjbGVhckxpbmVNZWFzdXJlbWVudENhY2hlKGNtKSB7XG4gICAgY20uZGlzcGxheS5leHRlcm5hbE1lYXN1cmUgPSBudWxsO1xuICAgIHJlbW92ZUNoaWxkcmVuKGNtLmRpc3BsYXkubGluZU1lYXN1cmUpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY20uZGlzcGxheS52aWV3Lmxlbmd0aDsgaSsrKVxuICAgICAgeyBjbGVhckxpbmVNZWFzdXJlbWVudENhY2hlRm9yKGNtLmRpc3BsYXkudmlld1tpXSk7IH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFyQ2FjaGVzKGNtKSB7XG4gICAgY2xlYXJMaW5lTWVhc3VyZW1lbnRDYWNoZShjbSk7XG4gICAgY20uZGlzcGxheS5jYWNoZWRDaGFyV2lkdGggPSBjbS5kaXNwbGF5LmNhY2hlZFRleHRIZWlnaHQgPSBjbS5kaXNwbGF5LmNhY2hlZFBhZGRpbmdIID0gbnVsbDtcbiAgICBpZiAoIWNtLm9wdGlvbnMubGluZVdyYXBwaW5nKSB7IGNtLmRpc3BsYXkubWF4TGluZUNoYW5nZWQgPSB0cnVlOyB9XG4gICAgY20uZGlzcGxheS5saW5lTnVtQ2hhcnMgPSBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFnZVNjcm9sbFgoKSB7XG4gICAgLy8gV29yayBhcm91bmQgaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDg5MjA2XG4gICAgLy8gd2hpY2ggY2F1c2VzIHBhZ2VfT2Zmc2V0IGFuZCBib3VuZGluZyBjbGllbnQgcmVjdHMgdG8gdXNlXG4gICAgLy8gZGlmZmVyZW50IHJlZmVyZW5jZSB2aWV3cG9ydHMgYW5kIGludmFsaWRhdGUgb3VyIGNhbGN1bGF0aW9ucy5cbiAgICBpZiAoY2hyb21lICYmIGFuZHJvaWQpIHsgcmV0dXJuIC0oZG9jdW1lbnQuYm9keS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0IC0gcGFyc2VJbnQoZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5ib2R5KS5tYXJnaW5MZWZ0KSkgfVxuICAgIHJldHVybiB3aW5kb3cucGFnZVhPZmZzZXQgfHwgKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCB8fCBkb2N1bWVudC5ib2R5KS5zY3JvbGxMZWZ0XG4gIH1cbiAgZnVuY3Rpb24gcGFnZVNjcm9sbFkoKSB7XG4gICAgaWYgKGNocm9tZSAmJiBhbmRyb2lkKSB7IHJldHVybiAtKGRvY3VtZW50LmJvZHkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wIC0gcGFyc2VJbnQoZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5ib2R5KS5tYXJnaW5Ub3ApKSB9XG4gICAgcmV0dXJuIHdpbmRvdy5wYWdlWU9mZnNldCB8fCAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50IHx8IGRvY3VtZW50LmJvZHkpLnNjcm9sbFRvcFxuICB9XG5cbiAgZnVuY3Rpb24gd2lkZ2V0VG9wSGVpZ2h0KGxpbmVPYmopIHtcbiAgICB2YXIgaGVpZ2h0ID0gMDtcbiAgICBpZiAobGluZU9iai53aWRnZXRzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgbGluZU9iai53aWRnZXRzLmxlbmd0aDsgKytpKSB7IGlmIChsaW5lT2JqLndpZGdldHNbaV0uYWJvdmUpXG4gICAgICB7IGhlaWdodCArPSB3aWRnZXRIZWlnaHQobGluZU9iai53aWRnZXRzW2ldKTsgfSB9IH1cbiAgICByZXR1cm4gaGVpZ2h0XG4gIH1cblxuICAvLyBDb252ZXJ0cyBhIHt0b3AsIGJvdHRvbSwgbGVmdCwgcmlnaHR9IGJveCBmcm9tIGxpbmUtbG9jYWxcbiAgLy8gY29vcmRpbmF0ZXMgaW50byBhbm90aGVyIGNvb3JkaW5hdGUgc3lzdGVtLiBDb250ZXh0IG1heSBiZSBvbmUgb2ZcbiAgLy8gXCJsaW5lXCIsIFwiZGl2XCIgKGRpc3BsYXkubGluZURpdiksIFwibG9jYWxcIi4vbnVsbCAoZWRpdG9yKSwgXCJ3aW5kb3dcIixcbiAgLy8gb3IgXCJwYWdlXCIuXG4gIGZ1bmN0aW9uIGludG9Db29yZFN5c3RlbShjbSwgbGluZU9iaiwgcmVjdCwgY29udGV4dCwgaW5jbHVkZVdpZGdldHMpIHtcbiAgICBpZiAoIWluY2x1ZGVXaWRnZXRzKSB7XG4gICAgICB2YXIgaGVpZ2h0ID0gd2lkZ2V0VG9wSGVpZ2h0KGxpbmVPYmopO1xuICAgICAgcmVjdC50b3AgKz0gaGVpZ2h0OyByZWN0LmJvdHRvbSArPSBoZWlnaHQ7XG4gICAgfVxuICAgIGlmIChjb250ZXh0ID09IFwibGluZVwiKSB7IHJldHVybiByZWN0IH1cbiAgICBpZiAoIWNvbnRleHQpIHsgY29udGV4dCA9IFwibG9jYWxcIjsgfVxuICAgIHZhciB5T2ZmID0gaGVpZ2h0QXRMaW5lKGxpbmVPYmopO1xuICAgIGlmIChjb250ZXh0ID09IFwibG9jYWxcIikgeyB5T2ZmICs9IHBhZGRpbmdUb3AoY20uZGlzcGxheSk7IH1cbiAgICBlbHNlIHsgeU9mZiAtPSBjbS5kaXNwbGF5LnZpZXdPZmZzZXQ7IH1cbiAgICBpZiAoY29udGV4dCA9PSBcInBhZ2VcIiB8fCBjb250ZXh0ID09IFwid2luZG93XCIpIHtcbiAgICAgIHZhciBsT2ZmID0gY20uZGlzcGxheS5saW5lU3BhY2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB5T2ZmICs9IGxPZmYudG9wICsgKGNvbnRleHQgPT0gXCJ3aW5kb3dcIiA/IDAgOiBwYWdlU2Nyb2xsWSgpKTtcbiAgICAgIHZhciB4T2ZmID0gbE9mZi5sZWZ0ICsgKGNvbnRleHQgPT0gXCJ3aW5kb3dcIiA/IDAgOiBwYWdlU2Nyb2xsWCgpKTtcbiAgICAgIHJlY3QubGVmdCArPSB4T2ZmOyByZWN0LnJpZ2h0ICs9IHhPZmY7XG4gICAgfVxuICAgIHJlY3QudG9wICs9IHlPZmY7IHJlY3QuYm90dG9tICs9IHlPZmY7XG4gICAgcmV0dXJuIHJlY3RcbiAgfVxuXG4gIC8vIENvdmVydHMgYSBib3ggZnJvbSBcImRpdlwiIGNvb3JkcyB0byBhbm90aGVyIGNvb3JkaW5hdGUgc3lzdGVtLlxuICAvLyBDb250ZXh0IG1heSBiZSBcIndpbmRvd1wiLCBcInBhZ2VcIiwgXCJkaXZcIiwgb3IgXCJsb2NhbFwiLi9udWxsLlxuICBmdW5jdGlvbiBmcm9tQ29vcmRTeXN0ZW0oY20sIGNvb3JkcywgY29udGV4dCkge1xuICAgIGlmIChjb250ZXh0ID09IFwiZGl2XCIpIHsgcmV0dXJuIGNvb3JkcyB9XG4gICAgdmFyIGxlZnQgPSBjb29yZHMubGVmdCwgdG9wID0gY29vcmRzLnRvcDtcbiAgICAvLyBGaXJzdCBtb3ZlIGludG8gXCJwYWdlXCIgY29vcmRpbmF0ZSBzeXN0ZW1cbiAgICBpZiAoY29udGV4dCA9PSBcInBhZ2VcIikge1xuICAgICAgbGVmdCAtPSBwYWdlU2Nyb2xsWCgpO1xuICAgICAgdG9wIC09IHBhZ2VTY3JvbGxZKCk7XG4gICAgfSBlbHNlIGlmIChjb250ZXh0ID09IFwibG9jYWxcIiB8fCAhY29udGV4dCkge1xuICAgICAgdmFyIGxvY2FsQm94ID0gY20uZGlzcGxheS5zaXplci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGxlZnQgKz0gbG9jYWxCb3gubGVmdDtcbiAgICAgIHRvcCArPSBsb2NhbEJveC50b3A7XG4gICAgfVxuXG4gICAgdmFyIGxpbmVTcGFjZUJveCA9IGNtLmRpc3BsYXkubGluZVNwYWNlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJldHVybiB7bGVmdDogbGVmdCAtIGxpbmVTcGFjZUJveC5sZWZ0LCB0b3A6IHRvcCAtIGxpbmVTcGFjZUJveC50b3B9XG4gIH1cblxuICBmdW5jdGlvbiBjaGFyQ29vcmRzKGNtLCBwb3MsIGNvbnRleHQsIGxpbmVPYmosIGJpYXMpIHtcbiAgICBpZiAoIWxpbmVPYmopIHsgbGluZU9iaiA9IGdldExpbmUoY20uZG9jLCBwb3MubGluZSk7IH1cbiAgICByZXR1cm4gaW50b0Nvb3JkU3lzdGVtKGNtLCBsaW5lT2JqLCBtZWFzdXJlQ2hhcihjbSwgbGluZU9iaiwgcG9zLmNoLCBiaWFzKSwgY29udGV4dClcbiAgfVxuXG4gIC8vIFJldHVybnMgYSBib3ggZm9yIGEgZ2l2ZW4gY3Vyc29yIHBvc2l0aW9uLCB3aGljaCBtYXkgaGF2ZSBhblxuICAvLyAnb3RoZXInIHByb3BlcnR5IGNvbnRhaW5pbmcgdGhlIHBvc2l0aW9uIG9mIHRoZSBzZWNvbmRhcnkgY3Vyc29yXG4gIC8vIG9uIGEgYmlkaSBib3VuZGFyeS5cbiAgLy8gQSBjdXJzb3IgUG9zKGxpbmUsIGNoYXIsIFwiYmVmb3JlXCIpIGlzIG9uIHRoZSBzYW1lIHZpc3VhbCBsaW5lIGFzIGBjaGFyIC0gMWBcbiAgLy8gYW5kIGFmdGVyIGBjaGFyIC0gMWAgaW4gd3JpdGluZyBvcmRlciBvZiBgY2hhciAtIDFgXG4gIC8vIEEgY3Vyc29yIFBvcyhsaW5lLCBjaGFyLCBcImFmdGVyXCIpIGlzIG9uIHRoZSBzYW1lIHZpc3VhbCBsaW5lIGFzIGBjaGFyYFxuICAvLyBhbmQgYmVmb3JlIGBjaGFyYCBpbiB3cml0aW5nIG9yZGVyIG9mIGBjaGFyYFxuICAvLyBFeGFtcGxlcyAodXBwZXItY2FzZSBsZXR0ZXJzIGFyZSBSVEwsIGxvd2VyLWNhc2UgYXJlIExUUik6XG4gIC8vICAgICBQb3MoMCwgMSwgLi4uKVxuICAvLyAgICAgYmVmb3JlICAgYWZ0ZXJcbiAgLy8gYWIgICAgIGF8YiAgICAgYXxiXG4gIC8vIGFCICAgICBhfEIgICAgIGFCfFxuICAvLyBBYiAgICAgfEFiICAgICBBfGJcbiAgLy8gQUIgICAgIEJ8QSAgICAgQnxBXG4gIC8vIEV2ZXJ5IHBvc2l0aW9uIGFmdGVyIHRoZSBsYXN0IGNoYXJhY3RlciBvbiBhIGxpbmUgaXMgY29uc2lkZXJlZCB0byBzdGlja1xuICAvLyB0byB0aGUgbGFzdCBjaGFyYWN0ZXIgb24gdGhlIGxpbmUuXG4gIGZ1bmN0aW9uIGN1cnNvckNvb3JkcyhjbSwgcG9zLCBjb250ZXh0LCBsaW5lT2JqLCBwcmVwYXJlZE1lYXN1cmUsIHZhckhlaWdodCkge1xuICAgIGxpbmVPYmogPSBsaW5lT2JqIHx8IGdldExpbmUoY20uZG9jLCBwb3MubGluZSk7XG4gICAgaWYgKCFwcmVwYXJlZE1lYXN1cmUpIHsgcHJlcGFyZWRNZWFzdXJlID0gcHJlcGFyZU1lYXN1cmVGb3JMaW5lKGNtLCBsaW5lT2JqKTsgfVxuICAgIGZ1bmN0aW9uIGdldChjaCwgcmlnaHQpIHtcbiAgICAgIHZhciBtID0gbWVhc3VyZUNoYXJQcmVwYXJlZChjbSwgcHJlcGFyZWRNZWFzdXJlLCBjaCwgcmlnaHQgPyBcInJpZ2h0XCIgOiBcImxlZnRcIiwgdmFySGVpZ2h0KTtcbiAgICAgIGlmIChyaWdodCkgeyBtLmxlZnQgPSBtLnJpZ2h0OyB9IGVsc2UgeyBtLnJpZ2h0ID0gbS5sZWZ0OyB9XG4gICAgICByZXR1cm4gaW50b0Nvb3JkU3lzdGVtKGNtLCBsaW5lT2JqLCBtLCBjb250ZXh0KVxuICAgIH1cbiAgICB2YXIgb3JkZXIgPSBnZXRPcmRlcihsaW5lT2JqLCBjbS5kb2MuZGlyZWN0aW9uKSwgY2ggPSBwb3MuY2gsIHN0aWNreSA9IHBvcy5zdGlja3k7XG4gICAgaWYgKGNoID49IGxpbmVPYmoudGV4dC5sZW5ndGgpIHtcbiAgICAgIGNoID0gbGluZU9iai50ZXh0Lmxlbmd0aDtcbiAgICAgIHN0aWNreSA9IFwiYmVmb3JlXCI7XG4gICAgfSBlbHNlIGlmIChjaCA8PSAwKSB7XG4gICAgICBjaCA9IDA7XG4gICAgICBzdGlja3kgPSBcImFmdGVyXCI7XG4gICAgfVxuICAgIGlmICghb3JkZXIpIHsgcmV0dXJuIGdldChzdGlja3kgPT0gXCJiZWZvcmVcIiA/IGNoIC0gMSA6IGNoLCBzdGlja3kgPT0gXCJiZWZvcmVcIikgfVxuXG4gICAgZnVuY3Rpb24gZ2V0QmlkaShjaCwgcGFydFBvcywgaW52ZXJ0KSB7XG4gICAgICB2YXIgcGFydCA9IG9yZGVyW3BhcnRQb3NdLCByaWdodCA9IHBhcnQubGV2ZWwgPT0gMTtcbiAgICAgIHJldHVybiBnZXQoaW52ZXJ0ID8gY2ggLSAxIDogY2gsIHJpZ2h0ICE9IGludmVydClcbiAgICB9XG4gICAgdmFyIHBhcnRQb3MgPSBnZXRCaWRpUGFydEF0KG9yZGVyLCBjaCwgc3RpY2t5KTtcbiAgICB2YXIgb3RoZXIgPSBiaWRpT3RoZXI7XG4gICAgdmFyIHZhbCA9IGdldEJpZGkoY2gsIHBhcnRQb3MsIHN0aWNreSA9PSBcImJlZm9yZVwiKTtcbiAgICBpZiAob3RoZXIgIT0gbnVsbCkgeyB2YWwub3RoZXIgPSBnZXRCaWRpKGNoLCBvdGhlciwgc3RpY2t5ICE9IFwiYmVmb3JlXCIpOyB9XG4gICAgcmV0dXJuIHZhbFxuICB9XG5cbiAgLy8gVXNlZCB0byBjaGVhcGx5IGVzdGltYXRlIHRoZSBjb29yZGluYXRlcyBmb3IgYSBwb3NpdGlvbi4gVXNlZCBmb3JcbiAgLy8gaW50ZXJtZWRpYXRlIHNjcm9sbCB1cGRhdGVzLlxuICBmdW5jdGlvbiBlc3RpbWF0ZUNvb3JkcyhjbSwgcG9zKSB7XG4gICAgdmFyIGxlZnQgPSAwO1xuICAgIHBvcyA9IGNsaXBQb3MoY20uZG9jLCBwb3MpO1xuICAgIGlmICghY20ub3B0aW9ucy5saW5lV3JhcHBpbmcpIHsgbGVmdCA9IGNoYXJXaWR0aChjbS5kaXNwbGF5KSAqIHBvcy5jaDsgfVxuICAgIHZhciBsaW5lT2JqID0gZ2V0TGluZShjbS5kb2MsIHBvcy5saW5lKTtcbiAgICB2YXIgdG9wID0gaGVpZ2h0QXRMaW5lKGxpbmVPYmopICsgcGFkZGluZ1RvcChjbS5kaXNwbGF5KTtcbiAgICByZXR1cm4ge2xlZnQ6IGxlZnQsIHJpZ2h0OiBsZWZ0LCB0b3A6IHRvcCwgYm90dG9tOiB0b3AgKyBsaW5lT2JqLmhlaWdodH1cbiAgfVxuXG4gIC8vIFBvc2l0aW9ucyByZXR1cm5lZCBieSBjb29yZHNDaGFyIGNvbnRhaW4gc29tZSBleHRyYSBpbmZvcm1hdGlvbi5cbiAgLy8geFJlbCBpcyB0aGUgcmVsYXRpdmUgeCBwb3NpdGlvbiBvZiB0aGUgaW5wdXQgY29vcmRpbmF0ZXMgY29tcGFyZWRcbiAgLy8gdG8gdGhlIGZvdW5kIHBvc2l0aW9uIChzbyB4UmVsID4gMCBtZWFucyB0aGUgY29vcmRpbmF0ZXMgYXJlIHRvXG4gIC8vIHRoZSByaWdodCBvZiB0aGUgY2hhcmFjdGVyIHBvc2l0aW9uLCBmb3IgZXhhbXBsZSkuIFdoZW4gb3V0c2lkZVxuICAvLyBpcyB0cnVlLCB0aGF0IG1lYW5zIHRoZSBjb29yZGluYXRlcyBsaWUgb3V0c2lkZSB0aGUgbGluZSdzXG4gIC8vIHZlcnRpY2FsIHJhbmdlLlxuICBmdW5jdGlvbiBQb3NXaXRoSW5mbyhsaW5lLCBjaCwgc3RpY2t5LCBvdXRzaWRlLCB4UmVsKSB7XG4gICAgdmFyIHBvcyA9IFBvcyhsaW5lLCBjaCwgc3RpY2t5KTtcbiAgICBwb3MueFJlbCA9IHhSZWw7XG4gICAgaWYgKG91dHNpZGUpIHsgcG9zLm91dHNpZGUgPSBvdXRzaWRlOyB9XG4gICAgcmV0dXJuIHBvc1xuICB9XG5cbiAgLy8gQ29tcHV0ZSB0aGUgY2hhcmFjdGVyIHBvc2l0aW9uIGNsb3Nlc3QgdG8gdGhlIGdpdmVuIGNvb3JkaW5hdGVzLlxuICAvLyBJbnB1dCBtdXN0IGJlIGxpbmVTcGFjZS1sb2NhbCAoXCJkaXZcIiBjb29yZGluYXRlIHN5c3RlbSkuXG4gIGZ1bmN0aW9uIGNvb3Jkc0NoYXIoY20sIHgsIHkpIHtcbiAgICB2YXIgZG9jID0gY20uZG9jO1xuICAgIHkgKz0gY20uZGlzcGxheS52aWV3T2Zmc2V0O1xuICAgIGlmICh5IDwgMCkgeyByZXR1cm4gUG9zV2l0aEluZm8oZG9jLmZpcnN0LCAwLCBudWxsLCAtMSwgLTEpIH1cbiAgICB2YXIgbGluZU4gPSBsaW5lQXRIZWlnaHQoZG9jLCB5KSwgbGFzdCA9IGRvYy5maXJzdCArIGRvYy5zaXplIC0gMTtcbiAgICBpZiAobGluZU4gPiBsYXN0KVxuICAgICAgeyByZXR1cm4gUG9zV2l0aEluZm8oZG9jLmZpcnN0ICsgZG9jLnNpemUgLSAxLCBnZXRMaW5lKGRvYywgbGFzdCkudGV4dC5sZW5ndGgsIG51bGwsIDEsIDEpIH1cbiAgICBpZiAoeCA8IDApIHsgeCA9IDA7IH1cblxuICAgIHZhciBsaW5lT2JqID0gZ2V0TGluZShkb2MsIGxpbmVOKTtcbiAgICBmb3IgKDs7KSB7XG4gICAgICB2YXIgZm91bmQgPSBjb29yZHNDaGFySW5uZXIoY20sIGxpbmVPYmosIGxpbmVOLCB4LCB5KTtcbiAgICAgIHZhciBjb2xsYXBzZWQgPSBjb2xsYXBzZWRTcGFuQXJvdW5kKGxpbmVPYmosIGZvdW5kLmNoICsgKGZvdW5kLnhSZWwgPiAwIHx8IGZvdW5kLm91dHNpZGUgPiAwID8gMSA6IDApKTtcbiAgICAgIGlmICghY29sbGFwc2VkKSB7IHJldHVybiBmb3VuZCB9XG4gICAgICB2YXIgcmFuZ2VFbmQgPSBjb2xsYXBzZWQuZmluZCgxKTtcbiAgICAgIGlmIChyYW5nZUVuZC5saW5lID09IGxpbmVOKSB7IHJldHVybiByYW5nZUVuZCB9XG4gICAgICBsaW5lT2JqID0gZ2V0TGluZShkb2MsIGxpbmVOID0gcmFuZ2VFbmQubGluZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gd3JhcHBlZExpbmVFeHRlbnQoY20sIGxpbmVPYmosIHByZXBhcmVkTWVhc3VyZSwgeSkge1xuICAgIHkgLT0gd2lkZ2V0VG9wSGVpZ2h0KGxpbmVPYmopO1xuICAgIHZhciBlbmQgPSBsaW5lT2JqLnRleHQubGVuZ3RoO1xuICAgIHZhciBiZWdpbiA9IGZpbmRGaXJzdChmdW5jdGlvbiAoY2gpIHsgcmV0dXJuIG1lYXN1cmVDaGFyUHJlcGFyZWQoY20sIHByZXBhcmVkTWVhc3VyZSwgY2ggLSAxKS5ib3R0b20gPD0geTsgfSwgZW5kLCAwKTtcbiAgICBlbmQgPSBmaW5kRmlyc3QoZnVuY3Rpb24gKGNoKSB7IHJldHVybiBtZWFzdXJlQ2hhclByZXBhcmVkKGNtLCBwcmVwYXJlZE1lYXN1cmUsIGNoKS50b3AgPiB5OyB9LCBiZWdpbiwgZW5kKTtcbiAgICByZXR1cm4ge2JlZ2luOiBiZWdpbiwgZW5kOiBlbmR9XG4gIH1cblxuICBmdW5jdGlvbiB3cmFwcGVkTGluZUV4dGVudENoYXIoY20sIGxpbmVPYmosIHByZXBhcmVkTWVhc3VyZSwgdGFyZ2V0KSB7XG4gICAgaWYgKCFwcmVwYXJlZE1lYXN1cmUpIHsgcHJlcGFyZWRNZWFzdXJlID0gcHJlcGFyZU1lYXN1cmVGb3JMaW5lKGNtLCBsaW5lT2JqKTsgfVxuICAgIHZhciB0YXJnZXRUb3AgPSBpbnRvQ29vcmRTeXN0ZW0oY20sIGxpbmVPYmosIG1lYXN1cmVDaGFyUHJlcGFyZWQoY20sIHByZXBhcmVkTWVhc3VyZSwgdGFyZ2V0KSwgXCJsaW5lXCIpLnRvcDtcbiAgICByZXR1cm4gd3JhcHBlZExpbmVFeHRlbnQoY20sIGxpbmVPYmosIHByZXBhcmVkTWVhc3VyZSwgdGFyZ2V0VG9wKVxuICB9XG5cbiAgLy8gUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzaWRlIG9mIGEgYm94IGlzIGFmdGVyIHRoZSBnaXZlblxuICAvLyBjb29yZGluYXRlcywgaW4gdG9wLXRvLWJvdHRvbSwgbGVmdC10by1yaWdodCBvcmRlci5cbiAgZnVuY3Rpb24gYm94SXNBZnRlcihib3gsIHgsIHksIGxlZnQpIHtcbiAgICByZXR1cm4gYm94LmJvdHRvbSA8PSB5ID8gZmFsc2UgOiBib3gudG9wID4geSA/IHRydWUgOiAobGVmdCA/IGJveC5sZWZ0IDogYm94LnJpZ2h0KSA+IHhcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvb3Jkc0NoYXJJbm5lcihjbSwgbGluZU9iaiwgbGluZU5vLCB4LCB5KSB7XG4gICAgLy8gTW92ZSB5IGludG8gbGluZS1sb2NhbCBjb29yZGluYXRlIHNwYWNlXG4gICAgeSAtPSBoZWlnaHRBdExpbmUobGluZU9iaik7XG4gICAgdmFyIHByZXBhcmVkTWVhc3VyZSA9IHByZXBhcmVNZWFzdXJlRm9yTGluZShjbSwgbGluZU9iaik7XG4gICAgLy8gV2hlbiBkaXJlY3RseSBjYWxsaW5nIGBtZWFzdXJlQ2hhclByZXBhcmVkYCwgd2UgaGF2ZSB0byBhZGp1c3RcbiAgICAvLyBmb3IgdGhlIHdpZGdldHMgYXQgdGhpcyBsaW5lLlxuICAgIHZhciB3aWRnZXRIZWlnaHQgPSB3aWRnZXRUb3BIZWlnaHQobGluZU9iaik7XG4gICAgdmFyIGJlZ2luID0gMCwgZW5kID0gbGluZU9iai50ZXh0Lmxlbmd0aCwgbHRyID0gdHJ1ZTtcblxuICAgIHZhciBvcmRlciA9IGdldE9yZGVyKGxpbmVPYmosIGNtLmRvYy5kaXJlY3Rpb24pO1xuICAgIC8vIElmIHRoZSBsaW5lIGlzbid0IHBsYWluIGxlZnQtdG8tcmlnaHQgdGV4dCwgZmlyc3QgZmlndXJlIG91dFxuICAgIC8vIHdoaWNoIGJpZGkgc2VjdGlvbiB0aGUgY29vcmRpbmF0ZXMgZmFsbCBpbnRvLlxuICAgIGlmIChvcmRlcikge1xuICAgICAgdmFyIHBhcnQgPSAoY20ub3B0aW9ucy5saW5lV3JhcHBpbmcgPyBjb29yZHNCaWRpUGFydFdyYXBwZWQgOiBjb29yZHNCaWRpUGFydClcbiAgICAgICAgICAgICAgICAgICAoY20sIGxpbmVPYmosIGxpbmVObywgcHJlcGFyZWRNZWFzdXJlLCBvcmRlciwgeCwgeSk7XG4gICAgICBsdHIgPSBwYXJ0LmxldmVsICE9IDE7XG4gICAgICAvLyBUaGUgYXdrd2FyZCAtMSBvZmZzZXRzIGFyZSBuZWVkZWQgYmVjYXVzZSBmaW5kRmlyc3QgKGNhbGxlZFxuICAgICAgLy8gb24gdGhlc2UgYmVsb3cpIHdpbGwgdHJlYXQgaXRzIGZpcnN0IGJvdW5kIGFzIGluY2x1c2l2ZSxcbiAgICAgIC8vIHNlY29uZCBhcyBleGNsdXNpdmUsIGJ1dCB3ZSB3YW50IHRvIGFjdHVhbGx5IGFkZHJlc3MgdGhlXG4gICAgICAvLyBjaGFyYWN0ZXJzIGluIHRoZSBwYXJ0J3MgcmFuZ2VcbiAgICAgIGJlZ2luID0gbHRyID8gcGFydC5mcm9tIDogcGFydC50byAtIDE7XG4gICAgICBlbmQgPSBsdHIgPyBwYXJ0LnRvIDogcGFydC5mcm9tIC0gMTtcbiAgICB9XG5cbiAgICAvLyBBIGJpbmFyeSBzZWFyY2ggdG8gZmluZCB0aGUgZmlyc3QgY2hhcmFjdGVyIHdob3NlIGJvdW5kaW5nIGJveFxuICAgIC8vIHN0YXJ0cyBhZnRlciB0aGUgY29vcmRpbmF0ZXMuIElmIHdlIHJ1biBhY3Jvc3MgYW55IHdob3NlIGJveCB3cmFwXG4gICAgLy8gdGhlIGNvb3JkaW5hdGVzLCBzdG9yZSB0aGF0LlxuICAgIHZhciBjaEFyb3VuZCA9IG51bGwsIGJveEFyb3VuZCA9IG51bGw7XG4gICAgdmFyIGNoID0gZmluZEZpcnN0KGZ1bmN0aW9uIChjaCkge1xuICAgICAgdmFyIGJveCA9IG1lYXN1cmVDaGFyUHJlcGFyZWQoY20sIHByZXBhcmVkTWVhc3VyZSwgY2gpO1xuICAgICAgYm94LnRvcCArPSB3aWRnZXRIZWlnaHQ7IGJveC5ib3R0b20gKz0gd2lkZ2V0SGVpZ2h0O1xuICAgICAgaWYgKCFib3hJc0FmdGVyKGJveCwgeCwgeSwgZmFsc2UpKSB7IHJldHVybiBmYWxzZSB9XG4gICAgICBpZiAoYm94LnRvcCA8PSB5ICYmIGJveC5sZWZ0IDw9IHgpIHtcbiAgICAgICAgY2hBcm91bmQgPSBjaDtcbiAgICAgICAgYm94QXJvdW5kID0gYm94O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9LCBiZWdpbiwgZW5kKTtcblxuICAgIHZhciBiYXNlWCwgc3RpY2t5LCBvdXRzaWRlID0gZmFsc2U7XG4gICAgLy8gSWYgYSBib3ggYXJvdW5kIHRoZSBjb29yZGluYXRlcyB3YXMgZm91bmQsIHVzZSB0aGF0XG4gICAgaWYgKGJveEFyb3VuZCkge1xuICAgICAgLy8gRGlzdGluZ3Vpc2ggY29vcmRpbmF0ZXMgbmVhcmVyIHRvIHRoZSBsZWZ0IG9yIHJpZ2h0IHNpZGUgb2YgdGhlIGJveFxuICAgICAgdmFyIGF0TGVmdCA9IHggLSBib3hBcm91bmQubGVmdCA8IGJveEFyb3VuZC5yaWdodCAtIHgsIGF0U3RhcnQgPSBhdExlZnQgPT0gbHRyO1xuICAgICAgY2ggPSBjaEFyb3VuZCArIChhdFN0YXJ0ID8gMCA6IDEpO1xuICAgICAgc3RpY2t5ID0gYXRTdGFydCA/IFwiYWZ0ZXJcIiA6IFwiYmVmb3JlXCI7XG4gICAgICBiYXNlWCA9IGF0TGVmdCA/IGJveEFyb3VuZC5sZWZ0IDogYm94QXJvdW5kLnJpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyAoQWRqdXN0IGZvciBleHRlbmRlZCBib3VuZCwgaWYgbmVjZXNzYXJ5LilcbiAgICAgIGlmICghbHRyICYmIChjaCA9PSBlbmQgfHwgY2ggPT0gYmVnaW4pKSB7IGNoKys7IH1cbiAgICAgIC8vIFRvIGRldGVybWluZSB3aGljaCBzaWRlIHRvIGFzc29jaWF0ZSB3aXRoLCBnZXQgdGhlIGJveCB0byB0aGVcbiAgICAgIC8vIGxlZnQgb2YgdGhlIGNoYXJhY3RlciBhbmQgY29tcGFyZSBpdCdzIHZlcnRpY2FsIHBvc2l0aW9uIHRvIHRoZVxuICAgICAgLy8gY29vcmRpbmF0ZXNcbiAgICAgIHN0aWNreSA9IGNoID09IDAgPyBcImFmdGVyXCIgOiBjaCA9PSBsaW5lT2JqLnRleHQubGVuZ3RoID8gXCJiZWZvcmVcIiA6XG4gICAgICAgIChtZWFzdXJlQ2hhclByZXBhcmVkKGNtLCBwcmVwYXJlZE1lYXN1cmUsIGNoIC0gKGx0ciA/IDEgOiAwKSkuYm90dG9tICsgd2lkZ2V0SGVpZ2h0IDw9IHkpID09IGx0ciA/XG4gICAgICAgIFwiYWZ0ZXJcIiA6IFwiYmVmb3JlXCI7XG4gICAgICAvLyBOb3cgZ2V0IGFjY3VyYXRlIGNvb3JkaW5hdGVzIGZvciB0aGlzIHBsYWNlLCBpbiBvcmRlciB0byBnZXQgYVxuICAgICAgLy8gYmFzZSBYIHBvc2l0aW9uXG4gICAgICB2YXIgY29vcmRzID0gY3Vyc29yQ29vcmRzKGNtLCBQb3MobGluZU5vLCBjaCwgc3RpY2t5KSwgXCJsaW5lXCIsIGxpbmVPYmosIHByZXBhcmVkTWVhc3VyZSk7XG4gICAgICBiYXNlWCA9IGNvb3Jkcy5sZWZ0O1xuICAgICAgb3V0c2lkZSA9IHkgPCBjb29yZHMudG9wID8gLTEgOiB5ID49IGNvb3Jkcy5ib3R0b20gPyAxIDogMDtcbiAgICB9XG5cbiAgICBjaCA9IHNraXBFeHRlbmRpbmdDaGFycyhsaW5lT2JqLnRleHQsIGNoLCAxKTtcbiAgICByZXR1cm4gUG9zV2l0aEluZm8obGluZU5vLCBjaCwgc3RpY2t5LCBvdXRzaWRlLCB4IC0gYmFzZVgpXG4gIH1cblxuICBmdW5jdGlvbiBjb29yZHNCaWRpUGFydChjbSwgbGluZU9iaiwgbGluZU5vLCBwcmVwYXJlZE1lYXN1cmUsIG9yZGVyLCB4LCB5KSB7XG4gICAgLy8gQmlkaSBwYXJ0cyBhcmUgc29ydGVkIGxlZnQtdG8tcmlnaHQsIGFuZCBpbiBhIG5vbi1saW5lLXdyYXBwaW5nXG4gICAgLy8gc2l0dWF0aW9uLCB3ZSBjYW4gdGFrZSB0aGlzIG9yZGVyaW5nIHRvIGNvcnJlc3BvbmQgdG8gdGhlIHZpc3VhbFxuICAgIC8vIG9yZGVyaW5nLiBUaGlzIGZpbmRzIHRoZSBmaXJzdCBwYXJ0IHdob3NlIGVuZCBpcyBhZnRlciB0aGUgZ2l2ZW5cbiAgICAvLyBjb29yZGluYXRlcy5cbiAgICB2YXIgaW5kZXggPSBmaW5kRmlyc3QoZnVuY3Rpb24gKGkpIHtcbiAgICAgIHZhciBwYXJ0ID0gb3JkZXJbaV0sIGx0ciA9IHBhcnQubGV2ZWwgIT0gMTtcbiAgICAgIHJldHVybiBib3hJc0FmdGVyKGN1cnNvckNvb3JkcyhjbSwgUG9zKGxpbmVObywgbHRyID8gcGFydC50byA6IHBhcnQuZnJvbSwgbHRyID8gXCJiZWZvcmVcIiA6IFwiYWZ0ZXJcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJsaW5lXCIsIGxpbmVPYmosIHByZXBhcmVkTWVhc3VyZSksIHgsIHksIHRydWUpXG4gICAgfSwgMCwgb3JkZXIubGVuZ3RoIC0gMSk7XG4gICAgdmFyIHBhcnQgPSBvcmRlcltpbmRleF07XG4gICAgLy8gSWYgdGhpcyBpc24ndCB0aGUgZmlyc3QgcGFydCwgdGhlIHBhcnQncyBzdGFydCBpcyBhbHNvIGFmdGVyXG4gICAgLy8gdGhlIGNvb3JkaW5hdGVzLCBhbmQgdGhlIGNvb3JkaW5hdGVzIGFyZW4ndCBvbiB0aGUgc2FtZSBsaW5lIGFzXG4gICAgLy8gdGhhdCBzdGFydCwgbW92ZSBvbmUgcGFydCBiYWNrLlxuICAgIGlmIChpbmRleCA+IDApIHtcbiAgICAgIHZhciBsdHIgPSBwYXJ0LmxldmVsICE9IDE7XG4gICAgICB2YXIgc3RhcnQgPSBjdXJzb3JDb29yZHMoY20sIFBvcyhsaW5lTm8sIGx0ciA/IHBhcnQuZnJvbSA6IHBhcnQudG8sIGx0ciA/IFwiYWZ0ZXJcIiA6IFwiYmVmb3JlXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibGluZVwiLCBsaW5lT2JqLCBwcmVwYXJlZE1lYXN1cmUpO1xuICAgICAgaWYgKGJveElzQWZ0ZXIoc3RhcnQsIHgsIHksIHRydWUpICYmIHN0YXJ0LnRvcCA+IHkpXG4gICAgICAgIHsgcGFydCA9IG9yZGVyW2luZGV4IC0gMV07IH1cbiAgICB9XG4gICAgcmV0dXJuIHBhcnRcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvb3Jkc0JpZGlQYXJ0V3JhcHBlZChjbSwgbGluZU9iaiwgX2xpbmVObywgcHJlcGFyZWRNZWFzdXJlLCBvcmRlciwgeCwgeSkge1xuICAgIC8vIEluIGEgd3JhcHBlZCBsaW5lLCBydGwgdGV4dCBvbiB3cmFwcGluZyBib3VuZGFyaWVzIGNhbiBkbyB0aGluZ3NcbiAgICAvLyB0aGF0IGRvbid0IGNvcnJlc3BvbmQgdG8gdGhlIG9yZGVyaW5nIGluIG91ciBgb3JkZXJgIGFycmF5IGF0XG4gICAgLy8gYWxsLCBzbyBhIGJpbmFyeSBzZWFyY2ggZG9lc24ndCB3b3JrLCBhbmQgd2Ugd2FudCB0byByZXR1cm4gYVxuICAgIC8vIHBhcnQgdGhhdCBvbmx5IHNwYW5zIG9uZSBsaW5lIHNvIHRoYXQgdGhlIGJpbmFyeSBzZWFyY2ggaW5cbiAgICAvLyBjb29yZHNDaGFySW5uZXIgaXMgc2FmZS4gQXMgc3VjaCwgd2UgZmlyc3QgZmluZCB0aGUgZXh0ZW50IG9mIHRoZVxuICAgIC8vIHdyYXBwZWQgbGluZSwgYW5kIHRoZW4gZG8gYSBmbGF0IHNlYXJjaCBpbiB3aGljaCB3ZSBkaXNjYXJkIGFueVxuICAgIC8vIHNwYW5zIHRoYXQgYXJlbid0IG9uIHRoZSBsaW5lLlxuICAgIHZhciByZWYgPSB3cmFwcGVkTGluZUV4dGVudChjbSwgbGluZU9iaiwgcHJlcGFyZWRNZWFzdXJlLCB5KTtcbiAgICB2YXIgYmVnaW4gPSByZWYuYmVnaW47XG4gICAgdmFyIGVuZCA9IHJlZi5lbmQ7XG4gICAgaWYgKC9cXHMvLnRlc3QobGluZU9iai50ZXh0LmNoYXJBdChlbmQgLSAxKSkpIHsgZW5kLS07IH1cbiAgICB2YXIgcGFydCA9IG51bGwsIGNsb3Nlc3REaXN0ID0gbnVsbDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9yZGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcCA9IG9yZGVyW2ldO1xuICAgICAgaWYgKHAuZnJvbSA+PSBlbmQgfHwgcC50byA8PSBiZWdpbikgeyBjb250aW51ZSB9XG4gICAgICB2YXIgbHRyID0gcC5sZXZlbCAhPSAxO1xuICAgICAgdmFyIGVuZFggPSBtZWFzdXJlQ2hhclByZXBhcmVkKGNtLCBwcmVwYXJlZE1lYXN1cmUsIGx0ciA/IE1hdGgubWluKGVuZCwgcC50bykgLSAxIDogTWF0aC5tYXgoYmVnaW4sIHAuZnJvbSkpLnJpZ2h0O1xuICAgICAgLy8gV2VpZ2ggYWdhaW5zdCBzcGFucyBlbmRpbmcgYmVmb3JlIHRoaXMsIHNvIHRoYXQgdGhleSBhcmUgb25seVxuICAgICAgLy8gcGlja2VkIGlmIG5vdGhpbmcgZW5kcyBhZnRlclxuICAgICAgdmFyIGRpc3QgPSBlbmRYIDwgeCA/IHggLSBlbmRYICsgMWU5IDogZW5kWCAtIHg7XG4gICAgICBpZiAoIXBhcnQgfHwgY2xvc2VzdERpc3QgPiBkaXN0KSB7XG4gICAgICAgIHBhcnQgPSBwO1xuICAgICAgICBjbG9zZXN0RGlzdCA9IGRpc3Q7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghcGFydCkgeyBwYXJ0ID0gb3JkZXJbb3JkZXIubGVuZ3RoIC0gMV07IH1cbiAgICAvLyBDbGlwIHRoZSBwYXJ0IHRvIHRoZSB3cmFwcGVkIGxpbmUuXG4gICAgaWYgKHBhcnQuZnJvbSA8IGJlZ2luKSB7IHBhcnQgPSB7ZnJvbTogYmVnaW4sIHRvOiBwYXJ0LnRvLCBsZXZlbDogcGFydC5sZXZlbH07IH1cbiAgICBpZiAocGFydC50byA+IGVuZCkgeyBwYXJ0ID0ge2Zyb206IHBhcnQuZnJvbSwgdG86IGVuZCwgbGV2ZWw6IHBhcnQubGV2ZWx9OyB9XG4gICAgcmV0dXJuIHBhcnRcbiAgfVxuXG4gIHZhciBtZWFzdXJlVGV4dDtcbiAgLy8gQ29tcHV0ZSB0aGUgZGVmYXVsdCB0ZXh0IGhlaWdodC5cbiAgZnVuY3Rpb24gdGV4dEhlaWdodChkaXNwbGF5KSB7XG4gICAgaWYgKGRpc3BsYXkuY2FjaGVkVGV4dEhlaWdodCAhPSBudWxsKSB7IHJldHVybiBkaXNwbGF5LmNhY2hlZFRleHRIZWlnaHQgfVxuICAgIGlmIChtZWFzdXJlVGV4dCA9PSBudWxsKSB7XG4gICAgICBtZWFzdXJlVGV4dCA9IGVsdChcInByZVwiLCBudWxsLCBcIkNvZGVNaXJyb3ItbGluZS1saWtlXCIpO1xuICAgICAgLy8gTWVhc3VyZSBhIGJ1bmNoIG9mIGxpbmVzLCBmb3IgYnJvd3NlcnMgdGhhdCBjb21wdXRlXG4gICAgICAvLyBmcmFjdGlvbmFsIGhlaWdodHMuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ5OyArK2kpIHtcbiAgICAgICAgbWVhc3VyZVRleHQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJ4XCIpKTtcbiAgICAgICAgbWVhc3VyZVRleHQuYXBwZW5kQ2hpbGQoZWx0KFwiYnJcIikpO1xuICAgICAgfVxuICAgICAgbWVhc3VyZVRleHQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJ4XCIpKTtcbiAgICB9XG4gICAgcmVtb3ZlQ2hpbGRyZW5BbmRBZGQoZGlzcGxheS5tZWFzdXJlLCBtZWFzdXJlVGV4dCk7XG4gICAgdmFyIGhlaWdodCA9IG1lYXN1cmVUZXh0Lm9mZnNldEhlaWdodCAvIDUwO1xuICAgIGlmIChoZWlnaHQgPiAzKSB7IGRpc3BsYXkuY2FjaGVkVGV4dEhlaWdodCA9IGhlaWdodDsgfVxuICAgIHJlbW92ZUNoaWxkcmVuKGRpc3BsYXkubWVhc3VyZSk7XG4gICAgcmV0dXJuIGhlaWdodCB8fCAxXG4gIH1cblxuICAvLyBDb21wdXRlIHRoZSBkZWZhdWx0IGNoYXJhY3RlciB3aWR0aC5cbiAgZnVuY3Rpb24gY2hhcldpZHRoKGRpc3BsYXkpIHtcbiAgICBpZiAoZGlzcGxheS5jYWNoZWRDaGFyV2lkdGggIT0gbnVsbCkgeyByZXR1cm4gZGlzcGxheS5jYWNoZWRDaGFyV2lkdGggfVxuICAgIHZhciBhbmNob3IgPSBlbHQoXCJzcGFuXCIsIFwieHh4eHh4eHh4eFwiKTtcbiAgICB2YXIgcHJlID0gZWx0KFwicHJlXCIsIFthbmNob3JdLCBcIkNvZGVNaXJyb3ItbGluZS1saWtlXCIpO1xuICAgIHJlbW92ZUNoaWxkcmVuQW5kQWRkKGRpc3BsYXkubWVhc3VyZSwgcHJlKTtcbiAgICB2YXIgcmVjdCA9IGFuY2hvci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgd2lkdGggPSAocmVjdC5yaWdodCAtIHJlY3QubGVmdCkgLyAxMDtcbiAgICBpZiAod2lkdGggPiAyKSB7IGRpc3BsYXkuY2FjaGVkQ2hhcldpZHRoID0gd2lkdGg7IH1cbiAgICByZXR1cm4gd2lkdGggfHwgMTBcbiAgfVxuXG4gIC8vIERvIGEgYnVsay1yZWFkIG9mIHRoZSBET00gcG9zaXRpb25zIGFuZCBzaXplcyBuZWVkZWQgdG8gZHJhdyB0aGVcbiAgLy8gdmlldywgc28gdGhhdCB3ZSBkb24ndCBpbnRlcmxlYXZlIHJlYWRpbmcgYW5kIHdyaXRpbmcgdG8gdGhlIERPTS5cbiAgZnVuY3Rpb24gZ2V0RGltZW5zaW9ucyhjbSkge1xuICAgIHZhciBkID0gY20uZGlzcGxheSwgbGVmdCA9IHt9LCB3aWR0aCA9IHt9O1xuICAgIHZhciBndXR0ZXJMZWZ0ID0gZC5ndXR0ZXJzLmNsaWVudExlZnQ7XG4gICAgZm9yICh2YXIgbiA9IGQuZ3V0dGVycy5maXJzdENoaWxkLCBpID0gMDsgbjsgbiA9IG4ubmV4dFNpYmxpbmcsICsraSkge1xuICAgICAgdmFyIGlkID0gY20uZGlzcGxheS5ndXR0ZXJTcGVjc1tpXS5jbGFzc05hbWU7XG4gICAgICBsZWZ0W2lkXSA9IG4ub2Zmc2V0TGVmdCArIG4uY2xpZW50TGVmdCArIGd1dHRlckxlZnQ7XG4gICAgICB3aWR0aFtpZF0gPSBuLmNsaWVudFdpZHRoO1xuICAgIH1cbiAgICByZXR1cm4ge2ZpeGVkUG9zOiBjb21wZW5zYXRlRm9ySFNjcm9sbChkKSxcbiAgICAgICAgICAgIGd1dHRlclRvdGFsV2lkdGg6IGQuZ3V0dGVycy5vZmZzZXRXaWR0aCxcbiAgICAgICAgICAgIGd1dHRlckxlZnQ6IGxlZnQsXG4gICAgICAgICAgICBndXR0ZXJXaWR0aDogd2lkdGgsXG4gICAgICAgICAgICB3cmFwcGVyV2lkdGg6IGQud3JhcHBlci5jbGllbnRXaWR0aH1cbiAgfVxuXG4gIC8vIENvbXB1dGVzIGRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsTGVmdCArIGRpc3BsYXkuZ3V0dGVycy5vZmZzZXRXaWR0aCxcbiAgLy8gYnV0IHVzaW5nIGdldEJvdW5kaW5nQ2xpZW50UmVjdCB0byBnZXQgYSBzdWItcGl4ZWwtYWNjdXJhdGVcbiAgLy8gcmVzdWx0LlxuICBmdW5jdGlvbiBjb21wZW5zYXRlRm9ySFNjcm9sbChkaXNwbGF5KSB7XG4gICAgcmV0dXJuIGRpc3BsYXkuc2Nyb2xsZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCAtIGRpc3BsYXkuc2l6ZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdFxuICB9XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgZXN0aW1hdGVzIHRoZSBoZWlnaHQgb2YgYSBsaW5lLCB0byB1c2UgYXNcbiAgLy8gZmlyc3QgYXBwcm94aW1hdGlvbiB1bnRpbCB0aGUgbGluZSBiZWNvbWVzIHZpc2libGUgKGFuZCBpcyB0aHVzXG4gIC8vIHByb3Blcmx5IG1lYXN1cmFibGUpLlxuICBmdW5jdGlvbiBlc3RpbWF0ZUhlaWdodChjbSkge1xuICAgIHZhciB0aCA9IHRleHRIZWlnaHQoY20uZGlzcGxheSksIHdyYXBwaW5nID0gY20ub3B0aW9ucy5saW5lV3JhcHBpbmc7XG4gICAgdmFyIHBlckxpbmUgPSB3cmFwcGluZyAmJiBNYXRoLm1heCg1LCBjbS5kaXNwbGF5LnNjcm9sbGVyLmNsaWVudFdpZHRoIC8gY2hhcldpZHRoKGNtLmRpc3BsYXkpIC0gMyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICBpZiAobGluZUlzSGlkZGVuKGNtLmRvYywgbGluZSkpIHsgcmV0dXJuIDAgfVxuXG4gICAgICB2YXIgd2lkZ2V0c0hlaWdodCA9IDA7XG4gICAgICBpZiAobGluZS53aWRnZXRzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgbGluZS53aWRnZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChsaW5lLndpZGdldHNbaV0uaGVpZ2h0KSB7IHdpZGdldHNIZWlnaHQgKz0gbGluZS53aWRnZXRzW2ldLmhlaWdodDsgfVxuICAgICAgfSB9XG5cbiAgICAgIGlmICh3cmFwcGluZylcbiAgICAgICAgeyByZXR1cm4gd2lkZ2V0c0hlaWdodCArIChNYXRoLmNlaWwobGluZS50ZXh0Lmxlbmd0aCAvIHBlckxpbmUpIHx8IDEpICogdGggfVxuICAgICAgZWxzZVxuICAgICAgICB7IHJldHVybiB3aWRnZXRzSGVpZ2h0ICsgdGggfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGVzdGltYXRlTGluZUhlaWdodHMoY20pIHtcbiAgICB2YXIgZG9jID0gY20uZG9jLCBlc3QgPSBlc3RpbWF0ZUhlaWdodChjbSk7XG4gICAgZG9jLml0ZXIoZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgIHZhciBlc3RIZWlnaHQgPSBlc3QobGluZSk7XG4gICAgICBpZiAoZXN0SGVpZ2h0ICE9IGxpbmUuaGVpZ2h0KSB7IHVwZGF0ZUxpbmVIZWlnaHQobGluZSwgZXN0SGVpZ2h0KTsgfVxuICAgIH0pO1xuICB9XG5cbiAgLy8gR2l2ZW4gYSBtb3VzZSBldmVudCwgZmluZCB0aGUgY29ycmVzcG9uZGluZyBwb3NpdGlvbi4gSWYgbGliZXJhbFxuICAvLyBpcyBmYWxzZSwgaXQgY2hlY2tzIHdoZXRoZXIgYSBndXR0ZXIgb3Igc2Nyb2xsYmFyIHdhcyBjbGlja2VkLFxuICAvLyBhbmQgcmV0dXJucyBudWxsIGlmIGl0IHdhcy4gZm9yUmVjdCBpcyB1c2VkIGJ5IHJlY3Rhbmd1bGFyXG4gIC8vIHNlbGVjdGlvbnMsIGFuZCB0cmllcyB0byBlc3RpbWF0ZSBhIGNoYXJhY3RlciBwb3NpdGlvbiBldmVuIGZvclxuICAvLyBjb29yZGluYXRlcyBiZXlvbmQgdGhlIHJpZ2h0IG9mIHRoZSB0ZXh0LlxuICBmdW5jdGlvbiBwb3NGcm9tTW91c2UoY20sIGUsIGxpYmVyYWwsIGZvclJlY3QpIHtcbiAgICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXk7XG4gICAgaWYgKCFsaWJlcmFsICYmIGVfdGFyZ2V0KGUpLmdldEF0dHJpYnV0ZShcImNtLW5vdC1jb250ZW50XCIpID09IFwidHJ1ZVwiKSB7IHJldHVybiBudWxsIH1cblxuICAgIHZhciB4LCB5LCBzcGFjZSA9IGRpc3BsYXkubGluZVNwYWNlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIC8vIEZhaWxzIHVucHJlZGljdGFibHkgb24gSUVbNjddIHdoZW4gbW91c2UgaXMgZHJhZ2dlZCBhcm91bmQgcXVpY2tseS5cbiAgICB0cnkgeyB4ID0gZS5jbGllbnRYIC0gc3BhY2UubGVmdDsgeSA9IGUuY2xpZW50WSAtIHNwYWNlLnRvcDsgfVxuICAgIGNhdGNoIChlJDEpIHsgcmV0dXJuIG51bGwgfVxuICAgIHZhciBjb29yZHMgPSBjb29yZHNDaGFyKGNtLCB4LCB5KSwgbGluZTtcbiAgICBpZiAoZm9yUmVjdCAmJiBjb29yZHMueFJlbCA+IDAgJiYgKGxpbmUgPSBnZXRMaW5lKGNtLmRvYywgY29vcmRzLmxpbmUpLnRleHQpLmxlbmd0aCA9PSBjb29yZHMuY2gpIHtcbiAgICAgIHZhciBjb2xEaWZmID0gY291bnRDb2x1bW4obGluZSwgbGluZS5sZW5ndGgsIGNtLm9wdGlvbnMudGFiU2l6ZSkgLSBsaW5lLmxlbmd0aDtcbiAgICAgIGNvb3JkcyA9IFBvcyhjb29yZHMubGluZSwgTWF0aC5tYXgoMCwgTWF0aC5yb3VuZCgoeCAtIHBhZGRpbmdIKGNtLmRpc3BsYXkpLmxlZnQpIC8gY2hhcldpZHRoKGNtLmRpc3BsYXkpKSAtIGNvbERpZmYpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvb3Jkc1xuICB9XG5cbiAgLy8gRmluZCB0aGUgdmlldyBlbGVtZW50IGNvcnJlc3BvbmRpbmcgdG8gYSBnaXZlbiBsaW5lLiBSZXR1cm4gbnVsbFxuICAvLyB3aGVuIHRoZSBsaW5lIGlzbid0IHZpc2libGUuXG4gIGZ1bmN0aW9uIGZpbmRWaWV3SW5kZXgoY20sIG4pIHtcbiAgICBpZiAobiA+PSBjbS5kaXNwbGF5LnZpZXdUbykgeyByZXR1cm4gbnVsbCB9XG4gICAgbiAtPSBjbS5kaXNwbGF5LnZpZXdGcm9tO1xuICAgIGlmIChuIDwgMCkgeyByZXR1cm4gbnVsbCB9XG4gICAgdmFyIHZpZXcgPSBjbS5kaXNwbGF5LnZpZXc7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2aWV3Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBuIC09IHZpZXdbaV0uc2l6ZTtcbiAgICAgIGlmIChuIDwgMCkgeyByZXR1cm4gaSB9XG4gICAgfVxuICB9XG5cbiAgLy8gVXBkYXRlcyB0aGUgZGlzcGxheS52aWV3IGRhdGEgc3RydWN0dXJlIGZvciBhIGdpdmVuIGNoYW5nZSB0byB0aGVcbiAgLy8gZG9jdW1lbnQuIEZyb20gYW5kIHRvIGFyZSBpbiBwcmUtY2hhbmdlIGNvb3JkaW5hdGVzLiBMZW5kaWZmIGlzXG4gIC8vIHRoZSBhbW91bnQgb2YgbGluZXMgYWRkZWQgb3Igc3VidHJhY3RlZCBieSB0aGUgY2hhbmdlLiBUaGlzIGlzXG4gIC8vIHVzZWQgZm9yIGNoYW5nZXMgdGhhdCBzcGFuIG11bHRpcGxlIGxpbmVzLCBvciBjaGFuZ2UgdGhlIHdheVxuICAvLyBsaW5lcyBhcmUgZGl2aWRlZCBpbnRvIHZpc3VhbCBsaW5lcy4gcmVnTGluZUNoYW5nZSAoYmVsb3cpXG4gIC8vIHJlZ2lzdGVycyBzaW5nbGUtbGluZSBjaGFuZ2VzLlxuICBmdW5jdGlvbiByZWdDaGFuZ2UoY20sIGZyb20sIHRvLCBsZW5kaWZmKSB7XG4gICAgaWYgKGZyb20gPT0gbnVsbCkgeyBmcm9tID0gY20uZG9jLmZpcnN0OyB9XG4gICAgaWYgKHRvID09IG51bGwpIHsgdG8gPSBjbS5kb2MuZmlyc3QgKyBjbS5kb2Muc2l6ZTsgfVxuICAgIGlmICghbGVuZGlmZikgeyBsZW5kaWZmID0gMDsgfVxuXG4gICAgdmFyIGRpc3BsYXkgPSBjbS5kaXNwbGF5O1xuICAgIGlmIChsZW5kaWZmICYmIHRvIDwgZGlzcGxheS52aWV3VG8gJiZcbiAgICAgICAgKGRpc3BsYXkudXBkYXRlTGluZU51bWJlcnMgPT0gbnVsbCB8fCBkaXNwbGF5LnVwZGF0ZUxpbmVOdW1iZXJzID4gZnJvbSkpXG4gICAgICB7IGRpc3BsYXkudXBkYXRlTGluZU51bWJlcnMgPSBmcm9tOyB9XG5cbiAgICBjbS5jdXJPcC52aWV3Q2hhbmdlZCA9IHRydWU7XG5cbiAgICBpZiAoZnJvbSA+PSBkaXNwbGF5LnZpZXdUbykgeyAvLyBDaGFuZ2UgYWZ0ZXJcbiAgICAgIGlmIChzYXdDb2xsYXBzZWRTcGFucyAmJiB2aXN1YWxMaW5lTm8oY20uZG9jLCBmcm9tKSA8IGRpc3BsYXkudmlld1RvKVxuICAgICAgICB7IHJlc2V0VmlldyhjbSk7IH1cbiAgICB9IGVsc2UgaWYgKHRvIDw9IGRpc3BsYXkudmlld0Zyb20pIHsgLy8gQ2hhbmdlIGJlZm9yZVxuICAgICAgaWYgKHNhd0NvbGxhcHNlZFNwYW5zICYmIHZpc3VhbExpbmVFbmRObyhjbS5kb2MsIHRvICsgbGVuZGlmZikgPiBkaXNwbGF5LnZpZXdGcm9tKSB7XG4gICAgICAgIHJlc2V0VmlldyhjbSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaXNwbGF5LnZpZXdGcm9tICs9IGxlbmRpZmY7XG4gICAgICAgIGRpc3BsYXkudmlld1RvICs9IGxlbmRpZmY7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChmcm9tIDw9IGRpc3BsYXkudmlld0Zyb20gJiYgdG8gPj0gZGlzcGxheS52aWV3VG8pIHsgLy8gRnVsbCBvdmVybGFwXG4gICAgICByZXNldFZpZXcoY20pO1xuICAgIH0gZWxzZSBpZiAoZnJvbSA8PSBkaXNwbGF5LnZpZXdGcm9tKSB7IC8vIFRvcCBvdmVybGFwXG4gICAgICB2YXIgY3V0ID0gdmlld0N1dHRpbmdQb2ludChjbSwgdG8sIHRvICsgbGVuZGlmZiwgMSk7XG4gICAgICBpZiAoY3V0KSB7XG4gICAgICAgIGRpc3BsYXkudmlldyA9IGRpc3BsYXkudmlldy5zbGljZShjdXQuaW5kZXgpO1xuICAgICAgICBkaXNwbGF5LnZpZXdGcm9tID0gY3V0LmxpbmVOO1xuICAgICAgICBkaXNwbGF5LnZpZXdUbyArPSBsZW5kaWZmO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzZXRWaWV3KGNtKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRvID49IGRpc3BsYXkudmlld1RvKSB7IC8vIEJvdHRvbSBvdmVybGFwXG4gICAgICB2YXIgY3V0JDEgPSB2aWV3Q3V0dGluZ1BvaW50KGNtLCBmcm9tLCBmcm9tLCAtMSk7XG4gICAgICBpZiAoY3V0JDEpIHtcbiAgICAgICAgZGlzcGxheS52aWV3ID0gZGlzcGxheS52aWV3LnNsaWNlKDAsIGN1dCQxLmluZGV4KTtcbiAgICAgICAgZGlzcGxheS52aWV3VG8gPSBjdXQkMS5saW5lTjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc2V0VmlldyhjbSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHsgLy8gR2FwIGluIHRoZSBtaWRkbGVcbiAgICAgIHZhciBjdXRUb3AgPSB2aWV3Q3V0dGluZ1BvaW50KGNtLCBmcm9tLCBmcm9tLCAtMSk7XG4gICAgICB2YXIgY3V0Qm90ID0gdmlld0N1dHRpbmdQb2ludChjbSwgdG8sIHRvICsgbGVuZGlmZiwgMSk7XG4gICAgICBpZiAoY3V0VG9wICYmIGN1dEJvdCkge1xuICAgICAgICBkaXNwbGF5LnZpZXcgPSBkaXNwbGF5LnZpZXcuc2xpY2UoMCwgY3V0VG9wLmluZGV4KVxuICAgICAgICAgIC5jb25jYXQoYnVpbGRWaWV3QXJyYXkoY20sIGN1dFRvcC5saW5lTiwgY3V0Qm90LmxpbmVOKSlcbiAgICAgICAgICAuY29uY2F0KGRpc3BsYXkudmlldy5zbGljZShjdXRCb3QuaW5kZXgpKTtcbiAgICAgICAgZGlzcGxheS52aWV3VG8gKz0gbGVuZGlmZjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc2V0VmlldyhjbSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGV4dCA9IGRpc3BsYXkuZXh0ZXJuYWxNZWFzdXJlZDtcbiAgICBpZiAoZXh0KSB7XG4gICAgICBpZiAodG8gPCBleHQubGluZU4pXG4gICAgICAgIHsgZXh0LmxpbmVOICs9IGxlbmRpZmY7IH1cbiAgICAgIGVsc2UgaWYgKGZyb20gPCBleHQubGluZU4gKyBleHQuc2l6ZSlcbiAgICAgICAgeyBkaXNwbGF5LmV4dGVybmFsTWVhc3VyZWQgPSBudWxsOyB9XG4gICAgfVxuICB9XG5cbiAgLy8gUmVnaXN0ZXIgYSBjaGFuZ2UgdG8gYSBzaW5nbGUgbGluZS4gVHlwZSBtdXN0IGJlIG9uZSBvZiBcInRleHRcIixcbiAgLy8gXCJndXR0ZXJcIiwgXCJjbGFzc1wiLCBcIndpZGdldFwiXG4gIGZ1bmN0aW9uIHJlZ0xpbmVDaGFuZ2UoY20sIGxpbmUsIHR5cGUpIHtcbiAgICBjbS5jdXJPcC52aWV3Q2hhbmdlZCA9IHRydWU7XG4gICAgdmFyIGRpc3BsYXkgPSBjbS5kaXNwbGF5LCBleHQgPSBjbS5kaXNwbGF5LmV4dGVybmFsTWVhc3VyZWQ7XG4gICAgaWYgKGV4dCAmJiBsaW5lID49IGV4dC5saW5lTiAmJiBsaW5lIDwgZXh0LmxpbmVOICsgZXh0LnNpemUpXG4gICAgICB7IGRpc3BsYXkuZXh0ZXJuYWxNZWFzdXJlZCA9IG51bGw7IH1cblxuICAgIGlmIChsaW5lIDwgZGlzcGxheS52aWV3RnJvbSB8fCBsaW5lID49IGRpc3BsYXkudmlld1RvKSB7IHJldHVybiB9XG4gICAgdmFyIGxpbmVWaWV3ID0gZGlzcGxheS52aWV3W2ZpbmRWaWV3SW5kZXgoY20sIGxpbmUpXTtcbiAgICBpZiAobGluZVZpZXcubm9kZSA9PSBudWxsKSB7IHJldHVybiB9XG4gICAgdmFyIGFyciA9IGxpbmVWaWV3LmNoYW5nZXMgfHwgKGxpbmVWaWV3LmNoYW5nZXMgPSBbXSk7XG4gICAgaWYgKGluZGV4T2YoYXJyLCB0eXBlKSA9PSAtMSkgeyBhcnIucHVzaCh0eXBlKTsgfVxuICB9XG5cbiAgLy8gQ2xlYXIgdGhlIHZpZXcuXG4gIGZ1bmN0aW9uIHJlc2V0VmlldyhjbSkge1xuICAgIGNtLmRpc3BsYXkudmlld0Zyb20gPSBjbS5kaXNwbGF5LnZpZXdUbyA9IGNtLmRvYy5maXJzdDtcbiAgICBjbS5kaXNwbGF5LnZpZXcgPSBbXTtcbiAgICBjbS5kaXNwbGF5LnZpZXdPZmZzZXQgPSAwO1xuICB9XG5cbiAgZnVuY3Rpb24gdmlld0N1dHRpbmdQb2ludChjbSwgb2xkTiwgbmV3TiwgZGlyKSB7XG4gICAgdmFyIGluZGV4ID0gZmluZFZpZXdJbmRleChjbSwgb2xkTiksIGRpZmYsIHZpZXcgPSBjbS5kaXNwbGF5LnZpZXc7XG4gICAgaWYgKCFzYXdDb2xsYXBzZWRTcGFucyB8fCBuZXdOID09IGNtLmRvYy5maXJzdCArIGNtLmRvYy5zaXplKVxuICAgICAgeyByZXR1cm4ge2luZGV4OiBpbmRleCwgbGluZU46IG5ld059IH1cbiAgICB2YXIgbiA9IGNtLmRpc3BsYXkudmlld0Zyb207XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmRleDsgaSsrKVxuICAgICAgeyBuICs9IHZpZXdbaV0uc2l6ZTsgfVxuICAgIGlmIChuICE9IG9sZE4pIHtcbiAgICAgIGlmIChkaXIgPiAwKSB7XG4gICAgICAgIGlmIChpbmRleCA9PSB2aWV3Lmxlbmd0aCAtIDEpIHsgcmV0dXJuIG51bGwgfVxuICAgICAgICBkaWZmID0gKG4gKyB2aWV3W2luZGV4XS5zaXplKSAtIG9sZE47XG4gICAgICAgIGluZGV4Kys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaWZmID0gbiAtIG9sZE47XG4gICAgICB9XG4gICAgICBvbGROICs9IGRpZmY7IG5ld04gKz0gZGlmZjtcbiAgICB9XG4gICAgd2hpbGUgKHZpc3VhbExpbmVObyhjbS5kb2MsIG5ld04pICE9IG5ld04pIHtcbiAgICAgIGlmIChpbmRleCA9PSAoZGlyIDwgMCA/IDAgOiB2aWV3Lmxlbmd0aCAtIDEpKSB7IHJldHVybiBudWxsIH1cbiAgICAgIG5ld04gKz0gZGlyICogdmlld1tpbmRleCAtIChkaXIgPCAwID8gMSA6IDApXS5zaXplO1xuICAgICAgaW5kZXggKz0gZGlyO1xuICAgIH1cbiAgICByZXR1cm4ge2luZGV4OiBpbmRleCwgbGluZU46IG5ld059XG4gIH1cblxuICAvLyBGb3JjZSB0aGUgdmlldyB0byBjb3ZlciBhIGdpdmVuIHJhbmdlLCBhZGRpbmcgZW1wdHkgdmlldyBlbGVtZW50XG4gIC8vIG9yIGNsaXBwaW5nIG9mZiBleGlzdGluZyBvbmVzIGFzIG5lZWRlZC5cbiAgZnVuY3Rpb24gYWRqdXN0VmlldyhjbSwgZnJvbSwgdG8pIHtcbiAgICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXksIHZpZXcgPSBkaXNwbGF5LnZpZXc7XG4gICAgaWYgKHZpZXcubGVuZ3RoID09IDAgfHwgZnJvbSA+PSBkaXNwbGF5LnZpZXdUbyB8fCB0byA8PSBkaXNwbGF5LnZpZXdGcm9tKSB7XG4gICAgICBkaXNwbGF5LnZpZXcgPSBidWlsZFZpZXdBcnJheShjbSwgZnJvbSwgdG8pO1xuICAgICAgZGlzcGxheS52aWV3RnJvbSA9IGZyb207XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChkaXNwbGF5LnZpZXdGcm9tID4gZnJvbSlcbiAgICAgICAgeyBkaXNwbGF5LnZpZXcgPSBidWlsZFZpZXdBcnJheShjbSwgZnJvbSwgZGlzcGxheS52aWV3RnJvbSkuY29uY2F0KGRpc3BsYXkudmlldyk7IH1cbiAgICAgIGVsc2UgaWYgKGRpc3BsYXkudmlld0Zyb20gPCBmcm9tKVxuICAgICAgICB7IGRpc3BsYXkudmlldyA9IGRpc3BsYXkudmlldy5zbGljZShmaW5kVmlld0luZGV4KGNtLCBmcm9tKSk7IH1cbiAgICAgIGRpc3BsYXkudmlld0Zyb20gPSBmcm9tO1xuICAgICAgaWYgKGRpc3BsYXkudmlld1RvIDwgdG8pXG4gICAgICAgIHsgZGlzcGxheS52aWV3ID0gZGlzcGxheS52aWV3LmNvbmNhdChidWlsZFZpZXdBcnJheShjbSwgZGlzcGxheS52aWV3VG8sIHRvKSk7IH1cbiAgICAgIGVsc2UgaWYgKGRpc3BsYXkudmlld1RvID4gdG8pXG4gICAgICAgIHsgZGlzcGxheS52aWV3ID0gZGlzcGxheS52aWV3LnNsaWNlKDAsIGZpbmRWaWV3SW5kZXgoY20sIHRvKSk7IH1cbiAgICB9XG4gICAgZGlzcGxheS52aWV3VG8gPSB0bztcbiAgfVxuXG4gIC8vIENvdW50IHRoZSBudW1iZXIgb2YgbGluZXMgaW4gdGhlIHZpZXcgd2hvc2UgRE9NIHJlcHJlc2VudGF0aW9uIGlzXG4gIC8vIG91dCBvZiBkYXRlIChvciBub25leGlzdGVudCkuXG4gIGZ1bmN0aW9uIGNvdW50RGlydHlWaWV3KGNtKSB7XG4gICAgdmFyIHZpZXcgPSBjbS5kaXNwbGF5LnZpZXcsIGRpcnR5ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZpZXcubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBsaW5lVmlldyA9IHZpZXdbaV07XG4gICAgICBpZiAoIWxpbmVWaWV3LmhpZGRlbiAmJiAoIWxpbmVWaWV3Lm5vZGUgfHwgbGluZVZpZXcuY2hhbmdlcykpIHsgKytkaXJ0eTsgfVxuICAgIH1cbiAgICByZXR1cm4gZGlydHlcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZVNlbGVjdGlvbihjbSkge1xuICAgIGNtLmRpc3BsYXkuaW5wdXQuc2hvd1NlbGVjdGlvbihjbS5kaXNwbGF5LmlucHV0LnByZXBhcmVTZWxlY3Rpb24oKSk7XG4gIH1cblxuICBmdW5jdGlvbiBwcmVwYXJlU2VsZWN0aW9uKGNtLCBwcmltYXJ5KSB7XG4gICAgaWYgKCBwcmltYXJ5ID09PSB2b2lkIDAgKSBwcmltYXJ5ID0gdHJ1ZTtcblxuICAgIHZhciBkb2MgPSBjbS5kb2MsIHJlc3VsdCA9IHt9O1xuICAgIHZhciBjdXJGcmFnbWVudCA9IHJlc3VsdC5jdXJzb3JzID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgIHZhciBzZWxGcmFnbWVudCA9IHJlc3VsdC5zZWxlY3Rpb24gPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRvYy5zZWwucmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIXByaW1hcnkgJiYgaSA9PSBkb2Muc2VsLnByaW1JbmRleCkgeyBjb250aW51ZSB9XG4gICAgICB2YXIgcmFuZ2UgPSBkb2Muc2VsLnJhbmdlc1tpXTtcbiAgICAgIGlmIChyYW5nZS5mcm9tKCkubGluZSA+PSBjbS5kaXNwbGF5LnZpZXdUbyB8fCByYW5nZS50bygpLmxpbmUgPCBjbS5kaXNwbGF5LnZpZXdGcm9tKSB7IGNvbnRpbnVlIH1cbiAgICAgIHZhciBjb2xsYXBzZWQgPSByYW5nZS5lbXB0eSgpO1xuICAgICAgaWYgKGNvbGxhcHNlZCB8fCBjbS5vcHRpb25zLnNob3dDdXJzb3JXaGVuU2VsZWN0aW5nKVxuICAgICAgICB7IGRyYXdTZWxlY3Rpb25DdXJzb3IoY20sIHJhbmdlLmhlYWQsIGN1ckZyYWdtZW50KTsgfVxuICAgICAgaWYgKCFjb2xsYXBzZWQpXG4gICAgICAgIHsgZHJhd1NlbGVjdGlvblJhbmdlKGNtLCByYW5nZSwgc2VsRnJhZ21lbnQpOyB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIC8vIERyYXdzIGEgY3Vyc29yIGZvciB0aGUgZ2l2ZW4gcmFuZ2VcbiAgZnVuY3Rpb24gZHJhd1NlbGVjdGlvbkN1cnNvcihjbSwgaGVhZCwgb3V0cHV0KSB7XG4gICAgdmFyIHBvcyA9IGN1cnNvckNvb3JkcyhjbSwgaGVhZCwgXCJkaXZcIiwgbnVsbCwgbnVsbCwgIWNtLm9wdGlvbnMuc2luZ2xlQ3Vyc29ySGVpZ2h0UGVyTGluZSk7XG5cbiAgICB2YXIgY3Vyc29yID0gb3V0cHV0LmFwcGVuZENoaWxkKGVsdChcImRpdlwiLCBcIlxcdTAwYTBcIiwgXCJDb2RlTWlycm9yLWN1cnNvclwiKSk7XG4gICAgY3Vyc29yLnN0eWxlLmxlZnQgPSBwb3MubGVmdCArIFwicHhcIjtcbiAgICBjdXJzb3Iuc3R5bGUudG9wID0gcG9zLnRvcCArIFwicHhcIjtcbiAgICBjdXJzb3Iuc3R5bGUuaGVpZ2h0ID0gTWF0aC5tYXgoMCwgcG9zLmJvdHRvbSAtIHBvcy50b3ApICogY20ub3B0aW9ucy5jdXJzb3JIZWlnaHQgKyBcInB4XCI7XG5cbiAgICBpZiAocG9zLm90aGVyKSB7XG4gICAgICAvLyBTZWNvbmRhcnkgY3Vyc29yLCBzaG93biB3aGVuIG9uIGEgJ2p1bXAnIGluIGJpLWRpcmVjdGlvbmFsIHRleHRcbiAgICAgIHZhciBvdGhlckN1cnNvciA9IG91dHB1dC5hcHBlbmRDaGlsZChlbHQoXCJkaXZcIiwgXCJcXHUwMGEwXCIsIFwiQ29kZU1pcnJvci1jdXJzb3IgQ29kZU1pcnJvci1zZWNvbmRhcnljdXJzb3JcIikpO1xuICAgICAgb3RoZXJDdXJzb3Iuc3R5bGUuZGlzcGxheSA9IFwiXCI7XG4gICAgICBvdGhlckN1cnNvci5zdHlsZS5sZWZ0ID0gcG9zLm90aGVyLmxlZnQgKyBcInB4XCI7XG4gICAgICBvdGhlckN1cnNvci5zdHlsZS50b3AgPSBwb3Mub3RoZXIudG9wICsgXCJweFwiO1xuICAgICAgb3RoZXJDdXJzb3Iuc3R5bGUuaGVpZ2h0ID0gKHBvcy5vdGhlci5ib3R0b20gLSBwb3Mub3RoZXIudG9wKSAqIC44NSArIFwicHhcIjtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjbXBDb29yZHMoYSwgYikgeyByZXR1cm4gYS50b3AgLSBiLnRvcCB8fCBhLmxlZnQgLSBiLmxlZnQgfVxuXG4gIC8vIERyYXdzIHRoZSBnaXZlbiByYW5nZSBhcyBhIGhpZ2hsaWdodGVkIHNlbGVjdGlvblxuICBmdW5jdGlvbiBkcmF3U2VsZWN0aW9uUmFuZ2UoY20sIHJhbmdlLCBvdXRwdXQpIHtcbiAgICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXksIGRvYyA9IGNtLmRvYztcbiAgICB2YXIgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgdmFyIHBhZGRpbmcgPSBwYWRkaW5nSChjbS5kaXNwbGF5KSwgbGVmdFNpZGUgPSBwYWRkaW5nLmxlZnQ7XG4gICAgdmFyIHJpZ2h0U2lkZSA9IE1hdGgubWF4KGRpc3BsYXkuc2l6ZXJXaWR0aCwgZGlzcGxheVdpZHRoKGNtKSAtIGRpc3BsYXkuc2l6ZXIub2Zmc2V0TGVmdCkgLSBwYWRkaW5nLnJpZ2h0O1xuICAgIHZhciBkb2NMVFIgPSBkb2MuZGlyZWN0aW9uID09IFwibHRyXCI7XG5cbiAgICBmdW5jdGlvbiBhZGQobGVmdCwgdG9wLCB3aWR0aCwgYm90dG9tKSB7XG4gICAgICBpZiAodG9wIDwgMCkgeyB0b3AgPSAwOyB9XG4gICAgICB0b3AgPSBNYXRoLnJvdW5kKHRvcCk7XG4gICAgICBib3R0b20gPSBNYXRoLnJvdW5kKGJvdHRvbSk7XG4gICAgICBmcmFnbWVudC5hcHBlbmRDaGlsZChlbHQoXCJkaXZcIiwgbnVsbCwgXCJDb2RlTWlycm9yLXNlbGVjdGVkXCIsIChcInBvc2l0aW9uOiBhYnNvbHV0ZTsgbGVmdDogXCIgKyBsZWZ0ICsgXCJweDtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogXCIgKyB0b3AgKyBcInB4OyB3aWR0aDogXCIgKyAod2lkdGggPT0gbnVsbCA/IHJpZ2h0U2lkZSAtIGxlZnQgOiB3aWR0aCkgKyBcInB4O1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBcIiArIChib3R0b20gLSB0b3ApICsgXCJweFwiKSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRyYXdGb3JMaW5lKGxpbmUsIGZyb21BcmcsIHRvQXJnKSB7XG4gICAgICB2YXIgbGluZU9iaiA9IGdldExpbmUoZG9jLCBsaW5lKTtcbiAgICAgIHZhciBsaW5lTGVuID0gbGluZU9iai50ZXh0Lmxlbmd0aDtcbiAgICAgIHZhciBzdGFydCwgZW5kO1xuICAgICAgZnVuY3Rpb24gY29vcmRzKGNoLCBiaWFzKSB7XG4gICAgICAgIHJldHVybiBjaGFyQ29vcmRzKGNtLCBQb3MobGluZSwgY2gpLCBcImRpdlwiLCBsaW5lT2JqLCBiaWFzKVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB3cmFwWChwb3MsIGRpciwgc2lkZSkge1xuICAgICAgICB2YXIgZXh0ZW50ID0gd3JhcHBlZExpbmVFeHRlbnRDaGFyKGNtLCBsaW5lT2JqLCBudWxsLCBwb3MpO1xuICAgICAgICB2YXIgcHJvcCA9IChkaXIgPT0gXCJsdHJcIikgPT0gKHNpZGUgPT0gXCJhZnRlclwiKSA/IFwibGVmdFwiIDogXCJyaWdodFwiO1xuICAgICAgICB2YXIgY2ggPSBzaWRlID09IFwiYWZ0ZXJcIiA/IGV4dGVudC5iZWdpbiA6IGV4dGVudC5lbmQgLSAoL1xccy8udGVzdChsaW5lT2JqLnRleHQuY2hhckF0KGV4dGVudC5lbmQgLSAxKSkgPyAyIDogMSk7XG4gICAgICAgIHJldHVybiBjb29yZHMoY2gsIHByb3ApW3Byb3BdXG4gICAgICB9XG5cbiAgICAgIHZhciBvcmRlciA9IGdldE9yZGVyKGxpbmVPYmosIGRvYy5kaXJlY3Rpb24pO1xuICAgICAgaXRlcmF0ZUJpZGlTZWN0aW9ucyhvcmRlciwgZnJvbUFyZyB8fCAwLCB0b0FyZyA9PSBudWxsID8gbGluZUxlbiA6IHRvQXJnLCBmdW5jdGlvbiAoZnJvbSwgdG8sIGRpciwgaSkge1xuICAgICAgICB2YXIgbHRyID0gZGlyID09IFwibHRyXCI7XG4gICAgICAgIHZhciBmcm9tUG9zID0gY29vcmRzKGZyb20sIGx0ciA/IFwibGVmdFwiIDogXCJyaWdodFwiKTtcbiAgICAgICAgdmFyIHRvUG9zID0gY29vcmRzKHRvIC0gMSwgbHRyID8gXCJyaWdodFwiIDogXCJsZWZ0XCIpO1xuXG4gICAgICAgIHZhciBvcGVuU3RhcnQgPSBmcm9tQXJnID09IG51bGwgJiYgZnJvbSA9PSAwLCBvcGVuRW5kID0gdG9BcmcgPT0gbnVsbCAmJiB0byA9PSBsaW5lTGVuO1xuICAgICAgICB2YXIgZmlyc3QgPSBpID09IDAsIGxhc3QgPSAhb3JkZXIgfHwgaSA9PSBvcmRlci5sZW5ndGggLSAxO1xuICAgICAgICBpZiAodG9Qb3MudG9wIC0gZnJvbVBvcy50b3AgPD0gMykgeyAvLyBTaW5nbGUgbGluZVxuICAgICAgICAgIHZhciBvcGVuTGVmdCA9IChkb2NMVFIgPyBvcGVuU3RhcnQgOiBvcGVuRW5kKSAmJiBmaXJzdDtcbiAgICAgICAgICB2YXIgb3BlblJpZ2h0ID0gKGRvY0xUUiA/IG9wZW5FbmQgOiBvcGVuU3RhcnQpICYmIGxhc3Q7XG4gICAgICAgICAgdmFyIGxlZnQgPSBvcGVuTGVmdCA/IGxlZnRTaWRlIDogKGx0ciA/IGZyb21Qb3MgOiB0b1BvcykubGVmdDtcbiAgICAgICAgICB2YXIgcmlnaHQgPSBvcGVuUmlnaHQgPyByaWdodFNpZGUgOiAobHRyID8gdG9Qb3MgOiBmcm9tUG9zKS5yaWdodDtcbiAgICAgICAgICBhZGQobGVmdCwgZnJvbVBvcy50b3AsIHJpZ2h0IC0gbGVmdCwgZnJvbVBvcy5ib3R0b20pO1xuICAgICAgICB9IGVsc2UgeyAvLyBNdWx0aXBsZSBsaW5lc1xuICAgICAgICAgIHZhciB0b3BMZWZ0LCB0b3BSaWdodCwgYm90TGVmdCwgYm90UmlnaHQ7XG4gICAgICAgICAgaWYgKGx0cikge1xuICAgICAgICAgICAgdG9wTGVmdCA9IGRvY0xUUiAmJiBvcGVuU3RhcnQgJiYgZmlyc3QgPyBsZWZ0U2lkZSA6IGZyb21Qb3MubGVmdDtcbiAgICAgICAgICAgIHRvcFJpZ2h0ID0gZG9jTFRSID8gcmlnaHRTaWRlIDogd3JhcFgoZnJvbSwgZGlyLCBcImJlZm9yZVwiKTtcbiAgICAgICAgICAgIGJvdExlZnQgPSBkb2NMVFIgPyBsZWZ0U2lkZSA6IHdyYXBYKHRvLCBkaXIsIFwiYWZ0ZXJcIik7XG4gICAgICAgICAgICBib3RSaWdodCA9IGRvY0xUUiAmJiBvcGVuRW5kICYmIGxhc3QgPyByaWdodFNpZGUgOiB0b1Bvcy5yaWdodDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdG9wTGVmdCA9ICFkb2NMVFIgPyBsZWZ0U2lkZSA6IHdyYXBYKGZyb20sIGRpciwgXCJiZWZvcmVcIik7XG4gICAgICAgICAgICB0b3BSaWdodCA9ICFkb2NMVFIgJiYgb3BlblN0YXJ0ICYmIGZpcnN0ID8gcmlnaHRTaWRlIDogZnJvbVBvcy5yaWdodDtcbiAgICAgICAgICAgIGJvdExlZnQgPSAhZG9jTFRSICYmIG9wZW5FbmQgJiYgbGFzdCA/IGxlZnRTaWRlIDogdG9Qb3MubGVmdDtcbiAgICAgICAgICAgIGJvdFJpZ2h0ID0gIWRvY0xUUiA/IHJpZ2h0U2lkZSA6IHdyYXBYKHRvLCBkaXIsIFwiYWZ0ZXJcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGFkZCh0b3BMZWZ0LCBmcm9tUG9zLnRvcCwgdG9wUmlnaHQgLSB0b3BMZWZ0LCBmcm9tUG9zLmJvdHRvbSk7XG4gICAgICAgICAgaWYgKGZyb21Qb3MuYm90dG9tIDwgdG9Qb3MudG9wKSB7IGFkZChsZWZ0U2lkZSwgZnJvbVBvcy5ib3R0b20sIG51bGwsIHRvUG9zLnRvcCk7IH1cbiAgICAgICAgICBhZGQoYm90TGVmdCwgdG9Qb3MudG9wLCBib3RSaWdodCAtIGJvdExlZnQsIHRvUG9zLmJvdHRvbSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXN0YXJ0IHx8IGNtcENvb3Jkcyhmcm9tUG9zLCBzdGFydCkgPCAwKSB7IHN0YXJ0ID0gZnJvbVBvczsgfVxuICAgICAgICBpZiAoY21wQ29vcmRzKHRvUG9zLCBzdGFydCkgPCAwKSB7IHN0YXJ0ID0gdG9Qb3M7IH1cbiAgICAgICAgaWYgKCFlbmQgfHwgY21wQ29vcmRzKGZyb21Qb3MsIGVuZCkgPCAwKSB7IGVuZCA9IGZyb21Qb3M7IH1cbiAgICAgICAgaWYgKGNtcENvb3Jkcyh0b1BvcywgZW5kKSA8IDApIHsgZW5kID0gdG9Qb3M7IH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHtzdGFydDogc3RhcnQsIGVuZDogZW5kfVxuICAgIH1cblxuICAgIHZhciBzRnJvbSA9IHJhbmdlLmZyb20oKSwgc1RvID0gcmFuZ2UudG8oKTtcbiAgICBpZiAoc0Zyb20ubGluZSA9PSBzVG8ubGluZSkge1xuICAgICAgZHJhd0ZvckxpbmUoc0Zyb20ubGluZSwgc0Zyb20uY2gsIHNUby5jaCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBmcm9tTGluZSA9IGdldExpbmUoZG9jLCBzRnJvbS5saW5lKSwgdG9MaW5lID0gZ2V0TGluZShkb2MsIHNUby5saW5lKTtcbiAgICAgIHZhciBzaW5nbGVWTGluZSA9IHZpc3VhbExpbmUoZnJvbUxpbmUpID09IHZpc3VhbExpbmUodG9MaW5lKTtcbiAgICAgIHZhciBsZWZ0RW5kID0gZHJhd0ZvckxpbmUoc0Zyb20ubGluZSwgc0Zyb20uY2gsIHNpbmdsZVZMaW5lID8gZnJvbUxpbmUudGV4dC5sZW5ndGggKyAxIDogbnVsbCkuZW5kO1xuICAgICAgdmFyIHJpZ2h0U3RhcnQgPSBkcmF3Rm9yTGluZShzVG8ubGluZSwgc2luZ2xlVkxpbmUgPyAwIDogbnVsbCwgc1RvLmNoKS5zdGFydDtcbiAgICAgIGlmIChzaW5nbGVWTGluZSkge1xuICAgICAgICBpZiAobGVmdEVuZC50b3AgPCByaWdodFN0YXJ0LnRvcCAtIDIpIHtcbiAgICAgICAgICBhZGQobGVmdEVuZC5yaWdodCwgbGVmdEVuZC50b3AsIG51bGwsIGxlZnRFbmQuYm90dG9tKTtcbiAgICAgICAgICBhZGQobGVmdFNpZGUsIHJpZ2h0U3RhcnQudG9wLCByaWdodFN0YXJ0LmxlZnQsIHJpZ2h0U3RhcnQuYm90dG9tKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZGQobGVmdEVuZC5yaWdodCwgbGVmdEVuZC50b3AsIHJpZ2h0U3RhcnQubGVmdCAtIGxlZnRFbmQucmlnaHQsIGxlZnRFbmQuYm90dG9tKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGxlZnRFbmQuYm90dG9tIDwgcmlnaHRTdGFydC50b3ApXG4gICAgICAgIHsgYWRkKGxlZnRTaWRlLCBsZWZ0RW5kLmJvdHRvbSwgbnVsbCwgcmlnaHRTdGFydC50b3ApOyB9XG4gICAgfVxuXG4gICAgb3V0cHV0LmFwcGVuZENoaWxkKGZyYWdtZW50KTtcbiAgfVxuXG4gIC8vIEN1cnNvci1ibGlua2luZ1xuICBmdW5jdGlvbiByZXN0YXJ0QmxpbmsoY20pIHtcbiAgICBpZiAoIWNtLnN0YXRlLmZvY3VzZWQpIHsgcmV0dXJuIH1cbiAgICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXk7XG4gICAgY2xlYXJJbnRlcnZhbChkaXNwbGF5LmJsaW5rZXIpO1xuICAgIHZhciBvbiA9IHRydWU7XG4gICAgZGlzcGxheS5jdXJzb3JEaXYuc3R5bGUudmlzaWJpbGl0eSA9IFwiXCI7XG4gICAgaWYgKGNtLm9wdGlvbnMuY3Vyc29yQmxpbmtSYXRlID4gMClcbiAgICAgIHsgZGlzcGxheS5ibGlua2VyID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWNtLmhhc0ZvY3VzKCkpIHsgb25CbHVyKGNtKTsgfVxuICAgICAgICBkaXNwbGF5LmN1cnNvckRpdi5zdHlsZS52aXNpYmlsaXR5ID0gKG9uID0gIW9uKSA/IFwiXCIgOiBcImhpZGRlblwiO1xuICAgICAgfSwgY20ub3B0aW9ucy5jdXJzb3JCbGlua1JhdGUpOyB9XG4gICAgZWxzZSBpZiAoY20ub3B0aW9ucy5jdXJzb3JCbGlua1JhdGUgPCAwKVxuICAgICAgeyBkaXNwbGF5LmN1cnNvckRpdi5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIjsgfVxuICB9XG5cbiAgZnVuY3Rpb24gZW5zdXJlRm9jdXMoY20pIHtcbiAgICBpZiAoIWNtLmhhc0ZvY3VzKCkpIHtcbiAgICAgIGNtLmRpc3BsYXkuaW5wdXQuZm9jdXMoKTtcbiAgICAgIGlmICghY20uc3RhdGUuZm9jdXNlZCkgeyBvbkZvY3VzKGNtKTsgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRlbGF5Qmx1ckV2ZW50KGNtKSB7XG4gICAgY20uc3RhdGUuZGVsYXlpbmdCbHVyRXZlbnQgPSB0cnVlO1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyBpZiAoY20uc3RhdGUuZGVsYXlpbmdCbHVyRXZlbnQpIHtcbiAgICAgIGNtLnN0YXRlLmRlbGF5aW5nQmx1ckV2ZW50ID0gZmFsc2U7XG4gICAgICBpZiAoY20uc3RhdGUuZm9jdXNlZCkgeyBvbkJsdXIoY20pOyB9XG4gICAgfSB9LCAxMDApO1xuICB9XG5cbiAgZnVuY3Rpb24gb25Gb2N1cyhjbSwgZSkge1xuICAgIGlmIChjbS5zdGF0ZS5kZWxheWluZ0JsdXJFdmVudCAmJiAhY20uc3RhdGUuZHJhZ2dpbmdUZXh0KSB7IGNtLnN0YXRlLmRlbGF5aW5nQmx1ckV2ZW50ID0gZmFsc2U7IH1cblxuICAgIGlmIChjbS5vcHRpb25zLnJlYWRPbmx5ID09IFwibm9jdXJzb3JcIikgeyByZXR1cm4gfVxuICAgIGlmICghY20uc3RhdGUuZm9jdXNlZCkge1xuICAgICAgc2lnbmFsKGNtLCBcImZvY3VzXCIsIGNtLCBlKTtcbiAgICAgIGNtLnN0YXRlLmZvY3VzZWQgPSB0cnVlO1xuICAgICAgYWRkQ2xhc3MoY20uZGlzcGxheS53cmFwcGVyLCBcIkNvZGVNaXJyb3ItZm9jdXNlZFwiKTtcbiAgICAgIC8vIFRoaXMgdGVzdCBwcmV2ZW50cyB0aGlzIGZyb20gZmlyaW5nIHdoZW4gYSBjb250ZXh0XG4gICAgICAvLyBtZW51IGlzIGNsb3NlZCAoc2luY2UgdGhlIGlucHV0IHJlc2V0IHdvdWxkIGtpbGwgdGhlXG4gICAgICAvLyBzZWxlY3QtYWxsIGRldGVjdGlvbiBoYWNrKVxuICAgICAgaWYgKCFjbS5jdXJPcCAmJiBjbS5kaXNwbGF5LnNlbEZvckNvbnRleHRNZW51ICE9IGNtLmRvYy5zZWwpIHtcbiAgICAgICAgY20uZGlzcGxheS5pbnB1dC5yZXNldCgpO1xuICAgICAgICBpZiAod2Via2l0KSB7IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gY20uZGlzcGxheS5pbnB1dC5yZXNldCh0cnVlKTsgfSwgMjApOyB9IC8vIElzc3VlICMxNzMwXG4gICAgICB9XG4gICAgICBjbS5kaXNwbGF5LmlucHV0LnJlY2VpdmVkRm9jdXMoKTtcbiAgICB9XG4gICAgcmVzdGFydEJsaW5rKGNtKTtcbiAgfVxuICBmdW5jdGlvbiBvbkJsdXIoY20sIGUpIHtcbiAgICBpZiAoY20uc3RhdGUuZGVsYXlpbmdCbHVyRXZlbnQpIHsgcmV0dXJuIH1cblxuICAgIGlmIChjbS5zdGF0ZS5mb2N1c2VkKSB7XG4gICAgICBzaWduYWwoY20sIFwiYmx1clwiLCBjbSwgZSk7XG4gICAgICBjbS5zdGF0ZS5mb2N1c2VkID0gZmFsc2U7XG4gICAgICBybUNsYXNzKGNtLmRpc3BsYXkud3JhcHBlciwgXCJDb2RlTWlycm9yLWZvY3VzZWRcIik7XG4gICAgfVxuICAgIGNsZWFySW50ZXJ2YWwoY20uZGlzcGxheS5ibGlua2VyKTtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgaWYgKCFjbS5zdGF0ZS5mb2N1c2VkKSB7IGNtLmRpc3BsYXkuc2hpZnQgPSBmYWxzZTsgfSB9LCAxNTApO1xuICB9XG5cbiAgLy8gUmVhZCB0aGUgYWN0dWFsIGhlaWdodHMgb2YgdGhlIHJlbmRlcmVkIGxpbmVzLCBhbmQgdXBkYXRlIHRoZWlyXG4gIC8vIHN0b3JlZCBoZWlnaHRzIHRvIG1hdGNoLlxuICBmdW5jdGlvbiB1cGRhdGVIZWlnaHRzSW5WaWV3cG9ydChjbSkge1xuICAgIHZhciBkaXNwbGF5ID0gY20uZGlzcGxheTtcbiAgICB2YXIgcHJldkJvdHRvbSA9IGRpc3BsYXkubGluZURpdi5vZmZzZXRUb3A7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXNwbGF5LnZpZXcubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjdXIgPSBkaXNwbGF5LnZpZXdbaV0sIHdyYXBwaW5nID0gY20ub3B0aW9ucy5saW5lV3JhcHBpbmc7XG4gICAgICB2YXIgaGVpZ2h0ID0gKHZvaWQgMCksIHdpZHRoID0gMDtcbiAgICAgIGlmIChjdXIuaGlkZGVuKSB7IGNvbnRpbnVlIH1cbiAgICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDwgOCkge1xuICAgICAgICB2YXIgYm90ID0gY3VyLm5vZGUub2Zmc2V0VG9wICsgY3VyLm5vZGUub2Zmc2V0SGVpZ2h0O1xuICAgICAgICBoZWlnaHQgPSBib3QgLSBwcmV2Qm90dG9tO1xuICAgICAgICBwcmV2Qm90dG9tID0gYm90O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGJveCA9IGN1ci5ub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBoZWlnaHQgPSBib3guYm90dG9tIC0gYm94LnRvcDtcbiAgICAgICAgLy8gQ2hlY2sgdGhhdCBsaW5lcyBkb24ndCBleHRlbmQgcGFzdCB0aGUgcmlnaHQgb2YgdGhlIGN1cnJlbnRcbiAgICAgICAgLy8gZWRpdG9yIHdpZHRoXG4gICAgICAgIGlmICghd3JhcHBpbmcgJiYgY3VyLnRleHQuZmlyc3RDaGlsZClcbiAgICAgICAgICB7IHdpZHRoID0gY3VyLnRleHQuZmlyc3RDaGlsZC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5yaWdodCAtIGJveC5sZWZ0IC0gMTsgfVxuICAgICAgfVxuICAgICAgdmFyIGRpZmYgPSBjdXIubGluZS5oZWlnaHQgLSBoZWlnaHQ7XG4gICAgICBpZiAoZGlmZiA+IC4wMDUgfHwgZGlmZiA8IC0uMDA1KSB7XG4gICAgICAgIHVwZGF0ZUxpbmVIZWlnaHQoY3VyLmxpbmUsIGhlaWdodCk7XG4gICAgICAgIHVwZGF0ZVdpZGdldEhlaWdodChjdXIubGluZSk7XG4gICAgICAgIGlmIChjdXIucmVzdCkgeyBmb3IgKHZhciBqID0gMDsgaiA8IGN1ci5yZXN0Lmxlbmd0aDsgaisrKVxuICAgICAgICAgIHsgdXBkYXRlV2lkZ2V0SGVpZ2h0KGN1ci5yZXN0W2pdKTsgfSB9XG4gICAgICB9XG4gICAgICBpZiAod2lkdGggPiBjbS5kaXNwbGF5LnNpemVyV2lkdGgpIHtcbiAgICAgICAgdmFyIGNoV2lkdGggPSBNYXRoLmNlaWwod2lkdGggLyBjaGFyV2lkdGgoY20uZGlzcGxheSkpO1xuICAgICAgICBpZiAoY2hXaWR0aCA+IGNtLmRpc3BsYXkubWF4TGluZUxlbmd0aCkge1xuICAgICAgICAgIGNtLmRpc3BsYXkubWF4TGluZUxlbmd0aCA9IGNoV2lkdGg7XG4gICAgICAgICAgY20uZGlzcGxheS5tYXhMaW5lID0gY3VyLmxpbmU7XG4gICAgICAgICAgY20uZGlzcGxheS5tYXhMaW5lQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBSZWFkIGFuZCBzdG9yZSB0aGUgaGVpZ2h0IG9mIGxpbmUgd2lkZ2V0cyBhc3NvY2lhdGVkIHdpdGggdGhlXG4gIC8vIGdpdmVuIGxpbmUuXG4gIGZ1bmN0aW9uIHVwZGF0ZVdpZGdldEhlaWdodChsaW5lKSB7XG4gICAgaWYgKGxpbmUud2lkZ2V0cykgeyBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmUud2lkZ2V0cy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIHcgPSBsaW5lLndpZGdldHNbaV0sIHBhcmVudCA9IHcubm9kZS5wYXJlbnROb2RlO1xuICAgICAgaWYgKHBhcmVudCkgeyB3LmhlaWdodCA9IHBhcmVudC5vZmZzZXRIZWlnaHQ7IH1cbiAgICB9IH1cbiAgfVxuXG4gIC8vIENvbXB1dGUgdGhlIGxpbmVzIHRoYXQgYXJlIHZpc2libGUgaW4gYSBnaXZlbiB2aWV3cG9ydCAoZGVmYXVsdHNcbiAgLy8gdGhlIHRoZSBjdXJyZW50IHNjcm9sbCBwb3NpdGlvbikuIHZpZXdwb3J0IG1heSBjb250YWluIHRvcCxcbiAgLy8gaGVpZ2h0LCBhbmQgZW5zdXJlIChzZWUgb3Auc2Nyb2xsVG9Qb3MpIHByb3BlcnRpZXMuXG4gIGZ1bmN0aW9uIHZpc2libGVMaW5lcyhkaXNwbGF5LCBkb2MsIHZpZXdwb3J0KSB7XG4gICAgdmFyIHRvcCA9IHZpZXdwb3J0ICYmIHZpZXdwb3J0LnRvcCAhPSBudWxsID8gTWF0aC5tYXgoMCwgdmlld3BvcnQudG9wKSA6IGRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsVG9wO1xuICAgIHRvcCA9IE1hdGguZmxvb3IodG9wIC0gcGFkZGluZ1RvcChkaXNwbGF5KSk7XG4gICAgdmFyIGJvdHRvbSA9IHZpZXdwb3J0ICYmIHZpZXdwb3J0LmJvdHRvbSAhPSBudWxsID8gdmlld3BvcnQuYm90dG9tIDogdG9wICsgZGlzcGxheS53cmFwcGVyLmNsaWVudEhlaWdodDtcblxuICAgIHZhciBmcm9tID0gbGluZUF0SGVpZ2h0KGRvYywgdG9wKSwgdG8gPSBsaW5lQXRIZWlnaHQoZG9jLCBib3R0b20pO1xuICAgIC8vIEVuc3VyZSBpcyBhIHtmcm9tOiB7bGluZSwgY2h9LCB0bzoge2xpbmUsIGNofX0gb2JqZWN0LCBhbmRcbiAgICAvLyBmb3JjZXMgdGhvc2UgbGluZXMgaW50byB0aGUgdmlld3BvcnQgKGlmIHBvc3NpYmxlKS5cbiAgICBpZiAodmlld3BvcnQgJiYgdmlld3BvcnQuZW5zdXJlKSB7XG4gICAgICB2YXIgZW5zdXJlRnJvbSA9IHZpZXdwb3J0LmVuc3VyZS5mcm9tLmxpbmUsIGVuc3VyZVRvID0gdmlld3BvcnQuZW5zdXJlLnRvLmxpbmU7XG4gICAgICBpZiAoZW5zdXJlRnJvbSA8IGZyb20pIHtcbiAgICAgICAgZnJvbSA9IGVuc3VyZUZyb207XG4gICAgICAgIHRvID0gbGluZUF0SGVpZ2h0KGRvYywgaGVpZ2h0QXRMaW5lKGdldExpbmUoZG9jLCBlbnN1cmVGcm9tKSkgKyBkaXNwbGF5LndyYXBwZXIuY2xpZW50SGVpZ2h0KTtcbiAgICAgIH0gZWxzZSBpZiAoTWF0aC5taW4oZW5zdXJlVG8sIGRvYy5sYXN0TGluZSgpKSA+PSB0bykge1xuICAgICAgICBmcm9tID0gbGluZUF0SGVpZ2h0KGRvYywgaGVpZ2h0QXRMaW5lKGdldExpbmUoZG9jLCBlbnN1cmVUbykpIC0gZGlzcGxheS53cmFwcGVyLmNsaWVudEhlaWdodCk7XG4gICAgICAgIHRvID0gZW5zdXJlVG87XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7ZnJvbTogZnJvbSwgdG86IE1hdGgubWF4KHRvLCBmcm9tICsgMSl9XG4gIH1cblxuICAvLyBTQ1JPTExJTkcgVEhJTkdTIElOVE8gVklFV1xuXG4gIC8vIElmIGFuIGVkaXRvciBzaXRzIG9uIHRoZSB0b3Agb3IgYm90dG9tIG9mIHRoZSB3aW5kb3csIHBhcnRpYWxseVxuICAvLyBzY3JvbGxlZCBvdXQgb2YgdmlldywgdGhpcyBlbnN1cmVzIHRoYXQgdGhlIGN1cnNvciBpcyB2aXNpYmxlLlxuICBmdW5jdGlvbiBtYXliZVNjcm9sbFdpbmRvdyhjbSwgcmVjdCkge1xuICAgIGlmIChzaWduYWxET01FdmVudChjbSwgXCJzY3JvbGxDdXJzb3JJbnRvVmlld1wiKSkgeyByZXR1cm4gfVxuXG4gICAgdmFyIGRpc3BsYXkgPSBjbS5kaXNwbGF5LCBib3ggPSBkaXNwbGF5LnNpemVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBkb1Njcm9sbCA9IG51bGw7XG4gICAgaWYgKHJlY3QudG9wICsgYm94LnRvcCA8IDApIHsgZG9TY3JvbGwgPSB0cnVlOyB9XG4gICAgZWxzZSBpZiAocmVjdC5ib3R0b20gKyBib3gudG9wID4gKHdpbmRvdy5pbm5lckhlaWdodCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0KSkgeyBkb1Njcm9sbCA9IGZhbHNlOyB9XG4gICAgaWYgKGRvU2Nyb2xsICE9IG51bGwgJiYgIXBoYW50b20pIHtcbiAgICAgIHZhciBzY3JvbGxOb2RlID0gZWx0KFwiZGl2XCIsIFwiXFx1MjAwYlwiLCBudWxsLCAoXCJwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogXCIgKyAocmVjdC50b3AgLSBkaXNwbGF5LnZpZXdPZmZzZXQgLSBwYWRkaW5nVG9wKGNtLmRpc3BsYXkpKSArIFwicHg7XFxuICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogXCIgKyAocmVjdC5ib3R0b20gLSByZWN0LnRvcCArIHNjcm9sbEdhcChjbSkgKyBkaXNwbGF5LmJhckhlaWdodCkgKyBcInB4O1xcbiAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBcIiArIChyZWN0LmxlZnQpICsgXCJweDsgd2lkdGg6IFwiICsgKE1hdGgubWF4KDIsIHJlY3QucmlnaHQgLSByZWN0LmxlZnQpKSArIFwicHg7XCIpKTtcbiAgICAgIGNtLmRpc3BsYXkubGluZVNwYWNlLmFwcGVuZENoaWxkKHNjcm9sbE5vZGUpO1xuICAgICAgc2Nyb2xsTm9kZS5zY3JvbGxJbnRvVmlldyhkb1Njcm9sbCk7XG4gICAgICBjbS5kaXNwbGF5LmxpbmVTcGFjZS5yZW1vdmVDaGlsZChzY3JvbGxOb2RlKTtcbiAgICB9XG4gIH1cblxuICAvLyBTY3JvbGwgYSBnaXZlbiBwb3NpdGlvbiBpbnRvIHZpZXcgKGltbWVkaWF0ZWx5KSwgdmVyaWZ5aW5nIHRoYXRcbiAgLy8gaXQgYWN0dWFsbHkgYmVjYW1lIHZpc2libGUgKGFzIGxpbmUgaGVpZ2h0cyBhcmUgYWNjdXJhdGVseVxuICAvLyBtZWFzdXJlZCwgdGhlIHBvc2l0aW9uIG9mIHNvbWV0aGluZyBtYXkgJ2RyaWZ0JyBkdXJpbmcgZHJhd2luZykuXG4gIGZ1bmN0aW9uIHNjcm9sbFBvc0ludG9WaWV3KGNtLCBwb3MsIGVuZCwgbWFyZ2luKSB7XG4gICAgaWYgKG1hcmdpbiA9PSBudWxsKSB7IG1hcmdpbiA9IDA7IH1cbiAgICB2YXIgcmVjdDtcbiAgICBpZiAoIWNtLm9wdGlvbnMubGluZVdyYXBwaW5nICYmIHBvcyA9PSBlbmQpIHtcbiAgICAgIC8vIFNldCBwb3MgYW5kIGVuZCB0byB0aGUgY3Vyc29yIHBvc2l0aW9ucyBhcm91bmQgdGhlIGNoYXJhY3RlciBwb3Mgc3RpY2tzIHRvXG4gICAgICAvLyBJZiBwb3Muc3RpY2t5ID09IFwiYmVmb3JlXCIsIHRoYXQgaXMgYXJvdW5kIHBvcy5jaCAtIDEsIG90aGVyd2lzZSBhcm91bmQgcG9zLmNoXG4gICAgICAvLyBJZiBwb3MgPT0gUG9zKF8sIDAsIFwiYmVmb3JlXCIpLCBwb3MgYW5kIGVuZCBhcmUgdW5jaGFuZ2VkXG4gICAgICBwb3MgPSBwb3MuY2ggPyBQb3MocG9zLmxpbmUsIHBvcy5zdGlja3kgPT0gXCJiZWZvcmVcIiA/IHBvcy5jaCAtIDEgOiBwb3MuY2gsIFwiYWZ0ZXJcIikgOiBwb3M7XG4gICAgICBlbmQgPSBwb3Muc3RpY2t5ID09IFwiYmVmb3JlXCIgPyBQb3MocG9zLmxpbmUsIHBvcy5jaCArIDEsIFwiYmVmb3JlXCIpIDogcG9zO1xuICAgIH1cbiAgICBmb3IgKHZhciBsaW1pdCA9IDA7IGxpbWl0IDwgNTsgbGltaXQrKykge1xuICAgICAgdmFyIGNoYW5nZWQgPSBmYWxzZTtcbiAgICAgIHZhciBjb29yZHMgPSBjdXJzb3JDb29yZHMoY20sIHBvcyk7XG4gICAgICB2YXIgZW5kQ29vcmRzID0gIWVuZCB8fCBlbmQgPT0gcG9zID8gY29vcmRzIDogY3Vyc29yQ29vcmRzKGNtLCBlbmQpO1xuICAgICAgcmVjdCA9IHtsZWZ0OiBNYXRoLm1pbihjb29yZHMubGVmdCwgZW5kQ29vcmRzLmxlZnQpLFxuICAgICAgICAgICAgICB0b3A6IE1hdGgubWluKGNvb3Jkcy50b3AsIGVuZENvb3Jkcy50b3ApIC0gbWFyZ2luLFxuICAgICAgICAgICAgICByaWdodDogTWF0aC5tYXgoY29vcmRzLmxlZnQsIGVuZENvb3Jkcy5sZWZ0KSxcbiAgICAgICAgICAgICAgYm90dG9tOiBNYXRoLm1heChjb29yZHMuYm90dG9tLCBlbmRDb29yZHMuYm90dG9tKSArIG1hcmdpbn07XG4gICAgICB2YXIgc2Nyb2xsUG9zID0gY2FsY3VsYXRlU2Nyb2xsUG9zKGNtLCByZWN0KTtcbiAgICAgIHZhciBzdGFydFRvcCA9IGNtLmRvYy5zY3JvbGxUb3AsIHN0YXJ0TGVmdCA9IGNtLmRvYy5zY3JvbGxMZWZ0O1xuICAgICAgaWYgKHNjcm9sbFBvcy5zY3JvbGxUb3AgIT0gbnVsbCkge1xuICAgICAgICB1cGRhdGVTY3JvbGxUb3AoY20sIHNjcm9sbFBvcy5zY3JvbGxUb3ApO1xuICAgICAgICBpZiAoTWF0aC5hYnMoY20uZG9jLnNjcm9sbFRvcCAtIHN0YXJ0VG9wKSA+IDEpIHsgY2hhbmdlZCA9IHRydWU7IH1cbiAgICAgIH1cbiAgICAgIGlmIChzY3JvbGxQb3Muc2Nyb2xsTGVmdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFNjcm9sbExlZnQoY20sIHNjcm9sbFBvcy5zY3JvbGxMZWZ0KTtcbiAgICAgICAgaWYgKE1hdGguYWJzKGNtLmRvYy5zY3JvbGxMZWZ0IC0gc3RhcnRMZWZ0KSA+IDEpIHsgY2hhbmdlZCA9IHRydWU7IH1cbiAgICAgIH1cbiAgICAgIGlmICghY2hhbmdlZCkgeyBicmVhayB9XG4gICAgfVxuICAgIHJldHVybiByZWN0XG4gIH1cblxuICAvLyBTY3JvbGwgYSBnaXZlbiBzZXQgb2YgY29vcmRpbmF0ZXMgaW50byB2aWV3IChpbW1lZGlhdGVseSkuXG4gIGZ1bmN0aW9uIHNjcm9sbEludG9WaWV3KGNtLCByZWN0KSB7XG4gICAgdmFyIHNjcm9sbFBvcyA9IGNhbGN1bGF0ZVNjcm9sbFBvcyhjbSwgcmVjdCk7XG4gICAgaWYgKHNjcm9sbFBvcy5zY3JvbGxUb3AgIT0gbnVsbCkgeyB1cGRhdGVTY3JvbGxUb3AoY20sIHNjcm9sbFBvcy5zY3JvbGxUb3ApOyB9XG4gICAgaWYgKHNjcm9sbFBvcy5zY3JvbGxMZWZ0ICE9IG51bGwpIHsgc2V0U2Nyb2xsTGVmdChjbSwgc2Nyb2xsUG9zLnNjcm9sbExlZnQpOyB9XG4gIH1cblxuICAvLyBDYWxjdWxhdGUgYSBuZXcgc2Nyb2xsIHBvc2l0aW9uIG5lZWRlZCB0byBzY3JvbGwgdGhlIGdpdmVuXG4gIC8vIHJlY3RhbmdsZSBpbnRvIHZpZXcuIFJldHVybnMgYW4gb2JqZWN0IHdpdGggc2Nyb2xsVG9wIGFuZFxuICAvLyBzY3JvbGxMZWZ0IHByb3BlcnRpZXMuIFdoZW4gdGhlc2UgYXJlIHVuZGVmaW5lZCwgdGhlXG4gIC8vIHZlcnRpY2FsL2hvcml6b250YWwgcG9zaXRpb24gZG9lcyBub3QgbmVlZCB0byBiZSBhZGp1c3RlZC5cbiAgZnVuY3Rpb24gY2FsY3VsYXRlU2Nyb2xsUG9zKGNtLCByZWN0KSB7XG4gICAgdmFyIGRpc3BsYXkgPSBjbS5kaXNwbGF5LCBzbmFwTWFyZ2luID0gdGV4dEhlaWdodChjbS5kaXNwbGF5KTtcbiAgICBpZiAocmVjdC50b3AgPCAwKSB7IHJlY3QudG9wID0gMDsgfVxuICAgIHZhciBzY3JlZW50b3AgPSBjbS5jdXJPcCAmJiBjbS5jdXJPcC5zY3JvbGxUb3AgIT0gbnVsbCA/IGNtLmN1ck9wLnNjcm9sbFRvcCA6IGRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsVG9wO1xuICAgIHZhciBzY3JlZW4gPSBkaXNwbGF5SGVpZ2h0KGNtKSwgcmVzdWx0ID0ge307XG4gICAgaWYgKHJlY3QuYm90dG9tIC0gcmVjdC50b3AgPiBzY3JlZW4pIHsgcmVjdC5ib3R0b20gPSByZWN0LnRvcCArIHNjcmVlbjsgfVxuICAgIHZhciBkb2NCb3R0b20gPSBjbS5kb2MuaGVpZ2h0ICsgcGFkZGluZ1ZlcnQoZGlzcGxheSk7XG4gICAgdmFyIGF0VG9wID0gcmVjdC50b3AgPCBzbmFwTWFyZ2luLCBhdEJvdHRvbSA9IHJlY3QuYm90dG9tID4gZG9jQm90dG9tIC0gc25hcE1hcmdpbjtcbiAgICBpZiAocmVjdC50b3AgPCBzY3JlZW50b3ApIHtcbiAgICAgIHJlc3VsdC5zY3JvbGxUb3AgPSBhdFRvcCA/IDAgOiByZWN0LnRvcDtcbiAgICB9IGVsc2UgaWYgKHJlY3QuYm90dG9tID4gc2NyZWVudG9wICsgc2NyZWVuKSB7XG4gICAgICB2YXIgbmV3VG9wID0gTWF0aC5taW4ocmVjdC50b3AsIChhdEJvdHRvbSA/IGRvY0JvdHRvbSA6IHJlY3QuYm90dG9tKSAtIHNjcmVlbik7XG4gICAgICBpZiAobmV3VG9wICE9IHNjcmVlbnRvcCkgeyByZXN1bHQuc2Nyb2xsVG9wID0gbmV3VG9wOyB9XG4gICAgfVxuXG4gICAgdmFyIGd1dHRlclNwYWNlID0gY20ub3B0aW9ucy5maXhlZEd1dHRlciA/IDAgOiBkaXNwbGF5Lmd1dHRlcnMub2Zmc2V0V2lkdGg7XG4gICAgdmFyIHNjcmVlbmxlZnQgPSBjbS5jdXJPcCAmJiBjbS5jdXJPcC5zY3JvbGxMZWZ0ICE9IG51bGwgPyBjbS5jdXJPcC5zY3JvbGxMZWZ0IDogZGlzcGxheS5zY3JvbGxlci5zY3JvbGxMZWZ0IC0gZ3V0dGVyU3BhY2U7XG4gICAgdmFyIHNjcmVlbncgPSBkaXNwbGF5V2lkdGgoY20pIC0gZGlzcGxheS5ndXR0ZXJzLm9mZnNldFdpZHRoO1xuICAgIHZhciB0b29XaWRlID0gcmVjdC5yaWdodCAtIHJlY3QubGVmdCA+IHNjcmVlbnc7XG4gICAgaWYgKHRvb1dpZGUpIHsgcmVjdC5yaWdodCA9IHJlY3QubGVmdCArIHNjcmVlbnc7IH1cbiAgICBpZiAocmVjdC5sZWZ0IDwgMTApXG4gICAgICB7IHJlc3VsdC5zY3JvbGxMZWZ0ID0gMDsgfVxuICAgIGVsc2UgaWYgKHJlY3QubGVmdCA8IHNjcmVlbmxlZnQpXG4gICAgICB7IHJlc3VsdC5zY3JvbGxMZWZ0ID0gTWF0aC5tYXgoMCwgcmVjdC5sZWZ0ICsgZ3V0dGVyU3BhY2UgLSAodG9vV2lkZSA/IDAgOiAxMCkpOyB9XG4gICAgZWxzZSBpZiAocmVjdC5yaWdodCA+IHNjcmVlbncgKyBzY3JlZW5sZWZ0IC0gMylcbiAgICAgIHsgcmVzdWx0LnNjcm9sbExlZnQgPSByZWN0LnJpZ2h0ICsgKHRvb1dpZGUgPyAwIDogMTApIC0gc2NyZWVudzsgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIC8vIFN0b3JlIGEgcmVsYXRpdmUgYWRqdXN0bWVudCB0byB0aGUgc2Nyb2xsIHBvc2l0aW9uIGluIHRoZSBjdXJyZW50XG4gIC8vIG9wZXJhdGlvbiAodG8gYmUgYXBwbGllZCB3aGVuIHRoZSBvcGVyYXRpb24gZmluaXNoZXMpLlxuICBmdW5jdGlvbiBhZGRUb1Njcm9sbFRvcChjbSwgdG9wKSB7XG4gICAgaWYgKHRvcCA9PSBudWxsKSB7IHJldHVybiB9XG4gICAgcmVzb2x2ZVNjcm9sbFRvUG9zKGNtKTtcbiAgICBjbS5jdXJPcC5zY3JvbGxUb3AgPSAoY20uY3VyT3Auc2Nyb2xsVG9wID09IG51bGwgPyBjbS5kb2Muc2Nyb2xsVG9wIDogY20uY3VyT3Auc2Nyb2xsVG9wKSArIHRvcDtcbiAgfVxuXG4gIC8vIE1ha2Ugc3VyZSB0aGF0IGF0IHRoZSBlbmQgb2YgdGhlIG9wZXJhdGlvbiB0aGUgY3VycmVudCBjdXJzb3IgaXNcbiAgLy8gc2hvd24uXG4gIGZ1bmN0aW9uIGVuc3VyZUN1cnNvclZpc2libGUoY20pIHtcbiAgICByZXNvbHZlU2Nyb2xsVG9Qb3MoY20pO1xuICAgIHZhciBjdXIgPSBjbS5nZXRDdXJzb3IoKTtcbiAgICBjbS5jdXJPcC5zY3JvbGxUb1BvcyA9IHtmcm9tOiBjdXIsIHRvOiBjdXIsIG1hcmdpbjogY20ub3B0aW9ucy5jdXJzb3JTY3JvbGxNYXJnaW59O1xuICB9XG5cbiAgZnVuY3Rpb24gc2Nyb2xsVG9Db29yZHMoY20sIHgsIHkpIHtcbiAgICBpZiAoeCAhPSBudWxsIHx8IHkgIT0gbnVsbCkgeyByZXNvbHZlU2Nyb2xsVG9Qb3MoY20pOyB9XG4gICAgaWYgKHggIT0gbnVsbCkgeyBjbS5jdXJPcC5zY3JvbGxMZWZ0ID0geDsgfVxuICAgIGlmICh5ICE9IG51bGwpIHsgY20uY3VyT3Auc2Nyb2xsVG9wID0geTsgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2Nyb2xsVG9SYW5nZShjbSwgcmFuZ2UpIHtcbiAgICByZXNvbHZlU2Nyb2xsVG9Qb3MoY20pO1xuICAgIGNtLmN1ck9wLnNjcm9sbFRvUG9zID0gcmFuZ2U7XG4gIH1cblxuICAvLyBXaGVuIGFuIG9wZXJhdGlvbiBoYXMgaXRzIHNjcm9sbFRvUG9zIHByb3BlcnR5IHNldCwgYW5kIGFub3RoZXJcbiAgLy8gc2Nyb2xsIGFjdGlvbiBpcyBhcHBsaWVkIGJlZm9yZSB0aGUgZW5kIG9mIHRoZSBvcGVyYXRpb24sIHRoaXNcbiAgLy8gJ3NpbXVsYXRlcycgc2Nyb2xsaW5nIHRoYXQgcG9zaXRpb24gaW50byB2aWV3IGluIGEgY2hlYXAgd2F5LCBzb1xuICAvLyB0aGF0IHRoZSBlZmZlY3Qgb2YgaW50ZXJtZWRpYXRlIHNjcm9sbCBjb21tYW5kcyBpcyBub3QgaWdub3JlZC5cbiAgZnVuY3Rpb24gcmVzb2x2ZVNjcm9sbFRvUG9zKGNtKSB7XG4gICAgdmFyIHJhbmdlID0gY20uY3VyT3Auc2Nyb2xsVG9Qb3M7XG4gICAgaWYgKHJhbmdlKSB7XG4gICAgICBjbS5jdXJPcC5zY3JvbGxUb1BvcyA9IG51bGw7XG4gICAgICB2YXIgZnJvbSA9IGVzdGltYXRlQ29vcmRzKGNtLCByYW5nZS5mcm9tKSwgdG8gPSBlc3RpbWF0ZUNvb3JkcyhjbSwgcmFuZ2UudG8pO1xuICAgICAgc2Nyb2xsVG9Db29yZHNSYW5nZShjbSwgZnJvbSwgdG8sIHJhbmdlLm1hcmdpbik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2Nyb2xsVG9Db29yZHNSYW5nZShjbSwgZnJvbSwgdG8sIG1hcmdpbikge1xuICAgIHZhciBzUG9zID0gY2FsY3VsYXRlU2Nyb2xsUG9zKGNtLCB7XG4gICAgICBsZWZ0OiBNYXRoLm1pbihmcm9tLmxlZnQsIHRvLmxlZnQpLFxuICAgICAgdG9wOiBNYXRoLm1pbihmcm9tLnRvcCwgdG8udG9wKSAtIG1hcmdpbixcbiAgICAgIHJpZ2h0OiBNYXRoLm1heChmcm9tLnJpZ2h0LCB0by5yaWdodCksXG4gICAgICBib3R0b206IE1hdGgubWF4KGZyb20uYm90dG9tLCB0by5ib3R0b20pICsgbWFyZ2luXG4gICAgfSk7XG4gICAgc2Nyb2xsVG9Db29yZHMoY20sIHNQb3Muc2Nyb2xsTGVmdCwgc1Bvcy5zY3JvbGxUb3ApO1xuICB9XG5cbiAgLy8gU3luYyB0aGUgc2Nyb2xsYWJsZSBhcmVhIGFuZCBzY3JvbGxiYXJzLCBlbnN1cmUgdGhlIHZpZXdwb3J0XG4gIC8vIGNvdmVycyB0aGUgdmlzaWJsZSBhcmVhLlxuICBmdW5jdGlvbiB1cGRhdGVTY3JvbGxUb3AoY20sIHZhbCkge1xuICAgIGlmIChNYXRoLmFicyhjbS5kb2Muc2Nyb2xsVG9wIC0gdmFsKSA8IDIpIHsgcmV0dXJuIH1cbiAgICBpZiAoIWdlY2tvKSB7IHVwZGF0ZURpc3BsYXlTaW1wbGUoY20sIHt0b3A6IHZhbH0pOyB9XG4gICAgc2V0U2Nyb2xsVG9wKGNtLCB2YWwsIHRydWUpO1xuICAgIGlmIChnZWNrbykgeyB1cGRhdGVEaXNwbGF5U2ltcGxlKGNtKTsgfVxuICAgIHN0YXJ0V29ya2VyKGNtLCAxMDApO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0U2Nyb2xsVG9wKGNtLCB2YWwsIGZvcmNlU2Nyb2xsKSB7XG4gICAgdmFsID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oY20uZGlzcGxheS5zY3JvbGxlci5zY3JvbGxIZWlnaHQgLSBjbS5kaXNwbGF5LnNjcm9sbGVyLmNsaWVudEhlaWdodCwgdmFsKSk7XG4gICAgaWYgKGNtLmRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsVG9wID09IHZhbCAmJiAhZm9yY2VTY3JvbGwpIHsgcmV0dXJuIH1cbiAgICBjbS5kb2Muc2Nyb2xsVG9wID0gdmFsO1xuICAgIGNtLmRpc3BsYXkuc2Nyb2xsYmFycy5zZXRTY3JvbGxUb3AodmFsKTtcbiAgICBpZiAoY20uZGlzcGxheS5zY3JvbGxlci5zY3JvbGxUb3AgIT0gdmFsKSB7IGNtLmRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsVG9wID0gdmFsOyB9XG4gIH1cblxuICAvLyBTeW5jIHNjcm9sbGVyIGFuZCBzY3JvbGxiYXIsIGVuc3VyZSB0aGUgZ3V0dGVyIGVsZW1lbnRzIGFyZVxuICAvLyBhbGlnbmVkLlxuICBmdW5jdGlvbiBzZXRTY3JvbGxMZWZ0KGNtLCB2YWwsIGlzU2Nyb2xsZXIsIGZvcmNlU2Nyb2xsKSB7XG4gICAgdmFsID0gTWF0aC5tYXgoMCwgTWF0aC5taW4odmFsLCBjbS5kaXNwbGF5LnNjcm9sbGVyLnNjcm9sbFdpZHRoIC0gY20uZGlzcGxheS5zY3JvbGxlci5jbGllbnRXaWR0aCkpO1xuICAgIGlmICgoaXNTY3JvbGxlciA/IHZhbCA9PSBjbS5kb2Muc2Nyb2xsTGVmdCA6IE1hdGguYWJzKGNtLmRvYy5zY3JvbGxMZWZ0IC0gdmFsKSA8IDIpICYmICFmb3JjZVNjcm9sbCkgeyByZXR1cm4gfVxuICAgIGNtLmRvYy5zY3JvbGxMZWZ0ID0gdmFsO1xuICAgIGFsaWduSG9yaXpvbnRhbGx5KGNtKTtcbiAgICBpZiAoY20uZGlzcGxheS5zY3JvbGxlci5zY3JvbGxMZWZ0ICE9IHZhbCkgeyBjbS5kaXNwbGF5LnNjcm9sbGVyLnNjcm9sbExlZnQgPSB2YWw7IH1cbiAgICBjbS5kaXNwbGF5LnNjcm9sbGJhcnMuc2V0U2Nyb2xsTGVmdCh2YWwpO1xuICB9XG5cbiAgLy8gU0NST0xMQkFSU1xuXG4gIC8vIFByZXBhcmUgRE9NIHJlYWRzIG5lZWRlZCB0byB1cGRhdGUgdGhlIHNjcm9sbGJhcnMuIERvbmUgaW4gb25lXG4gIC8vIHNob3QgdG8gbWluaW1pemUgdXBkYXRlL21lYXN1cmUgcm91bmR0cmlwcy5cbiAgZnVuY3Rpb24gbWVhc3VyZUZvclNjcm9sbGJhcnMoY20pIHtcbiAgICB2YXIgZCA9IGNtLmRpc3BsYXksIGd1dHRlclcgPSBkLmd1dHRlcnMub2Zmc2V0V2lkdGg7XG4gICAgdmFyIGRvY0ggPSBNYXRoLnJvdW5kKGNtLmRvYy5oZWlnaHQgKyBwYWRkaW5nVmVydChjbS5kaXNwbGF5KSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNsaWVudEhlaWdodDogZC5zY3JvbGxlci5jbGllbnRIZWlnaHQsXG4gICAgICB2aWV3SGVpZ2h0OiBkLndyYXBwZXIuY2xpZW50SGVpZ2h0LFxuICAgICAgc2Nyb2xsV2lkdGg6IGQuc2Nyb2xsZXIuc2Nyb2xsV2lkdGgsIGNsaWVudFdpZHRoOiBkLnNjcm9sbGVyLmNsaWVudFdpZHRoLFxuICAgICAgdmlld1dpZHRoOiBkLndyYXBwZXIuY2xpZW50V2lkdGgsXG4gICAgICBiYXJMZWZ0OiBjbS5vcHRpb25zLmZpeGVkR3V0dGVyID8gZ3V0dGVyVyA6IDAsXG4gICAgICBkb2NIZWlnaHQ6IGRvY0gsXG4gICAgICBzY3JvbGxIZWlnaHQ6IGRvY0ggKyBzY3JvbGxHYXAoY20pICsgZC5iYXJIZWlnaHQsXG4gICAgICBuYXRpdmVCYXJXaWR0aDogZC5uYXRpdmVCYXJXaWR0aCxcbiAgICAgIGd1dHRlcldpZHRoOiBndXR0ZXJXXG4gICAgfVxuICB9XG5cbiAgdmFyIE5hdGl2ZVNjcm9sbGJhcnMgPSBmdW5jdGlvbihwbGFjZSwgc2Nyb2xsLCBjbSkge1xuICAgIHRoaXMuY20gPSBjbTtcbiAgICB2YXIgdmVydCA9IHRoaXMudmVydCA9IGVsdChcImRpdlwiLCBbZWx0KFwiZGl2XCIsIG51bGwsIG51bGwsIFwibWluLXdpZHRoOiAxcHhcIildLCBcIkNvZGVNaXJyb3ItdnNjcm9sbGJhclwiKTtcbiAgICB2YXIgaG9yaXogPSB0aGlzLmhvcml6ID0gZWx0KFwiZGl2XCIsIFtlbHQoXCJkaXZcIiwgbnVsbCwgbnVsbCwgXCJoZWlnaHQ6IDEwMCU7IG1pbi1oZWlnaHQ6IDFweFwiKV0sIFwiQ29kZU1pcnJvci1oc2Nyb2xsYmFyXCIpO1xuICAgIHZlcnQudGFiSW5kZXggPSBob3Jpei50YWJJbmRleCA9IC0xO1xuICAgIHBsYWNlKHZlcnQpOyBwbGFjZShob3Jpeik7XG5cbiAgICBvbih2ZXJ0LCBcInNjcm9sbFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodmVydC5jbGllbnRIZWlnaHQpIHsgc2Nyb2xsKHZlcnQuc2Nyb2xsVG9wLCBcInZlcnRpY2FsXCIpOyB9XG4gICAgfSk7XG4gICAgb24oaG9yaXosIFwic2Nyb2xsXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChob3Jpei5jbGllbnRXaWR0aCkgeyBzY3JvbGwoaG9yaXouc2Nyb2xsTGVmdCwgXCJob3Jpem9udGFsXCIpOyB9XG4gICAgfSk7XG5cbiAgICB0aGlzLmNoZWNrZWRaZXJvV2lkdGggPSBmYWxzZTtcbiAgICAvLyBOZWVkIHRvIHNldCBhIG1pbmltdW0gd2lkdGggdG8gc2VlIHRoZSBzY3JvbGxiYXIgb24gSUU3IChidXQgbXVzdCBub3Qgc2V0IGl0IG9uIElFOCkuXG4gICAgaWYgKGllICYmIGllX3ZlcnNpb24gPCA4KSB7IHRoaXMuaG9yaXouc3R5bGUubWluSGVpZ2h0ID0gdGhpcy52ZXJ0LnN0eWxlLm1pbldpZHRoID0gXCIxOHB4XCI7IH1cbiAgfTtcblxuICBOYXRpdmVTY3JvbGxiYXJzLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAobWVhc3VyZSkge1xuICAgIHZhciBuZWVkc0ggPSBtZWFzdXJlLnNjcm9sbFdpZHRoID4gbWVhc3VyZS5jbGllbnRXaWR0aCArIDE7XG4gICAgdmFyIG5lZWRzViA9IG1lYXN1cmUuc2Nyb2xsSGVpZ2h0ID4gbWVhc3VyZS5jbGllbnRIZWlnaHQgKyAxO1xuICAgIHZhciBzV2lkdGggPSBtZWFzdXJlLm5hdGl2ZUJhcldpZHRoO1xuXG4gICAgaWYgKG5lZWRzVikge1xuICAgICAgdGhpcy52ZXJ0LnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgICB0aGlzLnZlcnQuc3R5bGUuYm90dG9tID0gbmVlZHNIID8gc1dpZHRoICsgXCJweFwiIDogXCIwXCI7XG4gICAgICB2YXIgdG90YWxIZWlnaHQgPSBtZWFzdXJlLnZpZXdIZWlnaHQgLSAobmVlZHNIID8gc1dpZHRoIDogMCk7XG4gICAgICAvLyBBIGJ1ZyBpbiBJRTggY2FuIGNhdXNlIHRoaXMgdmFsdWUgdG8gYmUgbmVnYXRpdmUsIHNvIGd1YXJkIGl0LlxuICAgICAgdGhpcy52ZXJ0LmZpcnN0Q2hpbGQuc3R5bGUuaGVpZ2h0ID1cbiAgICAgICAgTWF0aC5tYXgoMCwgbWVhc3VyZS5zY3JvbGxIZWlnaHQgLSBtZWFzdXJlLmNsaWVudEhlaWdodCArIHRvdGFsSGVpZ2h0KSArIFwicHhcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy52ZXJ0LnN0eWxlLmRpc3BsYXkgPSBcIlwiO1xuICAgICAgdGhpcy52ZXJ0LmZpcnN0Q2hpbGQuc3R5bGUuaGVpZ2h0ID0gXCIwXCI7XG4gICAgfVxuXG4gICAgaWYgKG5lZWRzSCkge1xuICAgICAgdGhpcy5ob3Jpei5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgICAgdGhpcy5ob3Jpei5zdHlsZS5yaWdodCA9IG5lZWRzViA/IHNXaWR0aCArIFwicHhcIiA6IFwiMFwiO1xuICAgICAgdGhpcy5ob3Jpei5zdHlsZS5sZWZ0ID0gbWVhc3VyZS5iYXJMZWZ0ICsgXCJweFwiO1xuICAgICAgdmFyIHRvdGFsV2lkdGggPSBtZWFzdXJlLnZpZXdXaWR0aCAtIG1lYXN1cmUuYmFyTGVmdCAtIChuZWVkc1YgPyBzV2lkdGggOiAwKTtcbiAgICAgIHRoaXMuaG9yaXouZmlyc3RDaGlsZC5zdHlsZS53aWR0aCA9XG4gICAgICAgIE1hdGgubWF4KDAsIG1lYXN1cmUuc2Nyb2xsV2lkdGggLSBtZWFzdXJlLmNsaWVudFdpZHRoICsgdG90YWxXaWR0aCkgKyBcInB4XCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaG9yaXouc3R5bGUuZGlzcGxheSA9IFwiXCI7XG4gICAgICB0aGlzLmhvcml6LmZpcnN0Q2hpbGQuc3R5bGUud2lkdGggPSBcIjBcIjtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuY2hlY2tlZFplcm9XaWR0aCAmJiBtZWFzdXJlLmNsaWVudEhlaWdodCA+IDApIHtcbiAgICAgIGlmIChzV2lkdGggPT0gMCkgeyB0aGlzLnplcm9XaWR0aEhhY2soKTsgfVxuICAgICAgdGhpcy5jaGVja2VkWmVyb1dpZHRoID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4ge3JpZ2h0OiBuZWVkc1YgPyBzV2lkdGggOiAwLCBib3R0b206IG5lZWRzSCA/IHNXaWR0aCA6IDB9XG4gIH07XG5cbiAgTmF0aXZlU2Nyb2xsYmFycy5wcm90b3R5cGUuc2V0U2Nyb2xsTGVmdCA9IGZ1bmN0aW9uIChwb3MpIHtcbiAgICBpZiAodGhpcy5ob3Jpei5zY3JvbGxMZWZ0ICE9IHBvcykgeyB0aGlzLmhvcml6LnNjcm9sbExlZnQgPSBwb3M7IH1cbiAgICBpZiAodGhpcy5kaXNhYmxlSG9yaXopIHsgdGhpcy5lbmFibGVaZXJvV2lkdGhCYXIodGhpcy5ob3JpeiwgdGhpcy5kaXNhYmxlSG9yaXosIFwiaG9yaXpcIik7IH1cbiAgfTtcblxuICBOYXRpdmVTY3JvbGxiYXJzLnByb3RvdHlwZS5zZXRTY3JvbGxUb3AgPSBmdW5jdGlvbiAocG9zKSB7XG4gICAgaWYgKHRoaXMudmVydC5zY3JvbGxUb3AgIT0gcG9zKSB7IHRoaXMudmVydC5zY3JvbGxUb3AgPSBwb3M7IH1cbiAgICBpZiAodGhpcy5kaXNhYmxlVmVydCkgeyB0aGlzLmVuYWJsZVplcm9XaWR0aEJhcih0aGlzLnZlcnQsIHRoaXMuZGlzYWJsZVZlcnQsIFwidmVydFwiKTsgfVxuICB9O1xuXG4gIE5hdGl2ZVNjcm9sbGJhcnMucHJvdG90eXBlLnplcm9XaWR0aEhhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHcgPSBtYWMgJiYgIW1hY19nZU1vdW50YWluTGlvbiA/IFwiMTJweFwiIDogXCIxOHB4XCI7XG4gICAgdGhpcy5ob3Jpei5zdHlsZS5oZWlnaHQgPSB0aGlzLnZlcnQuc3R5bGUud2lkdGggPSB3O1xuICAgIHRoaXMuaG9yaXouc3R5bGUucG9pbnRlckV2ZW50cyA9IHRoaXMudmVydC5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJub25lXCI7XG4gICAgdGhpcy5kaXNhYmxlSG9yaXogPSBuZXcgRGVsYXllZDtcbiAgICB0aGlzLmRpc2FibGVWZXJ0ID0gbmV3IERlbGF5ZWQ7XG4gIH07XG5cbiAgTmF0aXZlU2Nyb2xsYmFycy5wcm90b3R5cGUuZW5hYmxlWmVyb1dpZHRoQmFyID0gZnVuY3Rpb24gKGJhciwgZGVsYXksIHR5cGUpIHtcbiAgICBiYXIuc3R5bGUucG9pbnRlckV2ZW50cyA9IFwiYXV0b1wiO1xuICAgIGZ1bmN0aW9uIG1heWJlRGlzYWJsZSgpIHtcbiAgICAgIC8vIFRvIGZpbmQgb3V0IHdoZXRoZXIgdGhlIHNjcm9sbGJhciBpcyBzdGlsbCB2aXNpYmxlLCB3ZVxuICAgICAgLy8gY2hlY2sgd2hldGhlciB0aGUgZWxlbWVudCB1bmRlciB0aGUgcGl4ZWwgaW4gdGhlIGJvdHRvbVxuICAgICAgLy8gcmlnaHQgY29ybmVyIG9mIHRoZSBzY3JvbGxiYXIgYm94IGlzIHRoZSBzY3JvbGxiYXIgYm94XG4gICAgICAvLyBpdHNlbGYgKHdoZW4gdGhlIGJhciBpcyBzdGlsbCB2aXNpYmxlKSBvciBpdHMgZmlsbGVyIGNoaWxkXG4gICAgICAvLyAod2hlbiB0aGUgYmFyIGlzIGhpZGRlbikuIElmIGl0IGlzIHN0aWxsIHZpc2libGUsIHdlIGtlZXBcbiAgICAgIC8vIGl0IGVuYWJsZWQsIGlmIGl0J3MgaGlkZGVuLCB3ZSBkaXNhYmxlIHBvaW50ZXIgZXZlbnRzLlxuICAgICAgdmFyIGJveCA9IGJhci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHZhciBlbHQgPSB0eXBlID09IFwidmVydFwiID8gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChib3gucmlnaHQgLSAxLCAoYm94LnRvcCArIGJveC5ib3R0b20pIC8gMilcbiAgICAgICAgICA6IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQoKGJveC5yaWdodCArIGJveC5sZWZ0KSAvIDIsIGJveC5ib3R0b20gLSAxKTtcbiAgICAgIGlmIChlbHQgIT0gYmFyKSB7IGJhci5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJub25lXCI7IH1cbiAgICAgIGVsc2UgeyBkZWxheS5zZXQoMTAwMCwgbWF5YmVEaXNhYmxlKTsgfVxuICAgIH1cbiAgICBkZWxheS5zZXQoMTAwMCwgbWF5YmVEaXNhYmxlKTtcbiAgfTtcblxuICBOYXRpdmVTY3JvbGxiYXJzLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcGFyZW50ID0gdGhpcy5ob3Jpei5wYXJlbnROb2RlO1xuICAgIHBhcmVudC5yZW1vdmVDaGlsZCh0aGlzLmhvcml6KTtcbiAgICBwYXJlbnQucmVtb3ZlQ2hpbGQodGhpcy52ZXJ0KTtcbiAgfTtcblxuICB2YXIgTnVsbFNjcm9sbGJhcnMgPSBmdW5jdGlvbiAoKSB7fTtcblxuICBOdWxsU2Nyb2xsYmFycy5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4ge2JvdHRvbTogMCwgcmlnaHQ6IDB9IH07XG4gIE51bGxTY3JvbGxiYXJzLnByb3RvdHlwZS5zZXRTY3JvbGxMZWZ0ID0gZnVuY3Rpb24gKCkge307XG4gIE51bGxTY3JvbGxiYXJzLnByb3RvdHlwZS5zZXRTY3JvbGxUb3AgPSBmdW5jdGlvbiAoKSB7fTtcbiAgTnVsbFNjcm9sbGJhcnMucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge307XG5cbiAgZnVuY3Rpb24gdXBkYXRlU2Nyb2xsYmFycyhjbSwgbWVhc3VyZSkge1xuICAgIGlmICghbWVhc3VyZSkgeyBtZWFzdXJlID0gbWVhc3VyZUZvclNjcm9sbGJhcnMoY20pOyB9XG4gICAgdmFyIHN0YXJ0V2lkdGggPSBjbS5kaXNwbGF5LmJhcldpZHRoLCBzdGFydEhlaWdodCA9IGNtLmRpc3BsYXkuYmFySGVpZ2h0O1xuICAgIHVwZGF0ZVNjcm9sbGJhcnNJbm5lcihjbSwgbWVhc3VyZSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0ICYmIHN0YXJ0V2lkdGggIT0gY20uZGlzcGxheS5iYXJXaWR0aCB8fCBzdGFydEhlaWdodCAhPSBjbS5kaXNwbGF5LmJhckhlaWdodDsgaSsrKSB7XG4gICAgICBpZiAoc3RhcnRXaWR0aCAhPSBjbS5kaXNwbGF5LmJhcldpZHRoICYmIGNtLm9wdGlvbnMubGluZVdyYXBwaW5nKVxuICAgICAgICB7IHVwZGF0ZUhlaWdodHNJblZpZXdwb3J0KGNtKTsgfVxuICAgICAgdXBkYXRlU2Nyb2xsYmFyc0lubmVyKGNtLCBtZWFzdXJlRm9yU2Nyb2xsYmFycyhjbSkpO1xuICAgICAgc3RhcnRXaWR0aCA9IGNtLmRpc3BsYXkuYmFyV2lkdGg7IHN0YXJ0SGVpZ2h0ID0gY20uZGlzcGxheS5iYXJIZWlnaHQ7XG4gICAgfVxuICB9XG5cbiAgLy8gUmUtc3luY2hyb25pemUgdGhlIGZha2Ugc2Nyb2xsYmFycyB3aXRoIHRoZSBhY3R1YWwgc2l6ZSBvZiB0aGVcbiAgLy8gY29udGVudC5cbiAgZnVuY3Rpb24gdXBkYXRlU2Nyb2xsYmFyc0lubmVyKGNtLCBtZWFzdXJlKSB7XG4gICAgdmFyIGQgPSBjbS5kaXNwbGF5O1xuICAgIHZhciBzaXplcyA9IGQuc2Nyb2xsYmFycy51cGRhdGUobWVhc3VyZSk7XG5cbiAgICBkLnNpemVyLnN0eWxlLnBhZGRpbmdSaWdodCA9IChkLmJhcldpZHRoID0gc2l6ZXMucmlnaHQpICsgXCJweFwiO1xuICAgIGQuc2l6ZXIuc3R5bGUucGFkZGluZ0JvdHRvbSA9IChkLmJhckhlaWdodCA9IHNpemVzLmJvdHRvbSkgKyBcInB4XCI7XG4gICAgZC5oZWlnaHRGb3JjZXIuc3R5bGUuYm9yZGVyQm90dG9tID0gc2l6ZXMuYm90dG9tICsgXCJweCBzb2xpZCB0cmFuc3BhcmVudFwiO1xuXG4gICAgaWYgKHNpemVzLnJpZ2h0ICYmIHNpemVzLmJvdHRvbSkge1xuICAgICAgZC5zY3JvbGxiYXJGaWxsZXIuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICAgIGQuc2Nyb2xsYmFyRmlsbGVyLnN0eWxlLmhlaWdodCA9IHNpemVzLmJvdHRvbSArIFwicHhcIjtcbiAgICAgIGQuc2Nyb2xsYmFyRmlsbGVyLnN0eWxlLndpZHRoID0gc2l6ZXMucmlnaHQgKyBcInB4XCI7XG4gICAgfSBlbHNlIHsgZC5zY3JvbGxiYXJGaWxsZXIuc3R5bGUuZGlzcGxheSA9IFwiXCI7IH1cbiAgICBpZiAoc2l6ZXMuYm90dG9tICYmIGNtLm9wdGlvbnMuY292ZXJHdXR0ZXJOZXh0VG9TY3JvbGxiYXIgJiYgY20ub3B0aW9ucy5maXhlZEd1dHRlcikge1xuICAgICAgZC5ndXR0ZXJGaWxsZXIuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICAgIGQuZ3V0dGVyRmlsbGVyLnN0eWxlLmhlaWdodCA9IHNpemVzLmJvdHRvbSArIFwicHhcIjtcbiAgICAgIGQuZ3V0dGVyRmlsbGVyLnN0eWxlLndpZHRoID0gbWVhc3VyZS5ndXR0ZXJXaWR0aCArIFwicHhcIjtcbiAgICB9IGVsc2UgeyBkLmd1dHRlckZpbGxlci5zdHlsZS5kaXNwbGF5ID0gXCJcIjsgfVxuICB9XG5cbiAgdmFyIHNjcm9sbGJhck1vZGVsID0ge1wibmF0aXZlXCI6IE5hdGl2ZVNjcm9sbGJhcnMsIFwibnVsbFwiOiBOdWxsU2Nyb2xsYmFyc307XG5cbiAgZnVuY3Rpb24gaW5pdFNjcm9sbGJhcnMoY20pIHtcbiAgICBpZiAoY20uZGlzcGxheS5zY3JvbGxiYXJzKSB7XG4gICAgICBjbS5kaXNwbGF5LnNjcm9sbGJhcnMuY2xlYXIoKTtcbiAgICAgIGlmIChjbS5kaXNwbGF5LnNjcm9sbGJhcnMuYWRkQ2xhc3MpXG4gICAgICAgIHsgcm1DbGFzcyhjbS5kaXNwbGF5LndyYXBwZXIsIGNtLmRpc3BsYXkuc2Nyb2xsYmFycy5hZGRDbGFzcyk7IH1cbiAgICB9XG5cbiAgICBjbS5kaXNwbGF5LnNjcm9sbGJhcnMgPSBuZXcgc2Nyb2xsYmFyTW9kZWxbY20ub3B0aW9ucy5zY3JvbGxiYXJTdHlsZV0oZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIGNtLmRpc3BsYXkud3JhcHBlci5pbnNlcnRCZWZvcmUobm9kZSwgY20uZGlzcGxheS5zY3JvbGxiYXJGaWxsZXIpO1xuICAgICAgLy8gUHJldmVudCBjbGlja3MgaW4gdGhlIHNjcm9sbGJhcnMgZnJvbSBraWxsaW5nIGZvY3VzXG4gICAgICBvbihub2RlLCBcIm1vdXNlZG93blwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChjbS5zdGF0ZS5mb2N1c2VkKSB7IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gY20uZGlzcGxheS5pbnB1dC5mb2N1cygpOyB9LCAwKTsgfVxuICAgICAgfSk7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcImNtLW5vdC1jb250ZW50XCIsIFwidHJ1ZVwiKTtcbiAgICB9LCBmdW5jdGlvbiAocG9zLCBheGlzKSB7XG4gICAgICBpZiAoYXhpcyA9PSBcImhvcml6b250YWxcIikgeyBzZXRTY3JvbGxMZWZ0KGNtLCBwb3MpOyB9XG4gICAgICBlbHNlIHsgdXBkYXRlU2Nyb2xsVG9wKGNtLCBwb3MpOyB9XG4gICAgfSwgY20pO1xuICAgIGlmIChjbS5kaXNwbGF5LnNjcm9sbGJhcnMuYWRkQ2xhc3MpXG4gICAgICB7IGFkZENsYXNzKGNtLmRpc3BsYXkud3JhcHBlciwgY20uZGlzcGxheS5zY3JvbGxiYXJzLmFkZENsYXNzKTsgfVxuICB9XG5cbiAgLy8gT3BlcmF0aW9ucyBhcmUgdXNlZCB0byB3cmFwIGEgc2VyaWVzIG9mIGNoYW5nZXMgdG8gdGhlIGVkaXRvclxuICAvLyBzdGF0ZSBpbiBzdWNoIGEgd2F5IHRoYXQgZWFjaCBjaGFuZ2Ugd29uJ3QgaGF2ZSB0byB1cGRhdGUgdGhlXG4gIC8vIGN1cnNvciBhbmQgZGlzcGxheSAod2hpY2ggd291bGQgYmUgYXdrd2FyZCwgc2xvdywgYW5kXG4gIC8vIGVycm9yLXByb25lKS4gSW5zdGVhZCwgZGlzcGxheSB1cGRhdGVzIGFyZSBiYXRjaGVkIGFuZCB0aGVuIGFsbFxuICAvLyBjb21iaW5lZCBhbmQgZXhlY3V0ZWQgYXQgb25jZS5cblxuICB2YXIgbmV4dE9wSWQgPSAwO1xuICAvLyBTdGFydCBhIG5ldyBvcGVyYXRpb24uXG4gIGZ1bmN0aW9uIHN0YXJ0T3BlcmF0aW9uKGNtKSB7XG4gICAgY20uY3VyT3AgPSB7XG4gICAgICBjbTogY20sXG4gICAgICB2aWV3Q2hhbmdlZDogZmFsc2UsICAgICAgLy8gRmxhZyB0aGF0IGluZGljYXRlcyB0aGF0IGxpbmVzIG1pZ2h0IG5lZWQgdG8gYmUgcmVkcmF3blxuICAgICAgc3RhcnRIZWlnaHQ6IGNtLmRvYy5oZWlnaHQsIC8vIFVzZWQgdG8gZGV0ZWN0IG5lZWQgdG8gdXBkYXRlIHNjcm9sbGJhclxuICAgICAgZm9yY2VVcGRhdGU6IGZhbHNlLCAgICAgIC8vIFVzZWQgdG8gZm9yY2UgYSByZWRyYXdcbiAgICAgIHVwZGF0ZUlucHV0OiAwLCAgICAgICAvLyBXaGV0aGVyIHRvIHJlc2V0IHRoZSBpbnB1dCB0ZXh0YXJlYVxuICAgICAgdHlwaW5nOiBmYWxzZSwgICAgICAgICAgIC8vIFdoZXRoZXIgdGhpcyByZXNldCBzaG91bGQgYmUgY2FyZWZ1bCB0byBsZWF2ZSBleGlzdGluZyB0ZXh0IChmb3IgY29tcG9zaXRpbmcpXG4gICAgICBjaGFuZ2VPYmpzOiBudWxsLCAgICAgICAgLy8gQWNjdW11bGF0ZWQgY2hhbmdlcywgZm9yIGZpcmluZyBjaGFuZ2UgZXZlbnRzXG4gICAgICBjdXJzb3JBY3Rpdml0eUhhbmRsZXJzOiBudWxsLCAvLyBTZXQgb2YgaGFuZGxlcnMgdG8gZmlyZSBjdXJzb3JBY3Rpdml0eSBvblxuICAgICAgY3Vyc29yQWN0aXZpdHlDYWxsZWQ6IDAsIC8vIFRyYWNrcyB3aGljaCBjdXJzb3JBY3Rpdml0eSBoYW5kbGVycyBoYXZlIGJlZW4gY2FsbGVkIGFscmVhZHlcbiAgICAgIHNlbGVjdGlvbkNoYW5nZWQ6IGZhbHNlLCAvLyBXaGV0aGVyIHRoZSBzZWxlY3Rpb24gbmVlZHMgdG8gYmUgcmVkcmF3blxuICAgICAgdXBkYXRlTWF4TGluZTogZmFsc2UsICAgIC8vIFNldCB3aGVuIHRoZSB3aWRlc3QgbGluZSBuZWVkcyB0byBiZSBkZXRlcm1pbmVkIGFuZXdcbiAgICAgIHNjcm9sbExlZnQ6IG51bGwsIHNjcm9sbFRvcDogbnVsbCwgLy8gSW50ZXJtZWRpYXRlIHNjcm9sbCBwb3NpdGlvbiwgbm90IHB1c2hlZCB0byBET00geWV0XG4gICAgICBzY3JvbGxUb1BvczogbnVsbCwgICAgICAgLy8gVXNlZCB0byBzY3JvbGwgdG8gYSBzcGVjaWZpYyBwb3NpdGlvblxuICAgICAgZm9jdXM6IGZhbHNlLFxuICAgICAgaWQ6ICsrbmV4dE9wSWQgICAgICAgICAgIC8vIFVuaXF1ZSBJRFxuICAgIH07XG4gICAgcHVzaE9wZXJhdGlvbihjbS5jdXJPcCk7XG4gIH1cblxuICAvLyBGaW5pc2ggYW4gb3BlcmF0aW9uLCB1cGRhdGluZyB0aGUgZGlzcGxheSBhbmQgc2lnbmFsbGluZyBkZWxheWVkIGV2ZW50c1xuICBmdW5jdGlvbiBlbmRPcGVyYXRpb24oY20pIHtcbiAgICB2YXIgb3AgPSBjbS5jdXJPcDtcbiAgICBpZiAob3ApIHsgZmluaXNoT3BlcmF0aW9uKG9wLCBmdW5jdGlvbiAoZ3JvdXApIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXAub3BzLmxlbmd0aDsgaSsrKVxuICAgICAgICB7IGdyb3VwLm9wc1tpXS5jbS5jdXJPcCA9IG51bGw7IH1cbiAgICAgIGVuZE9wZXJhdGlvbnMoZ3JvdXApO1xuICAgIH0pOyB9XG4gIH1cblxuICAvLyBUaGUgRE9NIHVwZGF0ZXMgZG9uZSB3aGVuIGFuIG9wZXJhdGlvbiBmaW5pc2hlcyBhcmUgYmF0Y2hlZCBzb1xuICAvLyB0aGF0IHRoZSBtaW5pbXVtIG51bWJlciBvZiByZWxheW91dHMgYXJlIHJlcXVpcmVkLlxuICBmdW5jdGlvbiBlbmRPcGVyYXRpb25zKGdyb3VwKSB7XG4gICAgdmFyIG9wcyA9IGdyb3VwLm9wcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9wcy5sZW5ndGg7IGkrKykgLy8gUmVhZCBET01cbiAgICAgIHsgZW5kT3BlcmF0aW9uX1IxKG9wc1tpXSk7IH1cbiAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBvcHMubGVuZ3RoOyBpJDErKykgLy8gV3JpdGUgRE9NIChtYXliZSlcbiAgICAgIHsgZW5kT3BlcmF0aW9uX1cxKG9wc1tpJDFdKTsgfVxuICAgIGZvciAodmFyIGkkMiA9IDA7IGkkMiA8IG9wcy5sZW5ndGg7IGkkMisrKSAvLyBSZWFkIERPTVxuICAgICAgeyBlbmRPcGVyYXRpb25fUjIob3BzW2kkMl0pOyB9XG4gICAgZm9yICh2YXIgaSQzID0gMDsgaSQzIDwgb3BzLmxlbmd0aDsgaSQzKyspIC8vIFdyaXRlIERPTSAobWF5YmUpXG4gICAgICB7IGVuZE9wZXJhdGlvbl9XMihvcHNbaSQzXSk7IH1cbiAgICBmb3IgKHZhciBpJDQgPSAwOyBpJDQgPCBvcHMubGVuZ3RoOyBpJDQrKykgLy8gUmVhZCBET01cbiAgICAgIHsgZW5kT3BlcmF0aW9uX2ZpbmlzaChvcHNbaSQ0XSk7IH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGVuZE9wZXJhdGlvbl9SMShvcCkge1xuICAgIHZhciBjbSA9IG9wLmNtLCBkaXNwbGF5ID0gY20uZGlzcGxheTtcbiAgICBtYXliZUNsaXBTY3JvbGxiYXJzKGNtKTtcbiAgICBpZiAob3AudXBkYXRlTWF4TGluZSkgeyBmaW5kTWF4TGluZShjbSk7IH1cblxuICAgIG9wLm11c3RVcGRhdGUgPSBvcC52aWV3Q2hhbmdlZCB8fCBvcC5mb3JjZVVwZGF0ZSB8fCBvcC5zY3JvbGxUb3AgIT0gbnVsbCB8fFxuICAgICAgb3Auc2Nyb2xsVG9Qb3MgJiYgKG9wLnNjcm9sbFRvUG9zLmZyb20ubGluZSA8IGRpc3BsYXkudmlld0Zyb20gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICBvcC5zY3JvbGxUb1Bvcy50by5saW5lID49IGRpc3BsYXkudmlld1RvKSB8fFxuICAgICAgZGlzcGxheS5tYXhMaW5lQ2hhbmdlZCAmJiBjbS5vcHRpb25zLmxpbmVXcmFwcGluZztcbiAgICBvcC51cGRhdGUgPSBvcC5tdXN0VXBkYXRlICYmXG4gICAgICBuZXcgRGlzcGxheVVwZGF0ZShjbSwgb3AubXVzdFVwZGF0ZSAmJiB7dG9wOiBvcC5zY3JvbGxUb3AsIGVuc3VyZTogb3Auc2Nyb2xsVG9Qb3N9LCBvcC5mb3JjZVVwZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBlbmRPcGVyYXRpb25fVzEob3ApIHtcbiAgICBvcC51cGRhdGVkRGlzcGxheSA9IG9wLm11c3RVcGRhdGUgJiYgdXBkYXRlRGlzcGxheUlmTmVlZGVkKG9wLmNtLCBvcC51cGRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gZW5kT3BlcmF0aW9uX1IyKG9wKSB7XG4gICAgdmFyIGNtID0gb3AuY20sIGRpc3BsYXkgPSBjbS5kaXNwbGF5O1xuICAgIGlmIChvcC51cGRhdGVkRGlzcGxheSkgeyB1cGRhdGVIZWlnaHRzSW5WaWV3cG9ydChjbSk7IH1cblxuICAgIG9wLmJhck1lYXN1cmUgPSBtZWFzdXJlRm9yU2Nyb2xsYmFycyhjbSk7XG5cbiAgICAvLyBJZiB0aGUgbWF4IGxpbmUgY2hhbmdlZCBzaW5jZSBpdCB3YXMgbGFzdCBtZWFzdXJlZCwgbWVhc3VyZSBpdCxcbiAgICAvLyBhbmQgZW5zdXJlIHRoZSBkb2N1bWVudCdzIHdpZHRoIG1hdGNoZXMgaXQuXG4gICAgLy8gdXBkYXRlRGlzcGxheV9XMiB3aWxsIHVzZSB0aGVzZSBwcm9wZXJ0aWVzIHRvIGRvIHRoZSBhY3R1YWwgcmVzaXppbmdcbiAgICBpZiAoZGlzcGxheS5tYXhMaW5lQ2hhbmdlZCAmJiAhY20ub3B0aW9ucy5saW5lV3JhcHBpbmcpIHtcbiAgICAgIG9wLmFkanVzdFdpZHRoVG8gPSBtZWFzdXJlQ2hhcihjbSwgZGlzcGxheS5tYXhMaW5lLCBkaXNwbGF5Lm1heExpbmUudGV4dC5sZW5ndGgpLmxlZnQgKyAzO1xuICAgICAgY20uZGlzcGxheS5zaXplcldpZHRoID0gb3AuYWRqdXN0V2lkdGhUbztcbiAgICAgIG9wLmJhck1lYXN1cmUuc2Nyb2xsV2lkdGggPVxuICAgICAgICBNYXRoLm1heChkaXNwbGF5LnNjcm9sbGVyLmNsaWVudFdpZHRoLCBkaXNwbGF5LnNpemVyLm9mZnNldExlZnQgKyBvcC5hZGp1c3RXaWR0aFRvICsgc2Nyb2xsR2FwKGNtKSArIGNtLmRpc3BsYXkuYmFyV2lkdGgpO1xuICAgICAgb3AubWF4U2Nyb2xsTGVmdCA9IE1hdGgubWF4KDAsIGRpc3BsYXkuc2l6ZXIub2Zmc2V0TGVmdCArIG9wLmFkanVzdFdpZHRoVG8gLSBkaXNwbGF5V2lkdGgoY20pKTtcbiAgICB9XG5cbiAgICBpZiAob3AudXBkYXRlZERpc3BsYXkgfHwgb3Auc2VsZWN0aW9uQ2hhbmdlZClcbiAgICAgIHsgb3AucHJlcGFyZWRTZWxlY3Rpb24gPSBkaXNwbGF5LmlucHV0LnByZXBhcmVTZWxlY3Rpb24oKTsgfVxuICB9XG5cbiAgZnVuY3Rpb24gZW5kT3BlcmF0aW9uX1cyKG9wKSB7XG4gICAgdmFyIGNtID0gb3AuY207XG5cbiAgICBpZiAob3AuYWRqdXN0V2lkdGhUbyAhPSBudWxsKSB7XG4gICAgICBjbS5kaXNwbGF5LnNpemVyLnN0eWxlLm1pbldpZHRoID0gb3AuYWRqdXN0V2lkdGhUbyArIFwicHhcIjtcbiAgICAgIGlmIChvcC5tYXhTY3JvbGxMZWZ0IDwgY20uZG9jLnNjcm9sbExlZnQpXG4gICAgICAgIHsgc2V0U2Nyb2xsTGVmdChjbSwgTWF0aC5taW4oY20uZGlzcGxheS5zY3JvbGxlci5zY3JvbGxMZWZ0LCBvcC5tYXhTY3JvbGxMZWZ0KSwgdHJ1ZSk7IH1cbiAgICAgIGNtLmRpc3BsYXkubWF4TGluZUNoYW5nZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgdGFrZUZvY3VzID0gb3AuZm9jdXMgJiYgb3AuZm9jdXMgPT0gYWN0aXZlRWx0KCk7XG4gICAgaWYgKG9wLnByZXBhcmVkU2VsZWN0aW9uKVxuICAgICAgeyBjbS5kaXNwbGF5LmlucHV0LnNob3dTZWxlY3Rpb24ob3AucHJlcGFyZWRTZWxlY3Rpb24sIHRha2VGb2N1cyk7IH1cbiAgICBpZiAob3AudXBkYXRlZERpc3BsYXkgfHwgb3Auc3RhcnRIZWlnaHQgIT0gY20uZG9jLmhlaWdodClcbiAgICAgIHsgdXBkYXRlU2Nyb2xsYmFycyhjbSwgb3AuYmFyTWVhc3VyZSk7IH1cbiAgICBpZiAob3AudXBkYXRlZERpc3BsYXkpXG4gICAgICB7IHNldERvY3VtZW50SGVpZ2h0KGNtLCBvcC5iYXJNZWFzdXJlKTsgfVxuXG4gICAgaWYgKG9wLnNlbGVjdGlvbkNoYW5nZWQpIHsgcmVzdGFydEJsaW5rKGNtKTsgfVxuXG4gICAgaWYgKGNtLnN0YXRlLmZvY3VzZWQgJiYgb3AudXBkYXRlSW5wdXQpXG4gICAgICB7IGNtLmRpc3BsYXkuaW5wdXQucmVzZXQob3AudHlwaW5nKTsgfVxuICAgIGlmICh0YWtlRm9jdXMpIHsgZW5zdXJlRm9jdXMob3AuY20pOyB9XG4gIH1cblxuICBmdW5jdGlvbiBlbmRPcGVyYXRpb25fZmluaXNoKG9wKSB7XG4gICAgdmFyIGNtID0gb3AuY20sIGRpc3BsYXkgPSBjbS5kaXNwbGF5LCBkb2MgPSBjbS5kb2M7XG5cbiAgICBpZiAob3AudXBkYXRlZERpc3BsYXkpIHsgcG9zdFVwZGF0ZURpc3BsYXkoY20sIG9wLnVwZGF0ZSk7IH1cblxuICAgIC8vIEFib3J0IG1vdXNlIHdoZWVsIGRlbHRhIG1lYXN1cmVtZW50LCB3aGVuIHNjcm9sbGluZyBleHBsaWNpdGx5XG4gICAgaWYgKGRpc3BsYXkud2hlZWxTdGFydFggIT0gbnVsbCAmJiAob3Auc2Nyb2xsVG9wICE9IG51bGwgfHwgb3Auc2Nyb2xsTGVmdCAhPSBudWxsIHx8IG9wLnNjcm9sbFRvUG9zKSlcbiAgICAgIHsgZGlzcGxheS53aGVlbFN0YXJ0WCA9IGRpc3BsYXkud2hlZWxTdGFydFkgPSBudWxsOyB9XG5cbiAgICAvLyBQcm9wYWdhdGUgdGhlIHNjcm9sbCBwb3NpdGlvbiB0byB0aGUgYWN0dWFsIERPTSBzY3JvbGxlclxuICAgIGlmIChvcC5zY3JvbGxUb3AgIT0gbnVsbCkgeyBzZXRTY3JvbGxUb3AoY20sIG9wLnNjcm9sbFRvcCwgb3AuZm9yY2VTY3JvbGwpOyB9XG5cbiAgICBpZiAob3Auc2Nyb2xsTGVmdCAhPSBudWxsKSB7IHNldFNjcm9sbExlZnQoY20sIG9wLnNjcm9sbExlZnQsIHRydWUsIHRydWUpOyB9XG4gICAgLy8gSWYgd2UgbmVlZCB0byBzY3JvbGwgYSBzcGVjaWZpYyBwb3NpdGlvbiBpbnRvIHZpZXcsIGRvIHNvLlxuICAgIGlmIChvcC5zY3JvbGxUb1Bvcykge1xuICAgICAgdmFyIHJlY3QgPSBzY3JvbGxQb3NJbnRvVmlldyhjbSwgY2xpcFBvcyhkb2MsIG9wLnNjcm9sbFRvUG9zLmZyb20pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGlwUG9zKGRvYywgb3Auc2Nyb2xsVG9Qb3MudG8pLCBvcC5zY3JvbGxUb1Bvcy5tYXJnaW4pO1xuICAgICAgbWF5YmVTY3JvbGxXaW5kb3coY20sIHJlY3QpO1xuICAgIH1cblxuICAgIC8vIEZpcmUgZXZlbnRzIGZvciBtYXJrZXJzIHRoYXQgYXJlIGhpZGRlbi91bmlkZGVuIGJ5IGVkaXRpbmcgb3JcbiAgICAvLyB1bmRvaW5nXG4gICAgdmFyIGhpZGRlbiA9IG9wLm1heWJlSGlkZGVuTWFya2VycywgdW5oaWRkZW4gPSBvcC5tYXliZVVuaGlkZGVuTWFya2VycztcbiAgICBpZiAoaGlkZGVuKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgaGlkZGVuLmxlbmd0aDsgKytpKVxuICAgICAgeyBpZiAoIWhpZGRlbltpXS5saW5lcy5sZW5ndGgpIHsgc2lnbmFsKGhpZGRlbltpXSwgXCJoaWRlXCIpOyB9IH0gfVxuICAgIGlmICh1bmhpZGRlbikgeyBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCB1bmhpZGRlbi5sZW5ndGg7ICsraSQxKVxuICAgICAgeyBpZiAodW5oaWRkZW5baSQxXS5saW5lcy5sZW5ndGgpIHsgc2lnbmFsKHVuaGlkZGVuW2kkMV0sIFwidW5oaWRlXCIpOyB9IH0gfVxuXG4gICAgaWYgKGRpc3BsYXkud3JhcHBlci5vZmZzZXRIZWlnaHQpXG4gICAgICB7IGRvYy5zY3JvbGxUb3AgPSBjbS5kaXNwbGF5LnNjcm9sbGVyLnNjcm9sbFRvcDsgfVxuXG4gICAgLy8gRmlyZSBjaGFuZ2UgZXZlbnRzLCBhbmQgZGVsYXllZCBldmVudCBoYW5kbGVyc1xuICAgIGlmIChvcC5jaGFuZ2VPYmpzKVxuICAgICAgeyBzaWduYWwoY20sIFwiY2hhbmdlc1wiLCBjbSwgb3AuY2hhbmdlT2Jqcyk7IH1cbiAgICBpZiAob3AudXBkYXRlKVxuICAgICAgeyBvcC51cGRhdGUuZmluaXNoKCk7IH1cbiAgfVxuXG4gIC8vIFJ1biB0aGUgZ2l2ZW4gZnVuY3Rpb24gaW4gYW4gb3BlcmF0aW9uXG4gIGZ1bmN0aW9uIHJ1bkluT3AoY20sIGYpIHtcbiAgICBpZiAoY20uY3VyT3ApIHsgcmV0dXJuIGYoKSB9XG4gICAgc3RhcnRPcGVyYXRpb24oY20pO1xuICAgIHRyeSB7IHJldHVybiBmKCkgfVxuICAgIGZpbmFsbHkgeyBlbmRPcGVyYXRpb24oY20pOyB9XG4gIH1cbiAgLy8gV3JhcHMgYSBmdW5jdGlvbiBpbiBhbiBvcGVyYXRpb24uIFJldHVybnMgdGhlIHdyYXBwZWQgZnVuY3Rpb24uXG4gIGZ1bmN0aW9uIG9wZXJhdGlvbihjbSwgZikge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChjbS5jdXJPcCkgeyByZXR1cm4gZi5hcHBseShjbSwgYXJndW1lbnRzKSB9XG4gICAgICBzdGFydE9wZXJhdGlvbihjbSk7XG4gICAgICB0cnkgeyByZXR1cm4gZi5hcHBseShjbSwgYXJndW1lbnRzKSB9XG4gICAgICBmaW5hbGx5IHsgZW5kT3BlcmF0aW9uKGNtKTsgfVxuICAgIH1cbiAgfVxuICAvLyBVc2VkIHRvIGFkZCBtZXRob2RzIHRvIGVkaXRvciBhbmQgZG9jIGluc3RhbmNlcywgd3JhcHBpbmcgdGhlbSBpblxuICAvLyBvcGVyYXRpb25zLlxuICBmdW5jdGlvbiBtZXRob2RPcChmKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuY3VyT3ApIHsgcmV0dXJuIGYuYXBwbHkodGhpcywgYXJndW1lbnRzKSB9XG4gICAgICBzdGFydE9wZXJhdGlvbih0aGlzKTtcbiAgICAgIHRyeSB7IHJldHVybiBmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfVxuICAgICAgZmluYWxseSB7IGVuZE9wZXJhdGlvbih0aGlzKTsgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBkb2NNZXRob2RPcChmKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNtID0gdGhpcy5jbTtcbiAgICAgIGlmICghY20gfHwgY20uY3VyT3ApIHsgcmV0dXJuIGYuYXBwbHkodGhpcywgYXJndW1lbnRzKSB9XG4gICAgICBzdGFydE9wZXJhdGlvbihjbSk7XG4gICAgICB0cnkgeyByZXR1cm4gZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpIH1cbiAgICAgIGZpbmFsbHkgeyBlbmRPcGVyYXRpb24oY20pOyB9XG4gICAgfVxuICB9XG5cbiAgLy8gSElHSExJR0hUIFdPUktFUlxuXG4gIGZ1bmN0aW9uIHN0YXJ0V29ya2VyKGNtLCB0aW1lKSB7XG4gICAgaWYgKGNtLmRvYy5oaWdobGlnaHRGcm9udGllciA8IGNtLmRpc3BsYXkudmlld1RvKVxuICAgICAgeyBjbS5zdGF0ZS5oaWdobGlnaHQuc2V0KHRpbWUsIGJpbmQoaGlnaGxpZ2h0V29ya2VyLCBjbSkpOyB9XG4gIH1cblxuICBmdW5jdGlvbiBoaWdobGlnaHRXb3JrZXIoY20pIHtcbiAgICB2YXIgZG9jID0gY20uZG9jO1xuICAgIGlmIChkb2MuaGlnaGxpZ2h0RnJvbnRpZXIgPj0gY20uZGlzcGxheS52aWV3VG8pIHsgcmV0dXJuIH1cbiAgICB2YXIgZW5kID0gK25ldyBEYXRlICsgY20ub3B0aW9ucy53b3JrVGltZTtcbiAgICB2YXIgY29udGV4dCA9IGdldENvbnRleHRCZWZvcmUoY20sIGRvYy5oaWdobGlnaHRGcm9udGllcik7XG4gICAgdmFyIGNoYW5nZWRMaW5lcyA9IFtdO1xuXG4gICAgZG9jLml0ZXIoY29udGV4dC5saW5lLCBNYXRoLm1pbihkb2MuZmlyc3QgKyBkb2Muc2l6ZSwgY20uZGlzcGxheS52aWV3VG8gKyA1MDApLCBmdW5jdGlvbiAobGluZSkge1xuICAgICAgaWYgKGNvbnRleHQubGluZSA+PSBjbS5kaXNwbGF5LnZpZXdGcm9tKSB7IC8vIFZpc2libGVcbiAgICAgICAgdmFyIG9sZFN0eWxlcyA9IGxpbmUuc3R5bGVzO1xuICAgICAgICB2YXIgcmVzZXRTdGF0ZSA9IGxpbmUudGV4dC5sZW5ndGggPiBjbS5vcHRpb25zLm1heEhpZ2hsaWdodExlbmd0aCA/IGNvcHlTdGF0ZShkb2MubW9kZSwgY29udGV4dC5zdGF0ZSkgOiBudWxsO1xuICAgICAgICB2YXIgaGlnaGxpZ2h0ZWQgPSBoaWdobGlnaHRMaW5lKGNtLCBsaW5lLCBjb250ZXh0LCB0cnVlKTtcbiAgICAgICAgaWYgKHJlc2V0U3RhdGUpIHsgY29udGV4dC5zdGF0ZSA9IHJlc2V0U3RhdGU7IH1cbiAgICAgICAgbGluZS5zdHlsZXMgPSBoaWdobGlnaHRlZC5zdHlsZXM7XG4gICAgICAgIHZhciBvbGRDbHMgPSBsaW5lLnN0eWxlQ2xhc3NlcywgbmV3Q2xzID0gaGlnaGxpZ2h0ZWQuY2xhc3NlcztcbiAgICAgICAgaWYgKG5ld0NscykgeyBsaW5lLnN0eWxlQ2xhc3NlcyA9IG5ld0NsczsgfVxuICAgICAgICBlbHNlIGlmIChvbGRDbHMpIHsgbGluZS5zdHlsZUNsYXNzZXMgPSBudWxsOyB9XG4gICAgICAgIHZhciBpc2NoYW5nZSA9ICFvbGRTdHlsZXMgfHwgb2xkU3R5bGVzLmxlbmd0aCAhPSBsaW5lLnN0eWxlcy5sZW5ndGggfHxcbiAgICAgICAgICBvbGRDbHMgIT0gbmV3Q2xzICYmICghb2xkQ2xzIHx8ICFuZXdDbHMgfHwgb2xkQ2xzLmJnQ2xhc3MgIT0gbmV3Q2xzLmJnQ2xhc3MgfHwgb2xkQ2xzLnRleHRDbGFzcyAhPSBuZXdDbHMudGV4dENsYXNzKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7ICFpc2NoYW5nZSAmJiBpIDwgb2xkU3R5bGVzLmxlbmd0aDsgKytpKSB7IGlzY2hhbmdlID0gb2xkU3R5bGVzW2ldICE9IGxpbmUuc3R5bGVzW2ldOyB9XG4gICAgICAgIGlmIChpc2NoYW5nZSkgeyBjaGFuZ2VkTGluZXMucHVzaChjb250ZXh0LmxpbmUpOyB9XG4gICAgICAgIGxpbmUuc3RhdGVBZnRlciA9IGNvbnRleHQuc2F2ZSgpO1xuICAgICAgICBjb250ZXh0Lm5leHRMaW5lKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobGluZS50ZXh0Lmxlbmd0aCA8PSBjbS5vcHRpb25zLm1heEhpZ2hsaWdodExlbmd0aClcbiAgICAgICAgICB7IHByb2Nlc3NMaW5lKGNtLCBsaW5lLnRleHQsIGNvbnRleHQpOyB9XG4gICAgICAgIGxpbmUuc3RhdGVBZnRlciA9IGNvbnRleHQubGluZSAlIDUgPT0gMCA/IGNvbnRleHQuc2F2ZSgpIDogbnVsbDtcbiAgICAgICAgY29udGV4dC5uZXh0TGluZSgpO1xuICAgICAgfVxuICAgICAgaWYgKCtuZXcgRGF0ZSA+IGVuZCkge1xuICAgICAgICBzdGFydFdvcmtlcihjbSwgY20ub3B0aW9ucy53b3JrRGVsYXkpO1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICAgIGRvYy5oaWdobGlnaHRGcm9udGllciA9IGNvbnRleHQubGluZTtcbiAgICBkb2MubW9kZUZyb250aWVyID0gTWF0aC5tYXgoZG9jLm1vZGVGcm9udGllciwgY29udGV4dC5saW5lKTtcbiAgICBpZiAoY2hhbmdlZExpbmVzLmxlbmd0aCkgeyBydW5Jbk9wKGNtLCBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYW5nZWRMaW5lcy5sZW5ndGg7IGkrKylcbiAgICAgICAgeyByZWdMaW5lQ2hhbmdlKGNtLCBjaGFuZ2VkTGluZXNbaV0sIFwidGV4dFwiKTsgfVxuICAgIH0pOyB9XG4gIH1cblxuICAvLyBESVNQTEFZIERSQVdJTkdcblxuICB2YXIgRGlzcGxheVVwZGF0ZSA9IGZ1bmN0aW9uKGNtLCB2aWV3cG9ydCwgZm9yY2UpIHtcbiAgICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXk7XG5cbiAgICB0aGlzLnZpZXdwb3J0ID0gdmlld3BvcnQ7XG4gICAgLy8gU3RvcmUgc29tZSB2YWx1ZXMgdGhhdCB3ZSdsbCBuZWVkIGxhdGVyIChidXQgZG9uJ3Qgd2FudCB0byBmb3JjZSBhIHJlbGF5b3V0IGZvcilcbiAgICB0aGlzLnZpc2libGUgPSB2aXNpYmxlTGluZXMoZGlzcGxheSwgY20uZG9jLCB2aWV3cG9ydCk7XG4gICAgdGhpcy5lZGl0b3JJc0hpZGRlbiA9ICFkaXNwbGF5LndyYXBwZXIub2Zmc2V0V2lkdGg7XG4gICAgdGhpcy53cmFwcGVySGVpZ2h0ID0gZGlzcGxheS53cmFwcGVyLmNsaWVudEhlaWdodDtcbiAgICB0aGlzLndyYXBwZXJXaWR0aCA9IGRpc3BsYXkud3JhcHBlci5jbGllbnRXaWR0aDtcbiAgICB0aGlzLm9sZERpc3BsYXlXaWR0aCA9IGRpc3BsYXlXaWR0aChjbSk7XG4gICAgdGhpcy5mb3JjZSA9IGZvcmNlO1xuICAgIHRoaXMuZGltcyA9IGdldERpbWVuc2lvbnMoY20pO1xuICAgIHRoaXMuZXZlbnRzID0gW107XG4gIH07XG5cbiAgRGlzcGxheVVwZGF0ZS5wcm90b3R5cGUuc2lnbmFsID0gZnVuY3Rpb24gKGVtaXR0ZXIsIHR5cGUpIHtcbiAgICBpZiAoaGFzSGFuZGxlcihlbWl0dGVyLCB0eXBlKSlcbiAgICAgIHsgdGhpcy5ldmVudHMucHVzaChhcmd1bWVudHMpOyB9XG4gIH07XG4gIERpc3BsYXlVcGRhdGUucHJvdG90eXBlLmZpbmlzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZXZlbnRzLmxlbmd0aDsgaSsrKVxuICAgICAgeyBzaWduYWwuYXBwbHkobnVsbCwgdGhpcy5ldmVudHNbaV0pOyB9XG4gIH07XG5cbiAgZnVuY3Rpb24gbWF5YmVDbGlwU2Nyb2xsYmFycyhjbSkge1xuICAgIHZhciBkaXNwbGF5ID0gY20uZGlzcGxheTtcbiAgICBpZiAoIWRpc3BsYXkuc2Nyb2xsYmFyc0NsaXBwZWQgJiYgZGlzcGxheS5zY3JvbGxlci5vZmZzZXRXaWR0aCkge1xuICAgICAgZGlzcGxheS5uYXRpdmVCYXJXaWR0aCA9IGRpc3BsYXkuc2Nyb2xsZXIub2Zmc2V0V2lkdGggLSBkaXNwbGF5LnNjcm9sbGVyLmNsaWVudFdpZHRoO1xuICAgICAgZGlzcGxheS5oZWlnaHRGb3JjZXIuc3R5bGUuaGVpZ2h0ID0gc2Nyb2xsR2FwKGNtKSArIFwicHhcIjtcbiAgICAgIGRpc3BsYXkuc2l6ZXIuc3R5bGUubWFyZ2luQm90dG9tID0gLWRpc3BsYXkubmF0aXZlQmFyV2lkdGggKyBcInB4XCI7XG4gICAgICBkaXNwbGF5LnNpemVyLnN0eWxlLmJvcmRlclJpZ2h0V2lkdGggPSBzY3JvbGxHYXAoY20pICsgXCJweFwiO1xuICAgICAgZGlzcGxheS5zY3JvbGxiYXJzQ2xpcHBlZCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2VsZWN0aW9uU25hcHNob3QoY20pIHtcbiAgICBpZiAoY20uaGFzRm9jdXMoKSkgeyByZXR1cm4gbnVsbCB9XG4gICAgdmFyIGFjdGl2ZSA9IGFjdGl2ZUVsdCgpO1xuICAgIGlmICghYWN0aXZlIHx8ICFjb250YWlucyhjbS5kaXNwbGF5LmxpbmVEaXYsIGFjdGl2ZSkpIHsgcmV0dXJuIG51bGwgfVxuICAgIHZhciByZXN1bHQgPSB7YWN0aXZlRWx0OiBhY3RpdmV9O1xuICAgIGlmICh3aW5kb3cuZ2V0U2VsZWN0aW9uKSB7XG4gICAgICB2YXIgc2VsID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICAgICAgaWYgKHNlbC5hbmNob3JOb2RlICYmIHNlbC5leHRlbmQgJiYgY29udGFpbnMoY20uZGlzcGxheS5saW5lRGl2LCBzZWwuYW5jaG9yTm9kZSkpIHtcbiAgICAgICAgcmVzdWx0LmFuY2hvck5vZGUgPSBzZWwuYW5jaG9yTm9kZTtcbiAgICAgICAgcmVzdWx0LmFuY2hvck9mZnNldCA9IHNlbC5hbmNob3JPZmZzZXQ7XG4gICAgICAgIHJlc3VsdC5mb2N1c05vZGUgPSBzZWwuZm9jdXNOb2RlO1xuICAgICAgICByZXN1bHQuZm9jdXNPZmZzZXQgPSBzZWwuZm9jdXNPZmZzZXQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc3RvcmVTZWxlY3Rpb24oc25hcHNob3QpIHtcbiAgICBpZiAoIXNuYXBzaG90IHx8ICFzbmFwc2hvdC5hY3RpdmVFbHQgfHwgc25hcHNob3QuYWN0aXZlRWx0ID09IGFjdGl2ZUVsdCgpKSB7IHJldHVybiB9XG4gICAgc25hcHNob3QuYWN0aXZlRWx0LmZvY3VzKCk7XG4gICAgaWYgKCEvXihJTlBVVHxURVhUQVJFQSkkLy50ZXN0KHNuYXBzaG90LmFjdGl2ZUVsdC5ub2RlTmFtZSkgJiZcbiAgICAgICAgc25hcHNob3QuYW5jaG9yTm9kZSAmJiBjb250YWlucyhkb2N1bWVudC5ib2R5LCBzbmFwc2hvdC5hbmNob3JOb2RlKSAmJiBjb250YWlucyhkb2N1bWVudC5ib2R5LCBzbmFwc2hvdC5mb2N1c05vZGUpKSB7XG4gICAgICB2YXIgc2VsID0gd2luZG93LmdldFNlbGVjdGlvbigpLCByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgICByYW5nZS5zZXRFbmQoc25hcHNob3QuYW5jaG9yTm9kZSwgc25hcHNob3QuYW5jaG9yT2Zmc2V0KTtcbiAgICAgIHJhbmdlLmNvbGxhcHNlKGZhbHNlKTtcbiAgICAgIHNlbC5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgIHNlbC5hZGRSYW5nZShyYW5nZSk7XG4gICAgICBzZWwuZXh0ZW5kKHNuYXBzaG90LmZvY3VzTm9kZSwgc25hcHNob3QuZm9jdXNPZmZzZXQpO1xuICAgIH1cbiAgfVxuXG4gIC8vIERvZXMgdGhlIGFjdHVhbCB1cGRhdGluZyBvZiB0aGUgbGluZSBkaXNwbGF5LiBCYWlscyBvdXRcbiAgLy8gKHJldHVybmluZyBmYWxzZSkgd2hlbiB0aGVyZSBpcyBub3RoaW5nIHRvIGJlIGRvbmUgYW5kIGZvcmNlZCBpc1xuICAvLyBmYWxzZS5cbiAgZnVuY3Rpb24gdXBkYXRlRGlzcGxheUlmTmVlZGVkKGNtLCB1cGRhdGUpIHtcbiAgICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXksIGRvYyA9IGNtLmRvYztcblxuICAgIGlmICh1cGRhdGUuZWRpdG9ySXNIaWRkZW4pIHtcbiAgICAgIHJlc2V0VmlldyhjbSk7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICAvLyBCYWlsIG91dCBpZiB0aGUgdmlzaWJsZSBhcmVhIGlzIGFscmVhZHkgcmVuZGVyZWQgYW5kIG5vdGhpbmcgY2hhbmdlZC5cbiAgICBpZiAoIXVwZGF0ZS5mb3JjZSAmJlxuICAgICAgICB1cGRhdGUudmlzaWJsZS5mcm9tID49IGRpc3BsYXkudmlld0Zyb20gJiYgdXBkYXRlLnZpc2libGUudG8gPD0gZGlzcGxheS52aWV3VG8gJiZcbiAgICAgICAgKGRpc3BsYXkudXBkYXRlTGluZU51bWJlcnMgPT0gbnVsbCB8fCBkaXNwbGF5LnVwZGF0ZUxpbmVOdW1iZXJzID49IGRpc3BsYXkudmlld1RvKSAmJlxuICAgICAgICBkaXNwbGF5LnJlbmRlcmVkVmlldyA9PSBkaXNwbGF5LnZpZXcgJiYgY291bnREaXJ0eVZpZXcoY20pID09IDApXG4gICAgICB7IHJldHVybiBmYWxzZSB9XG5cbiAgICBpZiAobWF5YmVVcGRhdGVMaW5lTnVtYmVyV2lkdGgoY20pKSB7XG4gICAgICByZXNldFZpZXcoY20pO1xuICAgICAgdXBkYXRlLmRpbXMgPSBnZXREaW1lbnNpb25zKGNtKTtcbiAgICB9XG5cbiAgICAvLyBDb21wdXRlIGEgc3VpdGFibGUgbmV3IHZpZXdwb3J0IChmcm9tICYgdG8pXG4gICAgdmFyIGVuZCA9IGRvYy5maXJzdCArIGRvYy5zaXplO1xuICAgIHZhciBmcm9tID0gTWF0aC5tYXgodXBkYXRlLnZpc2libGUuZnJvbSAtIGNtLm9wdGlvbnMudmlld3BvcnRNYXJnaW4sIGRvYy5maXJzdCk7XG4gICAgdmFyIHRvID0gTWF0aC5taW4oZW5kLCB1cGRhdGUudmlzaWJsZS50byArIGNtLm9wdGlvbnMudmlld3BvcnRNYXJnaW4pO1xuICAgIGlmIChkaXNwbGF5LnZpZXdGcm9tIDwgZnJvbSAmJiBmcm9tIC0gZGlzcGxheS52aWV3RnJvbSA8IDIwKSB7IGZyb20gPSBNYXRoLm1heChkb2MuZmlyc3QsIGRpc3BsYXkudmlld0Zyb20pOyB9XG4gICAgaWYgKGRpc3BsYXkudmlld1RvID4gdG8gJiYgZGlzcGxheS52aWV3VG8gLSB0byA8IDIwKSB7IHRvID0gTWF0aC5taW4oZW5kLCBkaXNwbGF5LnZpZXdUbyk7IH1cbiAgICBpZiAoc2F3Q29sbGFwc2VkU3BhbnMpIHtcbiAgICAgIGZyb20gPSB2aXN1YWxMaW5lTm8oY20uZG9jLCBmcm9tKTtcbiAgICAgIHRvID0gdmlzdWFsTGluZUVuZE5vKGNtLmRvYywgdG8pO1xuICAgIH1cblxuICAgIHZhciBkaWZmZXJlbnQgPSBmcm9tICE9IGRpc3BsYXkudmlld0Zyb20gfHwgdG8gIT0gZGlzcGxheS52aWV3VG8gfHxcbiAgICAgIGRpc3BsYXkubGFzdFdyYXBIZWlnaHQgIT0gdXBkYXRlLndyYXBwZXJIZWlnaHQgfHwgZGlzcGxheS5sYXN0V3JhcFdpZHRoICE9IHVwZGF0ZS53cmFwcGVyV2lkdGg7XG4gICAgYWRqdXN0VmlldyhjbSwgZnJvbSwgdG8pO1xuXG4gICAgZGlzcGxheS52aWV3T2Zmc2V0ID0gaGVpZ2h0QXRMaW5lKGdldExpbmUoY20uZG9jLCBkaXNwbGF5LnZpZXdGcm9tKSk7XG4gICAgLy8gUG9zaXRpb24gdGhlIG1vdmVyIGRpdiB0byBhbGlnbiB3aXRoIHRoZSBjdXJyZW50IHNjcm9sbCBwb3NpdGlvblxuICAgIGNtLmRpc3BsYXkubW92ZXIuc3R5bGUudG9wID0gZGlzcGxheS52aWV3T2Zmc2V0ICsgXCJweFwiO1xuXG4gICAgdmFyIHRvVXBkYXRlID0gY291bnREaXJ0eVZpZXcoY20pO1xuICAgIGlmICghZGlmZmVyZW50ICYmIHRvVXBkYXRlID09IDAgJiYgIXVwZGF0ZS5mb3JjZSAmJiBkaXNwbGF5LnJlbmRlcmVkVmlldyA9PSBkaXNwbGF5LnZpZXcgJiZcbiAgICAgICAgKGRpc3BsYXkudXBkYXRlTGluZU51bWJlcnMgPT0gbnVsbCB8fCBkaXNwbGF5LnVwZGF0ZUxpbmVOdW1iZXJzID49IGRpc3BsYXkudmlld1RvKSlcbiAgICAgIHsgcmV0dXJuIGZhbHNlIH1cblxuICAgIC8vIEZvciBiaWcgY2hhbmdlcywgd2UgaGlkZSB0aGUgZW5jbG9zaW5nIGVsZW1lbnQgZHVyaW5nIHRoZVxuICAgIC8vIHVwZGF0ZSwgc2luY2UgdGhhdCBzcGVlZHMgdXAgdGhlIG9wZXJhdGlvbnMgb24gbW9zdCBicm93c2Vycy5cbiAgICB2YXIgc2VsU25hcHNob3QgPSBzZWxlY3Rpb25TbmFwc2hvdChjbSk7XG4gICAgaWYgKHRvVXBkYXRlID4gNCkgeyBkaXNwbGF5LmxpbmVEaXYuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiOyB9XG4gICAgcGF0Y2hEaXNwbGF5KGNtLCBkaXNwbGF5LnVwZGF0ZUxpbmVOdW1iZXJzLCB1cGRhdGUuZGltcyk7XG4gICAgaWYgKHRvVXBkYXRlID4gNCkgeyBkaXNwbGF5LmxpbmVEaXYuc3R5bGUuZGlzcGxheSA9IFwiXCI7IH1cbiAgICBkaXNwbGF5LnJlbmRlcmVkVmlldyA9IGRpc3BsYXkudmlldztcbiAgICAvLyBUaGVyZSBtaWdodCBoYXZlIGJlZW4gYSB3aWRnZXQgd2l0aCBhIGZvY3VzZWQgZWxlbWVudCB0aGF0IGdvdFxuICAgIC8vIGhpZGRlbiBvciB1cGRhdGVkLCBpZiBzbyByZS1mb2N1cyBpdC5cbiAgICByZXN0b3JlU2VsZWN0aW9uKHNlbFNuYXBzaG90KTtcblxuICAgIC8vIFByZXZlbnQgc2VsZWN0aW9uIGFuZCBjdXJzb3JzIGZyb20gaW50ZXJmZXJpbmcgd2l0aCB0aGUgc2Nyb2xsXG4gICAgLy8gd2lkdGggYW5kIGhlaWdodC5cbiAgICByZW1vdmVDaGlsZHJlbihkaXNwbGF5LmN1cnNvckRpdik7XG4gICAgcmVtb3ZlQ2hpbGRyZW4oZGlzcGxheS5zZWxlY3Rpb25EaXYpO1xuICAgIGRpc3BsYXkuZ3V0dGVycy5zdHlsZS5oZWlnaHQgPSBkaXNwbGF5LnNpemVyLnN0eWxlLm1pbkhlaWdodCA9IDA7XG5cbiAgICBpZiAoZGlmZmVyZW50KSB7XG4gICAgICBkaXNwbGF5Lmxhc3RXcmFwSGVpZ2h0ID0gdXBkYXRlLndyYXBwZXJIZWlnaHQ7XG4gICAgICBkaXNwbGF5Lmxhc3RXcmFwV2lkdGggPSB1cGRhdGUud3JhcHBlcldpZHRoO1xuICAgICAgc3RhcnRXb3JrZXIoY20sIDQwMCk7XG4gICAgfVxuXG4gICAgZGlzcGxheS51cGRhdGVMaW5lTnVtYmVycyA9IG51bGw7XG5cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgZnVuY3Rpb24gcG9zdFVwZGF0ZURpc3BsYXkoY20sIHVwZGF0ZSkge1xuICAgIHZhciB2aWV3cG9ydCA9IHVwZGF0ZS52aWV3cG9ydDtcblxuICAgIGZvciAodmFyIGZpcnN0ID0gdHJ1ZTs7IGZpcnN0ID0gZmFsc2UpIHtcbiAgICAgIGlmICghZmlyc3QgfHwgIWNtLm9wdGlvbnMubGluZVdyYXBwaW5nIHx8IHVwZGF0ZS5vbGREaXNwbGF5V2lkdGggPT0gZGlzcGxheVdpZHRoKGNtKSkge1xuICAgICAgICAvLyBDbGlwIGZvcmNlZCB2aWV3cG9ydCB0byBhY3R1YWwgc2Nyb2xsYWJsZSBhcmVhLlxuICAgICAgICBpZiAodmlld3BvcnQgJiYgdmlld3BvcnQudG9wICE9IG51bGwpXG4gICAgICAgICAgeyB2aWV3cG9ydCA9IHt0b3A6IE1hdGgubWluKGNtLmRvYy5oZWlnaHQgKyBwYWRkaW5nVmVydChjbS5kaXNwbGF5KSAtIGRpc3BsYXlIZWlnaHQoY20pLCB2aWV3cG9ydC50b3ApfTsgfVxuICAgICAgICAvLyBVcGRhdGVkIGxpbmUgaGVpZ2h0cyBtaWdodCByZXN1bHQgaW4gdGhlIGRyYXduIGFyZWEgbm90XG4gICAgICAgIC8vIGFjdHVhbGx5IGNvdmVyaW5nIHRoZSB2aWV3cG9ydC4gS2VlcCBsb29waW5nIHVudGlsIGl0IGRvZXMuXG4gICAgICAgIHVwZGF0ZS52aXNpYmxlID0gdmlzaWJsZUxpbmVzKGNtLmRpc3BsYXksIGNtLmRvYywgdmlld3BvcnQpO1xuICAgICAgICBpZiAodXBkYXRlLnZpc2libGUuZnJvbSA+PSBjbS5kaXNwbGF5LnZpZXdGcm9tICYmIHVwZGF0ZS52aXNpYmxlLnRvIDw9IGNtLmRpc3BsYXkudmlld1RvKVxuICAgICAgICAgIHsgYnJlYWsgfVxuICAgICAgfSBlbHNlIGlmIChmaXJzdCkge1xuICAgICAgICB1cGRhdGUudmlzaWJsZSA9IHZpc2libGVMaW5lcyhjbS5kaXNwbGF5LCBjbS5kb2MsIHZpZXdwb3J0KTtcbiAgICAgIH1cbiAgICAgIGlmICghdXBkYXRlRGlzcGxheUlmTmVlZGVkKGNtLCB1cGRhdGUpKSB7IGJyZWFrIH1cbiAgICAgIHVwZGF0ZUhlaWdodHNJblZpZXdwb3J0KGNtKTtcbiAgICAgIHZhciBiYXJNZWFzdXJlID0gbWVhc3VyZUZvclNjcm9sbGJhcnMoY20pO1xuICAgICAgdXBkYXRlU2VsZWN0aW9uKGNtKTtcbiAgICAgIHVwZGF0ZVNjcm9sbGJhcnMoY20sIGJhck1lYXN1cmUpO1xuICAgICAgc2V0RG9jdW1lbnRIZWlnaHQoY20sIGJhck1lYXN1cmUpO1xuICAgICAgdXBkYXRlLmZvcmNlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdXBkYXRlLnNpZ25hbChjbSwgXCJ1cGRhdGVcIiwgY20pO1xuICAgIGlmIChjbS5kaXNwbGF5LnZpZXdGcm9tICE9IGNtLmRpc3BsYXkucmVwb3J0ZWRWaWV3RnJvbSB8fCBjbS5kaXNwbGF5LnZpZXdUbyAhPSBjbS5kaXNwbGF5LnJlcG9ydGVkVmlld1RvKSB7XG4gICAgICB1cGRhdGUuc2lnbmFsKGNtLCBcInZpZXdwb3J0Q2hhbmdlXCIsIGNtLCBjbS5kaXNwbGF5LnZpZXdGcm9tLCBjbS5kaXNwbGF5LnZpZXdUbyk7XG4gICAgICBjbS5kaXNwbGF5LnJlcG9ydGVkVmlld0Zyb20gPSBjbS5kaXNwbGF5LnZpZXdGcm9tOyBjbS5kaXNwbGF5LnJlcG9ydGVkVmlld1RvID0gY20uZGlzcGxheS52aWV3VG87XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlRGlzcGxheVNpbXBsZShjbSwgdmlld3BvcnQpIHtcbiAgICB2YXIgdXBkYXRlID0gbmV3IERpc3BsYXlVcGRhdGUoY20sIHZpZXdwb3J0KTtcbiAgICBpZiAodXBkYXRlRGlzcGxheUlmTmVlZGVkKGNtLCB1cGRhdGUpKSB7XG4gICAgICB1cGRhdGVIZWlnaHRzSW5WaWV3cG9ydChjbSk7XG4gICAgICBwb3N0VXBkYXRlRGlzcGxheShjbSwgdXBkYXRlKTtcbiAgICAgIHZhciBiYXJNZWFzdXJlID0gbWVhc3VyZUZvclNjcm9sbGJhcnMoY20pO1xuICAgICAgdXBkYXRlU2VsZWN0aW9uKGNtKTtcbiAgICAgIHVwZGF0ZVNjcm9sbGJhcnMoY20sIGJhck1lYXN1cmUpO1xuICAgICAgc2V0RG9jdW1lbnRIZWlnaHQoY20sIGJhck1lYXN1cmUpO1xuICAgICAgdXBkYXRlLmZpbmlzaCgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFN5bmMgdGhlIGFjdHVhbCBkaXNwbGF5IERPTSBzdHJ1Y3R1cmUgd2l0aCBkaXNwbGF5LnZpZXcsIHJlbW92aW5nXG4gIC8vIG5vZGVzIGZvciBsaW5lcyB0aGF0IGFyZSBubyBsb25nZXIgaW4gdmlldywgYW5kIGNyZWF0aW5nIHRoZSBvbmVzXG4gIC8vIHRoYXQgYXJlIG5vdCB0aGVyZSB5ZXQsIGFuZCB1cGRhdGluZyB0aGUgb25lcyB0aGF0IGFyZSBvdXQgb2ZcbiAgLy8gZGF0ZS5cbiAgZnVuY3Rpb24gcGF0Y2hEaXNwbGF5KGNtLCB1cGRhdGVOdW1iZXJzRnJvbSwgZGltcykge1xuICAgIHZhciBkaXNwbGF5ID0gY20uZGlzcGxheSwgbGluZU51bWJlcnMgPSBjbS5vcHRpb25zLmxpbmVOdW1iZXJzO1xuICAgIHZhciBjb250YWluZXIgPSBkaXNwbGF5LmxpbmVEaXYsIGN1ciA9IGNvbnRhaW5lci5maXJzdENoaWxkO1xuXG4gICAgZnVuY3Rpb24gcm0obm9kZSkge1xuICAgICAgdmFyIG5leHQgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgICAgLy8gV29ya3MgYXJvdW5kIGEgdGhyb3ctc2Nyb2xsIGJ1ZyBpbiBPUyBYIFdlYmtpdFxuICAgICAgaWYgKHdlYmtpdCAmJiBtYWMgJiYgY20uZGlzcGxheS5jdXJyZW50V2hlZWxUYXJnZXQgPT0gbm9kZSlcbiAgICAgICAgeyBub2RlLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjsgfVxuICAgICAgZWxzZVxuICAgICAgICB7IG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTsgfVxuICAgICAgcmV0dXJuIG5leHRcbiAgICB9XG5cbiAgICB2YXIgdmlldyA9IGRpc3BsYXkudmlldywgbGluZU4gPSBkaXNwbGF5LnZpZXdGcm9tO1xuICAgIC8vIExvb3Agb3ZlciB0aGUgZWxlbWVudHMgaW4gdGhlIHZpZXcsIHN5bmNpbmcgY3VyICh0aGUgRE9NIG5vZGVzXG4gICAgLy8gaW4gZGlzcGxheS5saW5lRGl2KSB3aXRoIHRoZSB2aWV3IGFzIHdlIGdvLlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmlldy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGxpbmVWaWV3ID0gdmlld1tpXTtcbiAgICAgIGlmIChsaW5lVmlldy5oaWRkZW4pIDsgZWxzZSBpZiAoIWxpbmVWaWV3Lm5vZGUgfHwgbGluZVZpZXcubm9kZS5wYXJlbnROb2RlICE9IGNvbnRhaW5lcikgeyAvLyBOb3QgZHJhd24geWV0XG4gICAgICAgIHZhciBub2RlID0gYnVpbGRMaW5lRWxlbWVudChjbSwgbGluZVZpZXcsIGxpbmVOLCBkaW1zKTtcbiAgICAgICAgY29udGFpbmVyLmluc2VydEJlZm9yZShub2RlLCBjdXIpO1xuICAgICAgfSBlbHNlIHsgLy8gQWxyZWFkeSBkcmF3blxuICAgICAgICB3aGlsZSAoY3VyICE9IGxpbmVWaWV3Lm5vZGUpIHsgY3VyID0gcm0oY3VyKTsgfVxuICAgICAgICB2YXIgdXBkYXRlTnVtYmVyID0gbGluZU51bWJlcnMgJiYgdXBkYXRlTnVtYmVyc0Zyb20gIT0gbnVsbCAmJlxuICAgICAgICAgIHVwZGF0ZU51bWJlcnNGcm9tIDw9IGxpbmVOICYmIGxpbmVWaWV3LmxpbmVOdW1iZXI7XG4gICAgICAgIGlmIChsaW5lVmlldy5jaGFuZ2VzKSB7XG4gICAgICAgICAgaWYgKGluZGV4T2YobGluZVZpZXcuY2hhbmdlcywgXCJndXR0ZXJcIikgPiAtMSkgeyB1cGRhdGVOdW1iZXIgPSBmYWxzZTsgfVxuICAgICAgICAgIHVwZGF0ZUxpbmVGb3JDaGFuZ2VzKGNtLCBsaW5lVmlldywgbGluZU4sIGRpbXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cGRhdGVOdW1iZXIpIHtcbiAgICAgICAgICByZW1vdmVDaGlsZHJlbihsaW5lVmlldy5saW5lTnVtYmVyKTtcbiAgICAgICAgICBsaW5lVmlldy5saW5lTnVtYmVyLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGxpbmVOdW1iZXJGb3IoY20ub3B0aW9ucywgbGluZU4pKSk7XG4gICAgICAgIH1cbiAgICAgICAgY3VyID0gbGluZVZpZXcubm9kZS5uZXh0U2libGluZztcbiAgICAgIH1cbiAgICAgIGxpbmVOICs9IGxpbmVWaWV3LnNpemU7XG4gICAgfVxuICAgIHdoaWxlIChjdXIpIHsgY3VyID0gcm0oY3VyKTsgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlR3V0dGVyU3BhY2UoZGlzcGxheSkge1xuICAgIHZhciB3aWR0aCA9IGRpc3BsYXkuZ3V0dGVycy5vZmZzZXRXaWR0aDtcbiAgICBkaXNwbGF5LnNpemVyLnN0eWxlLm1hcmdpbkxlZnQgPSB3aWR0aCArIFwicHhcIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldERvY3VtZW50SGVpZ2h0KGNtLCBtZWFzdXJlKSB7XG4gICAgY20uZGlzcGxheS5zaXplci5zdHlsZS5taW5IZWlnaHQgPSBtZWFzdXJlLmRvY0hlaWdodCArIFwicHhcIjtcbiAgICBjbS5kaXNwbGF5LmhlaWdodEZvcmNlci5zdHlsZS50b3AgPSBtZWFzdXJlLmRvY0hlaWdodCArIFwicHhcIjtcbiAgICBjbS5kaXNwbGF5Lmd1dHRlcnMuc3R5bGUuaGVpZ2h0ID0gKG1lYXN1cmUuZG9jSGVpZ2h0ICsgY20uZGlzcGxheS5iYXJIZWlnaHQgKyBzY3JvbGxHYXAoY20pKSArIFwicHhcIjtcbiAgfVxuXG4gIC8vIFJlLWFsaWduIGxpbmUgbnVtYmVycyBhbmQgZ3V0dGVyIG1hcmtzIHRvIGNvbXBlbnNhdGUgZm9yXG4gIC8vIGhvcml6b250YWwgc2Nyb2xsaW5nLlxuICBmdW5jdGlvbiBhbGlnbkhvcml6b250YWxseShjbSkge1xuICAgIHZhciBkaXNwbGF5ID0gY20uZGlzcGxheSwgdmlldyA9IGRpc3BsYXkudmlldztcbiAgICBpZiAoIWRpc3BsYXkuYWxpZ25XaWRnZXRzICYmICghZGlzcGxheS5ndXR0ZXJzLmZpcnN0Q2hpbGQgfHwgIWNtLm9wdGlvbnMuZml4ZWRHdXR0ZXIpKSB7IHJldHVybiB9XG4gICAgdmFyIGNvbXAgPSBjb21wZW5zYXRlRm9ySFNjcm9sbChkaXNwbGF5KSAtIGRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsTGVmdCArIGNtLmRvYy5zY3JvbGxMZWZ0O1xuICAgIHZhciBndXR0ZXJXID0gZGlzcGxheS5ndXR0ZXJzLm9mZnNldFdpZHRoLCBsZWZ0ID0gY29tcCArIFwicHhcIjtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZpZXcubGVuZ3RoOyBpKyspIHsgaWYgKCF2aWV3W2ldLmhpZGRlbikge1xuICAgICAgaWYgKGNtLm9wdGlvbnMuZml4ZWRHdXR0ZXIpIHtcbiAgICAgICAgaWYgKHZpZXdbaV0uZ3V0dGVyKVxuICAgICAgICAgIHsgdmlld1tpXS5ndXR0ZXIuc3R5bGUubGVmdCA9IGxlZnQ7IH1cbiAgICAgICAgaWYgKHZpZXdbaV0uZ3V0dGVyQmFja2dyb3VuZClcbiAgICAgICAgICB7IHZpZXdbaV0uZ3V0dGVyQmFja2dyb3VuZC5zdHlsZS5sZWZ0ID0gbGVmdDsgfVxuICAgICAgfVxuICAgICAgdmFyIGFsaWduID0gdmlld1tpXS5hbGlnbmFibGU7XG4gICAgICBpZiAoYWxpZ24pIHsgZm9yICh2YXIgaiA9IDA7IGogPCBhbGlnbi5sZW5ndGg7IGorKylcbiAgICAgICAgeyBhbGlnbltqXS5zdHlsZS5sZWZ0ID0gbGVmdDsgfSB9XG4gICAgfSB9XG4gICAgaWYgKGNtLm9wdGlvbnMuZml4ZWRHdXR0ZXIpXG4gICAgICB7IGRpc3BsYXkuZ3V0dGVycy5zdHlsZS5sZWZ0ID0gKGNvbXAgKyBndXR0ZXJXKSArIFwicHhcIjsgfVxuICB9XG5cbiAgLy8gVXNlZCB0byBlbnN1cmUgdGhhdCB0aGUgbGluZSBudW1iZXIgZ3V0dGVyIGlzIHN0aWxsIHRoZSByaWdodFxuICAvLyBzaXplIGZvciB0aGUgY3VycmVudCBkb2N1bWVudCBzaXplLiBSZXR1cm5zIHRydWUgd2hlbiBhbiB1cGRhdGVcbiAgLy8gaXMgbmVlZGVkLlxuICBmdW5jdGlvbiBtYXliZVVwZGF0ZUxpbmVOdW1iZXJXaWR0aChjbSkge1xuICAgIGlmICghY20ub3B0aW9ucy5saW5lTnVtYmVycykgeyByZXR1cm4gZmFsc2UgfVxuICAgIHZhciBkb2MgPSBjbS5kb2MsIGxhc3QgPSBsaW5lTnVtYmVyRm9yKGNtLm9wdGlvbnMsIGRvYy5maXJzdCArIGRvYy5zaXplIC0gMSksIGRpc3BsYXkgPSBjbS5kaXNwbGF5O1xuICAgIGlmIChsYXN0Lmxlbmd0aCAhPSBkaXNwbGF5LmxpbmVOdW1DaGFycykge1xuICAgICAgdmFyIHRlc3QgPSBkaXNwbGF5Lm1lYXN1cmUuYXBwZW5kQ2hpbGQoZWx0KFwiZGl2XCIsIFtlbHQoXCJkaXZcIiwgbGFzdCldLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiQ29kZU1pcnJvci1saW5lbnVtYmVyIENvZGVNaXJyb3ItZ3V0dGVyLWVsdFwiKSk7XG4gICAgICB2YXIgaW5uZXJXID0gdGVzdC5maXJzdENoaWxkLm9mZnNldFdpZHRoLCBwYWRkaW5nID0gdGVzdC5vZmZzZXRXaWR0aCAtIGlubmVyVztcbiAgICAgIGRpc3BsYXkubGluZUd1dHRlci5zdHlsZS53aWR0aCA9IFwiXCI7XG4gICAgICBkaXNwbGF5LmxpbmVOdW1Jbm5lcldpZHRoID0gTWF0aC5tYXgoaW5uZXJXLCBkaXNwbGF5LmxpbmVHdXR0ZXIub2Zmc2V0V2lkdGggLSBwYWRkaW5nKSArIDE7XG4gICAgICBkaXNwbGF5LmxpbmVOdW1XaWR0aCA9IGRpc3BsYXkubGluZU51bUlubmVyV2lkdGggKyBwYWRkaW5nO1xuICAgICAgZGlzcGxheS5saW5lTnVtQ2hhcnMgPSBkaXNwbGF5LmxpbmVOdW1Jbm5lcldpZHRoID8gbGFzdC5sZW5ndGggOiAtMTtcbiAgICAgIGRpc3BsYXkubGluZUd1dHRlci5zdHlsZS53aWR0aCA9IGRpc3BsYXkubGluZU51bVdpZHRoICsgXCJweFwiO1xuICAgICAgdXBkYXRlR3V0dGVyU3BhY2UoY20uZGlzcGxheSk7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEd1dHRlcnMoZ3V0dGVycywgbGluZU51bWJlcnMpIHtcbiAgICB2YXIgcmVzdWx0ID0gW10sIHNhd0xpbmVOdW1iZXJzID0gZmFsc2U7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBndXR0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbmFtZSA9IGd1dHRlcnNbaV0sIHN0eWxlID0gbnVsbDtcbiAgICAgIGlmICh0eXBlb2YgbmFtZSAhPSBcInN0cmluZ1wiKSB7IHN0eWxlID0gbmFtZS5zdHlsZTsgbmFtZSA9IG5hbWUuY2xhc3NOYW1lOyB9XG4gICAgICBpZiAobmFtZSA9PSBcIkNvZGVNaXJyb3ItbGluZW51bWJlcnNcIikge1xuICAgICAgICBpZiAoIWxpbmVOdW1iZXJzKSB7IGNvbnRpbnVlIH1cbiAgICAgICAgZWxzZSB7IHNhd0xpbmVOdW1iZXJzID0gdHJ1ZTsgfVxuICAgICAgfVxuICAgICAgcmVzdWx0LnB1c2goe2NsYXNzTmFtZTogbmFtZSwgc3R5bGU6IHN0eWxlfSk7XG4gICAgfVxuICAgIGlmIChsaW5lTnVtYmVycyAmJiAhc2F3TGluZU51bWJlcnMpIHsgcmVzdWx0LnB1c2goe2NsYXNzTmFtZTogXCJDb2RlTWlycm9yLWxpbmVudW1iZXJzXCIsIHN0eWxlOiBudWxsfSk7IH1cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICAvLyBSZWJ1aWxkIHRoZSBndXR0ZXIgZWxlbWVudHMsIGVuc3VyZSB0aGUgbWFyZ2luIHRvIHRoZSBsZWZ0IG9mIHRoZVxuICAvLyBjb2RlIG1hdGNoZXMgdGhlaXIgd2lkdGguXG4gIGZ1bmN0aW9uIHJlbmRlckd1dHRlcnMoZGlzcGxheSkge1xuICAgIHZhciBndXR0ZXJzID0gZGlzcGxheS5ndXR0ZXJzLCBzcGVjcyA9IGRpc3BsYXkuZ3V0dGVyU3BlY3M7XG4gICAgcmVtb3ZlQ2hpbGRyZW4oZ3V0dGVycyk7XG4gICAgZGlzcGxheS5saW5lR3V0dGVyID0gbnVsbDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNwZWNzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgcmVmID0gc3BlY3NbaV07XG4gICAgICB2YXIgY2xhc3NOYW1lID0gcmVmLmNsYXNzTmFtZTtcbiAgICAgIHZhciBzdHlsZSA9IHJlZi5zdHlsZTtcbiAgICAgIHZhciBnRWx0ID0gZ3V0dGVycy5hcHBlbmRDaGlsZChlbHQoXCJkaXZcIiwgbnVsbCwgXCJDb2RlTWlycm9yLWd1dHRlciBcIiArIGNsYXNzTmFtZSkpO1xuICAgICAgaWYgKHN0eWxlKSB7IGdFbHQuc3R5bGUuY3NzVGV4dCA9IHN0eWxlOyB9XG4gICAgICBpZiAoY2xhc3NOYW1lID09IFwiQ29kZU1pcnJvci1saW5lbnVtYmVyc1wiKSB7XG4gICAgICAgIGRpc3BsYXkubGluZUd1dHRlciA9IGdFbHQ7XG4gICAgICAgIGdFbHQuc3R5bGUud2lkdGggPSAoZGlzcGxheS5saW5lTnVtV2lkdGggfHwgMSkgKyBcInB4XCI7XG4gICAgICB9XG4gICAgfVxuICAgIGd1dHRlcnMuc3R5bGUuZGlzcGxheSA9IHNwZWNzLmxlbmd0aCA/IFwiXCIgOiBcIm5vbmVcIjtcbiAgICB1cGRhdGVHdXR0ZXJTcGFjZShkaXNwbGF5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUd1dHRlcnMoY20pIHtcbiAgICByZW5kZXJHdXR0ZXJzKGNtLmRpc3BsYXkpO1xuICAgIHJlZ0NoYW5nZShjbSk7XG4gICAgYWxpZ25Ib3Jpem9udGFsbHkoY20pO1xuICB9XG5cbiAgLy8gVGhlIGRpc3BsYXkgaGFuZGxlcyB0aGUgRE9NIGludGVncmF0aW9uLCBib3RoIGZvciBpbnB1dCByZWFkaW5nXG4gIC8vIGFuZCBjb250ZW50IGRyYXdpbmcuIEl0IGhvbGRzIHJlZmVyZW5jZXMgdG8gRE9NIG5vZGVzIGFuZFxuICAvLyBkaXNwbGF5LXJlbGF0ZWQgc3RhdGUuXG5cbiAgZnVuY3Rpb24gRGlzcGxheShwbGFjZSwgZG9jLCBpbnB1dCwgb3B0aW9ucykge1xuICAgIHZhciBkID0gdGhpcztcbiAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG5cbiAgICAvLyBDb3ZlcnMgYm90dG9tLXJpZ2h0IHNxdWFyZSB3aGVuIGJvdGggc2Nyb2xsYmFycyBhcmUgcHJlc2VudC5cbiAgICBkLnNjcm9sbGJhckZpbGxlciA9IGVsdChcImRpdlwiLCBudWxsLCBcIkNvZGVNaXJyb3Itc2Nyb2xsYmFyLWZpbGxlclwiKTtcbiAgICBkLnNjcm9sbGJhckZpbGxlci5zZXRBdHRyaWJ1dGUoXCJjbS1ub3QtY29udGVudFwiLCBcInRydWVcIik7XG4gICAgLy8gQ292ZXJzIGJvdHRvbSBvZiBndXR0ZXIgd2hlbiBjb3Zlckd1dHRlck5leHRUb1Njcm9sbGJhciBpcyBvblxuICAgIC8vIGFuZCBoIHNjcm9sbGJhciBpcyBwcmVzZW50LlxuICAgIGQuZ3V0dGVyRmlsbGVyID0gZWx0KFwiZGl2XCIsIG51bGwsIFwiQ29kZU1pcnJvci1ndXR0ZXItZmlsbGVyXCIpO1xuICAgIGQuZ3V0dGVyRmlsbGVyLnNldEF0dHJpYnV0ZShcImNtLW5vdC1jb250ZW50XCIsIFwidHJ1ZVwiKTtcbiAgICAvLyBXaWxsIGNvbnRhaW4gdGhlIGFjdHVhbCBjb2RlLCBwb3NpdGlvbmVkIHRvIGNvdmVyIHRoZSB2aWV3cG9ydC5cbiAgICBkLmxpbmVEaXYgPSBlbHRQKFwiZGl2XCIsIG51bGwsIFwiQ29kZU1pcnJvci1jb2RlXCIpO1xuICAgIC8vIEVsZW1lbnRzIGFyZSBhZGRlZCB0byB0aGVzZSB0byByZXByZXNlbnQgc2VsZWN0aW9uIGFuZCBjdXJzb3JzLlxuICAgIGQuc2VsZWN0aW9uRGl2ID0gZWx0KFwiZGl2XCIsIG51bGwsIG51bGwsIFwicG9zaXRpb246IHJlbGF0aXZlOyB6LWluZGV4OiAxXCIpO1xuICAgIGQuY3Vyc29yRGl2ID0gZWx0KFwiZGl2XCIsIG51bGwsIFwiQ29kZU1pcnJvci1jdXJzb3JzXCIpO1xuICAgIC8vIEEgdmlzaWJpbGl0eTogaGlkZGVuIGVsZW1lbnQgdXNlZCB0byBmaW5kIHRoZSBzaXplIG9mIHRoaW5ncy5cbiAgICBkLm1lYXN1cmUgPSBlbHQoXCJkaXZcIiwgbnVsbCwgXCJDb2RlTWlycm9yLW1lYXN1cmVcIik7XG4gICAgLy8gV2hlbiBsaW5lcyBvdXRzaWRlIG9mIHRoZSB2aWV3cG9ydCBhcmUgbWVhc3VyZWQsIHRoZXkgYXJlIGRyYXduIGluIHRoaXMuXG4gICAgZC5saW5lTWVhc3VyZSA9IGVsdChcImRpdlwiLCBudWxsLCBcIkNvZGVNaXJyb3ItbWVhc3VyZVwiKTtcbiAgICAvLyBXcmFwcyBldmVyeXRoaW5nIHRoYXQgbmVlZHMgdG8gZXhpc3QgaW5zaWRlIHRoZSB2ZXJ0aWNhbGx5LXBhZGRlZCBjb29yZGluYXRlIHN5c3RlbVxuICAgIGQubGluZVNwYWNlID0gZWx0UChcImRpdlwiLCBbZC5tZWFzdXJlLCBkLmxpbmVNZWFzdXJlLCBkLnNlbGVjdGlvbkRpdiwgZC5jdXJzb3JEaXYsIGQubGluZURpdl0sXG4gICAgICAgICAgICAgICAgICAgICAgbnVsbCwgXCJwb3NpdGlvbjogcmVsYXRpdmU7IG91dGxpbmU6IG5vbmVcIik7XG4gICAgdmFyIGxpbmVzID0gZWx0UChcImRpdlwiLCBbZC5saW5lU3BhY2VdLCBcIkNvZGVNaXJyb3ItbGluZXNcIik7XG4gICAgLy8gTW92ZWQgYXJvdW5kIGl0cyBwYXJlbnQgdG8gY292ZXIgdmlzaWJsZSB2aWV3LlxuICAgIGQubW92ZXIgPSBlbHQoXCJkaXZcIiwgW2xpbmVzXSwgbnVsbCwgXCJwb3NpdGlvbjogcmVsYXRpdmVcIik7XG4gICAgLy8gU2V0IHRvIHRoZSBoZWlnaHQgb2YgdGhlIGRvY3VtZW50LCBhbGxvd2luZyBzY3JvbGxpbmcuXG4gICAgZC5zaXplciA9IGVsdChcImRpdlwiLCBbZC5tb3Zlcl0sIFwiQ29kZU1pcnJvci1zaXplclwiKTtcbiAgICBkLnNpemVyV2lkdGggPSBudWxsO1xuICAgIC8vIEJlaGF2aW9yIG9mIGVsdHMgd2l0aCBvdmVyZmxvdzogYXV0byBhbmQgcGFkZGluZyBpc1xuICAgIC8vIGluY29uc2lzdGVudCBhY3Jvc3MgYnJvd3NlcnMuIFRoaXMgaXMgdXNlZCB0byBlbnN1cmUgdGhlXG4gICAgLy8gc2Nyb2xsYWJsZSBhcmVhIGlzIGJpZyBlbm91Z2guXG4gICAgZC5oZWlnaHRGb3JjZXIgPSBlbHQoXCJkaXZcIiwgbnVsbCwgbnVsbCwgXCJwb3NpdGlvbjogYWJzb2x1dGU7IGhlaWdodDogXCIgKyBzY3JvbGxlckdhcCArIFwicHg7IHdpZHRoOiAxcHg7XCIpO1xuICAgIC8vIFdpbGwgY29udGFpbiB0aGUgZ3V0dGVycywgaWYgYW55LlxuICAgIGQuZ3V0dGVycyA9IGVsdChcImRpdlwiLCBudWxsLCBcIkNvZGVNaXJyb3ItZ3V0dGVyc1wiKTtcbiAgICBkLmxpbmVHdXR0ZXIgPSBudWxsO1xuICAgIC8vIEFjdHVhbCBzY3JvbGxhYmxlIGVsZW1lbnQuXG4gICAgZC5zY3JvbGxlciA9IGVsdChcImRpdlwiLCBbZC5zaXplciwgZC5oZWlnaHRGb3JjZXIsIGQuZ3V0dGVyc10sIFwiQ29kZU1pcnJvci1zY3JvbGxcIik7XG4gICAgZC5zY3JvbGxlci5zZXRBdHRyaWJ1dGUoXCJ0YWJJbmRleFwiLCBcIi0xXCIpO1xuICAgIC8vIFRoZSBlbGVtZW50IGluIHdoaWNoIHRoZSBlZGl0b3IgbGl2ZXMuXG4gICAgZC53cmFwcGVyID0gZWx0KFwiZGl2XCIsIFtkLnNjcm9sbGJhckZpbGxlciwgZC5ndXR0ZXJGaWxsZXIsIGQuc2Nyb2xsZXJdLCBcIkNvZGVNaXJyb3JcIik7XG5cbiAgICAvLyBXb3JrIGFyb3VuZCBJRTcgei1pbmRleCBidWcgKG5vdCBwZXJmZWN0LCBoZW5jZSBJRTcgbm90IHJlYWxseSBiZWluZyBzdXBwb3J0ZWQpXG4gICAgaWYgKGllICYmIGllX3ZlcnNpb24gPCA4KSB7IGQuZ3V0dGVycy5zdHlsZS56SW5kZXggPSAtMTsgZC5zY3JvbGxlci5zdHlsZS5wYWRkaW5nUmlnaHQgPSAwOyB9XG4gICAgaWYgKCF3ZWJraXQgJiYgIShnZWNrbyAmJiBtb2JpbGUpKSB7IGQuc2Nyb2xsZXIuZHJhZ2dhYmxlID0gdHJ1ZTsgfVxuXG4gICAgaWYgKHBsYWNlKSB7XG4gICAgICBpZiAocGxhY2UuYXBwZW5kQ2hpbGQpIHsgcGxhY2UuYXBwZW5kQ2hpbGQoZC53cmFwcGVyKTsgfVxuICAgICAgZWxzZSB7IHBsYWNlKGQud3JhcHBlcik7IH1cbiAgICB9XG5cbiAgICAvLyBDdXJyZW50IHJlbmRlcmVkIHJhbmdlIChtYXkgYmUgYmlnZ2VyIHRoYW4gdGhlIHZpZXcgd2luZG93KS5cbiAgICBkLnZpZXdGcm9tID0gZC52aWV3VG8gPSBkb2MuZmlyc3Q7XG4gICAgZC5yZXBvcnRlZFZpZXdGcm9tID0gZC5yZXBvcnRlZFZpZXdUbyA9IGRvYy5maXJzdDtcbiAgICAvLyBJbmZvcm1hdGlvbiBhYm91dCB0aGUgcmVuZGVyZWQgbGluZXMuXG4gICAgZC52aWV3ID0gW107XG4gICAgZC5yZW5kZXJlZFZpZXcgPSBudWxsO1xuICAgIC8vIEhvbGRzIGluZm8gYWJvdXQgYSBzaW5nbGUgcmVuZGVyZWQgbGluZSB3aGVuIGl0IHdhcyByZW5kZXJlZFxuICAgIC8vIGZvciBtZWFzdXJlbWVudCwgd2hpbGUgbm90IGluIHZpZXcuXG4gICAgZC5leHRlcm5hbE1lYXN1cmVkID0gbnVsbDtcbiAgICAvLyBFbXB0eSBzcGFjZSAoaW4gcGl4ZWxzKSBhYm92ZSB0aGUgdmlld1xuICAgIGQudmlld09mZnNldCA9IDA7XG4gICAgZC5sYXN0V3JhcEhlaWdodCA9IGQubGFzdFdyYXBXaWR0aCA9IDA7XG4gICAgZC51cGRhdGVMaW5lTnVtYmVycyA9IG51bGw7XG5cbiAgICBkLm5hdGl2ZUJhcldpZHRoID0gZC5iYXJIZWlnaHQgPSBkLmJhcldpZHRoID0gMDtcbiAgICBkLnNjcm9sbGJhcnNDbGlwcGVkID0gZmFsc2U7XG5cbiAgICAvLyBVc2VkIHRvIG9ubHkgcmVzaXplIHRoZSBsaW5lIG51bWJlciBndXR0ZXIgd2hlbiBuZWNlc3NhcnkgKHdoZW5cbiAgICAvLyB0aGUgYW1vdW50IG9mIGxpbmVzIGNyb3NzZXMgYSBib3VuZGFyeSB0aGF0IG1ha2VzIGl0cyB3aWR0aCBjaGFuZ2UpXG4gICAgZC5saW5lTnVtV2lkdGggPSBkLmxpbmVOdW1Jbm5lcldpZHRoID0gZC5saW5lTnVtQ2hhcnMgPSBudWxsO1xuICAgIC8vIFNldCB0byB0cnVlIHdoZW4gYSBub24taG9yaXpvbnRhbC1zY3JvbGxpbmcgbGluZSB3aWRnZXQgaXNcbiAgICAvLyBhZGRlZC4gQXMgYW4gb3B0aW1pemF0aW9uLCBsaW5lIHdpZGdldCBhbGlnbmluZyBpcyBza2lwcGVkIHdoZW5cbiAgICAvLyB0aGlzIGlzIGZhbHNlLlxuICAgIGQuYWxpZ25XaWRnZXRzID0gZmFsc2U7XG5cbiAgICBkLmNhY2hlZENoYXJXaWR0aCA9IGQuY2FjaGVkVGV4dEhlaWdodCA9IGQuY2FjaGVkUGFkZGluZ0ggPSBudWxsO1xuXG4gICAgLy8gVHJhY2tzIHRoZSBtYXhpbXVtIGxpbmUgbGVuZ3RoIHNvIHRoYXQgdGhlIGhvcml6b250YWwgc2Nyb2xsYmFyXG4gICAgLy8gY2FuIGJlIGtlcHQgc3RhdGljIHdoZW4gc2Nyb2xsaW5nLlxuICAgIGQubWF4TGluZSA9IG51bGw7XG4gICAgZC5tYXhMaW5lTGVuZ3RoID0gMDtcbiAgICBkLm1heExpbmVDaGFuZ2VkID0gZmFsc2U7XG5cbiAgICAvLyBVc2VkIGZvciBtZWFzdXJpbmcgd2hlZWwgc2Nyb2xsaW5nIGdyYW51bGFyaXR5XG4gICAgZC53aGVlbERYID0gZC53aGVlbERZID0gZC53aGVlbFN0YXJ0WCA9IGQud2hlZWxTdGFydFkgPSBudWxsO1xuXG4gICAgLy8gVHJ1ZSB3aGVuIHNoaWZ0IGlzIGhlbGQgZG93bi5cbiAgICBkLnNoaWZ0ID0gZmFsc2U7XG5cbiAgICAvLyBVc2VkIHRvIHRyYWNrIHdoZXRoZXIgYW55dGhpbmcgaGFwcGVuZWQgc2luY2UgdGhlIGNvbnRleHQgbWVudVxuICAgIC8vIHdhcyBvcGVuZWQuXG4gICAgZC5zZWxGb3JDb250ZXh0TWVudSA9IG51bGw7XG5cbiAgICBkLmFjdGl2ZVRvdWNoID0gbnVsbDtcblxuICAgIGQuZ3V0dGVyU3BlY3MgPSBnZXRHdXR0ZXJzKG9wdGlvbnMuZ3V0dGVycywgb3B0aW9ucy5saW5lTnVtYmVycyk7XG4gICAgcmVuZGVyR3V0dGVycyhkKTtcblxuICAgIGlucHV0LmluaXQoZCk7XG4gIH1cblxuICAvLyBTaW5jZSB0aGUgZGVsdGEgdmFsdWVzIHJlcG9ydGVkIG9uIG1vdXNlIHdoZWVsIGV2ZW50cyBhcmVcbiAgLy8gdW5zdGFuZGFyZGl6ZWQgYmV0d2VlbiBicm93c2VycyBhbmQgZXZlbiBicm93c2VyIHZlcnNpb25zLCBhbmRcbiAgLy8gZ2VuZXJhbGx5IGhvcnJpYmx5IHVucHJlZGljdGFibGUsIHRoaXMgY29kZSBzdGFydHMgYnkgbWVhc3VyaW5nXG4gIC8vIHRoZSBzY3JvbGwgZWZmZWN0IHRoYXQgdGhlIGZpcnN0IGZldyBtb3VzZSB3aGVlbCBldmVudHMgaGF2ZSxcbiAgLy8gYW5kLCBmcm9tIHRoYXQsIGRldGVjdHMgdGhlIHdheSBpdCBjYW4gY29udmVydCBkZWx0YXMgdG8gcGl4ZWxcbiAgLy8gb2Zmc2V0cyBhZnRlcndhcmRzLlxuICAvL1xuICAvLyBUaGUgcmVhc29uIHdlIHdhbnQgdG8ga25vdyB0aGUgYW1vdW50IGEgd2hlZWwgZXZlbnQgd2lsbCBzY3JvbGxcbiAgLy8gaXMgdGhhdCBpdCBnaXZlcyB1cyBhIGNoYW5jZSB0byB1cGRhdGUgdGhlIGRpc3BsYXkgYmVmb3JlIHRoZVxuICAvLyBhY3R1YWwgc2Nyb2xsaW5nIGhhcHBlbnMsIHJlZHVjaW5nIGZsaWNrZXJpbmcuXG5cbiAgdmFyIHdoZWVsU2FtcGxlcyA9IDAsIHdoZWVsUGl4ZWxzUGVyVW5pdCA9IG51bGw7XG4gIC8vIEZpbGwgaW4gYSBicm93c2VyLWRldGVjdGVkIHN0YXJ0aW5nIHZhbHVlIG9uIGJyb3dzZXJzIHdoZXJlIHdlXG4gIC8vIGtub3cgb25lLiBUaGVzZSBkb24ndCBoYXZlIHRvIGJlIGFjY3VyYXRlIC0tIHRoZSByZXN1bHQgb2YgdGhlbVxuICAvLyBiZWluZyB3cm9uZyB3b3VsZCBqdXN0IGJlIGEgc2xpZ2h0IGZsaWNrZXIgb24gdGhlIGZpcnN0IHdoZWVsXG4gIC8vIHNjcm9sbCAoaWYgaXQgaXMgbGFyZ2UgZW5vdWdoKS5cbiAgaWYgKGllKSB7IHdoZWVsUGl4ZWxzUGVyVW5pdCA9IC0uNTM7IH1cbiAgZWxzZSBpZiAoZ2Vja28pIHsgd2hlZWxQaXhlbHNQZXJVbml0ID0gMTU7IH1cbiAgZWxzZSBpZiAoY2hyb21lKSB7IHdoZWVsUGl4ZWxzUGVyVW5pdCA9IC0uNzsgfVxuICBlbHNlIGlmIChzYWZhcmkpIHsgd2hlZWxQaXhlbHNQZXJVbml0ID0gLTEvMzsgfVxuXG4gIGZ1bmN0aW9uIHdoZWVsRXZlbnREZWx0YShlKSB7XG4gICAgdmFyIGR4ID0gZS53aGVlbERlbHRhWCwgZHkgPSBlLndoZWVsRGVsdGFZO1xuICAgIGlmIChkeCA9PSBudWxsICYmIGUuZGV0YWlsICYmIGUuYXhpcyA9PSBlLkhPUklaT05UQUxfQVhJUykgeyBkeCA9IGUuZGV0YWlsOyB9XG4gICAgaWYgKGR5ID09IG51bGwgJiYgZS5kZXRhaWwgJiYgZS5heGlzID09IGUuVkVSVElDQUxfQVhJUykgeyBkeSA9IGUuZGV0YWlsOyB9XG4gICAgZWxzZSBpZiAoZHkgPT0gbnVsbCkgeyBkeSA9IGUud2hlZWxEZWx0YTsgfVxuICAgIHJldHVybiB7eDogZHgsIHk6IGR5fVxuICB9XG4gIGZ1bmN0aW9uIHdoZWVsRXZlbnRQaXhlbHMoZSkge1xuICAgIHZhciBkZWx0YSA9IHdoZWVsRXZlbnREZWx0YShlKTtcbiAgICBkZWx0YS54ICo9IHdoZWVsUGl4ZWxzUGVyVW5pdDtcbiAgICBkZWx0YS55ICo9IHdoZWVsUGl4ZWxzUGVyVW5pdDtcbiAgICByZXR1cm4gZGVsdGFcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uU2Nyb2xsV2hlZWwoY20sIGUpIHtcbiAgICB2YXIgZGVsdGEgPSB3aGVlbEV2ZW50RGVsdGEoZSksIGR4ID0gZGVsdGEueCwgZHkgPSBkZWx0YS55O1xuXG4gICAgdmFyIGRpc3BsYXkgPSBjbS5kaXNwbGF5LCBzY3JvbGwgPSBkaXNwbGF5LnNjcm9sbGVyO1xuICAgIC8vIFF1aXQgaWYgdGhlcmUncyBub3RoaW5nIHRvIHNjcm9sbCBoZXJlXG4gICAgdmFyIGNhblNjcm9sbFggPSBzY3JvbGwuc2Nyb2xsV2lkdGggPiBzY3JvbGwuY2xpZW50V2lkdGg7XG4gICAgdmFyIGNhblNjcm9sbFkgPSBzY3JvbGwuc2Nyb2xsSGVpZ2h0ID4gc2Nyb2xsLmNsaWVudEhlaWdodDtcbiAgICBpZiAoIShkeCAmJiBjYW5TY3JvbGxYIHx8IGR5ICYmIGNhblNjcm9sbFkpKSB7IHJldHVybiB9XG5cbiAgICAvLyBXZWJraXQgYnJvd3NlcnMgb24gT1MgWCBhYm9ydCBtb21lbnR1bSBzY3JvbGxzIHdoZW4gdGhlIHRhcmdldFxuICAgIC8vIG9mIHRoZSBzY3JvbGwgZXZlbnQgaXMgcmVtb3ZlZCBmcm9tIHRoZSBzY3JvbGxhYmxlIGVsZW1lbnQuXG4gICAgLy8gVGhpcyBoYWNrIChzZWUgcmVsYXRlZCBjb2RlIGluIHBhdGNoRGlzcGxheSkgbWFrZXMgc3VyZSB0aGVcbiAgICAvLyBlbGVtZW50IGlzIGtlcHQgYXJvdW5kLlxuICAgIGlmIChkeSAmJiBtYWMgJiYgd2Via2l0KSB7XG4gICAgICBvdXRlcjogZm9yICh2YXIgY3VyID0gZS50YXJnZXQsIHZpZXcgPSBkaXNwbGF5LnZpZXc7IGN1ciAhPSBzY3JvbGw7IGN1ciA9IGN1ci5wYXJlbnROb2RlKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmlldy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmICh2aWV3W2ldLm5vZGUgPT0gY3VyKSB7XG4gICAgICAgICAgICBjbS5kaXNwbGF5LmN1cnJlbnRXaGVlbFRhcmdldCA9IGN1cjtcbiAgICAgICAgICAgIGJyZWFrIG91dGVyXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gT24gc29tZSBicm93c2VycywgaG9yaXpvbnRhbCBzY3JvbGxpbmcgd2lsbCBjYXVzZSByZWRyYXdzIHRvXG4gICAgLy8gaGFwcGVuIGJlZm9yZSB0aGUgZ3V0dGVyIGhhcyBiZWVuIHJlYWxpZ25lZCwgY2F1c2luZyBpdCB0b1xuICAgIC8vIHdyaWdnbGUgYXJvdW5kIGluIGEgbW9zdCB1bnNlZW1seSB3YXkuIFdoZW4gd2UgaGF2ZSBhblxuICAgIC8vIGVzdGltYXRlZCBwaXhlbHMvZGVsdGEgdmFsdWUsIHdlIGp1c3QgaGFuZGxlIGhvcml6b250YWxcbiAgICAvLyBzY3JvbGxpbmcgZW50aXJlbHkgaGVyZS4gSXQnbGwgYmUgc2xpZ2h0bHkgb2ZmIGZyb20gbmF0aXZlLCBidXRcbiAgICAvLyBiZXR0ZXIgdGhhbiBnbGl0Y2hpbmcgb3V0LlxuICAgIGlmIChkeCAmJiAhZ2Vja28gJiYgIXByZXN0byAmJiB3aGVlbFBpeGVsc1BlclVuaXQgIT0gbnVsbCkge1xuICAgICAgaWYgKGR5ICYmIGNhblNjcm9sbFkpXG4gICAgICAgIHsgdXBkYXRlU2Nyb2xsVG9wKGNtLCBNYXRoLm1heCgwLCBzY3JvbGwuc2Nyb2xsVG9wICsgZHkgKiB3aGVlbFBpeGVsc1BlclVuaXQpKTsgfVxuICAgICAgc2V0U2Nyb2xsTGVmdChjbSwgTWF0aC5tYXgoMCwgc2Nyb2xsLnNjcm9sbExlZnQgKyBkeCAqIHdoZWVsUGl4ZWxzUGVyVW5pdCkpO1xuICAgICAgLy8gT25seSBwcmV2ZW50IGRlZmF1bHQgc2Nyb2xsaW5nIGlmIHZlcnRpY2FsIHNjcm9sbGluZyBpc1xuICAgICAgLy8gYWN0dWFsbHkgcG9zc2libGUuIE90aGVyd2lzZSwgaXQgY2F1c2VzIHZlcnRpY2FsIHNjcm9sbFxuICAgICAgLy8gaml0dGVyIG9uIE9TWCB0cmFja3BhZHMgd2hlbiBkZWx0YVggaXMgc21hbGwgYW5kIGRlbHRhWVxuICAgICAgLy8gaXMgbGFyZ2UgKGlzc3VlICMzNTc5KVxuICAgICAgaWYgKCFkeSB8fCAoZHkgJiYgY2FuU2Nyb2xsWSkpXG4gICAgICAgIHsgZV9wcmV2ZW50RGVmYXVsdChlKTsgfVxuICAgICAgZGlzcGxheS53aGVlbFN0YXJ0WCA9IG51bGw7IC8vIEFib3J0IG1lYXN1cmVtZW50LCBpZiBpbiBwcm9ncmVzc1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gJ1Byb2plY3QnIHRoZSB2aXNpYmxlIHZpZXdwb3J0IHRvIGNvdmVyIHRoZSBhcmVhIHRoYXQgaXMgYmVpbmdcbiAgICAvLyBzY3JvbGxlZCBpbnRvIHZpZXcgKGlmIHdlIGtub3cgZW5vdWdoIHRvIGVzdGltYXRlIGl0KS5cbiAgICBpZiAoZHkgJiYgd2hlZWxQaXhlbHNQZXJVbml0ICE9IG51bGwpIHtcbiAgICAgIHZhciBwaXhlbHMgPSBkeSAqIHdoZWVsUGl4ZWxzUGVyVW5pdDtcbiAgICAgIHZhciB0b3AgPSBjbS5kb2Muc2Nyb2xsVG9wLCBib3QgPSB0b3AgKyBkaXNwbGF5LndyYXBwZXIuY2xpZW50SGVpZ2h0O1xuICAgICAgaWYgKHBpeGVscyA8IDApIHsgdG9wID0gTWF0aC5tYXgoMCwgdG9wICsgcGl4ZWxzIC0gNTApOyB9XG4gICAgICBlbHNlIHsgYm90ID0gTWF0aC5taW4oY20uZG9jLmhlaWdodCwgYm90ICsgcGl4ZWxzICsgNTApOyB9XG4gICAgICB1cGRhdGVEaXNwbGF5U2ltcGxlKGNtLCB7dG9wOiB0b3AsIGJvdHRvbTogYm90fSk7XG4gICAgfVxuXG4gICAgaWYgKHdoZWVsU2FtcGxlcyA8IDIwKSB7XG4gICAgICBpZiAoZGlzcGxheS53aGVlbFN0YXJ0WCA9PSBudWxsKSB7XG4gICAgICAgIGRpc3BsYXkud2hlZWxTdGFydFggPSBzY3JvbGwuc2Nyb2xsTGVmdDsgZGlzcGxheS53aGVlbFN0YXJ0WSA9IHNjcm9sbC5zY3JvbGxUb3A7XG4gICAgICAgIGRpc3BsYXkud2hlZWxEWCA9IGR4OyBkaXNwbGF5LndoZWVsRFkgPSBkeTtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKGRpc3BsYXkud2hlZWxTdGFydFggPT0gbnVsbCkgeyByZXR1cm4gfVxuICAgICAgICAgIHZhciBtb3ZlZFggPSBzY3JvbGwuc2Nyb2xsTGVmdCAtIGRpc3BsYXkud2hlZWxTdGFydFg7XG4gICAgICAgICAgdmFyIG1vdmVkWSA9IHNjcm9sbC5zY3JvbGxUb3AgLSBkaXNwbGF5LndoZWVsU3RhcnRZO1xuICAgICAgICAgIHZhciBzYW1wbGUgPSAobW92ZWRZICYmIGRpc3BsYXkud2hlZWxEWSAmJiBtb3ZlZFkgLyBkaXNwbGF5LndoZWVsRFkpIHx8XG4gICAgICAgICAgICAobW92ZWRYICYmIGRpc3BsYXkud2hlZWxEWCAmJiBtb3ZlZFggLyBkaXNwbGF5LndoZWVsRFgpO1xuICAgICAgICAgIGRpc3BsYXkud2hlZWxTdGFydFggPSBkaXNwbGF5LndoZWVsU3RhcnRZID0gbnVsbDtcbiAgICAgICAgICBpZiAoIXNhbXBsZSkgeyByZXR1cm4gfVxuICAgICAgICAgIHdoZWVsUGl4ZWxzUGVyVW5pdCA9ICh3aGVlbFBpeGVsc1BlclVuaXQgKiB3aGVlbFNhbXBsZXMgKyBzYW1wbGUpIC8gKHdoZWVsU2FtcGxlcyArIDEpO1xuICAgICAgICAgICsrd2hlZWxTYW1wbGVzO1xuICAgICAgICB9LCAyMDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGlzcGxheS53aGVlbERYICs9IGR4OyBkaXNwbGF5LndoZWVsRFkgKz0gZHk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gU2VsZWN0aW9uIG9iamVjdHMgYXJlIGltbXV0YWJsZS4gQSBuZXcgb25lIGlzIGNyZWF0ZWQgZXZlcnkgdGltZVxuICAvLyB0aGUgc2VsZWN0aW9uIGNoYW5nZXMuIEEgc2VsZWN0aW9uIGlzIG9uZSBvciBtb3JlIG5vbi1vdmVybGFwcGluZ1xuICAvLyAoYW5kIG5vbi10b3VjaGluZykgcmFuZ2VzLCBzb3J0ZWQsIGFuZCBhbiBpbnRlZ2VyIHRoYXQgaW5kaWNhdGVzXG4gIC8vIHdoaWNoIG9uZSBpcyB0aGUgcHJpbWFyeSBzZWxlY3Rpb24gKHRoZSBvbmUgdGhhdCdzIHNjcm9sbGVkIGludG9cbiAgLy8gdmlldywgdGhhdCBnZXRDdXJzb3IgcmV0dXJucywgZXRjKS5cbiAgdmFyIFNlbGVjdGlvbiA9IGZ1bmN0aW9uKHJhbmdlcywgcHJpbUluZGV4KSB7XG4gICAgdGhpcy5yYW5nZXMgPSByYW5nZXM7XG4gICAgdGhpcy5wcmltSW5kZXggPSBwcmltSW5kZXg7XG4gIH07XG5cbiAgU2VsZWN0aW9uLnByb3RvdHlwZS5wcmltYXJ5ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5yYW5nZXNbdGhpcy5wcmltSW5kZXhdIH07XG5cbiAgU2VsZWN0aW9uLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICBpZiAob3RoZXIgPT0gdGhpcykgeyByZXR1cm4gdHJ1ZSB9XG4gICAgaWYgKG90aGVyLnByaW1JbmRleCAhPSB0aGlzLnByaW1JbmRleCB8fCBvdGhlci5yYW5nZXMubGVuZ3RoICE9IHRoaXMucmFuZ2VzLmxlbmd0aCkgeyByZXR1cm4gZmFsc2UgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBoZXJlID0gdGhpcy5yYW5nZXNbaV0sIHRoZXJlID0gb3RoZXIucmFuZ2VzW2ldO1xuICAgICAgaWYgKCFlcXVhbEN1cnNvclBvcyhoZXJlLmFuY2hvciwgdGhlcmUuYW5jaG9yKSB8fCAhZXF1YWxDdXJzb3JQb3MoaGVyZS5oZWFkLCB0aGVyZS5oZWFkKSkgeyByZXR1cm4gZmFsc2UgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9O1xuXG4gIFNlbGVjdGlvbi5wcm90b3R5cGUuZGVlcENvcHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG91dCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yYW5nZXMubGVuZ3RoOyBpKyspXG4gICAgICB7IG91dFtpXSA9IG5ldyBSYW5nZShjb3B5UG9zKHRoaXMucmFuZ2VzW2ldLmFuY2hvciksIGNvcHlQb3ModGhpcy5yYW5nZXNbaV0uaGVhZCkpOyB9XG4gICAgcmV0dXJuIG5ldyBTZWxlY3Rpb24ob3V0LCB0aGlzLnByaW1JbmRleClcbiAgfTtcblxuICBTZWxlY3Rpb24ucHJvdG90eXBlLnNvbWV0aGluZ1NlbGVjdGVkID0gZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yYW5nZXMubGVuZ3RoOyBpKyspXG4gICAgICB7IGlmICghdGhpcy5yYW5nZXNbaV0uZW1wdHkoKSkgeyByZXR1cm4gdHJ1ZSB9IH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcblxuICBTZWxlY3Rpb24ucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gKHBvcywgZW5kKSB7XG4gICAgaWYgKCFlbmQpIHsgZW5kID0gcG9zOyB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHJhbmdlID0gdGhpcy5yYW5nZXNbaV07XG4gICAgICBpZiAoY21wKGVuZCwgcmFuZ2UuZnJvbSgpKSA+PSAwICYmIGNtcChwb3MsIHJhbmdlLnRvKCkpIDw9IDApXG4gICAgICAgIHsgcmV0dXJuIGkgfVxuICAgIH1cbiAgICByZXR1cm4gLTFcbiAgfTtcblxuICB2YXIgUmFuZ2UgPSBmdW5jdGlvbihhbmNob3IsIGhlYWQpIHtcbiAgICB0aGlzLmFuY2hvciA9IGFuY2hvcjsgdGhpcy5oZWFkID0gaGVhZDtcbiAgfTtcblxuICBSYW5nZS5wcm90b3R5cGUuZnJvbSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1pblBvcyh0aGlzLmFuY2hvciwgdGhpcy5oZWFkKSB9O1xuICBSYW5nZS5wcm90b3R5cGUudG8gPSBmdW5jdGlvbiAoKSB7IHJldHVybiBtYXhQb3ModGhpcy5hbmNob3IsIHRoaXMuaGVhZCkgfTtcbiAgUmFuZ2UucHJvdG90eXBlLmVtcHR5ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5oZWFkLmxpbmUgPT0gdGhpcy5hbmNob3IubGluZSAmJiB0aGlzLmhlYWQuY2ggPT0gdGhpcy5hbmNob3IuY2ggfTtcblxuICAvLyBUYWtlIGFuIHVuc29ydGVkLCBwb3RlbnRpYWxseSBvdmVybGFwcGluZyBzZXQgb2YgcmFuZ2VzLCBhbmRcbiAgLy8gYnVpbGQgYSBzZWxlY3Rpb24gb3V0IG9mIGl0LiAnQ29uc3VtZXMnIHJhbmdlcyBhcnJheSAobW9kaWZ5aW5nXG4gIC8vIGl0KS5cbiAgZnVuY3Rpb24gbm9ybWFsaXplU2VsZWN0aW9uKGNtLCByYW5nZXMsIHByaW1JbmRleCkge1xuICAgIHZhciBtYXlUb3VjaCA9IGNtICYmIGNtLm9wdGlvbnMuc2VsZWN0aW9uc01heVRvdWNoO1xuICAgIHZhciBwcmltID0gcmFuZ2VzW3ByaW1JbmRleF07XG4gICAgcmFuZ2VzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGNtcChhLmZyb20oKSwgYi5mcm9tKCkpOyB9KTtcbiAgICBwcmltSW5kZXggPSBpbmRleE9mKHJhbmdlcywgcHJpbSk7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjdXIgPSByYW5nZXNbaV0sIHByZXYgPSByYW5nZXNbaSAtIDFdO1xuICAgICAgdmFyIGRpZmYgPSBjbXAocHJldi50bygpLCBjdXIuZnJvbSgpKTtcbiAgICAgIGlmIChtYXlUb3VjaCAmJiAhY3VyLmVtcHR5KCkgPyBkaWZmID4gMCA6IGRpZmYgPj0gMCkge1xuICAgICAgICB2YXIgZnJvbSA9IG1pblBvcyhwcmV2LmZyb20oKSwgY3VyLmZyb20oKSksIHRvID0gbWF4UG9zKHByZXYudG8oKSwgY3VyLnRvKCkpO1xuICAgICAgICB2YXIgaW52ID0gcHJldi5lbXB0eSgpID8gY3VyLmZyb20oKSA9PSBjdXIuaGVhZCA6IHByZXYuZnJvbSgpID09IHByZXYuaGVhZDtcbiAgICAgICAgaWYgKGkgPD0gcHJpbUluZGV4KSB7IC0tcHJpbUluZGV4OyB9XG4gICAgICAgIHJhbmdlcy5zcGxpY2UoLS1pLCAyLCBuZXcgUmFuZ2UoaW52ID8gdG8gOiBmcm9tLCBpbnYgPyBmcm9tIDogdG8pKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBTZWxlY3Rpb24ocmFuZ2VzLCBwcmltSW5kZXgpXG4gIH1cblxuICBmdW5jdGlvbiBzaW1wbGVTZWxlY3Rpb24oYW5jaG9yLCBoZWFkKSB7XG4gICAgcmV0dXJuIG5ldyBTZWxlY3Rpb24oW25ldyBSYW5nZShhbmNob3IsIGhlYWQgfHwgYW5jaG9yKV0sIDApXG4gIH1cblxuICAvLyBDb21wdXRlIHRoZSBwb3NpdGlvbiBvZiB0aGUgZW5kIG9mIGEgY2hhbmdlIChpdHMgJ3RvJyBwcm9wZXJ0eVxuICAvLyByZWZlcnMgdG8gdGhlIHByZS1jaGFuZ2UgZW5kKS5cbiAgZnVuY3Rpb24gY2hhbmdlRW5kKGNoYW5nZSkge1xuICAgIGlmICghY2hhbmdlLnRleHQpIHsgcmV0dXJuIGNoYW5nZS50byB9XG4gICAgcmV0dXJuIFBvcyhjaGFuZ2UuZnJvbS5saW5lICsgY2hhbmdlLnRleHQubGVuZ3RoIC0gMSxcbiAgICAgICAgICAgICAgIGxzdChjaGFuZ2UudGV4dCkubGVuZ3RoICsgKGNoYW5nZS50ZXh0Lmxlbmd0aCA9PSAxID8gY2hhbmdlLmZyb20uY2ggOiAwKSlcbiAgfVxuXG4gIC8vIEFkanVzdCBhIHBvc2l0aW9uIHRvIHJlZmVyIHRvIHRoZSBwb3N0LWNoYW5nZSBwb3NpdGlvbiBvZiB0aGVcbiAgLy8gc2FtZSB0ZXh0LCBvciB0aGUgZW5kIG9mIHRoZSBjaGFuZ2UgaWYgdGhlIGNoYW5nZSBjb3ZlcnMgaXQuXG4gIGZ1bmN0aW9uIGFkanVzdEZvckNoYW5nZShwb3MsIGNoYW5nZSkge1xuICAgIGlmIChjbXAocG9zLCBjaGFuZ2UuZnJvbSkgPCAwKSB7IHJldHVybiBwb3MgfVxuICAgIGlmIChjbXAocG9zLCBjaGFuZ2UudG8pIDw9IDApIHsgcmV0dXJuIGNoYW5nZUVuZChjaGFuZ2UpIH1cblxuICAgIHZhciBsaW5lID0gcG9zLmxpbmUgKyBjaGFuZ2UudGV4dC5sZW5ndGggLSAoY2hhbmdlLnRvLmxpbmUgLSBjaGFuZ2UuZnJvbS5saW5lKSAtIDEsIGNoID0gcG9zLmNoO1xuICAgIGlmIChwb3MubGluZSA9PSBjaGFuZ2UudG8ubGluZSkgeyBjaCArPSBjaGFuZ2VFbmQoY2hhbmdlKS5jaCAtIGNoYW5nZS50by5jaDsgfVxuICAgIHJldHVybiBQb3MobGluZSwgY2gpXG4gIH1cblxuICBmdW5jdGlvbiBjb21wdXRlU2VsQWZ0ZXJDaGFuZ2UoZG9jLCBjaGFuZ2UpIHtcbiAgICB2YXIgb3V0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkb2Muc2VsLnJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHJhbmdlID0gZG9jLnNlbC5yYW5nZXNbaV07XG4gICAgICBvdXQucHVzaChuZXcgUmFuZ2UoYWRqdXN0Rm9yQ2hhbmdlKHJhbmdlLmFuY2hvciwgY2hhbmdlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICBhZGp1c3RGb3JDaGFuZ2UocmFuZ2UuaGVhZCwgY2hhbmdlKSkpO1xuICAgIH1cbiAgICByZXR1cm4gbm9ybWFsaXplU2VsZWN0aW9uKGRvYy5jbSwgb3V0LCBkb2Muc2VsLnByaW1JbmRleClcbiAgfVxuXG4gIGZ1bmN0aW9uIG9mZnNldFBvcyhwb3MsIG9sZCwgbncpIHtcbiAgICBpZiAocG9zLmxpbmUgPT0gb2xkLmxpbmUpXG4gICAgICB7IHJldHVybiBQb3MobncubGluZSwgcG9zLmNoIC0gb2xkLmNoICsgbncuY2gpIH1cbiAgICBlbHNlXG4gICAgICB7IHJldHVybiBQb3MobncubGluZSArIChwb3MubGluZSAtIG9sZC5saW5lKSwgcG9zLmNoKSB9XG4gIH1cblxuICAvLyBVc2VkIGJ5IHJlcGxhY2VTZWxlY3Rpb25zIHRvIGFsbG93IG1vdmluZyB0aGUgc2VsZWN0aW9uIHRvIHRoZVxuICAvLyBzdGFydCBvciBhcm91bmQgdGhlIHJlcGxhY2VkIHRlc3QuIEhpbnQgbWF5IGJlIFwic3RhcnRcIiBvciBcImFyb3VuZFwiLlxuICBmdW5jdGlvbiBjb21wdXRlUmVwbGFjZWRTZWwoZG9jLCBjaGFuZ2VzLCBoaW50KSB7XG4gICAgdmFyIG91dCA9IFtdO1xuICAgIHZhciBvbGRQcmV2ID0gUG9zKGRvYy5maXJzdCwgMCksIG5ld1ByZXYgPSBvbGRQcmV2O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoYW5nZSA9IGNoYW5nZXNbaV07XG4gICAgICB2YXIgZnJvbSA9IG9mZnNldFBvcyhjaGFuZ2UuZnJvbSwgb2xkUHJldiwgbmV3UHJldik7XG4gICAgICB2YXIgdG8gPSBvZmZzZXRQb3MoY2hhbmdlRW5kKGNoYW5nZSksIG9sZFByZXYsIG5ld1ByZXYpO1xuICAgICAgb2xkUHJldiA9IGNoYW5nZS50bztcbiAgICAgIG5ld1ByZXYgPSB0bztcbiAgICAgIGlmIChoaW50ID09IFwiYXJvdW5kXCIpIHtcbiAgICAgICAgdmFyIHJhbmdlID0gZG9jLnNlbC5yYW5nZXNbaV0sIGludiA9IGNtcChyYW5nZS5oZWFkLCByYW5nZS5hbmNob3IpIDwgMDtcbiAgICAgICAgb3V0W2ldID0gbmV3IFJhbmdlKGludiA/IHRvIDogZnJvbSwgaW52ID8gZnJvbSA6IHRvKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dFtpXSA9IG5ldyBSYW5nZShmcm9tLCBmcm9tKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBTZWxlY3Rpb24ob3V0LCBkb2Muc2VsLnByaW1JbmRleClcbiAgfVxuXG4gIC8vIFVzZWQgdG8gZ2V0IHRoZSBlZGl0b3IgaW50byBhIGNvbnNpc3RlbnQgc3RhdGUgYWdhaW4gd2hlbiBvcHRpb25zIGNoYW5nZS5cblxuICBmdW5jdGlvbiBsb2FkTW9kZShjbSkge1xuICAgIGNtLmRvYy5tb2RlID0gZ2V0TW9kZShjbS5vcHRpb25zLCBjbS5kb2MubW9kZU9wdGlvbik7XG4gICAgcmVzZXRNb2RlU3RhdGUoY20pO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRNb2RlU3RhdGUoY20pIHtcbiAgICBjbS5kb2MuaXRlcihmdW5jdGlvbiAobGluZSkge1xuICAgICAgaWYgKGxpbmUuc3RhdGVBZnRlcikgeyBsaW5lLnN0YXRlQWZ0ZXIgPSBudWxsOyB9XG4gICAgICBpZiAobGluZS5zdHlsZXMpIHsgbGluZS5zdHlsZXMgPSBudWxsOyB9XG4gICAgfSk7XG4gICAgY20uZG9jLm1vZGVGcm9udGllciA9IGNtLmRvYy5oaWdobGlnaHRGcm9udGllciA9IGNtLmRvYy5maXJzdDtcbiAgICBzdGFydFdvcmtlcihjbSwgMTAwKTtcbiAgICBjbS5zdGF0ZS5tb2RlR2VuKys7XG4gICAgaWYgKGNtLmN1ck9wKSB7IHJlZ0NoYW5nZShjbSk7IH1cbiAgfVxuXG4gIC8vIERPQ1VNRU5UIERBVEEgU1RSVUNUVVJFXG5cbiAgLy8gQnkgZGVmYXVsdCwgdXBkYXRlcyB0aGF0IHN0YXJ0IGFuZCBlbmQgYXQgdGhlIGJlZ2lubmluZyBvZiBhIGxpbmVcbiAgLy8gYXJlIHRyZWF0ZWQgc3BlY2lhbGx5LCBpbiBvcmRlciB0byBtYWtlIHRoZSBhc3NvY2lhdGlvbiBvZiBsaW5lXG4gIC8vIHdpZGdldHMgYW5kIG1hcmtlciBlbGVtZW50cyB3aXRoIHRoZSB0ZXh0IGJlaGF2ZSBtb3JlIGludHVpdGl2ZS5cbiAgZnVuY3Rpb24gaXNXaG9sZUxpbmVVcGRhdGUoZG9jLCBjaGFuZ2UpIHtcbiAgICByZXR1cm4gY2hhbmdlLmZyb20uY2ggPT0gMCAmJiBjaGFuZ2UudG8uY2ggPT0gMCAmJiBsc3QoY2hhbmdlLnRleHQpID09IFwiXCIgJiZcbiAgICAgICghZG9jLmNtIHx8IGRvYy5jbS5vcHRpb25zLndob2xlTGluZVVwZGF0ZUJlZm9yZSlcbiAgfVxuXG4gIC8vIFBlcmZvcm0gYSBjaGFuZ2Ugb24gdGhlIGRvY3VtZW50IGRhdGEgc3RydWN0dXJlLlxuICBmdW5jdGlvbiB1cGRhdGVEb2MoZG9jLCBjaGFuZ2UsIG1hcmtlZFNwYW5zLCBlc3RpbWF0ZUhlaWdodCkge1xuICAgIGZ1bmN0aW9uIHNwYW5zRm9yKG4pIHtyZXR1cm4gbWFya2VkU3BhbnMgPyBtYXJrZWRTcGFuc1tuXSA6IG51bGx9XG4gICAgZnVuY3Rpb24gdXBkYXRlKGxpbmUsIHRleHQsIHNwYW5zKSB7XG4gICAgICB1cGRhdGVMaW5lKGxpbmUsIHRleHQsIHNwYW5zLCBlc3RpbWF0ZUhlaWdodCk7XG4gICAgICBzaWduYWxMYXRlcihsaW5lLCBcImNoYW5nZVwiLCBsaW5lLCBjaGFuZ2UpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBsaW5lc0ZvcihzdGFydCwgZW5kKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSlcbiAgICAgICAgeyByZXN1bHQucHVzaChuZXcgTGluZSh0ZXh0W2ldLCBzcGFuc0ZvcihpKSwgZXN0aW1hdGVIZWlnaHQpKTsgfVxuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH1cblxuICAgIHZhciBmcm9tID0gY2hhbmdlLmZyb20sIHRvID0gY2hhbmdlLnRvLCB0ZXh0ID0gY2hhbmdlLnRleHQ7XG4gICAgdmFyIGZpcnN0TGluZSA9IGdldExpbmUoZG9jLCBmcm9tLmxpbmUpLCBsYXN0TGluZSA9IGdldExpbmUoZG9jLCB0by5saW5lKTtcbiAgICB2YXIgbGFzdFRleHQgPSBsc3QodGV4dCksIGxhc3RTcGFucyA9IHNwYW5zRm9yKHRleHQubGVuZ3RoIC0gMSksIG5saW5lcyA9IHRvLmxpbmUgLSBmcm9tLmxpbmU7XG5cbiAgICAvLyBBZGp1c3QgdGhlIGxpbmUgc3RydWN0dXJlXG4gICAgaWYgKGNoYW5nZS5mdWxsKSB7XG4gICAgICBkb2MuaW5zZXJ0KDAsIGxpbmVzRm9yKDAsIHRleHQubGVuZ3RoKSk7XG4gICAgICBkb2MucmVtb3ZlKHRleHQubGVuZ3RoLCBkb2Muc2l6ZSAtIHRleHQubGVuZ3RoKTtcbiAgICB9IGVsc2UgaWYgKGlzV2hvbGVMaW5lVXBkYXRlKGRvYywgY2hhbmdlKSkge1xuICAgICAgLy8gVGhpcyBpcyBhIHdob2xlLWxpbmUgcmVwbGFjZS4gVHJlYXRlZCBzcGVjaWFsbHkgdG8gbWFrZVxuICAgICAgLy8gc3VyZSBsaW5lIG9iamVjdHMgbW92ZSB0aGUgd2F5IHRoZXkgYXJlIHN1cHBvc2VkIHRvLlxuICAgICAgdmFyIGFkZGVkID0gbGluZXNGb3IoMCwgdGV4dC5sZW5ndGggLSAxKTtcbiAgICAgIHVwZGF0ZShsYXN0TGluZSwgbGFzdExpbmUudGV4dCwgbGFzdFNwYW5zKTtcbiAgICAgIGlmIChubGluZXMpIHsgZG9jLnJlbW92ZShmcm9tLmxpbmUsIG5saW5lcyk7IH1cbiAgICAgIGlmIChhZGRlZC5sZW5ndGgpIHsgZG9jLmluc2VydChmcm9tLmxpbmUsIGFkZGVkKTsgfVxuICAgIH0gZWxzZSBpZiAoZmlyc3RMaW5lID09IGxhc3RMaW5lKSB7XG4gICAgICBpZiAodGV4dC5sZW5ndGggPT0gMSkge1xuICAgICAgICB1cGRhdGUoZmlyc3RMaW5lLCBmaXJzdExpbmUudGV4dC5zbGljZSgwLCBmcm9tLmNoKSArIGxhc3RUZXh0ICsgZmlyc3RMaW5lLnRleHQuc2xpY2UodG8uY2gpLCBsYXN0U3BhbnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGFkZGVkJDEgPSBsaW5lc0ZvcigxLCB0ZXh0Lmxlbmd0aCAtIDEpO1xuICAgICAgICBhZGRlZCQxLnB1c2gobmV3IExpbmUobGFzdFRleHQgKyBmaXJzdExpbmUudGV4dC5zbGljZSh0by5jaCksIGxhc3RTcGFucywgZXN0aW1hdGVIZWlnaHQpKTtcbiAgICAgICAgdXBkYXRlKGZpcnN0TGluZSwgZmlyc3RMaW5lLnRleHQuc2xpY2UoMCwgZnJvbS5jaCkgKyB0ZXh0WzBdLCBzcGFuc0ZvcigwKSk7XG4gICAgICAgIGRvYy5pbnNlcnQoZnJvbS5saW5lICsgMSwgYWRkZWQkMSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0ZXh0Lmxlbmd0aCA9PSAxKSB7XG4gICAgICB1cGRhdGUoZmlyc3RMaW5lLCBmaXJzdExpbmUudGV4dC5zbGljZSgwLCBmcm9tLmNoKSArIHRleHRbMF0gKyBsYXN0TGluZS50ZXh0LnNsaWNlKHRvLmNoKSwgc3BhbnNGb3IoMCkpO1xuICAgICAgZG9jLnJlbW92ZShmcm9tLmxpbmUgKyAxLCBubGluZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB1cGRhdGUoZmlyc3RMaW5lLCBmaXJzdExpbmUudGV4dC5zbGljZSgwLCBmcm9tLmNoKSArIHRleHRbMF0sIHNwYW5zRm9yKDApKTtcbiAgICAgIHVwZGF0ZShsYXN0TGluZSwgbGFzdFRleHQgKyBsYXN0TGluZS50ZXh0LnNsaWNlKHRvLmNoKSwgbGFzdFNwYW5zKTtcbiAgICAgIHZhciBhZGRlZCQyID0gbGluZXNGb3IoMSwgdGV4dC5sZW5ndGggLSAxKTtcbiAgICAgIGlmIChubGluZXMgPiAxKSB7IGRvYy5yZW1vdmUoZnJvbS5saW5lICsgMSwgbmxpbmVzIC0gMSk7IH1cbiAgICAgIGRvYy5pbnNlcnQoZnJvbS5saW5lICsgMSwgYWRkZWQkMik7XG4gICAgfVxuXG4gICAgc2lnbmFsTGF0ZXIoZG9jLCBcImNoYW5nZVwiLCBkb2MsIGNoYW5nZSk7XG4gIH1cblxuICAvLyBDYWxsIGYgZm9yIGFsbCBsaW5rZWQgZG9jdW1lbnRzLlxuICBmdW5jdGlvbiBsaW5rZWREb2NzKGRvYywgZiwgc2hhcmVkSGlzdE9ubHkpIHtcbiAgICBmdW5jdGlvbiBwcm9wYWdhdGUoZG9jLCBza2lwLCBzaGFyZWRIaXN0KSB7XG4gICAgICBpZiAoZG9jLmxpbmtlZCkgeyBmb3IgKHZhciBpID0gMDsgaSA8IGRvYy5saW5rZWQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHJlbCA9IGRvYy5saW5rZWRbaV07XG4gICAgICAgIGlmIChyZWwuZG9jID09IHNraXApIHsgY29udGludWUgfVxuICAgICAgICB2YXIgc2hhcmVkID0gc2hhcmVkSGlzdCAmJiByZWwuc2hhcmVkSGlzdDtcbiAgICAgICAgaWYgKHNoYXJlZEhpc3RPbmx5ICYmICFzaGFyZWQpIHsgY29udGludWUgfVxuICAgICAgICBmKHJlbC5kb2MsIHNoYXJlZCk7XG4gICAgICAgIHByb3BhZ2F0ZShyZWwuZG9jLCBkb2MsIHNoYXJlZCk7XG4gICAgICB9IH1cbiAgICB9XG4gICAgcHJvcGFnYXRlKGRvYywgbnVsbCwgdHJ1ZSk7XG4gIH1cblxuICAvLyBBdHRhY2ggYSBkb2N1bWVudCB0byBhbiBlZGl0b3IuXG4gIGZ1bmN0aW9uIGF0dGFjaERvYyhjbSwgZG9jKSB7XG4gICAgaWYgKGRvYy5jbSkgeyB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIGRvY3VtZW50IGlzIGFscmVhZHkgaW4gdXNlLlwiKSB9XG4gICAgY20uZG9jID0gZG9jO1xuICAgIGRvYy5jbSA9IGNtO1xuICAgIGVzdGltYXRlTGluZUhlaWdodHMoY20pO1xuICAgIGxvYWRNb2RlKGNtKTtcbiAgICBzZXREaXJlY3Rpb25DbGFzcyhjbSk7XG4gICAgaWYgKCFjbS5vcHRpb25zLmxpbmVXcmFwcGluZykgeyBmaW5kTWF4TGluZShjbSk7IH1cbiAgICBjbS5vcHRpb25zLm1vZGUgPSBkb2MubW9kZU9wdGlvbjtcbiAgICByZWdDaGFuZ2UoY20pO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0RGlyZWN0aW9uQ2xhc3MoY20pIHtcbiAgKGNtLmRvYy5kaXJlY3Rpb24gPT0gXCJydGxcIiA/IGFkZENsYXNzIDogcm1DbGFzcykoY20uZGlzcGxheS5saW5lRGl2LCBcIkNvZGVNaXJyb3ItcnRsXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZGlyZWN0aW9uQ2hhbmdlZChjbSkge1xuICAgIHJ1bkluT3AoY20sIGZ1bmN0aW9uICgpIHtcbiAgICAgIHNldERpcmVjdGlvbkNsYXNzKGNtKTtcbiAgICAgIHJlZ0NoYW5nZShjbSk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBIaXN0b3J5KHN0YXJ0R2VuKSB7XG4gICAgLy8gQXJyYXlzIG9mIGNoYW5nZSBldmVudHMgYW5kIHNlbGVjdGlvbnMuIERvaW5nIHNvbWV0aGluZyBhZGRzIGFuXG4gICAgLy8gZXZlbnQgdG8gZG9uZSBhbmQgY2xlYXJzIHVuZG8uIFVuZG9pbmcgbW92ZXMgZXZlbnRzIGZyb20gZG9uZVxuICAgIC8vIHRvIHVuZG9uZSwgcmVkb2luZyBtb3ZlcyB0aGVtIGluIHRoZSBvdGhlciBkaXJlY3Rpb24uXG4gICAgdGhpcy5kb25lID0gW107IHRoaXMudW5kb25lID0gW107XG4gICAgdGhpcy51bmRvRGVwdGggPSBJbmZpbml0eTtcbiAgICAvLyBVc2VkIHRvIHRyYWNrIHdoZW4gY2hhbmdlcyBjYW4gYmUgbWVyZ2VkIGludG8gYSBzaW5nbGUgdW5kb1xuICAgIC8vIGV2ZW50XG4gICAgdGhpcy5sYXN0TW9kVGltZSA9IHRoaXMubGFzdFNlbFRpbWUgPSAwO1xuICAgIHRoaXMubGFzdE9wID0gdGhpcy5sYXN0U2VsT3AgPSBudWxsO1xuICAgIHRoaXMubGFzdE9yaWdpbiA9IHRoaXMubGFzdFNlbE9yaWdpbiA9IG51bGw7XG4gICAgLy8gVXNlZCBieSB0aGUgaXNDbGVhbigpIG1ldGhvZFxuICAgIHRoaXMuZ2VuZXJhdGlvbiA9IHRoaXMubWF4R2VuZXJhdGlvbiA9IHN0YXJ0R2VuIHx8IDE7XG4gIH1cblxuICAvLyBDcmVhdGUgYSBoaXN0b3J5IGNoYW5nZSBldmVudCBmcm9tIGFuIHVwZGF0ZURvYy1zdHlsZSBjaGFuZ2VcbiAgLy8gb2JqZWN0LlxuICBmdW5jdGlvbiBoaXN0b3J5Q2hhbmdlRnJvbUNoYW5nZShkb2MsIGNoYW5nZSkge1xuICAgIHZhciBoaXN0Q2hhbmdlID0ge2Zyb206IGNvcHlQb3MoY2hhbmdlLmZyb20pLCB0bzogY2hhbmdlRW5kKGNoYW5nZSksIHRleHQ6IGdldEJldHdlZW4oZG9jLCBjaGFuZ2UuZnJvbSwgY2hhbmdlLnRvKX07XG4gICAgYXR0YWNoTG9jYWxTcGFucyhkb2MsIGhpc3RDaGFuZ2UsIGNoYW5nZS5mcm9tLmxpbmUsIGNoYW5nZS50by5saW5lICsgMSk7XG4gICAgbGlua2VkRG9jcyhkb2MsIGZ1bmN0aW9uIChkb2MpIHsgcmV0dXJuIGF0dGFjaExvY2FsU3BhbnMoZG9jLCBoaXN0Q2hhbmdlLCBjaGFuZ2UuZnJvbS5saW5lLCBjaGFuZ2UudG8ubGluZSArIDEpOyB9LCB0cnVlKTtcbiAgICByZXR1cm4gaGlzdENoYW5nZVxuICB9XG5cbiAgLy8gUG9wIGFsbCBzZWxlY3Rpb24gZXZlbnRzIG9mZiB0aGUgZW5kIG9mIGEgaGlzdG9yeSBhcnJheS4gU3RvcCBhdFxuICAvLyBhIGNoYW5nZSBldmVudC5cbiAgZnVuY3Rpb24gY2xlYXJTZWxlY3Rpb25FdmVudHMoYXJyYXkpIHtcbiAgICB3aGlsZSAoYXJyYXkubGVuZ3RoKSB7XG4gICAgICB2YXIgbGFzdCA9IGxzdChhcnJheSk7XG4gICAgICBpZiAobGFzdC5yYW5nZXMpIHsgYXJyYXkucG9wKCk7IH1cbiAgICAgIGVsc2UgeyBicmVhayB9XG4gICAgfVxuICB9XG5cbiAgLy8gRmluZCB0aGUgdG9wIGNoYW5nZSBldmVudCBpbiB0aGUgaGlzdG9yeS4gUG9wIG9mZiBzZWxlY3Rpb25cbiAgLy8gZXZlbnRzIHRoYXQgYXJlIGluIHRoZSB3YXkuXG4gIGZ1bmN0aW9uIGxhc3RDaGFuZ2VFdmVudChoaXN0LCBmb3JjZSkge1xuICAgIGlmIChmb3JjZSkge1xuICAgICAgY2xlYXJTZWxlY3Rpb25FdmVudHMoaGlzdC5kb25lKTtcbiAgICAgIHJldHVybiBsc3QoaGlzdC5kb25lKVxuICAgIH0gZWxzZSBpZiAoaGlzdC5kb25lLmxlbmd0aCAmJiAhbHN0KGhpc3QuZG9uZSkucmFuZ2VzKSB7XG4gICAgICByZXR1cm4gbHN0KGhpc3QuZG9uZSlcbiAgICB9IGVsc2UgaWYgKGhpc3QuZG9uZS5sZW5ndGggPiAxICYmICFoaXN0LmRvbmVbaGlzdC5kb25lLmxlbmd0aCAtIDJdLnJhbmdlcykge1xuICAgICAgaGlzdC5kb25lLnBvcCgpO1xuICAgICAgcmV0dXJuIGxzdChoaXN0LmRvbmUpXG4gICAgfVxuICB9XG5cbiAgLy8gUmVnaXN0ZXIgYSBjaGFuZ2UgaW4gdGhlIGhpc3RvcnkuIE1lcmdlcyBjaGFuZ2VzIHRoYXQgYXJlIHdpdGhpblxuICAvLyBhIHNpbmdsZSBvcGVyYXRpb24sIG9yIGFyZSBjbG9zZSB0b2dldGhlciB3aXRoIGFuIG9yaWdpbiB0aGF0XG4gIC8vIGFsbG93cyBtZXJnaW5nIChzdGFydGluZyB3aXRoIFwiK1wiKSBpbnRvIGEgc2luZ2xlIGV2ZW50LlxuICBmdW5jdGlvbiBhZGRDaGFuZ2VUb0hpc3RvcnkoZG9jLCBjaGFuZ2UsIHNlbEFmdGVyLCBvcElkKSB7XG4gICAgdmFyIGhpc3QgPSBkb2MuaGlzdG9yeTtcbiAgICBoaXN0LnVuZG9uZS5sZW5ndGggPSAwO1xuICAgIHZhciB0aW1lID0gK25ldyBEYXRlLCBjdXI7XG4gICAgdmFyIGxhc3Q7XG5cbiAgICBpZiAoKGhpc3QubGFzdE9wID09IG9wSWQgfHxcbiAgICAgICAgIGhpc3QubGFzdE9yaWdpbiA9PSBjaGFuZ2Uub3JpZ2luICYmIGNoYW5nZS5vcmlnaW4gJiZcbiAgICAgICAgICgoY2hhbmdlLm9yaWdpbi5jaGFyQXQoMCkgPT0gXCIrXCIgJiYgaGlzdC5sYXN0TW9kVGltZSA+IHRpbWUgLSAoZG9jLmNtID8gZG9jLmNtLm9wdGlvbnMuaGlzdG9yeUV2ZW50RGVsYXkgOiA1MDApKSB8fFxuICAgICAgICAgIGNoYW5nZS5vcmlnaW4uY2hhckF0KDApID09IFwiKlwiKSkgJiZcbiAgICAgICAgKGN1ciA9IGxhc3RDaGFuZ2VFdmVudChoaXN0LCBoaXN0Lmxhc3RPcCA9PSBvcElkKSkpIHtcbiAgICAgIC8vIE1lcmdlIHRoaXMgY2hhbmdlIGludG8gdGhlIGxhc3QgZXZlbnRcbiAgICAgIGxhc3QgPSBsc3QoY3VyLmNoYW5nZXMpO1xuICAgICAgaWYgKGNtcChjaGFuZ2UuZnJvbSwgY2hhbmdlLnRvKSA9PSAwICYmIGNtcChjaGFuZ2UuZnJvbSwgbGFzdC50bykgPT0gMCkge1xuICAgICAgICAvLyBPcHRpbWl6ZWQgY2FzZSBmb3Igc2ltcGxlIGluc2VydGlvbiAtLSBkb24ndCB3YW50IHRvIGFkZFxuICAgICAgICAvLyBuZXcgY2hhbmdlc2V0cyBmb3IgZXZlcnkgY2hhcmFjdGVyIHR5cGVkXG4gICAgICAgIGxhc3QudG8gPSBjaGFuZ2VFbmQoY2hhbmdlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEFkZCBuZXcgc3ViLWV2ZW50XG4gICAgICAgIGN1ci5jaGFuZ2VzLnB1c2goaGlzdG9yeUNoYW5nZUZyb21DaGFuZ2UoZG9jLCBjaGFuZ2UpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ2FuIG5vdCBiZSBtZXJnZWQsIHN0YXJ0IGEgbmV3IGV2ZW50LlxuICAgICAgdmFyIGJlZm9yZSA9IGxzdChoaXN0LmRvbmUpO1xuICAgICAgaWYgKCFiZWZvcmUgfHwgIWJlZm9yZS5yYW5nZXMpXG4gICAgICAgIHsgcHVzaFNlbGVjdGlvblRvSGlzdG9yeShkb2Muc2VsLCBoaXN0LmRvbmUpOyB9XG4gICAgICBjdXIgPSB7Y2hhbmdlczogW2hpc3RvcnlDaGFuZ2VGcm9tQ2hhbmdlKGRvYywgY2hhbmdlKV0sXG4gICAgICAgICAgICAgZ2VuZXJhdGlvbjogaGlzdC5nZW5lcmF0aW9ufTtcbiAgICAgIGhpc3QuZG9uZS5wdXNoKGN1cik7XG4gICAgICB3aGlsZSAoaGlzdC5kb25lLmxlbmd0aCA+IGhpc3QudW5kb0RlcHRoKSB7XG4gICAgICAgIGhpc3QuZG9uZS5zaGlmdCgpO1xuICAgICAgICBpZiAoIWhpc3QuZG9uZVswXS5yYW5nZXMpIHsgaGlzdC5kb25lLnNoaWZ0KCk7IH1cbiAgICAgIH1cbiAgICB9XG4gICAgaGlzdC5kb25lLnB1c2goc2VsQWZ0ZXIpO1xuICAgIGhpc3QuZ2VuZXJhdGlvbiA9ICsraGlzdC5tYXhHZW5lcmF0aW9uO1xuICAgIGhpc3QubGFzdE1vZFRpbWUgPSBoaXN0Lmxhc3RTZWxUaW1lID0gdGltZTtcbiAgICBoaXN0Lmxhc3RPcCA9IGhpc3QubGFzdFNlbE9wID0gb3BJZDtcbiAgICBoaXN0Lmxhc3RPcmlnaW4gPSBoaXN0Lmxhc3RTZWxPcmlnaW4gPSBjaGFuZ2Uub3JpZ2luO1xuXG4gICAgaWYgKCFsYXN0KSB7IHNpZ25hbChkb2MsIFwiaGlzdG9yeUFkZGVkXCIpOyB9XG4gIH1cblxuICBmdW5jdGlvbiBzZWxlY3Rpb25FdmVudENhbkJlTWVyZ2VkKGRvYywgb3JpZ2luLCBwcmV2LCBzZWwpIHtcbiAgICB2YXIgY2ggPSBvcmlnaW4uY2hhckF0KDApO1xuICAgIHJldHVybiBjaCA9PSBcIipcIiB8fFxuICAgICAgY2ggPT0gXCIrXCIgJiZcbiAgICAgIHByZXYucmFuZ2VzLmxlbmd0aCA9PSBzZWwucmFuZ2VzLmxlbmd0aCAmJlxuICAgICAgcHJldi5zb21ldGhpbmdTZWxlY3RlZCgpID09IHNlbC5zb21ldGhpbmdTZWxlY3RlZCgpICYmXG4gICAgICBuZXcgRGF0ZSAtIGRvYy5oaXN0b3J5Lmxhc3RTZWxUaW1lIDw9IChkb2MuY20gPyBkb2MuY20ub3B0aW9ucy5oaXN0b3J5RXZlbnREZWxheSA6IDUwMClcbiAgfVxuXG4gIC8vIENhbGxlZCB3aGVuZXZlciB0aGUgc2VsZWN0aW9uIGNoYW5nZXMsIHNldHMgdGhlIG5ldyBzZWxlY3Rpb24gYXNcbiAgLy8gdGhlIHBlbmRpbmcgc2VsZWN0aW9uIGluIHRoZSBoaXN0b3J5LCBhbmQgcHVzaGVzIHRoZSBvbGQgcGVuZGluZ1xuICAvLyBzZWxlY3Rpb24gaW50byB0aGUgJ2RvbmUnIGFycmF5IHdoZW4gaXQgd2FzIHNpZ25pZmljYW50bHlcbiAgLy8gZGlmZmVyZW50IChpbiBudW1iZXIgb2Ygc2VsZWN0ZWQgcmFuZ2VzLCBlbXB0aW5lc3MsIG9yIHRpbWUpLlxuICBmdW5jdGlvbiBhZGRTZWxlY3Rpb25Ub0hpc3RvcnkoZG9jLCBzZWwsIG9wSWQsIG9wdGlvbnMpIHtcbiAgICB2YXIgaGlzdCA9IGRvYy5oaXN0b3J5LCBvcmlnaW4gPSBvcHRpb25zICYmIG9wdGlvbnMub3JpZ2luO1xuXG4gICAgLy8gQSBuZXcgZXZlbnQgaXMgc3RhcnRlZCB3aGVuIHRoZSBwcmV2aW91cyBvcmlnaW4gZG9lcyBub3QgbWF0Y2hcbiAgICAvLyB0aGUgY3VycmVudCwgb3IgdGhlIG9yaWdpbnMgZG9uJ3QgYWxsb3cgbWF0Y2hpbmcuIE9yaWdpbnNcbiAgICAvLyBzdGFydGluZyB3aXRoICogYXJlIGFsd2F5cyBtZXJnZWQsIHRob3NlIHN0YXJ0aW5nIHdpdGggKyBhcmVcbiAgICAvLyBtZXJnZWQgd2hlbiBzaW1pbGFyIGFuZCBjbG9zZSB0b2dldGhlciBpbiB0aW1lLlxuICAgIGlmIChvcElkID09IGhpc3QubGFzdFNlbE9wIHx8XG4gICAgICAgIChvcmlnaW4gJiYgaGlzdC5sYXN0U2VsT3JpZ2luID09IG9yaWdpbiAmJlxuICAgICAgICAgKGhpc3QubGFzdE1vZFRpbWUgPT0gaGlzdC5sYXN0U2VsVGltZSAmJiBoaXN0Lmxhc3RPcmlnaW4gPT0gb3JpZ2luIHx8XG4gICAgICAgICAgc2VsZWN0aW9uRXZlbnRDYW5CZU1lcmdlZChkb2MsIG9yaWdpbiwgbHN0KGhpc3QuZG9uZSksIHNlbCkpKSlcbiAgICAgIHsgaGlzdC5kb25lW2hpc3QuZG9uZS5sZW5ndGggLSAxXSA9IHNlbDsgfVxuICAgIGVsc2VcbiAgICAgIHsgcHVzaFNlbGVjdGlvblRvSGlzdG9yeShzZWwsIGhpc3QuZG9uZSk7IH1cblxuICAgIGhpc3QubGFzdFNlbFRpbWUgPSArbmV3IERhdGU7XG4gICAgaGlzdC5sYXN0U2VsT3JpZ2luID0gb3JpZ2luO1xuICAgIGhpc3QubGFzdFNlbE9wID0gb3BJZDtcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmNsZWFyUmVkbyAhPT0gZmFsc2UpXG4gICAgICB7IGNsZWFyU2VsZWN0aW9uRXZlbnRzKGhpc3QudW5kb25lKTsgfVxuICB9XG5cbiAgZnVuY3Rpb24gcHVzaFNlbGVjdGlvblRvSGlzdG9yeShzZWwsIGRlc3QpIHtcbiAgICB2YXIgdG9wID0gbHN0KGRlc3QpO1xuICAgIGlmICghKHRvcCAmJiB0b3AucmFuZ2VzICYmIHRvcC5lcXVhbHMoc2VsKSkpXG4gICAgICB7IGRlc3QucHVzaChzZWwpOyB9XG4gIH1cblxuICAvLyBVc2VkIHRvIHN0b3JlIG1hcmtlZCBzcGFuIGluZm9ybWF0aW9uIGluIHRoZSBoaXN0b3J5LlxuICBmdW5jdGlvbiBhdHRhY2hMb2NhbFNwYW5zKGRvYywgY2hhbmdlLCBmcm9tLCB0bykge1xuICAgIHZhciBleGlzdGluZyA9IGNoYW5nZVtcInNwYW5zX1wiICsgZG9jLmlkXSwgbiA9IDA7XG4gICAgZG9jLml0ZXIoTWF0aC5tYXgoZG9jLmZpcnN0LCBmcm9tKSwgTWF0aC5taW4oZG9jLmZpcnN0ICsgZG9jLnNpemUsIHRvKSwgZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgIGlmIChsaW5lLm1hcmtlZFNwYW5zKVxuICAgICAgICB7IChleGlzdGluZyB8fCAoZXhpc3RpbmcgPSBjaGFuZ2VbXCJzcGFuc19cIiArIGRvYy5pZF0gPSB7fSkpW25dID0gbGluZS5tYXJrZWRTcGFuczsgfVxuICAgICAgKytuO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gV2hlbiB1bi9yZS1kb2luZyByZXN0b3JlcyB0ZXh0IGNvbnRhaW5pbmcgbWFya2VkIHNwYW5zLCB0aG9zZVxuICAvLyB0aGF0IGhhdmUgYmVlbiBleHBsaWNpdGx5IGNsZWFyZWQgc2hvdWxkIG5vdCBiZSByZXN0b3JlZC5cbiAgZnVuY3Rpb24gcmVtb3ZlQ2xlYXJlZFNwYW5zKHNwYW5zKSB7XG4gICAgaWYgKCFzcGFucykgeyByZXR1cm4gbnVsbCB9XG4gICAgdmFyIG91dDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNwYW5zLmxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAoc3BhbnNbaV0ubWFya2VyLmV4cGxpY2l0bHlDbGVhcmVkKSB7IGlmICghb3V0KSB7IG91dCA9IHNwYW5zLnNsaWNlKDAsIGkpOyB9IH1cbiAgICAgIGVsc2UgaWYgKG91dCkgeyBvdXQucHVzaChzcGFuc1tpXSk7IH1cbiAgICB9XG4gICAgcmV0dXJuICFvdXQgPyBzcGFucyA6IG91dC5sZW5ndGggPyBvdXQgOiBudWxsXG4gIH1cblxuICAvLyBSZXRyaWV2ZSBhbmQgZmlsdGVyIHRoZSBvbGQgbWFya2VkIHNwYW5zIHN0b3JlZCBpbiBhIGNoYW5nZSBldmVudC5cbiAgZnVuY3Rpb24gZ2V0T2xkU3BhbnMoZG9jLCBjaGFuZ2UpIHtcbiAgICB2YXIgZm91bmQgPSBjaGFuZ2VbXCJzcGFuc19cIiArIGRvYy5pZF07XG4gICAgaWYgKCFmb3VuZCkgeyByZXR1cm4gbnVsbCB9XG4gICAgdmFyIG53ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFuZ2UudGV4dC5sZW5ndGg7ICsraSlcbiAgICAgIHsgbncucHVzaChyZW1vdmVDbGVhcmVkU3BhbnMoZm91bmRbaV0pKTsgfVxuICAgIHJldHVybiBud1xuICB9XG5cbiAgLy8gVXNlZCBmb3IgdW4vcmUtZG9pbmcgY2hhbmdlcyBmcm9tIHRoZSBoaXN0b3J5LiBDb21iaW5lcyB0aGVcbiAgLy8gcmVzdWx0IG9mIGNvbXB1dGluZyB0aGUgZXhpc3Rpbmcgc3BhbnMgd2l0aCB0aGUgc2V0IG9mIHNwYW5zIHRoYXRcbiAgLy8gZXhpc3RlZCBpbiB0aGUgaGlzdG9yeSAoc28gdGhhdCBkZWxldGluZyBhcm91bmQgYSBzcGFuIGFuZCB0aGVuXG4gIC8vIHVuZG9pbmcgYnJpbmdzIGJhY2sgdGhlIHNwYW4pLlxuICBmdW5jdGlvbiBtZXJnZU9sZFNwYW5zKGRvYywgY2hhbmdlKSB7XG4gICAgdmFyIG9sZCA9IGdldE9sZFNwYW5zKGRvYywgY2hhbmdlKTtcbiAgICB2YXIgc3RyZXRjaGVkID0gc3RyZXRjaFNwYW5zT3ZlckNoYW5nZShkb2MsIGNoYW5nZSk7XG4gICAgaWYgKCFvbGQpIHsgcmV0dXJuIHN0cmV0Y2hlZCB9XG4gICAgaWYgKCFzdHJldGNoZWQpIHsgcmV0dXJuIG9sZCB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9sZC5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIG9sZEN1ciA9IG9sZFtpXSwgc3RyZXRjaEN1ciA9IHN0cmV0Y2hlZFtpXTtcbiAgICAgIGlmIChvbGRDdXIgJiYgc3RyZXRjaEN1cikge1xuICAgICAgICBzcGFuczogZm9yICh2YXIgaiA9IDA7IGogPCBzdHJldGNoQ3VyLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgdmFyIHNwYW4gPSBzdHJldGNoQ3VyW2pdO1xuICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgb2xkQ3VyLmxlbmd0aDsgKytrKVxuICAgICAgICAgICAgeyBpZiAob2xkQ3VyW2tdLm1hcmtlciA9PSBzcGFuLm1hcmtlcikgeyBjb250aW51ZSBzcGFucyB9IH1cbiAgICAgICAgICBvbGRDdXIucHVzaChzcGFuKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzdHJldGNoQ3VyKSB7XG4gICAgICAgIG9sZFtpXSA9IHN0cmV0Y2hDdXI7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvbGRcbiAgfVxuXG4gIC8vIFVzZWQgYm90aCB0byBwcm92aWRlIGEgSlNPTi1zYWZlIG9iamVjdCBpbiAuZ2V0SGlzdG9yeSwgYW5kLCB3aGVuXG4gIC8vIGRldGFjaGluZyBhIGRvY3VtZW50LCB0byBzcGxpdCB0aGUgaGlzdG9yeSBpbiB0d29cbiAgZnVuY3Rpb24gY29weUhpc3RvcnlBcnJheShldmVudHMsIG5ld0dyb3VwLCBpbnN0YW50aWF0ZVNlbCkge1xuICAgIHZhciBjb3B5ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBldmVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBldmVudCA9IGV2ZW50c1tpXTtcbiAgICAgIGlmIChldmVudC5yYW5nZXMpIHtcbiAgICAgICAgY29weS5wdXNoKGluc3RhbnRpYXRlU2VsID8gU2VsZWN0aW9uLnByb3RvdHlwZS5kZWVwQ29weS5jYWxsKGV2ZW50KSA6IGV2ZW50KTtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICAgIHZhciBjaGFuZ2VzID0gZXZlbnQuY2hhbmdlcywgbmV3Q2hhbmdlcyA9IFtdO1xuICAgICAgY29weS5wdXNoKHtjaGFuZ2VzOiBuZXdDaGFuZ2VzfSk7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNoYW5nZXMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgdmFyIGNoYW5nZSA9IGNoYW5nZXNbal0sIG0gPSAodm9pZCAwKTtcbiAgICAgICAgbmV3Q2hhbmdlcy5wdXNoKHtmcm9tOiBjaGFuZ2UuZnJvbSwgdG86IGNoYW5nZS50bywgdGV4dDogY2hhbmdlLnRleHR9KTtcbiAgICAgICAgaWYgKG5ld0dyb3VwKSB7IGZvciAodmFyIHByb3AgaW4gY2hhbmdlKSB7IGlmIChtID0gcHJvcC5tYXRjaCgvXnNwYW5zXyhcXGQrKSQvKSkge1xuICAgICAgICAgIGlmIChpbmRleE9mKG5ld0dyb3VwLCBOdW1iZXIobVsxXSkpID4gLTEpIHtcbiAgICAgICAgICAgIGxzdChuZXdDaGFuZ2VzKVtwcm9wXSA9IGNoYW5nZVtwcm9wXTtcbiAgICAgICAgICAgIGRlbGV0ZSBjaGFuZ2VbcHJvcF07XG4gICAgICAgICAgfVxuICAgICAgICB9IH0gfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29weVxuICB9XG5cbiAgLy8gVGhlICdzY3JvbGwnIHBhcmFtZXRlciBnaXZlbiB0byBtYW55IG9mIHRoZXNlIGluZGljYXRlZCB3aGV0aGVyXG4gIC8vIHRoZSBuZXcgY3Vyc29yIHBvc2l0aW9uIHNob3VsZCBiZSBzY3JvbGxlZCBpbnRvIHZpZXcgYWZ0ZXJcbiAgLy8gbW9kaWZ5aW5nIHRoZSBzZWxlY3Rpb24uXG5cbiAgLy8gSWYgc2hpZnQgaXMgaGVsZCBvciB0aGUgZXh0ZW5kIGZsYWcgaXMgc2V0LCBleHRlbmRzIGEgcmFuZ2UgdG9cbiAgLy8gaW5jbHVkZSBhIGdpdmVuIHBvc2l0aW9uIChhbmQgb3B0aW9uYWxseSBhIHNlY29uZCBwb3NpdGlvbikuXG4gIC8vIE90aGVyd2lzZSwgc2ltcGx5IHJldHVybnMgdGhlIHJhbmdlIGJldHdlZW4gdGhlIGdpdmVuIHBvc2l0aW9ucy5cbiAgLy8gVXNlZCBmb3IgY3Vyc29yIG1vdGlvbiBhbmQgc3VjaC5cbiAgZnVuY3Rpb24gZXh0ZW5kUmFuZ2UocmFuZ2UsIGhlYWQsIG90aGVyLCBleHRlbmQpIHtcbiAgICBpZiAoZXh0ZW5kKSB7XG4gICAgICB2YXIgYW5jaG9yID0gcmFuZ2UuYW5jaG9yO1xuICAgICAgaWYgKG90aGVyKSB7XG4gICAgICAgIHZhciBwb3NCZWZvcmUgPSBjbXAoaGVhZCwgYW5jaG9yKSA8IDA7XG4gICAgICAgIGlmIChwb3NCZWZvcmUgIT0gKGNtcChvdGhlciwgYW5jaG9yKSA8IDApKSB7XG4gICAgICAgICAgYW5jaG9yID0gaGVhZDtcbiAgICAgICAgICBoZWFkID0gb3RoZXI7XG4gICAgICAgIH0gZWxzZSBpZiAocG9zQmVmb3JlICE9IChjbXAoaGVhZCwgb3RoZXIpIDwgMCkpIHtcbiAgICAgICAgICBoZWFkID0gb3RoZXI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgUmFuZ2UoYW5jaG9yLCBoZWFkKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IFJhbmdlKG90aGVyIHx8IGhlYWQsIGhlYWQpXG4gICAgfVxuICB9XG5cbiAgLy8gRXh0ZW5kIHRoZSBwcmltYXJ5IHNlbGVjdGlvbiByYW5nZSwgZGlzY2FyZCB0aGUgcmVzdC5cbiAgZnVuY3Rpb24gZXh0ZW5kU2VsZWN0aW9uKGRvYywgaGVhZCwgb3RoZXIsIG9wdGlvbnMsIGV4dGVuZCkge1xuICAgIGlmIChleHRlbmQgPT0gbnVsbCkgeyBleHRlbmQgPSBkb2MuY20gJiYgKGRvYy5jbS5kaXNwbGF5LnNoaWZ0IHx8IGRvYy5leHRlbmQpOyB9XG4gICAgc2V0U2VsZWN0aW9uKGRvYywgbmV3IFNlbGVjdGlvbihbZXh0ZW5kUmFuZ2UoZG9jLnNlbC5wcmltYXJ5KCksIGhlYWQsIG90aGVyLCBleHRlbmQpXSwgMCksIG9wdGlvbnMpO1xuICB9XG5cbiAgLy8gRXh0ZW5kIGFsbCBzZWxlY3Rpb25zIChwb3MgaXMgYW4gYXJyYXkgb2Ygc2VsZWN0aW9ucyB3aXRoIGxlbmd0aFxuICAvLyBlcXVhbCB0aGUgbnVtYmVyIG9mIHNlbGVjdGlvbnMpXG4gIGZ1bmN0aW9uIGV4dGVuZFNlbGVjdGlvbnMoZG9jLCBoZWFkcywgb3B0aW9ucykge1xuICAgIHZhciBvdXQgPSBbXTtcbiAgICB2YXIgZXh0ZW5kID0gZG9jLmNtICYmIChkb2MuY20uZGlzcGxheS5zaGlmdCB8fCBkb2MuZXh0ZW5kKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRvYy5zZWwucmFuZ2VzLmxlbmd0aDsgaSsrKVxuICAgICAgeyBvdXRbaV0gPSBleHRlbmRSYW5nZShkb2Muc2VsLnJhbmdlc1tpXSwgaGVhZHNbaV0sIG51bGwsIGV4dGVuZCk7IH1cbiAgICB2YXIgbmV3U2VsID0gbm9ybWFsaXplU2VsZWN0aW9uKGRvYy5jbSwgb3V0LCBkb2Muc2VsLnByaW1JbmRleCk7XG4gICAgc2V0U2VsZWN0aW9uKGRvYywgbmV3U2VsLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8vIFVwZGF0ZXMgYSBzaW5nbGUgcmFuZ2UgaW4gdGhlIHNlbGVjdGlvbi5cbiAgZnVuY3Rpb24gcmVwbGFjZU9uZVNlbGVjdGlvbihkb2MsIGksIHJhbmdlLCBvcHRpb25zKSB7XG4gICAgdmFyIHJhbmdlcyA9IGRvYy5zZWwucmFuZ2VzLnNsaWNlKDApO1xuICAgIHJhbmdlc1tpXSA9IHJhbmdlO1xuICAgIHNldFNlbGVjdGlvbihkb2MsIG5vcm1hbGl6ZVNlbGVjdGlvbihkb2MuY20sIHJhbmdlcywgZG9jLnNlbC5wcmltSW5kZXgpLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8vIFJlc2V0IHRoZSBzZWxlY3Rpb24gdG8gYSBzaW5nbGUgcmFuZ2UuXG4gIGZ1bmN0aW9uIHNldFNpbXBsZVNlbGVjdGlvbihkb2MsIGFuY2hvciwgaGVhZCwgb3B0aW9ucykge1xuICAgIHNldFNlbGVjdGlvbihkb2MsIHNpbXBsZVNlbGVjdGlvbihhbmNob3IsIGhlYWQpLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8vIEdpdmUgYmVmb3JlU2VsZWN0aW9uQ2hhbmdlIGhhbmRsZXJzIGEgY2hhbmdlIHRvIGluZmx1ZW5jZSBhXG4gIC8vIHNlbGVjdGlvbiB1cGRhdGUuXG4gIGZ1bmN0aW9uIGZpbHRlclNlbGVjdGlvbkNoYW5nZShkb2MsIHNlbCwgb3B0aW9ucykge1xuICAgIHZhciBvYmogPSB7XG4gICAgICByYW5nZXM6IHNlbC5yYW5nZXMsXG4gICAgICB1cGRhdGU6IGZ1bmN0aW9uKHJhbmdlcykge1xuICAgICAgICB0aGlzLnJhbmdlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICB7IHRoaXMucmFuZ2VzW2ldID0gbmV3IFJhbmdlKGNsaXBQb3MoZG9jLCByYW5nZXNbaV0uYW5jaG9yKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGlwUG9zKGRvYywgcmFuZ2VzW2ldLmhlYWQpKTsgfVxuICAgICAgfSxcbiAgICAgIG9yaWdpbjogb3B0aW9ucyAmJiBvcHRpb25zLm9yaWdpblxuICAgIH07XG4gICAgc2lnbmFsKGRvYywgXCJiZWZvcmVTZWxlY3Rpb25DaGFuZ2VcIiwgZG9jLCBvYmopO1xuICAgIGlmIChkb2MuY20pIHsgc2lnbmFsKGRvYy5jbSwgXCJiZWZvcmVTZWxlY3Rpb25DaGFuZ2VcIiwgZG9jLmNtLCBvYmopOyB9XG4gICAgaWYgKG9iai5yYW5nZXMgIT0gc2VsLnJhbmdlcykgeyByZXR1cm4gbm9ybWFsaXplU2VsZWN0aW9uKGRvYy5jbSwgb2JqLnJhbmdlcywgb2JqLnJhbmdlcy5sZW5ndGggLSAxKSB9XG4gICAgZWxzZSB7IHJldHVybiBzZWwgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2V0U2VsZWN0aW9uUmVwbGFjZUhpc3RvcnkoZG9jLCBzZWwsIG9wdGlvbnMpIHtcbiAgICB2YXIgZG9uZSA9IGRvYy5oaXN0b3J5LmRvbmUsIGxhc3QgPSBsc3QoZG9uZSk7XG4gICAgaWYgKGxhc3QgJiYgbGFzdC5yYW5nZXMpIHtcbiAgICAgIGRvbmVbZG9uZS5sZW5ndGggLSAxXSA9IHNlbDtcbiAgICAgIHNldFNlbGVjdGlvbk5vVW5kbyhkb2MsIHNlbCwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldFNlbGVjdGlvbihkb2MsIHNlbCwgb3B0aW9ucyk7XG4gICAgfVxuICB9XG5cbiAgLy8gU2V0IGEgbmV3IHNlbGVjdGlvbi5cbiAgZnVuY3Rpb24gc2V0U2VsZWN0aW9uKGRvYywgc2VsLCBvcHRpb25zKSB7XG4gICAgc2V0U2VsZWN0aW9uTm9VbmRvKGRvYywgc2VsLCBvcHRpb25zKTtcbiAgICBhZGRTZWxlY3Rpb25Ub0hpc3RvcnkoZG9jLCBkb2Muc2VsLCBkb2MuY20gPyBkb2MuY20uY3VyT3AuaWQgOiBOYU4sIG9wdGlvbnMpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0U2VsZWN0aW9uTm9VbmRvKGRvYywgc2VsLCBvcHRpb25zKSB7XG4gICAgaWYgKGhhc0hhbmRsZXIoZG9jLCBcImJlZm9yZVNlbGVjdGlvbkNoYW5nZVwiKSB8fCBkb2MuY20gJiYgaGFzSGFuZGxlcihkb2MuY20sIFwiYmVmb3JlU2VsZWN0aW9uQ2hhbmdlXCIpKVxuICAgICAgeyBzZWwgPSBmaWx0ZXJTZWxlY3Rpb25DaGFuZ2UoZG9jLCBzZWwsIG9wdGlvbnMpOyB9XG5cbiAgICB2YXIgYmlhcyA9IG9wdGlvbnMgJiYgb3B0aW9ucy5iaWFzIHx8XG4gICAgICAoY21wKHNlbC5wcmltYXJ5KCkuaGVhZCwgZG9jLnNlbC5wcmltYXJ5KCkuaGVhZCkgPCAwID8gLTEgOiAxKTtcbiAgICBzZXRTZWxlY3Rpb25Jbm5lcihkb2MsIHNraXBBdG9taWNJblNlbGVjdGlvbihkb2MsIHNlbCwgYmlhcywgdHJ1ZSkpO1xuXG4gICAgaWYgKCEob3B0aW9ucyAmJiBvcHRpb25zLnNjcm9sbCA9PT0gZmFsc2UpICYmIGRvYy5jbSlcbiAgICAgIHsgZW5zdXJlQ3Vyc29yVmlzaWJsZShkb2MuY20pOyB9XG4gIH1cblxuICBmdW5jdGlvbiBzZXRTZWxlY3Rpb25Jbm5lcihkb2MsIHNlbCkge1xuICAgIGlmIChzZWwuZXF1YWxzKGRvYy5zZWwpKSB7IHJldHVybiB9XG5cbiAgICBkb2Muc2VsID0gc2VsO1xuXG4gICAgaWYgKGRvYy5jbSkge1xuICAgICAgZG9jLmNtLmN1ck9wLnVwZGF0ZUlucHV0ID0gMTtcbiAgICAgIGRvYy5jbS5jdXJPcC5zZWxlY3Rpb25DaGFuZ2VkID0gdHJ1ZTtcbiAgICAgIHNpZ25hbEN1cnNvckFjdGl2aXR5KGRvYy5jbSk7XG4gICAgfVxuICAgIHNpZ25hbExhdGVyKGRvYywgXCJjdXJzb3JBY3Rpdml0eVwiLCBkb2MpO1xuICB9XG5cbiAgLy8gVmVyaWZ5IHRoYXQgdGhlIHNlbGVjdGlvbiBkb2VzIG5vdCBwYXJ0aWFsbHkgc2VsZWN0IGFueSBhdG9taWNcbiAgLy8gbWFya2VkIHJhbmdlcy5cbiAgZnVuY3Rpb24gcmVDaGVja1NlbGVjdGlvbihkb2MpIHtcbiAgICBzZXRTZWxlY3Rpb25Jbm5lcihkb2MsIHNraXBBdG9taWNJblNlbGVjdGlvbihkb2MsIGRvYy5zZWwsIG51bGwsIGZhbHNlKSk7XG4gIH1cblxuICAvLyBSZXR1cm4gYSBzZWxlY3Rpb24gdGhhdCBkb2VzIG5vdCBwYXJ0aWFsbHkgc2VsZWN0IGFueSBhdG9taWNcbiAgLy8gcmFuZ2VzLlxuICBmdW5jdGlvbiBza2lwQXRvbWljSW5TZWxlY3Rpb24oZG9jLCBzZWwsIGJpYXMsIG1heUNsZWFyKSB7XG4gICAgdmFyIG91dDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbC5yYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciByYW5nZSA9IHNlbC5yYW5nZXNbaV07XG4gICAgICB2YXIgb2xkID0gc2VsLnJhbmdlcy5sZW5ndGggPT0gZG9jLnNlbC5yYW5nZXMubGVuZ3RoICYmIGRvYy5zZWwucmFuZ2VzW2ldO1xuICAgICAgdmFyIG5ld0FuY2hvciA9IHNraXBBdG9taWMoZG9jLCByYW5nZS5hbmNob3IsIG9sZCAmJiBvbGQuYW5jaG9yLCBiaWFzLCBtYXlDbGVhcik7XG4gICAgICB2YXIgbmV3SGVhZCA9IHNraXBBdG9taWMoZG9jLCByYW5nZS5oZWFkLCBvbGQgJiYgb2xkLmhlYWQsIGJpYXMsIG1heUNsZWFyKTtcbiAgICAgIGlmIChvdXQgfHwgbmV3QW5jaG9yICE9IHJhbmdlLmFuY2hvciB8fCBuZXdIZWFkICE9IHJhbmdlLmhlYWQpIHtcbiAgICAgICAgaWYgKCFvdXQpIHsgb3V0ID0gc2VsLnJhbmdlcy5zbGljZSgwLCBpKTsgfVxuICAgICAgICBvdXRbaV0gPSBuZXcgUmFuZ2UobmV3QW5jaG9yLCBuZXdIZWFkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dCA/IG5vcm1hbGl6ZVNlbGVjdGlvbihkb2MuY20sIG91dCwgc2VsLnByaW1JbmRleCkgOiBzZWxcbiAgfVxuXG4gIGZ1bmN0aW9uIHNraXBBdG9taWNJbm5lcihkb2MsIHBvcywgb2xkUG9zLCBkaXIsIG1heUNsZWFyKSB7XG4gICAgdmFyIGxpbmUgPSBnZXRMaW5lKGRvYywgcG9zLmxpbmUpO1xuICAgIGlmIChsaW5lLm1hcmtlZFNwYW5zKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgbGluZS5tYXJrZWRTcGFucy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIHNwID0gbGluZS5tYXJrZWRTcGFuc1tpXSwgbSA9IHNwLm1hcmtlcjtcblxuICAgICAgLy8gRGV0ZXJtaW5lIGlmIHdlIHNob3VsZCBwcmV2ZW50IHRoZSBjdXJzb3IgYmVpbmcgcGxhY2VkIHRvIHRoZSBsZWZ0L3JpZ2h0IG9mIGFuIGF0b21pYyBtYXJrZXJcbiAgICAgIC8vIEhpc3RvcmljYWxseSB0aGlzIHdhcyBkZXRlcm1pbmVkIHVzaW5nIHRoZSBpbmNsdXNpdmVMZWZ0L1JpZ2h0IG9wdGlvbiwgYnV0IHRoZSBuZXcgd2F5IHRvIGNvbnRyb2wgaXRcbiAgICAgIC8vIGlzIHdpdGggc2VsZWN0TGVmdC9SaWdodFxuICAgICAgdmFyIHByZXZlbnRDdXJzb3JMZWZ0ID0gKFwic2VsZWN0TGVmdFwiIGluIG0pID8gIW0uc2VsZWN0TGVmdCA6IG0uaW5jbHVzaXZlTGVmdDtcbiAgICAgIHZhciBwcmV2ZW50Q3Vyc29yUmlnaHQgPSAoXCJzZWxlY3RSaWdodFwiIGluIG0pID8gIW0uc2VsZWN0UmlnaHQgOiBtLmluY2x1c2l2ZVJpZ2h0O1xuXG4gICAgICBpZiAoKHNwLmZyb20gPT0gbnVsbCB8fCAocHJldmVudEN1cnNvckxlZnQgPyBzcC5mcm9tIDw9IHBvcy5jaCA6IHNwLmZyb20gPCBwb3MuY2gpKSAmJlxuICAgICAgICAgIChzcC50byA9PSBudWxsIHx8IChwcmV2ZW50Q3Vyc29yUmlnaHQgPyBzcC50byA+PSBwb3MuY2ggOiBzcC50byA+IHBvcy5jaCkpKSB7XG4gICAgICAgIGlmIChtYXlDbGVhcikge1xuICAgICAgICAgIHNpZ25hbChtLCBcImJlZm9yZUN1cnNvckVudGVyXCIpO1xuICAgICAgICAgIGlmIChtLmV4cGxpY2l0bHlDbGVhcmVkKSB7XG4gICAgICAgICAgICBpZiAoIWxpbmUubWFya2VkU3BhbnMpIHsgYnJlYWsgfVxuICAgICAgICAgICAgZWxzZSB7LS1pOyBjb250aW51ZX1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFtLmF0b21pYykgeyBjb250aW51ZSB9XG5cbiAgICAgICAgaWYgKG9sZFBvcykge1xuICAgICAgICAgIHZhciBuZWFyID0gbS5maW5kKGRpciA8IDAgPyAxIDogLTEpLCBkaWZmID0gKHZvaWQgMCk7XG4gICAgICAgICAgaWYgKGRpciA8IDAgPyBwcmV2ZW50Q3Vyc29yUmlnaHQgOiBwcmV2ZW50Q3Vyc29yTGVmdClcbiAgICAgICAgICAgIHsgbmVhciA9IG1vdmVQb3MoZG9jLCBuZWFyLCAtZGlyLCBuZWFyICYmIG5lYXIubGluZSA9PSBwb3MubGluZSA/IGxpbmUgOiBudWxsKTsgfVxuICAgICAgICAgIGlmIChuZWFyICYmIG5lYXIubGluZSA9PSBwb3MubGluZSAmJiAoZGlmZiA9IGNtcChuZWFyLCBvbGRQb3MpKSAmJiAoZGlyIDwgMCA/IGRpZmYgPCAwIDogZGlmZiA+IDApKVxuICAgICAgICAgICAgeyByZXR1cm4gc2tpcEF0b21pY0lubmVyKGRvYywgbmVhciwgcG9zLCBkaXIsIG1heUNsZWFyKSB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZmFyID0gbS5maW5kKGRpciA8IDAgPyAtMSA6IDEpO1xuICAgICAgICBpZiAoZGlyIDwgMCA/IHByZXZlbnRDdXJzb3JMZWZ0IDogcHJldmVudEN1cnNvclJpZ2h0KVxuICAgICAgICAgIHsgZmFyID0gbW92ZVBvcyhkb2MsIGZhciwgZGlyLCBmYXIubGluZSA9PSBwb3MubGluZSA/IGxpbmUgOiBudWxsKTsgfVxuICAgICAgICByZXR1cm4gZmFyID8gc2tpcEF0b21pY0lubmVyKGRvYywgZmFyLCBwb3MsIGRpciwgbWF5Q2xlYXIpIDogbnVsbFxuICAgICAgfVxuICAgIH0gfVxuICAgIHJldHVybiBwb3NcbiAgfVxuXG4gIC8vIEVuc3VyZSBhIGdpdmVuIHBvc2l0aW9uIGlzIG5vdCBpbnNpZGUgYW4gYXRvbWljIHJhbmdlLlxuICBmdW5jdGlvbiBza2lwQXRvbWljKGRvYywgcG9zLCBvbGRQb3MsIGJpYXMsIG1heUNsZWFyKSB7XG4gICAgdmFyIGRpciA9IGJpYXMgfHwgMTtcbiAgICB2YXIgZm91bmQgPSBza2lwQXRvbWljSW5uZXIoZG9jLCBwb3MsIG9sZFBvcywgZGlyLCBtYXlDbGVhcikgfHxcbiAgICAgICAgKCFtYXlDbGVhciAmJiBza2lwQXRvbWljSW5uZXIoZG9jLCBwb3MsIG9sZFBvcywgZGlyLCB0cnVlKSkgfHxcbiAgICAgICAgc2tpcEF0b21pY0lubmVyKGRvYywgcG9zLCBvbGRQb3MsIC1kaXIsIG1heUNsZWFyKSB8fFxuICAgICAgICAoIW1heUNsZWFyICYmIHNraXBBdG9taWNJbm5lcihkb2MsIHBvcywgb2xkUG9zLCAtZGlyLCB0cnVlKSk7XG4gICAgaWYgKCFmb3VuZCkge1xuICAgICAgZG9jLmNhbnRFZGl0ID0gdHJ1ZTtcbiAgICAgIHJldHVybiBQb3MoZG9jLmZpcnN0LCAwKVxuICAgIH1cbiAgICByZXR1cm4gZm91bmRcbiAgfVxuXG4gIGZ1bmN0aW9uIG1vdmVQb3MoZG9jLCBwb3MsIGRpciwgbGluZSkge1xuICAgIGlmIChkaXIgPCAwICYmIHBvcy5jaCA9PSAwKSB7XG4gICAgICBpZiAocG9zLmxpbmUgPiBkb2MuZmlyc3QpIHsgcmV0dXJuIGNsaXBQb3MoZG9jLCBQb3MocG9zLmxpbmUgLSAxKSkgfVxuICAgICAgZWxzZSB7IHJldHVybiBudWxsIH1cbiAgICB9IGVsc2UgaWYgKGRpciA+IDAgJiYgcG9zLmNoID09IChsaW5lIHx8IGdldExpbmUoZG9jLCBwb3MubGluZSkpLnRleHQubGVuZ3RoKSB7XG4gICAgICBpZiAocG9zLmxpbmUgPCBkb2MuZmlyc3QgKyBkb2Muc2l6ZSAtIDEpIHsgcmV0dXJuIFBvcyhwb3MubGluZSArIDEsIDApIH1cbiAgICAgIGVsc2UgeyByZXR1cm4gbnVsbCB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgUG9zKHBvcy5saW5lLCBwb3MuY2ggKyBkaXIpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2VsZWN0QWxsKGNtKSB7XG4gICAgY20uc2V0U2VsZWN0aW9uKFBvcyhjbS5maXJzdExpbmUoKSwgMCksIFBvcyhjbS5sYXN0TGluZSgpKSwgc2VsX2RvbnRTY3JvbGwpO1xuICB9XG5cbiAgLy8gVVBEQVRJTkdcblxuICAvLyBBbGxvdyBcImJlZm9yZUNoYW5nZVwiIGV2ZW50IGhhbmRsZXJzIHRvIGluZmx1ZW5jZSBhIGNoYW5nZVxuICBmdW5jdGlvbiBmaWx0ZXJDaGFuZ2UoZG9jLCBjaGFuZ2UsIHVwZGF0ZSkge1xuICAgIHZhciBvYmogPSB7XG4gICAgICBjYW5jZWxlZDogZmFsc2UsXG4gICAgICBmcm9tOiBjaGFuZ2UuZnJvbSxcbiAgICAgIHRvOiBjaGFuZ2UudG8sXG4gICAgICB0ZXh0OiBjaGFuZ2UudGV4dCxcbiAgICAgIG9yaWdpbjogY2hhbmdlLm9yaWdpbixcbiAgICAgIGNhbmNlbDogZnVuY3Rpb24gKCkgeyByZXR1cm4gb2JqLmNhbmNlbGVkID0gdHJ1ZTsgfVxuICAgIH07XG4gICAgaWYgKHVwZGF0ZSkgeyBvYmoudXBkYXRlID0gZnVuY3Rpb24gKGZyb20sIHRvLCB0ZXh0LCBvcmlnaW4pIHtcbiAgICAgIGlmIChmcm9tKSB7IG9iai5mcm9tID0gY2xpcFBvcyhkb2MsIGZyb20pOyB9XG4gICAgICBpZiAodG8pIHsgb2JqLnRvID0gY2xpcFBvcyhkb2MsIHRvKTsgfVxuICAgICAgaWYgKHRleHQpIHsgb2JqLnRleHQgPSB0ZXh0OyB9XG4gICAgICBpZiAob3JpZ2luICE9PSB1bmRlZmluZWQpIHsgb2JqLm9yaWdpbiA9IG9yaWdpbjsgfVxuICAgIH07IH1cbiAgICBzaWduYWwoZG9jLCBcImJlZm9yZUNoYW5nZVwiLCBkb2MsIG9iaik7XG4gICAgaWYgKGRvYy5jbSkgeyBzaWduYWwoZG9jLmNtLCBcImJlZm9yZUNoYW5nZVwiLCBkb2MuY20sIG9iaik7IH1cblxuICAgIGlmIChvYmouY2FuY2VsZWQpIHtcbiAgICAgIGlmIChkb2MuY20pIHsgZG9jLmNtLmN1ck9wLnVwZGF0ZUlucHV0ID0gMjsgfVxuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gICAgcmV0dXJuIHtmcm9tOiBvYmouZnJvbSwgdG86IG9iai50bywgdGV4dDogb2JqLnRleHQsIG9yaWdpbjogb2JqLm9yaWdpbn1cbiAgfVxuXG4gIC8vIEFwcGx5IGEgY2hhbmdlIHRvIGEgZG9jdW1lbnQsIGFuZCBhZGQgaXQgdG8gdGhlIGRvY3VtZW50J3NcbiAgLy8gaGlzdG9yeSwgYW5kIHByb3BhZ2F0aW5nIGl0IHRvIGFsbCBsaW5rZWQgZG9jdW1lbnRzLlxuICBmdW5jdGlvbiBtYWtlQ2hhbmdlKGRvYywgY2hhbmdlLCBpZ25vcmVSZWFkT25seSkge1xuICAgIGlmIChkb2MuY20pIHtcbiAgICAgIGlmICghZG9jLmNtLmN1ck9wKSB7IHJldHVybiBvcGVyYXRpb24oZG9jLmNtLCBtYWtlQ2hhbmdlKShkb2MsIGNoYW5nZSwgaWdub3JlUmVhZE9ubHkpIH1cbiAgICAgIGlmIChkb2MuY20uc3RhdGUuc3VwcHJlc3NFZGl0cykgeyByZXR1cm4gfVxuICAgIH1cblxuICAgIGlmIChoYXNIYW5kbGVyKGRvYywgXCJiZWZvcmVDaGFuZ2VcIikgfHwgZG9jLmNtICYmIGhhc0hhbmRsZXIoZG9jLmNtLCBcImJlZm9yZUNoYW5nZVwiKSkge1xuICAgICAgY2hhbmdlID0gZmlsdGVyQ2hhbmdlKGRvYywgY2hhbmdlLCB0cnVlKTtcbiAgICAgIGlmICghY2hhbmdlKSB7IHJldHVybiB9XG4gICAgfVxuXG4gICAgLy8gUG9zc2libHkgc3BsaXQgb3Igc3VwcHJlc3MgdGhlIHVwZGF0ZSBiYXNlZCBvbiB0aGUgcHJlc2VuY2VcbiAgICAvLyBvZiByZWFkLW9ubHkgc3BhbnMgaW4gaXRzIHJhbmdlLlxuICAgIHZhciBzcGxpdCA9IHNhd1JlYWRPbmx5U3BhbnMgJiYgIWlnbm9yZVJlYWRPbmx5ICYmIHJlbW92ZVJlYWRPbmx5UmFuZ2VzKGRvYywgY2hhbmdlLmZyb20sIGNoYW5nZS50byk7XG4gICAgaWYgKHNwbGl0KSB7XG4gICAgICBmb3IgKHZhciBpID0gc3BsaXQubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpXG4gICAgICAgIHsgbWFrZUNoYW5nZUlubmVyKGRvYywge2Zyb206IHNwbGl0W2ldLmZyb20sIHRvOiBzcGxpdFtpXS50bywgdGV4dDogaSA/IFtcIlwiXSA6IGNoYW5nZS50ZXh0LCBvcmlnaW46IGNoYW5nZS5vcmlnaW59KTsgfVxuICAgIH0gZWxzZSB7XG4gICAgICBtYWtlQ2hhbmdlSW5uZXIoZG9jLCBjaGFuZ2UpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1ha2VDaGFuZ2VJbm5lcihkb2MsIGNoYW5nZSkge1xuICAgIGlmIChjaGFuZ2UudGV4dC5sZW5ndGggPT0gMSAmJiBjaGFuZ2UudGV4dFswXSA9PSBcIlwiICYmIGNtcChjaGFuZ2UuZnJvbSwgY2hhbmdlLnRvKSA9PSAwKSB7IHJldHVybiB9XG4gICAgdmFyIHNlbEFmdGVyID0gY29tcHV0ZVNlbEFmdGVyQ2hhbmdlKGRvYywgY2hhbmdlKTtcbiAgICBhZGRDaGFuZ2VUb0hpc3RvcnkoZG9jLCBjaGFuZ2UsIHNlbEFmdGVyLCBkb2MuY20gPyBkb2MuY20uY3VyT3AuaWQgOiBOYU4pO1xuXG4gICAgbWFrZUNoYW5nZVNpbmdsZURvYyhkb2MsIGNoYW5nZSwgc2VsQWZ0ZXIsIHN0cmV0Y2hTcGFuc092ZXJDaGFuZ2UoZG9jLCBjaGFuZ2UpKTtcbiAgICB2YXIgcmViYXNlZCA9IFtdO1xuXG4gICAgbGlua2VkRG9jcyhkb2MsIGZ1bmN0aW9uIChkb2MsIHNoYXJlZEhpc3QpIHtcbiAgICAgIGlmICghc2hhcmVkSGlzdCAmJiBpbmRleE9mKHJlYmFzZWQsIGRvYy5oaXN0b3J5KSA9PSAtMSkge1xuICAgICAgICByZWJhc2VIaXN0KGRvYy5oaXN0b3J5LCBjaGFuZ2UpO1xuICAgICAgICByZWJhc2VkLnB1c2goZG9jLmhpc3RvcnkpO1xuICAgICAgfVxuICAgICAgbWFrZUNoYW5nZVNpbmdsZURvYyhkb2MsIGNoYW5nZSwgbnVsbCwgc3RyZXRjaFNwYW5zT3ZlckNoYW5nZShkb2MsIGNoYW5nZSkpO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gUmV2ZXJ0IGEgY2hhbmdlIHN0b3JlZCBpbiBhIGRvY3VtZW50J3MgaGlzdG9yeS5cbiAgZnVuY3Rpb24gbWFrZUNoYW5nZUZyb21IaXN0b3J5KGRvYywgdHlwZSwgYWxsb3dTZWxlY3Rpb25Pbmx5KSB7XG4gICAgdmFyIHN1cHByZXNzID0gZG9jLmNtICYmIGRvYy5jbS5zdGF0ZS5zdXBwcmVzc0VkaXRzO1xuICAgIGlmIChzdXBwcmVzcyAmJiAhYWxsb3dTZWxlY3Rpb25Pbmx5KSB7IHJldHVybiB9XG5cbiAgICB2YXIgaGlzdCA9IGRvYy5oaXN0b3J5LCBldmVudCwgc2VsQWZ0ZXIgPSBkb2Muc2VsO1xuICAgIHZhciBzb3VyY2UgPSB0eXBlID09IFwidW5kb1wiID8gaGlzdC5kb25lIDogaGlzdC51bmRvbmUsIGRlc3QgPSB0eXBlID09IFwidW5kb1wiID8gaGlzdC51bmRvbmUgOiBoaXN0LmRvbmU7XG5cbiAgICAvLyBWZXJpZnkgdGhhdCB0aGVyZSBpcyBhIHVzZWFibGUgZXZlbnQgKHNvIHRoYXQgY3RybC16IHdvbid0XG4gICAgLy8gbmVlZGxlc3NseSBjbGVhciBzZWxlY3Rpb24gZXZlbnRzKVxuICAgIHZhciBpID0gMDtcbiAgICBmb3IgKDsgaSA8IHNvdXJjZS5sZW5ndGg7IGkrKykge1xuICAgICAgZXZlbnQgPSBzb3VyY2VbaV07XG4gICAgICBpZiAoYWxsb3dTZWxlY3Rpb25Pbmx5ID8gZXZlbnQucmFuZ2VzICYmICFldmVudC5lcXVhbHMoZG9jLnNlbCkgOiAhZXZlbnQucmFuZ2VzKVxuICAgICAgICB7IGJyZWFrIH1cbiAgICB9XG4gICAgaWYgKGkgPT0gc291cmNlLmxlbmd0aCkgeyByZXR1cm4gfVxuICAgIGhpc3QubGFzdE9yaWdpbiA9IGhpc3QubGFzdFNlbE9yaWdpbiA9IG51bGw7XG5cbiAgICBmb3IgKDs7KSB7XG4gICAgICBldmVudCA9IHNvdXJjZS5wb3AoKTtcbiAgICAgIGlmIChldmVudC5yYW5nZXMpIHtcbiAgICAgICAgcHVzaFNlbGVjdGlvblRvSGlzdG9yeShldmVudCwgZGVzdCk7XG4gICAgICAgIGlmIChhbGxvd1NlbGVjdGlvbk9ubHkgJiYgIWV2ZW50LmVxdWFscyhkb2Muc2VsKSkge1xuICAgICAgICAgIHNldFNlbGVjdGlvbihkb2MsIGV2ZW50LCB7Y2xlYXJSZWRvOiBmYWxzZX0pO1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIHNlbEFmdGVyID0gZXZlbnQ7XG4gICAgICB9IGVsc2UgaWYgKHN1cHByZXNzKSB7XG4gICAgICAgIHNvdXJjZS5wdXNoKGV2ZW50KTtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9IGVsc2UgeyBicmVhayB9XG4gICAgfVxuXG4gICAgLy8gQnVpbGQgdXAgYSByZXZlcnNlIGNoYW5nZSBvYmplY3QgdG8gYWRkIHRvIHRoZSBvcHBvc2l0ZSBoaXN0b3J5XG4gICAgLy8gc3RhY2sgKHJlZG8gd2hlbiB1bmRvaW5nLCBhbmQgdmljZSB2ZXJzYSkuXG4gICAgdmFyIGFudGlDaGFuZ2VzID0gW107XG4gICAgcHVzaFNlbGVjdGlvblRvSGlzdG9yeShzZWxBZnRlciwgZGVzdCk7XG4gICAgZGVzdC5wdXNoKHtjaGFuZ2VzOiBhbnRpQ2hhbmdlcywgZ2VuZXJhdGlvbjogaGlzdC5nZW5lcmF0aW9ufSk7XG4gICAgaGlzdC5nZW5lcmF0aW9uID0gZXZlbnQuZ2VuZXJhdGlvbiB8fCArK2hpc3QubWF4R2VuZXJhdGlvbjtcblxuICAgIHZhciBmaWx0ZXIgPSBoYXNIYW5kbGVyKGRvYywgXCJiZWZvcmVDaGFuZ2VcIikgfHwgZG9jLmNtICYmIGhhc0hhbmRsZXIoZG9jLmNtLCBcImJlZm9yZUNoYW5nZVwiKTtcblxuICAgIHZhciBsb29wID0gZnVuY3Rpb24gKCBpICkge1xuICAgICAgdmFyIGNoYW5nZSA9IGV2ZW50LmNoYW5nZXNbaV07XG4gICAgICBjaGFuZ2Uub3JpZ2luID0gdHlwZTtcbiAgICAgIGlmIChmaWx0ZXIgJiYgIWZpbHRlckNoYW5nZShkb2MsIGNoYW5nZSwgZmFsc2UpKSB7XG4gICAgICAgIHNvdXJjZS5sZW5ndGggPSAwO1xuICAgICAgICByZXR1cm4ge31cbiAgICAgIH1cblxuICAgICAgYW50aUNoYW5nZXMucHVzaChoaXN0b3J5Q2hhbmdlRnJvbUNoYW5nZShkb2MsIGNoYW5nZSkpO1xuXG4gICAgICB2YXIgYWZ0ZXIgPSBpID8gY29tcHV0ZVNlbEFmdGVyQ2hhbmdlKGRvYywgY2hhbmdlKSA6IGxzdChzb3VyY2UpO1xuICAgICAgbWFrZUNoYW5nZVNpbmdsZURvYyhkb2MsIGNoYW5nZSwgYWZ0ZXIsIG1lcmdlT2xkU3BhbnMoZG9jLCBjaGFuZ2UpKTtcbiAgICAgIGlmICghaSAmJiBkb2MuY20pIHsgZG9jLmNtLnNjcm9sbEludG9WaWV3KHtmcm9tOiBjaGFuZ2UuZnJvbSwgdG86IGNoYW5nZUVuZChjaGFuZ2UpfSk7IH1cbiAgICAgIHZhciByZWJhc2VkID0gW107XG5cbiAgICAgIC8vIFByb3BhZ2F0ZSB0byB0aGUgbGlua2VkIGRvY3VtZW50c1xuICAgICAgbGlua2VkRG9jcyhkb2MsIGZ1bmN0aW9uIChkb2MsIHNoYXJlZEhpc3QpIHtcbiAgICAgICAgaWYgKCFzaGFyZWRIaXN0ICYmIGluZGV4T2YocmViYXNlZCwgZG9jLmhpc3RvcnkpID09IC0xKSB7XG4gICAgICAgICAgcmViYXNlSGlzdChkb2MuaGlzdG9yeSwgY2hhbmdlKTtcbiAgICAgICAgICByZWJhc2VkLnB1c2goZG9jLmhpc3RvcnkpO1xuICAgICAgICB9XG4gICAgICAgIG1ha2VDaGFuZ2VTaW5nbGVEb2MoZG9jLCBjaGFuZ2UsIG51bGwsIG1lcmdlT2xkU3BhbnMoZG9jLCBjaGFuZ2UpKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBmb3IgKHZhciBpJDEgPSBldmVudC5jaGFuZ2VzLmxlbmd0aCAtIDE7IGkkMSA+PSAwOyAtLWkkMSkge1xuICAgICAgdmFyIHJldHVybmVkID0gbG9vcCggaSQxICk7XG5cbiAgICAgIGlmICggcmV0dXJuZWQgKSByZXR1cm4gcmV0dXJuZWQudjtcbiAgICB9XG4gIH1cblxuICAvLyBTdWItdmlld3MgbmVlZCB0aGVpciBsaW5lIG51bWJlcnMgc2hpZnRlZCB3aGVuIHRleHQgaXMgYWRkZWRcbiAgLy8gYWJvdmUgb3IgYmVsb3cgdGhlbSBpbiB0aGUgcGFyZW50IGRvY3VtZW50LlxuICBmdW5jdGlvbiBzaGlmdERvYyhkb2MsIGRpc3RhbmNlKSB7XG4gICAgaWYgKGRpc3RhbmNlID09IDApIHsgcmV0dXJuIH1cbiAgICBkb2MuZmlyc3QgKz0gZGlzdGFuY2U7XG4gICAgZG9jLnNlbCA9IG5ldyBTZWxlY3Rpb24obWFwKGRvYy5zZWwucmFuZ2VzLCBmdW5jdGlvbiAocmFuZ2UpIHsgcmV0dXJuIG5ldyBSYW5nZShcbiAgICAgIFBvcyhyYW5nZS5hbmNob3IubGluZSArIGRpc3RhbmNlLCByYW5nZS5hbmNob3IuY2gpLFxuICAgICAgUG9zKHJhbmdlLmhlYWQubGluZSArIGRpc3RhbmNlLCByYW5nZS5oZWFkLmNoKVxuICAgICk7IH0pLCBkb2Muc2VsLnByaW1JbmRleCk7XG4gICAgaWYgKGRvYy5jbSkge1xuICAgICAgcmVnQ2hhbmdlKGRvYy5jbSwgZG9jLmZpcnN0LCBkb2MuZmlyc3QgLSBkaXN0YW5jZSwgZGlzdGFuY2UpO1xuICAgICAgZm9yICh2YXIgZCA9IGRvYy5jbS5kaXNwbGF5LCBsID0gZC52aWV3RnJvbTsgbCA8IGQudmlld1RvOyBsKyspXG4gICAgICAgIHsgcmVnTGluZUNoYW5nZShkb2MuY20sIGwsIFwiZ3V0dGVyXCIpOyB9XG4gICAgfVxuICB9XG5cbiAgLy8gTW9yZSBsb3dlci1sZXZlbCBjaGFuZ2UgZnVuY3Rpb24sIGhhbmRsaW5nIG9ubHkgYSBzaW5nbGUgZG9jdW1lbnRcbiAgLy8gKG5vdCBsaW5rZWQgb25lcykuXG4gIGZ1bmN0aW9uIG1ha2VDaGFuZ2VTaW5nbGVEb2MoZG9jLCBjaGFuZ2UsIHNlbEFmdGVyLCBzcGFucykge1xuICAgIGlmIChkb2MuY20gJiYgIWRvYy5jbS5jdXJPcClcbiAgICAgIHsgcmV0dXJuIG9wZXJhdGlvbihkb2MuY20sIG1ha2VDaGFuZ2VTaW5nbGVEb2MpKGRvYywgY2hhbmdlLCBzZWxBZnRlciwgc3BhbnMpIH1cblxuICAgIGlmIChjaGFuZ2UudG8ubGluZSA8IGRvYy5maXJzdCkge1xuICAgICAgc2hpZnREb2MoZG9jLCBjaGFuZ2UudGV4dC5sZW5ndGggLSAxIC0gKGNoYW5nZS50by5saW5lIC0gY2hhbmdlLmZyb20ubGluZSkpO1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGlmIChjaGFuZ2UuZnJvbS5saW5lID4gZG9jLmxhc3RMaW5lKCkpIHsgcmV0dXJuIH1cblxuICAgIC8vIENsaXAgdGhlIGNoYW5nZSB0byB0aGUgc2l6ZSBvZiB0aGlzIGRvY1xuICAgIGlmIChjaGFuZ2UuZnJvbS5saW5lIDwgZG9jLmZpcnN0KSB7XG4gICAgICB2YXIgc2hpZnQgPSBjaGFuZ2UudGV4dC5sZW5ndGggLSAxIC0gKGRvYy5maXJzdCAtIGNoYW5nZS5mcm9tLmxpbmUpO1xuICAgICAgc2hpZnREb2MoZG9jLCBzaGlmdCk7XG4gICAgICBjaGFuZ2UgPSB7ZnJvbTogUG9zKGRvYy5maXJzdCwgMCksIHRvOiBQb3MoY2hhbmdlLnRvLmxpbmUgKyBzaGlmdCwgY2hhbmdlLnRvLmNoKSxcbiAgICAgICAgICAgICAgICB0ZXh0OiBbbHN0KGNoYW5nZS50ZXh0KV0sIG9yaWdpbjogY2hhbmdlLm9yaWdpbn07XG4gICAgfVxuICAgIHZhciBsYXN0ID0gZG9jLmxhc3RMaW5lKCk7XG4gICAgaWYgKGNoYW5nZS50by5saW5lID4gbGFzdCkge1xuICAgICAgY2hhbmdlID0ge2Zyb206IGNoYW5nZS5mcm9tLCB0bzogUG9zKGxhc3QsIGdldExpbmUoZG9jLCBsYXN0KS50ZXh0Lmxlbmd0aCksXG4gICAgICAgICAgICAgICAgdGV4dDogW2NoYW5nZS50ZXh0WzBdXSwgb3JpZ2luOiBjaGFuZ2Uub3JpZ2lufTtcbiAgICB9XG5cbiAgICBjaGFuZ2UucmVtb3ZlZCA9IGdldEJldHdlZW4oZG9jLCBjaGFuZ2UuZnJvbSwgY2hhbmdlLnRvKTtcblxuICAgIGlmICghc2VsQWZ0ZXIpIHsgc2VsQWZ0ZXIgPSBjb21wdXRlU2VsQWZ0ZXJDaGFuZ2UoZG9jLCBjaGFuZ2UpOyB9XG4gICAgaWYgKGRvYy5jbSkgeyBtYWtlQ2hhbmdlU2luZ2xlRG9jSW5FZGl0b3IoZG9jLmNtLCBjaGFuZ2UsIHNwYW5zKTsgfVxuICAgIGVsc2UgeyB1cGRhdGVEb2MoZG9jLCBjaGFuZ2UsIHNwYW5zKTsgfVxuICAgIHNldFNlbGVjdGlvbk5vVW5kbyhkb2MsIHNlbEFmdGVyLCBzZWxfZG9udFNjcm9sbCk7XG5cbiAgICBpZiAoZG9jLmNhbnRFZGl0ICYmIHNraXBBdG9taWMoZG9jLCBQb3MoZG9jLmZpcnN0TGluZSgpLCAwKSkpXG4gICAgICB7IGRvYy5jYW50RWRpdCA9IGZhbHNlOyB9XG4gIH1cblxuICAvLyBIYW5kbGUgdGhlIGludGVyYWN0aW9uIG9mIGEgY2hhbmdlIHRvIGEgZG9jdW1lbnQgd2l0aCB0aGUgZWRpdG9yXG4gIC8vIHRoYXQgdGhpcyBkb2N1bWVudCBpcyBwYXJ0IG9mLlxuICBmdW5jdGlvbiBtYWtlQ2hhbmdlU2luZ2xlRG9jSW5FZGl0b3IoY20sIGNoYW5nZSwgc3BhbnMpIHtcbiAgICB2YXIgZG9jID0gY20uZG9jLCBkaXNwbGF5ID0gY20uZGlzcGxheSwgZnJvbSA9IGNoYW5nZS5mcm9tLCB0byA9IGNoYW5nZS50bztcblxuICAgIHZhciByZWNvbXB1dGVNYXhMZW5ndGggPSBmYWxzZSwgY2hlY2tXaWR0aFN0YXJ0ID0gZnJvbS5saW5lO1xuICAgIGlmICghY20ub3B0aW9ucy5saW5lV3JhcHBpbmcpIHtcbiAgICAgIGNoZWNrV2lkdGhTdGFydCA9IGxpbmVObyh2aXN1YWxMaW5lKGdldExpbmUoZG9jLCBmcm9tLmxpbmUpKSk7XG4gICAgICBkb2MuaXRlcihjaGVja1dpZHRoU3RhcnQsIHRvLmxpbmUgKyAxLCBmdW5jdGlvbiAobGluZSkge1xuICAgICAgICBpZiAobGluZSA9PSBkaXNwbGF5Lm1heExpbmUpIHtcbiAgICAgICAgICByZWNvbXB1dGVNYXhMZW5ndGggPSB0cnVlO1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChkb2Muc2VsLmNvbnRhaW5zKGNoYW5nZS5mcm9tLCBjaGFuZ2UudG8pID4gLTEpXG4gICAgICB7IHNpZ25hbEN1cnNvckFjdGl2aXR5KGNtKTsgfVxuXG4gICAgdXBkYXRlRG9jKGRvYywgY2hhbmdlLCBzcGFucywgZXN0aW1hdGVIZWlnaHQoY20pKTtcblxuICAgIGlmICghY20ub3B0aW9ucy5saW5lV3JhcHBpbmcpIHtcbiAgICAgIGRvYy5pdGVyKGNoZWNrV2lkdGhTdGFydCwgZnJvbS5saW5lICsgY2hhbmdlLnRleHQubGVuZ3RoLCBmdW5jdGlvbiAobGluZSkge1xuICAgICAgICB2YXIgbGVuID0gbGluZUxlbmd0aChsaW5lKTtcbiAgICAgICAgaWYgKGxlbiA+IGRpc3BsYXkubWF4TGluZUxlbmd0aCkge1xuICAgICAgICAgIGRpc3BsYXkubWF4TGluZSA9IGxpbmU7XG4gICAgICAgICAgZGlzcGxheS5tYXhMaW5lTGVuZ3RoID0gbGVuO1xuICAgICAgICAgIGRpc3BsYXkubWF4TGluZUNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgIHJlY29tcHV0ZU1heExlbmd0aCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmIChyZWNvbXB1dGVNYXhMZW5ndGgpIHsgY20uY3VyT3AudXBkYXRlTWF4TGluZSA9IHRydWU7IH1cbiAgICB9XG5cbiAgICByZXRyZWF0RnJvbnRpZXIoZG9jLCBmcm9tLmxpbmUpO1xuICAgIHN0YXJ0V29ya2VyKGNtLCA0MDApO1xuXG4gICAgdmFyIGxlbmRpZmYgPSBjaGFuZ2UudGV4dC5sZW5ndGggLSAodG8ubGluZSAtIGZyb20ubGluZSkgLSAxO1xuICAgIC8vIFJlbWVtYmVyIHRoYXQgdGhlc2UgbGluZXMgY2hhbmdlZCwgZm9yIHVwZGF0aW5nIHRoZSBkaXNwbGF5XG4gICAgaWYgKGNoYW5nZS5mdWxsKVxuICAgICAgeyByZWdDaGFuZ2UoY20pOyB9XG4gICAgZWxzZSBpZiAoZnJvbS5saW5lID09IHRvLmxpbmUgJiYgY2hhbmdlLnRleHQubGVuZ3RoID09IDEgJiYgIWlzV2hvbGVMaW5lVXBkYXRlKGNtLmRvYywgY2hhbmdlKSlcbiAgICAgIHsgcmVnTGluZUNoYW5nZShjbSwgZnJvbS5saW5lLCBcInRleHRcIik7IH1cbiAgICBlbHNlXG4gICAgICB7IHJlZ0NoYW5nZShjbSwgZnJvbS5saW5lLCB0by5saW5lICsgMSwgbGVuZGlmZik7IH1cblxuICAgIHZhciBjaGFuZ2VzSGFuZGxlciA9IGhhc0hhbmRsZXIoY20sIFwiY2hhbmdlc1wiKSwgY2hhbmdlSGFuZGxlciA9IGhhc0hhbmRsZXIoY20sIFwiY2hhbmdlXCIpO1xuICAgIGlmIChjaGFuZ2VIYW5kbGVyIHx8IGNoYW5nZXNIYW5kbGVyKSB7XG4gICAgICB2YXIgb2JqID0ge1xuICAgICAgICBmcm9tOiBmcm9tLCB0bzogdG8sXG4gICAgICAgIHRleHQ6IGNoYW5nZS50ZXh0LFxuICAgICAgICByZW1vdmVkOiBjaGFuZ2UucmVtb3ZlZCxcbiAgICAgICAgb3JpZ2luOiBjaGFuZ2Uub3JpZ2luXG4gICAgICB9O1xuICAgICAgaWYgKGNoYW5nZUhhbmRsZXIpIHsgc2lnbmFsTGF0ZXIoY20sIFwiY2hhbmdlXCIsIGNtLCBvYmopOyB9XG4gICAgICBpZiAoY2hhbmdlc0hhbmRsZXIpIHsgKGNtLmN1ck9wLmNoYW5nZU9ianMgfHwgKGNtLmN1ck9wLmNoYW5nZU9ianMgPSBbXSkpLnB1c2gob2JqKTsgfVxuICAgIH1cbiAgICBjbS5kaXNwbGF5LnNlbEZvckNvbnRleHRNZW51ID0gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlcGxhY2VSYW5nZShkb2MsIGNvZGUsIGZyb20sIHRvLCBvcmlnaW4pIHtcbiAgICB2YXIgYXNzaWduO1xuXG4gICAgaWYgKCF0bykgeyB0byA9IGZyb207IH1cbiAgICBpZiAoY21wKHRvLCBmcm9tKSA8IDApIHsgKGFzc2lnbiA9IFt0bywgZnJvbV0sIGZyb20gPSBhc3NpZ25bMF0sIHRvID0gYXNzaWduWzFdKTsgfVxuICAgIGlmICh0eXBlb2YgY29kZSA9PSBcInN0cmluZ1wiKSB7IGNvZGUgPSBkb2Muc3BsaXRMaW5lcyhjb2RlKTsgfVxuICAgIG1ha2VDaGFuZ2UoZG9jLCB7ZnJvbTogZnJvbSwgdG86IHRvLCB0ZXh0OiBjb2RlLCBvcmlnaW46IG9yaWdpbn0pO1xuICB9XG5cbiAgLy8gUmViYXNpbmcvcmVzZXR0aW5nIGhpc3RvcnkgdG8gZGVhbCB3aXRoIGV4dGVybmFsbHktc291cmNlZCBjaGFuZ2VzXG5cbiAgZnVuY3Rpb24gcmViYXNlSGlzdFNlbFNpbmdsZShwb3MsIGZyb20sIHRvLCBkaWZmKSB7XG4gICAgaWYgKHRvIDwgcG9zLmxpbmUpIHtcbiAgICAgIHBvcy5saW5lICs9IGRpZmY7XG4gICAgfSBlbHNlIGlmIChmcm9tIDwgcG9zLmxpbmUpIHtcbiAgICAgIHBvcy5saW5lID0gZnJvbTtcbiAgICAgIHBvcy5jaCA9IDA7XG4gICAgfVxuICB9XG5cbiAgLy8gVHJpZXMgdG8gcmViYXNlIGFuIGFycmF5IG9mIGhpc3RvcnkgZXZlbnRzIGdpdmVuIGEgY2hhbmdlIGluIHRoZVxuICAvLyBkb2N1bWVudC4gSWYgdGhlIGNoYW5nZSB0b3VjaGVzIHRoZSBzYW1lIGxpbmVzIGFzIHRoZSBldmVudCwgdGhlXG4gIC8vIGV2ZW50LCBhbmQgZXZlcnl0aGluZyAnYmVoaW5kJyBpdCwgaXMgZGlzY2FyZGVkLiBJZiB0aGUgY2hhbmdlIGlzXG4gIC8vIGJlZm9yZSB0aGUgZXZlbnQsIHRoZSBldmVudCdzIHBvc2l0aW9ucyBhcmUgdXBkYXRlZC4gVXNlcyBhXG4gIC8vIGNvcHktb24td3JpdGUgc2NoZW1lIGZvciB0aGUgcG9zaXRpb25zLCB0byBhdm9pZCBoYXZpbmcgdG9cbiAgLy8gcmVhbGxvY2F0ZSB0aGVtIGFsbCBvbiBldmVyeSByZWJhc2UsIGJ1dCBhbHNvIGF2b2lkIHByb2JsZW1zIHdpdGhcbiAgLy8gc2hhcmVkIHBvc2l0aW9uIG9iamVjdHMgYmVpbmcgdW5zYWZlbHkgdXBkYXRlZC5cbiAgZnVuY3Rpb24gcmViYXNlSGlzdEFycmF5KGFycmF5LCBmcm9tLCB0bywgZGlmZikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBzdWIgPSBhcnJheVtpXSwgb2sgPSB0cnVlO1xuICAgICAgaWYgKHN1Yi5yYW5nZXMpIHtcbiAgICAgICAgaWYgKCFzdWIuY29waWVkKSB7IHN1YiA9IGFycmF5W2ldID0gc3ViLmRlZXBDb3B5KCk7IHN1Yi5jb3BpZWQgPSB0cnVlOyB9XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc3ViLnJhbmdlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHJlYmFzZUhpc3RTZWxTaW5nbGUoc3ViLnJhbmdlc1tqXS5hbmNob3IsIGZyb20sIHRvLCBkaWZmKTtcbiAgICAgICAgICByZWJhc2VIaXN0U2VsU2luZ2xlKHN1Yi5yYW5nZXNbal0uaGVhZCwgZnJvbSwgdG8sIGRpZmYpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgICBmb3IgKHZhciBqJDEgPSAwOyBqJDEgPCBzdWIuY2hhbmdlcy5sZW5ndGg7ICsraiQxKSB7XG4gICAgICAgIHZhciBjdXIgPSBzdWIuY2hhbmdlc1tqJDFdO1xuICAgICAgICBpZiAodG8gPCBjdXIuZnJvbS5saW5lKSB7XG4gICAgICAgICAgY3VyLmZyb20gPSBQb3MoY3VyLmZyb20ubGluZSArIGRpZmYsIGN1ci5mcm9tLmNoKTtcbiAgICAgICAgICBjdXIudG8gPSBQb3MoY3VyLnRvLmxpbmUgKyBkaWZmLCBjdXIudG8uY2gpO1xuICAgICAgICB9IGVsc2UgaWYgKGZyb20gPD0gY3VyLnRvLmxpbmUpIHtcbiAgICAgICAgICBvayA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghb2spIHtcbiAgICAgICAgYXJyYXkuc3BsaWNlKDAsIGkgKyAxKTtcbiAgICAgICAgaSA9IDA7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmViYXNlSGlzdChoaXN0LCBjaGFuZ2UpIHtcbiAgICB2YXIgZnJvbSA9IGNoYW5nZS5mcm9tLmxpbmUsIHRvID0gY2hhbmdlLnRvLmxpbmUsIGRpZmYgPSBjaGFuZ2UudGV4dC5sZW5ndGggLSAodG8gLSBmcm9tKSAtIDE7XG4gICAgcmViYXNlSGlzdEFycmF5KGhpc3QuZG9uZSwgZnJvbSwgdG8sIGRpZmYpO1xuICAgIHJlYmFzZUhpc3RBcnJheShoaXN0LnVuZG9uZSwgZnJvbSwgdG8sIGRpZmYpO1xuICB9XG5cbiAgLy8gVXRpbGl0eSBmb3IgYXBwbHlpbmcgYSBjaGFuZ2UgdG8gYSBsaW5lIGJ5IGhhbmRsZSBvciBudW1iZXIsXG4gIC8vIHJldHVybmluZyB0aGUgbnVtYmVyIGFuZCBvcHRpb25hbGx5IHJlZ2lzdGVyaW5nIHRoZSBsaW5lIGFzXG4gIC8vIGNoYW5nZWQuXG4gIGZ1bmN0aW9uIGNoYW5nZUxpbmUoZG9jLCBoYW5kbGUsIGNoYW5nZVR5cGUsIG9wKSB7XG4gICAgdmFyIG5vID0gaGFuZGxlLCBsaW5lID0gaGFuZGxlO1xuICAgIGlmICh0eXBlb2YgaGFuZGxlID09IFwibnVtYmVyXCIpIHsgbGluZSA9IGdldExpbmUoZG9jLCBjbGlwTGluZShkb2MsIGhhbmRsZSkpOyB9XG4gICAgZWxzZSB7IG5vID0gbGluZU5vKGhhbmRsZSk7IH1cbiAgICBpZiAobm8gPT0gbnVsbCkgeyByZXR1cm4gbnVsbCB9XG4gICAgaWYgKG9wKGxpbmUsIG5vKSAmJiBkb2MuY20pIHsgcmVnTGluZUNoYW5nZShkb2MuY20sIG5vLCBjaGFuZ2VUeXBlKTsgfVxuICAgIHJldHVybiBsaW5lXG4gIH1cblxuICAvLyBUaGUgZG9jdW1lbnQgaXMgcmVwcmVzZW50ZWQgYXMgYSBCVHJlZSBjb25zaXN0aW5nIG9mIGxlYXZlcywgd2l0aFxuICAvLyBjaHVuayBvZiBsaW5lcyBpbiB0aGVtLCBhbmQgYnJhbmNoZXMsIHdpdGggdXAgdG8gdGVuIGxlYXZlcyBvclxuICAvLyBvdGhlciBicmFuY2ggbm9kZXMgYmVsb3cgdGhlbS4gVGhlIHRvcCBub2RlIGlzIGFsd2F5cyBhIGJyYW5jaFxuICAvLyBub2RlLCBhbmQgaXMgdGhlIGRvY3VtZW50IG9iamVjdCBpdHNlbGYgKG1lYW5pbmcgaXQgaGFzXG4gIC8vIGFkZGl0aW9uYWwgbWV0aG9kcyBhbmQgcHJvcGVydGllcykuXG4gIC8vXG4gIC8vIEFsbCBub2RlcyBoYXZlIHBhcmVudCBsaW5rcy4gVGhlIHRyZWUgaXMgdXNlZCBib3RoIHRvIGdvIGZyb21cbiAgLy8gbGluZSBudW1iZXJzIHRvIGxpbmUgb2JqZWN0cywgYW5kIHRvIGdvIGZyb20gb2JqZWN0cyB0byBudW1iZXJzLlxuICAvLyBJdCBhbHNvIGluZGV4ZXMgYnkgaGVpZ2h0LCBhbmQgaXMgdXNlZCB0byBjb252ZXJ0IGJldHdlZW4gaGVpZ2h0XG4gIC8vIGFuZCBsaW5lIG9iamVjdCwgYW5kIHRvIGZpbmQgdGhlIHRvdGFsIGhlaWdodCBvZiB0aGUgZG9jdW1lbnQuXG4gIC8vXG4gIC8vIFNlZSBhbHNvIGh0dHA6Ly9tYXJpam5oYXZlcmJla2UubmwvYmxvZy9jb2RlbWlycm9yLWxpbmUtdHJlZS5odG1sXG5cbiAgZnVuY3Rpb24gTGVhZkNodW5rKGxpbmVzKSB7XG4gICAgdGhpcy5saW5lcyA9IGxpbmVzO1xuICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICB2YXIgaGVpZ2h0ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgKytpKSB7XG4gICAgICBsaW5lc1tpXS5wYXJlbnQgPSB0aGlzO1xuICAgICAgaGVpZ2h0ICs9IGxpbmVzW2ldLmhlaWdodDtcbiAgICB9XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gIH1cblxuICBMZWFmQ2h1bmsucHJvdG90eXBlID0ge1xuICAgIGNodW5rU2l6ZTogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmxpbmVzLmxlbmd0aCB9LFxuXG4gICAgLy8gUmVtb3ZlIHRoZSBuIGxpbmVzIGF0IG9mZnNldCAnYXQnLlxuICAgIHJlbW92ZUlubmVyOiBmdW5jdGlvbihhdCwgbikge1xuICAgICAgZm9yICh2YXIgaSA9IGF0LCBlID0gYXQgKyBuOyBpIDwgZTsgKytpKSB7XG4gICAgICAgIHZhciBsaW5lID0gdGhpcy5saW5lc1tpXTtcbiAgICAgICAgdGhpcy5oZWlnaHQgLT0gbGluZS5oZWlnaHQ7XG4gICAgICAgIGNsZWFuVXBMaW5lKGxpbmUpO1xuICAgICAgICBzaWduYWxMYXRlcihsaW5lLCBcImRlbGV0ZVwiKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubGluZXMuc3BsaWNlKGF0LCBuKTtcbiAgICB9LFxuXG4gICAgLy8gSGVscGVyIHVzZWQgdG8gY29sbGFwc2UgYSBzbWFsbCBicmFuY2ggaW50byBhIHNpbmdsZSBsZWFmLlxuICAgIGNvbGxhcHNlOiBmdW5jdGlvbihsaW5lcykge1xuICAgICAgbGluZXMucHVzaC5hcHBseShsaW5lcywgdGhpcy5saW5lcyk7XG4gICAgfSxcblxuICAgIC8vIEluc2VydCB0aGUgZ2l2ZW4gYXJyYXkgb2YgbGluZXMgYXQgb2Zmc2V0ICdhdCcsIGNvdW50IHRoZW0gYXNcbiAgICAvLyBoYXZpbmcgdGhlIGdpdmVuIGhlaWdodC5cbiAgICBpbnNlcnRJbm5lcjogZnVuY3Rpb24oYXQsIGxpbmVzLCBoZWlnaHQpIHtcbiAgICAgIHRoaXMuaGVpZ2h0ICs9IGhlaWdodDtcbiAgICAgIHRoaXMubGluZXMgPSB0aGlzLmxpbmVzLnNsaWNlKDAsIGF0KS5jb25jYXQobGluZXMpLmNvbmNhdCh0aGlzLmxpbmVzLnNsaWNlKGF0KSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgKytpKSB7IGxpbmVzW2ldLnBhcmVudCA9IHRoaXM7IH1cbiAgICB9LFxuXG4gICAgLy8gVXNlZCB0byBpdGVyYXRlIG92ZXIgYSBwYXJ0IG9mIHRoZSB0cmVlLlxuICAgIGl0ZXJOOiBmdW5jdGlvbihhdCwgbiwgb3ApIHtcbiAgICAgIGZvciAodmFyIGUgPSBhdCArIG47IGF0IDwgZTsgKythdClcbiAgICAgICAgeyBpZiAob3AodGhpcy5saW5lc1thdF0pKSB7IHJldHVybiB0cnVlIH0gfVxuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBCcmFuY2hDaHVuayhjaGlsZHJlbikge1xuICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICB2YXIgc2l6ZSA9IDAsIGhlaWdodCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGNoID0gY2hpbGRyZW5baV07XG4gICAgICBzaXplICs9IGNoLmNodW5rU2l6ZSgpOyBoZWlnaHQgKz0gY2guaGVpZ2h0O1xuICAgICAgY2gucGFyZW50ID0gdGhpcztcbiAgICB9XG4gICAgdGhpcy5zaXplID0gc2l6ZTtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICB0aGlzLnBhcmVudCA9IG51bGw7XG4gIH1cblxuICBCcmFuY2hDaHVuay5wcm90b3R5cGUgPSB7XG4gICAgY2h1bmtTaXplOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuc2l6ZSB9LFxuXG4gICAgcmVtb3ZlSW5uZXI6IGZ1bmN0aW9uKGF0LCBuKSB7XG4gICAgICB0aGlzLnNpemUgLT0gbjtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldLCBzeiA9IGNoaWxkLmNodW5rU2l6ZSgpO1xuICAgICAgICBpZiAoYXQgPCBzeikge1xuICAgICAgICAgIHZhciBybSA9IE1hdGgubWluKG4sIHN6IC0gYXQpLCBvbGRIZWlnaHQgPSBjaGlsZC5oZWlnaHQ7XG4gICAgICAgICAgY2hpbGQucmVtb3ZlSW5uZXIoYXQsIHJtKTtcbiAgICAgICAgICB0aGlzLmhlaWdodCAtPSBvbGRIZWlnaHQgLSBjaGlsZC5oZWlnaHQ7XG4gICAgICAgICAgaWYgKHN6ID09IHJtKSB7IHRoaXMuY2hpbGRyZW4uc3BsaWNlKGktLSwgMSk7IGNoaWxkLnBhcmVudCA9IG51bGw7IH1cbiAgICAgICAgICBpZiAoKG4gLT0gcm0pID09IDApIHsgYnJlYWsgfVxuICAgICAgICAgIGF0ID0gMDtcbiAgICAgICAgfSBlbHNlIHsgYXQgLT0gc3o7IH1cbiAgICAgIH1cbiAgICAgIC8vIElmIHRoZSByZXN1bHQgaXMgc21hbGxlciB0aGFuIDI1IGxpbmVzLCBlbnN1cmUgdGhhdCBpdCBpcyBhXG4gICAgICAvLyBzaW5nbGUgbGVhZiBub2RlLlxuICAgICAgaWYgKHRoaXMuc2l6ZSAtIG4gPCAyNSAmJlxuICAgICAgICAgICh0aGlzLmNoaWxkcmVuLmxlbmd0aCA+IDEgfHwgISh0aGlzLmNoaWxkcmVuWzBdIGluc3RhbmNlb2YgTGVhZkNodW5rKSkpIHtcbiAgICAgICAgdmFyIGxpbmVzID0gW107XG4gICAgICAgIHRoaXMuY29sbGFwc2UobGluZXMpO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gW25ldyBMZWFmQ2h1bmsobGluZXMpXTtcbiAgICAgICAgdGhpcy5jaGlsZHJlblswXS5wYXJlbnQgPSB0aGlzO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBjb2xsYXBzZTogZnVuY3Rpb24obGluZXMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7ICsraSkgeyB0aGlzLmNoaWxkcmVuW2ldLmNvbGxhcHNlKGxpbmVzKTsgfVxuICAgIH0sXG5cbiAgICBpbnNlcnRJbm5lcjogZnVuY3Rpb24oYXQsIGxpbmVzLCBoZWlnaHQpIHtcbiAgICAgIHRoaXMuc2l6ZSArPSBsaW5lcy5sZW5ndGg7XG4gICAgICB0aGlzLmhlaWdodCArPSBoZWlnaHQ7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXSwgc3ogPSBjaGlsZC5jaHVua1NpemUoKTtcbiAgICAgICAgaWYgKGF0IDw9IHN6KSB7XG4gICAgICAgICAgY2hpbGQuaW5zZXJ0SW5uZXIoYXQsIGxpbmVzLCBoZWlnaHQpO1xuICAgICAgICAgIGlmIChjaGlsZC5saW5lcyAmJiBjaGlsZC5saW5lcy5sZW5ndGggPiA1MCkge1xuICAgICAgICAgICAgLy8gVG8gYXZvaWQgbWVtb3J5IHRocmFzaGluZyB3aGVuIGNoaWxkLmxpbmVzIGlzIGh1Z2UgKGUuZy4gZmlyc3QgdmlldyBvZiBhIGxhcmdlIGZpbGUpLCBpdCdzIG5ldmVyIHNwbGljZWQuXG4gICAgICAgICAgICAvLyBJbnN0ZWFkLCBzbWFsbCBzbGljZXMgYXJlIHRha2VuLiBUaGV5J3JlIHRha2VuIGluIG9yZGVyIGJlY2F1c2Ugc2VxdWVudGlhbCBtZW1vcnkgYWNjZXNzZXMgYXJlIGZhc3Rlc3QuXG4gICAgICAgICAgICB2YXIgcmVtYWluaW5nID0gY2hpbGQubGluZXMubGVuZ3RoICUgMjUgKyAyNTtcbiAgICAgICAgICAgIGZvciAodmFyIHBvcyA9IHJlbWFpbmluZzsgcG9zIDwgY2hpbGQubGluZXMubGVuZ3RoOykge1xuICAgICAgICAgICAgICB2YXIgbGVhZiA9IG5ldyBMZWFmQ2h1bmsoY2hpbGQubGluZXMuc2xpY2UocG9zLCBwb3MgKz0gMjUpKTtcbiAgICAgICAgICAgICAgY2hpbGQuaGVpZ2h0IC09IGxlYWYuaGVpZ2h0O1xuICAgICAgICAgICAgICB0aGlzLmNoaWxkcmVuLnNwbGljZSgrK2ksIDAsIGxlYWYpO1xuICAgICAgICAgICAgICBsZWFmLnBhcmVudCA9IHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGlsZC5saW5lcyA9IGNoaWxkLmxpbmVzLnNsaWNlKDAsIHJlbWFpbmluZyk7XG4gICAgICAgICAgICB0aGlzLm1heWJlU3BpbGwoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBhdCAtPSBzejtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gV2hlbiBhIG5vZGUgaGFzIGdyb3duLCBjaGVjayB3aGV0aGVyIGl0IHNob3VsZCBiZSBzcGxpdC5cbiAgICBtYXliZVNwaWxsOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmNoaWxkcmVuLmxlbmd0aCA8PSAxMCkgeyByZXR1cm4gfVxuICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgIGRvIHtcbiAgICAgICAgdmFyIHNwaWxsZWQgPSBtZS5jaGlsZHJlbi5zcGxpY2UobWUuY2hpbGRyZW4ubGVuZ3RoIC0gNSwgNSk7XG4gICAgICAgIHZhciBzaWJsaW5nID0gbmV3IEJyYW5jaENodW5rKHNwaWxsZWQpO1xuICAgICAgICBpZiAoIW1lLnBhcmVudCkgeyAvLyBCZWNvbWUgdGhlIHBhcmVudCBub2RlXG4gICAgICAgICAgdmFyIGNvcHkgPSBuZXcgQnJhbmNoQ2h1bmsobWUuY2hpbGRyZW4pO1xuICAgICAgICAgIGNvcHkucGFyZW50ID0gbWU7XG4gICAgICAgICAgbWUuY2hpbGRyZW4gPSBbY29weSwgc2libGluZ107XG4gICAgICAgICAgbWUgPSBjb3B5O1xuICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWUuc2l6ZSAtPSBzaWJsaW5nLnNpemU7XG4gICAgICAgICAgbWUuaGVpZ2h0IC09IHNpYmxpbmcuaGVpZ2h0O1xuICAgICAgICAgIHZhciBteUluZGV4ID0gaW5kZXhPZihtZS5wYXJlbnQuY2hpbGRyZW4sIG1lKTtcbiAgICAgICAgICBtZS5wYXJlbnQuY2hpbGRyZW4uc3BsaWNlKG15SW5kZXggKyAxLCAwLCBzaWJsaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBzaWJsaW5nLnBhcmVudCA9IG1lLnBhcmVudDtcbiAgICAgIH0gd2hpbGUgKG1lLmNoaWxkcmVuLmxlbmd0aCA+IDEwKVxuICAgICAgbWUucGFyZW50Lm1heWJlU3BpbGwoKTtcbiAgICB9LFxuXG4gICAgaXRlck46IGZ1bmN0aW9uKGF0LCBuLCBvcCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV0sIHN6ID0gY2hpbGQuY2h1bmtTaXplKCk7XG4gICAgICAgIGlmIChhdCA8IHN6KSB7XG4gICAgICAgICAgdmFyIHVzZWQgPSBNYXRoLm1pbihuLCBzeiAtIGF0KTtcbiAgICAgICAgICBpZiAoY2hpbGQuaXRlck4oYXQsIHVzZWQsIG9wKSkgeyByZXR1cm4gdHJ1ZSB9XG4gICAgICAgICAgaWYgKChuIC09IHVzZWQpID09IDApIHsgYnJlYWsgfVxuICAgICAgICAgIGF0ID0gMDtcbiAgICAgICAgfSBlbHNlIHsgYXQgLT0gc3o7IH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gTGluZSB3aWRnZXRzIGFyZSBibG9jayBlbGVtZW50cyBkaXNwbGF5ZWQgYWJvdmUgb3IgYmVsb3cgYSBsaW5lLlxuXG4gIHZhciBMaW5lV2lkZ2V0ID0gZnVuY3Rpb24oZG9jLCBub2RlLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMpIHsgZm9yICh2YXIgb3B0IGluIG9wdGlvbnMpIHsgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkob3B0KSlcbiAgICAgIHsgdGhpc1tvcHRdID0gb3B0aW9uc1tvcHRdOyB9IH0gfVxuICAgIHRoaXMuZG9jID0gZG9jO1xuICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gIH07XG5cbiAgTGluZVdpZGdldC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNtID0gdGhpcy5kb2MuY20sIHdzID0gdGhpcy5saW5lLndpZGdldHMsIGxpbmUgPSB0aGlzLmxpbmUsIG5vID0gbGluZU5vKGxpbmUpO1xuICAgIGlmIChubyA9PSBudWxsIHx8ICF3cykgeyByZXR1cm4gfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgd3MubGVuZ3RoOyArK2kpIHsgaWYgKHdzW2ldID09IHRoaXMpIHsgd3Muc3BsaWNlKGktLSwgMSk7IH0gfVxuICAgIGlmICghd3MubGVuZ3RoKSB7IGxpbmUud2lkZ2V0cyA9IG51bGw7IH1cbiAgICB2YXIgaGVpZ2h0ID0gd2lkZ2V0SGVpZ2h0KHRoaXMpO1xuICAgIHVwZGF0ZUxpbmVIZWlnaHQobGluZSwgTWF0aC5tYXgoMCwgbGluZS5oZWlnaHQgLSBoZWlnaHQpKTtcbiAgICBpZiAoY20pIHtcbiAgICAgIHJ1bkluT3AoY20sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgYWRqdXN0U2Nyb2xsV2hlbkFib3ZlVmlzaWJsZShjbSwgbGluZSwgLWhlaWdodCk7XG4gICAgICAgIHJlZ0xpbmVDaGFuZ2UoY20sIG5vLCBcIndpZGdldFwiKTtcbiAgICAgIH0pO1xuICAgICAgc2lnbmFsTGF0ZXIoY20sIFwibGluZVdpZGdldENsZWFyZWRcIiwgY20sIHRoaXMsIG5vKTtcbiAgICB9XG4gIH07XG5cbiAgTGluZVdpZGdldC5wcm90b3R5cGUuY2hhbmdlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIG9sZEggPSB0aGlzLmhlaWdodCwgY20gPSB0aGlzLmRvYy5jbSwgbGluZSA9IHRoaXMubGluZTtcbiAgICB0aGlzLmhlaWdodCA9IG51bGw7XG4gICAgdmFyIGRpZmYgPSB3aWRnZXRIZWlnaHQodGhpcykgLSBvbGRIO1xuICAgIGlmICghZGlmZikgeyByZXR1cm4gfVxuICAgIGlmICghbGluZUlzSGlkZGVuKHRoaXMuZG9jLCBsaW5lKSkgeyB1cGRhdGVMaW5lSGVpZ2h0KGxpbmUsIGxpbmUuaGVpZ2h0ICsgZGlmZik7IH1cbiAgICBpZiAoY20pIHtcbiAgICAgIHJ1bkluT3AoY20sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY20uY3VyT3AuZm9yY2VVcGRhdGUgPSB0cnVlO1xuICAgICAgICBhZGp1c3RTY3JvbGxXaGVuQWJvdmVWaXNpYmxlKGNtLCBsaW5lLCBkaWZmKTtcbiAgICAgICAgc2lnbmFsTGF0ZXIoY20sIFwibGluZVdpZGdldENoYW5nZWRcIiwgY20sIHRoaXMkMSwgbGluZU5vKGxpbmUpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgZXZlbnRNaXhpbihMaW5lV2lkZ2V0KTtcblxuICBmdW5jdGlvbiBhZGp1c3RTY3JvbGxXaGVuQWJvdmVWaXNpYmxlKGNtLCBsaW5lLCBkaWZmKSB7XG4gICAgaWYgKGhlaWdodEF0TGluZShsaW5lKSA8ICgoY20uY3VyT3AgJiYgY20uY3VyT3Auc2Nyb2xsVG9wKSB8fCBjbS5kb2Muc2Nyb2xsVG9wKSlcbiAgICAgIHsgYWRkVG9TY3JvbGxUb3AoY20sIGRpZmYpOyB9XG4gIH1cblxuICBmdW5jdGlvbiBhZGRMaW5lV2lkZ2V0KGRvYywgaGFuZGxlLCBub2RlLCBvcHRpb25zKSB7XG4gICAgdmFyIHdpZGdldCA9IG5ldyBMaW5lV2lkZ2V0KGRvYywgbm9kZSwgb3B0aW9ucyk7XG4gICAgdmFyIGNtID0gZG9jLmNtO1xuICAgIGlmIChjbSAmJiB3aWRnZXQubm9IU2Nyb2xsKSB7IGNtLmRpc3BsYXkuYWxpZ25XaWRnZXRzID0gdHJ1ZTsgfVxuICAgIGNoYW5nZUxpbmUoZG9jLCBoYW5kbGUsIFwid2lkZ2V0XCIsIGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICB2YXIgd2lkZ2V0cyA9IGxpbmUud2lkZ2V0cyB8fCAobGluZS53aWRnZXRzID0gW10pO1xuICAgICAgaWYgKHdpZGdldC5pbnNlcnRBdCA9PSBudWxsKSB7IHdpZGdldHMucHVzaCh3aWRnZXQpOyB9XG4gICAgICBlbHNlIHsgd2lkZ2V0cy5zcGxpY2UoTWF0aC5taW4od2lkZ2V0cy5sZW5ndGgsIE1hdGgubWF4KDAsIHdpZGdldC5pbnNlcnRBdCkpLCAwLCB3aWRnZXQpOyB9XG4gICAgICB3aWRnZXQubGluZSA9IGxpbmU7XG4gICAgICBpZiAoY20gJiYgIWxpbmVJc0hpZGRlbihkb2MsIGxpbmUpKSB7XG4gICAgICAgIHZhciBhYm92ZVZpc2libGUgPSBoZWlnaHRBdExpbmUobGluZSkgPCBkb2Muc2Nyb2xsVG9wO1xuICAgICAgICB1cGRhdGVMaW5lSGVpZ2h0KGxpbmUsIGxpbmUuaGVpZ2h0ICsgd2lkZ2V0SGVpZ2h0KHdpZGdldCkpO1xuICAgICAgICBpZiAoYWJvdmVWaXNpYmxlKSB7IGFkZFRvU2Nyb2xsVG9wKGNtLCB3aWRnZXQuaGVpZ2h0KTsgfVxuICAgICAgICBjbS5jdXJPcC5mb3JjZVVwZGF0ZSA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0pO1xuICAgIGlmIChjbSkgeyBzaWduYWxMYXRlcihjbSwgXCJsaW5lV2lkZ2V0QWRkZWRcIiwgY20sIHdpZGdldCwgdHlwZW9mIGhhbmRsZSA9PSBcIm51bWJlclwiID8gaGFuZGxlIDogbGluZU5vKGhhbmRsZSkpOyB9XG4gICAgcmV0dXJuIHdpZGdldFxuICB9XG5cbiAgLy8gVEVYVE1BUktFUlNcblxuICAvLyBDcmVhdGVkIHdpdGggbWFya1RleHQgYW5kIHNldEJvb2ttYXJrIG1ldGhvZHMuIEEgVGV4dE1hcmtlciBpcyBhXG4gIC8vIGhhbmRsZSB0aGF0IGNhbiBiZSB1c2VkIHRvIGNsZWFyIG9yIGZpbmQgYSBtYXJrZWQgcG9zaXRpb24gaW4gdGhlXG4gIC8vIGRvY3VtZW50LiBMaW5lIG9iamVjdHMgaG9sZCBhcnJheXMgKG1hcmtlZFNwYW5zKSBjb250YWluaW5nXG4gIC8vIHtmcm9tLCB0bywgbWFya2VyfSBvYmplY3QgcG9pbnRpbmcgdG8gc3VjaCBtYXJrZXIgb2JqZWN0cywgYW5kXG4gIC8vIGluZGljYXRpbmcgdGhhdCBzdWNoIGEgbWFya2VyIGlzIHByZXNlbnQgb24gdGhhdCBsaW5lLiBNdWx0aXBsZVxuICAvLyBsaW5lcyBtYXkgcG9pbnQgdG8gdGhlIHNhbWUgbWFya2VyIHdoZW4gaXQgc3BhbnMgYWNyb3NzIGxpbmVzLlxuICAvLyBUaGUgc3BhbnMgd2lsbCBoYXZlIG51bGwgZm9yIHRoZWlyIGZyb20vdG8gcHJvcGVydGllcyB3aGVuIHRoZVxuICAvLyBtYXJrZXIgY29udGludWVzIGJleW9uZCB0aGUgc3RhcnQvZW5kIG9mIHRoZSBsaW5lLiBNYXJrZXJzIGhhdmVcbiAgLy8gbGlua3MgYmFjayB0byB0aGUgbGluZXMgdGhleSBjdXJyZW50bHkgdG91Y2guXG5cbiAgLy8gQ29sbGFwc2VkIG1hcmtlcnMgaGF2ZSB1bmlxdWUgaWRzLCBpbiBvcmRlciB0byBiZSBhYmxlIHRvIG9yZGVyXG4gIC8vIHRoZW0sIHdoaWNoIGlzIG5lZWRlZCBmb3IgdW5pcXVlbHkgZGV0ZXJtaW5pbmcgYW4gb3V0ZXIgbWFya2VyXG4gIC8vIHdoZW4gdGhleSBvdmVybGFwICh0aGV5IG1heSBuZXN0LCBidXQgbm90IHBhcnRpYWxseSBvdmVybGFwKS5cbiAgdmFyIG5leHRNYXJrZXJJZCA9IDA7XG5cbiAgdmFyIFRleHRNYXJrZXIgPSBmdW5jdGlvbihkb2MsIHR5cGUpIHtcbiAgICB0aGlzLmxpbmVzID0gW107XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLmRvYyA9IGRvYztcbiAgICB0aGlzLmlkID0gKytuZXh0TWFya2VySWQ7XG4gIH07XG5cbiAgLy8gQ2xlYXIgdGhlIG1hcmtlci5cbiAgVGV4dE1hcmtlci5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuZXhwbGljaXRseUNsZWFyZWQpIHsgcmV0dXJuIH1cbiAgICB2YXIgY20gPSB0aGlzLmRvYy5jbSwgd2l0aE9wID0gY20gJiYgIWNtLmN1ck9wO1xuICAgIGlmICh3aXRoT3ApIHsgc3RhcnRPcGVyYXRpb24oY20pOyB9XG4gICAgaWYgKGhhc0hhbmRsZXIodGhpcywgXCJjbGVhclwiKSkge1xuICAgICAgdmFyIGZvdW5kID0gdGhpcy5maW5kKCk7XG4gICAgICBpZiAoZm91bmQpIHsgc2lnbmFsTGF0ZXIodGhpcywgXCJjbGVhclwiLCBmb3VuZC5mcm9tLCBmb3VuZC50byk7IH1cbiAgICB9XG4gICAgdmFyIG1pbiA9IG51bGwsIG1heCA9IG51bGw7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxpbmVzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgbGluZSA9IHRoaXMubGluZXNbaV07XG4gICAgICB2YXIgc3BhbiA9IGdldE1hcmtlZFNwYW5Gb3IobGluZS5tYXJrZWRTcGFucywgdGhpcyk7XG4gICAgICBpZiAoY20gJiYgIXRoaXMuY29sbGFwc2VkKSB7IHJlZ0xpbmVDaGFuZ2UoY20sIGxpbmVObyhsaW5lKSwgXCJ0ZXh0XCIpOyB9XG4gICAgICBlbHNlIGlmIChjbSkge1xuICAgICAgICBpZiAoc3Bhbi50byAhPSBudWxsKSB7IG1heCA9IGxpbmVObyhsaW5lKTsgfVxuICAgICAgICBpZiAoc3Bhbi5mcm9tICE9IG51bGwpIHsgbWluID0gbGluZU5vKGxpbmUpOyB9XG4gICAgICB9XG4gICAgICBsaW5lLm1hcmtlZFNwYW5zID0gcmVtb3ZlTWFya2VkU3BhbihsaW5lLm1hcmtlZFNwYW5zLCBzcGFuKTtcbiAgICAgIGlmIChzcGFuLmZyb20gPT0gbnVsbCAmJiB0aGlzLmNvbGxhcHNlZCAmJiAhbGluZUlzSGlkZGVuKHRoaXMuZG9jLCBsaW5lKSAmJiBjbSlcbiAgICAgICAgeyB1cGRhdGVMaW5lSGVpZ2h0KGxpbmUsIHRleHRIZWlnaHQoY20uZGlzcGxheSkpOyB9XG4gICAgfVxuICAgIGlmIChjbSAmJiB0aGlzLmNvbGxhcHNlZCAmJiAhY20ub3B0aW9ucy5saW5lV3JhcHBpbmcpIHsgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgdGhpcy5saW5lcy5sZW5ndGg7ICsraSQxKSB7XG4gICAgICB2YXIgdmlzdWFsID0gdmlzdWFsTGluZSh0aGlzLmxpbmVzW2kkMV0pLCBsZW4gPSBsaW5lTGVuZ3RoKHZpc3VhbCk7XG4gICAgICBpZiAobGVuID4gY20uZGlzcGxheS5tYXhMaW5lTGVuZ3RoKSB7XG4gICAgICAgIGNtLmRpc3BsYXkubWF4TGluZSA9IHZpc3VhbDtcbiAgICAgICAgY20uZGlzcGxheS5tYXhMaW5lTGVuZ3RoID0gbGVuO1xuICAgICAgICBjbS5kaXNwbGF5Lm1heExpbmVDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IH1cblxuICAgIGlmIChtaW4gIT0gbnVsbCAmJiBjbSAmJiB0aGlzLmNvbGxhcHNlZCkgeyByZWdDaGFuZ2UoY20sIG1pbiwgbWF4ICsgMSk7IH1cbiAgICB0aGlzLmxpbmVzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5leHBsaWNpdGx5Q2xlYXJlZCA9IHRydWU7XG4gICAgaWYgKHRoaXMuYXRvbWljICYmIHRoaXMuZG9jLmNhbnRFZGl0KSB7XG4gICAgICB0aGlzLmRvYy5jYW50RWRpdCA9IGZhbHNlO1xuICAgICAgaWYgKGNtKSB7IHJlQ2hlY2tTZWxlY3Rpb24oY20uZG9jKTsgfVxuICAgIH1cbiAgICBpZiAoY20pIHsgc2lnbmFsTGF0ZXIoY20sIFwibWFya2VyQ2xlYXJlZFwiLCBjbSwgdGhpcywgbWluLCBtYXgpOyB9XG4gICAgaWYgKHdpdGhPcCkgeyBlbmRPcGVyYXRpb24oY20pOyB9XG4gICAgaWYgKHRoaXMucGFyZW50KSB7IHRoaXMucGFyZW50LmNsZWFyKCk7IH1cbiAgfTtcblxuICAvLyBGaW5kIHRoZSBwb3NpdGlvbiBvZiB0aGUgbWFya2VyIGluIHRoZSBkb2N1bWVudC4gUmV0dXJucyBhIHtmcm9tLFxuICAvLyB0b30gb2JqZWN0IGJ5IGRlZmF1bHQuIFNpZGUgY2FuIGJlIHBhc3NlZCB0byBnZXQgYSBzcGVjaWZpYyBzaWRlXG4gIC8vIC0tIDAgKGJvdGgpLCAtMSAobGVmdCksIG9yIDEgKHJpZ2h0KS4gV2hlbiBsaW5lT2JqIGlzIHRydWUsIHRoZVxuICAvLyBQb3Mgb2JqZWN0cyByZXR1cm5lZCBjb250YWluIGEgbGluZSBvYmplY3QsIHJhdGhlciB0aGFuIGEgbGluZVxuICAvLyBudW1iZXIgKHVzZWQgdG8gcHJldmVudCBsb29raW5nIHVwIHRoZSBzYW1lIGxpbmUgdHdpY2UpLlxuICBUZXh0TWFya2VyLnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24gKHNpZGUsIGxpbmVPYmopIHtcbiAgICBpZiAoc2lkZSA9PSBudWxsICYmIHRoaXMudHlwZSA9PSBcImJvb2ttYXJrXCIpIHsgc2lkZSA9IDE7IH1cbiAgICB2YXIgZnJvbSwgdG87XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxpbmVzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgbGluZSA9IHRoaXMubGluZXNbaV07XG4gICAgICB2YXIgc3BhbiA9IGdldE1hcmtlZFNwYW5Gb3IobGluZS5tYXJrZWRTcGFucywgdGhpcyk7XG4gICAgICBpZiAoc3Bhbi5mcm9tICE9IG51bGwpIHtcbiAgICAgICAgZnJvbSA9IFBvcyhsaW5lT2JqID8gbGluZSA6IGxpbmVObyhsaW5lKSwgc3Bhbi5mcm9tKTtcbiAgICAgICAgaWYgKHNpZGUgPT0gLTEpIHsgcmV0dXJuIGZyb20gfVxuICAgICAgfVxuICAgICAgaWYgKHNwYW4udG8gIT0gbnVsbCkge1xuICAgICAgICB0byA9IFBvcyhsaW5lT2JqID8gbGluZSA6IGxpbmVObyhsaW5lKSwgc3Bhbi50byk7XG4gICAgICAgIGlmIChzaWRlID09IDEpIHsgcmV0dXJuIHRvIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZyb20gJiYge2Zyb206IGZyb20sIHRvOiB0b31cbiAgfTtcblxuICAvLyBTaWduYWxzIHRoYXQgdGhlIG1hcmtlcidzIHdpZGdldCBjaGFuZ2VkLCBhbmQgc3Vycm91bmRpbmcgbGF5b3V0XG4gIC8vIHNob3VsZCBiZSByZWNvbXB1dGVkLlxuICBUZXh0TWFya2VyLnByb3RvdHlwZS5jaGFuZ2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgcG9zID0gdGhpcy5maW5kKC0xLCB0cnVlKSwgd2lkZ2V0ID0gdGhpcywgY20gPSB0aGlzLmRvYy5jbTtcbiAgICBpZiAoIXBvcyB8fCAhY20pIHsgcmV0dXJuIH1cbiAgICBydW5Jbk9wKGNtLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbGluZSA9IHBvcy5saW5lLCBsaW5lTiA9IGxpbmVObyhwb3MubGluZSk7XG4gICAgICB2YXIgdmlldyA9IGZpbmRWaWV3Rm9yTGluZShjbSwgbGluZU4pO1xuICAgICAgaWYgKHZpZXcpIHtcbiAgICAgICAgY2xlYXJMaW5lTWVhc3VyZW1lbnRDYWNoZUZvcih2aWV3KTtcbiAgICAgICAgY20uY3VyT3Auc2VsZWN0aW9uQ2hhbmdlZCA9IGNtLmN1ck9wLmZvcmNlVXBkYXRlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGNtLmN1ck9wLnVwZGF0ZU1heExpbmUgPSB0cnVlO1xuICAgICAgaWYgKCFsaW5lSXNIaWRkZW4od2lkZ2V0LmRvYywgbGluZSkgJiYgd2lkZ2V0LmhlaWdodCAhPSBudWxsKSB7XG4gICAgICAgIHZhciBvbGRIZWlnaHQgPSB3aWRnZXQuaGVpZ2h0O1xuICAgICAgICB3aWRnZXQuaGVpZ2h0ID0gbnVsbDtcbiAgICAgICAgdmFyIGRIZWlnaHQgPSB3aWRnZXRIZWlnaHQod2lkZ2V0KSAtIG9sZEhlaWdodDtcbiAgICAgICAgaWYgKGRIZWlnaHQpXG4gICAgICAgICAgeyB1cGRhdGVMaW5lSGVpZ2h0KGxpbmUsIGxpbmUuaGVpZ2h0ICsgZEhlaWdodCk7IH1cbiAgICAgIH1cbiAgICAgIHNpZ25hbExhdGVyKGNtLCBcIm1hcmtlckNoYW5nZWRcIiwgY20sIHRoaXMkMSk7XG4gICAgfSk7XG4gIH07XG5cbiAgVGV4dE1hcmtlci5wcm90b3R5cGUuYXR0YWNoTGluZSA9IGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgaWYgKCF0aGlzLmxpbmVzLmxlbmd0aCAmJiB0aGlzLmRvYy5jbSkge1xuICAgICAgdmFyIG9wID0gdGhpcy5kb2MuY20uY3VyT3A7XG4gICAgICBpZiAoIW9wLm1heWJlSGlkZGVuTWFya2VycyB8fCBpbmRleE9mKG9wLm1heWJlSGlkZGVuTWFya2VycywgdGhpcykgPT0gLTEpXG4gICAgICAgIHsgKG9wLm1heWJlVW5oaWRkZW5NYXJrZXJzIHx8IChvcC5tYXliZVVuaGlkZGVuTWFya2VycyA9IFtdKSkucHVzaCh0aGlzKTsgfVxuICAgIH1cbiAgICB0aGlzLmxpbmVzLnB1c2gobGluZSk7XG4gIH07XG5cbiAgVGV4dE1hcmtlci5wcm90b3R5cGUuZGV0YWNoTGluZSA9IGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgdGhpcy5saW5lcy5zcGxpY2UoaW5kZXhPZih0aGlzLmxpbmVzLCBsaW5lKSwgMSk7XG4gICAgaWYgKCF0aGlzLmxpbmVzLmxlbmd0aCAmJiB0aGlzLmRvYy5jbSkge1xuICAgICAgdmFyIG9wID0gdGhpcy5kb2MuY20uY3VyT3BcbiAgICAgIDsob3AubWF5YmVIaWRkZW5NYXJrZXJzIHx8IChvcC5tYXliZUhpZGRlbk1hcmtlcnMgPSBbXSkpLnB1c2godGhpcyk7XG4gICAgfVxuICB9O1xuICBldmVudE1peGluKFRleHRNYXJrZXIpO1xuXG4gIC8vIENyZWF0ZSBhIG1hcmtlciwgd2lyZSBpdCB1cCB0byB0aGUgcmlnaHQgbGluZXMsIGFuZFxuICBmdW5jdGlvbiBtYXJrVGV4dChkb2MsIGZyb20sIHRvLCBvcHRpb25zLCB0eXBlKSB7XG4gICAgLy8gU2hhcmVkIG1hcmtlcnMgKGFjcm9zcyBsaW5rZWQgZG9jdW1lbnRzKSBhcmUgaGFuZGxlZCBzZXBhcmF0ZWx5XG4gICAgLy8gKG1hcmtUZXh0U2hhcmVkIHdpbGwgY2FsbCBvdXQgdG8gdGhpcyBhZ2Fpbiwgb25jZSBwZXJcbiAgICAvLyBkb2N1bWVudCkuXG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5zaGFyZWQpIHsgcmV0dXJuIG1hcmtUZXh0U2hhcmVkKGRvYywgZnJvbSwgdG8sIG9wdGlvbnMsIHR5cGUpIH1cbiAgICAvLyBFbnN1cmUgd2UgYXJlIGluIGFuIG9wZXJhdGlvbi5cbiAgICBpZiAoZG9jLmNtICYmICFkb2MuY20uY3VyT3ApIHsgcmV0dXJuIG9wZXJhdGlvbihkb2MuY20sIG1hcmtUZXh0KShkb2MsIGZyb20sIHRvLCBvcHRpb25zLCB0eXBlKSB9XG5cbiAgICB2YXIgbWFya2VyID0gbmV3IFRleHRNYXJrZXIoZG9jLCB0eXBlKSwgZGlmZiA9IGNtcChmcm9tLCB0byk7XG4gICAgaWYgKG9wdGlvbnMpIHsgY29weU9iaihvcHRpb25zLCBtYXJrZXIsIGZhbHNlKTsgfVxuICAgIC8vIERvbid0IGNvbm5lY3QgZW1wdHkgbWFya2VycyB1bmxlc3MgY2xlYXJXaGVuRW1wdHkgaXMgZmFsc2VcbiAgICBpZiAoZGlmZiA+IDAgfHwgZGlmZiA9PSAwICYmIG1hcmtlci5jbGVhcldoZW5FbXB0eSAhPT0gZmFsc2UpXG4gICAgICB7IHJldHVybiBtYXJrZXIgfVxuICAgIGlmIChtYXJrZXIucmVwbGFjZWRXaXRoKSB7XG4gICAgICAvLyBTaG93aW5nIHVwIGFzIGEgd2lkZ2V0IGltcGxpZXMgY29sbGFwc2VkICh3aWRnZXQgcmVwbGFjZXMgdGV4dClcbiAgICAgIG1hcmtlci5jb2xsYXBzZWQgPSB0cnVlO1xuICAgICAgbWFya2VyLndpZGdldE5vZGUgPSBlbHRQKFwic3BhblwiLCBbbWFya2VyLnJlcGxhY2VkV2l0aF0sIFwiQ29kZU1pcnJvci13aWRnZXRcIik7XG4gICAgICBpZiAoIW9wdGlvbnMuaGFuZGxlTW91c2VFdmVudHMpIHsgbWFya2VyLndpZGdldE5vZGUuc2V0QXR0cmlidXRlKFwiY20taWdub3JlLWV2ZW50c1wiLCBcInRydWVcIik7IH1cbiAgICAgIGlmIChvcHRpb25zLmluc2VydExlZnQpIHsgbWFya2VyLndpZGdldE5vZGUuaW5zZXJ0TGVmdCA9IHRydWU7IH1cbiAgICB9XG4gICAgaWYgKG1hcmtlci5jb2xsYXBzZWQpIHtcbiAgICAgIGlmIChjb25mbGljdGluZ0NvbGxhcHNlZFJhbmdlKGRvYywgZnJvbS5saW5lLCBmcm9tLCB0bywgbWFya2VyKSB8fFxuICAgICAgICAgIGZyb20ubGluZSAhPSB0by5saW5lICYmIGNvbmZsaWN0aW5nQ29sbGFwc2VkUmFuZ2UoZG9jLCB0by5saW5lLCBmcm9tLCB0bywgbWFya2VyKSlcbiAgICAgICAgeyB0aHJvdyBuZXcgRXJyb3IoXCJJbnNlcnRpbmcgY29sbGFwc2VkIG1hcmtlciBwYXJ0aWFsbHkgb3ZlcmxhcHBpbmcgYW4gZXhpc3Rpbmcgb25lXCIpIH1cbiAgICAgIHNlZUNvbGxhcHNlZFNwYW5zKCk7XG4gICAgfVxuXG4gICAgaWYgKG1hcmtlci5hZGRUb0hpc3RvcnkpXG4gICAgICB7IGFkZENoYW5nZVRvSGlzdG9yeShkb2MsIHtmcm9tOiBmcm9tLCB0bzogdG8sIG9yaWdpbjogXCJtYXJrVGV4dFwifSwgZG9jLnNlbCwgTmFOKTsgfVxuXG4gICAgdmFyIGN1ckxpbmUgPSBmcm9tLmxpbmUsIGNtID0gZG9jLmNtLCB1cGRhdGVNYXhMaW5lO1xuICAgIGRvYy5pdGVyKGN1ckxpbmUsIHRvLmxpbmUgKyAxLCBmdW5jdGlvbiAobGluZSkge1xuICAgICAgaWYgKGNtICYmIG1hcmtlci5jb2xsYXBzZWQgJiYgIWNtLm9wdGlvbnMubGluZVdyYXBwaW5nICYmIHZpc3VhbExpbmUobGluZSkgPT0gY20uZGlzcGxheS5tYXhMaW5lKVxuICAgICAgICB7IHVwZGF0ZU1heExpbmUgPSB0cnVlOyB9XG4gICAgICBpZiAobWFya2VyLmNvbGxhcHNlZCAmJiBjdXJMaW5lICE9IGZyb20ubGluZSkgeyB1cGRhdGVMaW5lSGVpZ2h0KGxpbmUsIDApOyB9XG4gICAgICBhZGRNYXJrZWRTcGFuKGxpbmUsIG5ldyBNYXJrZWRTcGFuKG1hcmtlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyTGluZSA9PSBmcm9tLmxpbmUgPyBmcm9tLmNoIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyTGluZSA9PSB0by5saW5lID8gdG8uY2ggOiBudWxsKSk7XG4gICAgICArK2N1ckxpbmU7XG4gICAgfSk7XG4gICAgLy8gbGluZUlzSGlkZGVuIGRlcGVuZHMgb24gdGhlIHByZXNlbmNlIG9mIHRoZSBzcGFucywgc28gbmVlZHMgYSBzZWNvbmQgcGFzc1xuICAgIGlmIChtYXJrZXIuY29sbGFwc2VkKSB7IGRvYy5pdGVyKGZyb20ubGluZSwgdG8ubGluZSArIDEsIGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICBpZiAobGluZUlzSGlkZGVuKGRvYywgbGluZSkpIHsgdXBkYXRlTGluZUhlaWdodChsaW5lLCAwKTsgfVxuICAgIH0pOyB9XG5cbiAgICBpZiAobWFya2VyLmNsZWFyT25FbnRlcikgeyBvbihtYXJrZXIsIFwiYmVmb3JlQ3Vyc29yRW50ZXJcIiwgZnVuY3Rpb24gKCkgeyByZXR1cm4gbWFya2VyLmNsZWFyKCk7IH0pOyB9XG5cbiAgICBpZiAobWFya2VyLnJlYWRPbmx5KSB7XG4gICAgICBzZWVSZWFkT25seVNwYW5zKCk7XG4gICAgICBpZiAoZG9jLmhpc3RvcnkuZG9uZS5sZW5ndGggfHwgZG9jLmhpc3RvcnkudW5kb25lLmxlbmd0aClcbiAgICAgICAgeyBkb2MuY2xlYXJIaXN0b3J5KCk7IH1cbiAgICB9XG4gICAgaWYgKG1hcmtlci5jb2xsYXBzZWQpIHtcbiAgICAgIG1hcmtlci5pZCA9ICsrbmV4dE1hcmtlcklkO1xuICAgICAgbWFya2VyLmF0b21pYyA9IHRydWU7XG4gICAgfVxuICAgIGlmIChjbSkge1xuICAgICAgLy8gU3luYyBlZGl0b3Igc3RhdGVcbiAgICAgIGlmICh1cGRhdGVNYXhMaW5lKSB7IGNtLmN1ck9wLnVwZGF0ZU1heExpbmUgPSB0cnVlOyB9XG4gICAgICBpZiAobWFya2VyLmNvbGxhcHNlZClcbiAgICAgICAgeyByZWdDaGFuZ2UoY20sIGZyb20ubGluZSwgdG8ubGluZSArIDEpOyB9XG4gICAgICBlbHNlIGlmIChtYXJrZXIuY2xhc3NOYW1lIHx8IG1hcmtlci5zdGFydFN0eWxlIHx8IG1hcmtlci5lbmRTdHlsZSB8fCBtYXJrZXIuY3NzIHx8XG4gICAgICAgICAgICAgICBtYXJrZXIuYXR0cmlidXRlcyB8fCBtYXJrZXIudGl0bGUpXG4gICAgICAgIHsgZm9yICh2YXIgaSA9IGZyb20ubGluZTsgaSA8PSB0by5saW5lOyBpKyspIHsgcmVnTGluZUNoYW5nZShjbSwgaSwgXCJ0ZXh0XCIpOyB9IH1cbiAgICAgIGlmIChtYXJrZXIuYXRvbWljKSB7IHJlQ2hlY2tTZWxlY3Rpb24oY20uZG9jKTsgfVxuICAgICAgc2lnbmFsTGF0ZXIoY20sIFwibWFya2VyQWRkZWRcIiwgY20sIG1hcmtlcik7XG4gICAgfVxuICAgIHJldHVybiBtYXJrZXJcbiAgfVxuXG4gIC8vIFNIQVJFRCBURVhUTUFSS0VSU1xuXG4gIC8vIEEgc2hhcmVkIG1hcmtlciBzcGFucyBtdWx0aXBsZSBsaW5rZWQgZG9jdW1lbnRzLiBJdCBpc1xuICAvLyBpbXBsZW1lbnRlZCBhcyBhIG1ldGEtbWFya2VyLW9iamVjdCBjb250cm9sbGluZyBtdWx0aXBsZSBub3JtYWxcbiAgLy8gbWFya2Vycy5cbiAgdmFyIFNoYXJlZFRleHRNYXJrZXIgPSBmdW5jdGlvbihtYXJrZXJzLCBwcmltYXJ5KSB7XG4gICAgdGhpcy5tYXJrZXJzID0gbWFya2VycztcbiAgICB0aGlzLnByaW1hcnkgPSBwcmltYXJ5O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWFya2Vycy5sZW5ndGg7ICsraSlcbiAgICAgIHsgbWFya2Vyc1tpXS5wYXJlbnQgPSB0aGlzOyB9XG4gIH07XG5cbiAgU2hhcmVkVGV4dE1hcmtlci5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuZXhwbGljaXRseUNsZWFyZWQpIHsgcmV0dXJuIH1cbiAgICB0aGlzLmV4cGxpY2l0bHlDbGVhcmVkID0gdHJ1ZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubWFya2Vycy5sZW5ndGg7ICsraSlcbiAgICAgIHsgdGhpcy5tYXJrZXJzW2ldLmNsZWFyKCk7IH1cbiAgICBzaWduYWxMYXRlcih0aGlzLCBcImNsZWFyXCIpO1xuICB9O1xuXG4gIFNoYXJlZFRleHRNYXJrZXIucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbiAoc2lkZSwgbGluZU9iaikge1xuICAgIHJldHVybiB0aGlzLnByaW1hcnkuZmluZChzaWRlLCBsaW5lT2JqKVxuICB9O1xuICBldmVudE1peGluKFNoYXJlZFRleHRNYXJrZXIpO1xuXG4gIGZ1bmN0aW9uIG1hcmtUZXh0U2hhcmVkKGRvYywgZnJvbSwgdG8sIG9wdGlvbnMsIHR5cGUpIHtcbiAgICBvcHRpb25zID0gY29weU9iaihvcHRpb25zKTtcbiAgICBvcHRpb25zLnNoYXJlZCA9IGZhbHNlO1xuICAgIHZhciBtYXJrZXJzID0gW21hcmtUZXh0KGRvYywgZnJvbSwgdG8sIG9wdGlvbnMsIHR5cGUpXSwgcHJpbWFyeSA9IG1hcmtlcnNbMF07XG4gICAgdmFyIHdpZGdldCA9IG9wdGlvbnMud2lkZ2V0Tm9kZTtcbiAgICBsaW5rZWREb2NzKGRvYywgZnVuY3Rpb24gKGRvYykge1xuICAgICAgaWYgKHdpZGdldCkgeyBvcHRpb25zLndpZGdldE5vZGUgPSB3aWRnZXQuY2xvbmVOb2RlKHRydWUpOyB9XG4gICAgICBtYXJrZXJzLnB1c2gobWFya1RleHQoZG9jLCBjbGlwUG9zKGRvYywgZnJvbSksIGNsaXBQb3MoZG9jLCB0byksIG9wdGlvbnMsIHR5cGUpKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZG9jLmxpbmtlZC5sZW5ndGg7ICsraSlcbiAgICAgICAgeyBpZiAoZG9jLmxpbmtlZFtpXS5pc1BhcmVudCkgeyByZXR1cm4gfSB9XG4gICAgICBwcmltYXJ5ID0gbHN0KG1hcmtlcnMpO1xuICAgIH0pO1xuICAgIHJldHVybiBuZXcgU2hhcmVkVGV4dE1hcmtlcihtYXJrZXJzLCBwcmltYXJ5KVxuICB9XG5cbiAgZnVuY3Rpb24gZmluZFNoYXJlZE1hcmtlcnMoZG9jKSB7XG4gICAgcmV0dXJuIGRvYy5maW5kTWFya3MoUG9zKGRvYy5maXJzdCwgMCksIGRvYy5jbGlwUG9zKFBvcyhkb2MubGFzdExpbmUoKSkpLCBmdW5jdGlvbiAobSkgeyByZXR1cm4gbS5wYXJlbnQ7IH0pXG4gIH1cblxuICBmdW5jdGlvbiBjb3B5U2hhcmVkTWFya2Vycyhkb2MsIG1hcmtlcnMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hcmtlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBtYXJrZXIgPSBtYXJrZXJzW2ldLCBwb3MgPSBtYXJrZXIuZmluZCgpO1xuICAgICAgdmFyIG1Gcm9tID0gZG9jLmNsaXBQb3MocG9zLmZyb20pLCBtVG8gPSBkb2MuY2xpcFBvcyhwb3MudG8pO1xuICAgICAgaWYgKGNtcChtRnJvbSwgbVRvKSkge1xuICAgICAgICB2YXIgc3ViTWFyayA9IG1hcmtUZXh0KGRvYywgbUZyb20sIG1UbywgbWFya2VyLnByaW1hcnksIG1hcmtlci5wcmltYXJ5LnR5cGUpO1xuICAgICAgICBtYXJrZXIubWFya2Vycy5wdXNoKHN1Yk1hcmspO1xuICAgICAgICBzdWJNYXJrLnBhcmVudCA9IG1hcmtlcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkZXRhY2hTaGFyZWRNYXJrZXJzKG1hcmtlcnMpIHtcbiAgICB2YXIgbG9vcCA9IGZ1bmN0aW9uICggaSApIHtcbiAgICAgIHZhciBtYXJrZXIgPSBtYXJrZXJzW2ldLCBsaW5rZWQgPSBbbWFya2VyLnByaW1hcnkuZG9jXTtcbiAgICAgIGxpbmtlZERvY3MobWFya2VyLnByaW1hcnkuZG9jLCBmdW5jdGlvbiAoZCkgeyByZXR1cm4gbGlua2VkLnB1c2goZCk7IH0pO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtYXJrZXIubWFya2Vycy5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIgc3ViTWFya2VyID0gbWFya2VyLm1hcmtlcnNbal07XG4gICAgICAgIGlmIChpbmRleE9mKGxpbmtlZCwgc3ViTWFya2VyLmRvYykgPT0gLTEpIHtcbiAgICAgICAgICBzdWJNYXJrZXIucGFyZW50ID0gbnVsbDtcbiAgICAgICAgICBtYXJrZXIubWFya2Vycy5zcGxpY2Uoai0tLCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hcmtlcnMubGVuZ3RoOyBpKyspIGxvb3AoIGkgKTtcbiAgfVxuXG4gIHZhciBuZXh0RG9jSWQgPSAwO1xuICB2YXIgRG9jID0gZnVuY3Rpb24odGV4dCwgbW9kZSwgZmlyc3RMaW5lLCBsaW5lU2VwLCBkaXJlY3Rpb24pIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRG9jKSkgeyByZXR1cm4gbmV3IERvYyh0ZXh0LCBtb2RlLCBmaXJzdExpbmUsIGxpbmVTZXAsIGRpcmVjdGlvbikgfVxuICAgIGlmIChmaXJzdExpbmUgPT0gbnVsbCkgeyBmaXJzdExpbmUgPSAwOyB9XG5cbiAgICBCcmFuY2hDaHVuay5jYWxsKHRoaXMsIFtuZXcgTGVhZkNodW5rKFtuZXcgTGluZShcIlwiLCBudWxsKV0pXSk7XG4gICAgdGhpcy5maXJzdCA9IGZpcnN0TGluZTtcbiAgICB0aGlzLnNjcm9sbFRvcCA9IHRoaXMuc2Nyb2xsTGVmdCA9IDA7XG4gICAgdGhpcy5jYW50RWRpdCA9IGZhbHNlO1xuICAgIHRoaXMuY2xlYW5HZW5lcmF0aW9uID0gMTtcbiAgICB0aGlzLm1vZGVGcm9udGllciA9IHRoaXMuaGlnaGxpZ2h0RnJvbnRpZXIgPSBmaXJzdExpbmU7XG4gICAgdmFyIHN0YXJ0ID0gUG9zKGZpcnN0TGluZSwgMCk7XG4gICAgdGhpcy5zZWwgPSBzaW1wbGVTZWxlY3Rpb24oc3RhcnQpO1xuICAgIHRoaXMuaGlzdG9yeSA9IG5ldyBIaXN0b3J5KG51bGwpO1xuICAgIHRoaXMuaWQgPSArK25leHREb2NJZDtcbiAgICB0aGlzLm1vZGVPcHRpb24gPSBtb2RlO1xuICAgIHRoaXMubGluZVNlcCA9IGxpbmVTZXA7XG4gICAgdGhpcy5kaXJlY3Rpb24gPSAoZGlyZWN0aW9uID09IFwicnRsXCIpID8gXCJydGxcIiA6IFwibHRyXCI7XG4gICAgdGhpcy5leHRlbmQgPSBmYWxzZTtcblxuICAgIGlmICh0eXBlb2YgdGV4dCA9PSBcInN0cmluZ1wiKSB7IHRleHQgPSB0aGlzLnNwbGl0TGluZXModGV4dCk7IH1cbiAgICB1cGRhdGVEb2ModGhpcywge2Zyb206IHN0YXJ0LCB0bzogc3RhcnQsIHRleHQ6IHRleHR9KTtcbiAgICBzZXRTZWxlY3Rpb24odGhpcywgc2ltcGxlU2VsZWN0aW9uKHN0YXJ0KSwgc2VsX2RvbnRTY3JvbGwpO1xuICB9O1xuXG4gIERvYy5wcm90b3R5cGUgPSBjcmVhdGVPYmooQnJhbmNoQ2h1bmsucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IERvYyxcbiAgICAvLyBJdGVyYXRlIG92ZXIgdGhlIGRvY3VtZW50LiBTdXBwb3J0cyB0d28gZm9ybXMgLS0gd2l0aCBvbmx5IG9uZVxuICAgIC8vIGFyZ3VtZW50LCBpdCBjYWxscyB0aGF0IGZvciBlYWNoIGxpbmUgaW4gdGhlIGRvY3VtZW50LiBXaXRoXG4gICAgLy8gdGhyZWUsIGl0IGl0ZXJhdGVzIG92ZXIgdGhlIHJhbmdlIGdpdmVuIGJ5IHRoZSBmaXJzdCB0d28gKHdpdGhcbiAgICAvLyB0aGUgc2Vjb25kIGJlaW5nIG5vbi1pbmNsdXNpdmUpLlxuICAgIGl0ZXI6IGZ1bmN0aW9uKGZyb20sIHRvLCBvcCkge1xuICAgICAgaWYgKG9wKSB7IHRoaXMuaXRlck4oZnJvbSAtIHRoaXMuZmlyc3QsIHRvIC0gZnJvbSwgb3ApOyB9XG4gICAgICBlbHNlIHsgdGhpcy5pdGVyTih0aGlzLmZpcnN0LCB0aGlzLmZpcnN0ICsgdGhpcy5zaXplLCBmcm9tKTsgfVxuICAgIH0sXG5cbiAgICAvLyBOb24tcHVibGljIGludGVyZmFjZSBmb3IgYWRkaW5nIGFuZCByZW1vdmluZyBsaW5lcy5cbiAgICBpbnNlcnQ6IGZ1bmN0aW9uKGF0LCBsaW5lcykge1xuICAgICAgdmFyIGhlaWdodCA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgKytpKSB7IGhlaWdodCArPSBsaW5lc1tpXS5oZWlnaHQ7IH1cbiAgICAgIHRoaXMuaW5zZXJ0SW5uZXIoYXQgLSB0aGlzLmZpcnN0LCBsaW5lcywgaGVpZ2h0KTtcbiAgICB9LFxuICAgIHJlbW92ZTogZnVuY3Rpb24oYXQsIG4pIHsgdGhpcy5yZW1vdmVJbm5lcihhdCAtIHRoaXMuZmlyc3QsIG4pOyB9LFxuXG4gICAgLy8gRnJvbSBoZXJlLCB0aGUgbWV0aG9kcyBhcmUgcGFydCBvZiB0aGUgcHVibGljIGludGVyZmFjZS4gTW9zdFxuICAgIC8vIGFyZSBhbHNvIGF2YWlsYWJsZSBmcm9tIENvZGVNaXJyb3IgKGVkaXRvcikgaW5zdGFuY2VzLlxuXG4gICAgZ2V0VmFsdWU6IGZ1bmN0aW9uKGxpbmVTZXApIHtcbiAgICAgIHZhciBsaW5lcyA9IGdldExpbmVzKHRoaXMsIHRoaXMuZmlyc3QsIHRoaXMuZmlyc3QgKyB0aGlzLnNpemUpO1xuICAgICAgaWYgKGxpbmVTZXAgPT09IGZhbHNlKSB7IHJldHVybiBsaW5lcyB9XG4gICAgICByZXR1cm4gbGluZXMuam9pbihsaW5lU2VwIHx8IHRoaXMubGluZVNlcGFyYXRvcigpKVxuICAgIH0sXG4gICAgc2V0VmFsdWU6IGRvY01ldGhvZE9wKGZ1bmN0aW9uKGNvZGUpIHtcbiAgICAgIHZhciB0b3AgPSBQb3ModGhpcy5maXJzdCwgMCksIGxhc3QgPSB0aGlzLmZpcnN0ICsgdGhpcy5zaXplIC0gMTtcbiAgICAgIG1ha2VDaGFuZ2UodGhpcywge2Zyb206IHRvcCwgdG86IFBvcyhsYXN0LCBnZXRMaW5lKHRoaXMsIGxhc3QpLnRleHQubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IHRoaXMuc3BsaXRMaW5lcyhjb2RlKSwgb3JpZ2luOiBcInNldFZhbHVlXCIsIGZ1bGw6IHRydWV9LCB0cnVlKTtcbiAgICAgIGlmICh0aGlzLmNtKSB7IHNjcm9sbFRvQ29vcmRzKHRoaXMuY20sIDAsIDApOyB9XG4gICAgICBzZXRTZWxlY3Rpb24odGhpcywgc2ltcGxlU2VsZWN0aW9uKHRvcCksIHNlbF9kb250U2Nyb2xsKTtcbiAgICB9KSxcbiAgICByZXBsYWNlUmFuZ2U6IGZ1bmN0aW9uKGNvZGUsIGZyb20sIHRvLCBvcmlnaW4pIHtcbiAgICAgIGZyb20gPSBjbGlwUG9zKHRoaXMsIGZyb20pO1xuICAgICAgdG8gPSB0byA/IGNsaXBQb3ModGhpcywgdG8pIDogZnJvbTtcbiAgICAgIHJlcGxhY2VSYW5nZSh0aGlzLCBjb2RlLCBmcm9tLCB0bywgb3JpZ2luKTtcbiAgICB9LFxuICAgIGdldFJhbmdlOiBmdW5jdGlvbihmcm9tLCB0bywgbGluZVNlcCkge1xuICAgICAgdmFyIGxpbmVzID0gZ2V0QmV0d2Vlbih0aGlzLCBjbGlwUG9zKHRoaXMsIGZyb20pLCBjbGlwUG9zKHRoaXMsIHRvKSk7XG4gICAgICBpZiAobGluZVNlcCA9PT0gZmFsc2UpIHsgcmV0dXJuIGxpbmVzIH1cbiAgICAgIHJldHVybiBsaW5lcy5qb2luKGxpbmVTZXAgfHwgdGhpcy5saW5lU2VwYXJhdG9yKCkpXG4gICAgfSxcblxuICAgIGdldExpbmU6IGZ1bmN0aW9uKGxpbmUpIHt2YXIgbCA9IHRoaXMuZ2V0TGluZUhhbmRsZShsaW5lKTsgcmV0dXJuIGwgJiYgbC50ZXh0fSxcblxuICAgIGdldExpbmVIYW5kbGU6IGZ1bmN0aW9uKGxpbmUpIHtpZiAoaXNMaW5lKHRoaXMsIGxpbmUpKSB7IHJldHVybiBnZXRMaW5lKHRoaXMsIGxpbmUpIH19LFxuICAgIGdldExpbmVOdW1iZXI6IGZ1bmN0aW9uKGxpbmUpIHtyZXR1cm4gbGluZU5vKGxpbmUpfSxcblxuICAgIGdldExpbmVIYW5kbGVWaXN1YWxTdGFydDogZnVuY3Rpb24obGluZSkge1xuICAgICAgaWYgKHR5cGVvZiBsaW5lID09IFwibnVtYmVyXCIpIHsgbGluZSA9IGdldExpbmUodGhpcywgbGluZSk7IH1cbiAgICAgIHJldHVybiB2aXN1YWxMaW5lKGxpbmUpXG4gICAgfSxcblxuICAgIGxpbmVDb3VudDogZnVuY3Rpb24oKSB7cmV0dXJuIHRoaXMuc2l6ZX0sXG4gICAgZmlyc3RMaW5lOiBmdW5jdGlvbigpIHtyZXR1cm4gdGhpcy5maXJzdH0sXG4gICAgbGFzdExpbmU6IGZ1bmN0aW9uKCkge3JldHVybiB0aGlzLmZpcnN0ICsgdGhpcy5zaXplIC0gMX0sXG5cbiAgICBjbGlwUG9zOiBmdW5jdGlvbihwb3MpIHtyZXR1cm4gY2xpcFBvcyh0aGlzLCBwb3MpfSxcblxuICAgIGdldEN1cnNvcjogZnVuY3Rpb24oc3RhcnQpIHtcbiAgICAgIHZhciByYW5nZSA9IHRoaXMuc2VsLnByaW1hcnkoKSwgcG9zO1xuICAgICAgaWYgKHN0YXJ0ID09IG51bGwgfHwgc3RhcnQgPT0gXCJoZWFkXCIpIHsgcG9zID0gcmFuZ2UuaGVhZDsgfVxuICAgICAgZWxzZSBpZiAoc3RhcnQgPT0gXCJhbmNob3JcIikgeyBwb3MgPSByYW5nZS5hbmNob3I7IH1cbiAgICAgIGVsc2UgaWYgKHN0YXJ0ID09IFwiZW5kXCIgfHwgc3RhcnQgPT0gXCJ0b1wiIHx8IHN0YXJ0ID09PSBmYWxzZSkgeyBwb3MgPSByYW5nZS50bygpOyB9XG4gICAgICBlbHNlIHsgcG9zID0gcmFuZ2UuZnJvbSgpOyB9XG4gICAgICByZXR1cm4gcG9zXG4gICAgfSxcbiAgICBsaXN0U2VsZWN0aW9uczogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnNlbC5yYW5nZXMgfSxcbiAgICBzb21ldGhpbmdTZWxlY3RlZDogZnVuY3Rpb24oKSB7cmV0dXJuIHRoaXMuc2VsLnNvbWV0aGluZ1NlbGVjdGVkKCl9LFxuXG4gICAgc2V0Q3Vyc29yOiBkb2NNZXRob2RPcChmdW5jdGlvbihsaW5lLCBjaCwgb3B0aW9ucykge1xuICAgICAgc2V0U2ltcGxlU2VsZWN0aW9uKHRoaXMsIGNsaXBQb3ModGhpcywgdHlwZW9mIGxpbmUgPT0gXCJudW1iZXJcIiA/IFBvcyhsaW5lLCBjaCB8fCAwKSA6IGxpbmUpLCBudWxsLCBvcHRpb25zKTtcbiAgICB9KSxcbiAgICBzZXRTZWxlY3Rpb246IGRvY01ldGhvZE9wKGZ1bmN0aW9uKGFuY2hvciwgaGVhZCwgb3B0aW9ucykge1xuICAgICAgc2V0U2ltcGxlU2VsZWN0aW9uKHRoaXMsIGNsaXBQb3ModGhpcywgYW5jaG9yKSwgY2xpcFBvcyh0aGlzLCBoZWFkIHx8IGFuY2hvciksIG9wdGlvbnMpO1xuICAgIH0pLFxuICAgIGV4dGVuZFNlbGVjdGlvbjogZG9jTWV0aG9kT3AoZnVuY3Rpb24oaGVhZCwgb3RoZXIsIG9wdGlvbnMpIHtcbiAgICAgIGV4dGVuZFNlbGVjdGlvbih0aGlzLCBjbGlwUG9zKHRoaXMsIGhlYWQpLCBvdGhlciAmJiBjbGlwUG9zKHRoaXMsIG90aGVyKSwgb3B0aW9ucyk7XG4gICAgfSksXG4gICAgZXh0ZW5kU2VsZWN0aW9uczogZG9jTWV0aG9kT3AoZnVuY3Rpb24oaGVhZHMsIG9wdGlvbnMpIHtcbiAgICAgIGV4dGVuZFNlbGVjdGlvbnModGhpcywgY2xpcFBvc0FycmF5KHRoaXMsIGhlYWRzKSwgb3B0aW9ucyk7XG4gICAgfSksXG4gICAgZXh0ZW5kU2VsZWN0aW9uc0J5OiBkb2NNZXRob2RPcChmdW5jdGlvbihmLCBvcHRpb25zKSB7XG4gICAgICB2YXIgaGVhZHMgPSBtYXAodGhpcy5zZWwucmFuZ2VzLCBmKTtcbiAgICAgIGV4dGVuZFNlbGVjdGlvbnModGhpcywgY2xpcFBvc0FycmF5KHRoaXMsIGhlYWRzKSwgb3B0aW9ucyk7XG4gICAgfSksXG4gICAgc2V0U2VsZWN0aW9uczogZG9jTWV0aG9kT3AoZnVuY3Rpb24ocmFuZ2VzLCBwcmltYXJ5LCBvcHRpb25zKSB7XG4gICAgICBpZiAoIXJhbmdlcy5sZW5ndGgpIHsgcmV0dXJuIH1cbiAgICAgIHZhciBvdXQgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKVxuICAgICAgICB7IG91dFtpXSA9IG5ldyBSYW5nZShjbGlwUG9zKHRoaXMsIHJhbmdlc1tpXS5hbmNob3IpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpcFBvcyh0aGlzLCByYW5nZXNbaV0uaGVhZCkpOyB9XG4gICAgICBpZiAocHJpbWFyeSA9PSBudWxsKSB7IHByaW1hcnkgPSBNYXRoLm1pbihyYW5nZXMubGVuZ3RoIC0gMSwgdGhpcy5zZWwucHJpbUluZGV4KTsgfVxuICAgICAgc2V0U2VsZWN0aW9uKHRoaXMsIG5vcm1hbGl6ZVNlbGVjdGlvbih0aGlzLmNtLCBvdXQsIHByaW1hcnkpLCBvcHRpb25zKTtcbiAgICB9KSxcbiAgICBhZGRTZWxlY3Rpb246IGRvY01ldGhvZE9wKGZ1bmN0aW9uKGFuY2hvciwgaGVhZCwgb3B0aW9ucykge1xuICAgICAgdmFyIHJhbmdlcyA9IHRoaXMuc2VsLnJhbmdlcy5zbGljZSgwKTtcbiAgICAgIHJhbmdlcy5wdXNoKG5ldyBSYW5nZShjbGlwUG9zKHRoaXMsIGFuY2hvciksIGNsaXBQb3ModGhpcywgaGVhZCB8fCBhbmNob3IpKSk7XG4gICAgICBzZXRTZWxlY3Rpb24odGhpcywgbm9ybWFsaXplU2VsZWN0aW9uKHRoaXMuY20sIHJhbmdlcywgcmFuZ2VzLmxlbmd0aCAtIDEpLCBvcHRpb25zKTtcbiAgICB9KSxcblxuICAgIGdldFNlbGVjdGlvbjogZnVuY3Rpb24obGluZVNlcCkge1xuICAgICAgdmFyIHJhbmdlcyA9IHRoaXMuc2VsLnJhbmdlcywgbGluZXM7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc2VsID0gZ2V0QmV0d2Vlbih0aGlzLCByYW5nZXNbaV0uZnJvbSgpLCByYW5nZXNbaV0udG8oKSk7XG4gICAgICAgIGxpbmVzID0gbGluZXMgPyBsaW5lcy5jb25jYXQoc2VsKSA6IHNlbDtcbiAgICAgIH1cbiAgICAgIGlmIChsaW5lU2VwID09PSBmYWxzZSkgeyByZXR1cm4gbGluZXMgfVxuICAgICAgZWxzZSB7IHJldHVybiBsaW5lcy5qb2luKGxpbmVTZXAgfHwgdGhpcy5saW5lU2VwYXJhdG9yKCkpIH1cbiAgICB9LFxuICAgIGdldFNlbGVjdGlvbnM6IGZ1bmN0aW9uKGxpbmVTZXApIHtcbiAgICAgIHZhciBwYXJ0cyA9IFtdLCByYW5nZXMgPSB0aGlzLnNlbC5yYW5nZXM7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc2VsID0gZ2V0QmV0d2Vlbih0aGlzLCByYW5nZXNbaV0uZnJvbSgpLCByYW5nZXNbaV0udG8oKSk7XG4gICAgICAgIGlmIChsaW5lU2VwICE9PSBmYWxzZSkgeyBzZWwgPSBzZWwuam9pbihsaW5lU2VwIHx8IHRoaXMubGluZVNlcGFyYXRvcigpKTsgfVxuICAgICAgICBwYXJ0c1tpXSA9IHNlbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJ0c1xuICAgIH0sXG4gICAgcmVwbGFjZVNlbGVjdGlvbjogZnVuY3Rpb24oY29kZSwgY29sbGFwc2UsIG9yaWdpbikge1xuICAgICAgdmFyIGR1cCA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnNlbC5yYW5nZXMubGVuZ3RoOyBpKyspXG4gICAgICAgIHsgZHVwW2ldID0gY29kZTsgfVxuICAgICAgdGhpcy5yZXBsYWNlU2VsZWN0aW9ucyhkdXAsIGNvbGxhcHNlLCBvcmlnaW4gfHwgXCIraW5wdXRcIik7XG4gICAgfSxcbiAgICByZXBsYWNlU2VsZWN0aW9uczogZG9jTWV0aG9kT3AoZnVuY3Rpb24oY29kZSwgY29sbGFwc2UsIG9yaWdpbikge1xuICAgICAgdmFyIGNoYW5nZXMgPSBbXSwgc2VsID0gdGhpcy5zZWw7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbC5yYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHJhbmdlID0gc2VsLnJhbmdlc1tpXTtcbiAgICAgICAgY2hhbmdlc1tpXSA9IHtmcm9tOiByYW5nZS5mcm9tKCksIHRvOiByYW5nZS50bygpLCB0ZXh0OiB0aGlzLnNwbGl0TGluZXMoY29kZVtpXSksIG9yaWdpbjogb3JpZ2lufTtcbiAgICAgIH1cbiAgICAgIHZhciBuZXdTZWwgPSBjb2xsYXBzZSAmJiBjb2xsYXBzZSAhPSBcImVuZFwiICYmIGNvbXB1dGVSZXBsYWNlZFNlbCh0aGlzLCBjaGFuZ2VzLCBjb2xsYXBzZSk7XG4gICAgICBmb3IgKHZhciBpJDEgPSBjaGFuZ2VzLmxlbmd0aCAtIDE7IGkkMSA+PSAwOyBpJDEtLSlcbiAgICAgICAgeyBtYWtlQ2hhbmdlKHRoaXMsIGNoYW5nZXNbaSQxXSk7IH1cbiAgICAgIGlmIChuZXdTZWwpIHsgc2V0U2VsZWN0aW9uUmVwbGFjZUhpc3RvcnkodGhpcywgbmV3U2VsKTsgfVxuICAgICAgZWxzZSBpZiAodGhpcy5jbSkgeyBlbnN1cmVDdXJzb3JWaXNpYmxlKHRoaXMuY20pOyB9XG4gICAgfSksXG4gICAgdW5kbzogZG9jTWV0aG9kT3AoZnVuY3Rpb24oKSB7bWFrZUNoYW5nZUZyb21IaXN0b3J5KHRoaXMsIFwidW5kb1wiKTt9KSxcbiAgICByZWRvOiBkb2NNZXRob2RPcChmdW5jdGlvbigpIHttYWtlQ2hhbmdlRnJvbUhpc3RvcnkodGhpcywgXCJyZWRvXCIpO30pLFxuICAgIHVuZG9TZWxlY3Rpb246IGRvY01ldGhvZE9wKGZ1bmN0aW9uKCkge21ha2VDaGFuZ2VGcm9tSGlzdG9yeSh0aGlzLCBcInVuZG9cIiwgdHJ1ZSk7fSksXG4gICAgcmVkb1NlbGVjdGlvbjogZG9jTWV0aG9kT3AoZnVuY3Rpb24oKSB7bWFrZUNoYW5nZUZyb21IaXN0b3J5KHRoaXMsIFwicmVkb1wiLCB0cnVlKTt9KSxcblxuICAgIHNldEV4dGVuZGluZzogZnVuY3Rpb24odmFsKSB7dGhpcy5leHRlbmQgPSB2YWw7fSxcbiAgICBnZXRFeHRlbmRpbmc6IGZ1bmN0aW9uKCkge3JldHVybiB0aGlzLmV4dGVuZH0sXG5cbiAgICBoaXN0b3J5U2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaGlzdCA9IHRoaXMuaGlzdG9yeSwgZG9uZSA9IDAsIHVuZG9uZSA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhpc3QuZG9uZS5sZW5ndGg7IGkrKykgeyBpZiAoIWhpc3QuZG9uZVtpXS5yYW5nZXMpIHsgKytkb25lOyB9IH1cbiAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGhpc3QudW5kb25lLmxlbmd0aDsgaSQxKyspIHsgaWYgKCFoaXN0LnVuZG9uZVtpJDFdLnJhbmdlcykgeyArK3VuZG9uZTsgfSB9XG4gICAgICByZXR1cm4ge3VuZG86IGRvbmUsIHJlZG86IHVuZG9uZX1cbiAgICB9LFxuICAgIGNsZWFySGlzdG9yeTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgdGhpcy5oaXN0b3J5ID0gbmV3IEhpc3RvcnkodGhpcy5oaXN0b3J5Lm1heEdlbmVyYXRpb24pO1xuICAgICAgbGlua2VkRG9jcyh0aGlzLCBmdW5jdGlvbiAoZG9jKSB7IHJldHVybiBkb2MuaGlzdG9yeSA9IHRoaXMkMS5oaXN0b3J5OyB9LCB0cnVlKTtcbiAgICB9LFxuXG4gICAgbWFya0NsZWFuOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuY2xlYW5HZW5lcmF0aW9uID0gdGhpcy5jaGFuZ2VHZW5lcmF0aW9uKHRydWUpO1xuICAgIH0sXG4gICAgY2hhbmdlR2VuZXJhdGlvbjogZnVuY3Rpb24oZm9yY2VTcGxpdCkge1xuICAgICAgaWYgKGZvcmNlU3BsaXQpXG4gICAgICAgIHsgdGhpcy5oaXN0b3J5Lmxhc3RPcCA9IHRoaXMuaGlzdG9yeS5sYXN0U2VsT3AgPSB0aGlzLmhpc3RvcnkubGFzdE9yaWdpbiA9IG51bGw7IH1cbiAgICAgIHJldHVybiB0aGlzLmhpc3RvcnkuZ2VuZXJhdGlvblxuICAgIH0sXG4gICAgaXNDbGVhbjogZnVuY3Rpb24gKGdlbikge1xuICAgICAgcmV0dXJuIHRoaXMuaGlzdG9yeS5nZW5lcmF0aW9uID09IChnZW4gfHwgdGhpcy5jbGVhbkdlbmVyYXRpb24pXG4gICAgfSxcblxuICAgIGdldEhpc3Rvcnk6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHtkb25lOiBjb3B5SGlzdG9yeUFycmF5KHRoaXMuaGlzdG9yeS5kb25lKSxcbiAgICAgICAgICAgICAgdW5kb25lOiBjb3B5SGlzdG9yeUFycmF5KHRoaXMuaGlzdG9yeS51bmRvbmUpfVxuICAgIH0sXG4gICAgc2V0SGlzdG9yeTogZnVuY3Rpb24oaGlzdERhdGEpIHtcbiAgICAgIHZhciBoaXN0ID0gdGhpcy5oaXN0b3J5ID0gbmV3IEhpc3RvcnkodGhpcy5oaXN0b3J5Lm1heEdlbmVyYXRpb24pO1xuICAgICAgaGlzdC5kb25lID0gY29weUhpc3RvcnlBcnJheShoaXN0RGF0YS5kb25lLnNsaWNlKDApLCBudWxsLCB0cnVlKTtcbiAgICAgIGhpc3QudW5kb25lID0gY29weUhpc3RvcnlBcnJheShoaXN0RGF0YS51bmRvbmUuc2xpY2UoMCksIG51bGwsIHRydWUpO1xuICAgIH0sXG5cbiAgICBzZXRHdXR0ZXJNYXJrZXI6IGRvY01ldGhvZE9wKGZ1bmN0aW9uKGxpbmUsIGd1dHRlcklELCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIGNoYW5nZUxpbmUodGhpcywgbGluZSwgXCJndXR0ZXJcIiwgZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgdmFyIG1hcmtlcnMgPSBsaW5lLmd1dHRlck1hcmtlcnMgfHwgKGxpbmUuZ3V0dGVyTWFya2VycyA9IHt9KTtcbiAgICAgICAgbWFya2Vyc1tndXR0ZXJJRF0gPSB2YWx1ZTtcbiAgICAgICAgaWYgKCF2YWx1ZSAmJiBpc0VtcHR5KG1hcmtlcnMpKSB7IGxpbmUuZ3V0dGVyTWFya2VycyA9IG51bGw7IH1cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH0pXG4gICAgfSksXG5cbiAgICBjbGVhckd1dHRlcjogZG9jTWV0aG9kT3AoZnVuY3Rpb24oZ3V0dGVySUQpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgICB0aGlzLml0ZXIoZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgaWYgKGxpbmUuZ3V0dGVyTWFya2VycyAmJiBsaW5lLmd1dHRlck1hcmtlcnNbZ3V0dGVySURdKSB7XG4gICAgICAgICAgY2hhbmdlTGluZSh0aGlzJDEsIGxpbmUsIFwiZ3V0dGVyXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGxpbmUuZ3V0dGVyTWFya2Vyc1tndXR0ZXJJRF0gPSBudWxsO1xuICAgICAgICAgICAgaWYgKGlzRW1wdHkobGluZS5ndXR0ZXJNYXJrZXJzKSkgeyBsaW5lLmd1dHRlck1hcmtlcnMgPSBudWxsOyB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KSxcblxuICAgIGxpbmVJbmZvOiBmdW5jdGlvbihsaW5lKSB7XG4gICAgICB2YXIgbjtcbiAgICAgIGlmICh0eXBlb2YgbGluZSA9PSBcIm51bWJlclwiKSB7XG4gICAgICAgIGlmICghaXNMaW5lKHRoaXMsIGxpbmUpKSB7IHJldHVybiBudWxsIH1cbiAgICAgICAgbiA9IGxpbmU7XG4gICAgICAgIGxpbmUgPSBnZXRMaW5lKHRoaXMsIGxpbmUpO1xuICAgICAgICBpZiAoIWxpbmUpIHsgcmV0dXJuIG51bGwgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbiA9IGxpbmVObyhsaW5lKTtcbiAgICAgICAgaWYgKG4gPT0gbnVsbCkgeyByZXR1cm4gbnVsbCB9XG4gICAgICB9XG4gICAgICByZXR1cm4ge2xpbmU6IG4sIGhhbmRsZTogbGluZSwgdGV4dDogbGluZS50ZXh0LCBndXR0ZXJNYXJrZXJzOiBsaW5lLmd1dHRlck1hcmtlcnMsXG4gICAgICAgICAgICAgIHRleHRDbGFzczogbGluZS50ZXh0Q2xhc3MsIGJnQ2xhc3M6IGxpbmUuYmdDbGFzcywgd3JhcENsYXNzOiBsaW5lLndyYXBDbGFzcyxcbiAgICAgICAgICAgICAgd2lkZ2V0czogbGluZS53aWRnZXRzfVxuICAgIH0sXG5cbiAgICBhZGRMaW5lQ2xhc3M6IGRvY01ldGhvZE9wKGZ1bmN0aW9uKGhhbmRsZSwgd2hlcmUsIGNscykge1xuICAgICAgcmV0dXJuIGNoYW5nZUxpbmUodGhpcywgaGFuZGxlLCB3aGVyZSA9PSBcImd1dHRlclwiID8gXCJndXR0ZXJcIiA6IFwiY2xhc3NcIiwgZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgdmFyIHByb3AgPSB3aGVyZSA9PSBcInRleHRcIiA/IFwidGV4dENsYXNzXCJcbiAgICAgICAgICAgICAgICAgOiB3aGVyZSA9PSBcImJhY2tncm91bmRcIiA/IFwiYmdDbGFzc1wiXG4gICAgICAgICAgICAgICAgIDogd2hlcmUgPT0gXCJndXR0ZXJcIiA/IFwiZ3V0dGVyQ2xhc3NcIiA6IFwid3JhcENsYXNzXCI7XG4gICAgICAgIGlmICghbGluZVtwcm9wXSkgeyBsaW5lW3Byb3BdID0gY2xzOyB9XG4gICAgICAgIGVsc2UgaWYgKGNsYXNzVGVzdChjbHMpLnRlc3QobGluZVtwcm9wXSkpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICAgICAgZWxzZSB7IGxpbmVbcHJvcF0gKz0gXCIgXCIgKyBjbHM7IH1cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH0pXG4gICAgfSksXG4gICAgcmVtb3ZlTGluZUNsYXNzOiBkb2NNZXRob2RPcChmdW5jdGlvbihoYW5kbGUsIHdoZXJlLCBjbHMpIHtcbiAgICAgIHJldHVybiBjaGFuZ2VMaW5lKHRoaXMsIGhhbmRsZSwgd2hlcmUgPT0gXCJndXR0ZXJcIiA/IFwiZ3V0dGVyXCIgOiBcImNsYXNzXCIsIGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgIHZhciBwcm9wID0gd2hlcmUgPT0gXCJ0ZXh0XCIgPyBcInRleHRDbGFzc1wiXG4gICAgICAgICAgICAgICAgIDogd2hlcmUgPT0gXCJiYWNrZ3JvdW5kXCIgPyBcImJnQ2xhc3NcIlxuICAgICAgICAgICAgICAgICA6IHdoZXJlID09IFwiZ3V0dGVyXCIgPyBcImd1dHRlckNsYXNzXCIgOiBcIndyYXBDbGFzc1wiO1xuICAgICAgICB2YXIgY3VyID0gbGluZVtwcm9wXTtcbiAgICAgICAgaWYgKCFjdXIpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICAgICAgZWxzZSBpZiAoY2xzID09IG51bGwpIHsgbGluZVtwcm9wXSA9IG51bGw7IH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFyIGZvdW5kID0gY3VyLm1hdGNoKGNsYXNzVGVzdChjbHMpKTtcbiAgICAgICAgICBpZiAoIWZvdW5kKSB7IHJldHVybiBmYWxzZSB9XG4gICAgICAgICAgdmFyIGVuZCA9IGZvdW5kLmluZGV4ICsgZm91bmRbMF0ubGVuZ3RoO1xuICAgICAgICAgIGxpbmVbcHJvcF0gPSBjdXIuc2xpY2UoMCwgZm91bmQuaW5kZXgpICsgKCFmb3VuZC5pbmRleCB8fCBlbmQgPT0gY3VyLmxlbmd0aCA/IFwiXCIgOiBcIiBcIikgKyBjdXIuc2xpY2UoZW5kKSB8fCBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9KVxuICAgIH0pLFxuXG4gICAgYWRkTGluZVdpZGdldDogZG9jTWV0aG9kT3AoZnVuY3Rpb24oaGFuZGxlLCBub2RlLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gYWRkTGluZVdpZGdldCh0aGlzLCBoYW5kbGUsIG5vZGUsIG9wdGlvbnMpXG4gICAgfSksXG4gICAgcmVtb3ZlTGluZVdpZGdldDogZnVuY3Rpb24od2lkZ2V0KSB7IHdpZGdldC5jbGVhcigpOyB9LFxuXG4gICAgbWFya1RleHQ6IGZ1bmN0aW9uKGZyb20sIHRvLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gbWFya1RleHQodGhpcywgY2xpcFBvcyh0aGlzLCBmcm9tKSwgY2xpcFBvcyh0aGlzLCB0byksIG9wdGlvbnMsIG9wdGlvbnMgJiYgb3B0aW9ucy50eXBlIHx8IFwicmFuZ2VcIilcbiAgICB9LFxuICAgIHNldEJvb2ttYXJrOiBmdW5jdGlvbihwb3MsIG9wdGlvbnMpIHtcbiAgICAgIHZhciByZWFsT3B0cyA9IHtyZXBsYWNlZFdpdGg6IG9wdGlvbnMgJiYgKG9wdGlvbnMubm9kZVR5cGUgPT0gbnVsbCA/IG9wdGlvbnMud2lkZ2V0IDogb3B0aW9ucyksXG4gICAgICAgICAgICAgICAgICAgICAgaW5zZXJ0TGVmdDogb3B0aW9ucyAmJiBvcHRpb25zLmluc2VydExlZnQsXG4gICAgICAgICAgICAgICAgICAgICAgY2xlYXJXaGVuRW1wdHk6IGZhbHNlLCBzaGFyZWQ6IG9wdGlvbnMgJiYgb3B0aW9ucy5zaGFyZWQsXG4gICAgICAgICAgICAgICAgICAgICAgaGFuZGxlTW91c2VFdmVudHM6IG9wdGlvbnMgJiYgb3B0aW9ucy5oYW5kbGVNb3VzZUV2ZW50c307XG4gICAgICBwb3MgPSBjbGlwUG9zKHRoaXMsIHBvcyk7XG4gICAgICByZXR1cm4gbWFya1RleHQodGhpcywgcG9zLCBwb3MsIHJlYWxPcHRzLCBcImJvb2ttYXJrXCIpXG4gICAgfSxcbiAgICBmaW5kTWFya3NBdDogZnVuY3Rpb24ocG9zKSB7XG4gICAgICBwb3MgPSBjbGlwUG9zKHRoaXMsIHBvcyk7XG4gICAgICB2YXIgbWFya2VycyA9IFtdLCBzcGFucyA9IGdldExpbmUodGhpcywgcG9zLmxpbmUpLm1hcmtlZFNwYW5zO1xuICAgICAgaWYgKHNwYW5zKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgc3BhbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHNwYW4gPSBzcGFuc1tpXTtcbiAgICAgICAgaWYgKChzcGFuLmZyb20gPT0gbnVsbCB8fCBzcGFuLmZyb20gPD0gcG9zLmNoKSAmJlxuICAgICAgICAgICAgKHNwYW4udG8gPT0gbnVsbCB8fCBzcGFuLnRvID49IHBvcy5jaCkpXG4gICAgICAgICAgeyBtYXJrZXJzLnB1c2goc3Bhbi5tYXJrZXIucGFyZW50IHx8IHNwYW4ubWFya2VyKTsgfVxuICAgICAgfSB9XG4gICAgICByZXR1cm4gbWFya2Vyc1xuICAgIH0sXG4gICAgZmluZE1hcmtzOiBmdW5jdGlvbihmcm9tLCB0bywgZmlsdGVyKSB7XG4gICAgICBmcm9tID0gY2xpcFBvcyh0aGlzLCBmcm9tKTsgdG8gPSBjbGlwUG9zKHRoaXMsIHRvKTtcbiAgICAgIHZhciBmb3VuZCA9IFtdLCBsaW5lTm8gPSBmcm9tLmxpbmU7XG4gICAgICB0aGlzLml0ZXIoZnJvbS5saW5lLCB0by5saW5lICsgMSwgZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgdmFyIHNwYW5zID0gbGluZS5tYXJrZWRTcGFucztcbiAgICAgICAgaWYgKHNwYW5zKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgc3BhbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgc3BhbiA9IHNwYW5zW2ldO1xuICAgICAgICAgIGlmICghKHNwYW4udG8gIT0gbnVsbCAmJiBsaW5lTm8gPT0gZnJvbS5saW5lICYmIGZyb20uY2ggPj0gc3Bhbi50byB8fFxuICAgICAgICAgICAgICAgIHNwYW4uZnJvbSA9PSBudWxsICYmIGxpbmVObyAhPSBmcm9tLmxpbmUgfHxcbiAgICAgICAgICAgICAgICBzcGFuLmZyb20gIT0gbnVsbCAmJiBsaW5lTm8gPT0gdG8ubGluZSAmJiBzcGFuLmZyb20gPj0gdG8uY2gpICYmXG4gICAgICAgICAgICAgICghZmlsdGVyIHx8IGZpbHRlcihzcGFuLm1hcmtlcikpKVxuICAgICAgICAgICAgeyBmb3VuZC5wdXNoKHNwYW4ubWFya2VyLnBhcmVudCB8fCBzcGFuLm1hcmtlcik7IH1cbiAgICAgICAgfSB9XG4gICAgICAgICsrbGluZU5vO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gZm91bmRcbiAgICB9LFxuICAgIGdldEFsbE1hcmtzOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBtYXJrZXJzID0gW107XG4gICAgICB0aGlzLml0ZXIoZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgdmFyIHNwcyA9IGxpbmUubWFya2VkU3BhbnM7XG4gICAgICAgIGlmIChzcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBzcHMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgeyBpZiAoc3BzW2ldLmZyb20gIT0gbnVsbCkgeyBtYXJrZXJzLnB1c2goc3BzW2ldLm1hcmtlcik7IH0gfSB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBtYXJrZXJzXG4gICAgfSxcblxuICAgIHBvc0Zyb21JbmRleDogZnVuY3Rpb24ob2ZmKSB7XG4gICAgICB2YXIgY2gsIGxpbmVObyA9IHRoaXMuZmlyc3QsIHNlcFNpemUgPSB0aGlzLmxpbmVTZXBhcmF0b3IoKS5sZW5ndGg7XG4gICAgICB0aGlzLml0ZXIoZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgdmFyIHN6ID0gbGluZS50ZXh0Lmxlbmd0aCArIHNlcFNpemU7XG4gICAgICAgIGlmIChzeiA+IG9mZikgeyBjaCA9IG9mZjsgcmV0dXJuIHRydWUgfVxuICAgICAgICBvZmYgLT0gc3o7XG4gICAgICAgICsrbGluZU5vO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gY2xpcFBvcyh0aGlzLCBQb3MobGluZU5vLCBjaCkpXG4gICAgfSxcbiAgICBpbmRleEZyb21Qb3M6IGZ1bmN0aW9uIChjb29yZHMpIHtcbiAgICAgIGNvb3JkcyA9IGNsaXBQb3ModGhpcywgY29vcmRzKTtcbiAgICAgIHZhciBpbmRleCA9IGNvb3Jkcy5jaDtcbiAgICAgIGlmIChjb29yZHMubGluZSA8IHRoaXMuZmlyc3QgfHwgY29vcmRzLmNoIDwgMCkgeyByZXR1cm4gMCB9XG4gICAgICB2YXIgc2VwU2l6ZSA9IHRoaXMubGluZVNlcGFyYXRvcigpLmxlbmd0aDtcbiAgICAgIHRoaXMuaXRlcih0aGlzLmZpcnN0LCBjb29yZHMubGluZSwgZnVuY3Rpb24gKGxpbmUpIHsgLy8gaXRlciBhYm9ydHMgd2hlbiBjYWxsYmFjayByZXR1cm5zIGEgdHJ1dGh5IHZhbHVlXG4gICAgICAgIGluZGV4ICs9IGxpbmUudGV4dC5sZW5ndGggKyBzZXBTaXplO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gaW5kZXhcbiAgICB9LFxuXG4gICAgY29weTogZnVuY3Rpb24oY29weUhpc3RvcnkpIHtcbiAgICAgIHZhciBkb2MgPSBuZXcgRG9jKGdldExpbmVzKHRoaXMsIHRoaXMuZmlyc3QsIHRoaXMuZmlyc3QgKyB0aGlzLnNpemUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tb2RlT3B0aW9uLCB0aGlzLmZpcnN0LCB0aGlzLmxpbmVTZXAsIHRoaXMuZGlyZWN0aW9uKTtcbiAgICAgIGRvYy5zY3JvbGxUb3AgPSB0aGlzLnNjcm9sbFRvcDsgZG9jLnNjcm9sbExlZnQgPSB0aGlzLnNjcm9sbExlZnQ7XG4gICAgICBkb2Muc2VsID0gdGhpcy5zZWw7XG4gICAgICBkb2MuZXh0ZW5kID0gZmFsc2U7XG4gICAgICBpZiAoY29weUhpc3RvcnkpIHtcbiAgICAgICAgZG9jLmhpc3RvcnkudW5kb0RlcHRoID0gdGhpcy5oaXN0b3J5LnVuZG9EZXB0aDtcbiAgICAgICAgZG9jLnNldEhpc3RvcnkodGhpcy5nZXRIaXN0b3J5KCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRvY1xuICAgIH0sXG5cbiAgICBsaW5rZWREb2M6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIGlmICghb3B0aW9ucykgeyBvcHRpb25zID0ge307IH1cbiAgICAgIHZhciBmcm9tID0gdGhpcy5maXJzdCwgdG8gPSB0aGlzLmZpcnN0ICsgdGhpcy5zaXplO1xuICAgICAgaWYgKG9wdGlvbnMuZnJvbSAhPSBudWxsICYmIG9wdGlvbnMuZnJvbSA+IGZyb20pIHsgZnJvbSA9IG9wdGlvbnMuZnJvbTsgfVxuICAgICAgaWYgKG9wdGlvbnMudG8gIT0gbnVsbCAmJiBvcHRpb25zLnRvIDwgdG8pIHsgdG8gPSBvcHRpb25zLnRvOyB9XG4gICAgICB2YXIgY29weSA9IG5ldyBEb2MoZ2V0TGluZXModGhpcywgZnJvbSwgdG8pLCBvcHRpb25zLm1vZGUgfHwgdGhpcy5tb2RlT3B0aW9uLCBmcm9tLCB0aGlzLmxpbmVTZXAsIHRoaXMuZGlyZWN0aW9uKTtcbiAgICAgIGlmIChvcHRpb25zLnNoYXJlZEhpc3QpIHsgY29weS5oaXN0b3J5ID0gdGhpcy5oaXN0b3J5XG4gICAgICA7IH0odGhpcy5saW5rZWQgfHwgKHRoaXMubGlua2VkID0gW10pKS5wdXNoKHtkb2M6IGNvcHksIHNoYXJlZEhpc3Q6IG9wdGlvbnMuc2hhcmVkSGlzdH0pO1xuICAgICAgY29weS5saW5rZWQgPSBbe2RvYzogdGhpcywgaXNQYXJlbnQ6IHRydWUsIHNoYXJlZEhpc3Q6IG9wdGlvbnMuc2hhcmVkSGlzdH1dO1xuICAgICAgY29weVNoYXJlZE1hcmtlcnMoY29weSwgZmluZFNoYXJlZE1hcmtlcnModGhpcykpO1xuICAgICAgcmV0dXJuIGNvcHlcbiAgICB9LFxuICAgIHVubGlua0RvYzogZnVuY3Rpb24ob3RoZXIpIHtcbiAgICAgIGlmIChvdGhlciBpbnN0YW5jZW9mIENvZGVNaXJyb3IpIHsgb3RoZXIgPSBvdGhlci5kb2M7IH1cbiAgICAgIGlmICh0aGlzLmxpbmtlZCkgeyBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGlua2VkLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBsaW5rID0gdGhpcy5saW5rZWRbaV07XG4gICAgICAgIGlmIChsaW5rLmRvYyAhPSBvdGhlcikgeyBjb250aW51ZSB9XG4gICAgICAgIHRoaXMubGlua2VkLnNwbGljZShpLCAxKTtcbiAgICAgICAgb3RoZXIudW5saW5rRG9jKHRoaXMpO1xuICAgICAgICBkZXRhY2hTaGFyZWRNYXJrZXJzKGZpbmRTaGFyZWRNYXJrZXJzKHRoaXMpKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH0gfVxuICAgICAgLy8gSWYgdGhlIGhpc3RvcmllcyB3ZXJlIHNoYXJlZCwgc3BsaXQgdGhlbSBhZ2FpblxuICAgICAgaWYgKG90aGVyLmhpc3RvcnkgPT0gdGhpcy5oaXN0b3J5KSB7XG4gICAgICAgIHZhciBzcGxpdElkcyA9IFtvdGhlci5pZF07XG4gICAgICAgIGxpbmtlZERvY3Mob3RoZXIsIGZ1bmN0aW9uIChkb2MpIHsgcmV0dXJuIHNwbGl0SWRzLnB1c2goZG9jLmlkKTsgfSwgdHJ1ZSk7XG4gICAgICAgIG90aGVyLmhpc3RvcnkgPSBuZXcgSGlzdG9yeShudWxsKTtcbiAgICAgICAgb3RoZXIuaGlzdG9yeS5kb25lID0gY29weUhpc3RvcnlBcnJheSh0aGlzLmhpc3RvcnkuZG9uZSwgc3BsaXRJZHMpO1xuICAgICAgICBvdGhlci5oaXN0b3J5LnVuZG9uZSA9IGNvcHlIaXN0b3J5QXJyYXkodGhpcy5oaXN0b3J5LnVuZG9uZSwgc3BsaXRJZHMpO1xuICAgICAgfVxuICAgIH0sXG4gICAgaXRlckxpbmtlZERvY3M6IGZ1bmN0aW9uKGYpIHtsaW5rZWREb2NzKHRoaXMsIGYpO30sXG5cbiAgICBnZXRNb2RlOiBmdW5jdGlvbigpIHtyZXR1cm4gdGhpcy5tb2RlfSxcbiAgICBnZXRFZGl0b3I6IGZ1bmN0aW9uKCkge3JldHVybiB0aGlzLmNtfSxcblxuICAgIHNwbGl0TGluZXM6IGZ1bmN0aW9uKHN0cikge1xuICAgICAgaWYgKHRoaXMubGluZVNlcCkgeyByZXR1cm4gc3RyLnNwbGl0KHRoaXMubGluZVNlcCkgfVxuICAgICAgcmV0dXJuIHNwbGl0TGluZXNBdXRvKHN0cilcbiAgICB9LFxuICAgIGxpbmVTZXBhcmF0b3I6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5saW5lU2VwIHx8IFwiXFxuXCIgfSxcblxuICAgIHNldERpcmVjdGlvbjogZG9jTWV0aG9kT3AoZnVuY3Rpb24gKGRpcikge1xuICAgICAgaWYgKGRpciAhPSBcInJ0bFwiKSB7IGRpciA9IFwibHRyXCI7IH1cbiAgICAgIGlmIChkaXIgPT0gdGhpcy5kaXJlY3Rpb24pIHsgcmV0dXJuIH1cbiAgICAgIHRoaXMuZGlyZWN0aW9uID0gZGlyO1xuICAgICAgdGhpcy5pdGVyKGZ1bmN0aW9uIChsaW5lKSB7IHJldHVybiBsaW5lLm9yZGVyID0gbnVsbDsgfSk7XG4gICAgICBpZiAodGhpcy5jbSkgeyBkaXJlY3Rpb25DaGFuZ2VkKHRoaXMuY20pOyB9XG4gICAgfSlcbiAgfSk7XG5cbiAgLy8gUHVibGljIGFsaWFzLlxuICBEb2MucHJvdG90eXBlLmVhY2hMaW5lID0gRG9jLnByb3RvdHlwZS5pdGVyO1xuXG4gIC8vIEtsdWRnZSB0byB3b3JrIGFyb3VuZCBzdHJhbmdlIElFIGJlaGF2aW9yIHdoZXJlIGl0J2xsIHNvbWV0aW1lc1xuICAvLyByZS1maXJlIGEgc2VyaWVzIG9mIGRyYWctcmVsYXRlZCBldmVudHMgcmlnaHQgYWZ0ZXIgdGhlIGRyb3AgKCMxNTUxKVxuICB2YXIgbGFzdERyb3AgPSAwO1xuXG4gIGZ1bmN0aW9uIG9uRHJvcChlKSB7XG4gICAgdmFyIGNtID0gdGhpcztcbiAgICBjbGVhckRyYWdDdXJzb3IoY20pO1xuICAgIGlmIChzaWduYWxET01FdmVudChjbSwgZSkgfHwgZXZlbnRJbldpZGdldChjbS5kaXNwbGF5LCBlKSlcbiAgICAgIHsgcmV0dXJuIH1cbiAgICBlX3ByZXZlbnREZWZhdWx0KGUpO1xuICAgIGlmIChpZSkgeyBsYXN0RHJvcCA9ICtuZXcgRGF0ZTsgfVxuICAgIHZhciBwb3MgPSBwb3NGcm9tTW91c2UoY20sIGUsIHRydWUpLCBmaWxlcyA9IGUuZGF0YVRyYW5zZmVyLmZpbGVzO1xuICAgIGlmICghcG9zIHx8IGNtLmlzUmVhZE9ubHkoKSkgeyByZXR1cm4gfVxuICAgIC8vIE1pZ2h0IGJlIGEgZmlsZSBkcm9wLCBpbiB3aGljaCBjYXNlIHdlIHNpbXBseSBleHRyYWN0IHRoZSB0ZXh0XG4gICAgLy8gYW5kIGluc2VydCBpdC5cbiAgICBpZiAoZmlsZXMgJiYgZmlsZXMubGVuZ3RoICYmIHdpbmRvdy5GaWxlUmVhZGVyICYmIHdpbmRvdy5GaWxlKSB7XG4gICAgICB2YXIgbiA9IGZpbGVzLmxlbmd0aCwgdGV4dCA9IEFycmF5KG4pLCByZWFkID0gMDtcbiAgICAgIHZhciBtYXJrQXNSZWFkQW5kUGFzdGVJZkFsbEZpbGVzQXJlUmVhZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCsrcmVhZCA9PSBuKSB7XG4gICAgICAgICAgb3BlcmF0aW9uKGNtLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBwb3MgPSBjbGlwUG9zKGNtLmRvYywgcG9zKTtcbiAgICAgICAgICAgIHZhciBjaGFuZ2UgPSB7ZnJvbTogcG9zLCB0bzogcG9zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBjbS5kb2Muc3BsaXRMaW5lcyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQuZmlsdGVyKGZ1bmN0aW9uICh0KSB7IHJldHVybiB0ICE9IG51bGw7IH0pLmpvaW4oY20uZG9jLmxpbmVTZXBhcmF0b3IoKSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW46IFwicGFzdGVcIn07XG4gICAgICAgICAgICBtYWtlQ2hhbmdlKGNtLmRvYywgY2hhbmdlKTtcbiAgICAgICAgICAgIHNldFNlbGVjdGlvblJlcGxhY2VIaXN0b3J5KGNtLmRvYywgc2ltcGxlU2VsZWN0aW9uKGNsaXBQb3MoY20uZG9jLCBwb3MpLCBjbGlwUG9zKGNtLmRvYywgY2hhbmdlRW5kKGNoYW5nZSkpKSk7XG4gICAgICAgICAgfSkoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHZhciByZWFkVGV4dEZyb21GaWxlID0gZnVuY3Rpb24gKGZpbGUsIGkpIHtcbiAgICAgICAgaWYgKGNtLm9wdGlvbnMuYWxsb3dEcm9wRmlsZVR5cGVzICYmXG4gICAgICAgICAgICBpbmRleE9mKGNtLm9wdGlvbnMuYWxsb3dEcm9wRmlsZVR5cGVzLCBmaWxlLnR5cGUpID09IC0xKSB7XG4gICAgICAgICAgbWFya0FzUmVhZEFuZFBhc3RlSWZBbGxGaWxlc0FyZVJlYWQoKTtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXI7XG4gICAgICAgIHJlYWRlci5vbmVycm9yID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbWFya0FzUmVhZEFuZFBhc3RlSWZBbGxGaWxlc0FyZVJlYWQoKTsgfTtcbiAgICAgICAgcmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgY29udGVudCA9IHJlYWRlci5yZXN1bHQ7XG4gICAgICAgICAgaWYgKC9bXFx4MDAtXFx4MDhcXHgwZS1cXHgxZl17Mn0vLnRlc3QoY29udGVudCkpIHtcbiAgICAgICAgICAgIG1hcmtBc1JlYWRBbmRQYXN0ZUlmQWxsRmlsZXNBcmVSZWFkKCk7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG4gICAgICAgICAgdGV4dFtpXSA9IGNvbnRlbnQ7XG4gICAgICAgICAgbWFya0FzUmVhZEFuZFBhc3RlSWZBbGxGaWxlc0FyZVJlYWQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmVhZGVyLnJlYWRBc1RleHQoZmlsZSk7XG4gICAgICB9O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWxlcy5sZW5ndGg7IGkrKykgeyByZWFkVGV4dEZyb21GaWxlKGZpbGVzW2ldLCBpKTsgfVxuICAgIH0gZWxzZSB7IC8vIE5vcm1hbCBkcm9wXG4gICAgICAvLyBEb24ndCBkbyBhIHJlcGxhY2UgaWYgdGhlIGRyb3AgaGFwcGVuZWQgaW5zaWRlIG9mIHRoZSBzZWxlY3RlZCB0ZXh0LlxuICAgICAgaWYgKGNtLnN0YXRlLmRyYWdnaW5nVGV4dCAmJiBjbS5kb2Muc2VsLmNvbnRhaW5zKHBvcykgPiAtMSkge1xuICAgICAgICBjbS5zdGF0ZS5kcmFnZ2luZ1RleHQoZSk7XG4gICAgICAgIC8vIEVuc3VyZSB0aGUgZWRpdG9yIGlzIHJlLWZvY3VzZWRcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBjbS5kaXNwbGF5LmlucHV0LmZvY3VzKCk7IH0sIDIwKTtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgdGV4dCQxID0gZS5kYXRhVHJhbnNmZXIuZ2V0RGF0YShcIlRleHRcIik7XG4gICAgICAgIGlmICh0ZXh0JDEpIHtcbiAgICAgICAgICB2YXIgc2VsZWN0ZWQ7XG4gICAgICAgICAgaWYgKGNtLnN0YXRlLmRyYWdnaW5nVGV4dCAmJiAhY20uc3RhdGUuZHJhZ2dpbmdUZXh0LmNvcHkpXG4gICAgICAgICAgICB7IHNlbGVjdGVkID0gY20ubGlzdFNlbGVjdGlvbnMoKTsgfVxuICAgICAgICAgIHNldFNlbGVjdGlvbk5vVW5kbyhjbS5kb2MsIHNpbXBsZVNlbGVjdGlvbihwb3MsIHBvcykpO1xuICAgICAgICAgIGlmIChzZWxlY3RlZCkgeyBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBzZWxlY3RlZC5sZW5ndGg7ICsraSQxKVxuICAgICAgICAgICAgeyByZXBsYWNlUmFuZ2UoY20uZG9jLCBcIlwiLCBzZWxlY3RlZFtpJDFdLmFuY2hvciwgc2VsZWN0ZWRbaSQxXS5oZWFkLCBcImRyYWdcIik7IH0gfVxuICAgICAgICAgIGNtLnJlcGxhY2VTZWxlY3Rpb24odGV4dCQxLCBcImFyb3VuZFwiLCBcInBhc3RlXCIpO1xuICAgICAgICAgIGNtLmRpc3BsYXkuaW5wdXQuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2F0Y2goZSQxKXt9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25EcmFnU3RhcnQoY20sIGUpIHtcbiAgICBpZiAoaWUgJiYgKCFjbS5zdGF0ZS5kcmFnZ2luZ1RleHQgfHwgK25ldyBEYXRlIC0gbGFzdERyb3AgPCAxMDApKSB7IGVfc3RvcChlKTsgcmV0dXJuIH1cbiAgICBpZiAoc2lnbmFsRE9NRXZlbnQoY20sIGUpIHx8IGV2ZW50SW5XaWRnZXQoY20uZGlzcGxheSwgZSkpIHsgcmV0dXJuIH1cblxuICAgIGUuZGF0YVRyYW5zZmVyLnNldERhdGEoXCJUZXh0XCIsIGNtLmdldFNlbGVjdGlvbigpKTtcbiAgICBlLmRhdGFUcmFuc2Zlci5lZmZlY3RBbGxvd2VkID0gXCJjb3B5TW92ZVwiO1xuXG4gICAgLy8gVXNlIGR1bW15IGltYWdlIGluc3RlYWQgb2YgZGVmYXVsdCBicm93c2VycyBpbWFnZS5cbiAgICAvLyBSZWNlbnQgU2FmYXJpICh+Ni4wLjIpIGhhdmUgYSB0ZW5kZW5jeSB0byBzZWdmYXVsdCB3aGVuIHRoaXMgaGFwcGVucywgc28gd2UgZG9uJ3QgZG8gaXQgdGhlcmUuXG4gICAgaWYgKGUuZGF0YVRyYW5zZmVyLnNldERyYWdJbWFnZSAmJiAhc2FmYXJpKSB7XG4gICAgICB2YXIgaW1nID0gZWx0KFwiaW1nXCIsIG51bGwsIG51bGwsIFwicG9zaXRpb246IGZpeGVkOyBsZWZ0OiAwOyB0b3A6IDA7XCIpO1xuICAgICAgaW1nLnNyYyA9IFwiZGF0YTppbWFnZS9naWY7YmFzZTY0LFIwbEdPRGxoQVFBQkFBQUFBQ0g1QkFFS0FBRUFMQUFBQUFBQkFBRUFBQUlDVEFFQU93PT1cIjtcbiAgICAgIGlmIChwcmVzdG8pIHtcbiAgICAgICAgaW1nLndpZHRoID0gaW1nLmhlaWdodCA9IDE7XG4gICAgICAgIGNtLmRpc3BsYXkud3JhcHBlci5hcHBlbmRDaGlsZChpbWcpO1xuICAgICAgICAvLyBGb3JjZSBhIHJlbGF5b3V0LCBvciBPcGVyYSB3b24ndCB1c2Ugb3VyIGltYWdlIGZvciBzb21lIG9ic2N1cmUgcmVhc29uXG4gICAgICAgIGltZy5fdG9wID0gaW1nLm9mZnNldFRvcDtcbiAgICAgIH1cbiAgICAgIGUuZGF0YVRyYW5zZmVyLnNldERyYWdJbWFnZShpbWcsIDAsIDApO1xuICAgICAgaWYgKHByZXN0bykgeyBpbWcucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChpbWcpOyB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25EcmFnT3ZlcihjbSwgZSkge1xuICAgIHZhciBwb3MgPSBwb3NGcm9tTW91c2UoY20sIGUpO1xuICAgIGlmICghcG9zKSB7IHJldHVybiB9XG4gICAgdmFyIGZyYWcgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgZHJhd1NlbGVjdGlvbkN1cnNvcihjbSwgcG9zLCBmcmFnKTtcbiAgICBpZiAoIWNtLmRpc3BsYXkuZHJhZ0N1cnNvcikge1xuICAgICAgY20uZGlzcGxheS5kcmFnQ3Vyc29yID0gZWx0KFwiZGl2XCIsIG51bGwsIFwiQ29kZU1pcnJvci1jdXJzb3JzIENvZGVNaXJyb3ItZHJhZ2N1cnNvcnNcIik7XG4gICAgICBjbS5kaXNwbGF5LmxpbmVTcGFjZS5pbnNlcnRCZWZvcmUoY20uZGlzcGxheS5kcmFnQ3Vyc29yLCBjbS5kaXNwbGF5LmN1cnNvckRpdik7XG4gICAgfVxuICAgIHJlbW92ZUNoaWxkcmVuQW5kQWRkKGNtLmRpc3BsYXkuZHJhZ0N1cnNvciwgZnJhZyk7XG4gIH1cblxuICBmdW5jdGlvbiBjbGVhckRyYWdDdXJzb3IoY20pIHtcbiAgICBpZiAoY20uZGlzcGxheS5kcmFnQ3Vyc29yKSB7XG4gICAgICBjbS5kaXNwbGF5LmxpbmVTcGFjZS5yZW1vdmVDaGlsZChjbS5kaXNwbGF5LmRyYWdDdXJzb3IpO1xuICAgICAgY20uZGlzcGxheS5kcmFnQ3Vyc29yID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICAvLyBUaGVzZSBtdXN0IGJlIGhhbmRsZWQgY2FyZWZ1bGx5LCBiZWNhdXNlIG5haXZlbHkgcmVnaXN0ZXJpbmcgYVxuICAvLyBoYW5kbGVyIGZvciBlYWNoIGVkaXRvciB3aWxsIGNhdXNlIHRoZSBlZGl0b3JzIHRvIG5ldmVyIGJlXG4gIC8vIGdhcmJhZ2UgY29sbGVjdGVkLlxuXG4gIGZ1bmN0aW9uIGZvckVhY2hDb2RlTWlycm9yKGYpIHtcbiAgICBpZiAoIWRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUpIHsgcmV0dXJuIH1cbiAgICB2YXIgYnlDbGFzcyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoXCJDb2RlTWlycm9yXCIpLCBlZGl0b3JzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBieUNsYXNzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY20gPSBieUNsYXNzW2ldLkNvZGVNaXJyb3I7XG4gICAgICBpZiAoY20pIHsgZWRpdG9ycy5wdXNoKGNtKTsgfVxuICAgIH1cbiAgICBpZiAoZWRpdG9ycy5sZW5ndGgpIHsgZWRpdG9yc1swXS5vcGVyYXRpb24oZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlZGl0b3JzLmxlbmd0aDsgaSsrKSB7IGYoZWRpdG9yc1tpXSk7IH1cbiAgICB9KTsgfVxuICB9XG5cbiAgdmFyIGdsb2JhbHNSZWdpc3RlcmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGVuc3VyZUdsb2JhbEhhbmRsZXJzKCkge1xuICAgIGlmIChnbG9iYWxzUmVnaXN0ZXJlZCkgeyByZXR1cm4gfVxuICAgIHJlZ2lzdGVyR2xvYmFsSGFuZGxlcnMoKTtcbiAgICBnbG9iYWxzUmVnaXN0ZXJlZCA9IHRydWU7XG4gIH1cbiAgZnVuY3Rpb24gcmVnaXN0ZXJHbG9iYWxIYW5kbGVycygpIHtcbiAgICAvLyBXaGVuIHRoZSB3aW5kb3cgcmVzaXplcywgd2UgbmVlZCB0byByZWZyZXNoIGFjdGl2ZSBlZGl0b3JzLlxuICAgIHZhciByZXNpemVUaW1lcjtcbiAgICBvbih3aW5kb3csIFwicmVzaXplXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChyZXNpemVUaW1lciA9PSBudWxsKSB7IHJlc2l6ZVRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJlc2l6ZVRpbWVyID0gbnVsbDtcbiAgICAgICAgZm9yRWFjaENvZGVNaXJyb3Iob25SZXNpemUpO1xuICAgICAgfSwgMTAwKTsgfVxuICAgIH0pO1xuICAgIC8vIFdoZW4gdGhlIHdpbmRvdyBsb3NlcyBmb2N1cywgd2Ugd2FudCB0byBzaG93IHRoZSBlZGl0b3IgYXMgYmx1cnJlZFxuICAgIG9uKHdpbmRvdywgXCJibHVyXCIsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZvckVhY2hDb2RlTWlycm9yKG9uQmx1cik7IH0pO1xuICB9XG4gIC8vIENhbGxlZCB3aGVuIHRoZSB3aW5kb3cgcmVzaXplc1xuICBmdW5jdGlvbiBvblJlc2l6ZShjbSkge1xuICAgIHZhciBkID0gY20uZGlzcGxheTtcbiAgICAvLyBNaWdodCBiZSBhIHRleHQgc2NhbGluZyBvcGVyYXRpb24sIGNsZWFyIHNpemUgY2FjaGVzLlxuICAgIGQuY2FjaGVkQ2hhcldpZHRoID0gZC5jYWNoZWRUZXh0SGVpZ2h0ID0gZC5jYWNoZWRQYWRkaW5nSCA9IG51bGw7XG4gICAgZC5zY3JvbGxiYXJzQ2xpcHBlZCA9IGZhbHNlO1xuICAgIGNtLnNldFNpemUoKTtcbiAgfVxuXG4gIHZhciBrZXlOYW1lcyA9IHtcbiAgICAzOiBcIlBhdXNlXCIsIDg6IFwiQmFja3NwYWNlXCIsIDk6IFwiVGFiXCIsIDEzOiBcIkVudGVyXCIsIDE2OiBcIlNoaWZ0XCIsIDE3OiBcIkN0cmxcIiwgMTg6IFwiQWx0XCIsXG4gICAgMTk6IFwiUGF1c2VcIiwgMjA6IFwiQ2Fwc0xvY2tcIiwgMjc6IFwiRXNjXCIsIDMyOiBcIlNwYWNlXCIsIDMzOiBcIlBhZ2VVcFwiLCAzNDogXCJQYWdlRG93blwiLCAzNTogXCJFbmRcIixcbiAgICAzNjogXCJIb21lXCIsIDM3OiBcIkxlZnRcIiwgMzg6IFwiVXBcIiwgMzk6IFwiUmlnaHRcIiwgNDA6IFwiRG93blwiLCA0NDogXCJQcmludFNjcm5cIiwgNDU6IFwiSW5zZXJ0XCIsXG4gICAgNDY6IFwiRGVsZXRlXCIsIDU5OiBcIjtcIiwgNjE6IFwiPVwiLCA5MTogXCJNb2RcIiwgOTI6IFwiTW9kXCIsIDkzOiBcIk1vZFwiLFxuICAgIDEwNjogXCIqXCIsIDEwNzogXCI9XCIsIDEwOTogXCItXCIsIDExMDogXCIuXCIsIDExMTogXCIvXCIsIDE0NTogXCJTY3JvbGxMb2NrXCIsXG4gICAgMTczOiBcIi1cIiwgMTg2OiBcIjtcIiwgMTg3OiBcIj1cIiwgMTg4OiBcIixcIiwgMTg5OiBcIi1cIiwgMTkwOiBcIi5cIiwgMTkxOiBcIi9cIiwgMTkyOiBcImBcIiwgMjE5OiBcIltcIiwgMjIwOiBcIlxcXFxcIixcbiAgICAyMjE6IFwiXVwiLCAyMjI6IFwiJ1wiLCAyMjQ6IFwiTW9kXCIsIDYzMjMyOiBcIlVwXCIsIDYzMjMzOiBcIkRvd25cIiwgNjMyMzQ6IFwiTGVmdFwiLCA2MzIzNTogXCJSaWdodFwiLCA2MzI3MjogXCJEZWxldGVcIixcbiAgICA2MzI3MzogXCJIb21lXCIsIDYzMjc1OiBcIkVuZFwiLCA2MzI3NjogXCJQYWdlVXBcIiwgNjMyNzc6IFwiUGFnZURvd25cIiwgNjMzMDI6IFwiSW5zZXJ0XCJcbiAgfTtcblxuICAvLyBOdW1iZXIga2V5c1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDEwOyBpKyspIHsga2V5TmFtZXNbaSArIDQ4XSA9IGtleU5hbWVzW2kgKyA5Nl0gPSBTdHJpbmcoaSk7IH1cbiAgLy8gQWxwaGFiZXRpYyBrZXlzXG4gIGZvciAodmFyIGkkMSA9IDY1OyBpJDEgPD0gOTA7IGkkMSsrKSB7IGtleU5hbWVzW2kkMV0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGkkMSk7IH1cbiAgLy8gRnVuY3Rpb24ga2V5c1xuICBmb3IgKHZhciBpJDIgPSAxOyBpJDIgPD0gMTI7IGkkMisrKSB7IGtleU5hbWVzW2kkMiArIDExMV0gPSBrZXlOYW1lc1tpJDIgKyA2MzIzNV0gPSBcIkZcIiArIGkkMjsgfVxuXG4gIHZhciBrZXlNYXAgPSB7fTtcblxuICBrZXlNYXAuYmFzaWMgPSB7XG4gICAgXCJMZWZ0XCI6IFwiZ29DaGFyTGVmdFwiLCBcIlJpZ2h0XCI6IFwiZ29DaGFyUmlnaHRcIiwgXCJVcFwiOiBcImdvTGluZVVwXCIsIFwiRG93blwiOiBcImdvTGluZURvd25cIixcbiAgICBcIkVuZFwiOiBcImdvTGluZUVuZFwiLCBcIkhvbWVcIjogXCJnb0xpbmVTdGFydFNtYXJ0XCIsIFwiUGFnZVVwXCI6IFwiZ29QYWdlVXBcIiwgXCJQYWdlRG93blwiOiBcImdvUGFnZURvd25cIixcbiAgICBcIkRlbGV0ZVwiOiBcImRlbENoYXJBZnRlclwiLCBcIkJhY2tzcGFjZVwiOiBcImRlbENoYXJCZWZvcmVcIiwgXCJTaGlmdC1CYWNrc3BhY2VcIjogXCJkZWxDaGFyQmVmb3JlXCIsXG4gICAgXCJUYWJcIjogXCJkZWZhdWx0VGFiXCIsIFwiU2hpZnQtVGFiXCI6IFwiaW5kZW50QXV0b1wiLFxuICAgIFwiRW50ZXJcIjogXCJuZXdsaW5lQW5kSW5kZW50XCIsIFwiSW5zZXJ0XCI6IFwidG9nZ2xlT3ZlcndyaXRlXCIsXG4gICAgXCJFc2NcIjogXCJzaW5nbGVTZWxlY3Rpb25cIlxuICB9O1xuICAvLyBOb3RlIHRoYXQgdGhlIHNhdmUgYW5kIGZpbmQtcmVsYXRlZCBjb21tYW5kcyBhcmVuJ3QgZGVmaW5lZCBieVxuICAvLyBkZWZhdWx0LiBVc2VyIGNvZGUgb3IgYWRkb25zIGNhbiBkZWZpbmUgdGhlbS4gVW5rbm93biBjb21tYW5kc1xuICAvLyBhcmUgc2ltcGx5IGlnbm9yZWQuXG4gIGtleU1hcC5wY0RlZmF1bHQgPSB7XG4gICAgXCJDdHJsLUFcIjogXCJzZWxlY3RBbGxcIiwgXCJDdHJsLURcIjogXCJkZWxldGVMaW5lXCIsIFwiQ3RybC1aXCI6IFwidW5kb1wiLCBcIlNoaWZ0LUN0cmwtWlwiOiBcInJlZG9cIiwgXCJDdHJsLVlcIjogXCJyZWRvXCIsXG4gICAgXCJDdHJsLUhvbWVcIjogXCJnb0RvY1N0YXJ0XCIsIFwiQ3RybC1FbmRcIjogXCJnb0RvY0VuZFwiLCBcIkN0cmwtVXBcIjogXCJnb0xpbmVVcFwiLCBcIkN0cmwtRG93blwiOiBcImdvTGluZURvd25cIixcbiAgICBcIkN0cmwtTGVmdFwiOiBcImdvR3JvdXBMZWZ0XCIsIFwiQ3RybC1SaWdodFwiOiBcImdvR3JvdXBSaWdodFwiLCBcIkFsdC1MZWZ0XCI6IFwiZ29MaW5lU3RhcnRcIiwgXCJBbHQtUmlnaHRcIjogXCJnb0xpbmVFbmRcIixcbiAgICBcIkN0cmwtQmFja3NwYWNlXCI6IFwiZGVsR3JvdXBCZWZvcmVcIiwgXCJDdHJsLURlbGV0ZVwiOiBcImRlbEdyb3VwQWZ0ZXJcIiwgXCJDdHJsLVNcIjogXCJzYXZlXCIsIFwiQ3RybC1GXCI6IFwiZmluZFwiLFxuICAgIFwiQ3RybC1HXCI6IFwiZmluZE5leHRcIiwgXCJTaGlmdC1DdHJsLUdcIjogXCJmaW5kUHJldlwiLCBcIlNoaWZ0LUN0cmwtRlwiOiBcInJlcGxhY2VcIiwgXCJTaGlmdC1DdHJsLVJcIjogXCJyZXBsYWNlQWxsXCIsXG4gICAgXCJDdHJsLVtcIjogXCJpbmRlbnRMZXNzXCIsIFwiQ3RybC1dXCI6IFwiaW5kZW50TW9yZVwiLFxuICAgIFwiQ3RybC1VXCI6IFwidW5kb1NlbGVjdGlvblwiLCBcIlNoaWZ0LUN0cmwtVVwiOiBcInJlZG9TZWxlY3Rpb25cIiwgXCJBbHQtVVwiOiBcInJlZG9TZWxlY3Rpb25cIixcbiAgICBcImZhbGx0aHJvdWdoXCI6IFwiYmFzaWNcIlxuICB9O1xuICAvLyBWZXJ5IGJhc2ljIHJlYWRsaW5lL2VtYWNzLXN0eWxlIGJpbmRpbmdzLCB3aGljaCBhcmUgc3RhbmRhcmQgb24gTWFjLlxuICBrZXlNYXAuZW1hY3N5ID0ge1xuICAgIFwiQ3RybC1GXCI6IFwiZ29DaGFyUmlnaHRcIiwgXCJDdHJsLUJcIjogXCJnb0NoYXJMZWZ0XCIsIFwiQ3RybC1QXCI6IFwiZ29MaW5lVXBcIiwgXCJDdHJsLU5cIjogXCJnb0xpbmVEb3duXCIsXG4gICAgXCJBbHQtRlwiOiBcImdvV29yZFJpZ2h0XCIsIFwiQWx0LUJcIjogXCJnb1dvcmRMZWZ0XCIsIFwiQ3RybC1BXCI6IFwiZ29MaW5lU3RhcnRcIiwgXCJDdHJsLUVcIjogXCJnb0xpbmVFbmRcIixcbiAgICBcIkN0cmwtVlwiOiBcImdvUGFnZURvd25cIiwgXCJTaGlmdC1DdHJsLVZcIjogXCJnb1BhZ2VVcFwiLCBcIkN0cmwtRFwiOiBcImRlbENoYXJBZnRlclwiLCBcIkN0cmwtSFwiOiBcImRlbENoYXJCZWZvcmVcIixcbiAgICBcIkFsdC1EXCI6IFwiZGVsV29yZEFmdGVyXCIsIFwiQWx0LUJhY2tzcGFjZVwiOiBcImRlbFdvcmRCZWZvcmVcIiwgXCJDdHJsLUtcIjogXCJraWxsTGluZVwiLCBcIkN0cmwtVFwiOiBcInRyYW5zcG9zZUNoYXJzXCIsXG4gICAgXCJDdHJsLU9cIjogXCJvcGVuTGluZVwiXG4gIH07XG4gIGtleU1hcC5tYWNEZWZhdWx0ID0ge1xuICAgIFwiQ21kLUFcIjogXCJzZWxlY3RBbGxcIiwgXCJDbWQtRFwiOiBcImRlbGV0ZUxpbmVcIiwgXCJDbWQtWlwiOiBcInVuZG9cIiwgXCJTaGlmdC1DbWQtWlwiOiBcInJlZG9cIiwgXCJDbWQtWVwiOiBcInJlZG9cIixcbiAgICBcIkNtZC1Ib21lXCI6IFwiZ29Eb2NTdGFydFwiLCBcIkNtZC1VcFwiOiBcImdvRG9jU3RhcnRcIiwgXCJDbWQtRW5kXCI6IFwiZ29Eb2NFbmRcIiwgXCJDbWQtRG93blwiOiBcImdvRG9jRW5kXCIsIFwiQWx0LUxlZnRcIjogXCJnb0dyb3VwTGVmdFwiLFxuICAgIFwiQWx0LVJpZ2h0XCI6IFwiZ29Hcm91cFJpZ2h0XCIsIFwiQ21kLUxlZnRcIjogXCJnb0xpbmVMZWZ0XCIsIFwiQ21kLVJpZ2h0XCI6IFwiZ29MaW5lUmlnaHRcIiwgXCJBbHQtQmFja3NwYWNlXCI6IFwiZGVsR3JvdXBCZWZvcmVcIixcbiAgICBcIkN0cmwtQWx0LUJhY2tzcGFjZVwiOiBcImRlbEdyb3VwQWZ0ZXJcIiwgXCJBbHQtRGVsZXRlXCI6IFwiZGVsR3JvdXBBZnRlclwiLCBcIkNtZC1TXCI6IFwic2F2ZVwiLCBcIkNtZC1GXCI6IFwiZmluZFwiLFxuICAgIFwiQ21kLUdcIjogXCJmaW5kTmV4dFwiLCBcIlNoaWZ0LUNtZC1HXCI6IFwiZmluZFByZXZcIiwgXCJDbWQtQWx0LUZcIjogXCJyZXBsYWNlXCIsIFwiU2hpZnQtQ21kLUFsdC1GXCI6IFwicmVwbGFjZUFsbFwiLFxuICAgIFwiQ21kLVtcIjogXCJpbmRlbnRMZXNzXCIsIFwiQ21kLV1cIjogXCJpbmRlbnRNb3JlXCIsIFwiQ21kLUJhY2tzcGFjZVwiOiBcImRlbFdyYXBwZWRMaW5lTGVmdFwiLCBcIkNtZC1EZWxldGVcIjogXCJkZWxXcmFwcGVkTGluZVJpZ2h0XCIsXG4gICAgXCJDbWQtVVwiOiBcInVuZG9TZWxlY3Rpb25cIiwgXCJTaGlmdC1DbWQtVVwiOiBcInJlZG9TZWxlY3Rpb25cIiwgXCJDdHJsLVVwXCI6IFwiZ29Eb2NTdGFydFwiLCBcIkN0cmwtRG93blwiOiBcImdvRG9jRW5kXCIsXG4gICAgXCJmYWxsdGhyb3VnaFwiOiBbXCJiYXNpY1wiLCBcImVtYWNzeVwiXVxuICB9O1xuICBrZXlNYXBbXCJkZWZhdWx0XCJdID0gbWFjID8ga2V5TWFwLm1hY0RlZmF1bHQgOiBrZXlNYXAucGNEZWZhdWx0O1xuXG4gIC8vIEtFWU1BUCBESVNQQVRDSFxuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZUtleU5hbWUobmFtZSkge1xuICAgIHZhciBwYXJ0cyA9IG5hbWUuc3BsaXQoLy0oPyEkKS8pO1xuICAgIG5hbWUgPSBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXTtcbiAgICB2YXIgYWx0LCBjdHJsLCBzaGlmdCwgY21kO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICB2YXIgbW9kID0gcGFydHNbaV07XG4gICAgICBpZiAoL14oY21kfG1ldGF8bSkkL2kudGVzdChtb2QpKSB7IGNtZCA9IHRydWU7IH1cbiAgICAgIGVsc2UgaWYgKC9eYShsdCk/JC9pLnRlc3QobW9kKSkgeyBhbHQgPSB0cnVlOyB9XG4gICAgICBlbHNlIGlmICgvXihjfGN0cmx8Y29udHJvbCkkL2kudGVzdChtb2QpKSB7IGN0cmwgPSB0cnVlOyB9XG4gICAgICBlbHNlIGlmICgvXnMoaGlmdCk/JC9pLnRlc3QobW9kKSkgeyBzaGlmdCA9IHRydWU7IH1cbiAgICAgIGVsc2UgeyB0aHJvdyBuZXcgRXJyb3IoXCJVbnJlY29nbml6ZWQgbW9kaWZpZXIgbmFtZTogXCIgKyBtb2QpIH1cbiAgICB9XG4gICAgaWYgKGFsdCkgeyBuYW1lID0gXCJBbHQtXCIgKyBuYW1lOyB9XG4gICAgaWYgKGN0cmwpIHsgbmFtZSA9IFwiQ3RybC1cIiArIG5hbWU7IH1cbiAgICBpZiAoY21kKSB7IG5hbWUgPSBcIkNtZC1cIiArIG5hbWU7IH1cbiAgICBpZiAoc2hpZnQpIHsgbmFtZSA9IFwiU2hpZnQtXCIgKyBuYW1lOyB9XG4gICAgcmV0dXJuIG5hbWVcbiAgfVxuXG4gIC8vIFRoaXMgaXMgYSBrbHVkZ2UgdG8ga2VlcCBrZXltYXBzIG1vc3RseSB3b3JraW5nIGFzIHJhdyBvYmplY3RzXG4gIC8vIChiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSkgd2hpbGUgYXQgdGhlIHNhbWUgdGltZSBzdXBwb3J0IGZlYXR1cmVzXG4gIC8vIGxpa2Ugbm9ybWFsaXphdGlvbiBhbmQgbXVsdGktc3Ryb2tlIGtleSBiaW5kaW5ncy4gSXQgY29tcGlsZXMgYVxuICAvLyBuZXcgbm9ybWFsaXplZCBrZXltYXAsIGFuZCB0aGVuIHVwZGF0ZXMgdGhlIG9sZCBvYmplY3QgdG8gcmVmbGVjdFxuICAvLyB0aGlzLlxuICBmdW5jdGlvbiBub3JtYWxpemVLZXlNYXAoa2V5bWFwKSB7XG4gICAgdmFyIGNvcHkgPSB7fTtcbiAgICBmb3IgKHZhciBrZXluYW1lIGluIGtleW1hcCkgeyBpZiAoa2V5bWFwLmhhc093blByb3BlcnR5KGtleW5hbWUpKSB7XG4gICAgICB2YXIgdmFsdWUgPSBrZXltYXBba2V5bmFtZV07XG4gICAgICBpZiAoL14obmFtZXxmYWxsdGhyb3VnaHwoZGV8YXQpdGFjaCkkLy50ZXN0KGtleW5hbWUpKSB7IGNvbnRpbnVlIH1cbiAgICAgIGlmICh2YWx1ZSA9PSBcIi4uLlwiKSB7IGRlbGV0ZSBrZXltYXBba2V5bmFtZV07IGNvbnRpbnVlIH1cblxuICAgICAgdmFyIGtleXMgPSBtYXAoa2V5bmFtZS5zcGxpdChcIiBcIiksIG5vcm1hbGl6ZUtleU5hbWUpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB2YWwgPSAodm9pZCAwKSwgbmFtZSA9ICh2b2lkIDApO1xuICAgICAgICBpZiAoaSA9PSBrZXlzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICBuYW1lID0ga2V5cy5qb2luKFwiIFwiKTtcbiAgICAgICAgICB2YWwgPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuYW1lID0ga2V5cy5zbGljZSgwLCBpICsgMSkuam9pbihcIiBcIik7XG4gICAgICAgICAgdmFsID0gXCIuLi5cIjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJldiA9IGNvcHlbbmFtZV07XG4gICAgICAgIGlmICghcHJldikgeyBjb3B5W25hbWVdID0gdmFsOyB9XG4gICAgICAgIGVsc2UgaWYgKHByZXYgIT0gdmFsKSB7IHRocm93IG5ldyBFcnJvcihcIkluY29uc2lzdGVudCBiaW5kaW5ncyBmb3IgXCIgKyBuYW1lKSB9XG4gICAgICB9XG4gICAgICBkZWxldGUga2V5bWFwW2tleW5hbWVdO1xuICAgIH0gfVxuICAgIGZvciAodmFyIHByb3AgaW4gY29weSkgeyBrZXltYXBbcHJvcF0gPSBjb3B5W3Byb3BdOyB9XG4gICAgcmV0dXJuIGtleW1hcFxuICB9XG5cbiAgZnVuY3Rpb24gbG9va3VwS2V5KGtleSwgbWFwLCBoYW5kbGUsIGNvbnRleHQpIHtcbiAgICBtYXAgPSBnZXRLZXlNYXAobWFwKTtcbiAgICB2YXIgZm91bmQgPSBtYXAuY2FsbCA/IG1hcC5jYWxsKGtleSwgY29udGV4dCkgOiBtYXBba2V5XTtcbiAgICBpZiAoZm91bmQgPT09IGZhbHNlKSB7IHJldHVybiBcIm5vdGhpbmdcIiB9XG4gICAgaWYgKGZvdW5kID09PSBcIi4uLlwiKSB7IHJldHVybiBcIm11bHRpXCIgfVxuICAgIGlmIChmb3VuZCAhPSBudWxsICYmIGhhbmRsZShmb3VuZCkpIHsgcmV0dXJuIFwiaGFuZGxlZFwiIH1cblxuICAgIGlmIChtYXAuZmFsbHRocm91Z2gpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobWFwLmZhbGx0aHJvdWdoKSAhPSBcIltvYmplY3QgQXJyYXldXCIpXG4gICAgICAgIHsgcmV0dXJuIGxvb2t1cEtleShrZXksIG1hcC5mYWxsdGhyb3VnaCwgaGFuZGxlLCBjb250ZXh0KSB9XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hcC5mYWxsdGhyb3VnaC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gbG9va3VwS2V5KGtleSwgbWFwLmZhbGx0aHJvdWdoW2ldLCBoYW5kbGUsIGNvbnRleHQpO1xuICAgICAgICBpZiAocmVzdWx0KSB7IHJldHVybiByZXN1bHQgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIE1vZGlmaWVyIGtleSBwcmVzc2VzIGRvbid0IGNvdW50IGFzICdyZWFsJyBrZXkgcHJlc3NlcyBmb3IgdGhlXG4gIC8vIHB1cnBvc2Ugb2Yga2V5bWFwIGZhbGx0aHJvdWdoLlxuICBmdW5jdGlvbiBpc01vZGlmaWVyS2V5KHZhbHVlKSB7XG4gICAgdmFyIG5hbWUgPSB0eXBlb2YgdmFsdWUgPT0gXCJzdHJpbmdcIiA/IHZhbHVlIDoga2V5TmFtZXNbdmFsdWUua2V5Q29kZV07XG4gICAgcmV0dXJuIG5hbWUgPT0gXCJDdHJsXCIgfHwgbmFtZSA9PSBcIkFsdFwiIHx8IG5hbWUgPT0gXCJTaGlmdFwiIHx8IG5hbWUgPT0gXCJNb2RcIlxuICB9XG5cbiAgZnVuY3Rpb24gYWRkTW9kaWZpZXJOYW1lcyhuYW1lLCBldmVudCwgbm9TaGlmdCkge1xuICAgIHZhciBiYXNlID0gbmFtZTtcbiAgICBpZiAoZXZlbnQuYWx0S2V5ICYmIGJhc2UgIT0gXCJBbHRcIikgeyBuYW1lID0gXCJBbHQtXCIgKyBuYW1lOyB9XG4gICAgaWYgKChmbGlwQ3RybENtZCA/IGV2ZW50Lm1ldGFLZXkgOiBldmVudC5jdHJsS2V5KSAmJiBiYXNlICE9IFwiQ3RybFwiKSB7IG5hbWUgPSBcIkN0cmwtXCIgKyBuYW1lOyB9XG4gICAgaWYgKChmbGlwQ3RybENtZCA/IGV2ZW50LmN0cmxLZXkgOiBldmVudC5tZXRhS2V5KSAmJiBiYXNlICE9IFwiTW9kXCIpIHsgbmFtZSA9IFwiQ21kLVwiICsgbmFtZTsgfVxuICAgIGlmICghbm9TaGlmdCAmJiBldmVudC5zaGlmdEtleSAmJiBiYXNlICE9IFwiU2hpZnRcIikgeyBuYW1lID0gXCJTaGlmdC1cIiArIG5hbWU7IH1cbiAgICByZXR1cm4gbmFtZVxuICB9XG5cbiAgLy8gTG9vayB1cCB0aGUgbmFtZSBvZiBhIGtleSBhcyBpbmRpY2F0ZWQgYnkgYW4gZXZlbnQgb2JqZWN0LlxuICBmdW5jdGlvbiBrZXlOYW1lKGV2ZW50LCBub1NoaWZ0KSB7XG4gICAgaWYgKHByZXN0byAmJiBldmVudC5rZXlDb2RlID09IDM0ICYmIGV2ZW50W1wiY2hhclwiXSkgeyByZXR1cm4gZmFsc2UgfVxuICAgIHZhciBuYW1lID0ga2V5TmFtZXNbZXZlbnQua2V5Q29kZV07XG4gICAgaWYgKG5hbWUgPT0gbnVsbCB8fCBldmVudC5hbHRHcmFwaEtleSkgeyByZXR1cm4gZmFsc2UgfVxuICAgIC8vIEN0cmwtU2Nyb2xsTG9jayBoYXMga2V5Q29kZSAzLCBzYW1lIGFzIEN0cmwtUGF1c2UsXG4gICAgLy8gc28gd2UnbGwgdXNlIGV2ZW50LmNvZGUgd2hlbiBhdmFpbGFibGUgKENocm9tZSA0OCssIEZGIDM4KywgU2FmYXJpIDEwLjErKVxuICAgIGlmIChldmVudC5rZXlDb2RlID09IDMgJiYgZXZlbnQuY29kZSkgeyBuYW1lID0gZXZlbnQuY29kZTsgfVxuICAgIHJldHVybiBhZGRNb2RpZmllck5hbWVzKG5hbWUsIGV2ZW50LCBub1NoaWZ0KVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0S2V5TWFwKHZhbCkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsID09IFwic3RyaW5nXCIgPyBrZXlNYXBbdmFsXSA6IHZhbFxuICB9XG5cbiAgLy8gSGVscGVyIGZvciBkZWxldGluZyB0ZXh0IG5lYXIgdGhlIHNlbGVjdGlvbihzKSwgdXNlZCB0byBpbXBsZW1lbnRcbiAgLy8gYmFja3NwYWNlLCBkZWxldGUsIGFuZCBzaW1pbGFyIGZ1bmN0aW9uYWxpdHkuXG4gIGZ1bmN0aW9uIGRlbGV0ZU5lYXJTZWxlY3Rpb24oY20sIGNvbXB1dGUpIHtcbiAgICB2YXIgcmFuZ2VzID0gY20uZG9jLnNlbC5yYW5nZXMsIGtpbGwgPSBbXTtcbiAgICAvLyBCdWlsZCB1cCBhIHNldCBvZiByYW5nZXMgdG8ga2lsbCBmaXJzdCwgbWVyZ2luZyBvdmVybGFwcGluZ1xuICAgIC8vIHJhbmdlcy5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHRvS2lsbCA9IGNvbXB1dGUocmFuZ2VzW2ldKTtcbiAgICAgIHdoaWxlIChraWxsLmxlbmd0aCAmJiBjbXAodG9LaWxsLmZyb20sIGxzdChraWxsKS50bykgPD0gMCkge1xuICAgICAgICB2YXIgcmVwbGFjZWQgPSBraWxsLnBvcCgpO1xuICAgICAgICBpZiAoY21wKHJlcGxhY2VkLmZyb20sIHRvS2lsbC5mcm9tKSA8IDApIHtcbiAgICAgICAgICB0b0tpbGwuZnJvbSA9IHJlcGxhY2VkLmZyb207XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAga2lsbC5wdXNoKHRvS2lsbCk7XG4gICAgfVxuICAgIC8vIE5leHQsIHJlbW92ZSB0aG9zZSBhY3R1YWwgcmFuZ2VzLlxuICAgIHJ1bkluT3AoY20sIGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIGkgPSBraWxsLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICB7IHJlcGxhY2VSYW5nZShjbS5kb2MsIFwiXCIsIGtpbGxbaV0uZnJvbSwga2lsbFtpXS50bywgXCIrZGVsZXRlXCIpOyB9XG4gICAgICBlbnN1cmVDdXJzb3JWaXNpYmxlKGNtKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1vdmVDaGFyTG9naWNhbGx5KGxpbmUsIGNoLCBkaXIpIHtcbiAgICB2YXIgdGFyZ2V0ID0gc2tpcEV4dGVuZGluZ0NoYXJzKGxpbmUudGV4dCwgY2ggKyBkaXIsIGRpcik7XG4gICAgcmV0dXJuIHRhcmdldCA8IDAgfHwgdGFyZ2V0ID4gbGluZS50ZXh0Lmxlbmd0aCA/IG51bGwgOiB0YXJnZXRcbiAgfVxuXG4gIGZ1bmN0aW9uIG1vdmVMb2dpY2FsbHkobGluZSwgc3RhcnQsIGRpcikge1xuICAgIHZhciBjaCA9IG1vdmVDaGFyTG9naWNhbGx5KGxpbmUsIHN0YXJ0LmNoLCBkaXIpO1xuICAgIHJldHVybiBjaCA9PSBudWxsID8gbnVsbCA6IG5ldyBQb3Moc3RhcnQubGluZSwgY2gsIGRpciA8IDAgPyBcImFmdGVyXCIgOiBcImJlZm9yZVwiKVxuICB9XG5cbiAgZnVuY3Rpb24gZW5kT2ZMaW5lKHZpc3VhbGx5LCBjbSwgbGluZU9iaiwgbGluZU5vLCBkaXIpIHtcbiAgICBpZiAodmlzdWFsbHkpIHtcbiAgICAgIGlmIChjbS5kb2MuZGlyZWN0aW9uID09IFwicnRsXCIpIHsgZGlyID0gLWRpcjsgfVxuICAgICAgdmFyIG9yZGVyID0gZ2V0T3JkZXIobGluZU9iaiwgY20uZG9jLmRpcmVjdGlvbik7XG4gICAgICBpZiAob3JkZXIpIHtcbiAgICAgICAgdmFyIHBhcnQgPSBkaXIgPCAwID8gbHN0KG9yZGVyKSA6IG9yZGVyWzBdO1xuICAgICAgICB2YXIgbW92ZUluU3RvcmFnZU9yZGVyID0gKGRpciA8IDApID09IChwYXJ0LmxldmVsID09IDEpO1xuICAgICAgICB2YXIgc3RpY2t5ID0gbW92ZUluU3RvcmFnZU9yZGVyID8gXCJhZnRlclwiIDogXCJiZWZvcmVcIjtcbiAgICAgICAgdmFyIGNoO1xuICAgICAgICAvLyBXaXRoIGEgd3JhcHBlZCBydGwgY2h1bmsgKHBvc3NpYmx5IHNwYW5uaW5nIG11bHRpcGxlIGJpZGkgcGFydHMpLFxuICAgICAgICAvLyBpdCBjb3VsZCBiZSB0aGF0IHRoZSBsYXN0IGJpZGkgcGFydCBpcyBub3Qgb24gdGhlIGxhc3QgdmlzdWFsIGxpbmUsXG4gICAgICAgIC8vIHNpbmNlIHZpc3VhbCBsaW5lcyBjb250YWluIGNvbnRlbnQgb3JkZXItY29uc2VjdXRpdmUgY2h1bmtzLlxuICAgICAgICAvLyBUaHVzLCBpbiBydGwsIHdlIGFyZSBsb29raW5nIGZvciB0aGUgZmlyc3QgKGNvbnRlbnQtb3JkZXIpIGNoYXJhY3RlclxuICAgICAgICAvLyBpbiB0aGUgcnRsIGNodW5rIHRoYXQgaXMgb24gdGhlIGxhc3QgbGluZSAodGhhdCBpcywgdGhlIHNhbWUgbGluZVxuICAgICAgICAvLyBhcyB0aGUgbGFzdCAoY29udGVudC1vcmRlcikgY2hhcmFjdGVyKS5cbiAgICAgICAgaWYgKHBhcnQubGV2ZWwgPiAwIHx8IGNtLmRvYy5kaXJlY3Rpb24gPT0gXCJydGxcIikge1xuICAgICAgICAgIHZhciBwcmVwID0gcHJlcGFyZU1lYXN1cmVGb3JMaW5lKGNtLCBsaW5lT2JqKTtcbiAgICAgICAgICBjaCA9IGRpciA8IDAgPyBsaW5lT2JqLnRleHQubGVuZ3RoIC0gMSA6IDA7XG4gICAgICAgICAgdmFyIHRhcmdldFRvcCA9IG1lYXN1cmVDaGFyUHJlcGFyZWQoY20sIHByZXAsIGNoKS50b3A7XG4gICAgICAgICAgY2ggPSBmaW5kRmlyc3QoZnVuY3Rpb24gKGNoKSB7IHJldHVybiBtZWFzdXJlQ2hhclByZXBhcmVkKGNtLCBwcmVwLCBjaCkudG9wID09IHRhcmdldFRvcDsgfSwgKGRpciA8IDApID09IChwYXJ0LmxldmVsID09IDEpID8gcGFydC5mcm9tIDogcGFydC50byAtIDEsIGNoKTtcbiAgICAgICAgICBpZiAoc3RpY2t5ID09IFwiYmVmb3JlXCIpIHsgY2ggPSBtb3ZlQ2hhckxvZ2ljYWxseShsaW5lT2JqLCBjaCwgMSk7IH1cbiAgICAgICAgfSBlbHNlIHsgY2ggPSBkaXIgPCAwID8gcGFydC50byA6IHBhcnQuZnJvbTsgfVxuICAgICAgICByZXR1cm4gbmV3IFBvcyhsaW5lTm8sIGNoLCBzdGlja3kpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgUG9zKGxpbmVObywgZGlyIDwgMCA/IGxpbmVPYmoudGV4dC5sZW5ndGggOiAwLCBkaXIgPCAwID8gXCJiZWZvcmVcIiA6IFwiYWZ0ZXJcIilcbiAgfVxuXG4gIGZ1bmN0aW9uIG1vdmVWaXN1YWxseShjbSwgbGluZSwgc3RhcnQsIGRpcikge1xuICAgIHZhciBiaWRpID0gZ2V0T3JkZXIobGluZSwgY20uZG9jLmRpcmVjdGlvbik7XG4gICAgaWYgKCFiaWRpKSB7IHJldHVybiBtb3ZlTG9naWNhbGx5KGxpbmUsIHN0YXJ0LCBkaXIpIH1cbiAgICBpZiAoc3RhcnQuY2ggPj0gbGluZS50ZXh0Lmxlbmd0aCkge1xuICAgICAgc3RhcnQuY2ggPSBsaW5lLnRleHQubGVuZ3RoO1xuICAgICAgc3RhcnQuc3RpY2t5ID0gXCJiZWZvcmVcIjtcbiAgICB9IGVsc2UgaWYgKHN0YXJ0LmNoIDw9IDApIHtcbiAgICAgIHN0YXJ0LmNoID0gMDtcbiAgICAgIHN0YXJ0LnN0aWNreSA9IFwiYWZ0ZXJcIjtcbiAgICB9XG4gICAgdmFyIHBhcnRQb3MgPSBnZXRCaWRpUGFydEF0KGJpZGksIHN0YXJ0LmNoLCBzdGFydC5zdGlja3kpLCBwYXJ0ID0gYmlkaVtwYXJ0UG9zXTtcbiAgICBpZiAoY20uZG9jLmRpcmVjdGlvbiA9PSBcImx0clwiICYmIHBhcnQubGV2ZWwgJSAyID09IDAgJiYgKGRpciA+IDAgPyBwYXJ0LnRvID4gc3RhcnQuY2ggOiBwYXJ0LmZyb20gPCBzdGFydC5jaCkpIHtcbiAgICAgIC8vIENhc2UgMTogV2UgbW92ZSB3aXRoaW4gYW4gbHRyIHBhcnQgaW4gYW4gbHRyIGVkaXRvci4gRXZlbiB3aXRoIHdyYXBwZWQgbGluZXMsXG4gICAgICAvLyBub3RoaW5nIGludGVyZXN0aW5nIGhhcHBlbnMuXG4gICAgICByZXR1cm4gbW92ZUxvZ2ljYWxseShsaW5lLCBzdGFydCwgZGlyKVxuICAgIH1cblxuICAgIHZhciBtdiA9IGZ1bmN0aW9uIChwb3MsIGRpcikgeyByZXR1cm4gbW92ZUNoYXJMb2dpY2FsbHkobGluZSwgcG9zIGluc3RhbmNlb2YgUG9zID8gcG9zLmNoIDogcG9zLCBkaXIpOyB9O1xuICAgIHZhciBwcmVwO1xuICAgIHZhciBnZXRXcmFwcGVkTGluZUV4dGVudCA9IGZ1bmN0aW9uIChjaCkge1xuICAgICAgaWYgKCFjbS5vcHRpb25zLmxpbmVXcmFwcGluZykgeyByZXR1cm4ge2JlZ2luOiAwLCBlbmQ6IGxpbmUudGV4dC5sZW5ndGh9IH1cbiAgICAgIHByZXAgPSBwcmVwIHx8IHByZXBhcmVNZWFzdXJlRm9yTGluZShjbSwgbGluZSk7XG4gICAgICByZXR1cm4gd3JhcHBlZExpbmVFeHRlbnRDaGFyKGNtLCBsaW5lLCBwcmVwLCBjaClcbiAgICB9O1xuICAgIHZhciB3cmFwcGVkTGluZUV4dGVudCA9IGdldFdyYXBwZWRMaW5lRXh0ZW50KHN0YXJ0LnN0aWNreSA9PSBcImJlZm9yZVwiID8gbXYoc3RhcnQsIC0xKSA6IHN0YXJ0LmNoKTtcblxuICAgIGlmIChjbS5kb2MuZGlyZWN0aW9uID09IFwicnRsXCIgfHwgcGFydC5sZXZlbCA9PSAxKSB7XG4gICAgICB2YXIgbW92ZUluU3RvcmFnZU9yZGVyID0gKHBhcnQubGV2ZWwgPT0gMSkgPT0gKGRpciA8IDApO1xuICAgICAgdmFyIGNoID0gbXYoc3RhcnQsIG1vdmVJblN0b3JhZ2VPcmRlciA/IDEgOiAtMSk7XG4gICAgICBpZiAoY2ggIT0gbnVsbCAmJiAoIW1vdmVJblN0b3JhZ2VPcmRlciA/IGNoID49IHBhcnQuZnJvbSAmJiBjaCA+PSB3cmFwcGVkTGluZUV4dGVudC5iZWdpbiA6IGNoIDw9IHBhcnQudG8gJiYgY2ggPD0gd3JhcHBlZExpbmVFeHRlbnQuZW5kKSkge1xuICAgICAgICAvLyBDYXNlIDI6IFdlIG1vdmUgd2l0aGluIGFuIHJ0bCBwYXJ0IG9yIGluIGFuIHJ0bCBlZGl0b3Igb24gdGhlIHNhbWUgdmlzdWFsIGxpbmVcbiAgICAgICAgdmFyIHN0aWNreSA9IG1vdmVJblN0b3JhZ2VPcmRlciA/IFwiYmVmb3JlXCIgOiBcImFmdGVyXCI7XG4gICAgICAgIHJldHVybiBuZXcgUG9zKHN0YXJ0LmxpbmUsIGNoLCBzdGlja3kpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2FzZSAzOiBDb3VsZCBub3QgbW92ZSB3aXRoaW4gdGhpcyBiaWRpIHBhcnQgaW4gdGhpcyB2aXN1YWwgbGluZSwgc28gbGVhdmVcbiAgICAvLyB0aGUgY3VycmVudCBiaWRpIHBhcnRcblxuICAgIHZhciBzZWFyY2hJblZpc3VhbExpbmUgPSBmdW5jdGlvbiAocGFydFBvcywgZGlyLCB3cmFwcGVkTGluZUV4dGVudCkge1xuICAgICAgdmFyIGdldFJlcyA9IGZ1bmN0aW9uIChjaCwgbW92ZUluU3RvcmFnZU9yZGVyKSB7IHJldHVybiBtb3ZlSW5TdG9yYWdlT3JkZXJcbiAgICAgICAgPyBuZXcgUG9zKHN0YXJ0LmxpbmUsIG12KGNoLCAxKSwgXCJiZWZvcmVcIilcbiAgICAgICAgOiBuZXcgUG9zKHN0YXJ0LmxpbmUsIGNoLCBcImFmdGVyXCIpOyB9O1xuXG4gICAgICBmb3IgKDsgcGFydFBvcyA+PSAwICYmIHBhcnRQb3MgPCBiaWRpLmxlbmd0aDsgcGFydFBvcyArPSBkaXIpIHtcbiAgICAgICAgdmFyIHBhcnQgPSBiaWRpW3BhcnRQb3NdO1xuICAgICAgICB2YXIgbW92ZUluU3RvcmFnZU9yZGVyID0gKGRpciA+IDApID09IChwYXJ0LmxldmVsICE9IDEpO1xuICAgICAgICB2YXIgY2ggPSBtb3ZlSW5TdG9yYWdlT3JkZXIgPyB3cmFwcGVkTGluZUV4dGVudC5iZWdpbiA6IG12KHdyYXBwZWRMaW5lRXh0ZW50LmVuZCwgLTEpO1xuICAgICAgICBpZiAocGFydC5mcm9tIDw9IGNoICYmIGNoIDwgcGFydC50bykgeyByZXR1cm4gZ2V0UmVzKGNoLCBtb3ZlSW5TdG9yYWdlT3JkZXIpIH1cbiAgICAgICAgY2ggPSBtb3ZlSW5TdG9yYWdlT3JkZXIgPyBwYXJ0LmZyb20gOiBtdihwYXJ0LnRvLCAtMSk7XG4gICAgICAgIGlmICh3cmFwcGVkTGluZUV4dGVudC5iZWdpbiA8PSBjaCAmJiBjaCA8IHdyYXBwZWRMaW5lRXh0ZW50LmVuZCkgeyByZXR1cm4gZ2V0UmVzKGNoLCBtb3ZlSW5TdG9yYWdlT3JkZXIpIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gQ2FzZSAzYTogTG9vayBmb3Igb3RoZXIgYmlkaSBwYXJ0cyBvbiB0aGUgc2FtZSB2aXN1YWwgbGluZVxuICAgIHZhciByZXMgPSBzZWFyY2hJblZpc3VhbExpbmUocGFydFBvcyArIGRpciwgZGlyLCB3cmFwcGVkTGluZUV4dGVudCk7XG4gICAgaWYgKHJlcykgeyByZXR1cm4gcmVzIH1cblxuICAgIC8vIENhc2UgM2I6IExvb2sgZm9yIG90aGVyIGJpZGkgcGFydHMgb24gdGhlIG5leHQgdmlzdWFsIGxpbmVcbiAgICB2YXIgbmV4dENoID0gZGlyID4gMCA/IHdyYXBwZWRMaW5lRXh0ZW50LmVuZCA6IG12KHdyYXBwZWRMaW5lRXh0ZW50LmJlZ2luLCAtMSk7XG4gICAgaWYgKG5leHRDaCAhPSBudWxsICYmICEoZGlyID4gMCAmJiBuZXh0Q2ggPT0gbGluZS50ZXh0Lmxlbmd0aCkpIHtcbiAgICAgIHJlcyA9IHNlYXJjaEluVmlzdWFsTGluZShkaXIgPiAwID8gMCA6IGJpZGkubGVuZ3RoIC0gMSwgZGlyLCBnZXRXcmFwcGVkTGluZUV4dGVudChuZXh0Q2gpKTtcbiAgICAgIGlmIChyZXMpIHsgcmV0dXJuIHJlcyB9XG4gICAgfVxuXG4gICAgLy8gQ2FzZSA0OiBOb3doZXJlIHRvIG1vdmVcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgLy8gQ29tbWFuZHMgYXJlIHBhcmFtZXRlci1sZXNzIGFjdGlvbnMgdGhhdCBjYW4gYmUgcGVyZm9ybWVkIG9uIGFuXG4gIC8vIGVkaXRvciwgbW9zdGx5IHVzZWQgZm9yIGtleWJpbmRpbmdzLlxuICB2YXIgY29tbWFuZHMgPSB7XG4gICAgc2VsZWN0QWxsOiBzZWxlY3RBbGwsXG4gICAgc2luZ2xlU2VsZWN0aW9uOiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLnNldFNlbGVjdGlvbihjbS5nZXRDdXJzb3IoXCJhbmNob3JcIiksIGNtLmdldEN1cnNvcihcImhlYWRcIiksIHNlbF9kb250U2Nyb2xsKTsgfSxcbiAgICBraWxsTGluZTogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBkZWxldGVOZWFyU2VsZWN0aW9uKGNtLCBmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAgIGlmIChyYW5nZS5lbXB0eSgpKSB7XG4gICAgICAgIHZhciBsZW4gPSBnZXRMaW5lKGNtLmRvYywgcmFuZ2UuaGVhZC5saW5lKS50ZXh0Lmxlbmd0aDtcbiAgICAgICAgaWYgKHJhbmdlLmhlYWQuY2ggPT0gbGVuICYmIHJhbmdlLmhlYWQubGluZSA8IGNtLmxhc3RMaW5lKCkpXG4gICAgICAgICAgeyByZXR1cm4ge2Zyb206IHJhbmdlLmhlYWQsIHRvOiBQb3MocmFuZ2UuaGVhZC5saW5lICsgMSwgMCl9IH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgIHsgcmV0dXJuIHtmcm9tOiByYW5nZS5oZWFkLCB0bzogUG9zKHJhbmdlLmhlYWQubGluZSwgbGVuKX0gfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHtmcm9tOiByYW5nZS5mcm9tKCksIHRvOiByYW5nZS50bygpfVxuICAgICAgfVxuICAgIH0pOyB9LFxuICAgIGRlbGV0ZUxpbmU6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gZGVsZXRlTmVhclNlbGVjdGlvbihjbSwgZnVuY3Rpb24gKHJhbmdlKSB7IHJldHVybiAoe1xuICAgICAgZnJvbTogUG9zKHJhbmdlLmZyb20oKS5saW5lLCAwKSxcbiAgICAgIHRvOiBjbGlwUG9zKGNtLmRvYywgUG9zKHJhbmdlLnRvKCkubGluZSArIDEsIDApKVxuICAgIH0pOyB9KTsgfSxcbiAgICBkZWxMaW5lTGVmdDogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBkZWxldGVOZWFyU2VsZWN0aW9uKGNtLCBmdW5jdGlvbiAocmFuZ2UpIHsgcmV0dXJuICh7XG4gICAgICBmcm9tOiBQb3MocmFuZ2UuZnJvbSgpLmxpbmUsIDApLCB0bzogcmFuZ2UuZnJvbSgpXG4gICAgfSk7IH0pOyB9LFxuICAgIGRlbFdyYXBwZWRMaW5lTGVmdDogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBkZWxldGVOZWFyU2VsZWN0aW9uKGNtLCBmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAgIHZhciB0b3AgPSBjbS5jaGFyQ29vcmRzKHJhbmdlLmhlYWQsIFwiZGl2XCIpLnRvcCArIDU7XG4gICAgICB2YXIgbGVmdFBvcyA9IGNtLmNvb3Jkc0NoYXIoe2xlZnQ6IDAsIHRvcDogdG9wfSwgXCJkaXZcIik7XG4gICAgICByZXR1cm4ge2Zyb206IGxlZnRQb3MsIHRvOiByYW5nZS5mcm9tKCl9XG4gICAgfSk7IH0sXG4gICAgZGVsV3JhcHBlZExpbmVSaWdodDogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBkZWxldGVOZWFyU2VsZWN0aW9uKGNtLCBmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAgIHZhciB0b3AgPSBjbS5jaGFyQ29vcmRzKHJhbmdlLmhlYWQsIFwiZGl2XCIpLnRvcCArIDU7XG4gICAgICB2YXIgcmlnaHRQb3MgPSBjbS5jb29yZHNDaGFyKHtsZWZ0OiBjbS5kaXNwbGF5LmxpbmVEaXYub2Zmc2V0V2lkdGggKyAxMDAsIHRvcDogdG9wfSwgXCJkaXZcIik7XG4gICAgICByZXR1cm4ge2Zyb206IHJhbmdlLmZyb20oKSwgdG86IHJpZ2h0UG9zIH1cbiAgICB9KTsgfSxcbiAgICB1bmRvOiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLnVuZG8oKTsgfSxcbiAgICByZWRvOiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLnJlZG8oKTsgfSxcbiAgICB1bmRvU2VsZWN0aW9uOiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLnVuZG9TZWxlY3Rpb24oKTsgfSxcbiAgICByZWRvU2VsZWN0aW9uOiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLnJlZG9TZWxlY3Rpb24oKTsgfSxcbiAgICBnb0RvY1N0YXJ0OiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLmV4dGVuZFNlbGVjdGlvbihQb3MoY20uZmlyc3RMaW5lKCksIDApKTsgfSxcbiAgICBnb0RvY0VuZDogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5leHRlbmRTZWxlY3Rpb24oUG9zKGNtLmxhc3RMaW5lKCkpKTsgfSxcbiAgICBnb0xpbmVTdGFydDogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5leHRlbmRTZWxlY3Rpb25zQnkoZnVuY3Rpb24gKHJhbmdlKSB7IHJldHVybiBsaW5lU3RhcnQoY20sIHJhbmdlLmhlYWQubGluZSk7IH0sXG4gICAgICB7b3JpZ2luOiBcIittb3ZlXCIsIGJpYXM6IDF9XG4gICAgKTsgfSxcbiAgICBnb0xpbmVTdGFydFNtYXJ0OiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLmV4dGVuZFNlbGVjdGlvbnNCeShmdW5jdGlvbiAocmFuZ2UpIHsgcmV0dXJuIGxpbmVTdGFydFNtYXJ0KGNtLCByYW5nZS5oZWFkKTsgfSxcbiAgICAgIHtvcmlnaW46IFwiK21vdmVcIiwgYmlhczogMX1cbiAgICApOyB9LFxuICAgIGdvTGluZUVuZDogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5leHRlbmRTZWxlY3Rpb25zQnkoZnVuY3Rpb24gKHJhbmdlKSB7IHJldHVybiBsaW5lRW5kKGNtLCByYW5nZS5oZWFkLmxpbmUpOyB9LFxuICAgICAge29yaWdpbjogXCIrbW92ZVwiLCBiaWFzOiAtMX1cbiAgICApOyB9LFxuICAgIGdvTGluZVJpZ2h0OiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLmV4dGVuZFNlbGVjdGlvbnNCeShmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAgIHZhciB0b3AgPSBjbS5jdXJzb3JDb29yZHMocmFuZ2UuaGVhZCwgXCJkaXZcIikudG9wICsgNTtcbiAgICAgIHJldHVybiBjbS5jb29yZHNDaGFyKHtsZWZ0OiBjbS5kaXNwbGF5LmxpbmVEaXYub2Zmc2V0V2lkdGggKyAxMDAsIHRvcDogdG9wfSwgXCJkaXZcIilcbiAgICB9LCBzZWxfbW92ZSk7IH0sXG4gICAgZ29MaW5lTGVmdDogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5leHRlbmRTZWxlY3Rpb25zQnkoZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICB2YXIgdG9wID0gY20uY3Vyc29yQ29vcmRzKHJhbmdlLmhlYWQsIFwiZGl2XCIpLnRvcCArIDU7XG4gICAgICByZXR1cm4gY20uY29vcmRzQ2hhcih7bGVmdDogMCwgdG9wOiB0b3B9LCBcImRpdlwiKVxuICAgIH0sIHNlbF9tb3ZlKTsgfSxcbiAgICBnb0xpbmVMZWZ0U21hcnQ6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20uZXh0ZW5kU2VsZWN0aW9uc0J5KGZ1bmN0aW9uIChyYW5nZSkge1xuICAgICAgdmFyIHRvcCA9IGNtLmN1cnNvckNvb3JkcyhyYW5nZS5oZWFkLCBcImRpdlwiKS50b3AgKyA1O1xuICAgICAgdmFyIHBvcyA9IGNtLmNvb3Jkc0NoYXIoe2xlZnQ6IDAsIHRvcDogdG9wfSwgXCJkaXZcIik7XG4gICAgICBpZiAocG9zLmNoIDwgY20uZ2V0TGluZShwb3MubGluZSkuc2VhcmNoKC9cXFMvKSkgeyByZXR1cm4gbGluZVN0YXJ0U21hcnQoY20sIHJhbmdlLmhlYWQpIH1cbiAgICAgIHJldHVybiBwb3NcbiAgICB9LCBzZWxfbW92ZSk7IH0sXG4gICAgZ29MaW5lVXA6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20ubW92ZVYoLTEsIFwibGluZVwiKTsgfSxcbiAgICBnb0xpbmVEb3duOiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLm1vdmVWKDEsIFwibGluZVwiKTsgfSxcbiAgICBnb1BhZ2VVcDogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5tb3ZlVigtMSwgXCJwYWdlXCIpOyB9LFxuICAgIGdvUGFnZURvd246IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20ubW92ZVYoMSwgXCJwYWdlXCIpOyB9LFxuICAgIGdvQ2hhckxlZnQ6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20ubW92ZUgoLTEsIFwiY2hhclwiKTsgfSxcbiAgICBnb0NoYXJSaWdodDogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5tb3ZlSCgxLCBcImNoYXJcIik7IH0sXG4gICAgZ29Db2x1bW5MZWZ0OiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLm1vdmVIKC0xLCBcImNvbHVtblwiKTsgfSxcbiAgICBnb0NvbHVtblJpZ2h0OiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLm1vdmVIKDEsIFwiY29sdW1uXCIpOyB9LFxuICAgIGdvV29yZExlZnQ6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20ubW92ZUgoLTEsIFwid29yZFwiKTsgfSxcbiAgICBnb0dyb3VwUmlnaHQ6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20ubW92ZUgoMSwgXCJncm91cFwiKTsgfSxcbiAgICBnb0dyb3VwTGVmdDogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5tb3ZlSCgtMSwgXCJncm91cFwiKTsgfSxcbiAgICBnb1dvcmRSaWdodDogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5tb3ZlSCgxLCBcIndvcmRcIik7IH0sXG4gICAgZGVsQ2hhckJlZm9yZTogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5kZWxldGVIKC0xLCBcImNvZGVwb2ludFwiKTsgfSxcbiAgICBkZWxDaGFyQWZ0ZXI6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20uZGVsZXRlSCgxLCBcImNoYXJcIik7IH0sXG4gICAgZGVsV29yZEJlZm9yZTogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5kZWxldGVIKC0xLCBcIndvcmRcIik7IH0sXG4gICAgZGVsV29yZEFmdGVyOiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLmRlbGV0ZUgoMSwgXCJ3b3JkXCIpOyB9LFxuICAgIGRlbEdyb3VwQmVmb3JlOiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLmRlbGV0ZUgoLTEsIFwiZ3JvdXBcIik7IH0sXG4gICAgZGVsR3JvdXBBZnRlcjogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5kZWxldGVIKDEsIFwiZ3JvdXBcIik7IH0sXG4gICAgaW5kZW50QXV0bzogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5pbmRlbnRTZWxlY3Rpb24oXCJzbWFydFwiKTsgfSxcbiAgICBpbmRlbnRNb3JlOiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLmluZGVudFNlbGVjdGlvbihcImFkZFwiKTsgfSxcbiAgICBpbmRlbnRMZXNzOiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLmluZGVudFNlbGVjdGlvbihcInN1YnRyYWN0XCIpOyB9LFxuICAgIGluc2VydFRhYjogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5yZXBsYWNlU2VsZWN0aW9uKFwiXFx0XCIpOyB9LFxuICAgIGluc2VydFNvZnRUYWI6IGZ1bmN0aW9uIChjbSkge1xuICAgICAgdmFyIHNwYWNlcyA9IFtdLCByYW5nZXMgPSBjbS5saXN0U2VsZWN0aW9ucygpLCB0YWJTaXplID0gY20ub3B0aW9ucy50YWJTaXplO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHBvcyA9IHJhbmdlc1tpXS5mcm9tKCk7XG4gICAgICAgIHZhciBjb2wgPSBjb3VudENvbHVtbihjbS5nZXRMaW5lKHBvcy5saW5lKSwgcG9zLmNoLCB0YWJTaXplKTtcbiAgICAgICAgc3BhY2VzLnB1c2goc3BhY2VTdHIodGFiU2l6ZSAtIGNvbCAlIHRhYlNpemUpKTtcbiAgICAgIH1cbiAgICAgIGNtLnJlcGxhY2VTZWxlY3Rpb25zKHNwYWNlcyk7XG4gICAgfSxcbiAgICBkZWZhdWx0VGFiOiBmdW5jdGlvbiAoY20pIHtcbiAgICAgIGlmIChjbS5zb21ldGhpbmdTZWxlY3RlZCgpKSB7IGNtLmluZGVudFNlbGVjdGlvbihcImFkZFwiKTsgfVxuICAgICAgZWxzZSB7IGNtLmV4ZWNDb21tYW5kKFwiaW5zZXJ0VGFiXCIpOyB9XG4gICAgfSxcbiAgICAvLyBTd2FwIHRoZSB0d28gY2hhcnMgbGVmdCBhbmQgcmlnaHQgb2YgZWFjaCBzZWxlY3Rpb24ncyBoZWFkLlxuICAgIC8vIE1vdmUgY3Vyc29yIGJlaGluZCB0aGUgdHdvIHN3YXBwZWQgY2hhcmFjdGVycyBhZnRlcndhcmRzLlxuICAgIC8vXG4gICAgLy8gRG9lc24ndCBjb25zaWRlciBsaW5lIGZlZWRzIGEgY2hhcmFjdGVyLlxuICAgIC8vIERvZXNuJ3Qgc2NhbiBtb3JlIHRoYW4gb25lIGxpbmUgYWJvdmUgdG8gZmluZCBhIGNoYXJhY3Rlci5cbiAgICAvLyBEb2Vzbid0IGRvIGFueXRoaW5nIG9uIGFuIGVtcHR5IGxpbmUuXG4gICAgLy8gRG9lc24ndCBkbyBhbnl0aGluZyB3aXRoIG5vbi1lbXB0eSBzZWxlY3Rpb25zLlxuICAgIHRyYW5zcG9zZUNoYXJzOiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIHJ1bkluT3AoY20sIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciByYW5nZXMgPSBjbS5saXN0U2VsZWN0aW9ucygpLCBuZXdTZWwgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICghcmFuZ2VzW2ldLmVtcHR5KCkpIHsgY29udGludWUgfVxuICAgICAgICB2YXIgY3VyID0gcmFuZ2VzW2ldLmhlYWQsIGxpbmUgPSBnZXRMaW5lKGNtLmRvYywgY3VyLmxpbmUpLnRleHQ7XG4gICAgICAgIGlmIChsaW5lKSB7XG4gICAgICAgICAgaWYgKGN1ci5jaCA9PSBsaW5lLmxlbmd0aCkgeyBjdXIgPSBuZXcgUG9zKGN1ci5saW5lLCBjdXIuY2ggLSAxKTsgfVxuICAgICAgICAgIGlmIChjdXIuY2ggPiAwKSB7XG4gICAgICAgICAgICBjdXIgPSBuZXcgUG9zKGN1ci5saW5lLCBjdXIuY2ggKyAxKTtcbiAgICAgICAgICAgIGNtLnJlcGxhY2VSYW5nZShsaW5lLmNoYXJBdChjdXIuY2ggLSAxKSArIGxpbmUuY2hhckF0KGN1ci5jaCAtIDIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFBvcyhjdXIubGluZSwgY3VyLmNoIC0gMiksIGN1ciwgXCIrdHJhbnNwb3NlXCIpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY3VyLmxpbmUgPiBjbS5kb2MuZmlyc3QpIHtcbiAgICAgICAgICAgIHZhciBwcmV2ID0gZ2V0TGluZShjbS5kb2MsIGN1ci5saW5lIC0gMSkudGV4dDtcbiAgICAgICAgICAgIGlmIChwcmV2KSB7XG4gICAgICAgICAgICAgIGN1ciA9IG5ldyBQb3MoY3VyLmxpbmUsIDEpO1xuICAgICAgICAgICAgICBjbS5yZXBsYWNlUmFuZ2UobGluZS5jaGFyQXQoMCkgKyBjbS5kb2MubGluZVNlcGFyYXRvcigpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXYuY2hhckF0KHByZXYubGVuZ3RoIC0gMSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBQb3MoY3VyLmxpbmUgLSAxLCBwcmV2Lmxlbmd0aCAtIDEpLCBjdXIsIFwiK3RyYW5zcG9zZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbmV3U2VsLnB1c2gobmV3IFJhbmdlKGN1ciwgY3VyKSk7XG4gICAgICB9XG4gICAgICBjbS5zZXRTZWxlY3Rpb25zKG5ld1NlbCk7XG4gICAgfSk7IH0sXG4gICAgbmV3bGluZUFuZEluZGVudDogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBydW5Jbk9wKGNtLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc2VscyA9IGNtLmxpc3RTZWxlY3Rpb25zKCk7XG4gICAgICBmb3IgKHZhciBpID0gc2Vscy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgeyBjbS5yZXBsYWNlUmFuZ2UoY20uZG9jLmxpbmVTZXBhcmF0b3IoKSwgc2Vsc1tpXS5hbmNob3IsIHNlbHNbaV0uaGVhZCwgXCIraW5wdXRcIik7IH1cbiAgICAgIHNlbHMgPSBjbS5saXN0U2VsZWN0aW9ucygpO1xuICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgc2Vscy5sZW5ndGg7IGkkMSsrKVxuICAgICAgICB7IGNtLmluZGVudExpbmUoc2Vsc1tpJDFdLmZyb20oKS5saW5lLCBudWxsLCB0cnVlKTsgfVxuICAgICAgZW5zdXJlQ3Vyc29yVmlzaWJsZShjbSk7XG4gICAgfSk7IH0sXG4gICAgb3BlbkxpbmU6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20ucmVwbGFjZVNlbGVjdGlvbihcIlxcblwiLCBcInN0YXJ0XCIpOyB9LFxuICAgIHRvZ2dsZU92ZXJ3cml0ZTogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS50b2dnbGVPdmVyd3JpdGUoKTsgfVxuICB9O1xuXG5cbiAgZnVuY3Rpb24gbGluZVN0YXJ0KGNtLCBsaW5lTikge1xuICAgIHZhciBsaW5lID0gZ2V0TGluZShjbS5kb2MsIGxpbmVOKTtcbiAgICB2YXIgdmlzdWFsID0gdmlzdWFsTGluZShsaW5lKTtcbiAgICBpZiAodmlzdWFsICE9IGxpbmUpIHsgbGluZU4gPSBsaW5lTm8odmlzdWFsKTsgfVxuICAgIHJldHVybiBlbmRPZkxpbmUodHJ1ZSwgY20sIHZpc3VhbCwgbGluZU4sIDEpXG4gIH1cbiAgZnVuY3Rpb24gbGluZUVuZChjbSwgbGluZU4pIHtcbiAgICB2YXIgbGluZSA9IGdldExpbmUoY20uZG9jLCBsaW5lTik7XG4gICAgdmFyIHZpc3VhbCA9IHZpc3VhbExpbmVFbmQobGluZSk7XG4gICAgaWYgKHZpc3VhbCAhPSBsaW5lKSB7IGxpbmVOID0gbGluZU5vKHZpc3VhbCk7IH1cbiAgICByZXR1cm4gZW5kT2ZMaW5lKHRydWUsIGNtLCBsaW5lLCBsaW5lTiwgLTEpXG4gIH1cbiAgZnVuY3Rpb24gbGluZVN0YXJ0U21hcnQoY20sIHBvcykge1xuICAgIHZhciBzdGFydCA9IGxpbmVTdGFydChjbSwgcG9zLmxpbmUpO1xuICAgIHZhciBsaW5lID0gZ2V0TGluZShjbS5kb2MsIHN0YXJ0LmxpbmUpO1xuICAgIHZhciBvcmRlciA9IGdldE9yZGVyKGxpbmUsIGNtLmRvYy5kaXJlY3Rpb24pO1xuICAgIGlmICghb3JkZXIgfHwgb3JkZXJbMF0ubGV2ZWwgPT0gMCkge1xuICAgICAgdmFyIGZpcnN0Tm9uV1MgPSBNYXRoLm1heChzdGFydC5jaCwgbGluZS50ZXh0LnNlYXJjaCgvXFxTLykpO1xuICAgICAgdmFyIGluV1MgPSBwb3MubGluZSA9PSBzdGFydC5saW5lICYmIHBvcy5jaCA8PSBmaXJzdE5vbldTICYmIHBvcy5jaDtcbiAgICAgIHJldHVybiBQb3Moc3RhcnQubGluZSwgaW5XUyA/IDAgOiBmaXJzdE5vbldTLCBzdGFydC5zdGlja3kpXG4gICAgfVxuICAgIHJldHVybiBzdGFydFxuICB9XG5cbiAgLy8gUnVuIGEgaGFuZGxlciB0aGF0IHdhcyBib3VuZCB0byBhIGtleS5cbiAgZnVuY3Rpb24gZG9IYW5kbGVCaW5kaW5nKGNtLCBib3VuZCwgZHJvcFNoaWZ0KSB7XG4gICAgaWYgKHR5cGVvZiBib3VuZCA9PSBcInN0cmluZ1wiKSB7XG4gICAgICBib3VuZCA9IGNvbW1hbmRzW2JvdW5kXTtcbiAgICAgIGlmICghYm91bmQpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICB9XG4gICAgLy8gRW5zdXJlIHByZXZpb3VzIGlucHV0IGhhcyBiZWVuIHJlYWQsIHNvIHRoYXQgdGhlIGhhbmRsZXIgc2VlcyBhXG4gICAgLy8gY29uc2lzdGVudCB2aWV3IG9mIHRoZSBkb2N1bWVudFxuICAgIGNtLmRpc3BsYXkuaW5wdXQuZW5zdXJlUG9sbGVkKCk7XG4gICAgdmFyIHByZXZTaGlmdCA9IGNtLmRpc3BsYXkuc2hpZnQsIGRvbmUgPSBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgaWYgKGNtLmlzUmVhZE9ubHkoKSkgeyBjbS5zdGF0ZS5zdXBwcmVzc0VkaXRzID0gdHJ1ZTsgfVxuICAgICAgaWYgKGRyb3BTaGlmdCkgeyBjbS5kaXNwbGF5LnNoaWZ0ID0gZmFsc2U7IH1cbiAgICAgIGRvbmUgPSBib3VuZChjbSkgIT0gUGFzcztcbiAgICB9IGZpbmFsbHkge1xuICAgICAgY20uZGlzcGxheS5zaGlmdCA9IHByZXZTaGlmdDtcbiAgICAgIGNtLnN0YXRlLnN1cHByZXNzRWRpdHMgPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGRvbmVcbiAgfVxuXG4gIGZ1bmN0aW9uIGxvb2t1cEtleUZvckVkaXRvcihjbSwgbmFtZSwgaGFuZGxlKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbS5zdGF0ZS5rZXlNYXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gbG9va3VwS2V5KG5hbWUsIGNtLnN0YXRlLmtleU1hcHNbaV0sIGhhbmRsZSwgY20pO1xuICAgICAgaWYgKHJlc3VsdCkgeyByZXR1cm4gcmVzdWx0IH1cbiAgICB9XG4gICAgcmV0dXJuIChjbS5vcHRpb25zLmV4dHJhS2V5cyAmJiBsb29rdXBLZXkobmFtZSwgY20ub3B0aW9ucy5leHRyYUtleXMsIGhhbmRsZSwgY20pKVxuICAgICAgfHwgbG9va3VwS2V5KG5hbWUsIGNtLm9wdGlvbnMua2V5TWFwLCBoYW5kbGUsIGNtKVxuICB9XG5cbiAgLy8gTm90ZSB0aGF0LCBkZXNwaXRlIHRoZSBuYW1lLCB0aGlzIGZ1bmN0aW9uIGlzIGFsc28gdXNlZCB0byBjaGVja1xuICAvLyBmb3IgYm91bmQgbW91c2UgY2xpY2tzLlxuXG4gIHZhciBzdG9wU2VxID0gbmV3IERlbGF5ZWQ7XG5cbiAgZnVuY3Rpb24gZGlzcGF0Y2hLZXkoY20sIG5hbWUsIGUsIGhhbmRsZSkge1xuICAgIHZhciBzZXEgPSBjbS5zdGF0ZS5rZXlTZXE7XG4gICAgaWYgKHNlcSkge1xuICAgICAgaWYgKGlzTW9kaWZpZXJLZXkobmFtZSkpIHsgcmV0dXJuIFwiaGFuZGxlZFwiIH1cbiAgICAgIGlmICgvXFwnJC8udGVzdChuYW1lKSlcbiAgICAgICAgeyBjbS5zdGF0ZS5rZXlTZXEgPSBudWxsOyB9XG4gICAgICBlbHNlXG4gICAgICAgIHsgc3RvcFNlcS5zZXQoNTAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoY20uc3RhdGUua2V5U2VxID09IHNlcSkge1xuICAgICAgICAgICAgY20uc3RhdGUua2V5U2VxID0gbnVsbDtcbiAgICAgICAgICAgIGNtLmRpc3BsYXkuaW5wdXQucmVzZXQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pOyB9XG4gICAgICBpZiAoZGlzcGF0Y2hLZXlJbm5lcihjbSwgc2VxICsgXCIgXCIgKyBuYW1lLCBlLCBoYW5kbGUpKSB7IHJldHVybiB0cnVlIH1cbiAgICB9XG4gICAgcmV0dXJuIGRpc3BhdGNoS2V5SW5uZXIoY20sIG5hbWUsIGUsIGhhbmRsZSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGRpc3BhdGNoS2V5SW5uZXIoY20sIG5hbWUsIGUsIGhhbmRsZSkge1xuICAgIHZhciByZXN1bHQgPSBsb29rdXBLZXlGb3JFZGl0b3IoY20sIG5hbWUsIGhhbmRsZSk7XG5cbiAgICBpZiAocmVzdWx0ID09IFwibXVsdGlcIilcbiAgICAgIHsgY20uc3RhdGUua2V5U2VxID0gbmFtZTsgfVxuICAgIGlmIChyZXN1bHQgPT0gXCJoYW5kbGVkXCIpXG4gICAgICB7IHNpZ25hbExhdGVyKGNtLCBcImtleUhhbmRsZWRcIiwgY20sIG5hbWUsIGUpOyB9XG5cbiAgICBpZiAocmVzdWx0ID09IFwiaGFuZGxlZFwiIHx8IHJlc3VsdCA9PSBcIm11bHRpXCIpIHtcbiAgICAgIGVfcHJldmVudERlZmF1bHQoZSk7XG4gICAgICByZXN0YXJ0QmxpbmsoY20pO1xuICAgIH1cblxuICAgIHJldHVybiAhIXJlc3VsdFxuICB9XG5cbiAgLy8gSGFuZGxlIGEga2V5IGZyb20gdGhlIGtleWRvd24gZXZlbnQuXG4gIGZ1bmN0aW9uIGhhbmRsZUtleUJpbmRpbmcoY20sIGUpIHtcbiAgICB2YXIgbmFtZSA9IGtleU5hbWUoZSwgdHJ1ZSk7XG4gICAgaWYgKCFuYW1lKSB7IHJldHVybiBmYWxzZSB9XG5cbiAgICBpZiAoZS5zaGlmdEtleSAmJiAhY20uc3RhdGUua2V5U2VxKSB7XG4gICAgICAvLyBGaXJzdCB0cnkgdG8gcmVzb2x2ZSBmdWxsIG5hbWUgKGluY2x1ZGluZyAnU2hpZnQtJykuIEZhaWxpbmdcbiAgICAgIC8vIHRoYXQsIHNlZSBpZiB0aGVyZSBpcyBhIGN1cnNvci1tb3Rpb24gY29tbWFuZCAoc3RhcnRpbmcgd2l0aFxuICAgICAgLy8gJ2dvJykgYm91bmQgdG8gdGhlIGtleW5hbWUgd2l0aG91dCAnU2hpZnQtJy5cbiAgICAgIHJldHVybiBkaXNwYXRjaEtleShjbSwgXCJTaGlmdC1cIiArIG5hbWUsIGUsIGZ1bmN0aW9uIChiKSB7IHJldHVybiBkb0hhbmRsZUJpbmRpbmcoY20sIGIsIHRydWUpOyB9KVxuICAgICAgICAgIHx8IGRpc3BhdGNoS2V5KGNtLCBuYW1lLCBlLCBmdW5jdGlvbiAoYikge1xuICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBiID09IFwic3RyaW5nXCIgPyAvXmdvW0EtWl0vLnRlc3QoYikgOiBiLm1vdGlvbilcbiAgICAgICAgICAgICAgICAgeyByZXR1cm4gZG9IYW5kbGVCaW5kaW5nKGNtLCBiKSB9XG4gICAgICAgICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGRpc3BhdGNoS2V5KGNtLCBuYW1lLCBlLCBmdW5jdGlvbiAoYikgeyByZXR1cm4gZG9IYW5kbGVCaW5kaW5nKGNtLCBiKTsgfSlcbiAgICB9XG4gIH1cblxuICAvLyBIYW5kbGUgYSBrZXkgZnJvbSB0aGUga2V5cHJlc3MgZXZlbnRcbiAgZnVuY3Rpb24gaGFuZGxlQ2hhckJpbmRpbmcoY20sIGUsIGNoKSB7XG4gICAgcmV0dXJuIGRpc3BhdGNoS2V5KGNtLCBcIidcIiArIGNoICsgXCInXCIsIGUsIGZ1bmN0aW9uIChiKSB7IHJldHVybiBkb0hhbmRsZUJpbmRpbmcoY20sIGIsIHRydWUpOyB9KVxuICB9XG5cbiAgdmFyIGxhc3RTdG9wcGVkS2V5ID0gbnVsbDtcbiAgZnVuY3Rpb24gb25LZXlEb3duKGUpIHtcbiAgICB2YXIgY20gPSB0aGlzO1xuICAgIGlmIChlLnRhcmdldCAmJiBlLnRhcmdldCAhPSBjbS5kaXNwbGF5LmlucHV0LmdldEZpZWxkKCkpIHsgcmV0dXJuIH1cbiAgICBjbS5jdXJPcC5mb2N1cyA9IGFjdGl2ZUVsdCgpO1xuICAgIGlmIChzaWduYWxET01FdmVudChjbSwgZSkpIHsgcmV0dXJuIH1cbiAgICAvLyBJRSBkb2VzIHN0cmFuZ2UgdGhpbmdzIHdpdGggZXNjYXBlLlxuICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDwgMTEgJiYgZS5rZXlDb2RlID09IDI3KSB7IGUucmV0dXJuVmFsdWUgPSBmYWxzZTsgfVxuICAgIHZhciBjb2RlID0gZS5rZXlDb2RlO1xuICAgIGNtLmRpc3BsYXkuc2hpZnQgPSBjb2RlID09IDE2IHx8IGUuc2hpZnRLZXk7XG4gICAgdmFyIGhhbmRsZWQgPSBoYW5kbGVLZXlCaW5kaW5nKGNtLCBlKTtcbiAgICBpZiAocHJlc3RvKSB7XG4gICAgICBsYXN0U3RvcHBlZEtleSA9IGhhbmRsZWQgPyBjb2RlIDogbnVsbDtcbiAgICAgIC8vIE9wZXJhIGhhcyBubyBjdXQgZXZlbnQuLi4gd2UgdHJ5IHRvIGF0IGxlYXN0IGNhdGNoIHRoZSBrZXkgY29tYm9cbiAgICAgIGlmICghaGFuZGxlZCAmJiBjb2RlID09IDg4ICYmICFoYXNDb3B5RXZlbnQgJiYgKG1hYyA/IGUubWV0YUtleSA6IGUuY3RybEtleSkpXG4gICAgICAgIHsgY20ucmVwbGFjZVNlbGVjdGlvbihcIlwiLCBudWxsLCBcImN1dFwiKTsgfVxuICAgIH1cbiAgICBpZiAoZ2Vja28gJiYgIW1hYyAmJiAhaGFuZGxlZCAmJiBjb2RlID09IDQ2ICYmIGUuc2hpZnRLZXkgJiYgIWUuY3RybEtleSAmJiBkb2N1bWVudC5leGVjQ29tbWFuZClcbiAgICAgIHsgZG9jdW1lbnQuZXhlY0NvbW1hbmQoXCJjdXRcIik7IH1cblxuICAgIC8vIFR1cm4gbW91c2UgaW50byBjcm9zc2hhaXIgd2hlbiBBbHQgaXMgaGVsZCBvbiBNYWMuXG4gICAgaWYgKGNvZGUgPT0gMTggJiYgIS9cXGJDb2RlTWlycm9yLWNyb3NzaGFpclxcYi8udGVzdChjbS5kaXNwbGF5LmxpbmVEaXYuY2xhc3NOYW1lKSlcbiAgICAgIHsgc2hvd0Nyb3NzSGFpcihjbSk7IH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNob3dDcm9zc0hhaXIoY20pIHtcbiAgICB2YXIgbGluZURpdiA9IGNtLmRpc3BsYXkubGluZURpdjtcbiAgICBhZGRDbGFzcyhsaW5lRGl2LCBcIkNvZGVNaXJyb3ItY3Jvc3NoYWlyXCIpO1xuXG4gICAgZnVuY3Rpb24gdXAoZSkge1xuICAgICAgaWYgKGUua2V5Q29kZSA9PSAxOCB8fCAhZS5hbHRLZXkpIHtcbiAgICAgICAgcm1DbGFzcyhsaW5lRGl2LCBcIkNvZGVNaXJyb3ItY3Jvc3NoYWlyXCIpO1xuICAgICAgICBvZmYoZG9jdW1lbnQsIFwia2V5dXBcIiwgdXApO1xuICAgICAgICBvZmYoZG9jdW1lbnQsIFwibW91c2VvdmVyXCIsIHVwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgb24oZG9jdW1lbnQsIFwia2V5dXBcIiwgdXApO1xuICAgIG9uKGRvY3VtZW50LCBcIm1vdXNlb3ZlclwiLCB1cCk7XG4gIH1cblxuICBmdW5jdGlvbiBvbktleVVwKGUpIHtcbiAgICBpZiAoZS5rZXlDb2RlID09IDE2KSB7IHRoaXMuZG9jLnNlbC5zaGlmdCA9IGZhbHNlOyB9XG4gICAgc2lnbmFsRE9NRXZlbnQodGhpcywgZSk7XG4gIH1cblxuICBmdW5jdGlvbiBvbktleVByZXNzKGUpIHtcbiAgICB2YXIgY20gPSB0aGlzO1xuICAgIGlmIChlLnRhcmdldCAmJiBlLnRhcmdldCAhPSBjbS5kaXNwbGF5LmlucHV0LmdldEZpZWxkKCkpIHsgcmV0dXJuIH1cbiAgICBpZiAoZXZlbnRJbldpZGdldChjbS5kaXNwbGF5LCBlKSB8fCBzaWduYWxET01FdmVudChjbSwgZSkgfHwgZS5jdHJsS2V5ICYmICFlLmFsdEtleSB8fCBtYWMgJiYgZS5tZXRhS2V5KSB7IHJldHVybiB9XG4gICAgdmFyIGtleUNvZGUgPSBlLmtleUNvZGUsIGNoYXJDb2RlID0gZS5jaGFyQ29kZTtcbiAgICBpZiAocHJlc3RvICYmIGtleUNvZGUgPT0gbGFzdFN0b3BwZWRLZXkpIHtsYXN0U3RvcHBlZEtleSA9IG51bGw7IGVfcHJldmVudERlZmF1bHQoZSk7IHJldHVybn1cbiAgICBpZiAoKHByZXN0byAmJiAoIWUud2hpY2ggfHwgZS53aGljaCA8IDEwKSkgJiYgaGFuZGxlS2V5QmluZGluZyhjbSwgZSkpIHsgcmV0dXJuIH1cbiAgICB2YXIgY2ggPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJDb2RlID09IG51bGwgPyBrZXlDb2RlIDogY2hhckNvZGUpO1xuICAgIC8vIFNvbWUgYnJvd3NlcnMgZmlyZSBrZXlwcmVzcyBldmVudHMgZm9yIGJhY2tzcGFjZVxuICAgIGlmIChjaCA9PSBcIlxceDA4XCIpIHsgcmV0dXJuIH1cbiAgICBpZiAoaGFuZGxlQ2hhckJpbmRpbmcoY20sIGUsIGNoKSkgeyByZXR1cm4gfVxuICAgIGNtLmRpc3BsYXkuaW5wdXQub25LZXlQcmVzcyhlKTtcbiAgfVxuXG4gIHZhciBET1VCTEVDTElDS19ERUxBWSA9IDQwMDtcblxuICB2YXIgUGFzdENsaWNrID0gZnVuY3Rpb24odGltZSwgcG9zLCBidXR0b24pIHtcbiAgICB0aGlzLnRpbWUgPSB0aW1lO1xuICAgIHRoaXMucG9zID0gcG9zO1xuICAgIHRoaXMuYnV0dG9uID0gYnV0dG9uO1xuICB9O1xuXG4gIFBhc3RDbGljay5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uICh0aW1lLCBwb3MsIGJ1dHRvbikge1xuICAgIHJldHVybiB0aGlzLnRpbWUgKyBET1VCTEVDTElDS19ERUxBWSA+IHRpbWUgJiZcbiAgICAgIGNtcChwb3MsIHRoaXMucG9zKSA9PSAwICYmIGJ1dHRvbiA9PSB0aGlzLmJ1dHRvblxuICB9O1xuXG4gIHZhciBsYXN0Q2xpY2ssIGxhc3REb3VibGVDbGljaztcbiAgZnVuY3Rpb24gY2xpY2tSZXBlYXQocG9zLCBidXR0b24pIHtcbiAgICB2YXIgbm93ID0gK25ldyBEYXRlO1xuICAgIGlmIChsYXN0RG91YmxlQ2xpY2sgJiYgbGFzdERvdWJsZUNsaWNrLmNvbXBhcmUobm93LCBwb3MsIGJ1dHRvbikpIHtcbiAgICAgIGxhc3RDbGljayA9IGxhc3REb3VibGVDbGljayA9IG51bGw7XG4gICAgICByZXR1cm4gXCJ0cmlwbGVcIlxuICAgIH0gZWxzZSBpZiAobGFzdENsaWNrICYmIGxhc3RDbGljay5jb21wYXJlKG5vdywgcG9zLCBidXR0b24pKSB7XG4gICAgICBsYXN0RG91YmxlQ2xpY2sgPSBuZXcgUGFzdENsaWNrKG5vdywgcG9zLCBidXR0b24pO1xuICAgICAgbGFzdENsaWNrID0gbnVsbDtcbiAgICAgIHJldHVybiBcImRvdWJsZVwiXG4gICAgfSBlbHNlIHtcbiAgICAgIGxhc3RDbGljayA9IG5ldyBQYXN0Q2xpY2sobm93LCBwb3MsIGJ1dHRvbik7XG4gICAgICBsYXN0RG91YmxlQ2xpY2sgPSBudWxsO1xuICAgICAgcmV0dXJuIFwic2luZ2xlXCJcbiAgICB9XG4gIH1cblxuICAvLyBBIG1vdXNlIGRvd24gY2FuIGJlIGEgc2luZ2xlIGNsaWNrLCBkb3VibGUgY2xpY2ssIHRyaXBsZSBjbGljayxcbiAgLy8gc3RhcnQgb2Ygc2VsZWN0aW9uIGRyYWcsIHN0YXJ0IG9mIHRleHQgZHJhZywgbmV3IGN1cnNvclxuICAvLyAoY3RybC1jbGljayksIHJlY3RhbmdsZSBkcmFnIChhbHQtZHJhZyksIG9yIHh3aW5cbiAgLy8gbWlkZGxlLWNsaWNrLXBhc3RlLiBPciBpdCBtaWdodCBiZSBhIGNsaWNrIG9uIHNvbWV0aGluZyB3ZSBzaG91bGRcbiAgLy8gbm90IGludGVyZmVyZSB3aXRoLCBzdWNoIGFzIGEgc2Nyb2xsYmFyIG9yIHdpZGdldC5cbiAgZnVuY3Rpb24gb25Nb3VzZURvd24oZSkge1xuICAgIHZhciBjbSA9IHRoaXMsIGRpc3BsYXkgPSBjbS5kaXNwbGF5O1xuICAgIGlmIChzaWduYWxET01FdmVudChjbSwgZSkgfHwgZGlzcGxheS5hY3RpdmVUb3VjaCAmJiBkaXNwbGF5LmlucHV0LnN1cHBvcnRzVG91Y2goKSkgeyByZXR1cm4gfVxuICAgIGRpc3BsYXkuaW5wdXQuZW5zdXJlUG9sbGVkKCk7XG4gICAgZGlzcGxheS5zaGlmdCA9IGUuc2hpZnRLZXk7XG5cbiAgICBpZiAoZXZlbnRJbldpZGdldChkaXNwbGF5LCBlKSkge1xuICAgICAgaWYgKCF3ZWJraXQpIHtcbiAgICAgICAgLy8gQnJpZWZseSB0dXJuIG9mZiBkcmFnZ2FiaWxpdHksIHRvIGFsbG93IHdpZGdldHMgdG8gZG9cbiAgICAgICAgLy8gbm9ybWFsIGRyYWdnaW5nIHRoaW5ncy5cbiAgICAgICAgZGlzcGxheS5zY3JvbGxlci5kcmFnZ2FibGUgPSBmYWxzZTtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBkaXNwbGF5LnNjcm9sbGVyLmRyYWdnYWJsZSA9IHRydWU7IH0sIDEwMCk7XG4gICAgICB9XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgaWYgKGNsaWNrSW5HdXR0ZXIoY20sIGUpKSB7IHJldHVybiB9XG4gICAgdmFyIHBvcyA9IHBvc0Zyb21Nb3VzZShjbSwgZSksIGJ1dHRvbiA9IGVfYnV0dG9uKGUpLCByZXBlYXQgPSBwb3MgPyBjbGlja1JlcGVhdChwb3MsIGJ1dHRvbikgOiBcInNpbmdsZVwiO1xuICAgIHdpbmRvdy5mb2N1cygpO1xuXG4gICAgLy8gIzMyNjE6IG1ha2Ugc3VyZSwgdGhhdCB3ZSdyZSBub3Qgc3RhcnRpbmcgYSBzZWNvbmQgc2VsZWN0aW9uXG4gICAgaWYgKGJ1dHRvbiA9PSAxICYmIGNtLnN0YXRlLnNlbGVjdGluZ1RleHQpXG4gICAgICB7IGNtLnN0YXRlLnNlbGVjdGluZ1RleHQoZSk7IH1cblxuICAgIGlmIChwb3MgJiYgaGFuZGxlTWFwcGVkQnV0dG9uKGNtLCBidXR0b24sIHBvcywgcmVwZWF0LCBlKSkgeyByZXR1cm4gfVxuXG4gICAgaWYgKGJ1dHRvbiA9PSAxKSB7XG4gICAgICBpZiAocG9zKSB7IGxlZnRCdXR0b25Eb3duKGNtLCBwb3MsIHJlcGVhdCwgZSk7IH1cbiAgICAgIGVsc2UgaWYgKGVfdGFyZ2V0KGUpID09IGRpc3BsYXkuc2Nyb2xsZXIpIHsgZV9wcmV2ZW50RGVmYXVsdChlKTsgfVxuICAgIH0gZWxzZSBpZiAoYnV0dG9uID09IDIpIHtcbiAgICAgIGlmIChwb3MpIHsgZXh0ZW5kU2VsZWN0aW9uKGNtLmRvYywgcG9zKTsgfVxuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBkaXNwbGF5LmlucHV0LmZvY3VzKCk7IH0sIDIwKTtcbiAgICB9IGVsc2UgaWYgKGJ1dHRvbiA9PSAzKSB7XG4gICAgICBpZiAoY2FwdHVyZVJpZ2h0Q2xpY2spIHsgY20uZGlzcGxheS5pbnB1dC5vbkNvbnRleHRNZW51KGUpOyB9XG4gICAgICBlbHNlIHsgZGVsYXlCbHVyRXZlbnQoY20pOyB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlTWFwcGVkQnV0dG9uKGNtLCBidXR0b24sIHBvcywgcmVwZWF0LCBldmVudCkge1xuICAgIHZhciBuYW1lID0gXCJDbGlja1wiO1xuICAgIGlmIChyZXBlYXQgPT0gXCJkb3VibGVcIikgeyBuYW1lID0gXCJEb3VibGVcIiArIG5hbWU7IH1cbiAgICBlbHNlIGlmIChyZXBlYXQgPT0gXCJ0cmlwbGVcIikgeyBuYW1lID0gXCJUcmlwbGVcIiArIG5hbWU7IH1cbiAgICBuYW1lID0gKGJ1dHRvbiA9PSAxID8gXCJMZWZ0XCIgOiBidXR0b24gPT0gMiA/IFwiTWlkZGxlXCIgOiBcIlJpZ2h0XCIpICsgbmFtZTtcblxuICAgIHJldHVybiBkaXNwYXRjaEtleShjbSwgIGFkZE1vZGlmaWVyTmFtZXMobmFtZSwgZXZlbnQpLCBldmVudCwgZnVuY3Rpb24gKGJvdW5kKSB7XG4gICAgICBpZiAodHlwZW9mIGJvdW5kID09IFwic3RyaW5nXCIpIHsgYm91bmQgPSBjb21tYW5kc1tib3VuZF07IH1cbiAgICAgIGlmICghYm91bmQpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICAgIHZhciBkb25lID0gZmFsc2U7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoY20uaXNSZWFkT25seSgpKSB7IGNtLnN0YXRlLnN1cHByZXNzRWRpdHMgPSB0cnVlOyB9XG4gICAgICAgIGRvbmUgPSBib3VuZChjbSwgcG9zKSAhPSBQYXNzO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgY20uc3RhdGUuc3VwcHJlc3NFZGl0cyA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRvbmVcbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gY29uZmlndXJlTW91c2UoY20sIHJlcGVhdCwgZXZlbnQpIHtcbiAgICB2YXIgb3B0aW9uID0gY20uZ2V0T3B0aW9uKFwiY29uZmlndXJlTW91c2VcIik7XG4gICAgdmFyIHZhbHVlID0gb3B0aW9uID8gb3B0aW9uKGNtLCByZXBlYXQsIGV2ZW50KSA6IHt9O1xuICAgIGlmICh2YWx1ZS51bml0ID09IG51bGwpIHtcbiAgICAgIHZhciByZWN0ID0gY2hyb21lT1MgPyBldmVudC5zaGlmdEtleSAmJiBldmVudC5tZXRhS2V5IDogZXZlbnQuYWx0S2V5O1xuICAgICAgdmFsdWUudW5pdCA9IHJlY3QgPyBcInJlY3RhbmdsZVwiIDogcmVwZWF0ID09IFwic2luZ2xlXCIgPyBcImNoYXJcIiA6IHJlcGVhdCA9PSBcImRvdWJsZVwiID8gXCJ3b3JkXCIgOiBcImxpbmVcIjtcbiAgICB9XG4gICAgaWYgKHZhbHVlLmV4dGVuZCA9PSBudWxsIHx8IGNtLmRvYy5leHRlbmQpIHsgdmFsdWUuZXh0ZW5kID0gY20uZG9jLmV4dGVuZCB8fCBldmVudC5zaGlmdEtleTsgfVxuICAgIGlmICh2YWx1ZS5hZGROZXcgPT0gbnVsbCkgeyB2YWx1ZS5hZGROZXcgPSBtYWMgPyBldmVudC5tZXRhS2V5IDogZXZlbnQuY3RybEtleTsgfVxuICAgIGlmICh2YWx1ZS5tb3ZlT25EcmFnID09IG51bGwpIHsgdmFsdWUubW92ZU9uRHJhZyA9ICEobWFjID8gZXZlbnQuYWx0S2V5IDogZXZlbnQuY3RybEtleSk7IH1cbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuXG4gIGZ1bmN0aW9uIGxlZnRCdXR0b25Eb3duKGNtLCBwb3MsIHJlcGVhdCwgZXZlbnQpIHtcbiAgICBpZiAoaWUpIHsgc2V0VGltZW91dChiaW5kKGVuc3VyZUZvY3VzLCBjbSksIDApOyB9XG4gICAgZWxzZSB7IGNtLmN1ck9wLmZvY3VzID0gYWN0aXZlRWx0KCk7IH1cblxuICAgIHZhciBiZWhhdmlvciA9IGNvbmZpZ3VyZU1vdXNlKGNtLCByZXBlYXQsIGV2ZW50KTtcblxuICAgIHZhciBzZWwgPSBjbS5kb2Muc2VsLCBjb250YWluZWQ7XG4gICAgaWYgKGNtLm9wdGlvbnMuZHJhZ0Ryb3AgJiYgZHJhZ0FuZERyb3AgJiYgIWNtLmlzUmVhZE9ubHkoKSAmJlxuICAgICAgICByZXBlYXQgPT0gXCJzaW5nbGVcIiAmJiAoY29udGFpbmVkID0gc2VsLmNvbnRhaW5zKHBvcykpID4gLTEgJiZcbiAgICAgICAgKGNtcCgoY29udGFpbmVkID0gc2VsLnJhbmdlc1tjb250YWluZWRdKS5mcm9tKCksIHBvcykgPCAwIHx8IHBvcy54UmVsID4gMCkgJiZcbiAgICAgICAgKGNtcChjb250YWluZWQudG8oKSwgcG9zKSA+IDAgfHwgcG9zLnhSZWwgPCAwKSlcbiAgICAgIHsgbGVmdEJ1dHRvblN0YXJ0RHJhZyhjbSwgZXZlbnQsIHBvcywgYmVoYXZpb3IpOyB9XG4gICAgZWxzZVxuICAgICAgeyBsZWZ0QnV0dG9uU2VsZWN0KGNtLCBldmVudCwgcG9zLCBiZWhhdmlvcik7IH1cbiAgfVxuXG4gIC8vIFN0YXJ0IGEgdGV4dCBkcmFnLiBXaGVuIGl0IGVuZHMsIHNlZSBpZiBhbnkgZHJhZ2dpbmcgYWN0dWFsbHlcbiAgLy8gaGFwcGVuLCBhbmQgdHJlYXQgYXMgYSBjbGljayBpZiBpdCBkaWRuJ3QuXG4gIGZ1bmN0aW9uIGxlZnRCdXR0b25TdGFydERyYWcoY20sIGV2ZW50LCBwb3MsIGJlaGF2aW9yKSB7XG4gICAgdmFyIGRpc3BsYXkgPSBjbS5kaXNwbGF5LCBtb3ZlZCA9IGZhbHNlO1xuICAgIHZhciBkcmFnRW5kID0gb3BlcmF0aW9uKGNtLCBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKHdlYmtpdCkgeyBkaXNwbGF5LnNjcm9sbGVyLmRyYWdnYWJsZSA9IGZhbHNlOyB9XG4gICAgICBjbS5zdGF0ZS5kcmFnZ2luZ1RleHQgPSBmYWxzZTtcbiAgICAgIGlmIChjbS5zdGF0ZS5kZWxheWluZ0JsdXJFdmVudCkge1xuICAgICAgICBpZiAoY20uaGFzRm9jdXMoKSkgeyBjbS5zdGF0ZS5kZWxheWluZ0JsdXJFdmVudCA9IGZhbHNlOyB9XG4gICAgICAgIGVsc2UgeyBkZWxheUJsdXJFdmVudChjbSk7IH1cbiAgICAgIH1cbiAgICAgIG9mZihkaXNwbGF5LndyYXBwZXIub3duZXJEb2N1bWVudCwgXCJtb3VzZXVwXCIsIGRyYWdFbmQpO1xuICAgICAgb2ZmKGRpc3BsYXkud3JhcHBlci5vd25lckRvY3VtZW50LCBcIm1vdXNlbW92ZVwiLCBtb3VzZU1vdmUpO1xuICAgICAgb2ZmKGRpc3BsYXkuc2Nyb2xsZXIsIFwiZHJhZ3N0YXJ0XCIsIGRyYWdTdGFydCk7XG4gICAgICBvZmYoZGlzcGxheS5zY3JvbGxlciwgXCJkcm9wXCIsIGRyYWdFbmQpO1xuICAgICAgaWYgKCFtb3ZlZCkge1xuICAgICAgICBlX3ByZXZlbnREZWZhdWx0KGUpO1xuICAgICAgICBpZiAoIWJlaGF2aW9yLmFkZE5ldylcbiAgICAgICAgICB7IGV4dGVuZFNlbGVjdGlvbihjbS5kb2MsIHBvcywgbnVsbCwgbnVsbCwgYmVoYXZpb3IuZXh0ZW5kKTsgfVxuICAgICAgICAvLyBXb3JrIGFyb3VuZCB1bmV4cGxhaW5hYmxlIGZvY3VzIHByb2JsZW0gaW4gSUU5ICgjMjEyNykgYW5kIENocm9tZSAoIzMwODEpXG4gICAgICAgIGlmICgod2Via2l0ICYmICFzYWZhcmkpIHx8IGllICYmIGllX3ZlcnNpb24gPT0gOSlcbiAgICAgICAgICB7IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge2Rpc3BsYXkud3JhcHBlci5vd25lckRvY3VtZW50LmJvZHkuZm9jdXMoe3ByZXZlbnRTY3JvbGw6IHRydWV9KTsgZGlzcGxheS5pbnB1dC5mb2N1cygpO30sIDIwKTsgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgeyBkaXNwbGF5LmlucHV0LmZvY3VzKCk7IH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgbW91c2VNb3ZlID0gZnVuY3Rpb24oZTIpIHtcbiAgICAgIG1vdmVkID0gbW92ZWQgfHwgTWF0aC5hYnMoZXZlbnQuY2xpZW50WCAtIGUyLmNsaWVudFgpICsgTWF0aC5hYnMoZXZlbnQuY2xpZW50WSAtIGUyLmNsaWVudFkpID49IDEwO1xuICAgIH07XG4gICAgdmFyIGRyYWdTdGFydCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1vdmVkID0gdHJ1ZTsgfTtcbiAgICAvLyBMZXQgdGhlIGRyYWcgaGFuZGxlciBoYW5kbGUgdGhpcy5cbiAgICBpZiAod2Via2l0KSB7IGRpc3BsYXkuc2Nyb2xsZXIuZHJhZ2dhYmxlID0gdHJ1ZTsgfVxuICAgIGNtLnN0YXRlLmRyYWdnaW5nVGV4dCA9IGRyYWdFbmQ7XG4gICAgZHJhZ0VuZC5jb3B5ID0gIWJlaGF2aW9yLm1vdmVPbkRyYWc7XG4gICAgb24oZGlzcGxheS53cmFwcGVyLm93bmVyRG9jdW1lbnQsIFwibW91c2V1cFwiLCBkcmFnRW5kKTtcbiAgICBvbihkaXNwbGF5LndyYXBwZXIub3duZXJEb2N1bWVudCwgXCJtb3VzZW1vdmVcIiwgbW91c2VNb3ZlKTtcbiAgICBvbihkaXNwbGF5LnNjcm9sbGVyLCBcImRyYWdzdGFydFwiLCBkcmFnU3RhcnQpO1xuICAgIG9uKGRpc3BsYXkuc2Nyb2xsZXIsIFwiZHJvcFwiLCBkcmFnRW5kKTtcblxuICAgIGNtLnN0YXRlLmRlbGF5aW5nQmx1ckV2ZW50ID0gdHJ1ZTtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRpc3BsYXkuaW5wdXQuZm9jdXMoKTsgfSwgMjApO1xuICAgIC8vIElFJ3MgYXBwcm9hY2ggdG8gZHJhZ2dhYmxlXG4gICAgaWYgKGRpc3BsYXkuc2Nyb2xsZXIuZHJhZ0Ryb3ApIHsgZGlzcGxheS5zY3JvbGxlci5kcmFnRHJvcCgpOyB9XG4gIH1cblxuICBmdW5jdGlvbiByYW5nZUZvclVuaXQoY20sIHBvcywgdW5pdCkge1xuICAgIGlmICh1bml0ID09IFwiY2hhclwiKSB7IHJldHVybiBuZXcgUmFuZ2UocG9zLCBwb3MpIH1cbiAgICBpZiAodW5pdCA9PSBcIndvcmRcIikgeyByZXR1cm4gY20uZmluZFdvcmRBdChwb3MpIH1cbiAgICBpZiAodW5pdCA9PSBcImxpbmVcIikgeyByZXR1cm4gbmV3IFJhbmdlKFBvcyhwb3MubGluZSwgMCksIGNsaXBQb3MoY20uZG9jLCBQb3MocG9zLmxpbmUgKyAxLCAwKSkpIH1cbiAgICB2YXIgcmVzdWx0ID0gdW5pdChjbSwgcG9zKTtcbiAgICByZXR1cm4gbmV3IFJhbmdlKHJlc3VsdC5mcm9tLCByZXN1bHQudG8pXG4gIH1cblxuICAvLyBOb3JtYWwgc2VsZWN0aW9uLCBhcyBvcHBvc2VkIHRvIHRleHQgZHJhZ2dpbmcuXG4gIGZ1bmN0aW9uIGxlZnRCdXR0b25TZWxlY3QoY20sIGV2ZW50LCBzdGFydCwgYmVoYXZpb3IpIHtcbiAgICBpZiAoaWUpIHsgZGVsYXlCbHVyRXZlbnQoY20pOyB9XG4gICAgdmFyIGRpc3BsYXkgPSBjbS5kaXNwbGF5LCBkb2MgPSBjbS5kb2M7XG4gICAgZV9wcmV2ZW50RGVmYXVsdChldmVudCk7XG5cbiAgICB2YXIgb3VyUmFuZ2UsIG91ckluZGV4LCBzdGFydFNlbCA9IGRvYy5zZWwsIHJhbmdlcyA9IHN0YXJ0U2VsLnJhbmdlcztcbiAgICBpZiAoYmVoYXZpb3IuYWRkTmV3ICYmICFiZWhhdmlvci5leHRlbmQpIHtcbiAgICAgIG91ckluZGV4ID0gZG9jLnNlbC5jb250YWlucyhzdGFydCk7XG4gICAgICBpZiAob3VySW5kZXggPiAtMSlcbiAgICAgICAgeyBvdXJSYW5nZSA9IHJhbmdlc1tvdXJJbmRleF07IH1cbiAgICAgIGVsc2VcbiAgICAgICAgeyBvdXJSYW5nZSA9IG5ldyBSYW5nZShzdGFydCwgc3RhcnQpOyB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG91clJhbmdlID0gZG9jLnNlbC5wcmltYXJ5KCk7XG4gICAgICBvdXJJbmRleCA9IGRvYy5zZWwucHJpbUluZGV4O1xuICAgIH1cblxuICAgIGlmIChiZWhhdmlvci51bml0ID09IFwicmVjdGFuZ2xlXCIpIHtcbiAgICAgIGlmICghYmVoYXZpb3IuYWRkTmV3KSB7IG91clJhbmdlID0gbmV3IFJhbmdlKHN0YXJ0LCBzdGFydCk7IH1cbiAgICAgIHN0YXJ0ID0gcG9zRnJvbU1vdXNlKGNtLCBldmVudCwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICBvdXJJbmRleCA9IC0xO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcmFuZ2UgPSByYW5nZUZvclVuaXQoY20sIHN0YXJ0LCBiZWhhdmlvci51bml0KTtcbiAgICAgIGlmIChiZWhhdmlvci5leHRlbmQpXG4gICAgICAgIHsgb3VyUmFuZ2UgPSBleHRlbmRSYW5nZShvdXJSYW5nZSwgcmFuZ2UuYW5jaG9yLCByYW5nZS5oZWFkLCBiZWhhdmlvci5leHRlbmQpOyB9XG4gICAgICBlbHNlXG4gICAgICAgIHsgb3VyUmFuZ2UgPSByYW5nZTsgfVxuICAgIH1cblxuICAgIGlmICghYmVoYXZpb3IuYWRkTmV3KSB7XG4gICAgICBvdXJJbmRleCA9IDA7XG4gICAgICBzZXRTZWxlY3Rpb24oZG9jLCBuZXcgU2VsZWN0aW9uKFtvdXJSYW5nZV0sIDApLCBzZWxfbW91c2UpO1xuICAgICAgc3RhcnRTZWwgPSBkb2Muc2VsO1xuICAgIH0gZWxzZSBpZiAob3VySW5kZXggPT0gLTEpIHtcbiAgICAgIG91ckluZGV4ID0gcmFuZ2VzLmxlbmd0aDtcbiAgICAgIHNldFNlbGVjdGlvbihkb2MsIG5vcm1hbGl6ZVNlbGVjdGlvbihjbSwgcmFuZ2VzLmNvbmNhdChbb3VyUmFuZ2VdKSwgb3VySW5kZXgpLFxuICAgICAgICAgICAgICAgICAgIHtzY3JvbGw6IGZhbHNlLCBvcmlnaW46IFwiKm1vdXNlXCJ9KTtcbiAgICB9IGVsc2UgaWYgKHJhbmdlcy5sZW5ndGggPiAxICYmIHJhbmdlc1tvdXJJbmRleF0uZW1wdHkoKSAmJiBiZWhhdmlvci51bml0ID09IFwiY2hhclwiICYmICFiZWhhdmlvci5leHRlbmQpIHtcbiAgICAgIHNldFNlbGVjdGlvbihkb2MsIG5vcm1hbGl6ZVNlbGVjdGlvbihjbSwgcmFuZ2VzLnNsaWNlKDAsIG91ckluZGV4KS5jb25jYXQocmFuZ2VzLnNsaWNlKG91ckluZGV4ICsgMSkpLCAwKSxcbiAgICAgICAgICAgICAgICAgICB7c2Nyb2xsOiBmYWxzZSwgb3JpZ2luOiBcIiptb3VzZVwifSk7XG4gICAgICBzdGFydFNlbCA9IGRvYy5zZWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcGxhY2VPbmVTZWxlY3Rpb24oZG9jLCBvdXJJbmRleCwgb3VyUmFuZ2UsIHNlbF9tb3VzZSk7XG4gICAgfVxuXG4gICAgdmFyIGxhc3RQb3MgPSBzdGFydDtcbiAgICBmdW5jdGlvbiBleHRlbmRUbyhwb3MpIHtcbiAgICAgIGlmIChjbXAobGFzdFBvcywgcG9zKSA9PSAwKSB7IHJldHVybiB9XG4gICAgICBsYXN0UG9zID0gcG9zO1xuXG4gICAgICBpZiAoYmVoYXZpb3IudW5pdCA9PSBcInJlY3RhbmdsZVwiKSB7XG4gICAgICAgIHZhciByYW5nZXMgPSBbXSwgdGFiU2l6ZSA9IGNtLm9wdGlvbnMudGFiU2l6ZTtcbiAgICAgICAgdmFyIHN0YXJ0Q29sID0gY291bnRDb2x1bW4oZ2V0TGluZShkb2MsIHN0YXJ0LmxpbmUpLnRleHQsIHN0YXJ0LmNoLCB0YWJTaXplKTtcbiAgICAgICAgdmFyIHBvc0NvbCA9IGNvdW50Q29sdW1uKGdldExpbmUoZG9jLCBwb3MubGluZSkudGV4dCwgcG9zLmNoLCB0YWJTaXplKTtcbiAgICAgICAgdmFyIGxlZnQgPSBNYXRoLm1pbihzdGFydENvbCwgcG9zQ29sKSwgcmlnaHQgPSBNYXRoLm1heChzdGFydENvbCwgcG9zQ29sKTtcbiAgICAgICAgZm9yICh2YXIgbGluZSA9IE1hdGgubWluKHN0YXJ0LmxpbmUsIHBvcy5saW5lKSwgZW5kID0gTWF0aC5taW4oY20ubGFzdExpbmUoKSwgTWF0aC5tYXgoc3RhcnQubGluZSwgcG9zLmxpbmUpKTtcbiAgICAgICAgICAgICBsaW5lIDw9IGVuZDsgbGluZSsrKSB7XG4gICAgICAgICAgdmFyIHRleHQgPSBnZXRMaW5lKGRvYywgbGluZSkudGV4dCwgbGVmdFBvcyA9IGZpbmRDb2x1bW4odGV4dCwgbGVmdCwgdGFiU2l6ZSk7XG4gICAgICAgICAgaWYgKGxlZnQgPT0gcmlnaHQpXG4gICAgICAgICAgICB7IHJhbmdlcy5wdXNoKG5ldyBSYW5nZShQb3MobGluZSwgbGVmdFBvcyksIFBvcyhsaW5lLCBsZWZ0UG9zKSkpOyB9XG4gICAgICAgICAgZWxzZSBpZiAodGV4dC5sZW5ndGggPiBsZWZ0UG9zKVxuICAgICAgICAgICAgeyByYW5nZXMucHVzaChuZXcgUmFuZ2UoUG9zKGxpbmUsIGxlZnRQb3MpLCBQb3MobGluZSwgZmluZENvbHVtbih0ZXh0LCByaWdodCwgdGFiU2l6ZSkpKSk7IH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJhbmdlcy5sZW5ndGgpIHsgcmFuZ2VzLnB1c2gobmV3IFJhbmdlKHN0YXJ0LCBzdGFydCkpOyB9XG4gICAgICAgIHNldFNlbGVjdGlvbihkb2MsIG5vcm1hbGl6ZVNlbGVjdGlvbihjbSwgc3RhcnRTZWwucmFuZ2VzLnNsaWNlKDAsIG91ckluZGV4KS5jb25jYXQocmFuZ2VzKSwgb3VySW5kZXgpLFxuICAgICAgICAgICAgICAgICAgICAge29yaWdpbjogXCIqbW91c2VcIiwgc2Nyb2xsOiBmYWxzZX0pO1xuICAgICAgICBjbS5zY3JvbGxJbnRvVmlldyhwb3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG9sZFJhbmdlID0gb3VyUmFuZ2U7XG4gICAgICAgIHZhciByYW5nZSA9IHJhbmdlRm9yVW5pdChjbSwgcG9zLCBiZWhhdmlvci51bml0KTtcbiAgICAgICAgdmFyIGFuY2hvciA9IG9sZFJhbmdlLmFuY2hvciwgaGVhZDtcbiAgICAgICAgaWYgKGNtcChyYW5nZS5hbmNob3IsIGFuY2hvcikgPiAwKSB7XG4gICAgICAgICAgaGVhZCA9IHJhbmdlLmhlYWQ7XG4gICAgICAgICAgYW5jaG9yID0gbWluUG9zKG9sZFJhbmdlLmZyb20oKSwgcmFuZ2UuYW5jaG9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoZWFkID0gcmFuZ2UuYW5jaG9yO1xuICAgICAgICAgIGFuY2hvciA9IG1heFBvcyhvbGRSYW5nZS50bygpLCByYW5nZS5oZWFkKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmFuZ2VzJDEgPSBzdGFydFNlbC5yYW5nZXMuc2xpY2UoMCk7XG4gICAgICAgIHJhbmdlcyQxW291ckluZGV4XSA9IGJpZGlTaW1wbGlmeShjbSwgbmV3IFJhbmdlKGNsaXBQb3MoZG9jLCBhbmNob3IpLCBoZWFkKSk7XG4gICAgICAgIHNldFNlbGVjdGlvbihkb2MsIG5vcm1hbGl6ZVNlbGVjdGlvbihjbSwgcmFuZ2VzJDEsIG91ckluZGV4KSwgc2VsX21vdXNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZWRpdG9yU2l6ZSA9IGRpc3BsYXkud3JhcHBlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAvLyBVc2VkIHRvIGVuc3VyZSB0aW1lb3V0IHJlLXRyaWVzIGRvbid0IGZpcmUgd2hlbiBhbm90aGVyIGV4dGVuZFxuICAgIC8vIGhhcHBlbmVkIGluIHRoZSBtZWFudGltZSAoY2xlYXJUaW1lb3V0IGlzbid0IHJlbGlhYmxlIC0tIGF0XG4gICAgLy8gbGVhc3Qgb24gQ2hyb21lLCB0aGUgdGltZW91dHMgc3RpbGwgaGFwcGVuIGV2ZW4gd2hlbiBjbGVhcmVkLFxuICAgIC8vIGlmIHRoZSBjbGVhciBoYXBwZW5zIGFmdGVyIHRoZWlyIHNjaGVkdWxlZCBmaXJpbmcgdGltZSkuXG4gICAgdmFyIGNvdW50ZXIgPSAwO1xuXG4gICAgZnVuY3Rpb24gZXh0ZW5kKGUpIHtcbiAgICAgIHZhciBjdXJDb3VudCA9ICsrY291bnRlcjtcbiAgICAgIHZhciBjdXIgPSBwb3NGcm9tTW91c2UoY20sIGUsIHRydWUsIGJlaGF2aW9yLnVuaXQgPT0gXCJyZWN0YW5nbGVcIik7XG4gICAgICBpZiAoIWN1cikgeyByZXR1cm4gfVxuICAgICAgaWYgKGNtcChjdXIsIGxhc3RQb3MpICE9IDApIHtcbiAgICAgICAgY20uY3VyT3AuZm9jdXMgPSBhY3RpdmVFbHQoKTtcbiAgICAgICAgZXh0ZW5kVG8oY3VyKTtcbiAgICAgICAgdmFyIHZpc2libGUgPSB2aXNpYmxlTGluZXMoZGlzcGxheSwgZG9jKTtcbiAgICAgICAgaWYgKGN1ci5saW5lID49IHZpc2libGUudG8gfHwgY3VyLmxpbmUgPCB2aXNpYmxlLmZyb20pXG4gICAgICAgICAgeyBzZXRUaW1lb3V0KG9wZXJhdGlvbihjbSwgZnVuY3Rpb24gKCkge2lmIChjb3VudGVyID09IGN1ckNvdW50KSB7IGV4dGVuZChlKTsgfX0pLCAxNTApOyB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgb3V0c2lkZSA9IGUuY2xpZW50WSA8IGVkaXRvclNpemUudG9wID8gLTIwIDogZS5jbGllbnRZID4gZWRpdG9yU2l6ZS5ib3R0b20gPyAyMCA6IDA7XG4gICAgICAgIGlmIChvdXRzaWRlKSB7IHNldFRpbWVvdXQob3BlcmF0aW9uKGNtLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKGNvdW50ZXIgIT0gY3VyQ291bnQpIHsgcmV0dXJuIH1cbiAgICAgICAgICBkaXNwbGF5LnNjcm9sbGVyLnNjcm9sbFRvcCArPSBvdXRzaWRlO1xuICAgICAgICAgIGV4dGVuZChlKTtcbiAgICAgICAgfSksIDUwKTsgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRvbmUoZSkge1xuICAgICAgY20uc3RhdGUuc2VsZWN0aW5nVGV4dCA9IGZhbHNlO1xuICAgICAgY291bnRlciA9IEluZmluaXR5O1xuICAgICAgLy8gSWYgZSBpcyBudWxsIG9yIHVuZGVmaW5lZCB3ZSBpbnRlcnByZXQgdGhpcyBhcyBzb21lb25lIHRyeWluZ1xuICAgICAgLy8gdG8gZXhwbGljaXRseSBjYW5jZWwgdGhlIHNlbGVjdGlvbiByYXRoZXIgdGhhbiB0aGUgdXNlclxuICAgICAgLy8gbGV0dGluZyBnbyBvZiB0aGUgbW91c2UgYnV0dG9uLlxuICAgICAgaWYgKGUpIHtcbiAgICAgICAgZV9wcmV2ZW50RGVmYXVsdChlKTtcbiAgICAgICAgZGlzcGxheS5pbnB1dC5mb2N1cygpO1xuICAgICAgfVxuICAgICAgb2ZmKGRpc3BsYXkud3JhcHBlci5vd25lckRvY3VtZW50LCBcIm1vdXNlbW92ZVwiLCBtb3ZlKTtcbiAgICAgIG9mZihkaXNwbGF5LndyYXBwZXIub3duZXJEb2N1bWVudCwgXCJtb3VzZXVwXCIsIHVwKTtcbiAgICAgIGRvYy5oaXN0b3J5Lmxhc3RTZWxPcmlnaW4gPSBudWxsO1xuICAgIH1cblxuICAgIHZhciBtb3ZlID0gb3BlcmF0aW9uKGNtLCBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKGUuYnV0dG9ucyA9PT0gMCB8fCAhZV9idXR0b24oZSkpIHsgZG9uZShlKTsgfVxuICAgICAgZWxzZSB7IGV4dGVuZChlKTsgfVxuICAgIH0pO1xuICAgIHZhciB1cCA9IG9wZXJhdGlvbihjbSwgZG9uZSk7XG4gICAgY20uc3RhdGUuc2VsZWN0aW5nVGV4dCA9IHVwO1xuICAgIG9uKGRpc3BsYXkud3JhcHBlci5vd25lckRvY3VtZW50LCBcIm1vdXNlbW92ZVwiLCBtb3ZlKTtcbiAgICBvbihkaXNwbGF5LndyYXBwZXIub3duZXJEb2N1bWVudCwgXCJtb3VzZXVwXCIsIHVwKTtcbiAgfVxuXG4gIC8vIFVzZWQgd2hlbiBtb3VzZS1zZWxlY3RpbmcgdG8gYWRqdXN0IHRoZSBhbmNob3IgdG8gdGhlIHByb3BlciBzaWRlXG4gIC8vIG9mIGEgYmlkaSBqdW1wIGRlcGVuZGluZyBvbiB0aGUgdmlzdWFsIHBvc2l0aW9uIG9mIHRoZSBoZWFkLlxuICBmdW5jdGlvbiBiaWRpU2ltcGxpZnkoY20sIHJhbmdlKSB7XG4gICAgdmFyIGFuY2hvciA9IHJhbmdlLmFuY2hvcjtcbiAgICB2YXIgaGVhZCA9IHJhbmdlLmhlYWQ7XG4gICAgdmFyIGFuY2hvckxpbmUgPSBnZXRMaW5lKGNtLmRvYywgYW5jaG9yLmxpbmUpO1xuICAgIGlmIChjbXAoYW5jaG9yLCBoZWFkKSA9PSAwICYmIGFuY2hvci5zdGlja3kgPT0gaGVhZC5zdGlja3kpIHsgcmV0dXJuIHJhbmdlIH1cbiAgICB2YXIgb3JkZXIgPSBnZXRPcmRlcihhbmNob3JMaW5lKTtcbiAgICBpZiAoIW9yZGVyKSB7IHJldHVybiByYW5nZSB9XG4gICAgdmFyIGluZGV4ID0gZ2V0QmlkaVBhcnRBdChvcmRlciwgYW5jaG9yLmNoLCBhbmNob3Iuc3RpY2t5KSwgcGFydCA9IG9yZGVyW2luZGV4XTtcbiAgICBpZiAocGFydC5mcm9tICE9IGFuY2hvci5jaCAmJiBwYXJ0LnRvICE9IGFuY2hvci5jaCkgeyByZXR1cm4gcmFuZ2UgfVxuICAgIHZhciBib3VuZGFyeSA9IGluZGV4ICsgKChwYXJ0LmZyb20gPT0gYW5jaG9yLmNoKSA9PSAocGFydC5sZXZlbCAhPSAxKSA/IDAgOiAxKTtcbiAgICBpZiAoYm91bmRhcnkgPT0gMCB8fCBib3VuZGFyeSA9PSBvcmRlci5sZW5ndGgpIHsgcmV0dXJuIHJhbmdlIH1cblxuICAgIC8vIENvbXB1dGUgdGhlIHJlbGF0aXZlIHZpc3VhbCBwb3NpdGlvbiBvZiB0aGUgaGVhZCBjb21wYXJlZCB0byB0aGVcbiAgICAvLyBhbmNob3IgKDwwIGlzIHRvIHRoZSBsZWZ0LCA+MCB0byB0aGUgcmlnaHQpXG4gICAgdmFyIGxlZnRTaWRlO1xuICAgIGlmIChoZWFkLmxpbmUgIT0gYW5jaG9yLmxpbmUpIHtcbiAgICAgIGxlZnRTaWRlID0gKGhlYWQubGluZSAtIGFuY2hvci5saW5lKSAqIChjbS5kb2MuZGlyZWN0aW9uID09IFwibHRyXCIgPyAxIDogLTEpID4gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGhlYWRJbmRleCA9IGdldEJpZGlQYXJ0QXQob3JkZXIsIGhlYWQuY2gsIGhlYWQuc3RpY2t5KTtcbiAgICAgIHZhciBkaXIgPSBoZWFkSW5kZXggLSBpbmRleCB8fCAoaGVhZC5jaCAtIGFuY2hvci5jaCkgKiAocGFydC5sZXZlbCA9PSAxID8gLTEgOiAxKTtcbiAgICAgIGlmIChoZWFkSW5kZXggPT0gYm91bmRhcnkgLSAxIHx8IGhlYWRJbmRleCA9PSBib3VuZGFyeSlcbiAgICAgICAgeyBsZWZ0U2lkZSA9IGRpciA8IDA7IH1cbiAgICAgIGVsc2VcbiAgICAgICAgeyBsZWZ0U2lkZSA9IGRpciA+IDA7IH1cbiAgICB9XG5cbiAgICB2YXIgdXNlUGFydCA9IG9yZGVyW2JvdW5kYXJ5ICsgKGxlZnRTaWRlID8gLTEgOiAwKV07XG4gICAgdmFyIGZyb20gPSBsZWZ0U2lkZSA9PSAodXNlUGFydC5sZXZlbCA9PSAxKTtcbiAgICB2YXIgY2ggPSBmcm9tID8gdXNlUGFydC5mcm9tIDogdXNlUGFydC50bywgc3RpY2t5ID0gZnJvbSA/IFwiYWZ0ZXJcIiA6IFwiYmVmb3JlXCI7XG4gICAgcmV0dXJuIGFuY2hvci5jaCA9PSBjaCAmJiBhbmNob3Iuc3RpY2t5ID09IHN0aWNreSA/IHJhbmdlIDogbmV3IFJhbmdlKG5ldyBQb3MoYW5jaG9yLmxpbmUsIGNoLCBzdGlja3kpLCBoZWFkKVxuICB9XG5cblxuICAvLyBEZXRlcm1pbmVzIHdoZXRoZXIgYW4gZXZlbnQgaGFwcGVuZWQgaW4gdGhlIGd1dHRlciwgYW5kIGZpcmVzIHRoZVxuICAvLyBoYW5kbGVycyBmb3IgdGhlIGNvcnJlc3BvbmRpbmcgZXZlbnQuXG4gIGZ1bmN0aW9uIGd1dHRlckV2ZW50KGNtLCBlLCB0eXBlLCBwcmV2ZW50KSB7XG4gICAgdmFyIG1YLCBtWTtcbiAgICBpZiAoZS50b3VjaGVzKSB7XG4gICAgICBtWCA9IGUudG91Y2hlc1swXS5jbGllbnRYO1xuICAgICAgbVkgPSBlLnRvdWNoZXNbMF0uY2xpZW50WTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHsgbVggPSBlLmNsaWVudFg7IG1ZID0gZS5jbGllbnRZOyB9XG4gICAgICBjYXRjaChlJDEpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICB9XG4gICAgaWYgKG1YID49IE1hdGguZmxvb3IoY20uZGlzcGxheS5ndXR0ZXJzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnJpZ2h0KSkgeyByZXR1cm4gZmFsc2UgfVxuICAgIGlmIChwcmV2ZW50KSB7IGVfcHJldmVudERlZmF1bHQoZSk7IH1cblxuICAgIHZhciBkaXNwbGF5ID0gY20uZGlzcGxheTtcbiAgICB2YXIgbGluZUJveCA9IGRpc3BsYXkubGluZURpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgIGlmIChtWSA+IGxpbmVCb3guYm90dG9tIHx8ICFoYXNIYW5kbGVyKGNtLCB0eXBlKSkgeyByZXR1cm4gZV9kZWZhdWx0UHJldmVudGVkKGUpIH1cbiAgICBtWSAtPSBsaW5lQm94LnRvcCAtIGRpc3BsYXkudmlld09mZnNldDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY20uZGlzcGxheS5ndXR0ZXJTcGVjcy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGcgPSBkaXNwbGF5Lmd1dHRlcnMuY2hpbGROb2Rlc1tpXTtcbiAgICAgIGlmIChnICYmIGcuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkucmlnaHQgPj0gbVgpIHtcbiAgICAgICAgdmFyIGxpbmUgPSBsaW5lQXRIZWlnaHQoY20uZG9jLCBtWSk7XG4gICAgICAgIHZhciBndXR0ZXIgPSBjbS5kaXNwbGF5Lmd1dHRlclNwZWNzW2ldO1xuICAgICAgICBzaWduYWwoY20sIHR5cGUsIGNtLCBsaW5lLCBndXR0ZXIuY2xhc3NOYW1lLCBlKTtcbiAgICAgICAgcmV0dXJuIGVfZGVmYXVsdFByZXZlbnRlZChlKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNsaWNrSW5HdXR0ZXIoY20sIGUpIHtcbiAgICByZXR1cm4gZ3V0dGVyRXZlbnQoY20sIGUsIFwiZ3V0dGVyQ2xpY2tcIiwgdHJ1ZSlcbiAgfVxuXG4gIC8vIENPTlRFWFQgTUVOVSBIQU5ETElOR1xuXG4gIC8vIFRvIG1ha2UgdGhlIGNvbnRleHQgbWVudSB3b3JrLCB3ZSBuZWVkIHRvIGJyaWVmbHkgdW5oaWRlIHRoZVxuICAvLyB0ZXh0YXJlYSAobWFraW5nIGl0IGFzIHVub2J0cnVzaXZlIGFzIHBvc3NpYmxlKSB0byBsZXQgdGhlXG4gIC8vIHJpZ2h0LWNsaWNrIHRha2UgZWZmZWN0IG9uIGl0LlxuICBmdW5jdGlvbiBvbkNvbnRleHRNZW51KGNtLCBlKSB7XG4gICAgaWYgKGV2ZW50SW5XaWRnZXQoY20uZGlzcGxheSwgZSkgfHwgY29udGV4dE1lbnVJbkd1dHRlcihjbSwgZSkpIHsgcmV0dXJuIH1cbiAgICBpZiAoc2lnbmFsRE9NRXZlbnQoY20sIGUsIFwiY29udGV4dG1lbnVcIikpIHsgcmV0dXJuIH1cbiAgICBpZiAoIWNhcHR1cmVSaWdodENsaWNrKSB7IGNtLmRpc3BsYXkuaW5wdXQub25Db250ZXh0TWVudShlKTsgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29udGV4dE1lbnVJbkd1dHRlcihjbSwgZSkge1xuICAgIGlmICghaGFzSGFuZGxlcihjbSwgXCJndXR0ZXJDb250ZXh0TWVudVwiKSkgeyByZXR1cm4gZmFsc2UgfVxuICAgIHJldHVybiBndXR0ZXJFdmVudChjbSwgZSwgXCJndXR0ZXJDb250ZXh0TWVudVwiLCBmYWxzZSlcbiAgfVxuXG4gIGZ1bmN0aW9uIHRoZW1lQ2hhbmdlZChjbSkge1xuICAgIGNtLmRpc3BsYXkud3JhcHBlci5jbGFzc05hbWUgPSBjbS5kaXNwbGF5LndyYXBwZXIuY2xhc3NOYW1lLnJlcGxhY2UoL1xccypjbS1zLVxcUysvZywgXCJcIikgK1xuICAgICAgY20ub3B0aW9ucy50aGVtZS5yZXBsYWNlKC8oXnxcXHMpXFxzKi9nLCBcIiBjbS1zLVwiKTtcbiAgICBjbGVhckNhY2hlcyhjbSk7XG4gIH1cblxuICB2YXIgSW5pdCA9IHt0b1N0cmluZzogZnVuY3Rpb24oKXtyZXR1cm4gXCJDb2RlTWlycm9yLkluaXRcIn19O1xuXG4gIHZhciBkZWZhdWx0cyA9IHt9O1xuICB2YXIgb3B0aW9uSGFuZGxlcnMgPSB7fTtcblxuICBmdW5jdGlvbiBkZWZpbmVPcHRpb25zKENvZGVNaXJyb3IpIHtcbiAgICB2YXIgb3B0aW9uSGFuZGxlcnMgPSBDb2RlTWlycm9yLm9wdGlvbkhhbmRsZXJzO1xuXG4gICAgZnVuY3Rpb24gb3B0aW9uKG5hbWUsIGRlZmx0LCBoYW5kbGUsIG5vdE9uSW5pdCkge1xuICAgICAgQ29kZU1pcnJvci5kZWZhdWx0c1tuYW1lXSA9IGRlZmx0O1xuICAgICAgaWYgKGhhbmRsZSkgeyBvcHRpb25IYW5kbGVyc1tuYW1lXSA9XG4gICAgICAgIG5vdE9uSW5pdCA/IGZ1bmN0aW9uIChjbSwgdmFsLCBvbGQpIHtpZiAob2xkICE9IEluaXQpIHsgaGFuZGxlKGNtLCB2YWwsIG9sZCk7IH19IDogaGFuZGxlOyB9XG4gICAgfVxuXG4gICAgQ29kZU1pcnJvci5kZWZpbmVPcHRpb24gPSBvcHRpb247XG5cbiAgICAvLyBQYXNzZWQgdG8gb3B0aW9uIGhhbmRsZXJzIHdoZW4gdGhlcmUgaXMgbm8gb2xkIHZhbHVlLlxuICAgIENvZGVNaXJyb3IuSW5pdCA9IEluaXQ7XG5cbiAgICAvLyBUaGVzZSB0d28gYXJlLCBvbiBpbml0LCBjYWxsZWQgZnJvbSB0aGUgY29uc3RydWN0b3IgYmVjYXVzZSB0aGV5XG4gICAgLy8gaGF2ZSB0byBiZSBpbml0aWFsaXplZCBiZWZvcmUgdGhlIGVkaXRvciBjYW4gc3RhcnQgYXQgYWxsLlxuICAgIG9wdGlvbihcInZhbHVlXCIsIFwiXCIsIGZ1bmN0aW9uIChjbSwgdmFsKSB7IHJldHVybiBjbS5zZXRWYWx1ZSh2YWwpOyB9LCB0cnVlKTtcbiAgICBvcHRpb24oXCJtb2RlXCIsIG51bGwsIGZ1bmN0aW9uIChjbSwgdmFsKSB7XG4gICAgICBjbS5kb2MubW9kZU9wdGlvbiA9IHZhbDtcbiAgICAgIGxvYWRNb2RlKGNtKTtcbiAgICB9LCB0cnVlKTtcblxuICAgIG9wdGlvbihcImluZGVudFVuaXRcIiwgMiwgbG9hZE1vZGUsIHRydWUpO1xuICAgIG9wdGlvbihcImluZGVudFdpdGhUYWJzXCIsIGZhbHNlKTtcbiAgICBvcHRpb24oXCJzbWFydEluZGVudFwiLCB0cnVlKTtcbiAgICBvcHRpb24oXCJ0YWJTaXplXCIsIDQsIGZ1bmN0aW9uIChjbSkge1xuICAgICAgcmVzZXRNb2RlU3RhdGUoY20pO1xuICAgICAgY2xlYXJDYWNoZXMoY20pO1xuICAgICAgcmVnQ2hhbmdlKGNtKTtcbiAgICB9LCB0cnVlKTtcblxuICAgIG9wdGlvbihcImxpbmVTZXBhcmF0b3JcIiwgbnVsbCwgZnVuY3Rpb24gKGNtLCB2YWwpIHtcbiAgICAgIGNtLmRvYy5saW5lU2VwID0gdmFsO1xuICAgICAgaWYgKCF2YWwpIHsgcmV0dXJuIH1cbiAgICAgIHZhciBuZXdCcmVha3MgPSBbXSwgbGluZU5vID0gY20uZG9jLmZpcnN0O1xuICAgICAgY20uZG9jLml0ZXIoZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgZm9yICh2YXIgcG9zID0gMDs7KSB7XG4gICAgICAgICAgdmFyIGZvdW5kID0gbGluZS50ZXh0LmluZGV4T2YodmFsLCBwb3MpO1xuICAgICAgICAgIGlmIChmb3VuZCA9PSAtMSkgeyBicmVhayB9XG4gICAgICAgICAgcG9zID0gZm91bmQgKyB2YWwubGVuZ3RoO1xuICAgICAgICAgIG5ld0JyZWFrcy5wdXNoKFBvcyhsaW5lTm8sIGZvdW5kKSk7XG4gICAgICAgIH1cbiAgICAgICAgbGluZU5vKys7XG4gICAgICB9KTtcbiAgICAgIGZvciAodmFyIGkgPSBuZXdCcmVha3MubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgIHsgcmVwbGFjZVJhbmdlKGNtLmRvYywgdmFsLCBuZXdCcmVha3NbaV0sIFBvcyhuZXdCcmVha3NbaV0ubGluZSwgbmV3QnJlYWtzW2ldLmNoICsgdmFsLmxlbmd0aCkpOyB9XG4gICAgfSk7XG4gICAgb3B0aW9uKFwic3BlY2lhbENoYXJzXCIsIC9bXFx1MDAwMC1cXHUwMDFmXFx1MDA3Zi1cXHUwMDlmXFx1MDBhZFxcdTA2MWNcXHUyMDBiLVxcdTIwMGNcXHUyMDBlXFx1MjAwZlxcdTIwMjhcXHUyMDI5XFx1ZmVmZlxcdWZmZjktXFx1ZmZmY10vZywgZnVuY3Rpb24gKGNtLCB2YWwsIG9sZCkge1xuICAgICAgY20uc3RhdGUuc3BlY2lhbENoYXJzID0gbmV3IFJlZ0V4cCh2YWwuc291cmNlICsgKHZhbC50ZXN0KFwiXFx0XCIpID8gXCJcIiA6IFwifFxcdFwiKSwgXCJnXCIpO1xuICAgICAgaWYgKG9sZCAhPSBJbml0KSB7IGNtLnJlZnJlc2goKTsgfVxuICAgIH0pO1xuICAgIG9wdGlvbihcInNwZWNpYWxDaGFyUGxhY2Vob2xkZXJcIiwgZGVmYXVsdFNwZWNpYWxDaGFyUGxhY2Vob2xkZXIsIGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20ucmVmcmVzaCgpOyB9LCB0cnVlKTtcbiAgICBvcHRpb24oXCJlbGVjdHJpY0NoYXJzXCIsIHRydWUpO1xuICAgIG9wdGlvbihcImlucHV0U3R5bGVcIiwgbW9iaWxlID8gXCJjb250ZW50ZWRpdGFibGVcIiA6IFwidGV4dGFyZWFcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW5wdXRTdHlsZSBjYW4gbm90ICh5ZXQpIGJlIGNoYW5nZWQgaW4gYSBydW5uaW5nIGVkaXRvclwiKSAvLyBGSVhNRVxuICAgIH0sIHRydWUpO1xuICAgIG9wdGlvbihcInNwZWxsY2hlY2tcIiwgZmFsc2UsIGZ1bmN0aW9uIChjbSwgdmFsKSB7IHJldHVybiBjbS5nZXRJbnB1dEZpZWxkKCkuc3BlbGxjaGVjayA9IHZhbDsgfSwgdHJ1ZSk7XG4gICAgb3B0aW9uKFwiYXV0b2NvcnJlY3RcIiwgZmFsc2UsIGZ1bmN0aW9uIChjbSwgdmFsKSB7IHJldHVybiBjbS5nZXRJbnB1dEZpZWxkKCkuYXV0b2NvcnJlY3QgPSB2YWw7IH0sIHRydWUpO1xuICAgIG9wdGlvbihcImF1dG9jYXBpdGFsaXplXCIsIGZhbHNlLCBmdW5jdGlvbiAoY20sIHZhbCkgeyByZXR1cm4gY20uZ2V0SW5wdXRGaWVsZCgpLmF1dG9jYXBpdGFsaXplID0gdmFsOyB9LCB0cnVlKTtcbiAgICBvcHRpb24oXCJydGxNb3ZlVmlzdWFsbHlcIiwgIXdpbmRvd3MpO1xuICAgIG9wdGlvbihcIndob2xlTGluZVVwZGF0ZUJlZm9yZVwiLCB0cnVlKTtcblxuICAgIG9wdGlvbihcInRoZW1lXCIsIFwiZGVmYXVsdFwiLCBmdW5jdGlvbiAoY20pIHtcbiAgICAgIHRoZW1lQ2hhbmdlZChjbSk7XG4gICAgICB1cGRhdGVHdXR0ZXJzKGNtKTtcbiAgICB9LCB0cnVlKTtcbiAgICBvcHRpb24oXCJrZXlNYXBcIiwgXCJkZWZhdWx0XCIsIGZ1bmN0aW9uIChjbSwgdmFsLCBvbGQpIHtcbiAgICAgIHZhciBuZXh0ID0gZ2V0S2V5TWFwKHZhbCk7XG4gICAgICB2YXIgcHJldiA9IG9sZCAhPSBJbml0ICYmIGdldEtleU1hcChvbGQpO1xuICAgICAgaWYgKHByZXYgJiYgcHJldi5kZXRhY2gpIHsgcHJldi5kZXRhY2goY20sIG5leHQpOyB9XG4gICAgICBpZiAobmV4dC5hdHRhY2gpIHsgbmV4dC5hdHRhY2goY20sIHByZXYgfHwgbnVsbCk7IH1cbiAgICB9KTtcbiAgICBvcHRpb24oXCJleHRyYUtleXNcIiwgbnVsbCk7XG4gICAgb3B0aW9uKFwiY29uZmlndXJlTW91c2VcIiwgbnVsbCk7XG5cbiAgICBvcHRpb24oXCJsaW5lV3JhcHBpbmdcIiwgZmFsc2UsIHdyYXBwaW5nQ2hhbmdlZCwgdHJ1ZSk7XG4gICAgb3B0aW9uKFwiZ3V0dGVyc1wiLCBbXSwgZnVuY3Rpb24gKGNtLCB2YWwpIHtcbiAgICAgIGNtLmRpc3BsYXkuZ3V0dGVyU3BlY3MgPSBnZXRHdXR0ZXJzKHZhbCwgY20ub3B0aW9ucy5saW5lTnVtYmVycyk7XG4gICAgICB1cGRhdGVHdXR0ZXJzKGNtKTtcbiAgICB9LCB0cnVlKTtcbiAgICBvcHRpb24oXCJmaXhlZEd1dHRlclwiLCB0cnVlLCBmdW5jdGlvbiAoY20sIHZhbCkge1xuICAgICAgY20uZGlzcGxheS5ndXR0ZXJzLnN0eWxlLmxlZnQgPSB2YWwgPyBjb21wZW5zYXRlRm9ySFNjcm9sbChjbS5kaXNwbGF5KSArIFwicHhcIiA6IFwiMFwiO1xuICAgICAgY20ucmVmcmVzaCgpO1xuICAgIH0sIHRydWUpO1xuICAgIG9wdGlvbihcImNvdmVyR3V0dGVyTmV4dFRvU2Nyb2xsYmFyXCIsIGZhbHNlLCBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIHVwZGF0ZVNjcm9sbGJhcnMoY20pOyB9LCB0cnVlKTtcbiAgICBvcHRpb24oXCJzY3JvbGxiYXJTdHlsZVwiLCBcIm5hdGl2ZVwiLCBmdW5jdGlvbiAoY20pIHtcbiAgICAgIGluaXRTY3JvbGxiYXJzKGNtKTtcbiAgICAgIHVwZGF0ZVNjcm9sbGJhcnMoY20pO1xuICAgICAgY20uZGlzcGxheS5zY3JvbGxiYXJzLnNldFNjcm9sbFRvcChjbS5kb2Muc2Nyb2xsVG9wKTtcbiAgICAgIGNtLmRpc3BsYXkuc2Nyb2xsYmFycy5zZXRTY3JvbGxMZWZ0KGNtLmRvYy5zY3JvbGxMZWZ0KTtcbiAgICB9LCB0cnVlKTtcbiAgICBvcHRpb24oXCJsaW5lTnVtYmVyc1wiLCBmYWxzZSwgZnVuY3Rpb24gKGNtLCB2YWwpIHtcbiAgICAgIGNtLmRpc3BsYXkuZ3V0dGVyU3BlY3MgPSBnZXRHdXR0ZXJzKGNtLm9wdGlvbnMuZ3V0dGVycywgdmFsKTtcbiAgICAgIHVwZGF0ZUd1dHRlcnMoY20pO1xuICAgIH0sIHRydWUpO1xuICAgIG9wdGlvbihcImZpcnN0TGluZU51bWJlclwiLCAxLCB1cGRhdGVHdXR0ZXJzLCB0cnVlKTtcbiAgICBvcHRpb24oXCJsaW5lTnVtYmVyRm9ybWF0dGVyXCIsIGZ1bmN0aW9uIChpbnRlZ2VyKSB7IHJldHVybiBpbnRlZ2VyOyB9LCB1cGRhdGVHdXR0ZXJzLCB0cnVlKTtcbiAgICBvcHRpb24oXCJzaG93Q3Vyc29yV2hlblNlbGVjdGluZ1wiLCBmYWxzZSwgdXBkYXRlU2VsZWN0aW9uLCB0cnVlKTtcblxuICAgIG9wdGlvbihcInJlc2V0U2VsZWN0aW9uT25Db250ZXh0TWVudVwiLCB0cnVlKTtcbiAgICBvcHRpb24oXCJsaW5lV2lzZUNvcHlDdXRcIiwgdHJ1ZSk7XG4gICAgb3B0aW9uKFwicGFzdGVMaW5lc1BlclNlbGVjdGlvblwiLCB0cnVlKTtcbiAgICBvcHRpb24oXCJzZWxlY3Rpb25zTWF5VG91Y2hcIiwgZmFsc2UpO1xuXG4gICAgb3B0aW9uKFwicmVhZE9ubHlcIiwgZmFsc2UsIGZ1bmN0aW9uIChjbSwgdmFsKSB7XG4gICAgICBpZiAodmFsID09IFwibm9jdXJzb3JcIikge1xuICAgICAgICBvbkJsdXIoY20pO1xuICAgICAgICBjbS5kaXNwbGF5LmlucHV0LmJsdXIoKTtcbiAgICAgIH1cbiAgICAgIGNtLmRpc3BsYXkuaW5wdXQucmVhZE9ubHlDaGFuZ2VkKHZhbCk7XG4gICAgfSk7XG5cbiAgICBvcHRpb24oXCJzY3JlZW5SZWFkZXJMYWJlbFwiLCBudWxsLCBmdW5jdGlvbiAoY20sIHZhbCkge1xuICAgICAgdmFsID0gKHZhbCA9PT0gJycpID8gbnVsbCA6IHZhbDtcbiAgICAgIGNtLmRpc3BsYXkuaW5wdXQuc2NyZWVuUmVhZGVyTGFiZWxDaGFuZ2VkKHZhbCk7XG4gICAgfSk7XG5cbiAgICBvcHRpb24oXCJkaXNhYmxlSW5wdXRcIiwgZmFsc2UsIGZ1bmN0aW9uIChjbSwgdmFsKSB7aWYgKCF2YWwpIHsgY20uZGlzcGxheS5pbnB1dC5yZXNldCgpOyB9fSwgdHJ1ZSk7XG4gICAgb3B0aW9uKFwiZHJhZ0Ryb3BcIiwgdHJ1ZSwgZHJhZ0Ryb3BDaGFuZ2VkKTtcbiAgICBvcHRpb24oXCJhbGxvd0Ryb3BGaWxlVHlwZXNcIiwgbnVsbCk7XG5cbiAgICBvcHRpb24oXCJjdXJzb3JCbGlua1JhdGVcIiwgNTMwKTtcbiAgICBvcHRpb24oXCJjdXJzb3JTY3JvbGxNYXJnaW5cIiwgMCk7XG4gICAgb3B0aW9uKFwiY3Vyc29ySGVpZ2h0XCIsIDEsIHVwZGF0ZVNlbGVjdGlvbiwgdHJ1ZSk7XG4gICAgb3B0aW9uKFwic2luZ2xlQ3Vyc29ySGVpZ2h0UGVyTGluZVwiLCB0cnVlLCB1cGRhdGVTZWxlY3Rpb24sIHRydWUpO1xuICAgIG9wdGlvbihcIndvcmtUaW1lXCIsIDEwMCk7XG4gICAgb3B0aW9uKFwid29ya0RlbGF5XCIsIDEwMCk7XG4gICAgb3B0aW9uKFwiZmxhdHRlblNwYW5zXCIsIHRydWUsIHJlc2V0TW9kZVN0YXRlLCB0cnVlKTtcbiAgICBvcHRpb24oXCJhZGRNb2RlQ2xhc3NcIiwgZmFsc2UsIHJlc2V0TW9kZVN0YXRlLCB0cnVlKTtcbiAgICBvcHRpb24oXCJwb2xsSW50ZXJ2YWxcIiwgMTAwKTtcbiAgICBvcHRpb24oXCJ1bmRvRGVwdGhcIiwgMjAwLCBmdW5jdGlvbiAoY20sIHZhbCkgeyByZXR1cm4gY20uZG9jLmhpc3RvcnkudW5kb0RlcHRoID0gdmFsOyB9KTtcbiAgICBvcHRpb24oXCJoaXN0b3J5RXZlbnREZWxheVwiLCAxMjUwKTtcbiAgICBvcHRpb24oXCJ2aWV3cG9ydE1hcmdpblwiLCAxMCwgZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5yZWZyZXNoKCk7IH0sIHRydWUpO1xuICAgIG9wdGlvbihcIm1heEhpZ2hsaWdodExlbmd0aFwiLCAxMDAwMCwgcmVzZXRNb2RlU3RhdGUsIHRydWUpO1xuICAgIG9wdGlvbihcIm1vdmVJbnB1dFdpdGhDdXJzb3JcIiwgdHJ1ZSwgZnVuY3Rpb24gKGNtLCB2YWwpIHtcbiAgICAgIGlmICghdmFsKSB7IGNtLmRpc3BsYXkuaW5wdXQucmVzZXRQb3NpdGlvbigpOyB9XG4gICAgfSk7XG5cbiAgICBvcHRpb24oXCJ0YWJpbmRleFwiLCBudWxsLCBmdW5jdGlvbiAoY20sIHZhbCkgeyByZXR1cm4gY20uZGlzcGxheS5pbnB1dC5nZXRGaWVsZCgpLnRhYkluZGV4ID0gdmFsIHx8IFwiXCI7IH0pO1xuICAgIG9wdGlvbihcImF1dG9mb2N1c1wiLCBudWxsKTtcbiAgICBvcHRpb24oXCJkaXJlY3Rpb25cIiwgXCJsdHJcIiwgZnVuY3Rpb24gKGNtLCB2YWwpIHsgcmV0dXJuIGNtLmRvYy5zZXREaXJlY3Rpb24odmFsKTsgfSwgdHJ1ZSk7XG4gICAgb3B0aW9uKFwicGhyYXNlc1wiLCBudWxsKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRyYWdEcm9wQ2hhbmdlZChjbSwgdmFsdWUsIG9sZCkge1xuICAgIHZhciB3YXNPbiA9IG9sZCAmJiBvbGQgIT0gSW5pdDtcbiAgICBpZiAoIXZhbHVlICE9ICF3YXNPbikge1xuICAgICAgdmFyIGZ1bmNzID0gY20uZGlzcGxheS5kcmFnRnVuY3Rpb25zO1xuICAgICAgdmFyIHRvZ2dsZSA9IHZhbHVlID8gb24gOiBvZmY7XG4gICAgICB0b2dnbGUoY20uZGlzcGxheS5zY3JvbGxlciwgXCJkcmFnc3RhcnRcIiwgZnVuY3Muc3RhcnQpO1xuICAgICAgdG9nZ2xlKGNtLmRpc3BsYXkuc2Nyb2xsZXIsIFwiZHJhZ2VudGVyXCIsIGZ1bmNzLmVudGVyKTtcbiAgICAgIHRvZ2dsZShjbS5kaXNwbGF5LnNjcm9sbGVyLCBcImRyYWdvdmVyXCIsIGZ1bmNzLm92ZXIpO1xuICAgICAgdG9nZ2xlKGNtLmRpc3BsYXkuc2Nyb2xsZXIsIFwiZHJhZ2xlYXZlXCIsIGZ1bmNzLmxlYXZlKTtcbiAgICAgIHRvZ2dsZShjbS5kaXNwbGF5LnNjcm9sbGVyLCBcImRyb3BcIiwgZnVuY3MuZHJvcCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gd3JhcHBpbmdDaGFuZ2VkKGNtKSB7XG4gICAgaWYgKGNtLm9wdGlvbnMubGluZVdyYXBwaW5nKSB7XG4gICAgICBhZGRDbGFzcyhjbS5kaXNwbGF5LndyYXBwZXIsIFwiQ29kZU1pcnJvci13cmFwXCIpO1xuICAgICAgY20uZGlzcGxheS5zaXplci5zdHlsZS5taW5XaWR0aCA9IFwiXCI7XG4gICAgICBjbS5kaXNwbGF5LnNpemVyV2lkdGggPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBybUNsYXNzKGNtLmRpc3BsYXkud3JhcHBlciwgXCJDb2RlTWlycm9yLXdyYXBcIik7XG4gICAgICBmaW5kTWF4TGluZShjbSk7XG4gICAgfVxuICAgIGVzdGltYXRlTGluZUhlaWdodHMoY20pO1xuICAgIHJlZ0NoYW5nZShjbSk7XG4gICAgY2xlYXJDYWNoZXMoY20pO1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gdXBkYXRlU2Nyb2xsYmFycyhjbSk7IH0sIDEwMCk7XG4gIH1cblxuICAvLyBBIENvZGVNaXJyb3IgaW5zdGFuY2UgcmVwcmVzZW50cyBhbiBlZGl0b3IuIFRoaXMgaXMgdGhlIG9iamVjdFxuICAvLyB0aGF0IHVzZXIgY29kZSBpcyB1c3VhbGx5IGRlYWxpbmcgd2l0aC5cblxuICBmdW5jdGlvbiBDb2RlTWlycm9yKHBsYWNlLCBvcHRpb25zKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQ29kZU1pcnJvcikpIHsgcmV0dXJuIG5ldyBDb2RlTWlycm9yKHBsYWNlLCBvcHRpb25zKSB9XG5cbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zID0gb3B0aW9ucyA/IGNvcHlPYmoob3B0aW9ucykgOiB7fTtcbiAgICAvLyBEZXRlcm1pbmUgZWZmZWN0aXZlIG9wdGlvbnMgYmFzZWQgb24gZ2l2ZW4gdmFsdWVzIGFuZCBkZWZhdWx0cy5cbiAgICBjb3B5T2JqKGRlZmF1bHRzLCBvcHRpb25zLCBmYWxzZSk7XG5cbiAgICB2YXIgZG9jID0gb3B0aW9ucy52YWx1ZTtcbiAgICBpZiAodHlwZW9mIGRvYyA9PSBcInN0cmluZ1wiKSB7IGRvYyA9IG5ldyBEb2MoZG9jLCBvcHRpb25zLm1vZGUsIG51bGwsIG9wdGlvbnMubGluZVNlcGFyYXRvciwgb3B0aW9ucy5kaXJlY3Rpb24pOyB9XG4gICAgZWxzZSBpZiAob3B0aW9ucy5tb2RlKSB7IGRvYy5tb2RlT3B0aW9uID0gb3B0aW9ucy5tb2RlOyB9XG4gICAgdGhpcy5kb2MgPSBkb2M7XG5cbiAgICB2YXIgaW5wdXQgPSBuZXcgQ29kZU1pcnJvci5pbnB1dFN0eWxlc1tvcHRpb25zLmlucHV0U3R5bGVdKHRoaXMpO1xuICAgIHZhciBkaXNwbGF5ID0gdGhpcy5kaXNwbGF5ID0gbmV3IERpc3BsYXkocGxhY2UsIGRvYywgaW5wdXQsIG9wdGlvbnMpO1xuICAgIGRpc3BsYXkud3JhcHBlci5Db2RlTWlycm9yID0gdGhpcztcbiAgICB0aGVtZUNoYW5nZWQodGhpcyk7XG4gICAgaWYgKG9wdGlvbnMubGluZVdyYXBwaW5nKVxuICAgICAgeyB0aGlzLmRpc3BsYXkud3JhcHBlci5jbGFzc05hbWUgKz0gXCIgQ29kZU1pcnJvci13cmFwXCI7IH1cbiAgICBpbml0U2Nyb2xsYmFycyh0aGlzKTtcblxuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBrZXlNYXBzOiBbXSwgIC8vIHN0b3JlcyBtYXBzIGFkZGVkIGJ5IGFkZEtleU1hcFxuICAgICAgb3ZlcmxheXM6IFtdLCAvLyBoaWdobGlnaHRpbmcgb3ZlcmxheXMsIGFzIGFkZGVkIGJ5IGFkZE92ZXJsYXlcbiAgICAgIG1vZGVHZW46IDAsICAgLy8gYnVtcGVkIHdoZW4gbW9kZS9vdmVybGF5IGNoYW5nZXMsIHVzZWQgdG8gaW52YWxpZGF0ZSBoaWdobGlnaHRpbmcgaW5mb1xuICAgICAgb3ZlcndyaXRlOiBmYWxzZSxcbiAgICAgIGRlbGF5aW5nQmx1ckV2ZW50OiBmYWxzZSxcbiAgICAgIGZvY3VzZWQ6IGZhbHNlLFxuICAgICAgc3VwcHJlc3NFZGl0czogZmFsc2UsIC8vIHVzZWQgdG8gZGlzYWJsZSBlZGl0aW5nIGR1cmluZyBrZXkgaGFuZGxlcnMgd2hlbiBpbiByZWFkT25seSBtb2RlXG4gICAgICBwYXN0ZUluY29taW5nOiAtMSwgY3V0SW5jb21pbmc6IC0xLCAvLyBoZWxwIHJlY29nbml6ZSBwYXN0ZS9jdXQgZWRpdHMgaW4gaW5wdXQucG9sbFxuICAgICAgc2VsZWN0aW5nVGV4dDogZmFsc2UsXG4gICAgICBkcmFnZ2luZ1RleHQ6IGZhbHNlLFxuICAgICAgaGlnaGxpZ2h0OiBuZXcgRGVsYXllZCgpLCAvLyBzdG9yZXMgaGlnaGxpZ2h0IHdvcmtlciB0aW1lb3V0XG4gICAgICBrZXlTZXE6IG51bGwsICAvLyBVbmZpbmlzaGVkIGtleSBzZXF1ZW5jZVxuICAgICAgc3BlY2lhbENoYXJzOiBudWxsXG4gICAgfTtcblxuICAgIGlmIChvcHRpb25zLmF1dG9mb2N1cyAmJiAhbW9iaWxlKSB7IGRpc3BsYXkuaW5wdXQuZm9jdXMoKTsgfVxuXG4gICAgLy8gT3ZlcnJpZGUgbWFnaWMgdGV4dGFyZWEgY29udGVudCByZXN0b3JlIHRoYXQgSUUgc29tZXRpbWVzIGRvZXNcbiAgICAvLyBvbiBvdXIgaGlkZGVuIHRleHRhcmVhIG9uIHJlbG9hZFxuICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDwgMTEpIHsgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzJDEuZGlzcGxheS5pbnB1dC5yZXNldCh0cnVlKTsgfSwgMjApOyB9XG5cbiAgICByZWdpc3RlckV2ZW50SGFuZGxlcnModGhpcyk7XG4gICAgZW5zdXJlR2xvYmFsSGFuZGxlcnMoKTtcblxuICAgIHN0YXJ0T3BlcmF0aW9uKHRoaXMpO1xuICAgIHRoaXMuY3VyT3AuZm9yY2VVcGRhdGUgPSB0cnVlO1xuICAgIGF0dGFjaERvYyh0aGlzLCBkb2MpO1xuXG4gICAgaWYgKChvcHRpb25zLmF1dG9mb2N1cyAmJiAhbW9iaWxlKSB8fCB0aGlzLmhhc0ZvY3VzKCkpXG4gICAgICB7IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcyQxLmhhc0ZvY3VzKCkgJiYgIXRoaXMkMS5zdGF0ZS5mb2N1c2VkKSB7IG9uRm9jdXModGhpcyQxKTsgfVxuICAgICAgfSwgMjApOyB9XG4gICAgZWxzZVxuICAgICAgeyBvbkJsdXIodGhpcyk7IH1cblxuICAgIGZvciAodmFyIG9wdCBpbiBvcHRpb25IYW5kbGVycykgeyBpZiAob3B0aW9uSGFuZGxlcnMuaGFzT3duUHJvcGVydHkob3B0KSlcbiAgICAgIHsgb3B0aW9uSGFuZGxlcnNbb3B0XSh0aGlzLCBvcHRpb25zW29wdF0sIEluaXQpOyB9IH1cbiAgICBtYXliZVVwZGF0ZUxpbmVOdW1iZXJXaWR0aCh0aGlzKTtcbiAgICBpZiAob3B0aW9ucy5maW5pc2hJbml0KSB7IG9wdGlvbnMuZmluaXNoSW5pdCh0aGlzKTsgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5pdEhvb2tzLmxlbmd0aDsgKytpKSB7IGluaXRIb29rc1tpXSh0aGlzKTsgfVxuICAgIGVuZE9wZXJhdGlvbih0aGlzKTtcbiAgICAvLyBTdXBwcmVzcyBvcHRpbWl6ZWxlZ2liaWxpdHkgaW4gV2Via2l0LCBzaW5jZSBpdCBicmVha3MgdGV4dFxuICAgIC8vIG1lYXN1cmluZyBvbiBsaW5lIHdyYXBwaW5nIGJvdW5kYXJpZXMuXG4gICAgaWYgKHdlYmtpdCAmJiBvcHRpb25zLmxpbmVXcmFwcGluZyAmJlxuICAgICAgICBnZXRDb21wdXRlZFN0eWxlKGRpc3BsYXkubGluZURpdikudGV4dFJlbmRlcmluZyA9PSBcIm9wdGltaXplbGVnaWJpbGl0eVwiKVxuICAgICAgeyBkaXNwbGF5LmxpbmVEaXYuc3R5bGUudGV4dFJlbmRlcmluZyA9IFwiYXV0b1wiOyB9XG4gIH1cblxuICAvLyBUaGUgZGVmYXVsdCBjb25maWd1cmF0aW9uIG9wdGlvbnMuXG4gIENvZGVNaXJyb3IuZGVmYXVsdHMgPSBkZWZhdWx0cztcbiAgLy8gRnVuY3Rpb25zIHRvIHJ1biB3aGVuIG9wdGlvbnMgYXJlIGNoYW5nZWQuXG4gIENvZGVNaXJyb3Iub3B0aW9uSGFuZGxlcnMgPSBvcHRpb25IYW5kbGVycztcblxuICAvLyBBdHRhY2ggdGhlIG5lY2Vzc2FyeSBldmVudCBoYW5kbGVycyB3aGVuIGluaXRpYWxpemluZyB0aGUgZWRpdG9yXG4gIGZ1bmN0aW9uIHJlZ2lzdGVyRXZlbnRIYW5kbGVycyhjbSkge1xuICAgIHZhciBkID0gY20uZGlzcGxheTtcbiAgICBvbihkLnNjcm9sbGVyLCBcIm1vdXNlZG93blwiLCBvcGVyYXRpb24oY20sIG9uTW91c2VEb3duKSk7XG4gICAgLy8gT2xkZXIgSUUncyB3aWxsIG5vdCBmaXJlIGEgc2Vjb25kIG1vdXNlZG93biBmb3IgYSBkb3VibGUgY2xpY2tcbiAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8IDExKVxuICAgICAgeyBvbihkLnNjcm9sbGVyLCBcImRibGNsaWNrXCIsIG9wZXJhdGlvbihjbSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKHNpZ25hbERPTUV2ZW50KGNtLCBlKSkgeyByZXR1cm4gfVxuICAgICAgICB2YXIgcG9zID0gcG9zRnJvbU1vdXNlKGNtLCBlKTtcbiAgICAgICAgaWYgKCFwb3MgfHwgY2xpY2tJbkd1dHRlcihjbSwgZSkgfHwgZXZlbnRJbldpZGdldChjbS5kaXNwbGF5LCBlKSkgeyByZXR1cm4gfVxuICAgICAgICBlX3ByZXZlbnREZWZhdWx0KGUpO1xuICAgICAgICB2YXIgd29yZCA9IGNtLmZpbmRXb3JkQXQocG9zKTtcbiAgICAgICAgZXh0ZW5kU2VsZWN0aW9uKGNtLmRvYywgd29yZC5hbmNob3IsIHdvcmQuaGVhZCk7XG4gICAgICB9KSk7IH1cbiAgICBlbHNlXG4gICAgICB7IG9uKGQuc2Nyb2xsZXIsIFwiZGJsY2xpY2tcIiwgZnVuY3Rpb24gKGUpIHsgcmV0dXJuIHNpZ25hbERPTUV2ZW50KGNtLCBlKSB8fCBlX3ByZXZlbnREZWZhdWx0KGUpOyB9KTsgfVxuICAgIC8vIFNvbWUgYnJvd3NlcnMgZmlyZSBjb250ZXh0bWVudSAqYWZ0ZXIqIG9wZW5pbmcgdGhlIG1lbnUsIGF0XG4gICAgLy8gd2hpY2ggcG9pbnQgd2UgY2FuJ3QgbWVzcyB3aXRoIGl0IGFueW1vcmUuIENvbnRleHQgbWVudSBpc1xuICAgIC8vIGhhbmRsZWQgaW4gb25Nb3VzZURvd24gZm9yIHRoZXNlIGJyb3dzZXJzLlxuICAgIG9uKGQuc2Nyb2xsZXIsIFwiY29udGV4dG1lbnVcIiwgZnVuY3Rpb24gKGUpIHsgcmV0dXJuIG9uQ29udGV4dE1lbnUoY20sIGUpOyB9KTtcbiAgICBvbihkLmlucHV0LmdldEZpZWxkKCksIFwiY29udGV4dG1lbnVcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmICghZC5zY3JvbGxlci5jb250YWlucyhlLnRhcmdldCkpIHsgb25Db250ZXh0TWVudShjbSwgZSk7IH1cbiAgICB9KTtcblxuICAgIC8vIFVzZWQgdG8gc3VwcHJlc3MgbW91c2UgZXZlbnQgaGFuZGxpbmcgd2hlbiBhIHRvdWNoIGhhcHBlbnNcbiAgICB2YXIgdG91Y2hGaW5pc2hlZCwgcHJldlRvdWNoID0ge2VuZDogMH07XG4gICAgZnVuY3Rpb24gZmluaXNoVG91Y2goKSB7XG4gICAgICBpZiAoZC5hY3RpdmVUb3VjaCkge1xuICAgICAgICB0b3VjaEZpbmlzaGVkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBkLmFjdGl2ZVRvdWNoID0gbnVsbDsgfSwgMTAwMCk7XG4gICAgICAgIHByZXZUb3VjaCA9IGQuYWN0aXZlVG91Y2g7XG4gICAgICAgIHByZXZUb3VjaC5lbmQgPSArbmV3IERhdGU7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzTW91c2VMaWtlVG91Y2hFdmVudChlKSB7XG4gICAgICBpZiAoZS50b3VjaGVzLmxlbmd0aCAhPSAxKSB7IHJldHVybiBmYWxzZSB9XG4gICAgICB2YXIgdG91Y2ggPSBlLnRvdWNoZXNbMF07XG4gICAgICByZXR1cm4gdG91Y2gucmFkaXVzWCA8PSAxICYmIHRvdWNoLnJhZGl1c1kgPD0gMVxuICAgIH1cbiAgICBmdW5jdGlvbiBmYXJBd2F5KHRvdWNoLCBvdGhlcikge1xuICAgICAgaWYgKG90aGVyLmxlZnQgPT0gbnVsbCkgeyByZXR1cm4gdHJ1ZSB9XG4gICAgICB2YXIgZHggPSBvdGhlci5sZWZ0IC0gdG91Y2gubGVmdCwgZHkgPSBvdGhlci50b3AgLSB0b3VjaC50b3A7XG4gICAgICByZXR1cm4gZHggKiBkeCArIGR5ICogZHkgPiAyMCAqIDIwXG4gICAgfVxuICAgIG9uKGQuc2Nyb2xsZXIsIFwidG91Y2hzdGFydFwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKCFzaWduYWxET01FdmVudChjbSwgZSkgJiYgIWlzTW91c2VMaWtlVG91Y2hFdmVudChlKSAmJiAhY2xpY2tJbkd1dHRlcihjbSwgZSkpIHtcbiAgICAgICAgZC5pbnB1dC5lbnN1cmVQb2xsZWQoKTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRvdWNoRmluaXNoZWQpO1xuICAgICAgICB2YXIgbm93ID0gK25ldyBEYXRlO1xuICAgICAgICBkLmFjdGl2ZVRvdWNoID0ge3N0YXJ0OiBub3csIG1vdmVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2OiBub3cgLSBwcmV2VG91Y2guZW5kIDw9IDMwMCA/IHByZXZUb3VjaCA6IG51bGx9O1xuICAgICAgICBpZiAoZS50b3VjaGVzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgZC5hY3RpdmVUb3VjaC5sZWZ0ID0gZS50b3VjaGVzWzBdLnBhZ2VYO1xuICAgICAgICAgIGQuYWN0aXZlVG91Y2gudG9wID0gZS50b3VjaGVzWzBdLnBhZ2VZO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgb24oZC5zY3JvbGxlciwgXCJ0b3VjaG1vdmVcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGQuYWN0aXZlVG91Y2gpIHsgZC5hY3RpdmVUb3VjaC5tb3ZlZCA9IHRydWU7IH1cbiAgICB9KTtcbiAgICBvbihkLnNjcm9sbGVyLCBcInRvdWNoZW5kXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICB2YXIgdG91Y2ggPSBkLmFjdGl2ZVRvdWNoO1xuICAgICAgaWYgKHRvdWNoICYmICFldmVudEluV2lkZ2V0KGQsIGUpICYmIHRvdWNoLmxlZnQgIT0gbnVsbCAmJlxuICAgICAgICAgICF0b3VjaC5tb3ZlZCAmJiBuZXcgRGF0ZSAtIHRvdWNoLnN0YXJ0IDwgMzAwKSB7XG4gICAgICAgIHZhciBwb3MgPSBjbS5jb29yZHNDaGFyKGQuYWN0aXZlVG91Y2gsIFwicGFnZVwiKSwgcmFuZ2U7XG4gICAgICAgIGlmICghdG91Y2gucHJldiB8fCBmYXJBd2F5KHRvdWNoLCB0b3VjaC5wcmV2KSkgLy8gU2luZ2xlIHRhcFxuICAgICAgICAgIHsgcmFuZ2UgPSBuZXcgUmFuZ2UocG9zLCBwb3MpOyB9XG4gICAgICAgIGVsc2UgaWYgKCF0b3VjaC5wcmV2LnByZXYgfHwgZmFyQXdheSh0b3VjaCwgdG91Y2gucHJldi5wcmV2KSkgLy8gRG91YmxlIHRhcFxuICAgICAgICAgIHsgcmFuZ2UgPSBjbS5maW5kV29yZEF0KHBvcyk7IH1cbiAgICAgICAgZWxzZSAvLyBUcmlwbGUgdGFwXG4gICAgICAgICAgeyByYW5nZSA9IG5ldyBSYW5nZShQb3MocG9zLmxpbmUsIDApLCBjbGlwUG9zKGNtLmRvYywgUG9zKHBvcy5saW5lICsgMSwgMCkpKTsgfVxuICAgICAgICBjbS5zZXRTZWxlY3Rpb24ocmFuZ2UuYW5jaG9yLCByYW5nZS5oZWFkKTtcbiAgICAgICAgY20uZm9jdXMoKTtcbiAgICAgICAgZV9wcmV2ZW50RGVmYXVsdChlKTtcbiAgICAgIH1cbiAgICAgIGZpbmlzaFRvdWNoKCk7XG4gICAgfSk7XG4gICAgb24oZC5zY3JvbGxlciwgXCJ0b3VjaGNhbmNlbFwiLCBmaW5pc2hUb3VjaCk7XG5cbiAgICAvLyBTeW5jIHNjcm9sbGluZyBiZXR3ZWVuIGZha2Ugc2Nyb2xsYmFycyBhbmQgcmVhbCBzY3JvbGxhYmxlXG4gICAgLy8gYXJlYSwgZW5zdXJlIHZpZXdwb3J0IGlzIHVwZGF0ZWQgd2hlbiBzY3JvbGxpbmcuXG4gICAgb24oZC5zY3JvbGxlciwgXCJzY3JvbGxcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGQuc2Nyb2xsZXIuY2xpZW50SGVpZ2h0KSB7XG4gICAgICAgIHVwZGF0ZVNjcm9sbFRvcChjbSwgZC5zY3JvbGxlci5zY3JvbGxUb3ApO1xuICAgICAgICBzZXRTY3JvbGxMZWZ0KGNtLCBkLnNjcm9sbGVyLnNjcm9sbExlZnQsIHRydWUpO1xuICAgICAgICBzaWduYWwoY20sIFwic2Nyb2xsXCIsIGNtKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIExpc3RlbiB0byB3aGVlbCBldmVudHMgaW4gb3JkZXIgdG8gdHJ5IGFuZCB1cGRhdGUgdGhlIHZpZXdwb3J0IG9uIHRpbWUuXG4gICAgb24oZC5zY3JvbGxlciwgXCJtb3VzZXdoZWVsXCIsIGZ1bmN0aW9uIChlKSB7IHJldHVybiBvblNjcm9sbFdoZWVsKGNtLCBlKTsgfSk7XG4gICAgb24oZC5zY3JvbGxlciwgXCJET01Nb3VzZVNjcm9sbFwiLCBmdW5jdGlvbiAoZSkgeyByZXR1cm4gb25TY3JvbGxXaGVlbChjbSwgZSk7IH0pO1xuXG4gICAgLy8gUHJldmVudCB3cmFwcGVyIGZyb20gZXZlciBzY3JvbGxpbmdcbiAgICBvbihkLndyYXBwZXIsIFwic2Nyb2xsXCIsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGQud3JhcHBlci5zY3JvbGxUb3AgPSBkLndyYXBwZXIuc2Nyb2xsTGVmdCA9IDA7IH0pO1xuXG4gICAgZC5kcmFnRnVuY3Rpb25zID0ge1xuICAgICAgZW50ZXI6IGZ1bmN0aW9uIChlKSB7aWYgKCFzaWduYWxET01FdmVudChjbSwgZSkpIHsgZV9zdG9wKGUpOyB9fSxcbiAgICAgIG92ZXI6IGZ1bmN0aW9uIChlKSB7aWYgKCFzaWduYWxET01FdmVudChjbSwgZSkpIHsgb25EcmFnT3ZlcihjbSwgZSk7IGVfc3RvcChlKTsgfX0sXG4gICAgICBzdGFydDogZnVuY3Rpb24gKGUpIHsgcmV0dXJuIG9uRHJhZ1N0YXJ0KGNtLCBlKTsgfSxcbiAgICAgIGRyb3A6IG9wZXJhdGlvbihjbSwgb25Ecm9wKSxcbiAgICAgIGxlYXZlOiBmdW5jdGlvbiAoZSkge2lmICghc2lnbmFsRE9NRXZlbnQoY20sIGUpKSB7IGNsZWFyRHJhZ0N1cnNvcihjbSk7IH19XG4gICAgfTtcblxuICAgIHZhciBpbnAgPSBkLmlucHV0LmdldEZpZWxkKCk7XG4gICAgb24oaW5wLCBcImtleXVwXCIsIGZ1bmN0aW9uIChlKSB7IHJldHVybiBvbktleVVwLmNhbGwoY20sIGUpOyB9KTtcbiAgICBvbihpbnAsIFwia2V5ZG93blwiLCBvcGVyYXRpb24oY20sIG9uS2V5RG93bikpO1xuICAgIG9uKGlucCwgXCJrZXlwcmVzc1wiLCBvcGVyYXRpb24oY20sIG9uS2V5UHJlc3MpKTtcbiAgICBvbihpbnAsIFwiZm9jdXNcIiwgZnVuY3Rpb24gKGUpIHsgcmV0dXJuIG9uRm9jdXMoY20sIGUpOyB9KTtcbiAgICBvbihpbnAsIFwiYmx1clwiLCBmdW5jdGlvbiAoZSkgeyByZXR1cm4gb25CbHVyKGNtLCBlKTsgfSk7XG4gIH1cblxuICB2YXIgaW5pdEhvb2tzID0gW107XG4gIENvZGVNaXJyb3IuZGVmaW5lSW5pdEhvb2sgPSBmdW5jdGlvbiAoZikgeyByZXR1cm4gaW5pdEhvb2tzLnB1c2goZik7IH07XG5cbiAgLy8gSW5kZW50IHRoZSBnaXZlbiBsaW5lLiBUaGUgaG93IHBhcmFtZXRlciBjYW4gYmUgXCJzbWFydFwiLFxuICAvLyBcImFkZFwiL251bGwsIFwic3VidHJhY3RcIiwgb3IgXCJwcmV2XCIuIFdoZW4gYWdncmVzc2l2ZSBpcyBmYWxzZVxuICAvLyAodHlwaWNhbGx5IHNldCB0byB0cnVlIGZvciBmb3JjZWQgc2luZ2xlLWxpbmUgaW5kZW50cyksIGVtcHR5XG4gIC8vIGxpbmVzIGFyZSBub3QgaW5kZW50ZWQsIGFuZCBwbGFjZXMgd2hlcmUgdGhlIG1vZGUgcmV0dXJucyBQYXNzXG4gIC8vIGFyZSBsZWZ0IGFsb25lLlxuICBmdW5jdGlvbiBpbmRlbnRMaW5lKGNtLCBuLCBob3csIGFnZ3Jlc3NpdmUpIHtcbiAgICB2YXIgZG9jID0gY20uZG9jLCBzdGF0ZTtcbiAgICBpZiAoaG93ID09IG51bGwpIHsgaG93ID0gXCJhZGRcIjsgfVxuICAgIGlmIChob3cgPT0gXCJzbWFydFwiKSB7XG4gICAgICAvLyBGYWxsIGJhY2sgdG8gXCJwcmV2XCIgd2hlbiB0aGUgbW9kZSBkb2Vzbid0IGhhdmUgYW4gaW5kZW50YXRpb25cbiAgICAgIC8vIG1ldGhvZC5cbiAgICAgIGlmICghZG9jLm1vZGUuaW5kZW50KSB7IGhvdyA9IFwicHJldlwiOyB9XG4gICAgICBlbHNlIHsgc3RhdGUgPSBnZXRDb250ZXh0QmVmb3JlKGNtLCBuKS5zdGF0ZTsgfVxuICAgIH1cblxuICAgIHZhciB0YWJTaXplID0gY20ub3B0aW9ucy50YWJTaXplO1xuICAgIHZhciBsaW5lID0gZ2V0TGluZShkb2MsIG4pLCBjdXJTcGFjZSA9IGNvdW50Q29sdW1uKGxpbmUudGV4dCwgbnVsbCwgdGFiU2l6ZSk7XG4gICAgaWYgKGxpbmUuc3RhdGVBZnRlcikgeyBsaW5lLnN0YXRlQWZ0ZXIgPSBudWxsOyB9XG4gICAgdmFyIGN1clNwYWNlU3RyaW5nID0gbGluZS50ZXh0Lm1hdGNoKC9eXFxzKi8pWzBdLCBpbmRlbnRhdGlvbjtcbiAgICBpZiAoIWFnZ3Jlc3NpdmUgJiYgIS9cXFMvLnRlc3QobGluZS50ZXh0KSkge1xuICAgICAgaW5kZW50YXRpb24gPSAwO1xuICAgICAgaG93ID0gXCJub3RcIjtcbiAgICB9IGVsc2UgaWYgKGhvdyA9PSBcInNtYXJ0XCIpIHtcbiAgICAgIGluZGVudGF0aW9uID0gZG9jLm1vZGUuaW5kZW50KHN0YXRlLCBsaW5lLnRleHQuc2xpY2UoY3VyU3BhY2VTdHJpbmcubGVuZ3RoKSwgbGluZS50ZXh0KTtcbiAgICAgIGlmIChpbmRlbnRhdGlvbiA9PSBQYXNzIHx8IGluZGVudGF0aW9uID4gMTUwKSB7XG4gICAgICAgIGlmICghYWdncmVzc2l2ZSkgeyByZXR1cm4gfVxuICAgICAgICBob3cgPSBcInByZXZcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGhvdyA9PSBcInByZXZcIikge1xuICAgICAgaWYgKG4gPiBkb2MuZmlyc3QpIHsgaW5kZW50YXRpb24gPSBjb3VudENvbHVtbihnZXRMaW5lKGRvYywgbi0xKS50ZXh0LCBudWxsLCB0YWJTaXplKTsgfVxuICAgICAgZWxzZSB7IGluZGVudGF0aW9uID0gMDsgfVxuICAgIH0gZWxzZSBpZiAoaG93ID09IFwiYWRkXCIpIHtcbiAgICAgIGluZGVudGF0aW9uID0gY3VyU3BhY2UgKyBjbS5vcHRpb25zLmluZGVudFVuaXQ7XG4gICAgfSBlbHNlIGlmIChob3cgPT0gXCJzdWJ0cmFjdFwiKSB7XG4gICAgICBpbmRlbnRhdGlvbiA9IGN1clNwYWNlIC0gY20ub3B0aW9ucy5pbmRlbnRVbml0O1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGhvdyA9PSBcIm51bWJlclwiKSB7XG4gICAgICBpbmRlbnRhdGlvbiA9IGN1clNwYWNlICsgaG93O1xuICAgIH1cbiAgICBpbmRlbnRhdGlvbiA9IE1hdGgubWF4KDAsIGluZGVudGF0aW9uKTtcblxuICAgIHZhciBpbmRlbnRTdHJpbmcgPSBcIlwiLCBwb3MgPSAwO1xuICAgIGlmIChjbS5vcHRpb25zLmluZGVudFdpdGhUYWJzKVxuICAgICAgeyBmb3IgKHZhciBpID0gTWF0aC5mbG9vcihpbmRlbnRhdGlvbiAvIHRhYlNpemUpOyBpOyAtLWkpIHtwb3MgKz0gdGFiU2l6ZTsgaW5kZW50U3RyaW5nICs9IFwiXFx0XCI7fSB9XG4gICAgaWYgKHBvcyA8IGluZGVudGF0aW9uKSB7IGluZGVudFN0cmluZyArPSBzcGFjZVN0cihpbmRlbnRhdGlvbiAtIHBvcyk7IH1cblxuICAgIGlmIChpbmRlbnRTdHJpbmcgIT0gY3VyU3BhY2VTdHJpbmcpIHtcbiAgICAgIHJlcGxhY2VSYW5nZShkb2MsIGluZGVudFN0cmluZywgUG9zKG4sIDApLCBQb3MobiwgY3VyU3BhY2VTdHJpbmcubGVuZ3RoKSwgXCIraW5wdXRcIik7XG4gICAgICBsaW5lLnN0YXRlQWZ0ZXIgPSBudWxsO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRW5zdXJlIHRoYXQsIGlmIHRoZSBjdXJzb3Igd2FzIGluIHRoZSB3aGl0ZXNwYWNlIGF0IHRoZSBzdGFydFxuICAgICAgLy8gb2YgdGhlIGxpbmUsIGl0IGlzIG1vdmVkIHRvIHRoZSBlbmQgb2YgdGhhdCBzcGFjZS5cbiAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGRvYy5zZWwucmFuZ2VzLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgICAgdmFyIHJhbmdlID0gZG9jLnNlbC5yYW5nZXNbaSQxXTtcbiAgICAgICAgaWYgKHJhbmdlLmhlYWQubGluZSA9PSBuICYmIHJhbmdlLmhlYWQuY2ggPCBjdXJTcGFjZVN0cmluZy5sZW5ndGgpIHtcbiAgICAgICAgICB2YXIgcG9zJDEgPSBQb3MobiwgY3VyU3BhY2VTdHJpbmcubGVuZ3RoKTtcbiAgICAgICAgICByZXBsYWNlT25lU2VsZWN0aW9uKGRvYywgaSQxLCBuZXcgUmFuZ2UocG9zJDEsIHBvcyQxKSk7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFRoaXMgd2lsbCBiZSBzZXQgdG8gYSB7bGluZVdpc2U6IGJvb2wsIHRleHQ6IFtzdHJpbmddfSBvYmplY3QsIHNvXG4gIC8vIHRoYXQsIHdoZW4gcGFzdGluZywgd2Uga25vdyB3aGF0IGtpbmQgb2Ygc2VsZWN0aW9ucyB0aGUgY29waWVkXG4gIC8vIHRleHQgd2FzIG1hZGUgb3V0IG9mLlxuICB2YXIgbGFzdENvcGllZCA9IG51bGw7XG5cbiAgZnVuY3Rpb24gc2V0TGFzdENvcGllZChuZXdMYXN0Q29waWVkKSB7XG4gICAgbGFzdENvcGllZCA9IG5ld0xhc3RDb3BpZWQ7XG4gIH1cblxuICBmdW5jdGlvbiBhcHBseVRleHRJbnB1dChjbSwgaW5zZXJ0ZWQsIGRlbGV0ZWQsIHNlbCwgb3JpZ2luKSB7XG4gICAgdmFyIGRvYyA9IGNtLmRvYztcbiAgICBjbS5kaXNwbGF5LnNoaWZ0ID0gZmFsc2U7XG4gICAgaWYgKCFzZWwpIHsgc2VsID0gZG9jLnNlbDsgfVxuXG4gICAgdmFyIHJlY2VudCA9ICtuZXcgRGF0ZSAtIDIwMDtcbiAgICB2YXIgcGFzdGUgPSBvcmlnaW4gPT0gXCJwYXN0ZVwiIHx8IGNtLnN0YXRlLnBhc3RlSW5jb21pbmcgPiByZWNlbnQ7XG4gICAgdmFyIHRleHRMaW5lcyA9IHNwbGl0TGluZXNBdXRvKGluc2VydGVkKSwgbXVsdGlQYXN0ZSA9IG51bGw7XG4gICAgLy8gV2hlbiBwYXN0aW5nIE4gbGluZXMgaW50byBOIHNlbGVjdGlvbnMsIGluc2VydCBvbmUgbGluZSBwZXIgc2VsZWN0aW9uXG4gICAgaWYgKHBhc3RlICYmIHNlbC5yYW5nZXMubGVuZ3RoID4gMSkge1xuICAgICAgaWYgKGxhc3RDb3BpZWQgJiYgbGFzdENvcGllZC50ZXh0LmpvaW4oXCJcXG5cIikgPT0gaW5zZXJ0ZWQpIHtcbiAgICAgICAgaWYgKHNlbC5yYW5nZXMubGVuZ3RoICUgbGFzdENvcGllZC50ZXh0Lmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgbXVsdGlQYXN0ZSA9IFtdO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGFzdENvcGllZC50ZXh0Lmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgeyBtdWx0aVBhc3RlLnB1c2goZG9jLnNwbGl0TGluZXMobGFzdENvcGllZC50ZXh0W2ldKSk7IH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0ZXh0TGluZXMubGVuZ3RoID09IHNlbC5yYW5nZXMubGVuZ3RoICYmIGNtLm9wdGlvbnMucGFzdGVMaW5lc1BlclNlbGVjdGlvbikge1xuICAgICAgICBtdWx0aVBhc3RlID0gbWFwKHRleHRMaW5lcywgZnVuY3Rpb24gKGwpIHsgcmV0dXJuIFtsXTsgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHVwZGF0ZUlucHV0ID0gY20uY3VyT3AudXBkYXRlSW5wdXQ7XG4gICAgLy8gTm9ybWFsIGJlaGF2aW9yIGlzIHRvIGluc2VydCB0aGUgbmV3IHRleHQgaW50byBldmVyeSBzZWxlY3Rpb25cbiAgICBmb3IgKHZhciBpJDEgPSBzZWwucmFuZ2VzLmxlbmd0aCAtIDE7IGkkMSA+PSAwOyBpJDEtLSkge1xuICAgICAgdmFyIHJhbmdlID0gc2VsLnJhbmdlc1tpJDFdO1xuICAgICAgdmFyIGZyb20gPSByYW5nZS5mcm9tKCksIHRvID0gcmFuZ2UudG8oKTtcbiAgICAgIGlmIChyYW5nZS5lbXB0eSgpKSB7XG4gICAgICAgIGlmIChkZWxldGVkICYmIGRlbGV0ZWQgPiAwKSAvLyBIYW5kbGUgZGVsZXRpb25cbiAgICAgICAgICB7IGZyb20gPSBQb3MoZnJvbS5saW5lLCBmcm9tLmNoIC0gZGVsZXRlZCk7IH1cbiAgICAgICAgZWxzZSBpZiAoY20uc3RhdGUub3ZlcndyaXRlICYmICFwYXN0ZSkgLy8gSGFuZGxlIG92ZXJ3cml0ZVxuICAgICAgICAgIHsgdG8gPSBQb3ModG8ubGluZSwgTWF0aC5taW4oZ2V0TGluZShkb2MsIHRvLmxpbmUpLnRleHQubGVuZ3RoLCB0by5jaCArIGxzdCh0ZXh0TGluZXMpLmxlbmd0aCkpOyB9XG4gICAgICAgIGVsc2UgaWYgKHBhc3RlICYmIGxhc3RDb3BpZWQgJiYgbGFzdENvcGllZC5saW5lV2lzZSAmJiBsYXN0Q29waWVkLnRleHQuam9pbihcIlxcblwiKSA9PSB0ZXh0TGluZXMuam9pbihcIlxcblwiKSlcbiAgICAgICAgICB7IGZyb20gPSB0byA9IFBvcyhmcm9tLmxpbmUsIDApOyB9XG4gICAgICB9XG4gICAgICB2YXIgY2hhbmdlRXZlbnQgPSB7ZnJvbTogZnJvbSwgdG86IHRvLCB0ZXh0OiBtdWx0aVBhc3RlID8gbXVsdGlQYXN0ZVtpJDEgJSBtdWx0aVBhc3RlLmxlbmd0aF0gOiB0ZXh0TGluZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luOiBvcmlnaW4gfHwgKHBhc3RlID8gXCJwYXN0ZVwiIDogY20uc3RhdGUuY3V0SW5jb21pbmcgPiByZWNlbnQgPyBcImN1dFwiIDogXCIraW5wdXRcIil9O1xuICAgICAgbWFrZUNoYW5nZShjbS5kb2MsIGNoYW5nZUV2ZW50KTtcbiAgICAgIHNpZ25hbExhdGVyKGNtLCBcImlucHV0UmVhZFwiLCBjbSwgY2hhbmdlRXZlbnQpO1xuICAgIH1cbiAgICBpZiAoaW5zZXJ0ZWQgJiYgIXBhc3RlKVxuICAgICAgeyB0cmlnZ2VyRWxlY3RyaWMoY20sIGluc2VydGVkKTsgfVxuXG4gICAgZW5zdXJlQ3Vyc29yVmlzaWJsZShjbSk7XG4gICAgaWYgKGNtLmN1ck9wLnVwZGF0ZUlucHV0IDwgMikgeyBjbS5jdXJPcC51cGRhdGVJbnB1dCA9IHVwZGF0ZUlucHV0OyB9XG4gICAgY20uY3VyT3AudHlwaW5nID0gdHJ1ZTtcbiAgICBjbS5zdGF0ZS5wYXN0ZUluY29taW5nID0gY20uc3RhdGUuY3V0SW5jb21pbmcgPSAtMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZVBhc3RlKGUsIGNtKSB7XG4gICAgdmFyIHBhc3RlZCA9IGUuY2xpcGJvYXJkRGF0YSAmJiBlLmNsaXBib2FyZERhdGEuZ2V0RGF0YShcIlRleHRcIik7XG4gICAgaWYgKHBhc3RlZCkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgaWYgKCFjbS5pc1JlYWRPbmx5KCkgJiYgIWNtLm9wdGlvbnMuZGlzYWJsZUlucHV0KVxuICAgICAgICB7IHJ1bkluT3AoY20sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFwcGx5VGV4dElucHV0KGNtLCBwYXN0ZWQsIDAsIG51bGwsIFwicGFzdGVcIik7IH0pOyB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHRyaWdnZXJFbGVjdHJpYyhjbSwgaW5zZXJ0ZWQpIHtcbiAgICAvLyBXaGVuIGFuICdlbGVjdHJpYycgY2hhcmFjdGVyIGlzIGluc2VydGVkLCBpbW1lZGlhdGVseSB0cmlnZ2VyIGEgcmVpbmRlbnRcbiAgICBpZiAoIWNtLm9wdGlvbnMuZWxlY3RyaWNDaGFycyB8fCAhY20ub3B0aW9ucy5zbWFydEluZGVudCkgeyByZXR1cm4gfVxuICAgIHZhciBzZWwgPSBjbS5kb2Muc2VsO1xuXG4gICAgZm9yICh2YXIgaSA9IHNlbC5yYW5nZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciByYW5nZSA9IHNlbC5yYW5nZXNbaV07XG4gICAgICBpZiAocmFuZ2UuaGVhZC5jaCA+IDEwMCB8fCAoaSAmJiBzZWwucmFuZ2VzW2kgLSAxXS5oZWFkLmxpbmUgPT0gcmFuZ2UuaGVhZC5saW5lKSkgeyBjb250aW51ZSB9XG4gICAgICB2YXIgbW9kZSA9IGNtLmdldE1vZGVBdChyYW5nZS5oZWFkKTtcbiAgICAgIHZhciBpbmRlbnRlZCA9IGZhbHNlO1xuICAgICAgaWYgKG1vZGUuZWxlY3RyaWNDaGFycykge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1vZGUuZWxlY3RyaWNDaGFycy5sZW5ndGg7IGorKylcbiAgICAgICAgICB7IGlmIChpbnNlcnRlZC5pbmRleE9mKG1vZGUuZWxlY3RyaWNDaGFycy5jaGFyQXQoaikpID4gLTEpIHtcbiAgICAgICAgICAgIGluZGVudGVkID0gaW5kZW50TGluZShjbSwgcmFuZ2UuaGVhZC5saW5lLCBcInNtYXJ0XCIpO1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9IH1cbiAgICAgIH0gZWxzZSBpZiAobW9kZS5lbGVjdHJpY0lucHV0KSB7XG4gICAgICAgIGlmIChtb2RlLmVsZWN0cmljSW5wdXQudGVzdChnZXRMaW5lKGNtLmRvYywgcmFuZ2UuaGVhZC5saW5lKS50ZXh0LnNsaWNlKDAsIHJhbmdlLmhlYWQuY2gpKSlcbiAgICAgICAgICB7IGluZGVudGVkID0gaW5kZW50TGluZShjbSwgcmFuZ2UuaGVhZC5saW5lLCBcInNtYXJ0XCIpOyB9XG4gICAgICB9XG4gICAgICBpZiAoaW5kZW50ZWQpIHsgc2lnbmFsTGF0ZXIoY20sIFwiZWxlY3RyaWNJbnB1dFwiLCBjbSwgcmFuZ2UuaGVhZC5saW5lKTsgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvcHlhYmxlUmFuZ2VzKGNtKSB7XG4gICAgdmFyIHRleHQgPSBbXSwgcmFuZ2VzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbS5kb2Muc2VsLnJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGxpbmUgPSBjbS5kb2Muc2VsLnJhbmdlc1tpXS5oZWFkLmxpbmU7XG4gICAgICB2YXIgbGluZVJhbmdlID0ge2FuY2hvcjogUG9zKGxpbmUsIDApLCBoZWFkOiBQb3MobGluZSArIDEsIDApfTtcbiAgICAgIHJhbmdlcy5wdXNoKGxpbmVSYW5nZSk7XG4gICAgICB0ZXh0LnB1c2goY20uZ2V0UmFuZ2UobGluZVJhbmdlLmFuY2hvciwgbGluZVJhbmdlLmhlYWQpKTtcbiAgICB9XG4gICAgcmV0dXJuIHt0ZXh0OiB0ZXh0LCByYW5nZXM6IHJhbmdlc31cbiAgfVxuXG4gIGZ1bmN0aW9uIGRpc2FibGVCcm93c2VyTWFnaWMoZmllbGQsIHNwZWxsY2hlY2ssIGF1dG9jb3JyZWN0LCBhdXRvY2FwaXRhbGl6ZSkge1xuICAgIGZpZWxkLnNldEF0dHJpYnV0ZShcImF1dG9jb3JyZWN0XCIsIGF1dG9jb3JyZWN0ID8gXCJcIiA6IFwib2ZmXCIpO1xuICAgIGZpZWxkLnNldEF0dHJpYnV0ZShcImF1dG9jYXBpdGFsaXplXCIsIGF1dG9jYXBpdGFsaXplID8gXCJcIiA6IFwib2ZmXCIpO1xuICAgIGZpZWxkLnNldEF0dHJpYnV0ZShcInNwZWxsY2hlY2tcIiwgISFzcGVsbGNoZWNrKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhpZGRlblRleHRhcmVhKCkge1xuICAgIHZhciB0ZSA9IGVsdChcInRleHRhcmVhXCIsIG51bGwsIG51bGwsIFwicG9zaXRpb246IGFic29sdXRlOyBib3R0b206IC0xZW07IHBhZGRpbmc6IDA7IHdpZHRoOiAxcHg7IGhlaWdodDogMWVtOyBvdXRsaW5lOiBub25lXCIpO1xuICAgIHZhciBkaXYgPSBlbHQoXCJkaXZcIiwgW3RlXSwgbnVsbCwgXCJvdmVyZmxvdzogaGlkZGVuOyBwb3NpdGlvbjogcmVsYXRpdmU7IHdpZHRoOiAzcHg7IGhlaWdodDogMHB4O1wiKTtcbiAgICAvLyBUaGUgdGV4dGFyZWEgaXMga2VwdCBwb3NpdGlvbmVkIG5lYXIgdGhlIGN1cnNvciB0byBwcmV2ZW50IHRoZVxuICAgIC8vIGZhY3QgdGhhdCBpdCdsbCBiZSBzY3JvbGxlZCBpbnRvIHZpZXcgb24gaW5wdXQgZnJvbSBzY3JvbGxpbmdcbiAgICAvLyBvdXIgZmFrZSBjdXJzb3Igb3V0IG9mIHZpZXcuIE9uIHdlYmtpdCwgd2hlbiB3cmFwPW9mZiwgcGFzdGUgaXNcbiAgICAvLyB2ZXJ5IHNsb3cuIFNvIG1ha2UgdGhlIGFyZWEgd2lkZSBpbnN0ZWFkLlxuICAgIGlmICh3ZWJraXQpIHsgdGUuc3R5bGUud2lkdGggPSBcIjEwMDBweFwiOyB9XG4gICAgZWxzZSB7IHRlLnNldEF0dHJpYnV0ZShcIndyYXBcIiwgXCJvZmZcIik7IH1cbiAgICAvLyBJZiBib3JkZXI6IDA7IC0tIGlPUyBmYWlscyB0byBvcGVuIGtleWJvYXJkIChpc3N1ZSAjMTI4NylcbiAgICBpZiAoaW9zKSB7IHRlLnN0eWxlLmJvcmRlciA9IFwiMXB4IHNvbGlkIGJsYWNrXCI7IH1cbiAgICBkaXNhYmxlQnJvd3Nlck1hZ2ljKHRlKTtcbiAgICByZXR1cm4gZGl2XG4gIH1cblxuICAvLyBUaGUgcHVibGljbHkgdmlzaWJsZSBBUEkuIE5vdGUgdGhhdCBtZXRob2RPcChmKSBtZWFuc1xuICAvLyAnd3JhcCBmIGluIGFuIG9wZXJhdGlvbiwgcGVyZm9ybWVkIG9uIGl0cyBgdGhpc2AgcGFyYW1ldGVyJy5cblxuICAvLyBUaGlzIGlzIG5vdCB0aGUgY29tcGxldGUgc2V0IG9mIGVkaXRvciBtZXRob2RzLiBNb3N0IG9mIHRoZVxuICAvLyBtZXRob2RzIGRlZmluZWQgb24gdGhlIERvYyB0eXBlIGFyZSBhbHNvIGluamVjdGVkIGludG9cbiAgLy8gQ29kZU1pcnJvci5wcm90b3R5cGUsIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSBhbmRcbiAgLy8gY29udmVuaWVuY2UuXG5cbiAgZnVuY3Rpb24gYWRkRWRpdG9yTWV0aG9kcyhDb2RlTWlycm9yKSB7XG4gICAgdmFyIG9wdGlvbkhhbmRsZXJzID0gQ29kZU1pcnJvci5vcHRpb25IYW5kbGVycztcblxuICAgIHZhciBoZWxwZXJzID0gQ29kZU1pcnJvci5oZWxwZXJzID0ge307XG5cbiAgICBDb2RlTWlycm9yLnByb3RvdHlwZSA9IHtcbiAgICAgIGNvbnN0cnVjdG9yOiBDb2RlTWlycm9yLFxuICAgICAgZm9jdXM6IGZ1bmN0aW9uKCl7d2luZG93LmZvY3VzKCk7IHRoaXMuZGlzcGxheS5pbnB1dC5mb2N1cygpO30sXG5cbiAgICAgIHNldE9wdGlvbjogZnVuY3Rpb24ob3B0aW9uLCB2YWx1ZSkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucywgb2xkID0gb3B0aW9uc1tvcHRpb25dO1xuICAgICAgICBpZiAob3B0aW9uc1tvcHRpb25dID09IHZhbHVlICYmIG9wdGlvbiAhPSBcIm1vZGVcIikgeyByZXR1cm4gfVxuICAgICAgICBvcHRpb25zW29wdGlvbl0gPSB2YWx1ZTtcbiAgICAgICAgaWYgKG9wdGlvbkhhbmRsZXJzLmhhc093blByb3BlcnR5KG9wdGlvbikpXG4gICAgICAgICAgeyBvcGVyYXRpb24odGhpcywgb3B0aW9uSGFuZGxlcnNbb3B0aW9uXSkodGhpcywgdmFsdWUsIG9sZCk7IH1cbiAgICAgICAgc2lnbmFsKHRoaXMsIFwib3B0aW9uQ2hhbmdlXCIsIHRoaXMsIG9wdGlvbik7XG4gICAgICB9LFxuXG4gICAgICBnZXRPcHRpb246IGZ1bmN0aW9uKG9wdGlvbikge3JldHVybiB0aGlzLm9wdGlvbnNbb3B0aW9uXX0sXG4gICAgICBnZXREb2M6IGZ1bmN0aW9uKCkge3JldHVybiB0aGlzLmRvY30sXG5cbiAgICAgIGFkZEtleU1hcDogZnVuY3Rpb24obWFwLCBib3R0b20pIHtcbiAgICAgICAgdGhpcy5zdGF0ZS5rZXlNYXBzW2JvdHRvbSA/IFwicHVzaFwiIDogXCJ1bnNoaWZ0XCJdKGdldEtleU1hcChtYXApKTtcbiAgICAgIH0sXG4gICAgICByZW1vdmVLZXlNYXA6IGZ1bmN0aW9uKG1hcCkge1xuICAgICAgICB2YXIgbWFwcyA9IHRoaXMuc3RhdGUua2V5TWFwcztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXBzLmxlbmd0aDsgKytpKVxuICAgICAgICAgIHsgaWYgKG1hcHNbaV0gPT0gbWFwIHx8IG1hcHNbaV0ubmFtZSA9PSBtYXApIHtcbiAgICAgICAgICAgIG1hcHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICB9IH1cbiAgICAgIH0sXG5cbiAgICAgIGFkZE92ZXJsYXk6IG1ldGhvZE9wKGZ1bmN0aW9uKHNwZWMsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIG1vZGUgPSBzcGVjLnRva2VuID8gc3BlYyA6IENvZGVNaXJyb3IuZ2V0TW9kZSh0aGlzLm9wdGlvbnMsIHNwZWMpO1xuICAgICAgICBpZiAobW9kZS5zdGFydFN0YXRlKSB7IHRocm93IG5ldyBFcnJvcihcIk92ZXJsYXlzIG1heSBub3QgYmUgc3RhdGVmdWwuXCIpIH1cbiAgICAgICAgaW5zZXJ0U29ydGVkKHRoaXMuc3RhdGUub3ZlcmxheXMsXG4gICAgICAgICAgICAgICAgICAgICB7bW9kZTogbW9kZSwgbW9kZVNwZWM6IHNwZWMsIG9wYXF1ZTogb3B0aW9ucyAmJiBvcHRpb25zLm9wYXF1ZSxcbiAgICAgICAgICAgICAgICAgICAgICBwcmlvcml0eTogKG9wdGlvbnMgJiYgb3B0aW9ucy5wcmlvcml0eSkgfHwgMH0sXG4gICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAob3ZlcmxheSkgeyByZXR1cm4gb3ZlcmxheS5wcmlvcml0eTsgfSk7XG4gICAgICAgIHRoaXMuc3RhdGUubW9kZUdlbisrO1xuICAgICAgICByZWdDaGFuZ2UodGhpcyk7XG4gICAgICB9KSxcbiAgICAgIHJlbW92ZU92ZXJsYXk6IG1ldGhvZE9wKGZ1bmN0aW9uKHNwZWMpIHtcbiAgICAgICAgdmFyIG92ZXJsYXlzID0gdGhpcy5zdGF0ZS5vdmVybGF5cztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvdmVybGF5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIHZhciBjdXIgPSBvdmVybGF5c1tpXS5tb2RlU3BlYztcbiAgICAgICAgICBpZiAoY3VyID09IHNwZWMgfHwgdHlwZW9mIHNwZWMgPT0gXCJzdHJpbmdcIiAmJiBjdXIubmFtZSA9PSBzcGVjKSB7XG4gICAgICAgICAgICBvdmVybGF5cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLm1vZGVHZW4rKztcbiAgICAgICAgICAgIHJlZ0NoYW5nZSh0aGlzKTtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSksXG5cbiAgICAgIGluZGVudExpbmU6IG1ldGhvZE9wKGZ1bmN0aW9uKG4sIGRpciwgYWdncmVzc2l2ZSkge1xuICAgICAgICBpZiAodHlwZW9mIGRpciAhPSBcInN0cmluZ1wiICYmIHR5cGVvZiBkaXIgIT0gXCJudW1iZXJcIikge1xuICAgICAgICAgIGlmIChkaXIgPT0gbnVsbCkgeyBkaXIgPSB0aGlzLm9wdGlvbnMuc21hcnRJbmRlbnQgPyBcInNtYXJ0XCIgOiBcInByZXZcIjsgfVxuICAgICAgICAgIGVsc2UgeyBkaXIgPSBkaXIgPyBcImFkZFwiIDogXCJzdWJ0cmFjdFwiOyB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTGluZSh0aGlzLmRvYywgbikpIHsgaW5kZW50TGluZSh0aGlzLCBuLCBkaXIsIGFnZ3Jlc3NpdmUpOyB9XG4gICAgICB9KSxcbiAgICAgIGluZGVudFNlbGVjdGlvbjogbWV0aG9kT3AoZnVuY3Rpb24oaG93KSB7XG4gICAgICAgIHZhciByYW5nZXMgPSB0aGlzLmRvYy5zZWwucmFuZ2VzLCBlbmQgPSAtMTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgcmFuZ2UgPSByYW5nZXNbaV07XG4gICAgICAgICAgaWYgKCFyYW5nZS5lbXB0eSgpKSB7XG4gICAgICAgICAgICB2YXIgZnJvbSA9IHJhbmdlLmZyb20oKSwgdG8gPSByYW5nZS50bygpO1xuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gTWF0aC5tYXgoZW5kLCBmcm9tLmxpbmUpO1xuICAgICAgICAgICAgZW5kID0gTWF0aC5taW4odGhpcy5sYXN0TGluZSgpLCB0by5saW5lIC0gKHRvLmNoID8gMCA6IDEpKSArIDE7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gc3RhcnQ7IGogPCBlbmQ7ICsrailcbiAgICAgICAgICAgICAgeyBpbmRlbnRMaW5lKHRoaXMsIGosIGhvdyk7IH1cbiAgICAgICAgICAgIHZhciBuZXdSYW5nZXMgPSB0aGlzLmRvYy5zZWwucmFuZ2VzO1xuICAgICAgICAgICAgaWYgKGZyb20uY2ggPT0gMCAmJiByYW5nZXMubGVuZ3RoID09IG5ld1Jhbmdlcy5sZW5ndGggJiYgbmV3UmFuZ2VzW2ldLmZyb20oKS5jaCA+IDApXG4gICAgICAgICAgICAgIHsgcmVwbGFjZU9uZVNlbGVjdGlvbih0aGlzLmRvYywgaSwgbmV3IFJhbmdlKGZyb20sIG5ld1Jhbmdlc1tpXS50bygpKSwgc2VsX2RvbnRTY3JvbGwpOyB9XG4gICAgICAgICAgfSBlbHNlIGlmIChyYW5nZS5oZWFkLmxpbmUgPiBlbmQpIHtcbiAgICAgICAgICAgIGluZGVudExpbmUodGhpcywgcmFuZ2UuaGVhZC5saW5lLCBob3csIHRydWUpO1xuICAgICAgICAgICAgZW5kID0gcmFuZ2UuaGVhZC5saW5lO1xuICAgICAgICAgICAgaWYgKGkgPT0gdGhpcy5kb2Muc2VsLnByaW1JbmRleCkgeyBlbnN1cmVDdXJzb3JWaXNpYmxlKHRoaXMpOyB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KSxcblxuICAgICAgLy8gRmV0Y2ggdGhlIHBhcnNlciB0b2tlbiBmb3IgYSBnaXZlbiBjaGFyYWN0ZXIuIFVzZWZ1bCBmb3IgaGFja3NcbiAgICAgIC8vIHRoYXQgd2FudCB0byBpbnNwZWN0IHRoZSBtb2RlIHN0YXRlIChzYXksIGZvciBjb21wbGV0aW9uKS5cbiAgICAgIGdldFRva2VuQXQ6IGZ1bmN0aW9uKHBvcywgcHJlY2lzZSkge1xuICAgICAgICByZXR1cm4gdGFrZVRva2VuKHRoaXMsIHBvcywgcHJlY2lzZSlcbiAgICAgIH0sXG5cbiAgICAgIGdldExpbmVUb2tlbnM6IGZ1bmN0aW9uKGxpbmUsIHByZWNpc2UpIHtcbiAgICAgICAgcmV0dXJuIHRha2VUb2tlbih0aGlzLCBQb3MobGluZSksIHByZWNpc2UsIHRydWUpXG4gICAgICB9LFxuXG4gICAgICBnZXRUb2tlblR5cGVBdDogZnVuY3Rpb24ocG9zKSB7XG4gICAgICAgIHBvcyA9IGNsaXBQb3ModGhpcy5kb2MsIHBvcyk7XG4gICAgICAgIHZhciBzdHlsZXMgPSBnZXRMaW5lU3R5bGVzKHRoaXMsIGdldExpbmUodGhpcy5kb2MsIHBvcy5saW5lKSk7XG4gICAgICAgIHZhciBiZWZvcmUgPSAwLCBhZnRlciA9IChzdHlsZXMubGVuZ3RoIC0gMSkgLyAyLCBjaCA9IHBvcy5jaDtcbiAgICAgICAgdmFyIHR5cGU7XG4gICAgICAgIGlmIChjaCA9PSAwKSB7IHR5cGUgPSBzdHlsZXNbMl07IH1cbiAgICAgICAgZWxzZSB7IGZvciAoOzspIHtcbiAgICAgICAgICB2YXIgbWlkID0gKGJlZm9yZSArIGFmdGVyKSA+PiAxO1xuICAgICAgICAgIGlmICgobWlkID8gc3R5bGVzW21pZCAqIDIgLSAxXSA6IDApID49IGNoKSB7IGFmdGVyID0gbWlkOyB9XG4gICAgICAgICAgZWxzZSBpZiAoc3R5bGVzW21pZCAqIDIgKyAxXSA8IGNoKSB7IGJlZm9yZSA9IG1pZCArIDE7IH1cbiAgICAgICAgICBlbHNlIHsgdHlwZSA9IHN0eWxlc1ttaWQgKiAyICsgMl07IGJyZWFrIH1cbiAgICAgICAgfSB9XG4gICAgICAgIHZhciBjdXQgPSB0eXBlID8gdHlwZS5pbmRleE9mKFwib3ZlcmxheSBcIikgOiAtMTtcbiAgICAgICAgcmV0dXJuIGN1dCA8IDAgPyB0eXBlIDogY3V0ID09IDAgPyBudWxsIDogdHlwZS5zbGljZSgwLCBjdXQgLSAxKVxuICAgICAgfSxcblxuICAgICAgZ2V0TW9kZUF0OiBmdW5jdGlvbihwb3MpIHtcbiAgICAgICAgdmFyIG1vZGUgPSB0aGlzLmRvYy5tb2RlO1xuICAgICAgICBpZiAoIW1vZGUuaW5uZXJNb2RlKSB7IHJldHVybiBtb2RlIH1cbiAgICAgICAgcmV0dXJuIENvZGVNaXJyb3IuaW5uZXJNb2RlKG1vZGUsIHRoaXMuZ2V0VG9rZW5BdChwb3MpLnN0YXRlKS5tb2RlXG4gICAgICB9LFxuXG4gICAgICBnZXRIZWxwZXI6IGZ1bmN0aW9uKHBvcywgdHlwZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRIZWxwZXJzKHBvcywgdHlwZSlbMF1cbiAgICAgIH0sXG5cbiAgICAgIGdldEhlbHBlcnM6IGZ1bmN0aW9uKHBvcywgdHlwZSkge1xuICAgICAgICB2YXIgZm91bmQgPSBbXTtcbiAgICAgICAgaWYgKCFoZWxwZXJzLmhhc093blByb3BlcnR5KHR5cGUpKSB7IHJldHVybiBmb3VuZCB9XG4gICAgICAgIHZhciBoZWxwID0gaGVscGVyc1t0eXBlXSwgbW9kZSA9IHRoaXMuZ2V0TW9kZUF0KHBvcyk7XG4gICAgICAgIGlmICh0eXBlb2YgbW9kZVt0eXBlXSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgaWYgKGhlbHBbbW9kZVt0eXBlXV0pIHsgZm91bmQucHVzaChoZWxwW21vZGVbdHlwZV1dKTsgfVxuICAgICAgICB9IGVsc2UgaWYgKG1vZGVbdHlwZV0pIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1vZGVbdHlwZV0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB2YWwgPSBoZWxwW21vZGVbdHlwZV1baV1dO1xuICAgICAgICAgICAgaWYgKHZhbCkgeyBmb3VuZC5wdXNoKHZhbCk7IH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobW9kZS5oZWxwZXJUeXBlICYmIGhlbHBbbW9kZS5oZWxwZXJUeXBlXSkge1xuICAgICAgICAgIGZvdW5kLnB1c2goaGVscFttb2RlLmhlbHBlclR5cGVdKTtcbiAgICAgICAgfSBlbHNlIGlmIChoZWxwW21vZGUubmFtZV0pIHtcbiAgICAgICAgICBmb3VuZC5wdXNoKGhlbHBbbW9kZS5uYW1lXSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgaGVscC5fZ2xvYmFsLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgICAgICB2YXIgY3VyID0gaGVscC5fZ2xvYmFsW2kkMV07XG4gICAgICAgICAgaWYgKGN1ci5wcmVkKG1vZGUsIHRoaXMpICYmIGluZGV4T2YoZm91bmQsIGN1ci52YWwpID09IC0xKVxuICAgICAgICAgICAgeyBmb3VuZC5wdXNoKGN1ci52YWwpOyB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvdW5kXG4gICAgICB9LFxuXG4gICAgICBnZXRTdGF0ZUFmdGVyOiBmdW5jdGlvbihsaW5lLCBwcmVjaXNlKSB7XG4gICAgICAgIHZhciBkb2MgPSB0aGlzLmRvYztcbiAgICAgICAgbGluZSA9IGNsaXBMaW5lKGRvYywgbGluZSA9PSBudWxsID8gZG9jLmZpcnN0ICsgZG9jLnNpemUgLSAxOiBsaW5lKTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHRCZWZvcmUodGhpcywgbGluZSArIDEsIHByZWNpc2UpLnN0YXRlXG4gICAgICB9LFxuXG4gICAgICBjdXJzb3JDb29yZHM6IGZ1bmN0aW9uKHN0YXJ0LCBtb2RlKSB7XG4gICAgICAgIHZhciBwb3MsIHJhbmdlID0gdGhpcy5kb2Muc2VsLnByaW1hcnkoKTtcbiAgICAgICAgaWYgKHN0YXJ0ID09IG51bGwpIHsgcG9zID0gcmFuZ2UuaGVhZDsgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygc3RhcnQgPT0gXCJvYmplY3RcIikgeyBwb3MgPSBjbGlwUG9zKHRoaXMuZG9jLCBzdGFydCk7IH1cbiAgICAgICAgZWxzZSB7IHBvcyA9IHN0YXJ0ID8gcmFuZ2UuZnJvbSgpIDogcmFuZ2UudG8oKTsgfVxuICAgICAgICByZXR1cm4gY3Vyc29yQ29vcmRzKHRoaXMsIHBvcywgbW9kZSB8fCBcInBhZ2VcIilcbiAgICAgIH0sXG5cbiAgICAgIGNoYXJDb29yZHM6IGZ1bmN0aW9uKHBvcywgbW9kZSkge1xuICAgICAgICByZXR1cm4gY2hhckNvb3Jkcyh0aGlzLCBjbGlwUG9zKHRoaXMuZG9jLCBwb3MpLCBtb2RlIHx8IFwicGFnZVwiKVxuICAgICAgfSxcblxuICAgICAgY29vcmRzQ2hhcjogZnVuY3Rpb24oY29vcmRzLCBtb2RlKSB7XG4gICAgICAgIGNvb3JkcyA9IGZyb21Db29yZFN5c3RlbSh0aGlzLCBjb29yZHMsIG1vZGUgfHwgXCJwYWdlXCIpO1xuICAgICAgICByZXR1cm4gY29vcmRzQ2hhcih0aGlzLCBjb29yZHMubGVmdCwgY29vcmRzLnRvcClcbiAgICAgIH0sXG5cbiAgICAgIGxpbmVBdEhlaWdodDogZnVuY3Rpb24oaGVpZ2h0LCBtb2RlKSB7XG4gICAgICAgIGhlaWdodCA9IGZyb21Db29yZFN5c3RlbSh0aGlzLCB7dG9wOiBoZWlnaHQsIGxlZnQ6IDB9LCBtb2RlIHx8IFwicGFnZVwiKS50b3A7XG4gICAgICAgIHJldHVybiBsaW5lQXRIZWlnaHQodGhpcy5kb2MsIGhlaWdodCArIHRoaXMuZGlzcGxheS52aWV3T2Zmc2V0KVxuICAgICAgfSxcbiAgICAgIGhlaWdodEF0TGluZTogZnVuY3Rpb24obGluZSwgbW9kZSwgaW5jbHVkZVdpZGdldHMpIHtcbiAgICAgICAgdmFyIGVuZCA9IGZhbHNlLCBsaW5lT2JqO1xuICAgICAgICBpZiAodHlwZW9mIGxpbmUgPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgIHZhciBsYXN0ID0gdGhpcy5kb2MuZmlyc3QgKyB0aGlzLmRvYy5zaXplIC0gMTtcbiAgICAgICAgICBpZiAobGluZSA8IHRoaXMuZG9jLmZpcnN0KSB7IGxpbmUgPSB0aGlzLmRvYy5maXJzdDsgfVxuICAgICAgICAgIGVsc2UgaWYgKGxpbmUgPiBsYXN0KSB7IGxpbmUgPSBsYXN0OyBlbmQgPSB0cnVlOyB9XG4gICAgICAgICAgbGluZU9iaiA9IGdldExpbmUodGhpcy5kb2MsIGxpbmUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxpbmVPYmogPSBsaW5lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnRvQ29vcmRTeXN0ZW0odGhpcywgbGluZU9iaiwge3RvcDogMCwgbGVmdDogMH0sIG1vZGUgfHwgXCJwYWdlXCIsIGluY2x1ZGVXaWRnZXRzIHx8IGVuZCkudG9wICtcbiAgICAgICAgICAoZW5kID8gdGhpcy5kb2MuaGVpZ2h0IC0gaGVpZ2h0QXRMaW5lKGxpbmVPYmopIDogMClcbiAgICAgIH0sXG5cbiAgICAgIGRlZmF1bHRUZXh0SGVpZ2h0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRleHRIZWlnaHQodGhpcy5kaXNwbGF5KSB9LFxuICAgICAgZGVmYXVsdENoYXJXaWR0aDogZnVuY3Rpb24oKSB7IHJldHVybiBjaGFyV2lkdGgodGhpcy5kaXNwbGF5KSB9LFxuXG4gICAgICBnZXRWaWV3cG9ydDogZnVuY3Rpb24oKSB7IHJldHVybiB7ZnJvbTogdGhpcy5kaXNwbGF5LnZpZXdGcm9tLCB0bzogdGhpcy5kaXNwbGF5LnZpZXdUb319LFxuXG4gICAgICBhZGRXaWRnZXQ6IGZ1bmN0aW9uKHBvcywgbm9kZSwgc2Nyb2xsLCB2ZXJ0LCBob3Jpeikge1xuICAgICAgICB2YXIgZGlzcGxheSA9IHRoaXMuZGlzcGxheTtcbiAgICAgICAgcG9zID0gY3Vyc29yQ29vcmRzKHRoaXMsIGNsaXBQb3ModGhpcy5kb2MsIHBvcykpO1xuICAgICAgICB2YXIgdG9wID0gcG9zLmJvdHRvbSwgbGVmdCA9IHBvcy5sZWZ0O1xuICAgICAgICBub2RlLnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShcImNtLWlnbm9yZS1ldmVudHNcIiwgXCJ0cnVlXCIpO1xuICAgICAgICB0aGlzLmRpc3BsYXkuaW5wdXQuc2V0VW5lZGl0YWJsZShub2RlKTtcbiAgICAgICAgZGlzcGxheS5zaXplci5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgICAgaWYgKHZlcnQgPT0gXCJvdmVyXCIpIHtcbiAgICAgICAgICB0b3AgPSBwb3MudG9wO1xuICAgICAgICB9IGVsc2UgaWYgKHZlcnQgPT0gXCJhYm92ZVwiIHx8IHZlcnQgPT0gXCJuZWFyXCIpIHtcbiAgICAgICAgICB2YXIgdnNwYWNlID0gTWF0aC5tYXgoZGlzcGxheS53cmFwcGVyLmNsaWVudEhlaWdodCwgdGhpcy5kb2MuaGVpZ2h0KSxcbiAgICAgICAgICBoc3BhY2UgPSBNYXRoLm1heChkaXNwbGF5LnNpemVyLmNsaWVudFdpZHRoLCBkaXNwbGF5LmxpbmVTcGFjZS5jbGllbnRXaWR0aCk7XG4gICAgICAgICAgLy8gRGVmYXVsdCB0byBwb3NpdGlvbmluZyBhYm92ZSAoaWYgc3BlY2lmaWVkIGFuZCBwb3NzaWJsZSk7IG90aGVyd2lzZSBkZWZhdWx0IHRvIHBvc2l0aW9uaW5nIGJlbG93XG4gICAgICAgICAgaWYgKCh2ZXJ0ID09ICdhYm92ZScgfHwgcG9zLmJvdHRvbSArIG5vZGUub2Zmc2V0SGVpZ2h0ID4gdnNwYWNlKSAmJiBwb3MudG9wID4gbm9kZS5vZmZzZXRIZWlnaHQpXG4gICAgICAgICAgICB7IHRvcCA9IHBvcy50b3AgLSBub2RlLm9mZnNldEhlaWdodDsgfVxuICAgICAgICAgIGVsc2UgaWYgKHBvcy5ib3R0b20gKyBub2RlLm9mZnNldEhlaWdodCA8PSB2c3BhY2UpXG4gICAgICAgICAgICB7IHRvcCA9IHBvcy5ib3R0b207IH1cbiAgICAgICAgICBpZiAobGVmdCArIG5vZGUub2Zmc2V0V2lkdGggPiBoc3BhY2UpXG4gICAgICAgICAgICB7IGxlZnQgPSBoc3BhY2UgLSBub2RlLm9mZnNldFdpZHRoOyB9XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5zdHlsZS50b3AgPSB0b3AgKyBcInB4XCI7XG4gICAgICAgIG5vZGUuc3R5bGUubGVmdCA9IG5vZGUuc3R5bGUucmlnaHQgPSBcIlwiO1xuICAgICAgICBpZiAoaG9yaXogPT0gXCJyaWdodFwiKSB7XG4gICAgICAgICAgbGVmdCA9IGRpc3BsYXkuc2l6ZXIuY2xpZW50V2lkdGggLSBub2RlLm9mZnNldFdpZHRoO1xuICAgICAgICAgIG5vZGUuc3R5bGUucmlnaHQgPSBcIjBweFwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChob3JpeiA9PSBcImxlZnRcIikgeyBsZWZ0ID0gMDsgfVxuICAgICAgICAgIGVsc2UgaWYgKGhvcml6ID09IFwibWlkZGxlXCIpIHsgbGVmdCA9IChkaXNwbGF5LnNpemVyLmNsaWVudFdpZHRoIC0gbm9kZS5vZmZzZXRXaWR0aCkgLyAyOyB9XG4gICAgICAgICAgbm9kZS5zdHlsZS5sZWZ0ID0gbGVmdCArIFwicHhcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2Nyb2xsKVxuICAgICAgICAgIHsgc2Nyb2xsSW50b1ZpZXcodGhpcywge2xlZnQ6IGxlZnQsIHRvcDogdG9wLCByaWdodDogbGVmdCArIG5vZGUub2Zmc2V0V2lkdGgsIGJvdHRvbTogdG9wICsgbm9kZS5vZmZzZXRIZWlnaHR9KTsgfVxuICAgICAgfSxcblxuICAgICAgdHJpZ2dlck9uS2V5RG93bjogbWV0aG9kT3Aob25LZXlEb3duKSxcbiAgICAgIHRyaWdnZXJPbktleVByZXNzOiBtZXRob2RPcChvbktleVByZXNzKSxcbiAgICAgIHRyaWdnZXJPbktleVVwOiBvbktleVVwLFxuICAgICAgdHJpZ2dlck9uTW91c2VEb3duOiBtZXRob2RPcChvbk1vdXNlRG93biksXG5cbiAgICAgIGV4ZWNDb21tYW5kOiBmdW5jdGlvbihjbWQpIHtcbiAgICAgICAgaWYgKGNvbW1hbmRzLmhhc093blByb3BlcnR5KGNtZCkpXG4gICAgICAgICAgeyByZXR1cm4gY29tbWFuZHNbY21kXS5jYWxsKG51bGwsIHRoaXMpIH1cbiAgICAgIH0sXG5cbiAgICAgIHRyaWdnZXJFbGVjdHJpYzogbWV0aG9kT3AoZnVuY3Rpb24odGV4dCkgeyB0cmlnZ2VyRWxlY3RyaWModGhpcywgdGV4dCk7IH0pLFxuXG4gICAgICBmaW5kUG9zSDogZnVuY3Rpb24oZnJvbSwgYW1vdW50LCB1bml0LCB2aXN1YWxseSkge1xuICAgICAgICB2YXIgZGlyID0gMTtcbiAgICAgICAgaWYgKGFtb3VudCA8IDApIHsgZGlyID0gLTE7IGFtb3VudCA9IC1hbW91bnQ7IH1cbiAgICAgICAgdmFyIGN1ciA9IGNsaXBQb3ModGhpcy5kb2MsIGZyb20pO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFtb3VudDsgKytpKSB7XG4gICAgICAgICAgY3VyID0gZmluZFBvc0godGhpcy5kb2MsIGN1ciwgZGlyLCB1bml0LCB2aXN1YWxseSk7XG4gICAgICAgICAgaWYgKGN1ci5oaXRTaWRlKSB7IGJyZWFrIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3VyXG4gICAgICB9LFxuXG4gICAgICBtb3ZlSDogbWV0aG9kT3AoZnVuY3Rpb24oZGlyLCB1bml0KSB7XG4gICAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgICAgIHRoaXMuZXh0ZW5kU2VsZWN0aW9uc0J5KGZ1bmN0aW9uIChyYW5nZSkge1xuICAgICAgICAgIGlmICh0aGlzJDEuZGlzcGxheS5zaGlmdCB8fCB0aGlzJDEuZG9jLmV4dGVuZCB8fCByYW5nZS5lbXB0eSgpKVxuICAgICAgICAgICAgeyByZXR1cm4gZmluZFBvc0godGhpcyQxLmRvYywgcmFuZ2UuaGVhZCwgZGlyLCB1bml0LCB0aGlzJDEub3B0aW9ucy5ydGxNb3ZlVmlzdWFsbHkpIH1cbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7IHJldHVybiBkaXIgPCAwID8gcmFuZ2UuZnJvbSgpIDogcmFuZ2UudG8oKSB9XG4gICAgICAgIH0sIHNlbF9tb3ZlKTtcbiAgICAgIH0pLFxuXG4gICAgICBkZWxldGVIOiBtZXRob2RPcChmdW5jdGlvbihkaXIsIHVuaXQpIHtcbiAgICAgICAgdmFyIHNlbCA9IHRoaXMuZG9jLnNlbCwgZG9jID0gdGhpcy5kb2M7XG4gICAgICAgIGlmIChzZWwuc29tZXRoaW5nU2VsZWN0ZWQoKSlcbiAgICAgICAgICB7IGRvYy5yZXBsYWNlU2VsZWN0aW9uKFwiXCIsIG51bGwsIFwiK2RlbGV0ZVwiKTsgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgeyBkZWxldGVOZWFyU2VsZWN0aW9uKHRoaXMsIGZ1bmN0aW9uIChyYW5nZSkge1xuICAgICAgICAgICAgdmFyIG90aGVyID0gZmluZFBvc0goZG9jLCByYW5nZS5oZWFkLCBkaXIsIHVuaXQsIGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybiBkaXIgPCAwID8ge2Zyb206IG90aGVyLCB0bzogcmFuZ2UuaGVhZH0gOiB7ZnJvbTogcmFuZ2UuaGVhZCwgdG86IG90aGVyfVxuICAgICAgICAgIH0pOyB9XG4gICAgICB9KSxcblxuICAgICAgZmluZFBvc1Y6IGZ1bmN0aW9uKGZyb20sIGFtb3VudCwgdW5pdCwgZ29hbENvbHVtbikge1xuICAgICAgICB2YXIgZGlyID0gMSwgeCA9IGdvYWxDb2x1bW47XG4gICAgICAgIGlmIChhbW91bnQgPCAwKSB7IGRpciA9IC0xOyBhbW91bnQgPSAtYW1vdW50OyB9XG4gICAgICAgIHZhciBjdXIgPSBjbGlwUG9zKHRoaXMuZG9jLCBmcm9tKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbW91bnQ7ICsraSkge1xuICAgICAgICAgIHZhciBjb29yZHMgPSBjdXJzb3JDb29yZHModGhpcywgY3VyLCBcImRpdlwiKTtcbiAgICAgICAgICBpZiAoeCA9PSBudWxsKSB7IHggPSBjb29yZHMubGVmdDsgfVxuICAgICAgICAgIGVsc2UgeyBjb29yZHMubGVmdCA9IHg7IH1cbiAgICAgICAgICBjdXIgPSBmaW5kUG9zVih0aGlzLCBjb29yZHMsIGRpciwgdW5pdCk7XG4gICAgICAgICAgaWYgKGN1ci5oaXRTaWRlKSB7IGJyZWFrIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3VyXG4gICAgICB9LFxuXG4gICAgICBtb3ZlVjogbWV0aG9kT3AoZnVuY3Rpb24oZGlyLCB1bml0KSB7XG4gICAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgICAgIHZhciBkb2MgPSB0aGlzLmRvYywgZ29hbHMgPSBbXTtcbiAgICAgICAgdmFyIGNvbGxhcHNlID0gIXRoaXMuZGlzcGxheS5zaGlmdCAmJiAhZG9jLmV4dGVuZCAmJiBkb2Muc2VsLnNvbWV0aGluZ1NlbGVjdGVkKCk7XG4gICAgICAgIGRvYy5leHRlbmRTZWxlY3Rpb25zQnkoZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICAgICAgaWYgKGNvbGxhcHNlKVxuICAgICAgICAgICAgeyByZXR1cm4gZGlyIDwgMCA/IHJhbmdlLmZyb20oKSA6IHJhbmdlLnRvKCkgfVxuICAgICAgICAgIHZhciBoZWFkUG9zID0gY3Vyc29yQ29vcmRzKHRoaXMkMSwgcmFuZ2UuaGVhZCwgXCJkaXZcIik7XG4gICAgICAgICAgaWYgKHJhbmdlLmdvYWxDb2x1bW4gIT0gbnVsbCkgeyBoZWFkUG9zLmxlZnQgPSByYW5nZS5nb2FsQ29sdW1uOyB9XG4gICAgICAgICAgZ29hbHMucHVzaChoZWFkUG9zLmxlZnQpO1xuICAgICAgICAgIHZhciBwb3MgPSBmaW5kUG9zVih0aGlzJDEsIGhlYWRQb3MsIGRpciwgdW5pdCk7XG4gICAgICAgICAgaWYgKHVuaXQgPT0gXCJwYWdlXCIgJiYgcmFuZ2UgPT0gZG9jLnNlbC5wcmltYXJ5KCkpXG4gICAgICAgICAgICB7IGFkZFRvU2Nyb2xsVG9wKHRoaXMkMSwgY2hhckNvb3Jkcyh0aGlzJDEsIHBvcywgXCJkaXZcIikudG9wIC0gaGVhZFBvcy50b3ApOyB9XG4gICAgICAgICAgcmV0dXJuIHBvc1xuICAgICAgICB9LCBzZWxfbW92ZSk7XG4gICAgICAgIGlmIChnb2Fscy5sZW5ndGgpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBkb2Muc2VsLnJhbmdlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICB7IGRvYy5zZWwucmFuZ2VzW2ldLmdvYWxDb2x1bW4gPSBnb2Fsc1tpXTsgfSB9XG4gICAgICB9KSxcblxuICAgICAgLy8gRmluZCB0aGUgd29yZCBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24gKGFzIHJldHVybmVkIGJ5IGNvb3Jkc0NoYXIpLlxuICAgICAgZmluZFdvcmRBdDogZnVuY3Rpb24ocG9zKSB7XG4gICAgICAgIHZhciBkb2MgPSB0aGlzLmRvYywgbGluZSA9IGdldExpbmUoZG9jLCBwb3MubGluZSkudGV4dDtcbiAgICAgICAgdmFyIHN0YXJ0ID0gcG9zLmNoLCBlbmQgPSBwb3MuY2g7XG4gICAgICAgIGlmIChsaW5lKSB7XG4gICAgICAgICAgdmFyIGhlbHBlciA9IHRoaXMuZ2V0SGVscGVyKHBvcywgXCJ3b3JkQ2hhcnNcIik7XG4gICAgICAgICAgaWYgKChwb3Muc3RpY2t5ID09IFwiYmVmb3JlXCIgfHwgZW5kID09IGxpbmUubGVuZ3RoKSAmJiBzdGFydCkgeyAtLXN0YXJ0OyB9IGVsc2UgeyArK2VuZDsgfVxuICAgICAgICAgIHZhciBzdGFydENoYXIgPSBsaW5lLmNoYXJBdChzdGFydCk7XG4gICAgICAgICAgdmFyIGNoZWNrID0gaXNXb3JkQ2hhcihzdGFydENoYXIsIGhlbHBlcilcbiAgICAgICAgICAgID8gZnVuY3Rpb24gKGNoKSB7IHJldHVybiBpc1dvcmRDaGFyKGNoLCBoZWxwZXIpOyB9XG4gICAgICAgICAgICA6IC9cXHMvLnRlc3Qoc3RhcnRDaGFyKSA/IGZ1bmN0aW9uIChjaCkgeyByZXR1cm4gL1xccy8udGVzdChjaCk7IH1cbiAgICAgICAgICAgIDogZnVuY3Rpb24gKGNoKSB7IHJldHVybiAoIS9cXHMvLnRlc3QoY2gpICYmICFpc1dvcmRDaGFyKGNoKSk7IH07XG4gICAgICAgICAgd2hpbGUgKHN0YXJ0ID4gMCAmJiBjaGVjayhsaW5lLmNoYXJBdChzdGFydCAtIDEpKSkgeyAtLXN0YXJ0OyB9XG4gICAgICAgICAgd2hpbGUgKGVuZCA8IGxpbmUubGVuZ3RoICYmIGNoZWNrKGxpbmUuY2hhckF0KGVuZCkpKSB7ICsrZW5kOyB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBSYW5nZShQb3MocG9zLmxpbmUsIHN0YXJ0KSwgUG9zKHBvcy5saW5lLCBlbmQpKVxuICAgICAgfSxcblxuICAgICAgdG9nZ2xlT3ZlcndyaXRlOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCAmJiB2YWx1ZSA9PSB0aGlzLnN0YXRlLm92ZXJ3cml0ZSkgeyByZXR1cm4gfVxuICAgICAgICBpZiAodGhpcy5zdGF0ZS5vdmVyd3JpdGUgPSAhdGhpcy5zdGF0ZS5vdmVyd3JpdGUpXG4gICAgICAgICAgeyBhZGRDbGFzcyh0aGlzLmRpc3BsYXkuY3Vyc29yRGl2LCBcIkNvZGVNaXJyb3Itb3ZlcndyaXRlXCIpOyB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB7IHJtQ2xhc3ModGhpcy5kaXNwbGF5LmN1cnNvckRpdiwgXCJDb2RlTWlycm9yLW92ZXJ3cml0ZVwiKTsgfVxuXG4gICAgICAgIHNpZ25hbCh0aGlzLCBcIm92ZXJ3cml0ZVRvZ2dsZVwiLCB0aGlzLCB0aGlzLnN0YXRlLm92ZXJ3cml0ZSk7XG4gICAgICB9LFxuICAgICAgaGFzRm9jdXM6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5kaXNwbGF5LmlucHV0LmdldEZpZWxkKCkgPT0gYWN0aXZlRWx0KCkgfSxcbiAgICAgIGlzUmVhZE9ubHk6IGZ1bmN0aW9uKCkgeyByZXR1cm4gISEodGhpcy5vcHRpb25zLnJlYWRPbmx5IHx8IHRoaXMuZG9jLmNhbnRFZGl0KSB9LFxuXG4gICAgICBzY3JvbGxUbzogbWV0aG9kT3AoZnVuY3Rpb24gKHgsIHkpIHsgc2Nyb2xsVG9Db29yZHModGhpcywgeCwgeSk7IH0pLFxuICAgICAgZ2V0U2Nyb2xsSW5mbzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzY3JvbGxlciA9IHRoaXMuZGlzcGxheS5zY3JvbGxlcjtcbiAgICAgICAgcmV0dXJuIHtsZWZ0OiBzY3JvbGxlci5zY3JvbGxMZWZ0LCB0b3A6IHNjcm9sbGVyLnNjcm9sbFRvcCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHNjcm9sbGVyLnNjcm9sbEhlaWdodCAtIHNjcm9sbEdhcCh0aGlzKSAtIHRoaXMuZGlzcGxheS5iYXJIZWlnaHQsXG4gICAgICAgICAgICAgICAgd2lkdGg6IHNjcm9sbGVyLnNjcm9sbFdpZHRoIC0gc2Nyb2xsR2FwKHRoaXMpIC0gdGhpcy5kaXNwbGF5LmJhcldpZHRoLFxuICAgICAgICAgICAgICAgIGNsaWVudEhlaWdodDogZGlzcGxheUhlaWdodCh0aGlzKSwgY2xpZW50V2lkdGg6IGRpc3BsYXlXaWR0aCh0aGlzKX1cbiAgICAgIH0sXG5cbiAgICAgIHNjcm9sbEludG9WaWV3OiBtZXRob2RPcChmdW5jdGlvbihyYW5nZSwgbWFyZ2luKSB7XG4gICAgICAgIGlmIChyYW5nZSA9PSBudWxsKSB7XG4gICAgICAgICAgcmFuZ2UgPSB7ZnJvbTogdGhpcy5kb2Muc2VsLnByaW1hcnkoKS5oZWFkLCB0bzogbnVsbH07XG4gICAgICAgICAgaWYgKG1hcmdpbiA9PSBudWxsKSB7IG1hcmdpbiA9IHRoaXMub3B0aW9ucy5jdXJzb3JTY3JvbGxNYXJnaW47IH1cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcmFuZ2UgPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgIHJhbmdlID0ge2Zyb206IFBvcyhyYW5nZSwgMCksIHRvOiBudWxsfTtcbiAgICAgICAgfSBlbHNlIGlmIChyYW5nZS5mcm9tID09IG51bGwpIHtcbiAgICAgICAgICByYW5nZSA9IHtmcm9tOiByYW5nZSwgdG86IG51bGx9O1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmFuZ2UudG8pIHsgcmFuZ2UudG8gPSByYW5nZS5mcm9tOyB9XG4gICAgICAgIHJhbmdlLm1hcmdpbiA9IG1hcmdpbiB8fCAwO1xuXG4gICAgICAgIGlmIChyYW5nZS5mcm9tLmxpbmUgIT0gbnVsbCkge1xuICAgICAgICAgIHNjcm9sbFRvUmFuZ2UodGhpcywgcmFuZ2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNjcm9sbFRvQ29vcmRzUmFuZ2UodGhpcywgcmFuZ2UuZnJvbSwgcmFuZ2UudG8sIHJhbmdlLm1hcmdpbik7XG4gICAgICAgIH1cbiAgICAgIH0pLFxuXG4gICAgICBzZXRTaXplOiBtZXRob2RPcChmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgICAgIHZhciBpbnRlcnByZXQgPSBmdW5jdGlvbiAodmFsKSB7IHJldHVybiB0eXBlb2YgdmFsID09IFwibnVtYmVyXCIgfHwgL15cXGQrJC8udGVzdChTdHJpbmcodmFsKSkgPyB2YWwgKyBcInB4XCIgOiB2YWw7IH07XG4gICAgICAgIGlmICh3aWR0aCAhPSBudWxsKSB7IHRoaXMuZGlzcGxheS53cmFwcGVyLnN0eWxlLndpZHRoID0gaW50ZXJwcmV0KHdpZHRoKTsgfVxuICAgICAgICBpZiAoaGVpZ2h0ICE9IG51bGwpIHsgdGhpcy5kaXNwbGF5LndyYXBwZXIuc3R5bGUuaGVpZ2h0ID0gaW50ZXJwcmV0KGhlaWdodCk7IH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5saW5lV3JhcHBpbmcpIHsgY2xlYXJMaW5lTWVhc3VyZW1lbnRDYWNoZSh0aGlzKTsgfVxuICAgICAgICB2YXIgbGluZU5vID0gdGhpcy5kaXNwbGF5LnZpZXdGcm9tO1xuICAgICAgICB0aGlzLmRvYy5pdGVyKGxpbmVObywgdGhpcy5kaXNwbGF5LnZpZXdUbywgZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgICBpZiAobGluZS53aWRnZXRzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgbGluZS53aWRnZXRzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgeyBpZiAobGluZS53aWRnZXRzW2ldLm5vSFNjcm9sbCkgeyByZWdMaW5lQ2hhbmdlKHRoaXMkMSwgbGluZU5vLCBcIndpZGdldFwiKTsgYnJlYWsgfSB9IH1cbiAgICAgICAgICArK2xpbmVObztcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY3VyT3AuZm9yY2VVcGRhdGUgPSB0cnVlO1xuICAgICAgICBzaWduYWwodGhpcywgXCJyZWZyZXNoXCIsIHRoaXMpO1xuICAgICAgfSksXG5cbiAgICAgIG9wZXJhdGlvbjogZnVuY3Rpb24oZil7cmV0dXJuIHJ1bkluT3AodGhpcywgZil9LFxuICAgICAgc3RhcnRPcGVyYXRpb246IGZ1bmN0aW9uKCl7cmV0dXJuIHN0YXJ0T3BlcmF0aW9uKHRoaXMpfSxcbiAgICAgIGVuZE9wZXJhdGlvbjogZnVuY3Rpb24oKXtyZXR1cm4gZW5kT3BlcmF0aW9uKHRoaXMpfSxcblxuICAgICAgcmVmcmVzaDogbWV0aG9kT3AoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBvbGRIZWlnaHQgPSB0aGlzLmRpc3BsYXkuY2FjaGVkVGV4dEhlaWdodDtcbiAgICAgICAgcmVnQ2hhbmdlKHRoaXMpO1xuICAgICAgICB0aGlzLmN1ck9wLmZvcmNlVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgY2xlYXJDYWNoZXModGhpcyk7XG4gICAgICAgIHNjcm9sbFRvQ29vcmRzKHRoaXMsIHRoaXMuZG9jLnNjcm9sbExlZnQsIHRoaXMuZG9jLnNjcm9sbFRvcCk7XG4gICAgICAgIHVwZGF0ZUd1dHRlclNwYWNlKHRoaXMuZGlzcGxheSk7XG4gICAgICAgIGlmIChvbGRIZWlnaHQgPT0gbnVsbCB8fCBNYXRoLmFicyhvbGRIZWlnaHQgLSB0ZXh0SGVpZ2h0KHRoaXMuZGlzcGxheSkpID4gLjUgfHwgdGhpcy5vcHRpb25zLmxpbmVXcmFwcGluZylcbiAgICAgICAgICB7IGVzdGltYXRlTGluZUhlaWdodHModGhpcyk7IH1cbiAgICAgICAgc2lnbmFsKHRoaXMsIFwicmVmcmVzaFwiLCB0aGlzKTtcbiAgICAgIH0pLFxuXG4gICAgICBzd2FwRG9jOiBtZXRob2RPcChmdW5jdGlvbihkb2MpIHtcbiAgICAgICAgdmFyIG9sZCA9IHRoaXMuZG9jO1xuICAgICAgICBvbGQuY20gPSBudWxsO1xuICAgICAgICAvLyBDYW5jZWwgdGhlIGN1cnJlbnQgdGV4dCBzZWxlY3Rpb24gaWYgYW55ICgjNTgyMSlcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuc2VsZWN0aW5nVGV4dCkgeyB0aGlzLnN0YXRlLnNlbGVjdGluZ1RleHQoKTsgfVxuICAgICAgICBhdHRhY2hEb2ModGhpcywgZG9jKTtcbiAgICAgICAgY2xlYXJDYWNoZXModGhpcyk7XG4gICAgICAgIHRoaXMuZGlzcGxheS5pbnB1dC5yZXNldCgpO1xuICAgICAgICBzY3JvbGxUb0Nvb3Jkcyh0aGlzLCBkb2Muc2Nyb2xsTGVmdCwgZG9jLnNjcm9sbFRvcCk7XG4gICAgICAgIHRoaXMuY3VyT3AuZm9yY2VTY3JvbGwgPSB0cnVlO1xuICAgICAgICBzaWduYWxMYXRlcih0aGlzLCBcInN3YXBEb2NcIiwgdGhpcywgb2xkKTtcbiAgICAgICAgcmV0dXJuIG9sZFxuICAgICAgfSksXG5cbiAgICAgIHBocmFzZTogZnVuY3Rpb24ocGhyYXNlVGV4dCkge1xuICAgICAgICB2YXIgcGhyYXNlcyA9IHRoaXMub3B0aW9ucy5waHJhc2VzO1xuICAgICAgICByZXR1cm4gcGhyYXNlcyAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocGhyYXNlcywgcGhyYXNlVGV4dCkgPyBwaHJhc2VzW3BocmFzZVRleHRdIDogcGhyYXNlVGV4dFxuICAgICAgfSxcblxuICAgICAgZ2V0SW5wdXRGaWVsZDogZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kaXNwbGF5LmlucHV0LmdldEZpZWxkKCl9LFxuICAgICAgZ2V0V3JhcHBlckVsZW1lbnQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGlzcGxheS53cmFwcGVyfSxcbiAgICAgIGdldFNjcm9sbGVyRWxlbWVudDogZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kaXNwbGF5LnNjcm9sbGVyfSxcbiAgICAgIGdldEd1dHRlckVsZW1lbnQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGlzcGxheS5ndXR0ZXJzfVxuICAgIH07XG4gICAgZXZlbnRNaXhpbihDb2RlTWlycm9yKTtcblxuICAgIENvZGVNaXJyb3IucmVnaXN0ZXJIZWxwZXIgPSBmdW5jdGlvbih0eXBlLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgaWYgKCFoZWxwZXJzLmhhc093blByb3BlcnR5KHR5cGUpKSB7IGhlbHBlcnNbdHlwZV0gPSBDb2RlTWlycm9yW3R5cGVdID0ge19nbG9iYWw6IFtdfTsgfVxuICAgICAgaGVscGVyc1t0eXBlXVtuYW1lXSA9IHZhbHVlO1xuICAgIH07XG4gICAgQ29kZU1pcnJvci5yZWdpc3Rlckdsb2JhbEhlbHBlciA9IGZ1bmN0aW9uKHR5cGUsIG5hbWUsIHByZWRpY2F0ZSwgdmFsdWUpIHtcbiAgICAgIENvZGVNaXJyb3IucmVnaXN0ZXJIZWxwZXIodHlwZSwgbmFtZSwgdmFsdWUpO1xuICAgICAgaGVscGVyc1t0eXBlXS5fZ2xvYmFsLnB1c2goe3ByZWQ6IHByZWRpY2F0ZSwgdmFsOiB2YWx1ZX0pO1xuICAgIH07XG4gIH1cblxuICAvLyBVc2VkIGZvciBob3Jpem9udGFsIHJlbGF0aXZlIG1vdGlvbi4gRGlyIGlzIC0xIG9yIDEgKGxlZnQgb3JcbiAgLy8gcmlnaHQpLCB1bml0IGNhbiBiZSBcImNvZGVwb2ludFwiLCBcImNoYXJcIiwgXCJjb2x1bW5cIiAobGlrZSBjaGFyLCBidXRcbiAgLy8gZG9lc24ndCBjcm9zcyBsaW5lIGJvdW5kYXJpZXMpLCBcIndvcmRcIiAoYWNyb3NzIG5leHQgd29yZCksIG9yXG4gIC8vIFwiZ3JvdXBcIiAodG8gdGhlIHN0YXJ0IG9mIG5leHQgZ3JvdXAgb2Ygd29yZCBvclxuICAvLyBub24td29yZC1ub24td2hpdGVzcGFjZSBjaGFycykuIFRoZSB2aXN1YWxseSBwYXJhbSBjb250cm9sc1xuICAvLyB3aGV0aGVyLCBpbiByaWdodC10by1sZWZ0IHRleHQsIGRpcmVjdGlvbiAxIG1lYW5zIHRvIG1vdmUgdG93YXJkc1xuICAvLyB0aGUgbmV4dCBpbmRleCBpbiB0aGUgc3RyaW5nLCBvciB0b3dhcmRzIHRoZSBjaGFyYWN0ZXIgdG8gdGhlIHJpZ2h0XG4gIC8vIG9mIHRoZSBjdXJyZW50IHBvc2l0aW9uLiBUaGUgcmVzdWx0aW5nIHBvc2l0aW9uIHdpbGwgaGF2ZSBhXG4gIC8vIGhpdFNpZGU9dHJ1ZSBwcm9wZXJ0eSBpZiBpdCByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIGRvY3VtZW50LlxuICBmdW5jdGlvbiBmaW5kUG9zSChkb2MsIHBvcywgZGlyLCB1bml0LCB2aXN1YWxseSkge1xuICAgIHZhciBvbGRQb3MgPSBwb3M7XG4gICAgdmFyIG9yaWdEaXIgPSBkaXI7XG4gICAgdmFyIGxpbmVPYmogPSBnZXRMaW5lKGRvYywgcG9zLmxpbmUpO1xuICAgIHZhciBsaW5lRGlyID0gdmlzdWFsbHkgJiYgZG9jLmRpcmVjdGlvbiA9PSBcInJ0bFwiID8gLWRpciA6IGRpcjtcbiAgICBmdW5jdGlvbiBmaW5kTmV4dExpbmUoKSB7XG4gICAgICB2YXIgbCA9IHBvcy5saW5lICsgbGluZURpcjtcbiAgICAgIGlmIChsIDwgZG9jLmZpcnN0IHx8IGwgPj0gZG9jLmZpcnN0ICsgZG9jLnNpemUpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICAgIHBvcyA9IG5ldyBQb3MobCwgcG9zLmNoLCBwb3Muc3RpY2t5KTtcbiAgICAgIHJldHVybiBsaW5lT2JqID0gZ2V0TGluZShkb2MsIGwpXG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vdmVPbmNlKGJvdW5kVG9MaW5lKSB7XG4gICAgICB2YXIgbmV4dDtcbiAgICAgIGlmICh1bml0ID09IFwiY29kZXBvaW50XCIpIHtcbiAgICAgICAgdmFyIGNoID0gbGluZU9iai50ZXh0LmNoYXJDb2RlQXQocG9zLmNoICsgKHVuaXQgPiAwID8gMCA6IC0xKSk7XG4gICAgICAgIGlmIChpc05hTihjaCkpIHsgbmV4dCA9IG51bGw7IH1cbiAgICAgICAgZWxzZSB7IG5leHQgPSBuZXcgUG9zKHBvcy5saW5lLCBNYXRoLm1heCgwLCBNYXRoLm1pbihsaW5lT2JqLnRleHQubGVuZ3RoLCBwb3MuY2ggKyBkaXIgKiAoY2ggPj0gMHhEODAwICYmIGNoIDwgMHhEQzAwID8gMiA6IDEpKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLWRpcik7IH1cbiAgICAgIH0gZWxzZSBpZiAodmlzdWFsbHkpIHtcbiAgICAgICAgbmV4dCA9IG1vdmVWaXN1YWxseShkb2MuY20sIGxpbmVPYmosIHBvcywgZGlyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHQgPSBtb3ZlTG9naWNhbGx5KGxpbmVPYmosIHBvcywgZGlyKTtcbiAgICAgIH1cbiAgICAgIGlmIChuZXh0ID09IG51bGwpIHtcbiAgICAgICAgaWYgKCFib3VuZFRvTGluZSAmJiBmaW5kTmV4dExpbmUoKSlcbiAgICAgICAgICB7IHBvcyA9IGVuZE9mTGluZSh2aXN1YWxseSwgZG9jLmNtLCBsaW5lT2JqLCBwb3MubGluZSwgbGluZURpcik7IH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgIHsgcmV0dXJuIGZhbHNlIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBvcyA9IG5leHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIGlmICh1bml0ID09IFwiY2hhclwiIHx8IHVuaXQgPT0gXCJjb2RlcG9pbnRcIikge1xuICAgICAgbW92ZU9uY2UoKTtcbiAgICB9IGVsc2UgaWYgKHVuaXQgPT0gXCJjb2x1bW5cIikge1xuICAgICAgbW92ZU9uY2UodHJ1ZSk7XG4gICAgfSBlbHNlIGlmICh1bml0ID09IFwid29yZFwiIHx8IHVuaXQgPT0gXCJncm91cFwiKSB7XG4gICAgICB2YXIgc2F3VHlwZSA9IG51bGwsIGdyb3VwID0gdW5pdCA9PSBcImdyb3VwXCI7XG4gICAgICB2YXIgaGVscGVyID0gZG9jLmNtICYmIGRvYy5jbS5nZXRIZWxwZXIocG9zLCBcIndvcmRDaGFyc1wiKTtcbiAgICAgIGZvciAodmFyIGZpcnN0ID0gdHJ1ZTs7IGZpcnN0ID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKGRpciA8IDAgJiYgIW1vdmVPbmNlKCFmaXJzdCkpIHsgYnJlYWsgfVxuICAgICAgICB2YXIgY3VyID0gbGluZU9iai50ZXh0LmNoYXJBdChwb3MuY2gpIHx8IFwiXFxuXCI7XG4gICAgICAgIHZhciB0eXBlID0gaXNXb3JkQ2hhcihjdXIsIGhlbHBlcikgPyBcIndcIlxuICAgICAgICAgIDogZ3JvdXAgJiYgY3VyID09IFwiXFxuXCIgPyBcIm5cIlxuICAgICAgICAgIDogIWdyb3VwIHx8IC9cXHMvLnRlc3QoY3VyKSA/IG51bGxcbiAgICAgICAgICA6IFwicFwiO1xuICAgICAgICBpZiAoZ3JvdXAgJiYgIWZpcnN0ICYmICF0eXBlKSB7IHR5cGUgPSBcInNcIjsgfVxuICAgICAgICBpZiAoc2F3VHlwZSAmJiBzYXdUeXBlICE9IHR5cGUpIHtcbiAgICAgICAgICBpZiAoZGlyIDwgMCkge2RpciA9IDE7IG1vdmVPbmNlKCk7IHBvcy5zdGlja3kgPSBcImFmdGVyXCI7fVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZSkgeyBzYXdUeXBlID0gdHlwZTsgfVxuICAgICAgICBpZiAoZGlyID4gMCAmJiAhbW92ZU9uY2UoIWZpcnN0KSkgeyBicmVhayB9XG4gICAgICB9XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBza2lwQXRvbWljKGRvYywgcG9zLCBvbGRQb3MsIG9yaWdEaXIsIHRydWUpO1xuICAgIGlmIChlcXVhbEN1cnNvclBvcyhvbGRQb3MsIHJlc3VsdCkpIHsgcmVzdWx0LmhpdFNpZGUgPSB0cnVlOyB9XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgLy8gRm9yIHJlbGF0aXZlIHZlcnRpY2FsIG1vdmVtZW50LiBEaXIgbWF5IGJlIC0xIG9yIDEuIFVuaXQgY2FuIGJlXG4gIC8vIFwicGFnZVwiIG9yIFwibGluZVwiLiBUaGUgcmVzdWx0aW5nIHBvc2l0aW9uIHdpbGwgaGF2ZSBhIGhpdFNpZGU9dHJ1ZVxuICAvLyBwcm9wZXJ0eSBpZiBpdCByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIGRvY3VtZW50LlxuICBmdW5jdGlvbiBmaW5kUG9zVihjbSwgcG9zLCBkaXIsIHVuaXQpIHtcbiAgICB2YXIgZG9jID0gY20uZG9jLCB4ID0gcG9zLmxlZnQsIHk7XG4gICAgaWYgKHVuaXQgPT0gXCJwYWdlXCIpIHtcbiAgICAgIHZhciBwYWdlU2l6ZSA9IE1hdGgubWluKGNtLmRpc3BsYXkud3JhcHBlci5jbGllbnRIZWlnaHQsIHdpbmRvdy5pbm5lckhlaWdodCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0KTtcbiAgICAgIHZhciBtb3ZlQW1vdW50ID0gTWF0aC5tYXgocGFnZVNpemUgLSAuNSAqIHRleHRIZWlnaHQoY20uZGlzcGxheSksIDMpO1xuICAgICAgeSA9IChkaXIgPiAwID8gcG9zLmJvdHRvbSA6IHBvcy50b3ApICsgZGlyICogbW92ZUFtb3VudDtcblxuICAgIH0gZWxzZSBpZiAodW5pdCA9PSBcImxpbmVcIikge1xuICAgICAgeSA9IGRpciA+IDAgPyBwb3MuYm90dG9tICsgMyA6IHBvcy50b3AgLSAzO1xuICAgIH1cbiAgICB2YXIgdGFyZ2V0O1xuICAgIGZvciAoOzspIHtcbiAgICAgIHRhcmdldCA9IGNvb3Jkc0NoYXIoY20sIHgsIHkpO1xuICAgICAgaWYgKCF0YXJnZXQub3V0c2lkZSkgeyBicmVhayB9XG4gICAgICBpZiAoZGlyIDwgMCA/IHkgPD0gMCA6IHkgPj0gZG9jLmhlaWdodCkgeyB0YXJnZXQuaGl0U2lkZSA9IHRydWU7IGJyZWFrIH1cbiAgICAgIHkgKz0gZGlyICogNTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldFxuICB9XG5cbiAgLy8gQ09OVEVOVEVESVRBQkxFIElOUFVUIFNUWUxFXG5cbiAgdmFyIENvbnRlbnRFZGl0YWJsZUlucHV0ID0gZnVuY3Rpb24oY20pIHtcbiAgICB0aGlzLmNtID0gY207XG4gICAgdGhpcy5sYXN0QW5jaG9yTm9kZSA9IHRoaXMubGFzdEFuY2hvck9mZnNldCA9IHRoaXMubGFzdEZvY3VzTm9kZSA9IHRoaXMubGFzdEZvY3VzT2Zmc2V0ID0gbnVsbDtcbiAgICB0aGlzLnBvbGxpbmcgPSBuZXcgRGVsYXllZCgpO1xuICAgIHRoaXMuY29tcG9zaW5nID0gbnVsbDtcbiAgICB0aGlzLmdyYWNlUGVyaW9kID0gZmFsc2U7XG4gICAgdGhpcy5yZWFkRE9NVGltZW91dCA9IG51bGw7XG4gIH07XG5cbiAgQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoZGlzcGxheSkge1xuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgaW5wdXQgPSB0aGlzLCBjbSA9IGlucHV0LmNtO1xuICAgIHZhciBkaXYgPSBpbnB1dC5kaXYgPSBkaXNwbGF5LmxpbmVEaXY7XG4gICAgZGlzYWJsZUJyb3dzZXJNYWdpYyhkaXYsIGNtLm9wdGlvbnMuc3BlbGxjaGVjaywgY20ub3B0aW9ucy5hdXRvY29ycmVjdCwgY20ub3B0aW9ucy5hdXRvY2FwaXRhbGl6ZSk7XG5cbiAgICBmdW5jdGlvbiBiZWxvbmdzVG9JbnB1dChlKSB7XG4gICAgICBmb3IgKHZhciB0ID0gZS50YXJnZXQ7IHQ7IHQgPSB0LnBhcmVudE5vZGUpIHtcbiAgICAgICAgaWYgKHQgPT0gZGl2KSB7IHJldHVybiB0cnVlIH1cbiAgICAgICAgaWYgKC9cXGJDb2RlTWlycm9yLSg/OmxpbmUpP3dpZGdldFxcYi8udGVzdCh0LmNsYXNzTmFtZSkpIHsgYnJlYWsgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgb24oZGl2LCBcInBhc3RlXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoIWJlbG9uZ3NUb0lucHV0KGUpIHx8IHNpZ25hbERPTUV2ZW50KGNtLCBlKSB8fCBoYW5kbGVQYXN0ZShlLCBjbSkpIHsgcmV0dXJuIH1cbiAgICAgIC8vIElFIGRvZXNuJ3QgZmlyZSBpbnB1dCBldmVudHMsIHNvIHdlIHNjaGVkdWxlIGEgcmVhZCBmb3IgdGhlIHBhc3RlZCBjb250ZW50IGluIHRoaXMgd2F5XG4gICAgICBpZiAoaWVfdmVyc2lvbiA8PSAxMSkgeyBzZXRUaW1lb3V0KG9wZXJhdGlvbihjbSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcyQxLnVwZGF0ZUZyb21ET00oKTsgfSksIDIwKTsgfVxuICAgIH0pO1xuXG4gICAgb24oZGl2LCBcImNvbXBvc2l0aW9uc3RhcnRcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgIHRoaXMkMS5jb21wb3NpbmcgPSB7ZGF0YTogZS5kYXRhLCBkb25lOiBmYWxzZX07XG4gICAgfSk7XG4gICAgb24oZGl2LCBcImNvbXBvc2l0aW9udXBkYXRlXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoIXRoaXMkMS5jb21wb3NpbmcpIHsgdGhpcyQxLmNvbXBvc2luZyA9IHtkYXRhOiBlLmRhdGEsIGRvbmU6IGZhbHNlfTsgfVxuICAgIH0pO1xuICAgIG9uKGRpdiwgXCJjb21wb3NpdGlvbmVuZFwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKHRoaXMkMS5jb21wb3NpbmcpIHtcbiAgICAgICAgaWYgKGUuZGF0YSAhPSB0aGlzJDEuY29tcG9zaW5nLmRhdGEpIHsgdGhpcyQxLnJlYWRGcm9tRE9NU29vbigpOyB9XG4gICAgICAgIHRoaXMkMS5jb21wb3NpbmcuZG9uZSA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBvbihkaXYsIFwidG91Y2hzdGFydFwiLCBmdW5jdGlvbiAoKSB7IHJldHVybiBpbnB1dC5mb3JjZUNvbXBvc2l0aW9uRW5kKCk7IH0pO1xuXG4gICAgb24oZGl2LCBcImlucHV0XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghdGhpcyQxLmNvbXBvc2luZykgeyB0aGlzJDEucmVhZEZyb21ET01Tb29uKCk7IH1cbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIG9uQ29weUN1dChlKSB7XG4gICAgICBpZiAoIWJlbG9uZ3NUb0lucHV0KGUpIHx8IHNpZ25hbERPTUV2ZW50KGNtLCBlKSkgeyByZXR1cm4gfVxuICAgICAgaWYgKGNtLnNvbWV0aGluZ1NlbGVjdGVkKCkpIHtcbiAgICAgICAgc2V0TGFzdENvcGllZCh7bGluZVdpc2U6IGZhbHNlLCB0ZXh0OiBjbS5nZXRTZWxlY3Rpb25zKCl9KTtcbiAgICAgICAgaWYgKGUudHlwZSA9PSBcImN1dFwiKSB7IGNtLnJlcGxhY2VTZWxlY3Rpb24oXCJcIiwgbnVsbCwgXCJjdXRcIik7IH1cbiAgICAgIH0gZWxzZSBpZiAoIWNtLm9wdGlvbnMubGluZVdpc2VDb3B5Q3V0KSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJhbmdlcyA9IGNvcHlhYmxlUmFuZ2VzKGNtKTtcbiAgICAgICAgc2V0TGFzdENvcGllZCh7bGluZVdpc2U6IHRydWUsIHRleHQ6IHJhbmdlcy50ZXh0fSk7XG4gICAgICAgIGlmIChlLnR5cGUgPT0gXCJjdXRcIikge1xuICAgICAgICAgIGNtLm9wZXJhdGlvbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjbS5zZXRTZWxlY3Rpb25zKHJhbmdlcy5yYW5nZXMsIDAsIHNlbF9kb250U2Nyb2xsKTtcbiAgICAgICAgICAgIGNtLnJlcGxhY2VTZWxlY3Rpb24oXCJcIiwgbnVsbCwgXCJjdXRcIik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChlLmNsaXBib2FyZERhdGEpIHtcbiAgICAgICAgZS5jbGlwYm9hcmREYXRhLmNsZWFyRGF0YSgpO1xuICAgICAgICB2YXIgY29udGVudCA9IGxhc3RDb3BpZWQudGV4dC5qb2luKFwiXFxuXCIpO1xuICAgICAgICAvLyBpT1MgZXhwb3NlcyB0aGUgY2xpcGJvYXJkIEFQSSwgYnV0IHNlZW1zIHRvIGRpc2NhcmQgY29udGVudCBpbnNlcnRlZCBpbnRvIGl0XG4gICAgICAgIGUuY2xpcGJvYXJkRGF0YS5zZXREYXRhKFwiVGV4dFwiLCBjb250ZW50KTtcbiAgICAgICAgaWYgKGUuY2xpcGJvYXJkRGF0YS5nZXREYXRhKFwiVGV4dFwiKSA9PSBjb250ZW50KSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBPbGQtZmFzaGlvbmVkIGJyaWVmbHktZm9jdXMtYS10ZXh0YXJlYSBoYWNrXG4gICAgICB2YXIga2x1ZGdlID0gaGlkZGVuVGV4dGFyZWEoKSwgdGUgPSBrbHVkZ2UuZmlyc3RDaGlsZDtcbiAgICAgIGNtLmRpc3BsYXkubGluZVNwYWNlLmluc2VydEJlZm9yZShrbHVkZ2UsIGNtLmRpc3BsYXkubGluZVNwYWNlLmZpcnN0Q2hpbGQpO1xuICAgICAgdGUudmFsdWUgPSBsYXN0Q29waWVkLnRleHQuam9pbihcIlxcblwiKTtcbiAgICAgIHZhciBoYWRGb2N1cyA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICBzZWxlY3RJbnB1dCh0ZSk7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY20uZGlzcGxheS5saW5lU3BhY2UucmVtb3ZlQ2hpbGQoa2x1ZGdlKTtcbiAgICAgICAgaGFkRm9jdXMuZm9jdXMoKTtcbiAgICAgICAgaWYgKGhhZEZvY3VzID09IGRpdikgeyBpbnB1dC5zaG93UHJpbWFyeVNlbGVjdGlvbigpOyB9XG4gICAgICB9LCA1MCk7XG4gICAgfVxuICAgIG9uKGRpdiwgXCJjb3B5XCIsIG9uQ29weUN1dCk7XG4gICAgb24oZGl2LCBcImN1dFwiLCBvbkNvcHlDdXQpO1xuICB9O1xuXG4gIENvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5zY3JlZW5SZWFkZXJMYWJlbENoYW5nZWQgPSBmdW5jdGlvbiAobGFiZWwpIHtcbiAgICAvLyBMYWJlbCBmb3Igc2NyZWVucmVhZGVycywgYWNjZXNzaWJpbGl0eVxuICAgIGlmKGxhYmVsKSB7XG4gICAgICB0aGlzLmRpdi5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnLCBsYWJlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGl2LnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcpO1xuICAgIH1cbiAgfTtcblxuICBDb250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUucHJlcGFyZVNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVzdWx0ID0gcHJlcGFyZVNlbGVjdGlvbih0aGlzLmNtLCBmYWxzZSk7XG4gICAgcmVzdWx0LmZvY3VzID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PSB0aGlzLmRpdjtcbiAgICByZXR1cm4gcmVzdWx0XG4gIH07XG5cbiAgQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLnNob3dTZWxlY3Rpb24gPSBmdW5jdGlvbiAoaW5mbywgdGFrZUZvY3VzKSB7XG4gICAgaWYgKCFpbmZvIHx8ICF0aGlzLmNtLmRpc3BsYXkudmlldy5sZW5ndGgpIHsgcmV0dXJuIH1cbiAgICBpZiAoaW5mby5mb2N1cyB8fCB0YWtlRm9jdXMpIHsgdGhpcy5zaG93UHJpbWFyeVNlbGVjdGlvbigpOyB9XG4gICAgdGhpcy5zaG93TXVsdGlwbGVTZWxlY3Rpb25zKGluZm8pO1xuICB9O1xuXG4gIENvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5nZXRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY20uZGlzcGxheS53cmFwcGVyLm93bmVyRG9jdW1lbnQuZ2V0U2VsZWN0aW9uKClcbiAgfTtcblxuICBDb250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUuc2hvd1ByaW1hcnlTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbCA9IHRoaXMuZ2V0U2VsZWN0aW9uKCksIGNtID0gdGhpcy5jbSwgcHJpbSA9IGNtLmRvYy5zZWwucHJpbWFyeSgpO1xuICAgIHZhciBmcm9tID0gcHJpbS5mcm9tKCksIHRvID0gcHJpbS50bygpO1xuXG4gICAgaWYgKGNtLmRpc3BsYXkudmlld1RvID09IGNtLmRpc3BsYXkudmlld0Zyb20gfHwgZnJvbS5saW5lID49IGNtLmRpc3BsYXkudmlld1RvIHx8IHRvLmxpbmUgPCBjbS5kaXNwbGF5LnZpZXdGcm9tKSB7XG4gICAgICBzZWwucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgY3VyQW5jaG9yID0gZG9tVG9Qb3MoY20sIHNlbC5hbmNob3JOb2RlLCBzZWwuYW5jaG9yT2Zmc2V0KTtcbiAgICB2YXIgY3VyRm9jdXMgPSBkb21Ub1BvcyhjbSwgc2VsLmZvY3VzTm9kZSwgc2VsLmZvY3VzT2Zmc2V0KTtcbiAgICBpZiAoY3VyQW5jaG9yICYmICFjdXJBbmNob3IuYmFkICYmIGN1ckZvY3VzICYmICFjdXJGb2N1cy5iYWQgJiZcbiAgICAgICAgY21wKG1pblBvcyhjdXJBbmNob3IsIGN1ckZvY3VzKSwgZnJvbSkgPT0gMCAmJlxuICAgICAgICBjbXAobWF4UG9zKGN1ckFuY2hvciwgY3VyRm9jdXMpLCB0bykgPT0gMClcbiAgICAgIHsgcmV0dXJuIH1cblxuICAgIHZhciB2aWV3ID0gY20uZGlzcGxheS52aWV3O1xuICAgIHZhciBzdGFydCA9IChmcm9tLmxpbmUgPj0gY20uZGlzcGxheS52aWV3RnJvbSAmJiBwb3NUb0RPTShjbSwgZnJvbSkpIHx8XG4gICAgICAgIHtub2RlOiB2aWV3WzBdLm1lYXN1cmUubWFwWzJdLCBvZmZzZXQ6IDB9O1xuICAgIHZhciBlbmQgPSB0by5saW5lIDwgY20uZGlzcGxheS52aWV3VG8gJiYgcG9zVG9ET00oY20sIHRvKTtcbiAgICBpZiAoIWVuZCkge1xuICAgICAgdmFyIG1lYXN1cmUgPSB2aWV3W3ZpZXcubGVuZ3RoIC0gMV0ubWVhc3VyZTtcbiAgICAgIHZhciBtYXAgPSBtZWFzdXJlLm1hcHMgPyBtZWFzdXJlLm1hcHNbbWVhc3VyZS5tYXBzLmxlbmd0aCAtIDFdIDogbWVhc3VyZS5tYXA7XG4gICAgICBlbmQgPSB7bm9kZTogbWFwW21hcC5sZW5ndGggLSAxXSwgb2Zmc2V0OiBtYXBbbWFwLmxlbmd0aCAtIDJdIC0gbWFwW21hcC5sZW5ndGggLSAzXX07XG4gICAgfVxuXG4gICAgaWYgKCFzdGFydCB8fCAhZW5kKSB7XG4gICAgICBzZWwucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgb2xkID0gc2VsLnJhbmdlQ291bnQgJiYgc2VsLmdldFJhbmdlQXQoMCksIHJuZztcbiAgICB0cnkgeyBybmcgPSByYW5nZShzdGFydC5ub2RlLCBzdGFydC5vZmZzZXQsIGVuZC5vZmZzZXQsIGVuZC5ub2RlKTsgfVxuICAgIGNhdGNoKGUpIHt9IC8vIE91ciBtb2RlbCBvZiB0aGUgRE9NIG1pZ2h0IGJlIG91dGRhdGVkLCBpbiB3aGljaCBjYXNlIHRoZSByYW5nZSB3ZSB0cnkgdG8gc2V0IGNhbiBiZSBpbXBvc3NpYmxlXG4gICAgaWYgKHJuZykge1xuICAgICAgaWYgKCFnZWNrbyAmJiBjbS5zdGF0ZS5mb2N1c2VkKSB7XG4gICAgICAgIHNlbC5jb2xsYXBzZShzdGFydC5ub2RlLCBzdGFydC5vZmZzZXQpO1xuICAgICAgICBpZiAoIXJuZy5jb2xsYXBzZWQpIHtcbiAgICAgICAgICBzZWwucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICAgICAgc2VsLmFkZFJhbmdlKHJuZyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbC5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgICAgc2VsLmFkZFJhbmdlKHJuZyk7XG4gICAgICB9XG4gICAgICBpZiAob2xkICYmIHNlbC5hbmNob3JOb2RlID09IG51bGwpIHsgc2VsLmFkZFJhbmdlKG9sZCk7IH1cbiAgICAgIGVsc2UgaWYgKGdlY2tvKSB7IHRoaXMuc3RhcnRHcmFjZVBlcmlvZCgpOyB9XG4gICAgfVxuICAgIHRoaXMucmVtZW1iZXJTZWxlY3Rpb24oKTtcbiAgfTtcblxuICBDb250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUuc3RhcnRHcmFjZVBlcmlvZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuZ3JhY2VQZXJpb2QpO1xuICAgIHRoaXMuZ3JhY2VQZXJpb2QgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMkMS5ncmFjZVBlcmlvZCA9IGZhbHNlO1xuICAgICAgaWYgKHRoaXMkMS5zZWxlY3Rpb25DaGFuZ2VkKCkpXG4gICAgICAgIHsgdGhpcyQxLmNtLm9wZXJhdGlvbihmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzJDEuY20uY3VyT3Auc2VsZWN0aW9uQ2hhbmdlZCA9IHRydWU7IH0pOyB9XG4gICAgfSwgMjApO1xuICB9O1xuXG4gIENvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5zaG93TXVsdGlwbGVTZWxlY3Rpb25zID0gZnVuY3Rpb24gKGluZm8pIHtcbiAgICByZW1vdmVDaGlsZHJlbkFuZEFkZCh0aGlzLmNtLmRpc3BsYXkuY3Vyc29yRGl2LCBpbmZvLmN1cnNvcnMpO1xuICAgIHJlbW92ZUNoaWxkcmVuQW5kQWRkKHRoaXMuY20uZGlzcGxheS5zZWxlY3Rpb25EaXYsIGluZm8uc2VsZWN0aW9uKTtcbiAgfTtcblxuICBDb250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUucmVtZW1iZXJTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbCA9IHRoaXMuZ2V0U2VsZWN0aW9uKCk7XG4gICAgdGhpcy5sYXN0QW5jaG9yTm9kZSA9IHNlbC5hbmNob3JOb2RlOyB0aGlzLmxhc3RBbmNob3JPZmZzZXQgPSBzZWwuYW5jaG9yT2Zmc2V0O1xuICAgIHRoaXMubGFzdEZvY3VzTm9kZSA9IHNlbC5mb2N1c05vZGU7IHRoaXMubGFzdEZvY3VzT2Zmc2V0ID0gc2VsLmZvY3VzT2Zmc2V0O1xuICB9O1xuXG4gIENvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5zZWxlY3Rpb25JbkVkaXRvciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsID0gdGhpcy5nZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoIXNlbC5yYW5nZUNvdW50KSB7IHJldHVybiBmYWxzZSB9XG4gICAgdmFyIG5vZGUgPSBzZWwuZ2V0UmFuZ2VBdCgwKS5jb21tb25BbmNlc3RvckNvbnRhaW5lcjtcbiAgICByZXR1cm4gY29udGFpbnModGhpcy5kaXYsIG5vZGUpXG4gIH07XG5cbiAgQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLmZvY3VzID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmNtLm9wdGlvbnMucmVhZE9ubHkgIT0gXCJub2N1cnNvclwiKSB7XG4gICAgICBpZiAoIXRoaXMuc2VsZWN0aW9uSW5FZGl0b3IoKSB8fCBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICE9IHRoaXMuZGl2KVxuICAgICAgICB7IHRoaXMuc2hvd1NlbGVjdGlvbih0aGlzLnByZXBhcmVTZWxlY3Rpb24oKSwgdHJ1ZSk7IH1cbiAgICAgIHRoaXMuZGl2LmZvY3VzKCk7XG4gICAgfVxuICB9O1xuICBDb250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUuYmx1ciA9IGZ1bmN0aW9uICgpIHsgdGhpcy5kaXYuYmx1cigpOyB9O1xuICBDb250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUuZ2V0RmllbGQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmRpdiB9O1xuXG4gIENvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5zdXBwb3J0c1RvdWNoID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZSB9O1xuXG4gIENvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5yZWNlaXZlZEZvY3VzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpbnB1dCA9IHRoaXM7XG4gICAgaWYgKHRoaXMuc2VsZWN0aW9uSW5FZGl0b3IoKSlcbiAgICAgIHsgdGhpcy5wb2xsU2VsZWN0aW9uKCk7IH1cbiAgICBlbHNlXG4gICAgICB7IHJ1bkluT3AodGhpcy5jbSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5wdXQuY20uY3VyT3Auc2VsZWN0aW9uQ2hhbmdlZCA9IHRydWU7IH0pOyB9XG5cbiAgICBmdW5jdGlvbiBwb2xsKCkge1xuICAgICAgaWYgKGlucHV0LmNtLnN0YXRlLmZvY3VzZWQpIHtcbiAgICAgICAgaW5wdXQucG9sbFNlbGVjdGlvbigpO1xuICAgICAgICBpbnB1dC5wb2xsaW5nLnNldChpbnB1dC5jbS5vcHRpb25zLnBvbGxJbnRlcnZhbCwgcG9sbCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMucG9sbGluZy5zZXQodGhpcy5jbS5vcHRpb25zLnBvbGxJbnRlcnZhbCwgcG9sbCk7XG4gIH07XG5cbiAgQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLnNlbGVjdGlvbkNoYW5nZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbCA9IHRoaXMuZ2V0U2VsZWN0aW9uKCk7XG4gICAgcmV0dXJuIHNlbC5hbmNob3JOb2RlICE9IHRoaXMubGFzdEFuY2hvck5vZGUgfHwgc2VsLmFuY2hvck9mZnNldCAhPSB0aGlzLmxhc3RBbmNob3JPZmZzZXQgfHxcbiAgICAgIHNlbC5mb2N1c05vZGUgIT0gdGhpcy5sYXN0Rm9jdXNOb2RlIHx8IHNlbC5mb2N1c09mZnNldCAhPSB0aGlzLmxhc3RGb2N1c09mZnNldFxuICB9O1xuXG4gIENvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5wb2xsU2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnJlYWRET01UaW1lb3V0ICE9IG51bGwgfHwgdGhpcy5ncmFjZVBlcmlvZCB8fCAhdGhpcy5zZWxlY3Rpb25DaGFuZ2VkKCkpIHsgcmV0dXJuIH1cbiAgICB2YXIgc2VsID0gdGhpcy5nZXRTZWxlY3Rpb24oKSwgY20gPSB0aGlzLmNtO1xuICAgIC8vIE9uIEFuZHJvaWQgQ2hyb21lICh2ZXJzaW9uIDU2LCBhdCBsZWFzdCksIGJhY2tzcGFjaW5nIGludG8gYW5cbiAgICAvLyB1bmVkaXRhYmxlIGJsb2NrIGVsZW1lbnQgd2lsbCBwdXQgdGhlIGN1cnNvciBpbiB0aGF0IGVsZW1lbnQsXG4gICAgLy8gYW5kIHRoZW4sIGJlY2F1c2UgaXQncyBub3QgZWRpdGFibGUsIGhpZGUgdGhlIHZpcnR1YWwga2V5Ym9hcmQuXG4gICAgLy8gQmVjYXVzZSBBbmRyb2lkIGRvZXNuJ3QgYWxsb3cgdXMgdG8gYWN0dWFsbHkgZGV0ZWN0IGJhY2tzcGFjZVxuICAgIC8vIHByZXNzZXMgaW4gYSBzYW5lIHdheSwgdGhpcyBjb2RlIGNoZWNrcyBmb3Igd2hlbiB0aGF0IGhhcHBlbnNcbiAgICAvLyBhbmQgc2ltdWxhdGVzIGEgYmFja3NwYWNlIHByZXNzIGluIHRoaXMgY2FzZS5cbiAgICBpZiAoYW5kcm9pZCAmJiBjaHJvbWUgJiYgdGhpcy5jbS5kaXNwbGF5Lmd1dHRlclNwZWNzLmxlbmd0aCAmJiBpc0luR3V0dGVyKHNlbC5hbmNob3JOb2RlKSkge1xuICAgICAgdGhpcy5jbS50cmlnZ2VyT25LZXlEb3duKHt0eXBlOiBcImtleWRvd25cIiwga2V5Q29kZTogOCwgcHJldmVudERlZmF1bHQ6IE1hdGguYWJzfSk7XG4gICAgICB0aGlzLmJsdXIoKTtcbiAgICAgIHRoaXMuZm9jdXMoKTtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBpZiAodGhpcy5jb21wb3NpbmcpIHsgcmV0dXJuIH1cbiAgICB0aGlzLnJlbWVtYmVyU2VsZWN0aW9uKCk7XG4gICAgdmFyIGFuY2hvciA9IGRvbVRvUG9zKGNtLCBzZWwuYW5jaG9yTm9kZSwgc2VsLmFuY2hvck9mZnNldCk7XG4gICAgdmFyIGhlYWQgPSBkb21Ub1BvcyhjbSwgc2VsLmZvY3VzTm9kZSwgc2VsLmZvY3VzT2Zmc2V0KTtcbiAgICBpZiAoYW5jaG9yICYmIGhlYWQpIHsgcnVuSW5PcChjbSwgZnVuY3Rpb24gKCkge1xuICAgICAgc2V0U2VsZWN0aW9uKGNtLmRvYywgc2ltcGxlU2VsZWN0aW9uKGFuY2hvciwgaGVhZCksIHNlbF9kb250U2Nyb2xsKTtcbiAgICAgIGlmIChhbmNob3IuYmFkIHx8IGhlYWQuYmFkKSB7IGNtLmN1ck9wLnNlbGVjdGlvbkNoYW5nZWQgPSB0cnVlOyB9XG4gICAgfSk7IH1cbiAgfTtcblxuICBDb250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUucG9sbENvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMucmVhZERPTVRpbWVvdXQgIT0gbnVsbCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucmVhZERPTVRpbWVvdXQpO1xuICAgICAgdGhpcy5yZWFkRE9NVGltZW91dCA9IG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGNtID0gdGhpcy5jbSwgZGlzcGxheSA9IGNtLmRpc3BsYXksIHNlbCA9IGNtLmRvYy5zZWwucHJpbWFyeSgpO1xuICAgIHZhciBmcm9tID0gc2VsLmZyb20oKSwgdG8gPSBzZWwudG8oKTtcbiAgICBpZiAoZnJvbS5jaCA9PSAwICYmIGZyb20ubGluZSA+IGNtLmZpcnN0TGluZSgpKVxuICAgICAgeyBmcm9tID0gUG9zKGZyb20ubGluZSAtIDEsIGdldExpbmUoY20uZG9jLCBmcm9tLmxpbmUgLSAxKS5sZW5ndGgpOyB9XG4gICAgaWYgKHRvLmNoID09IGdldExpbmUoY20uZG9jLCB0by5saW5lKS50ZXh0Lmxlbmd0aCAmJiB0by5saW5lIDwgY20ubGFzdExpbmUoKSlcbiAgICAgIHsgdG8gPSBQb3ModG8ubGluZSArIDEsIDApOyB9XG4gICAgaWYgKGZyb20ubGluZSA8IGRpc3BsYXkudmlld0Zyb20gfHwgdG8ubGluZSA+IGRpc3BsYXkudmlld1RvIC0gMSkgeyByZXR1cm4gZmFsc2UgfVxuXG4gICAgdmFyIGZyb21JbmRleCwgZnJvbUxpbmUsIGZyb21Ob2RlO1xuICAgIGlmIChmcm9tLmxpbmUgPT0gZGlzcGxheS52aWV3RnJvbSB8fCAoZnJvbUluZGV4ID0gZmluZFZpZXdJbmRleChjbSwgZnJvbS5saW5lKSkgPT0gMCkge1xuICAgICAgZnJvbUxpbmUgPSBsaW5lTm8oZGlzcGxheS52aWV3WzBdLmxpbmUpO1xuICAgICAgZnJvbU5vZGUgPSBkaXNwbGF5LnZpZXdbMF0ubm9kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZnJvbUxpbmUgPSBsaW5lTm8oZGlzcGxheS52aWV3W2Zyb21JbmRleF0ubGluZSk7XG4gICAgICBmcm9tTm9kZSA9IGRpc3BsYXkudmlld1tmcm9tSW5kZXggLSAxXS5ub2RlLm5leHRTaWJsaW5nO1xuICAgIH1cbiAgICB2YXIgdG9JbmRleCA9IGZpbmRWaWV3SW5kZXgoY20sIHRvLmxpbmUpO1xuICAgIHZhciB0b0xpbmUsIHRvTm9kZTtcbiAgICBpZiAodG9JbmRleCA9PSBkaXNwbGF5LnZpZXcubGVuZ3RoIC0gMSkge1xuICAgICAgdG9MaW5lID0gZGlzcGxheS52aWV3VG8gLSAxO1xuICAgICAgdG9Ob2RlID0gZGlzcGxheS5saW5lRGl2Lmxhc3RDaGlsZDtcbiAgICB9IGVsc2Uge1xuICAgICAgdG9MaW5lID0gbGluZU5vKGRpc3BsYXkudmlld1t0b0luZGV4ICsgMV0ubGluZSkgLSAxO1xuICAgICAgdG9Ob2RlID0gZGlzcGxheS52aWV3W3RvSW5kZXggKyAxXS5ub2RlLnByZXZpb3VzU2libGluZztcbiAgICB9XG5cbiAgICBpZiAoIWZyb21Ob2RlKSB7IHJldHVybiBmYWxzZSB9XG4gICAgdmFyIG5ld1RleHQgPSBjbS5kb2Muc3BsaXRMaW5lcyhkb21UZXh0QmV0d2VlbihjbSwgZnJvbU5vZGUsIHRvTm9kZSwgZnJvbUxpbmUsIHRvTGluZSkpO1xuICAgIHZhciBvbGRUZXh0ID0gZ2V0QmV0d2VlbihjbS5kb2MsIFBvcyhmcm9tTGluZSwgMCksIFBvcyh0b0xpbmUsIGdldExpbmUoY20uZG9jLCB0b0xpbmUpLnRleHQubGVuZ3RoKSk7XG4gICAgd2hpbGUgKG5ld1RleHQubGVuZ3RoID4gMSAmJiBvbGRUZXh0Lmxlbmd0aCA+IDEpIHtcbiAgICAgIGlmIChsc3QobmV3VGV4dCkgPT0gbHN0KG9sZFRleHQpKSB7IG5ld1RleHQucG9wKCk7IG9sZFRleHQucG9wKCk7IHRvTGluZS0tOyB9XG4gICAgICBlbHNlIGlmIChuZXdUZXh0WzBdID09IG9sZFRleHRbMF0pIHsgbmV3VGV4dC5zaGlmdCgpOyBvbGRUZXh0LnNoaWZ0KCk7IGZyb21MaW5lKys7IH1cbiAgICAgIGVsc2UgeyBicmVhayB9XG4gICAgfVxuXG4gICAgdmFyIGN1dEZyb250ID0gMCwgY3V0RW5kID0gMDtcbiAgICB2YXIgbmV3VG9wID0gbmV3VGV4dFswXSwgb2xkVG9wID0gb2xkVGV4dFswXSwgbWF4Q3V0RnJvbnQgPSBNYXRoLm1pbihuZXdUb3AubGVuZ3RoLCBvbGRUb3AubGVuZ3RoKTtcbiAgICB3aGlsZSAoY3V0RnJvbnQgPCBtYXhDdXRGcm9udCAmJiBuZXdUb3AuY2hhckNvZGVBdChjdXRGcm9udCkgPT0gb2xkVG9wLmNoYXJDb2RlQXQoY3V0RnJvbnQpKVxuICAgICAgeyArK2N1dEZyb250OyB9XG4gICAgdmFyIG5ld0JvdCA9IGxzdChuZXdUZXh0KSwgb2xkQm90ID0gbHN0KG9sZFRleHQpO1xuICAgIHZhciBtYXhDdXRFbmQgPSBNYXRoLm1pbihuZXdCb3QubGVuZ3RoIC0gKG5ld1RleHQubGVuZ3RoID09IDEgPyBjdXRGcm9udCA6IDApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbGRCb3QubGVuZ3RoIC0gKG9sZFRleHQubGVuZ3RoID09IDEgPyBjdXRGcm9udCA6IDApKTtcbiAgICB3aGlsZSAoY3V0RW5kIDwgbWF4Q3V0RW5kICYmXG4gICAgICAgICAgIG5ld0JvdC5jaGFyQ29kZUF0KG5ld0JvdC5sZW5ndGggLSBjdXRFbmQgLSAxKSA9PSBvbGRCb3QuY2hhckNvZGVBdChvbGRCb3QubGVuZ3RoIC0gY3V0RW5kIC0gMSkpXG4gICAgICB7ICsrY3V0RW5kOyB9XG4gICAgLy8gVHJ5IHRvIG1vdmUgc3RhcnQgb2YgY2hhbmdlIHRvIHN0YXJ0IG9mIHNlbGVjdGlvbiBpZiBhbWJpZ3VvdXNcbiAgICBpZiAobmV3VGV4dC5sZW5ndGggPT0gMSAmJiBvbGRUZXh0Lmxlbmd0aCA9PSAxICYmIGZyb21MaW5lID09IGZyb20ubGluZSkge1xuICAgICAgd2hpbGUgKGN1dEZyb250ICYmIGN1dEZyb250ID4gZnJvbS5jaCAmJlxuICAgICAgICAgICAgIG5ld0JvdC5jaGFyQ29kZUF0KG5ld0JvdC5sZW5ndGggLSBjdXRFbmQgLSAxKSA9PSBvbGRCb3QuY2hhckNvZGVBdChvbGRCb3QubGVuZ3RoIC0gY3V0RW5kIC0gMSkpIHtcbiAgICAgICAgY3V0RnJvbnQtLTtcbiAgICAgICAgY3V0RW5kKys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbmV3VGV4dFtuZXdUZXh0Lmxlbmd0aCAtIDFdID0gbmV3Qm90LnNsaWNlKDAsIG5ld0JvdC5sZW5ndGggLSBjdXRFbmQpLnJlcGxhY2UoL15cXHUyMDBiKy8sIFwiXCIpO1xuICAgIG5ld1RleHRbMF0gPSBuZXdUZXh0WzBdLnNsaWNlKGN1dEZyb250KS5yZXBsYWNlKC9cXHUyMDBiKyQvLCBcIlwiKTtcblxuICAgIHZhciBjaEZyb20gPSBQb3MoZnJvbUxpbmUsIGN1dEZyb250KTtcbiAgICB2YXIgY2hUbyA9IFBvcyh0b0xpbmUsIG9sZFRleHQubGVuZ3RoID8gbHN0KG9sZFRleHQpLmxlbmd0aCAtIGN1dEVuZCA6IDApO1xuICAgIGlmIChuZXdUZXh0Lmxlbmd0aCA+IDEgfHwgbmV3VGV4dFswXSB8fCBjbXAoY2hGcm9tLCBjaFRvKSkge1xuICAgICAgcmVwbGFjZVJhbmdlKGNtLmRvYywgbmV3VGV4dCwgY2hGcm9tLCBjaFRvLCBcIitpbnB1dFwiKTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9O1xuXG4gIENvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5lbnN1cmVQb2xsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mb3JjZUNvbXBvc2l0aW9uRW5kKCk7XG4gIH07XG4gIENvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZvcmNlQ29tcG9zaXRpb25FbmQoKTtcbiAgfTtcbiAgQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLmZvcmNlQ29tcG9zaXRpb25FbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLmNvbXBvc2luZykgeyByZXR1cm4gfVxuICAgIGNsZWFyVGltZW91dCh0aGlzLnJlYWRET01UaW1lb3V0KTtcbiAgICB0aGlzLmNvbXBvc2luZyA9IG51bGw7XG4gICAgdGhpcy51cGRhdGVGcm9tRE9NKCk7XG4gICAgdGhpcy5kaXYuYmx1cigpO1xuICAgIHRoaXMuZGl2LmZvY3VzKCk7XG4gIH07XG4gIENvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5yZWFkRnJvbURPTVNvb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGlmICh0aGlzLnJlYWRET01UaW1lb3V0ICE9IG51bGwpIHsgcmV0dXJuIH1cbiAgICB0aGlzLnJlYWRET01UaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzJDEucmVhZERPTVRpbWVvdXQgPSBudWxsO1xuICAgICAgaWYgKHRoaXMkMS5jb21wb3NpbmcpIHtcbiAgICAgICAgaWYgKHRoaXMkMS5jb21wb3NpbmcuZG9uZSkgeyB0aGlzJDEuY29tcG9zaW5nID0gbnVsbDsgfVxuICAgICAgICBlbHNlIHsgcmV0dXJuIH1cbiAgICAgIH1cbiAgICAgIHRoaXMkMS51cGRhdGVGcm9tRE9NKCk7XG4gICAgfSwgODApO1xuICB9O1xuXG4gIENvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS51cGRhdGVGcm9tRE9NID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBpZiAodGhpcy5jbS5pc1JlYWRPbmx5KCkgfHwgIXRoaXMucG9sbENvbnRlbnQoKSlcbiAgICAgIHsgcnVuSW5PcCh0aGlzLmNtLCBmdW5jdGlvbiAoKSB7IHJldHVybiByZWdDaGFuZ2UodGhpcyQxLmNtKTsgfSk7IH1cbiAgfTtcblxuICBDb250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUuc2V0VW5lZGl0YWJsZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgbm9kZS5jb250ZW50RWRpdGFibGUgPSBcImZhbHNlXCI7XG4gIH07XG5cbiAgQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLm9uS2V5UHJlc3MgPSBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChlLmNoYXJDb2RlID09IDAgfHwgdGhpcy5jb21wb3NpbmcpIHsgcmV0dXJuIH1cbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgaWYgKCF0aGlzLmNtLmlzUmVhZE9ubHkoKSlcbiAgICAgIHsgb3BlcmF0aW9uKHRoaXMuY20sIGFwcGx5VGV4dElucHV0KSh0aGlzLmNtLCBTdHJpbmcuZnJvbUNoYXJDb2RlKGUuY2hhckNvZGUgPT0gbnVsbCA/IGUua2V5Q29kZSA6IGUuY2hhckNvZGUpLCAwKTsgfVxuICB9O1xuXG4gIENvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5yZWFkT25seUNoYW5nZWQgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgdGhpcy5kaXYuY29udGVudEVkaXRhYmxlID0gU3RyaW5nKHZhbCAhPSBcIm5vY3Vyc29yXCIpO1xuICB9O1xuXG4gIENvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5vbkNvbnRleHRNZW51ID0gZnVuY3Rpb24gKCkge307XG4gIENvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5yZXNldFBvc2l0aW9uID0gZnVuY3Rpb24gKCkge307XG5cbiAgQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLm5lZWRzQ29udGVudEF0dHJpYnV0ZSA9IHRydWU7XG5cbiAgZnVuY3Rpb24gcG9zVG9ET00oY20sIHBvcykge1xuICAgIHZhciB2aWV3ID0gZmluZFZpZXdGb3JMaW5lKGNtLCBwb3MubGluZSk7XG4gICAgaWYgKCF2aWV3IHx8IHZpZXcuaGlkZGVuKSB7IHJldHVybiBudWxsIH1cbiAgICB2YXIgbGluZSA9IGdldExpbmUoY20uZG9jLCBwb3MubGluZSk7XG4gICAgdmFyIGluZm8gPSBtYXBGcm9tTGluZVZpZXcodmlldywgbGluZSwgcG9zLmxpbmUpO1xuXG4gICAgdmFyIG9yZGVyID0gZ2V0T3JkZXIobGluZSwgY20uZG9jLmRpcmVjdGlvbiksIHNpZGUgPSBcImxlZnRcIjtcbiAgICBpZiAob3JkZXIpIHtcbiAgICAgIHZhciBwYXJ0UG9zID0gZ2V0QmlkaVBhcnRBdChvcmRlciwgcG9zLmNoKTtcbiAgICAgIHNpZGUgPSBwYXJ0UG9zICUgMiA/IFwicmlnaHRcIiA6IFwibGVmdFwiO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gbm9kZUFuZE9mZnNldEluTGluZU1hcChpbmZvLm1hcCwgcG9zLmNoLCBzaWRlKTtcbiAgICByZXN1bHQub2Zmc2V0ID0gcmVzdWx0LmNvbGxhcHNlID09IFwicmlnaHRcIiA/IHJlc3VsdC5lbmQgOiByZXN1bHQuc3RhcnQ7XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgZnVuY3Rpb24gaXNJbkd1dHRlcihub2RlKSB7XG4gICAgZm9yICh2YXIgc2NhbiA9IG5vZGU7IHNjYW47IHNjYW4gPSBzY2FuLnBhcmVudE5vZGUpXG4gICAgICB7IGlmICgvQ29kZU1pcnJvci1ndXR0ZXItd3JhcHBlci8udGVzdChzY2FuLmNsYXNzTmFtZSkpIHsgcmV0dXJuIHRydWUgfSB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBmdW5jdGlvbiBiYWRQb3MocG9zLCBiYWQpIHsgaWYgKGJhZCkgeyBwb3MuYmFkID0gdHJ1ZTsgfSByZXR1cm4gcG9zIH1cblxuICBmdW5jdGlvbiBkb21UZXh0QmV0d2VlbihjbSwgZnJvbSwgdG8sIGZyb21MaW5lLCB0b0xpbmUpIHtcbiAgICB2YXIgdGV4dCA9IFwiXCIsIGNsb3NpbmcgPSBmYWxzZSwgbGluZVNlcCA9IGNtLmRvYy5saW5lU2VwYXJhdG9yKCksIGV4dHJhTGluZWJyZWFrID0gZmFsc2U7XG4gICAgZnVuY3Rpb24gcmVjb2duaXplTWFya2VyKGlkKSB7IHJldHVybiBmdW5jdGlvbiAobWFya2VyKSB7IHJldHVybiBtYXJrZXIuaWQgPT0gaWQ7IH0gfVxuICAgIGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgICAgaWYgKGNsb3NpbmcpIHtcbiAgICAgICAgdGV4dCArPSBsaW5lU2VwO1xuICAgICAgICBpZiAoZXh0cmFMaW5lYnJlYWspIHsgdGV4dCArPSBsaW5lU2VwOyB9XG4gICAgICAgIGNsb3NpbmcgPSBleHRyYUxpbmVicmVhayA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBhZGRUZXh0KHN0cikge1xuICAgICAgaWYgKHN0cikge1xuICAgICAgICBjbG9zZSgpO1xuICAgICAgICB0ZXh0ICs9IHN0cjtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gd2Fsayhub2RlKSB7XG4gICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAxKSB7XG4gICAgICAgIHZhciBjbVRleHQgPSBub2RlLmdldEF0dHJpYnV0ZShcImNtLXRleHRcIik7XG4gICAgICAgIGlmIChjbVRleHQpIHtcbiAgICAgICAgICBhZGRUZXh0KGNtVGV4dCk7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1hcmtlcklEID0gbm9kZS5nZXRBdHRyaWJ1dGUoXCJjbS1tYXJrZXJcIiksIHJhbmdlO1xuICAgICAgICBpZiAobWFya2VySUQpIHtcbiAgICAgICAgICB2YXIgZm91bmQgPSBjbS5maW5kTWFya3MoUG9zKGZyb21MaW5lLCAwKSwgUG9zKHRvTGluZSArIDEsIDApLCByZWNvZ25pemVNYXJrZXIoK21hcmtlcklEKSk7XG4gICAgICAgICAgaWYgKGZvdW5kLmxlbmd0aCAmJiAocmFuZ2UgPSBmb3VuZFswXS5maW5kKDApKSlcbiAgICAgICAgICAgIHsgYWRkVGV4dChnZXRCZXR3ZWVuKGNtLmRvYywgcmFuZ2UuZnJvbSwgcmFuZ2UudG8pLmpvaW4obGluZVNlcCkpOyB9XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUuZ2V0QXR0cmlidXRlKFwiY29udGVudGVkaXRhYmxlXCIpID09IFwiZmFsc2VcIikgeyByZXR1cm4gfVxuICAgICAgICB2YXIgaXNCbG9jayA9IC9eKHByZXxkaXZ8cHxsaXx0YWJsZXxicikkL2kudGVzdChub2RlLm5vZGVOYW1lKTtcbiAgICAgICAgaWYgKCEvXmJyJC9pLnRlc3Qobm9kZS5ub2RlTmFtZSkgJiYgbm9kZS50ZXh0Q29udGVudC5sZW5ndGggPT0gMCkgeyByZXR1cm4gfVxuXG4gICAgICAgIGlmIChpc0Jsb2NrKSB7IGNsb3NlKCk7IH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmNoaWxkTm9kZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgeyB3YWxrKG5vZGUuY2hpbGROb2Rlc1tpXSk7IH1cblxuICAgICAgICBpZiAoL14ocHJlfHApJC9pLnRlc3Qobm9kZS5ub2RlTmFtZSkpIHsgZXh0cmFMaW5lYnJlYWsgPSB0cnVlOyB9XG4gICAgICAgIGlmIChpc0Jsb2NrKSB7IGNsb3NpbmcgPSB0cnVlOyB9XG4gICAgICB9IGVsc2UgaWYgKG5vZGUubm9kZVR5cGUgPT0gMykge1xuICAgICAgICBhZGRUZXh0KG5vZGUubm9kZVZhbHVlLnJlcGxhY2UoL1xcdTIwMGIvZywgXCJcIikucmVwbGFjZSgvXFx1MDBhMC9nLCBcIiBcIikpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKDs7KSB7XG4gICAgICB3YWxrKGZyb20pO1xuICAgICAgaWYgKGZyb20gPT0gdG8pIHsgYnJlYWsgfVxuICAgICAgZnJvbSA9IGZyb20ubmV4dFNpYmxpbmc7XG4gICAgICBleHRyYUxpbmVicmVhayA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGV4dFxuICB9XG5cbiAgZnVuY3Rpb24gZG9tVG9Qb3MoY20sIG5vZGUsIG9mZnNldCkge1xuICAgIHZhciBsaW5lTm9kZTtcbiAgICBpZiAobm9kZSA9PSBjbS5kaXNwbGF5LmxpbmVEaXYpIHtcbiAgICAgIGxpbmVOb2RlID0gY20uZGlzcGxheS5saW5lRGl2LmNoaWxkTm9kZXNbb2Zmc2V0XTtcbiAgICAgIGlmICghbGluZU5vZGUpIHsgcmV0dXJuIGJhZFBvcyhjbS5jbGlwUG9zKFBvcyhjbS5kaXNwbGF5LnZpZXdUbyAtIDEpKSwgdHJ1ZSkgfVxuICAgICAgbm9kZSA9IG51bGw7IG9mZnNldCA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAobGluZU5vZGUgPSBub2RlOzsgbGluZU5vZGUgPSBsaW5lTm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICAgIGlmICghbGluZU5vZGUgfHwgbGluZU5vZGUgPT0gY20uZGlzcGxheS5saW5lRGl2KSB7IHJldHVybiBudWxsIH1cbiAgICAgICAgaWYgKGxpbmVOb2RlLnBhcmVudE5vZGUgJiYgbGluZU5vZGUucGFyZW50Tm9kZSA9PSBjbS5kaXNwbGF5LmxpbmVEaXYpIHsgYnJlYWsgfVxuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNtLmRpc3BsYXkudmlldy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGxpbmVWaWV3ID0gY20uZGlzcGxheS52aWV3W2ldO1xuICAgICAgaWYgKGxpbmVWaWV3Lm5vZGUgPT0gbGluZU5vZGUpXG4gICAgICAgIHsgcmV0dXJuIGxvY2F0ZU5vZGVJbkxpbmVWaWV3KGxpbmVWaWV3LCBub2RlLCBvZmZzZXQpIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBsb2NhdGVOb2RlSW5MaW5lVmlldyhsaW5lVmlldywgbm9kZSwgb2Zmc2V0KSB7XG4gICAgdmFyIHdyYXBwZXIgPSBsaW5lVmlldy50ZXh0LmZpcnN0Q2hpbGQsIGJhZCA9IGZhbHNlO1xuICAgIGlmICghbm9kZSB8fCAhY29udGFpbnMod3JhcHBlciwgbm9kZSkpIHsgcmV0dXJuIGJhZFBvcyhQb3MobGluZU5vKGxpbmVWaWV3LmxpbmUpLCAwKSwgdHJ1ZSkgfVxuICAgIGlmIChub2RlID09IHdyYXBwZXIpIHtcbiAgICAgIGJhZCA9IHRydWU7XG4gICAgICBub2RlID0gd3JhcHBlci5jaGlsZE5vZGVzW29mZnNldF07XG4gICAgICBvZmZzZXQgPSAwO1xuICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgIHZhciBsaW5lID0gbGluZVZpZXcucmVzdCA/IGxzdChsaW5lVmlldy5yZXN0KSA6IGxpbmVWaWV3LmxpbmU7XG4gICAgICAgIHJldHVybiBiYWRQb3MoUG9zKGxpbmVObyhsaW5lKSwgbGluZS50ZXh0Lmxlbmd0aCksIGJhZClcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdGV4dE5vZGUgPSBub2RlLm5vZGVUeXBlID09IDMgPyBub2RlIDogbnVsbCwgdG9wTm9kZSA9IG5vZGU7XG4gICAgaWYgKCF0ZXh0Tm9kZSAmJiBub2RlLmNoaWxkTm9kZXMubGVuZ3RoID09IDEgJiYgbm9kZS5maXJzdENoaWxkLm5vZGVUeXBlID09IDMpIHtcbiAgICAgIHRleHROb2RlID0gbm9kZS5maXJzdENoaWxkO1xuICAgICAgaWYgKG9mZnNldCkgeyBvZmZzZXQgPSB0ZXh0Tm9kZS5ub2RlVmFsdWUubGVuZ3RoOyB9XG4gICAgfVxuICAgIHdoaWxlICh0b3BOb2RlLnBhcmVudE5vZGUgIT0gd3JhcHBlcikgeyB0b3BOb2RlID0gdG9wTm9kZS5wYXJlbnROb2RlOyB9XG4gICAgdmFyIG1lYXN1cmUgPSBsaW5lVmlldy5tZWFzdXJlLCBtYXBzID0gbWVhc3VyZS5tYXBzO1xuXG4gICAgZnVuY3Rpb24gZmluZCh0ZXh0Tm9kZSwgdG9wTm9kZSwgb2Zmc2V0KSB7XG4gICAgICBmb3IgKHZhciBpID0gLTE7IGkgPCAobWFwcyA/IG1hcHMubGVuZ3RoIDogMCk7IGkrKykge1xuICAgICAgICB2YXIgbWFwID0gaSA8IDAgPyBtZWFzdXJlLm1hcCA6IG1hcHNbaV07XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWFwLmxlbmd0aDsgaiArPSAzKSB7XG4gICAgICAgICAgdmFyIGN1ck5vZGUgPSBtYXBbaiArIDJdO1xuICAgICAgICAgIGlmIChjdXJOb2RlID09IHRleHROb2RlIHx8IGN1ck5vZGUgPT0gdG9wTm9kZSkge1xuICAgICAgICAgICAgdmFyIGxpbmUgPSBsaW5lTm8oaSA8IDAgPyBsaW5lVmlldy5saW5lIDogbGluZVZpZXcucmVzdFtpXSk7XG4gICAgICAgICAgICB2YXIgY2ggPSBtYXBbal0gKyBvZmZzZXQ7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBjdXJOb2RlICE9IHRleHROb2RlKSB7IGNoID0gbWFwW2ogKyAob2Zmc2V0ID8gMSA6IDApXTsgfVxuICAgICAgICAgICAgcmV0dXJuIFBvcyhsaW5lLCBjaClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGZvdW5kID0gZmluZCh0ZXh0Tm9kZSwgdG9wTm9kZSwgb2Zmc2V0KTtcbiAgICBpZiAoZm91bmQpIHsgcmV0dXJuIGJhZFBvcyhmb3VuZCwgYmFkKSB9XG5cbiAgICAvLyBGSVhNRSB0aGlzIGlzIGFsbCByZWFsbHkgc2hha3kuIG1pZ2h0IGhhbmRsZSB0aGUgZmV3IGNhc2VzIGl0IG5lZWRzIHRvIGhhbmRsZSwgYnV0IGxpa2VseSB0byBjYXVzZSBwcm9ibGVtc1xuICAgIGZvciAodmFyIGFmdGVyID0gdG9wTm9kZS5uZXh0U2libGluZywgZGlzdCA9IHRleHROb2RlID8gdGV4dE5vZGUubm9kZVZhbHVlLmxlbmd0aCAtIG9mZnNldCA6IDA7IGFmdGVyOyBhZnRlciA9IGFmdGVyLm5leHRTaWJsaW5nKSB7XG4gICAgICBmb3VuZCA9IGZpbmQoYWZ0ZXIsIGFmdGVyLmZpcnN0Q2hpbGQsIDApO1xuICAgICAgaWYgKGZvdW5kKVxuICAgICAgICB7IHJldHVybiBiYWRQb3MoUG9zKGZvdW5kLmxpbmUsIGZvdW5kLmNoIC0gZGlzdCksIGJhZCkgfVxuICAgICAgZWxzZVxuICAgICAgICB7IGRpc3QgKz0gYWZ0ZXIudGV4dENvbnRlbnQubGVuZ3RoOyB9XG4gICAgfVxuICAgIGZvciAodmFyIGJlZm9yZSA9IHRvcE5vZGUucHJldmlvdXNTaWJsaW5nLCBkaXN0JDEgPSBvZmZzZXQ7IGJlZm9yZTsgYmVmb3JlID0gYmVmb3JlLnByZXZpb3VzU2libGluZykge1xuICAgICAgZm91bmQgPSBmaW5kKGJlZm9yZSwgYmVmb3JlLmZpcnN0Q2hpbGQsIC0xKTtcbiAgICAgIGlmIChmb3VuZClcbiAgICAgICAgeyByZXR1cm4gYmFkUG9zKFBvcyhmb3VuZC5saW5lLCBmb3VuZC5jaCArIGRpc3QkMSksIGJhZCkgfVxuICAgICAgZWxzZVxuICAgICAgICB7IGRpc3QkMSArPSBiZWZvcmUudGV4dENvbnRlbnQubGVuZ3RoOyB9XG4gICAgfVxuICB9XG5cbiAgLy8gVEVYVEFSRUEgSU5QVVQgU1RZTEVcblxuICB2YXIgVGV4dGFyZWFJbnB1dCA9IGZ1bmN0aW9uKGNtKSB7XG4gICAgdGhpcy5jbSA9IGNtO1xuICAgIC8vIFNlZSBpbnB1dC5wb2xsIGFuZCBpbnB1dC5yZXNldFxuICAgIHRoaXMucHJldklucHV0ID0gXCJcIjtcblxuICAgIC8vIEZsYWcgdGhhdCBpbmRpY2F0ZXMgd2hldGhlciB3ZSBleHBlY3QgaW5wdXQgdG8gYXBwZWFyIHJlYWwgc29vblxuICAgIC8vIG5vdyAoYWZ0ZXIgc29tZSBldmVudCBsaWtlICdrZXlwcmVzcycgb3IgJ2lucHV0JykgYW5kIGFyZVxuICAgIC8vIHBvbGxpbmcgaW50ZW5zaXZlbHkuXG4gICAgdGhpcy5wb2xsaW5nRmFzdCA9IGZhbHNlO1xuICAgIC8vIFNlbGYtcmVzZXR0aW5nIHRpbWVvdXQgZm9yIHRoZSBwb2xsZXJcbiAgICB0aGlzLnBvbGxpbmcgPSBuZXcgRGVsYXllZCgpO1xuICAgIC8vIFVzZWQgdG8gd29yayBhcm91bmQgSUUgaXNzdWUgd2l0aCBzZWxlY3Rpb24gYmVpbmcgZm9yZ290dGVuIHdoZW4gZm9jdXMgbW92ZXMgYXdheSBmcm9tIHRleHRhcmVhXG4gICAgdGhpcy5oYXNTZWxlY3Rpb24gPSBmYWxzZTtcbiAgICB0aGlzLmNvbXBvc2luZyA9IG51bGw7XG4gIH07XG5cbiAgVGV4dGFyZWFJbnB1dC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIChkaXNwbGF5KSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBpbnB1dCA9IHRoaXMsIGNtID0gdGhpcy5jbTtcbiAgICB0aGlzLmNyZWF0ZUZpZWxkKGRpc3BsYXkpO1xuICAgIHZhciB0ZSA9IHRoaXMudGV4dGFyZWE7XG5cbiAgICBkaXNwbGF5LndyYXBwZXIuaW5zZXJ0QmVmb3JlKHRoaXMud3JhcHBlciwgZGlzcGxheS53cmFwcGVyLmZpcnN0Q2hpbGQpO1xuXG4gICAgLy8gTmVlZGVkIHRvIGhpZGUgYmlnIGJsdWUgYmxpbmtpbmcgY3Vyc29yIG9uIE1vYmlsZSBTYWZhcmkgKGRvZXNuJ3Qgc2VlbSB0byB3b3JrIGluIGlPUyA4IGFueW1vcmUpXG4gICAgaWYgKGlvcykgeyB0ZS5zdHlsZS53aWR0aCA9IFwiMHB4XCI7IH1cblxuICAgIG9uKHRlLCBcImlucHV0XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uID49IDkgJiYgdGhpcyQxLmhhc1NlbGVjdGlvbikgeyB0aGlzJDEuaGFzU2VsZWN0aW9uID0gbnVsbDsgfVxuICAgICAgaW5wdXQucG9sbCgpO1xuICAgIH0pO1xuXG4gICAgb24odGUsIFwicGFzdGVcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmIChzaWduYWxET01FdmVudChjbSwgZSkgfHwgaGFuZGxlUGFzdGUoZSwgY20pKSB7IHJldHVybiB9XG5cbiAgICAgIGNtLnN0YXRlLnBhc3RlSW5jb21pbmcgPSArbmV3IERhdGU7XG4gICAgICBpbnB1dC5mYXN0UG9sbCgpO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gcHJlcGFyZUNvcHlDdXQoZSkge1xuICAgICAgaWYgKHNpZ25hbERPTUV2ZW50KGNtLCBlKSkgeyByZXR1cm4gfVxuICAgICAgaWYgKGNtLnNvbWV0aGluZ1NlbGVjdGVkKCkpIHtcbiAgICAgICAgc2V0TGFzdENvcGllZCh7bGluZVdpc2U6IGZhbHNlLCB0ZXh0OiBjbS5nZXRTZWxlY3Rpb25zKCl9KTtcbiAgICAgIH0gZWxzZSBpZiAoIWNtLm9wdGlvbnMubGluZVdpc2VDb3B5Q3V0KSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJhbmdlcyA9IGNvcHlhYmxlUmFuZ2VzKGNtKTtcbiAgICAgICAgc2V0TGFzdENvcGllZCh7bGluZVdpc2U6IHRydWUsIHRleHQ6IHJhbmdlcy50ZXh0fSk7XG4gICAgICAgIGlmIChlLnR5cGUgPT0gXCJjdXRcIikge1xuICAgICAgICAgIGNtLnNldFNlbGVjdGlvbnMocmFuZ2VzLnJhbmdlcywgbnVsbCwgc2VsX2RvbnRTY3JvbGwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlucHV0LnByZXZJbnB1dCA9IFwiXCI7XG4gICAgICAgICAgdGUudmFsdWUgPSByYW5nZXMudGV4dC5qb2luKFwiXFxuXCIpO1xuICAgICAgICAgIHNlbGVjdElucHV0KHRlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGUudHlwZSA9PSBcImN1dFwiKSB7IGNtLnN0YXRlLmN1dEluY29taW5nID0gK25ldyBEYXRlOyB9XG4gICAgfVxuICAgIG9uKHRlLCBcImN1dFwiLCBwcmVwYXJlQ29weUN1dCk7XG4gICAgb24odGUsIFwiY29weVwiLCBwcmVwYXJlQ29weUN1dCk7XG5cbiAgICBvbihkaXNwbGF5LnNjcm9sbGVyLCBcInBhc3RlXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoZXZlbnRJbldpZGdldChkaXNwbGF5LCBlKSB8fCBzaWduYWxET01FdmVudChjbSwgZSkpIHsgcmV0dXJuIH1cbiAgICAgIGlmICghdGUuZGlzcGF0Y2hFdmVudCkge1xuICAgICAgICBjbS5zdGF0ZS5wYXN0ZUluY29taW5nID0gK25ldyBEYXRlO1xuICAgICAgICBpbnB1dC5mb2N1cygpO1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gUGFzcyB0aGUgYHBhc3RlYCBldmVudCB0byB0aGUgdGV4dGFyZWEgc28gaXQncyBoYW5kbGVkIGJ5IGl0cyBldmVudCBsaXN0ZW5lci5cbiAgICAgIHZhciBldmVudCA9IG5ldyBFdmVudChcInBhc3RlXCIpO1xuICAgICAgZXZlbnQuY2xpcGJvYXJkRGF0YSA9IGUuY2xpcGJvYXJkRGF0YTtcbiAgICAgIHRlLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgIH0pO1xuXG4gICAgLy8gUHJldmVudCBub3JtYWwgc2VsZWN0aW9uIGluIHRoZSBlZGl0b3IgKHdlIGhhbmRsZSBvdXIgb3duKVxuICAgIG9uKGRpc3BsYXkubGluZVNwYWNlLCBcInNlbGVjdHN0YXJ0XCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoIWV2ZW50SW5XaWRnZXQoZGlzcGxheSwgZSkpIHsgZV9wcmV2ZW50RGVmYXVsdChlKTsgfVxuICAgIH0pO1xuXG4gICAgb24odGUsIFwiY29tcG9zaXRpb25zdGFydFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc3RhcnQgPSBjbS5nZXRDdXJzb3IoXCJmcm9tXCIpO1xuICAgICAgaWYgKGlucHV0LmNvbXBvc2luZykgeyBpbnB1dC5jb21wb3NpbmcucmFuZ2UuY2xlYXIoKTsgfVxuICAgICAgaW5wdXQuY29tcG9zaW5nID0ge1xuICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgIHJhbmdlOiBjbS5tYXJrVGV4dChzdGFydCwgY20uZ2V0Q3Vyc29yKFwidG9cIiksIHtjbGFzc05hbWU6IFwiQ29kZU1pcnJvci1jb21wb3NpbmdcIn0pXG4gICAgICB9O1xuICAgIH0pO1xuICAgIG9uKHRlLCBcImNvbXBvc2l0aW9uZW5kXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChpbnB1dC5jb21wb3NpbmcpIHtcbiAgICAgICAgaW5wdXQucG9sbCgpO1xuICAgICAgICBpbnB1dC5jb21wb3NpbmcucmFuZ2UuY2xlYXIoKTtcbiAgICAgICAgaW5wdXQuY29tcG9zaW5nID0gbnVsbDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBUZXh0YXJlYUlucHV0LnByb3RvdHlwZS5jcmVhdGVGaWVsZCA9IGZ1bmN0aW9uIChfZGlzcGxheSkge1xuICAgIC8vIFdyYXBzIGFuZCBoaWRlcyBpbnB1dCB0ZXh0YXJlYVxuICAgIHRoaXMud3JhcHBlciA9IGhpZGRlblRleHRhcmVhKCk7XG4gICAgLy8gVGhlIHNlbWloaWRkZW4gdGV4dGFyZWEgdGhhdCBpcyBmb2N1c2VkIHdoZW4gdGhlIGVkaXRvciBpc1xuICAgIC8vIGZvY3VzZWQsIGFuZCByZWNlaXZlcyBpbnB1dC5cbiAgICB0aGlzLnRleHRhcmVhID0gdGhpcy53cmFwcGVyLmZpcnN0Q2hpbGQ7XG4gIH07XG5cbiAgVGV4dGFyZWFJbnB1dC5wcm90b3R5cGUuc2NyZWVuUmVhZGVyTGFiZWxDaGFuZ2VkID0gZnVuY3Rpb24gKGxhYmVsKSB7XG4gICAgLy8gTGFiZWwgZm9yIHNjcmVlbnJlYWRlcnMsIGFjY2Vzc2liaWxpdHlcbiAgICBpZihsYWJlbCkge1xuICAgICAgdGhpcy50ZXh0YXJlYS5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnLCBsYWJlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudGV4dGFyZWEucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWxhYmVsJyk7XG4gICAgfVxuICB9O1xuXG4gIFRleHRhcmVhSW5wdXQucHJvdG90eXBlLnByZXBhcmVTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gUmVkcmF3IHRoZSBzZWxlY3Rpb24gYW5kL29yIGN1cnNvclxuICAgIHZhciBjbSA9IHRoaXMuY20sIGRpc3BsYXkgPSBjbS5kaXNwbGF5LCBkb2MgPSBjbS5kb2M7XG4gICAgdmFyIHJlc3VsdCA9IHByZXBhcmVTZWxlY3Rpb24oY20pO1xuXG4gICAgLy8gTW92ZSB0aGUgaGlkZGVuIHRleHRhcmVhIG5lYXIgdGhlIGN1cnNvciB0byBwcmV2ZW50IHNjcm9sbGluZyBhcnRpZmFjdHNcbiAgICBpZiAoY20ub3B0aW9ucy5tb3ZlSW5wdXRXaXRoQ3Vyc29yKSB7XG4gICAgICB2YXIgaGVhZFBvcyA9IGN1cnNvckNvb3JkcyhjbSwgZG9jLnNlbC5wcmltYXJ5KCkuaGVhZCwgXCJkaXZcIik7XG4gICAgICB2YXIgd3JhcE9mZiA9IGRpc3BsYXkud3JhcHBlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgbGluZU9mZiA9IGRpc3BsYXkubGluZURpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHJlc3VsdC50ZVRvcCA9IE1hdGgubWF4KDAsIE1hdGgubWluKGRpc3BsYXkud3JhcHBlci5jbGllbnRIZWlnaHQgLSAxMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRQb3MudG9wICsgbGluZU9mZi50b3AgLSB3cmFwT2ZmLnRvcCkpO1xuICAgICAgcmVzdWx0LnRlTGVmdCA9IE1hdGgubWF4KDAsIE1hdGgubWluKGRpc3BsYXkud3JhcHBlci5jbGllbnRXaWR0aCAtIDEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRQb3MubGVmdCArIGxpbmVPZmYubGVmdCAtIHdyYXBPZmYubGVmdCkpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRcbiAgfTtcblxuICBUZXh0YXJlYUlucHV0LnByb3RvdHlwZS5zaG93U2VsZWN0aW9uID0gZnVuY3Rpb24gKGRyYXduKSB7XG4gICAgdmFyIGNtID0gdGhpcy5jbSwgZGlzcGxheSA9IGNtLmRpc3BsYXk7XG4gICAgcmVtb3ZlQ2hpbGRyZW5BbmRBZGQoZGlzcGxheS5jdXJzb3JEaXYsIGRyYXduLmN1cnNvcnMpO1xuICAgIHJlbW92ZUNoaWxkcmVuQW5kQWRkKGRpc3BsYXkuc2VsZWN0aW9uRGl2LCBkcmF3bi5zZWxlY3Rpb24pO1xuICAgIGlmIChkcmF3bi50ZVRvcCAhPSBudWxsKSB7XG4gICAgICB0aGlzLndyYXBwZXIuc3R5bGUudG9wID0gZHJhd24udGVUb3AgKyBcInB4XCI7XG4gICAgICB0aGlzLndyYXBwZXIuc3R5bGUubGVmdCA9IGRyYXduLnRlTGVmdCArIFwicHhcIjtcbiAgICB9XG4gIH07XG5cbiAgLy8gUmVzZXQgdGhlIGlucHV0IHRvIGNvcnJlc3BvbmQgdG8gdGhlIHNlbGVjdGlvbiAob3IgdG8gYmUgZW1wdHksXG4gIC8vIHdoZW4gbm90IHR5cGluZyBhbmQgbm90aGluZyBpcyBzZWxlY3RlZClcbiAgVGV4dGFyZWFJbnB1dC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAodHlwaW5nKSB7XG4gICAgaWYgKHRoaXMuY29udGV4dE1lbnVQZW5kaW5nIHx8IHRoaXMuY29tcG9zaW5nKSB7IHJldHVybiB9XG4gICAgdmFyIGNtID0gdGhpcy5jbTtcbiAgICBpZiAoY20uc29tZXRoaW5nU2VsZWN0ZWQoKSkge1xuICAgICAgdGhpcy5wcmV2SW5wdXQgPSBcIlwiO1xuICAgICAgdmFyIGNvbnRlbnQgPSBjbS5nZXRTZWxlY3Rpb24oKTtcbiAgICAgIHRoaXMudGV4dGFyZWEudmFsdWUgPSBjb250ZW50O1xuICAgICAgaWYgKGNtLnN0YXRlLmZvY3VzZWQpIHsgc2VsZWN0SW5wdXQodGhpcy50ZXh0YXJlYSk7IH1cbiAgICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uID49IDkpIHsgdGhpcy5oYXNTZWxlY3Rpb24gPSBjb250ZW50OyB9XG4gICAgfSBlbHNlIGlmICghdHlwaW5nKSB7XG4gICAgICB0aGlzLnByZXZJbnB1dCA9IHRoaXMudGV4dGFyZWEudmFsdWUgPSBcIlwiO1xuICAgICAgaWYgKGllICYmIGllX3ZlcnNpb24gPj0gOSkgeyB0aGlzLmhhc1NlbGVjdGlvbiA9IG51bGw7IH1cbiAgICB9XG4gIH07XG5cbiAgVGV4dGFyZWFJbnB1dC5wcm90b3R5cGUuZ2V0RmllbGQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnRleHRhcmVhIH07XG5cbiAgVGV4dGFyZWFJbnB1dC5wcm90b3R5cGUuc3VwcG9ydHNUb3VjaCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZhbHNlIH07XG5cbiAgVGV4dGFyZWFJbnB1dC5wcm90b3R5cGUuZm9jdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuY20ub3B0aW9ucy5yZWFkT25seSAhPSBcIm5vY3Vyc29yXCIgJiYgKCFtb2JpbGUgfHwgYWN0aXZlRWx0KCkgIT0gdGhpcy50ZXh0YXJlYSkpIHtcbiAgICAgIHRyeSB7IHRoaXMudGV4dGFyZWEuZm9jdXMoKTsgfVxuICAgICAgY2F0Y2ggKGUpIHt9IC8vIElFOCB3aWxsIHRocm93IGlmIHRoZSB0ZXh0YXJlYSBpcyBkaXNwbGF5OiBub25lIG9yIG5vdCBpbiBET01cbiAgICB9XG4gIH07XG5cbiAgVGV4dGFyZWFJbnB1dC5wcm90b3R5cGUuYmx1ciA9IGZ1bmN0aW9uICgpIHsgdGhpcy50ZXh0YXJlYS5ibHVyKCk7IH07XG5cbiAgVGV4dGFyZWFJbnB1dC5wcm90b3R5cGUucmVzZXRQb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLndyYXBwZXIuc3R5bGUudG9wID0gdGhpcy53cmFwcGVyLnN0eWxlLmxlZnQgPSAwO1xuICB9O1xuXG4gIFRleHRhcmVhSW5wdXQucHJvdG90eXBlLnJlY2VpdmVkRm9jdXMgPSBmdW5jdGlvbiAoKSB7IHRoaXMuc2xvd1BvbGwoKTsgfTtcblxuICAvLyBQb2xsIGZvciBpbnB1dCBjaGFuZ2VzLCB1c2luZyB0aGUgbm9ybWFsIHJhdGUgb2YgcG9sbGluZy4gVGhpc1xuICAvLyBydW5zIGFzIGxvbmcgYXMgdGhlIGVkaXRvciBpcyBmb2N1c2VkLlxuICBUZXh0YXJlYUlucHV0LnByb3RvdHlwZS5zbG93UG9sbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgaWYgKHRoaXMucG9sbGluZ0Zhc3QpIHsgcmV0dXJuIH1cbiAgICB0aGlzLnBvbGxpbmcuc2V0KHRoaXMuY20ub3B0aW9ucy5wb2xsSW50ZXJ2YWwsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMkMS5wb2xsKCk7XG4gICAgICBpZiAodGhpcyQxLmNtLnN0YXRlLmZvY3VzZWQpIHsgdGhpcyQxLnNsb3dQb2xsKCk7IH1cbiAgICB9KTtcbiAgfTtcblxuICAvLyBXaGVuIGFuIGV2ZW50IGhhcyBqdXN0IGNvbWUgaW4gdGhhdCBpcyBsaWtlbHkgdG8gYWRkIG9yIGNoYW5nZVxuICAvLyBzb21ldGhpbmcgaW4gdGhlIGlucHV0IHRleHRhcmVhLCB3ZSBwb2xsIGZhc3RlciwgdG8gZW5zdXJlIHRoYXRcbiAgLy8gdGhlIGNoYW5nZSBhcHBlYXJzIG9uIHRoZSBzY3JlZW4gcXVpY2tseS5cbiAgVGV4dGFyZWFJbnB1dC5wcm90b3R5cGUuZmFzdFBvbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1pc3NlZCA9IGZhbHNlLCBpbnB1dCA9IHRoaXM7XG4gICAgaW5wdXQucG9sbGluZ0Zhc3QgPSB0cnVlO1xuICAgIGZ1bmN0aW9uIHAoKSB7XG4gICAgICB2YXIgY2hhbmdlZCA9IGlucHV0LnBvbGwoKTtcbiAgICAgIGlmICghY2hhbmdlZCAmJiAhbWlzc2VkKSB7bWlzc2VkID0gdHJ1ZTsgaW5wdXQucG9sbGluZy5zZXQoNjAsIHApO31cbiAgICAgIGVsc2Uge2lucHV0LnBvbGxpbmdGYXN0ID0gZmFsc2U7IGlucHV0LnNsb3dQb2xsKCk7fVxuICAgIH1cbiAgICBpbnB1dC5wb2xsaW5nLnNldCgyMCwgcCk7XG4gIH07XG5cbiAgLy8gUmVhZCBpbnB1dCBmcm9tIHRoZSB0ZXh0YXJlYSwgYW5kIHVwZGF0ZSB0aGUgZG9jdW1lbnQgdG8gbWF0Y2guXG4gIC8vIFdoZW4gc29tZXRoaW5nIGlzIHNlbGVjdGVkLCBpdCBpcyBwcmVzZW50IGluIHRoZSB0ZXh0YXJlYSwgYW5kXG4gIC8vIHNlbGVjdGVkICh1bmxlc3MgaXQgaXMgaHVnZSwgaW4gd2hpY2ggY2FzZSBhIHBsYWNlaG9sZGVyIGlzXG4gIC8vIHVzZWQpLiBXaGVuIG5vdGhpbmcgaXMgc2VsZWN0ZWQsIHRoZSBjdXJzb3Igc2l0cyBhZnRlciBwcmV2aW91c2x5XG4gIC8vIHNlZW4gdGV4dCAoY2FuIGJlIGVtcHR5KSwgd2hpY2ggaXMgc3RvcmVkIGluIHByZXZJbnB1dCAod2UgbXVzdFxuICAvLyBub3QgcmVzZXQgdGhlIHRleHRhcmVhIHdoZW4gdHlwaW5nLCBiZWNhdXNlIHRoYXQgYnJlYWtzIElNRSkuXG4gIFRleHRhcmVhSW5wdXQucHJvdG90eXBlLnBvbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBjbSA9IHRoaXMuY20sIGlucHV0ID0gdGhpcy50ZXh0YXJlYSwgcHJldklucHV0ID0gdGhpcy5wcmV2SW5wdXQ7XG4gICAgLy8gU2luY2UgdGhpcyBpcyBjYWxsZWQgYSAqbG90KiwgdHJ5IHRvIGJhaWwgb3V0IGFzIGNoZWFwbHkgYXNcbiAgICAvLyBwb3NzaWJsZSB3aGVuIGl0IGlzIGNsZWFyIHRoYXQgbm90aGluZyBoYXBwZW5lZC4gaGFzU2VsZWN0aW9uXG4gICAgLy8gd2lsbCBiZSB0aGUgY2FzZSB3aGVuIHRoZXJlIGlzIGEgbG90IG9mIHRleHQgaW4gdGhlIHRleHRhcmVhLFxuICAgIC8vIGluIHdoaWNoIGNhc2UgcmVhZGluZyBpdHMgdmFsdWUgd291bGQgYmUgZXhwZW5zaXZlLlxuICAgIGlmICh0aGlzLmNvbnRleHRNZW51UGVuZGluZyB8fCAhY20uc3RhdGUuZm9jdXNlZCB8fFxuICAgICAgICAoaGFzU2VsZWN0aW9uKGlucHV0KSAmJiAhcHJldklucHV0ICYmICF0aGlzLmNvbXBvc2luZykgfHxcbiAgICAgICAgY20uaXNSZWFkT25seSgpIHx8IGNtLm9wdGlvbnMuZGlzYWJsZUlucHV0IHx8IGNtLnN0YXRlLmtleVNlcSlcbiAgICAgIHsgcmV0dXJuIGZhbHNlIH1cblxuICAgIHZhciB0ZXh0ID0gaW5wdXQudmFsdWU7XG4gICAgLy8gSWYgbm90aGluZyBjaGFuZ2VkLCBiYWlsLlxuICAgIGlmICh0ZXh0ID09IHByZXZJbnB1dCAmJiAhY20uc29tZXRoaW5nU2VsZWN0ZWQoKSkgeyByZXR1cm4gZmFsc2UgfVxuICAgIC8vIFdvcmsgYXJvdW5kIG5vbnNlbnNpY2FsIHNlbGVjdGlvbiByZXNldHRpbmcgaW4gSUU5LzEwLCBhbmRcbiAgICAvLyBpbmV4cGxpY2FibGUgYXBwZWFyYW5jZSBvZiBwcml2YXRlIGFyZWEgdW5pY29kZSBjaGFyYWN0ZXJzIG9uXG4gICAgLy8gc29tZSBrZXkgY29tYm9zIGluIE1hYyAoIzI2ODkpLlxuICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uID49IDkgJiYgdGhpcy5oYXNTZWxlY3Rpb24gPT09IHRleHQgfHxcbiAgICAgICAgbWFjICYmIC9bXFx1ZjcwMC1cXHVmN2ZmXS8udGVzdCh0ZXh0KSkge1xuICAgICAgY20uZGlzcGxheS5pbnB1dC5yZXNldCgpO1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgaWYgKGNtLmRvYy5zZWwgPT0gY20uZGlzcGxheS5zZWxGb3JDb250ZXh0TWVudSkge1xuICAgICAgdmFyIGZpcnN0ID0gdGV4dC5jaGFyQ29kZUF0KDApO1xuICAgICAgaWYgKGZpcnN0ID09IDB4MjAwYiAmJiAhcHJldklucHV0KSB7IHByZXZJbnB1dCA9IFwiXFx1MjAwYlwiOyB9XG4gICAgICBpZiAoZmlyc3QgPT0gMHgyMWRhKSB7IHRoaXMucmVzZXQoKTsgcmV0dXJuIHRoaXMuY20uZXhlY0NvbW1hbmQoXCJ1bmRvXCIpIH1cbiAgICB9XG4gICAgLy8gRmluZCB0aGUgcGFydCBvZiB0aGUgaW5wdXQgdGhhdCBpcyBhY3R1YWxseSBuZXdcbiAgICB2YXIgc2FtZSA9IDAsIGwgPSBNYXRoLm1pbihwcmV2SW5wdXQubGVuZ3RoLCB0ZXh0Lmxlbmd0aCk7XG4gICAgd2hpbGUgKHNhbWUgPCBsICYmIHByZXZJbnB1dC5jaGFyQ29kZUF0KHNhbWUpID09IHRleHQuY2hhckNvZGVBdChzYW1lKSkgeyArK3NhbWU7IH1cblxuICAgIHJ1bkluT3AoY20sIGZ1bmN0aW9uICgpIHtcbiAgICAgIGFwcGx5VGV4dElucHV0KGNtLCB0ZXh0LnNsaWNlKHNhbWUpLCBwcmV2SW5wdXQubGVuZ3RoIC0gc2FtZSxcbiAgICAgICAgICAgICAgICAgICAgIG51bGwsIHRoaXMkMS5jb21wb3NpbmcgPyBcIipjb21wb3NlXCIgOiBudWxsKTtcblxuICAgICAgLy8gRG9uJ3QgbGVhdmUgbG9uZyB0ZXh0IGluIHRoZSB0ZXh0YXJlYSwgc2luY2UgaXQgbWFrZXMgZnVydGhlciBwb2xsaW5nIHNsb3dcbiAgICAgIGlmICh0ZXh0Lmxlbmd0aCA+IDEwMDAgfHwgdGV4dC5pbmRleE9mKFwiXFxuXCIpID4gLTEpIHsgaW5wdXQudmFsdWUgPSB0aGlzJDEucHJldklucHV0ID0gXCJcIjsgfVxuICAgICAgZWxzZSB7IHRoaXMkMS5wcmV2SW5wdXQgPSB0ZXh0OyB9XG5cbiAgICAgIGlmICh0aGlzJDEuY29tcG9zaW5nKSB7XG4gICAgICAgIHRoaXMkMS5jb21wb3NpbmcucmFuZ2UuY2xlYXIoKTtcbiAgICAgICAgdGhpcyQxLmNvbXBvc2luZy5yYW5nZSA9IGNtLm1hcmtUZXh0KHRoaXMkMS5jb21wb3Npbmcuc3RhcnQsIGNtLmdldEN1cnNvcihcInRvXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtjbGFzc05hbWU6IFwiQ29kZU1pcnJvci1jb21wb3NpbmdcIn0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB0cnVlXG4gIH07XG5cbiAgVGV4dGFyZWFJbnB1dC5wcm90b3R5cGUuZW5zdXJlUG9sbGVkID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnBvbGxpbmdGYXN0ICYmIHRoaXMucG9sbCgpKSB7IHRoaXMucG9sbGluZ0Zhc3QgPSBmYWxzZTsgfVxuICB9O1xuXG4gIFRleHRhcmVhSW5wdXQucHJvdG90eXBlLm9uS2V5UHJlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGllICYmIGllX3ZlcnNpb24gPj0gOSkgeyB0aGlzLmhhc1NlbGVjdGlvbiA9IG51bGw7IH1cbiAgICB0aGlzLmZhc3RQb2xsKCk7XG4gIH07XG5cbiAgVGV4dGFyZWFJbnB1dC5wcm90b3R5cGUub25Db250ZXh0TWVudSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIGlucHV0ID0gdGhpcywgY20gPSBpbnB1dC5jbSwgZGlzcGxheSA9IGNtLmRpc3BsYXksIHRlID0gaW5wdXQudGV4dGFyZWE7XG4gICAgaWYgKGlucHV0LmNvbnRleHRNZW51UGVuZGluZykgeyBpbnB1dC5jb250ZXh0TWVudVBlbmRpbmcoKTsgfVxuICAgIHZhciBwb3MgPSBwb3NGcm9tTW91c2UoY20sIGUpLCBzY3JvbGxQb3MgPSBkaXNwbGF5LnNjcm9sbGVyLnNjcm9sbFRvcDtcbiAgICBpZiAoIXBvcyB8fCBwcmVzdG8pIHsgcmV0dXJuIH0gLy8gT3BlcmEgaXMgZGlmZmljdWx0LlxuXG4gICAgLy8gUmVzZXQgdGhlIGN1cnJlbnQgdGV4dCBzZWxlY3Rpb24gb25seSBpZiB0aGUgY2xpY2sgaXMgZG9uZSBvdXRzaWRlIG9mIHRoZSBzZWxlY3Rpb25cbiAgICAvLyBhbmQgJ3Jlc2V0U2VsZWN0aW9uT25Db250ZXh0TWVudScgb3B0aW9uIGlzIHRydWUuXG4gICAgdmFyIHJlc2V0ID0gY20ub3B0aW9ucy5yZXNldFNlbGVjdGlvbk9uQ29udGV4dE1lbnU7XG4gICAgaWYgKHJlc2V0ICYmIGNtLmRvYy5zZWwuY29udGFpbnMocG9zKSA9PSAtMSlcbiAgICAgIHsgb3BlcmF0aW9uKGNtLCBzZXRTZWxlY3Rpb24pKGNtLmRvYywgc2ltcGxlU2VsZWN0aW9uKHBvcyksIHNlbF9kb250U2Nyb2xsKTsgfVxuXG4gICAgdmFyIG9sZENTUyA9IHRlLnN0eWxlLmNzc1RleHQsIG9sZFdyYXBwZXJDU1MgPSBpbnB1dC53cmFwcGVyLnN0eWxlLmNzc1RleHQ7XG4gICAgdmFyIHdyYXBwZXJCb3ggPSBpbnB1dC53cmFwcGVyLm9mZnNldFBhcmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBpbnB1dC53cmFwcGVyLnN0eWxlLmNzc1RleHQgPSBcInBvc2l0aW9uOiBzdGF0aWNcIjtcbiAgICB0ZS5zdHlsZS5jc3NUZXh0ID0gXCJwb3NpdGlvbjogYWJzb2x1dGU7IHdpZHRoOiAzMHB4OyBoZWlnaHQ6IDMwcHg7XFxuICAgICAgdG9wOiBcIiArIChlLmNsaWVudFkgLSB3cmFwcGVyQm94LnRvcCAtIDUpICsgXCJweDsgbGVmdDogXCIgKyAoZS5jbGllbnRYIC0gd3JhcHBlckJveC5sZWZ0IC0gNSkgKyBcInB4O1xcbiAgICAgIHotaW5kZXg6IDEwMDA7IGJhY2tncm91bmQ6IFwiICsgKGllID8gXCJyZ2JhKDI1NSwgMjU1LCAyNTUsIC4wNSlcIiA6IFwidHJhbnNwYXJlbnRcIikgKyBcIjtcXG4gICAgICBvdXRsaW5lOiBub25lOyBib3JkZXItd2lkdGg6IDA7IG91dGxpbmU6IG5vbmU7IG92ZXJmbG93OiBoaWRkZW47IG9wYWNpdHk6IC4wNTsgZmlsdGVyOiBhbHBoYShvcGFjaXR5PTUpO1wiO1xuICAgIHZhciBvbGRTY3JvbGxZO1xuICAgIGlmICh3ZWJraXQpIHsgb2xkU2Nyb2xsWSA9IHdpbmRvdy5zY3JvbGxZOyB9IC8vIFdvcmsgYXJvdW5kIENocm9tZSBpc3N1ZSAoIzI3MTIpXG4gICAgZGlzcGxheS5pbnB1dC5mb2N1cygpO1xuICAgIGlmICh3ZWJraXQpIHsgd2luZG93LnNjcm9sbFRvKG51bGwsIG9sZFNjcm9sbFkpOyB9XG4gICAgZGlzcGxheS5pbnB1dC5yZXNldCgpO1xuICAgIC8vIEFkZHMgXCJTZWxlY3QgYWxsXCIgdG8gY29udGV4dCBtZW51IGluIEZGXG4gICAgaWYgKCFjbS5zb21ldGhpbmdTZWxlY3RlZCgpKSB7IHRlLnZhbHVlID0gaW5wdXQucHJldklucHV0ID0gXCIgXCI7IH1cbiAgICBpbnB1dC5jb250ZXh0TWVudVBlbmRpbmcgPSByZWhpZGU7XG4gICAgZGlzcGxheS5zZWxGb3JDb250ZXh0TWVudSA9IGNtLmRvYy5zZWw7XG4gICAgY2xlYXJUaW1lb3V0KGRpc3BsYXkuZGV0ZWN0aW5nU2VsZWN0QWxsKTtcblxuICAgIC8vIFNlbGVjdC1hbGwgd2lsbCBiZSBncmV5ZWQgb3V0IGlmIHRoZXJlJ3Mgbm90aGluZyB0byBzZWxlY3QsIHNvXG4gICAgLy8gdGhpcyBhZGRzIGEgemVyby13aWR0aCBzcGFjZSBzbyB0aGF0IHdlIGNhbiBsYXRlciBjaGVjayB3aGV0aGVyXG4gICAgLy8gaXQgZ290IHNlbGVjdGVkLlxuICAgIGZ1bmN0aW9uIHByZXBhcmVTZWxlY3RBbGxIYWNrKCkge1xuICAgICAgaWYgKHRlLnNlbGVjdGlvblN0YXJ0ICE9IG51bGwpIHtcbiAgICAgICAgdmFyIHNlbGVjdGVkID0gY20uc29tZXRoaW5nU2VsZWN0ZWQoKTtcbiAgICAgICAgdmFyIGV4dHZhbCA9IFwiXFx1MjAwYlwiICsgKHNlbGVjdGVkID8gdGUudmFsdWUgOiBcIlwiKTtcbiAgICAgICAgdGUudmFsdWUgPSBcIlxcdTIxZGFcIjsgLy8gVXNlZCB0byBjYXRjaCBjb250ZXh0LW1lbnUgdW5kb1xuICAgICAgICB0ZS52YWx1ZSA9IGV4dHZhbDtcbiAgICAgICAgaW5wdXQucHJldklucHV0ID0gc2VsZWN0ZWQgPyBcIlwiIDogXCJcXHUyMDBiXCI7XG4gICAgICAgIHRlLnNlbGVjdGlvblN0YXJ0ID0gMTsgdGUuc2VsZWN0aW9uRW5kID0gZXh0dmFsLmxlbmd0aDtcbiAgICAgICAgLy8gUmUtc2V0IHRoaXMsIGluIGNhc2Ugc29tZSBvdGhlciBoYW5kbGVyIHRvdWNoZWQgdGhlXG4gICAgICAgIC8vIHNlbGVjdGlvbiBpbiB0aGUgbWVhbnRpbWUuXG4gICAgICAgIGRpc3BsYXkuc2VsRm9yQ29udGV4dE1lbnUgPSBjbS5kb2Muc2VsO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZWhpZGUoKSB7XG4gICAgICBpZiAoaW5wdXQuY29udGV4dE1lbnVQZW5kaW5nICE9IHJlaGlkZSkgeyByZXR1cm4gfVxuICAgICAgaW5wdXQuY29udGV4dE1lbnVQZW5kaW5nID0gZmFsc2U7XG4gICAgICBpbnB1dC53cmFwcGVyLnN0eWxlLmNzc1RleHQgPSBvbGRXcmFwcGVyQ1NTO1xuICAgICAgdGUuc3R5bGUuY3NzVGV4dCA9IG9sZENTUztcbiAgICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDwgOSkgeyBkaXNwbGF5LnNjcm9sbGJhcnMuc2V0U2Nyb2xsVG9wKGRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsVG9wID0gc2Nyb2xsUG9zKTsgfVxuXG4gICAgICAvLyBUcnkgdG8gZGV0ZWN0IHRoZSB1c2VyIGNob29zaW5nIHNlbGVjdC1hbGxcbiAgICAgIGlmICh0ZS5zZWxlY3Rpb25TdGFydCAhPSBudWxsKSB7XG4gICAgICAgIGlmICghaWUgfHwgKGllICYmIGllX3ZlcnNpb24gPCA5KSkgeyBwcmVwYXJlU2VsZWN0QWxsSGFjaygpOyB9XG4gICAgICAgIHZhciBpID0gMCwgcG9sbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoZGlzcGxheS5zZWxGb3JDb250ZXh0TWVudSA9PSBjbS5kb2Muc2VsICYmIHRlLnNlbGVjdGlvblN0YXJ0ID09IDAgJiZcbiAgICAgICAgICAgICAgdGUuc2VsZWN0aW9uRW5kID4gMCAmJiBpbnB1dC5wcmV2SW5wdXQgPT0gXCJcXHUyMDBiXCIpIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbihjbSwgc2VsZWN0QWxsKShjbSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChpKysgPCAxMCkge1xuICAgICAgICAgICAgZGlzcGxheS5kZXRlY3RpbmdTZWxlY3RBbGwgPSBzZXRUaW1lb3V0KHBvbGwsIDUwMCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRpc3BsYXkuc2VsRm9yQ29udGV4dE1lbnUgPSBudWxsO1xuICAgICAgICAgICAgZGlzcGxheS5pbnB1dC5yZXNldCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZGlzcGxheS5kZXRlY3RpbmdTZWxlY3RBbGwgPSBzZXRUaW1lb3V0KHBvbGwsIDIwMCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGllICYmIGllX3ZlcnNpb24gPj0gOSkgeyBwcmVwYXJlU2VsZWN0QWxsSGFjaygpOyB9XG4gICAgaWYgKGNhcHR1cmVSaWdodENsaWNrKSB7XG4gICAgICBlX3N0b3AoZSk7XG4gICAgICB2YXIgbW91c2V1cCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgb2ZmKHdpbmRvdywgXCJtb3VzZXVwXCIsIG1vdXNldXApO1xuICAgICAgICBzZXRUaW1lb3V0KHJlaGlkZSwgMjApO1xuICAgICAgfTtcbiAgICAgIG9uKHdpbmRvdywgXCJtb3VzZXVwXCIsIG1vdXNldXApO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRUaW1lb3V0KHJlaGlkZSwgNTApO1xuICAgIH1cbiAgfTtcblxuICBUZXh0YXJlYUlucHV0LnByb3RvdHlwZS5yZWFkT25seUNoYW5nZWQgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgaWYgKCF2YWwpIHsgdGhpcy5yZXNldCgpOyB9XG4gICAgdGhpcy50ZXh0YXJlYS5kaXNhYmxlZCA9IHZhbCA9PSBcIm5vY3Vyc29yXCI7XG4gICAgdGhpcy50ZXh0YXJlYS5yZWFkT25seSA9ICEhdmFsO1xuICB9O1xuXG4gIFRleHRhcmVhSW5wdXQucHJvdG90eXBlLnNldFVuZWRpdGFibGUgPSBmdW5jdGlvbiAoKSB7fTtcblxuICBUZXh0YXJlYUlucHV0LnByb3RvdHlwZS5uZWVkc0NvbnRlbnRBdHRyaWJ1dGUgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBmcm9tVGV4dEFyZWEodGV4dGFyZWEsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyA/IGNvcHlPYmoob3B0aW9ucykgOiB7fTtcbiAgICBvcHRpb25zLnZhbHVlID0gdGV4dGFyZWEudmFsdWU7XG4gICAgaWYgKCFvcHRpb25zLnRhYmluZGV4ICYmIHRleHRhcmVhLnRhYkluZGV4KVxuICAgICAgeyBvcHRpb25zLnRhYmluZGV4ID0gdGV4dGFyZWEudGFiSW5kZXg7IH1cbiAgICBpZiAoIW9wdGlvbnMucGxhY2Vob2xkZXIgJiYgdGV4dGFyZWEucGxhY2Vob2xkZXIpXG4gICAgICB7IG9wdGlvbnMucGxhY2Vob2xkZXIgPSB0ZXh0YXJlYS5wbGFjZWhvbGRlcjsgfVxuICAgIC8vIFNldCBhdXRvZm9jdXMgdG8gdHJ1ZSBpZiB0aGlzIHRleHRhcmVhIGlzIGZvY3VzZWQsIG9yIGlmIGl0IGhhc1xuICAgIC8vIGF1dG9mb2N1cyBhbmQgbm8gb3RoZXIgZWxlbWVudCBpcyBmb2N1c2VkLlxuICAgIGlmIChvcHRpb25zLmF1dG9mb2N1cyA9PSBudWxsKSB7XG4gICAgICB2YXIgaGFzRm9jdXMgPSBhY3RpdmVFbHQoKTtcbiAgICAgIG9wdGlvbnMuYXV0b2ZvY3VzID0gaGFzRm9jdXMgPT0gdGV4dGFyZWEgfHxcbiAgICAgICAgdGV4dGFyZWEuZ2V0QXR0cmlidXRlKFwiYXV0b2ZvY3VzXCIpICE9IG51bGwgJiYgaGFzRm9jdXMgPT0gZG9jdW1lbnQuYm9keTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzYXZlKCkge3RleHRhcmVhLnZhbHVlID0gY20uZ2V0VmFsdWUoKTt9XG5cbiAgICB2YXIgcmVhbFN1Ym1pdDtcbiAgICBpZiAodGV4dGFyZWEuZm9ybSkge1xuICAgICAgb24odGV4dGFyZWEuZm9ybSwgXCJzdWJtaXRcIiwgc2F2ZSk7XG4gICAgICAvLyBEZXBsb3JhYmxlIGhhY2sgdG8gbWFrZSB0aGUgc3VibWl0IG1ldGhvZCBkbyB0aGUgcmlnaHQgdGhpbmcuXG4gICAgICBpZiAoIW9wdGlvbnMubGVhdmVTdWJtaXRNZXRob2RBbG9uZSkge1xuICAgICAgICB2YXIgZm9ybSA9IHRleHRhcmVhLmZvcm07XG4gICAgICAgIHJlYWxTdWJtaXQgPSBmb3JtLnN1Ym1pdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgd3JhcHBlZFN1Ym1pdCA9IGZvcm0uc3VibWl0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc2F2ZSgpO1xuICAgICAgICAgICAgZm9ybS5zdWJtaXQgPSByZWFsU3VibWl0O1xuICAgICAgICAgICAgZm9ybS5zdWJtaXQoKTtcbiAgICAgICAgICAgIGZvcm0uc3VibWl0ID0gd3JhcHBlZFN1Ym1pdDtcbiAgICAgICAgICB9O1xuICAgICAgICB9IGNhdGNoKGUpIHt9XG4gICAgICB9XG4gICAgfVxuXG4gICAgb3B0aW9ucy5maW5pc2hJbml0ID0gZnVuY3Rpb24gKGNtKSB7XG4gICAgICBjbS5zYXZlID0gc2F2ZTtcbiAgICAgIGNtLmdldFRleHRBcmVhID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGV4dGFyZWE7IH07XG4gICAgICBjbS50b1RleHRBcmVhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjbS50b1RleHRBcmVhID0gaXNOYU47IC8vIFByZXZlbnQgdGhpcyBmcm9tIGJlaW5nIHJhbiB0d2ljZVxuICAgICAgICBzYXZlKCk7XG4gICAgICAgIHRleHRhcmVhLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY20uZ2V0V3JhcHBlckVsZW1lbnQoKSk7XG4gICAgICAgIHRleHRhcmVhLnN0eWxlLmRpc3BsYXkgPSBcIlwiO1xuICAgICAgICBpZiAodGV4dGFyZWEuZm9ybSkge1xuICAgICAgICAgIG9mZih0ZXh0YXJlYS5mb3JtLCBcInN1Ym1pdFwiLCBzYXZlKTtcbiAgICAgICAgICBpZiAoIW9wdGlvbnMubGVhdmVTdWJtaXRNZXRob2RBbG9uZSAmJiB0eXBlb2YgdGV4dGFyZWEuZm9ybS5zdWJtaXQgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgeyB0ZXh0YXJlYS5mb3JtLnN1Ym1pdCA9IHJlYWxTdWJtaXQ7IH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdGV4dGFyZWEuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgIHZhciBjbSA9IENvZGVNaXJyb3IoZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIHRleHRhcmVhLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5vZGUsIHRleHRhcmVhLm5leHRTaWJsaW5nKTsgfSxcbiAgICAgIG9wdGlvbnMpO1xuICAgIHJldHVybiBjbVxuICB9XG5cbiAgZnVuY3Rpb24gYWRkTGVnYWN5UHJvcHMoQ29kZU1pcnJvcikge1xuICAgIENvZGVNaXJyb3Iub2ZmID0gb2ZmO1xuICAgIENvZGVNaXJyb3Iub24gPSBvbjtcbiAgICBDb2RlTWlycm9yLndoZWVsRXZlbnRQaXhlbHMgPSB3aGVlbEV2ZW50UGl4ZWxzO1xuICAgIENvZGVNaXJyb3IuRG9jID0gRG9jO1xuICAgIENvZGVNaXJyb3Iuc3BsaXRMaW5lcyA9IHNwbGl0TGluZXNBdXRvO1xuICAgIENvZGVNaXJyb3IuY291bnRDb2x1bW4gPSBjb3VudENvbHVtbjtcbiAgICBDb2RlTWlycm9yLmZpbmRDb2x1bW4gPSBmaW5kQ29sdW1uO1xuICAgIENvZGVNaXJyb3IuaXNXb3JkQ2hhciA9IGlzV29yZENoYXJCYXNpYztcbiAgICBDb2RlTWlycm9yLlBhc3MgPSBQYXNzO1xuICAgIENvZGVNaXJyb3Iuc2lnbmFsID0gc2lnbmFsO1xuICAgIENvZGVNaXJyb3IuTGluZSA9IExpbmU7XG4gICAgQ29kZU1pcnJvci5jaGFuZ2VFbmQgPSBjaGFuZ2VFbmQ7XG4gICAgQ29kZU1pcnJvci5zY3JvbGxiYXJNb2RlbCA9IHNjcm9sbGJhck1vZGVsO1xuICAgIENvZGVNaXJyb3IuUG9zID0gUG9zO1xuICAgIENvZGVNaXJyb3IuY21wUG9zID0gY21wO1xuICAgIENvZGVNaXJyb3IubW9kZXMgPSBtb2RlcztcbiAgICBDb2RlTWlycm9yLm1pbWVNb2RlcyA9IG1pbWVNb2RlcztcbiAgICBDb2RlTWlycm9yLnJlc29sdmVNb2RlID0gcmVzb2x2ZU1vZGU7XG4gICAgQ29kZU1pcnJvci5nZXRNb2RlID0gZ2V0TW9kZTtcbiAgICBDb2RlTWlycm9yLm1vZGVFeHRlbnNpb25zID0gbW9kZUV4dGVuc2lvbnM7XG4gICAgQ29kZU1pcnJvci5leHRlbmRNb2RlID0gZXh0ZW5kTW9kZTtcbiAgICBDb2RlTWlycm9yLmNvcHlTdGF0ZSA9IGNvcHlTdGF0ZTtcbiAgICBDb2RlTWlycm9yLnN0YXJ0U3RhdGUgPSBzdGFydFN0YXRlO1xuICAgIENvZGVNaXJyb3IuaW5uZXJNb2RlID0gaW5uZXJNb2RlO1xuICAgIENvZGVNaXJyb3IuY29tbWFuZHMgPSBjb21tYW5kcztcbiAgICBDb2RlTWlycm9yLmtleU1hcCA9IGtleU1hcDtcbiAgICBDb2RlTWlycm9yLmtleU5hbWUgPSBrZXlOYW1lO1xuICAgIENvZGVNaXJyb3IuaXNNb2RpZmllcktleSA9IGlzTW9kaWZpZXJLZXk7XG4gICAgQ29kZU1pcnJvci5sb29rdXBLZXkgPSBsb29rdXBLZXk7XG4gICAgQ29kZU1pcnJvci5ub3JtYWxpemVLZXlNYXAgPSBub3JtYWxpemVLZXlNYXA7XG4gICAgQ29kZU1pcnJvci5TdHJpbmdTdHJlYW0gPSBTdHJpbmdTdHJlYW07XG4gICAgQ29kZU1pcnJvci5TaGFyZWRUZXh0TWFya2VyID0gU2hhcmVkVGV4dE1hcmtlcjtcbiAgICBDb2RlTWlycm9yLlRleHRNYXJrZXIgPSBUZXh0TWFya2VyO1xuICAgIENvZGVNaXJyb3IuTGluZVdpZGdldCA9IExpbmVXaWRnZXQ7XG4gICAgQ29kZU1pcnJvci5lX3ByZXZlbnREZWZhdWx0ID0gZV9wcmV2ZW50RGVmYXVsdDtcbiAgICBDb2RlTWlycm9yLmVfc3RvcFByb3BhZ2F0aW9uID0gZV9zdG9wUHJvcGFnYXRpb247XG4gICAgQ29kZU1pcnJvci5lX3N0b3AgPSBlX3N0b3A7XG4gICAgQ29kZU1pcnJvci5hZGRDbGFzcyA9IGFkZENsYXNzO1xuICAgIENvZGVNaXJyb3IuY29udGFpbnMgPSBjb250YWlucztcbiAgICBDb2RlTWlycm9yLnJtQ2xhc3MgPSBybUNsYXNzO1xuICAgIENvZGVNaXJyb3Iua2V5TmFtZXMgPSBrZXlOYW1lcztcbiAgfVxuXG4gIC8vIEVESVRPUiBDT05TVFJVQ1RPUlxuXG4gIGRlZmluZU9wdGlvbnMoQ29kZU1pcnJvcik7XG5cbiAgYWRkRWRpdG9yTWV0aG9kcyhDb2RlTWlycm9yKTtcblxuICAvLyBTZXQgdXAgbWV0aG9kcyBvbiBDb2RlTWlycm9yJ3MgcHJvdG90eXBlIHRvIHJlZGlyZWN0IHRvIHRoZSBlZGl0b3IncyBkb2N1bWVudC5cbiAgdmFyIGRvbnREZWxlZ2F0ZSA9IFwiaXRlciBpbnNlcnQgcmVtb3ZlIGNvcHkgZ2V0RWRpdG9yIGNvbnN0cnVjdG9yXCIuc3BsaXQoXCIgXCIpO1xuICBmb3IgKHZhciBwcm9wIGluIERvYy5wcm90b3R5cGUpIHsgaWYgKERvYy5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkocHJvcCkgJiYgaW5kZXhPZihkb250RGVsZWdhdGUsIHByb3ApIDwgMClcbiAgICB7IENvZGVNaXJyb3IucHJvdG90eXBlW3Byb3BdID0gKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge3JldHVybiBtZXRob2QuYXBwbHkodGhpcy5kb2MsIGFyZ3VtZW50cyl9XG4gICAgfSkoRG9jLnByb3RvdHlwZVtwcm9wXSk7IH0gfVxuXG4gIGV2ZW50TWl4aW4oRG9jKTtcbiAgQ29kZU1pcnJvci5pbnB1dFN0eWxlcyA9IHtcInRleHRhcmVhXCI6IFRleHRhcmVhSW5wdXQsIFwiY29udGVudGVkaXRhYmxlXCI6IENvbnRlbnRFZGl0YWJsZUlucHV0fTtcblxuICAvLyBFeHRyYSBhcmd1bWVudHMgYXJlIHN0b3JlZCBhcyB0aGUgbW9kZSdzIGRlcGVuZGVuY2llcywgd2hpY2ggaXNcbiAgLy8gdXNlZCBieSAobGVnYWN5KSBtZWNoYW5pc21zIGxpa2UgbG9hZG1vZGUuanMgdG8gYXV0b21hdGljYWxseVxuICAvLyBsb2FkIGEgbW9kZS4gKFByZWZlcnJlZCBtZWNoYW5pc20gaXMgdGhlIHJlcXVpcmUvZGVmaW5lIGNhbGxzLilcbiAgQ29kZU1pcnJvci5kZWZpbmVNb2RlID0gZnVuY3Rpb24obmFtZS8qLCBtb2RlLCDigKYqLykge1xuICAgIGlmICghQ29kZU1pcnJvci5kZWZhdWx0cy5tb2RlICYmIG5hbWUgIT0gXCJudWxsXCIpIHsgQ29kZU1pcnJvci5kZWZhdWx0cy5tb2RlID0gbmFtZTsgfVxuICAgIGRlZmluZU1vZGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcblxuICBDb2RlTWlycm9yLmRlZmluZU1JTUUgPSBkZWZpbmVNSU1FO1xuXG4gIC8vIE1pbmltYWwgZGVmYXVsdCBtb2RlLlxuICBDb2RlTWlycm9yLmRlZmluZU1vZGUoXCJudWxsXCIsIGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7dG9rZW46IGZ1bmN0aW9uIChzdHJlYW0pIHsgcmV0dXJuIHN0cmVhbS5za2lwVG9FbmQoKTsgfX0pOyB9KTtcbiAgQ29kZU1pcnJvci5kZWZpbmVNSU1FKFwidGV4dC9wbGFpblwiLCBcIm51bGxcIik7XG5cbiAgLy8gRVhURU5TSU9OU1xuXG4gIENvZGVNaXJyb3IuZGVmaW5lRXh0ZW5zaW9uID0gZnVuY3Rpb24gKG5hbWUsIGZ1bmMpIHtcbiAgICBDb2RlTWlycm9yLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmM7XG4gIH07XG4gIENvZGVNaXJyb3IuZGVmaW5lRG9jRXh0ZW5zaW9uID0gZnVuY3Rpb24gKG5hbWUsIGZ1bmMpIHtcbiAgICBEb2MucHJvdG90eXBlW25hbWVdID0gZnVuYztcbiAgfTtcblxuICBDb2RlTWlycm9yLmZyb21UZXh0QXJlYSA9IGZyb21UZXh0QXJlYTtcblxuICBhZGRMZWdhY3lQcm9wcyhDb2RlTWlycm9yKTtcblxuICBDb2RlTWlycm9yLnZlcnNpb24gPSBcIjUuNTkuMFwiO1xuXG4gIHJldHVybiBDb2RlTWlycm9yO1xuXG59KSkpO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/codemirror/lib/codemirror.js\n");

/***/ }),

/***/ "./node_modules/codemirror/mode/css/css.js":
/*!*************************************************!*\
  !*** ./node_modules/codemirror/mode/css/css.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (true) // CommonJS\n    mod(__webpack_require__(/*! ../../lib/codemirror */ \"./node_modules/codemirror/lib/codemirror.js\"));\n  else {}\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"css\", function(config, parserConfig) {\n  var inline = parserConfig.inline\n  if (!parserConfig.propertyKeywords) parserConfig = CodeMirror.resolveMode(\"text/css\");\n\n  var indentUnit = config.indentUnit,\n      tokenHooks = parserConfig.tokenHooks,\n      documentTypes = parserConfig.documentTypes || {},\n      mediaTypes = parserConfig.mediaTypes || {},\n      mediaFeatures = parserConfig.mediaFeatures || {},\n      mediaValueKeywords = parserConfig.mediaValueKeywords || {},\n      propertyKeywords = parserConfig.propertyKeywords || {},\n      nonStandardPropertyKeywords = parserConfig.nonStandardPropertyKeywords || {},\n      fontProperties = parserConfig.fontProperties || {},\n      counterDescriptors = parserConfig.counterDescriptors || {},\n      colorKeywords = parserConfig.colorKeywords || {},\n      valueKeywords = parserConfig.valueKeywords || {},\n      allowNested = parserConfig.allowNested,\n      lineComment = parserConfig.lineComment,\n      supportsAtComponent = parserConfig.supportsAtComponent === true,\n      highlightNonStandardPropertyKeywords = config.highlightNonStandardPropertyKeywords !== false;\n\n  var type, override;\n  function ret(style, tp) { type = tp; return style; }\n\n  // Tokenizers\n\n  function tokenBase(stream, state) {\n    var ch = stream.next();\n    if (tokenHooks[ch]) {\n      var result = tokenHooks[ch](stream, state);\n      if (result !== false) return result;\n    }\n    if (ch == \"@\") {\n      stream.eatWhile(/[\\w\\\\\\-]/);\n      return ret(\"def\", stream.current());\n    } else if (ch == \"=\" || (ch == \"~\" || ch == \"|\") && stream.eat(\"=\")) {\n      return ret(null, \"compare\");\n    } else if (ch == \"\\\"\" || ch == \"'\") {\n      state.tokenize = tokenString(ch);\n      return state.tokenize(stream, state);\n    } else if (ch == \"#\") {\n      stream.eatWhile(/[\\w\\\\\\-]/);\n      return ret(\"atom\", \"hash\");\n    } else if (ch == \"!\") {\n      stream.match(/^\\s*\\w*/);\n      return ret(\"keyword\", \"important\");\n    } else if (/\\d/.test(ch) || ch == \".\" && stream.eat(/\\d/)) {\n      stream.eatWhile(/[\\w.%]/);\n      return ret(\"number\", \"unit\");\n    } else if (ch === \"-\") {\n      if (/[\\d.]/.test(stream.peek())) {\n        stream.eatWhile(/[\\w.%]/);\n        return ret(\"number\", \"unit\");\n      } else if (stream.match(/^-[\\w\\\\\\-]*/)) {\n        stream.eatWhile(/[\\w\\\\\\-]/);\n        if (stream.match(/^\\s*:/, false))\n          return ret(\"variable-2\", \"variable-definition\");\n        return ret(\"variable-2\", \"variable\");\n      } else if (stream.match(/^\\w+-/)) {\n        return ret(\"meta\", \"meta\");\n      }\n    } else if (/[,+>*\\/]/.test(ch)) {\n      return ret(null, \"select-op\");\n    } else if (ch == \".\" && stream.match(/^-?[_a-z][_a-z0-9-]*/i)) {\n      return ret(\"qualifier\", \"qualifier\");\n    } else if (/[:;{}\\[\\]\\(\\)]/.test(ch)) {\n      return ret(null, ch);\n    } else if (stream.match(/[\\w-.]+(?=\\()/)) {\n      if (/^(url(-prefix)?|domain|regexp)$/.test(stream.current().toLowerCase())) {\n        state.tokenize = tokenParenthesized;\n      }\n      return ret(\"variable callee\", \"variable\");\n    } else if (/[\\w\\\\\\-]/.test(ch)) {\n      stream.eatWhile(/[\\w\\\\\\-]/);\n      return ret(\"property\", \"word\");\n    } else {\n      return ret(null, null);\n    }\n  }\n\n  function tokenString(quote) {\n    return function(stream, state) {\n      var escaped = false, ch;\n      while ((ch = stream.next()) != null) {\n        if (ch == quote && !escaped) {\n          if (quote == \")\") stream.backUp(1);\n          break;\n        }\n        escaped = !escaped && ch == \"\\\\\";\n      }\n      if (ch == quote || !escaped && quote != \")\") state.tokenize = null;\n      return ret(\"string\", \"string\");\n    };\n  }\n\n  function tokenParenthesized(stream, state) {\n    stream.next(); // Must be '('\n    if (!stream.match(/\\s*[\\\"\\')]/, false))\n      state.tokenize = tokenString(\")\");\n    else\n      state.tokenize = null;\n    return ret(null, \"(\");\n  }\n\n  // Context management\n\n  function Context(type, indent, prev) {\n    this.type = type;\n    this.indent = indent;\n    this.prev = prev;\n  }\n\n  function pushContext(state, stream, type, indent) {\n    state.context = new Context(type, stream.indentation() + (indent === false ? 0 : indentUnit), state.context);\n    return type;\n  }\n\n  function popContext(state) {\n    if (state.context.prev)\n      state.context = state.context.prev;\n    return state.context.type;\n  }\n\n  function pass(type, stream, state) {\n    return states[state.context.type](type, stream, state);\n  }\n  function popAndPass(type, stream, state, n) {\n    for (var i = n || 1; i > 0; i--)\n      state.context = state.context.prev;\n    return pass(type, stream, state);\n  }\n\n  // Parser\n\n  function wordAsValue(stream) {\n    var word = stream.current().toLowerCase();\n    if (valueKeywords.hasOwnProperty(word))\n      override = \"atom\";\n    else if (colorKeywords.hasOwnProperty(word))\n      override = \"keyword\";\n    else\n      override = \"variable\";\n  }\n\n  var states = {};\n\n  states.top = function(type, stream, state) {\n    if (type == \"{\") {\n      return pushContext(state, stream, \"block\");\n    } else if (type == \"}\" && state.context.prev) {\n      return popContext(state);\n    } else if (supportsAtComponent && /@component/i.test(type)) {\n      return pushContext(state, stream, \"atComponentBlock\");\n    } else if (/^@(-moz-)?document$/i.test(type)) {\n      return pushContext(state, stream, \"documentTypes\");\n    } else if (/^@(media|supports|(-moz-)?document|import)$/i.test(type)) {\n      return pushContext(state, stream, \"atBlock\");\n    } else if (/^@(font-face|counter-style)/i.test(type)) {\n      state.stateArg = type;\n      return \"restricted_atBlock_before\";\n    } else if (/^@(-(moz|ms|o|webkit)-)?keyframes$/i.test(type)) {\n      return \"keyframes\";\n    } else if (type && type.charAt(0) == \"@\") {\n      return pushContext(state, stream, \"at\");\n    } else if (type == \"hash\") {\n      override = \"builtin\";\n    } else if (type == \"word\") {\n      override = \"tag\";\n    } else if (type == \"variable-definition\") {\n      return \"maybeprop\";\n    } else if (type == \"interpolation\") {\n      return pushContext(state, stream, \"interpolation\");\n    } else if (type == \":\") {\n      return \"pseudo\";\n    } else if (allowNested && type == \"(\") {\n      return pushContext(state, stream, \"parens\");\n    }\n    return state.context.type;\n  };\n\n  states.block = function(type, stream, state) {\n    if (type == \"word\") {\n      var word = stream.current().toLowerCase();\n      if (propertyKeywords.hasOwnProperty(word)) {\n        override = \"property\";\n        return \"maybeprop\";\n      } else if (nonStandardPropertyKeywords.hasOwnProperty(word)) {\n        override = highlightNonStandardPropertyKeywords ? \"string-2\" : \"property\";\n        return \"maybeprop\";\n      } else if (allowNested) {\n        override = stream.match(/^\\s*:(?:\\s|$)/, false) ? \"property\" : \"tag\";\n        return \"block\";\n      } else {\n        override += \" error\";\n        return \"maybeprop\";\n      }\n    } else if (type == \"meta\") {\n      return \"block\";\n    } else if (!allowNested && (type == \"hash\" || type == \"qualifier\")) {\n      override = \"error\";\n      return \"block\";\n    } else {\n      return states.top(type, stream, state);\n    }\n  };\n\n  states.maybeprop = function(type, stream, state) {\n    if (type == \":\") return pushContext(state, stream, \"prop\");\n    return pass(type, stream, state);\n  };\n\n  states.prop = function(type, stream, state) {\n    if (type == \";\") return popContext(state);\n    if (type == \"{\" && allowNested) return pushContext(state, stream, \"propBlock\");\n    if (type == \"}\" || type == \"{\") return popAndPass(type, stream, state);\n    if (type == \"(\") return pushContext(state, stream, \"parens\");\n\n    if (type == \"hash\" && !/^#([0-9a-fA-f]{3,4}|[0-9a-fA-f]{6}|[0-9a-fA-f]{8})$/.test(stream.current())) {\n      override += \" error\";\n    } else if (type == \"word\") {\n      wordAsValue(stream);\n    } else if (type == \"interpolation\") {\n      return pushContext(state, stream, \"interpolation\");\n    }\n    return \"prop\";\n  };\n\n  states.propBlock = function(type, _stream, state) {\n    if (type == \"}\") return popContext(state);\n    if (type == \"word\") { override = \"property\"; return \"maybeprop\"; }\n    return state.context.type;\n  };\n\n  states.parens = function(type, stream, state) {\n    if (type == \"{\" || type == \"}\") return popAndPass(type, stream, state);\n    if (type == \")\") return popContext(state);\n    if (type == \"(\") return pushContext(state, stream, \"parens\");\n    if (type == \"interpolation\") return pushContext(state, stream, \"interpolation\");\n    if (type == \"word\") wordAsValue(stream);\n    return \"parens\";\n  };\n\n  states.pseudo = function(type, stream, state) {\n    if (type == \"meta\") return \"pseudo\";\n\n    if (type == \"word\") {\n      override = \"variable-3\";\n      return state.context.type;\n    }\n    return pass(type, stream, state);\n  };\n\n  states.documentTypes = function(type, stream, state) {\n    if (type == \"word\" && documentTypes.hasOwnProperty(stream.current())) {\n      override = \"tag\";\n      return state.context.type;\n    } else {\n      return states.atBlock(type, stream, state);\n    }\n  };\n\n  states.atBlock = function(type, stream, state) {\n    if (type == \"(\") return pushContext(state, stream, \"atBlock_parens\");\n    if (type == \"}\" || type == \";\") return popAndPass(type, stream, state);\n    if (type == \"{\") return popContext(state) && pushContext(state, stream, allowNested ? \"block\" : \"top\");\n\n    if (type == \"interpolation\") return pushContext(state, stream, \"interpolation\");\n\n    if (type == \"word\") {\n      var word = stream.current().toLowerCase();\n      if (word == \"only\" || word == \"not\" || word == \"and\" || word == \"or\")\n        override = \"keyword\";\n      else if (mediaTypes.hasOwnProperty(word))\n        override = \"attribute\";\n      else if (mediaFeatures.hasOwnProperty(word))\n        override = \"property\";\n      else if (mediaValueKeywords.hasOwnProperty(word))\n        override = \"keyword\";\n      else if (propertyKeywords.hasOwnProperty(word))\n        override = \"property\";\n      else if (nonStandardPropertyKeywords.hasOwnProperty(word))\n        override = highlightNonStandardPropertyKeywords ? \"string-2\" : \"property\";\n      else if (valueKeywords.hasOwnProperty(word))\n        override = \"atom\";\n      else if (colorKeywords.hasOwnProperty(word))\n        override = \"keyword\";\n      else\n        override = \"error\";\n    }\n    return state.context.type;\n  };\n\n  states.atComponentBlock = function(type, stream, state) {\n    if (type == \"}\")\n      return popAndPass(type, stream, state);\n    if (type == \"{\")\n      return popContext(state) && pushContext(state, stream, allowNested ? \"block\" : \"top\", false);\n    if (type == \"word\")\n      override = \"error\";\n    return state.context.type;\n  };\n\n  states.atBlock_parens = function(type, stream, state) {\n    if (type == \")\") return popContext(state);\n    if (type == \"{\" || type == \"}\") return popAndPass(type, stream, state, 2);\n    return states.atBlock(type, stream, state);\n  };\n\n  states.restricted_atBlock_before = function(type, stream, state) {\n    if (type == \"{\")\n      return pushContext(state, stream, \"restricted_atBlock\");\n    if (type == \"word\" && state.stateArg == \"@counter-style\") {\n      override = \"variable\";\n      return \"restricted_atBlock_before\";\n    }\n    return pass(type, stream, state);\n  };\n\n  states.restricted_atBlock = function(type, stream, state) {\n    if (type == \"}\") {\n      state.stateArg = null;\n      return popContext(state);\n    }\n    if (type == \"word\") {\n      if ((state.stateArg == \"@font-face\" && !fontProperties.hasOwnProperty(stream.current().toLowerCase())) ||\n          (state.stateArg == \"@counter-style\" && !counterDescriptors.hasOwnProperty(stream.current().toLowerCase())))\n        override = \"error\";\n      else\n        override = \"property\";\n      return \"maybeprop\";\n    }\n    return \"restricted_atBlock\";\n  };\n\n  states.keyframes = function(type, stream, state) {\n    if (type == \"word\") { override = \"variable\"; return \"keyframes\"; }\n    if (type == \"{\") return pushContext(state, stream, \"top\");\n    return pass(type, stream, state);\n  };\n\n  states.at = function(type, stream, state) {\n    if (type == \";\") return popContext(state);\n    if (type == \"{\" || type == \"}\") return popAndPass(type, stream, state);\n    if (type == \"word\") override = \"tag\";\n    else if (type == \"hash\") override = \"builtin\";\n    return \"at\";\n  };\n\n  states.interpolation = function(type, stream, state) {\n    if (type == \"}\") return popContext(state);\n    if (type == \"{\" || type == \";\") return popAndPass(type, stream, state);\n    if (type == \"word\") override = \"variable\";\n    else if (type != \"variable\" && type != \"(\" && type != \")\") override = \"error\";\n    return \"interpolation\";\n  };\n\n  return {\n    startState: function(base) {\n      return {tokenize: null,\n              state: inline ? \"block\" : \"top\",\n              stateArg: null,\n              context: new Context(inline ? \"block\" : \"top\", base || 0, null)};\n    },\n\n    token: function(stream, state) {\n      if (!state.tokenize && stream.eatSpace()) return null;\n      var style = (state.tokenize || tokenBase)(stream, state);\n      if (style && typeof style == \"object\") {\n        type = style[1];\n        style = style[0];\n      }\n      override = style;\n      if (type != \"comment\")\n        state.state = states[state.state](type, stream, state);\n      return override;\n    },\n\n    indent: function(state, textAfter) {\n      var cx = state.context, ch = textAfter && textAfter.charAt(0);\n      var indent = cx.indent;\n      if (cx.type == \"prop\" && (ch == \"}\" || ch == \")\")) cx = cx.prev;\n      if (cx.prev) {\n        if (ch == \"}\" && (cx.type == \"block\" || cx.type == \"top\" ||\n                          cx.type == \"interpolation\" || cx.type == \"restricted_atBlock\")) {\n          // Resume indentation from parent context.\n          cx = cx.prev;\n          indent = cx.indent;\n        } else if (ch == \")\" && (cx.type == \"parens\" || cx.type == \"atBlock_parens\") ||\n            ch == \"{\" && (cx.type == \"at\" || cx.type == \"atBlock\")) {\n          // Dedent relative to current context.\n          indent = Math.max(0, cx.indent - indentUnit);\n        }\n      }\n      return indent;\n    },\n\n    electricChars: \"}\",\n    blockCommentStart: \"/*\",\n    blockCommentEnd: \"*/\",\n    blockCommentContinue: \" * \",\n    lineComment: lineComment,\n    fold: \"brace\"\n  };\n});\n\n  function keySet(array) {\n    var keys = {};\n    for (var i = 0; i < array.length; ++i) {\n      keys[array[i].toLowerCase()] = true;\n    }\n    return keys;\n  }\n\n  var documentTypes_ = [\n    \"domain\", \"regexp\", \"url\", \"url-prefix\"\n  ], documentTypes = keySet(documentTypes_);\n\n  var mediaTypes_ = [\n    \"all\", \"aural\", \"braille\", \"handheld\", \"print\", \"projection\", \"screen\",\n    \"tty\", \"tv\", \"embossed\"\n  ], mediaTypes = keySet(mediaTypes_);\n\n  var mediaFeatures_ = [\n    \"width\", \"min-width\", \"max-width\", \"height\", \"min-height\", \"max-height\",\n    \"device-width\", \"min-device-width\", \"max-device-width\", \"device-height\",\n    \"min-device-height\", \"max-device-height\", \"aspect-ratio\",\n    \"min-aspect-ratio\", \"max-aspect-ratio\", \"device-aspect-ratio\",\n    \"min-device-aspect-ratio\", \"max-device-aspect-ratio\", \"color\", \"min-color\",\n    \"max-color\", \"color-index\", \"min-color-index\", \"max-color-index\",\n    \"monochrome\", \"min-monochrome\", \"max-monochrome\", \"resolution\",\n    \"min-resolution\", \"max-resolution\", \"scan\", \"grid\", \"orientation\",\n    \"device-pixel-ratio\", \"min-device-pixel-ratio\", \"max-device-pixel-ratio\",\n    \"pointer\", \"any-pointer\", \"hover\", \"any-hover\", \"prefers-color-scheme\"\n  ], mediaFeatures = keySet(mediaFeatures_);\n\n  var mediaValueKeywords_ = [\n    \"landscape\", \"portrait\", \"none\", \"coarse\", \"fine\", \"on-demand\", \"hover\",\n    \"interlace\", \"progressive\",\n    \"dark\", \"light\"\n  ], mediaValueKeywords = keySet(mediaValueKeywords_);\n\n  var propertyKeywords_ = [\n    \"align-content\", \"align-items\", \"align-self\", \"alignment-adjust\",\n    \"alignment-baseline\", \"all\", \"anchor-point\", \"animation\", \"animation-delay\",\n    \"animation-direction\", \"animation-duration\", \"animation-fill-mode\",\n    \"animation-iteration-count\", \"animation-name\", \"animation-play-state\",\n    \"animation-timing-function\", \"appearance\", \"azimuth\", \"backdrop-filter\",\n    \"backface-visibility\", \"background\", \"background-attachment\",\n    \"background-blend-mode\", \"background-clip\", \"background-color\",\n    \"background-image\", \"background-origin\", \"background-position\",\n    \"background-position-x\", \"background-position-y\", \"background-repeat\",\n    \"background-size\", \"baseline-shift\", \"binding\", \"bleed\", \"block-size\",\n    \"bookmark-label\", \"bookmark-level\", \"bookmark-state\", \"bookmark-target\",\n    \"border\", \"border-bottom\", \"border-bottom-color\", \"border-bottom-left-radius\",\n    \"border-bottom-right-radius\", \"border-bottom-style\", \"border-bottom-width\",\n    \"border-collapse\", \"border-color\", \"border-image\", \"border-image-outset\",\n    \"border-image-repeat\", \"border-image-slice\", \"border-image-source\",\n    \"border-image-width\", \"border-left\", \"border-left-color\", \"border-left-style\",\n    \"border-left-width\", \"border-radius\", \"border-right\", \"border-right-color\",\n    \"border-right-style\", \"border-right-width\", \"border-spacing\", \"border-style\",\n    \"border-top\", \"border-top-color\", \"border-top-left-radius\",\n    \"border-top-right-radius\", \"border-top-style\", \"border-top-width\",\n    \"border-width\", \"bottom\", \"box-decoration-break\", \"box-shadow\", \"box-sizing\",\n    \"break-after\", \"break-before\", \"break-inside\", \"caption-side\", \"caret-color\",\n    \"clear\", \"clip\", \"color\", \"color-profile\", \"column-count\", \"column-fill\",\n    \"column-gap\", \"column-rule\", \"column-rule-color\", \"column-rule-style\",\n    \"column-rule-width\", \"column-span\", \"column-width\", \"columns\", \"contain\",\n    \"content\", \"counter-increment\", \"counter-reset\", \"crop\", \"cue\", \"cue-after\",\n    \"cue-before\", \"cursor\", \"direction\", \"display\", \"dominant-baseline\",\n    \"drop-initial-after-adjust\", \"drop-initial-after-align\",\n    \"drop-initial-before-adjust\", \"drop-initial-before-align\", \"drop-initial-size\",\n    \"drop-initial-value\", \"elevation\", \"empty-cells\", \"fit\", \"fit-position\",\n    \"flex\", \"flex-basis\", \"flex-direction\", \"flex-flow\", \"flex-grow\",\n    \"flex-shrink\", \"flex-wrap\", \"float\", \"float-offset\", \"flow-from\", \"flow-into\",\n    \"font\", \"font-family\", \"font-feature-settings\", \"font-kerning\",\n    \"font-language-override\", \"font-optical-sizing\", \"font-size\",\n    \"font-size-adjust\", \"font-stretch\", \"font-style\", \"font-synthesis\",\n    \"font-variant\", \"font-variant-alternates\", \"font-variant-caps\",\n    \"font-variant-east-asian\", \"font-variant-ligatures\", \"font-variant-numeric\",\n    \"font-variant-position\", \"font-variation-settings\", \"font-weight\", \"gap\",\n    \"grid\", \"grid-area\", \"grid-auto-columns\", \"grid-auto-flow\", \"grid-auto-rows\",\n    \"grid-column\", \"grid-column-end\", \"grid-column-gap\", \"grid-column-start\",\n    \"grid-gap\", \"grid-row\", \"grid-row-end\", \"grid-row-gap\", \"grid-row-start\",\n    \"grid-template\", \"grid-template-areas\", \"grid-template-columns\",\n    \"grid-template-rows\", \"hanging-punctuation\", \"height\", \"hyphens\", \"icon\",\n    \"image-orientation\", \"image-rendering\", \"image-resolution\", \"inline-box-align\",\n    \"inset\", \"inset-block\", \"inset-block-end\", \"inset-block-start\", \"inset-inline\",\n    \"inset-inline-end\", \"inset-inline-start\", \"isolation\", \"justify-content\",\n    \"justify-items\", \"justify-self\", \"left\", \"letter-spacing\", \"line-break\",\n    \"line-height\", \"line-height-step\", \"line-stacking\", \"line-stacking-ruby\",\n    \"line-stacking-shift\", \"line-stacking-strategy\", \"list-style\",\n    \"list-style-image\", \"list-style-position\", \"list-style-type\", \"margin\",\n    \"margin-bottom\", \"margin-left\", \"margin-right\", \"margin-top\", \"marks\",\n    \"marquee-direction\", \"marquee-loop\", \"marquee-play-count\", \"marquee-speed\",\n    \"marquee-style\", \"mask-clip\", \"mask-composite\", \"mask-image\", \"mask-mode\",\n    \"mask-origin\", \"mask-position\", \"mask-repeat\", \"mask-size\",\"mask-type\",\n    \"max-block-size\", \"max-height\", \"max-inline-size\",\n    \"max-width\", \"min-block-size\", \"min-height\", \"min-inline-size\", \"min-width\",\n    \"mix-blend-mode\", \"move-to\", \"nav-down\", \"nav-index\", \"nav-left\", \"nav-right\",\n    \"nav-up\", \"object-fit\", \"object-position\", \"offset\", \"offset-anchor\",\n    \"offset-distance\", \"offset-path\", \"offset-position\", \"offset-rotate\",\n    \"opacity\", \"order\", \"orphans\", \"outline\", \"outline-color\", \"outline-offset\",\n    \"outline-style\", \"outline-width\", \"overflow\", \"overflow-style\",\n    \"overflow-wrap\", \"overflow-x\", \"overflow-y\", \"padding\", \"padding-bottom\",\n    \"padding-left\", \"padding-right\", \"padding-top\", \"page\", \"page-break-after\",\n    \"page-break-before\", \"page-break-inside\", \"page-policy\", \"pause\",\n    \"pause-after\", \"pause-before\", \"perspective\", \"perspective-origin\", \"pitch\",\n    \"pitch-range\", \"place-content\", \"place-items\", \"place-self\", \"play-during\",\n    \"position\", \"presentation-level\", \"punctuation-trim\", \"quotes\",\n    \"region-break-after\", \"region-break-before\", \"region-break-inside\",\n    \"region-fragment\", \"rendering-intent\", \"resize\", \"rest\", \"rest-after\",\n    \"rest-before\", \"richness\", \"right\", \"rotate\", \"rotation\", \"rotation-point\",\n    \"row-gap\", \"ruby-align\", \"ruby-overhang\", \"ruby-position\", \"ruby-span\",\n    \"scale\", \"scroll-behavior\", \"scroll-margin\", \"scroll-margin-block\",\n    \"scroll-margin-block-end\", \"scroll-margin-block-start\", \"scroll-margin-bottom\",\n    \"scroll-margin-inline\", \"scroll-margin-inline-end\",\n    \"scroll-margin-inline-start\", \"scroll-margin-left\", \"scroll-margin-right\",\n    \"scroll-margin-top\", \"scroll-padding\", \"scroll-padding-block\",\n    \"scroll-padding-block-end\", \"scroll-padding-block-start\",\n    \"scroll-padding-bottom\", \"scroll-padding-inline\", \"scroll-padding-inline-end\",\n    \"scroll-padding-inline-start\", \"scroll-padding-left\", \"scroll-padding-right\",\n    \"scroll-padding-top\", \"scroll-snap-align\", \"scroll-snap-type\",\n    \"shape-image-threshold\", \"shape-inside\", \"shape-margin\", \"shape-outside\",\n    \"size\", \"speak\", \"speak-as\", \"speak-header\", \"speak-numeral\",\n    \"speak-punctuation\", \"speech-rate\", \"stress\", \"string-set\", \"tab-size\",\n    \"table-layout\", \"target\", \"target-name\", \"target-new\", \"target-position\",\n    \"text-align\", \"text-align-last\", \"text-combine-upright\", \"text-decoration\",\n    \"text-decoration-color\", \"text-decoration-line\", \"text-decoration-skip\",\n    \"text-decoration-skip-ink\", \"text-decoration-style\", \"text-emphasis\",\n    \"text-emphasis-color\", \"text-emphasis-position\", \"text-emphasis-style\",\n    \"text-height\", \"text-indent\", \"text-justify\", \"text-orientation\",\n    \"text-outline\", \"text-overflow\", \"text-rendering\", \"text-shadow\",\n    \"text-size-adjust\", \"text-space-collapse\", \"text-transform\",\n    \"text-underline-position\", \"text-wrap\", \"top\", \"touch-action\", \"transform\", \"transform-origin\",\n    \"transform-style\", \"transition\", \"transition-delay\", \"transition-duration\",\n    \"transition-property\", \"transition-timing-function\", \"translate\",\n    \"unicode-bidi\", \"user-select\", \"vertical-align\", \"visibility\", \"voice-balance\",\n    \"voice-duration\", \"voice-family\", \"voice-pitch\", \"voice-range\", \"voice-rate\",\n    \"voice-stress\", \"voice-volume\", \"volume\", \"white-space\", \"widows\", \"width\",\n    \"will-change\", \"word-break\", \"word-spacing\", \"word-wrap\", \"writing-mode\", \"z-index\",\n    // SVG-specific\n    \"clip-path\", \"clip-rule\", \"mask\", \"enable-background\", \"filter\", \"flood-color\",\n    \"flood-opacity\", \"lighting-color\", \"stop-color\", \"stop-opacity\", \"pointer-events\",\n    \"color-interpolation\", \"color-interpolation-filters\",\n    \"color-rendering\", \"fill\", \"fill-opacity\", \"fill-rule\", \"image-rendering\",\n    \"marker\", \"marker-end\", \"marker-mid\", \"marker-start\", \"paint-order\", \"shape-rendering\", \"stroke\",\n    \"stroke-dasharray\", \"stroke-dashoffset\", \"stroke-linecap\", \"stroke-linejoin\",\n    \"stroke-miterlimit\", \"stroke-opacity\", \"stroke-width\", \"text-rendering\",\n    \"baseline-shift\", \"dominant-baseline\", \"glyph-orientation-horizontal\",\n    \"glyph-orientation-vertical\", \"text-anchor\", \"writing-mode\",\n  ], propertyKeywords = keySet(propertyKeywords_);\n\n  var nonStandardPropertyKeywords_ = [\n    \"border-block\", \"border-block-color\", \"border-block-end\",\n    \"border-block-end-color\", \"border-block-end-style\", \"border-block-end-width\",\n    \"border-block-start\", \"border-block-start-color\", \"border-block-start-style\",\n    \"border-block-start-width\", \"border-block-style\", \"border-block-width\",\n    \"border-inline\", \"border-inline-color\", \"border-inline-end\",\n    \"border-inline-end-color\", \"border-inline-end-style\",\n    \"border-inline-end-width\", \"border-inline-start\", \"border-inline-start-color\",\n    \"border-inline-start-style\", \"border-inline-start-width\",\n    \"border-inline-style\", \"border-inline-width\", \"margin-block\",\n    \"margin-block-end\", \"margin-block-start\", \"margin-inline\", \"margin-inline-end\",\n    \"margin-inline-start\", \"padding-block\", \"padding-block-end\",\n    \"padding-block-start\", \"padding-inline\", \"padding-inline-end\",\n    \"padding-inline-start\", \"scroll-snap-stop\", \"scrollbar-3d-light-color\",\n    \"scrollbar-arrow-color\", \"scrollbar-base-color\", \"scrollbar-dark-shadow-color\",\n    \"scrollbar-face-color\", \"scrollbar-highlight-color\", \"scrollbar-shadow-color\",\n    \"scrollbar-track-color\", \"searchfield-cancel-button\", \"searchfield-decoration\",\n    \"searchfield-results-button\", \"searchfield-results-decoration\", \"shape-inside\", \"zoom\"\n  ], nonStandardPropertyKeywords = keySet(nonStandardPropertyKeywords_);\n\n  var fontProperties_ = [\n    \"font-display\", \"font-family\", \"src\", \"unicode-range\", \"font-variant\",\n     \"font-feature-settings\", \"font-stretch\", \"font-weight\", \"font-style\"\n  ], fontProperties = keySet(fontProperties_);\n\n  var counterDescriptors_ = [\n    \"additive-symbols\", \"fallback\", \"negative\", \"pad\", \"prefix\", \"range\",\n    \"speak-as\", \"suffix\", \"symbols\", \"system\"\n  ], counterDescriptors = keySet(counterDescriptors_);\n\n  var colorKeywords_ = [\n    \"aliceblue\", \"antiquewhite\", \"aqua\", \"aquamarine\", \"azure\", \"beige\",\n    \"bisque\", \"black\", \"blanchedalmond\", \"blue\", \"blueviolet\", \"brown\",\n    \"burlywood\", \"cadetblue\", \"chartreuse\", \"chocolate\", \"coral\", \"cornflowerblue\",\n    \"cornsilk\", \"crimson\", \"cyan\", \"darkblue\", \"darkcyan\", \"darkgoldenrod\",\n    \"darkgray\", \"darkgreen\", \"darkkhaki\", \"darkmagenta\", \"darkolivegreen\",\n    \"darkorange\", \"darkorchid\", \"darkred\", \"darksalmon\", \"darkseagreen\",\n    \"darkslateblue\", \"darkslategray\", \"darkturquoise\", \"darkviolet\",\n    \"deeppink\", \"deepskyblue\", \"dimgray\", \"dodgerblue\", \"firebrick\",\n    \"floralwhite\", \"forestgreen\", \"fuchsia\", \"gainsboro\", \"ghostwhite\",\n    \"gold\", \"goldenrod\", \"gray\", \"grey\", \"green\", \"greenyellow\", \"honeydew\",\n    \"hotpink\", \"indianred\", \"indigo\", \"ivory\", \"khaki\", \"lavender\",\n    \"lavenderblush\", \"lawngreen\", \"lemonchiffon\", \"lightblue\", \"lightcoral\",\n    \"lightcyan\", \"lightgoldenrodyellow\", \"lightgray\", \"lightgreen\", \"lightpink\",\n    \"lightsalmon\", \"lightseagreen\", \"lightskyblue\", \"lightslategray\",\n    \"lightsteelblue\", \"lightyellow\", \"lime\", \"limegreen\", \"linen\", \"magenta\",\n    \"maroon\", \"mediumaquamarine\", \"mediumblue\", \"mediumorchid\", \"mediumpurple\",\n    \"mediumseagreen\", \"mediumslateblue\", \"mediumspringgreen\", \"mediumturquoise\",\n    \"mediumvioletred\", \"midnightblue\", \"mintcream\", \"mistyrose\", \"moccasin\",\n    \"navajowhite\", \"navy\", \"oldlace\", \"olive\", \"olivedrab\", \"orange\", \"orangered\",\n    \"orchid\", \"palegoldenrod\", \"palegreen\", \"paleturquoise\", \"palevioletred\",\n    \"papayawhip\", \"peachpuff\", \"peru\", \"pink\", \"plum\", \"powderblue\",\n    \"purple\", \"rebeccapurple\", \"red\", \"rosybrown\", \"royalblue\", \"saddlebrown\",\n    \"salmon\", \"sandybrown\", \"seagreen\", \"seashell\", \"sienna\", \"silver\", \"skyblue\",\n    \"slateblue\", \"slategray\", \"snow\", \"springgreen\", \"steelblue\", \"tan\",\n    \"teal\", \"thistle\", \"tomato\", \"turquoise\", \"violet\", \"wheat\", \"white\",\n    \"whitesmoke\", \"yellow\", \"yellowgreen\"\n  ], colorKeywords = keySet(colorKeywords_);\n\n  var valueKeywords_ = [\n    \"above\", \"absolute\", \"activeborder\", \"additive\", \"activecaption\", \"afar\",\n    \"after-white-space\", \"ahead\", \"alias\", \"all\", \"all-scroll\", \"alphabetic\", \"alternate\",\n    \"always\", \"amharic\", \"amharic-abegede\", \"antialiased\", \"appworkspace\",\n    \"arabic-indic\", \"armenian\", \"asterisks\", \"attr\", \"auto\", \"auto-flow\", \"avoid\", \"avoid-column\", \"avoid-page\",\n    \"avoid-region\", \"axis-pan\", \"background\", \"backwards\", \"baseline\", \"below\", \"bidi-override\", \"binary\",\n    \"bengali\", \"blink\", \"block\", \"block-axis\", \"bold\", \"bolder\", \"border\", \"border-box\",\n    \"both\", \"bottom\", \"break\", \"break-all\", \"break-word\", \"bullets\", \"button\", \"button-bevel\",\n    \"buttonface\", \"buttonhighlight\", \"buttonshadow\", \"buttontext\", \"calc\", \"cambodian\",\n    \"capitalize\", \"caps-lock-indicator\", \"caption\", \"captiontext\", \"caret\",\n    \"cell\", \"center\", \"checkbox\", \"circle\", \"cjk-decimal\", \"cjk-earthly-branch\",\n    \"cjk-heavenly-stem\", \"cjk-ideographic\", \"clear\", \"clip\", \"close-quote\",\n    \"col-resize\", \"collapse\", \"color\", \"color-burn\", \"color-dodge\", \"column\", \"column-reverse\",\n    \"compact\", \"condensed\", \"contain\", \"content\", \"contents\",\n    \"content-box\", \"context-menu\", \"continuous\", \"copy\", \"counter\", \"counters\", \"cover\", \"crop\",\n    \"cross\", \"crosshair\", \"currentcolor\", \"cursive\", \"cyclic\", \"darken\", \"dashed\", \"decimal\",\n    \"decimal-leading-zero\", \"default\", \"default-button\", \"dense\", \"destination-atop\",\n    \"destination-in\", \"destination-out\", \"destination-over\", \"devanagari\", \"difference\",\n    \"disc\", \"discard\", \"disclosure-closed\", \"disclosure-open\", \"document\",\n    \"dot-dash\", \"dot-dot-dash\",\n    \"dotted\", \"double\", \"down\", \"e-resize\", \"ease\", \"ease-in\", \"ease-in-out\", \"ease-out\",\n    \"element\", \"ellipse\", \"ellipsis\", \"embed\", \"end\", \"ethiopic\", \"ethiopic-abegede\",\n    \"ethiopic-abegede-am-et\", \"ethiopic-abegede-gez\", \"ethiopic-abegede-ti-er\",\n    \"ethiopic-abegede-ti-et\", \"ethiopic-halehame-aa-er\",\n    \"ethiopic-halehame-aa-et\", \"ethiopic-halehame-am-et\",\n    \"ethiopic-halehame-gez\", \"ethiopic-halehame-om-et\",\n    \"ethiopic-halehame-sid-et\", \"ethiopic-halehame-so-et\",\n    \"ethiopic-halehame-ti-er\", \"ethiopic-halehame-ti-et\", \"ethiopic-halehame-tig\",\n    \"ethiopic-numeric\", \"ew-resize\", \"exclusion\", \"expanded\", \"extends\", \"extra-condensed\",\n    \"extra-expanded\", \"fantasy\", \"fast\", \"fill\", \"fill-box\", \"fixed\", \"flat\", \"flex\", \"flex-end\", \"flex-start\", \"footnotes\",\n    \"forwards\", \"from\", \"geometricPrecision\", \"georgian\", \"graytext\", \"grid\", \"groove\",\n    \"gujarati\", \"gurmukhi\", \"hand\", \"hangul\", \"hangul-consonant\", \"hard-light\", \"hebrew\",\n    \"help\", \"hidden\", \"hide\", \"higher\", \"highlight\", \"highlighttext\",\n    \"hiragana\", \"hiragana-iroha\", \"horizontal\", \"hsl\", \"hsla\", \"hue\", \"icon\", \"ignore\",\n    \"inactiveborder\", \"inactivecaption\", \"inactivecaptiontext\", \"infinite\",\n    \"infobackground\", \"infotext\", \"inherit\", \"initial\", \"inline\", \"inline-axis\",\n    \"inline-block\", \"inline-flex\", \"inline-grid\", \"inline-table\", \"inset\", \"inside\", \"intrinsic\", \"invert\",\n    \"italic\", \"japanese-formal\", \"japanese-informal\", \"justify\", \"kannada\",\n    \"katakana\", \"katakana-iroha\", \"keep-all\", \"khmer\",\n    \"korean-hangul-formal\", \"korean-hanja-formal\", \"korean-hanja-informal\",\n    \"landscape\", \"lao\", \"large\", \"larger\", \"left\", \"level\", \"lighter\", \"lighten\",\n    \"line-through\", \"linear\", \"linear-gradient\", \"lines\", \"list-item\", \"listbox\", \"listitem\",\n    \"local\", \"logical\", \"loud\", \"lower\", \"lower-alpha\", \"lower-armenian\",\n    \"lower-greek\", \"lower-hexadecimal\", \"lower-latin\", \"lower-norwegian\",\n    \"lower-roman\", \"lowercase\", \"ltr\", \"luminosity\", \"malayalam\", \"manipulation\", \"match\", \"matrix\", \"matrix3d\",\n    \"media-controls-background\", \"media-current-time-display\",\n    \"media-fullscreen-button\", \"media-mute-button\", \"media-play-button\",\n    \"media-return-to-realtime-button\", \"media-rewind-button\",\n    \"media-seek-back-button\", \"media-seek-forward-button\", \"media-slider\",\n    \"media-sliderthumb\", \"media-time-remaining-display\", \"media-volume-slider\",\n    \"media-volume-slider-container\", \"media-volume-sliderthumb\", \"medium\",\n    \"menu\", \"menulist\", \"menulist-button\", \"menulist-text\",\n    \"menulist-textfield\", \"menutext\", \"message-box\", \"middle\", \"min-intrinsic\",\n    \"mix\", \"mongolian\", \"monospace\", \"move\", \"multiple\", \"multiple_mask_images\", \"multiply\", \"myanmar\", \"n-resize\",\n    \"narrower\", \"ne-resize\", \"nesw-resize\", \"no-close-quote\", \"no-drop\",\n    \"no-open-quote\", \"no-repeat\", \"none\", \"normal\", \"not-allowed\", \"nowrap\",\n    \"ns-resize\", \"numbers\", \"numeric\", \"nw-resize\", \"nwse-resize\", \"oblique\", \"octal\", \"opacity\", \"open-quote\",\n    \"optimizeLegibility\", \"optimizeSpeed\", \"oriya\", \"oromo\", \"outset\",\n    \"outside\", \"outside-shape\", \"overlay\", \"overline\", \"padding\", \"padding-box\",\n    \"painted\", \"page\", \"paused\", \"persian\", \"perspective\", \"pinch-zoom\", \"plus-darker\", \"plus-lighter\",\n    \"pointer\", \"polygon\", \"portrait\", \"pre\", \"pre-line\", \"pre-wrap\", \"preserve-3d\",\n    \"progress\", \"push-button\", \"radial-gradient\", \"radio\", \"read-only\",\n    \"read-write\", \"read-write-plaintext-only\", \"rectangle\", \"region\",\n    \"relative\", \"repeat\", \"repeating-linear-gradient\",\n    \"repeating-radial-gradient\", \"repeat-x\", \"repeat-y\", \"reset\", \"reverse\",\n    \"rgb\", \"rgba\", \"ridge\", \"right\", \"rotate\", \"rotate3d\", \"rotateX\", \"rotateY\",\n    \"rotateZ\", \"round\", \"row\", \"row-resize\", \"row-reverse\", \"rtl\", \"run-in\", \"running\",\n    \"s-resize\", \"sans-serif\", \"saturation\", \"scale\", \"scale3d\", \"scaleX\", \"scaleY\", \"scaleZ\", \"screen\",\n    \"scroll\", \"scrollbar\", \"scroll-position\", \"se-resize\", \"searchfield\",\n    \"searchfield-cancel-button\", \"searchfield-decoration\",\n    \"searchfield-results-button\", \"searchfield-results-decoration\", \"self-start\", \"self-end\",\n    \"semi-condensed\", \"semi-expanded\", \"separate\", \"serif\", \"show\", \"sidama\",\n    \"simp-chinese-formal\", \"simp-chinese-informal\", \"single\",\n    \"skew\", \"skewX\", \"skewY\", \"skip-white-space\", \"slide\", \"slider-horizontal\",\n    \"slider-vertical\", \"sliderthumb-horizontal\", \"sliderthumb-vertical\", \"slow\",\n    \"small\", \"small-caps\", \"small-caption\", \"smaller\", \"soft-light\", \"solid\", \"somali\",\n    \"source-atop\", \"source-in\", \"source-out\", \"source-over\", \"space\", \"space-around\", \"space-between\", \"space-evenly\", \"spell-out\", \"square\",\n    \"square-button\", \"start\", \"static\", \"status-bar\", \"stretch\", \"stroke\", \"stroke-box\", \"sub\",\n    \"subpixel-antialiased\", \"svg_masks\", \"super\", \"sw-resize\", \"symbolic\", \"symbols\", \"system-ui\", \"table\",\n    \"table-caption\", \"table-cell\", \"table-column\", \"table-column-group\",\n    \"table-footer-group\", \"table-header-group\", \"table-row\", \"table-row-group\",\n    \"tamil\",\n    \"telugu\", \"text\", \"text-bottom\", \"text-top\", \"textarea\", \"textfield\", \"thai\",\n    \"thick\", \"thin\", \"threeddarkshadow\", \"threedface\", \"threedhighlight\",\n    \"threedlightshadow\", \"threedshadow\", \"tibetan\", \"tigre\", \"tigrinya-er\",\n    \"tigrinya-er-abegede\", \"tigrinya-et\", \"tigrinya-et-abegede\", \"to\", \"top\",\n    \"trad-chinese-formal\", \"trad-chinese-informal\", \"transform\",\n    \"translate\", \"translate3d\", \"translateX\", \"translateY\", \"translateZ\",\n    \"transparent\", \"ultra-condensed\", \"ultra-expanded\", \"underline\", \"unidirectional-pan\", \"unset\", \"up\",\n    \"upper-alpha\", \"upper-armenian\", \"upper-greek\", \"upper-hexadecimal\",\n    \"upper-latin\", \"upper-norwegian\", \"upper-roman\", \"uppercase\", \"urdu\", \"url\",\n    \"var\", \"vertical\", \"vertical-text\", \"view-box\", \"visible\", \"visibleFill\", \"visiblePainted\",\n    \"visibleStroke\", \"visual\", \"w-resize\", \"wait\", \"wave\", \"wider\",\n    \"window\", \"windowframe\", \"windowtext\", \"words\", \"wrap\", \"wrap-reverse\", \"x-large\", \"x-small\", \"xor\",\n    \"xx-large\", \"xx-small\"\n  ], valueKeywords = keySet(valueKeywords_);\n\n  var allWords = documentTypes_.concat(mediaTypes_).concat(mediaFeatures_).concat(mediaValueKeywords_)\n    .concat(propertyKeywords_).concat(nonStandardPropertyKeywords_).concat(colorKeywords_)\n    .concat(valueKeywords_);\n  CodeMirror.registerHelper(\"hintWords\", \"css\", allWords);\n\n  function tokenCComment(stream, state) {\n    var maybeEnd = false, ch;\n    while ((ch = stream.next()) != null) {\n      if (maybeEnd && ch == \"/\") {\n        state.tokenize = null;\n        break;\n      }\n      maybeEnd = (ch == \"*\");\n    }\n    return [\"comment\", \"comment\"];\n  }\n\n  CodeMirror.defineMIME(\"text/css\", {\n    documentTypes: documentTypes,\n    mediaTypes: mediaTypes,\n    mediaFeatures: mediaFeatures,\n    mediaValueKeywords: mediaValueKeywords,\n    propertyKeywords: propertyKeywords,\n    nonStandardPropertyKeywords: nonStandardPropertyKeywords,\n    fontProperties: fontProperties,\n    counterDescriptors: counterDescriptors,\n    colorKeywords: colorKeywords,\n    valueKeywords: valueKeywords,\n    tokenHooks: {\n      \"/\": function(stream, state) {\n        if (!stream.eat(\"*\")) return false;\n        state.tokenize = tokenCComment;\n        return tokenCComment(stream, state);\n      }\n    },\n    name: \"css\"\n  });\n\n  CodeMirror.defineMIME(\"text/x-scss\", {\n    mediaTypes: mediaTypes,\n    mediaFeatures: mediaFeatures,\n    mediaValueKeywords: mediaValueKeywords,\n    propertyKeywords: propertyKeywords,\n    nonStandardPropertyKeywords: nonStandardPropertyKeywords,\n    colorKeywords: colorKeywords,\n    valueKeywords: valueKeywords,\n    fontProperties: fontProperties,\n    allowNested: true,\n    lineComment: \"//\",\n    tokenHooks: {\n      \"/\": function(stream, state) {\n        if (stream.eat(\"/\")) {\n          stream.skipToEnd();\n          return [\"comment\", \"comment\"];\n        } else if (stream.eat(\"*\")) {\n          state.tokenize = tokenCComment;\n          return tokenCComment(stream, state);\n        } else {\n          return [\"operator\", \"operator\"];\n        }\n      },\n      \":\": function(stream) {\n        if (stream.match(/\\s*\\{/, false))\n          return [null, null]\n        return false;\n      },\n      \"$\": function(stream) {\n        stream.match(/^[\\w-]+/);\n        if (stream.match(/^\\s*:/, false))\n          return [\"variable-2\", \"variable-definition\"];\n        return [\"variable-2\", \"variable\"];\n      },\n      \"#\": function(stream) {\n        if (!stream.eat(\"{\")) return false;\n        return [null, \"interpolation\"];\n      }\n    },\n    name: \"css\",\n    helperType: \"scss\"\n  });\n\n  CodeMirror.defineMIME(\"text/x-less\", {\n    mediaTypes: mediaTypes,\n    mediaFeatures: mediaFeatures,\n    mediaValueKeywords: mediaValueKeywords,\n    propertyKeywords: propertyKeywords,\n    nonStandardPropertyKeywords: nonStandardPropertyKeywords,\n    colorKeywords: colorKeywords,\n    valueKeywords: valueKeywords,\n    fontProperties: fontProperties,\n    allowNested: true,\n    lineComment: \"//\",\n    tokenHooks: {\n      \"/\": function(stream, state) {\n        if (stream.eat(\"/\")) {\n          stream.skipToEnd();\n          return [\"comment\", \"comment\"];\n        } else if (stream.eat(\"*\")) {\n          state.tokenize = tokenCComment;\n          return tokenCComment(stream, state);\n        } else {\n          return [\"operator\", \"operator\"];\n        }\n      },\n      \"@\": function(stream) {\n        if (stream.eat(\"{\")) return [null, \"interpolation\"];\n        if (stream.match(/^(charset|document|font-face|import|(-(moz|ms|o|webkit)-)?keyframes|media|namespace|page|supports)\\b/i, false)) return false;\n        stream.eatWhile(/[\\w\\\\\\-]/);\n        if (stream.match(/^\\s*:/, false))\n          return [\"variable-2\", \"variable-definition\"];\n        return [\"variable-2\", \"variable\"];\n      },\n      \"&\": function() {\n        return [\"atom\", \"atom\"];\n      }\n    },\n    name: \"css\",\n    helperType: \"less\"\n  });\n\n  CodeMirror.defineMIME(\"text/x-gss\", {\n    documentTypes: documentTypes,\n    mediaTypes: mediaTypes,\n    mediaFeatures: mediaFeatures,\n    propertyKeywords: propertyKeywords,\n    nonStandardPropertyKeywords: nonStandardPropertyKeywords,\n    fontProperties: fontProperties,\n    counterDescriptors: counterDescriptors,\n    colorKeywords: colorKeywords,\n    valueKeywords: valueKeywords,\n    supportsAtComponent: true,\n    tokenHooks: {\n      \"/\": function(stream, state) {\n        if (!stream.eat(\"*\")) return false;\n        state.tokenize = tokenCComment;\n        return tokenCComment(stream, state);\n      }\n    },\n    name: \"css\",\n    helperType: \"gss\"\n  });\n\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29kZW1pcnJvci9tb2RlL2Nzcy9jc3MuanM/N2IwMCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBO0FBQ0EsTUFBTSxJQUF1RDtBQUM3RCxRQUFRLG1CQUFPLENBQUMseUVBQXNCO0FBQ3RDLE9BQU8sRUFHYTtBQUNwQixDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQsZ0RBQWdEO0FBQ2hELHNEQUFzRDtBQUN0RCxnRUFBZ0U7QUFDaEUsNERBQTREO0FBQzVELGtGQUFrRjtBQUNsRix3REFBd0Q7QUFDeEQsZ0VBQWdFO0FBQ2hFLHNEQUFzRDtBQUN0RCxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkIsV0FBVyxjQUFjOztBQUVwRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUssZ0JBQWdCO0FBQ3JCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxLQUFLLG9CQUFvQjtBQUN6QjtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCLGtCQUFrQjtBQUNsQixrQkFBa0IsZUFBZTtBQUNqQzs7QUFFQSwyQ0FBMkMsSUFBSSxhQUFhLEVBQUUsYUFBYSxFQUFFO0FBQzdFO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCLHlCQUF5Qix1QkFBdUIsb0JBQW9CO0FBQ3BFO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsZUFBZTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsZUFBZTtBQUNqQyxrQkFBa0I7O0FBRWxCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLGVBQWU7QUFDakM7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlCQUF5Qix1QkFBdUIsb0JBQW9CO0FBQ3BFLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCLGtCQUFrQixlQUFlO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCLGtCQUFrQixlQUFlO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRzs7QUFFSCxDQUFDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2NvZGVtaXJyb3IvbW9kZS9jc3MvY3NzLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29kZU1pcnJvciwgY29weXJpZ2h0IChjKSBieSBNYXJpam4gSGF2ZXJiZWtlIGFuZCBvdGhlcnNcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIGFuIE1JVCBsaWNlbnNlOiBodHRwczovL2NvZGVtaXJyb3IubmV0L0xJQ0VOU0VcblxuKGZ1bmN0aW9uKG1vZCkge1xuICBpZiAodHlwZW9mIGV4cG9ydHMgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlID09IFwib2JqZWN0XCIpIC8vIENvbW1vbkpTXG4gICAgbW9kKHJlcXVpcmUoXCIuLi8uLi9saWIvY29kZW1pcnJvclwiKSk7XG4gIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIC8vIEFNRFxuICAgIGRlZmluZShbXCIuLi8uLi9saWIvY29kZW1pcnJvclwiXSwgbW9kKTtcbiAgZWxzZSAvLyBQbGFpbiBicm93c2VyIGVudlxuICAgIG1vZChDb2RlTWlycm9yKTtcbn0pKGZ1bmN0aW9uKENvZGVNaXJyb3IpIHtcblwidXNlIHN0cmljdFwiO1xuXG5Db2RlTWlycm9yLmRlZmluZU1vZGUoXCJjc3NcIiwgZnVuY3Rpb24oY29uZmlnLCBwYXJzZXJDb25maWcpIHtcbiAgdmFyIGlubGluZSA9IHBhcnNlckNvbmZpZy5pbmxpbmVcbiAgaWYgKCFwYXJzZXJDb25maWcucHJvcGVydHlLZXl3b3JkcykgcGFyc2VyQ29uZmlnID0gQ29kZU1pcnJvci5yZXNvbHZlTW9kZShcInRleHQvY3NzXCIpO1xuXG4gIHZhciBpbmRlbnRVbml0ID0gY29uZmlnLmluZGVudFVuaXQsXG4gICAgICB0b2tlbkhvb2tzID0gcGFyc2VyQ29uZmlnLnRva2VuSG9va3MsXG4gICAgICBkb2N1bWVudFR5cGVzID0gcGFyc2VyQ29uZmlnLmRvY3VtZW50VHlwZXMgfHwge30sXG4gICAgICBtZWRpYVR5cGVzID0gcGFyc2VyQ29uZmlnLm1lZGlhVHlwZXMgfHwge30sXG4gICAgICBtZWRpYUZlYXR1cmVzID0gcGFyc2VyQ29uZmlnLm1lZGlhRmVhdHVyZXMgfHwge30sXG4gICAgICBtZWRpYVZhbHVlS2V5d29yZHMgPSBwYXJzZXJDb25maWcubWVkaWFWYWx1ZUtleXdvcmRzIHx8IHt9LFxuICAgICAgcHJvcGVydHlLZXl3b3JkcyA9IHBhcnNlckNvbmZpZy5wcm9wZXJ0eUtleXdvcmRzIHx8IHt9LFxuICAgICAgbm9uU3RhbmRhcmRQcm9wZXJ0eUtleXdvcmRzID0gcGFyc2VyQ29uZmlnLm5vblN0YW5kYXJkUHJvcGVydHlLZXl3b3JkcyB8fCB7fSxcbiAgICAgIGZvbnRQcm9wZXJ0aWVzID0gcGFyc2VyQ29uZmlnLmZvbnRQcm9wZXJ0aWVzIHx8IHt9LFxuICAgICAgY291bnRlckRlc2NyaXB0b3JzID0gcGFyc2VyQ29uZmlnLmNvdW50ZXJEZXNjcmlwdG9ycyB8fCB7fSxcbiAgICAgIGNvbG9yS2V5d29yZHMgPSBwYXJzZXJDb25maWcuY29sb3JLZXl3b3JkcyB8fCB7fSxcbiAgICAgIHZhbHVlS2V5d29yZHMgPSBwYXJzZXJDb25maWcudmFsdWVLZXl3b3JkcyB8fCB7fSxcbiAgICAgIGFsbG93TmVzdGVkID0gcGFyc2VyQ29uZmlnLmFsbG93TmVzdGVkLFxuICAgICAgbGluZUNvbW1lbnQgPSBwYXJzZXJDb25maWcubGluZUNvbW1lbnQsXG4gICAgICBzdXBwb3J0c0F0Q29tcG9uZW50ID0gcGFyc2VyQ29uZmlnLnN1cHBvcnRzQXRDb21wb25lbnQgPT09IHRydWUsXG4gICAgICBoaWdobGlnaHROb25TdGFuZGFyZFByb3BlcnR5S2V5d29yZHMgPSBjb25maWcuaGlnaGxpZ2h0Tm9uU3RhbmRhcmRQcm9wZXJ0eUtleXdvcmRzICE9PSBmYWxzZTtcblxuICB2YXIgdHlwZSwgb3ZlcnJpZGU7XG4gIGZ1bmN0aW9uIHJldChzdHlsZSwgdHApIHsgdHlwZSA9IHRwOyByZXR1cm4gc3R5bGU7IH1cblxuICAvLyBUb2tlbml6ZXJzXG5cbiAgZnVuY3Rpb24gdG9rZW5CYXNlKHN0cmVhbSwgc3RhdGUpIHtcbiAgICB2YXIgY2ggPSBzdHJlYW0ubmV4dCgpO1xuICAgIGlmICh0b2tlbkhvb2tzW2NoXSkge1xuICAgICAgdmFyIHJlc3VsdCA9IHRva2VuSG9va3NbY2hdKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgaWYgKHJlc3VsdCAhPT0gZmFsc2UpIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGlmIChjaCA9PSBcIkBcIikge1xuICAgICAgc3RyZWFtLmVhdFdoaWxlKC9bXFx3XFxcXFxcLV0vKTtcbiAgICAgIHJldHVybiByZXQoXCJkZWZcIiwgc3RyZWFtLmN1cnJlbnQoKSk7XG4gICAgfSBlbHNlIGlmIChjaCA9PSBcIj1cIiB8fCAoY2ggPT0gXCJ+XCIgfHwgY2ggPT0gXCJ8XCIpICYmIHN0cmVhbS5lYXQoXCI9XCIpKSB7XG4gICAgICByZXR1cm4gcmV0KG51bGwsIFwiY29tcGFyZVwiKTtcbiAgICB9IGVsc2UgaWYgKGNoID09IFwiXFxcIlwiIHx8IGNoID09IFwiJ1wiKSB7XG4gICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuU3RyaW5nKGNoKTtcbiAgICAgIHJldHVybiBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKTtcbiAgICB9IGVsc2UgaWYgKGNoID09IFwiI1wiKSB7XG4gICAgICBzdHJlYW0uZWF0V2hpbGUoL1tcXHdcXFxcXFwtXS8pO1xuICAgICAgcmV0dXJuIHJldChcImF0b21cIiwgXCJoYXNoXCIpO1xuICAgIH0gZWxzZSBpZiAoY2ggPT0gXCIhXCIpIHtcbiAgICAgIHN0cmVhbS5tYXRjaCgvXlxccypcXHcqLyk7XG4gICAgICByZXR1cm4gcmV0KFwia2V5d29yZFwiLCBcImltcG9ydGFudFwiKTtcbiAgICB9IGVsc2UgaWYgKC9cXGQvLnRlc3QoY2gpIHx8IGNoID09IFwiLlwiICYmIHN0cmVhbS5lYXQoL1xcZC8pKSB7XG4gICAgICBzdHJlYW0uZWF0V2hpbGUoL1tcXHcuJV0vKTtcbiAgICAgIHJldHVybiByZXQoXCJudW1iZXJcIiwgXCJ1bml0XCIpO1xuICAgIH0gZWxzZSBpZiAoY2ggPT09IFwiLVwiKSB7XG4gICAgICBpZiAoL1tcXGQuXS8udGVzdChzdHJlYW0ucGVlaygpKSkge1xuICAgICAgICBzdHJlYW0uZWF0V2hpbGUoL1tcXHcuJV0vKTtcbiAgICAgICAgcmV0dXJuIHJldChcIm51bWJlclwiLCBcInVuaXRcIik7XG4gICAgICB9IGVsc2UgaWYgKHN0cmVhbS5tYXRjaCgvXi1bXFx3XFxcXFxcLV0qLykpIHtcbiAgICAgICAgc3RyZWFtLmVhdFdoaWxlKC9bXFx3XFxcXFxcLV0vKTtcbiAgICAgICAgaWYgKHN0cmVhbS5tYXRjaCgvXlxccyo6LywgZmFsc2UpKVxuICAgICAgICAgIHJldHVybiByZXQoXCJ2YXJpYWJsZS0yXCIsIFwidmFyaWFibGUtZGVmaW5pdGlvblwiKTtcbiAgICAgICAgcmV0dXJuIHJldChcInZhcmlhYmxlLTJcIiwgXCJ2YXJpYWJsZVwiKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RyZWFtLm1hdGNoKC9eXFx3Ky0vKSkge1xuICAgICAgICByZXR1cm4gcmV0KFwibWV0YVwiLCBcIm1ldGFcIik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICgvWywrPipcXC9dLy50ZXN0KGNoKSkge1xuICAgICAgcmV0dXJuIHJldChudWxsLCBcInNlbGVjdC1vcFwiKTtcbiAgICB9IGVsc2UgaWYgKGNoID09IFwiLlwiICYmIHN0cmVhbS5tYXRjaCgvXi0/W19hLXpdW19hLXowLTktXSovaSkpIHtcbiAgICAgIHJldHVybiByZXQoXCJxdWFsaWZpZXJcIiwgXCJxdWFsaWZpZXJcIik7XG4gICAgfSBlbHNlIGlmICgvWzo7e31cXFtcXF1cXChcXCldLy50ZXN0KGNoKSkge1xuICAgICAgcmV0dXJuIHJldChudWxsLCBjaCk7XG4gICAgfSBlbHNlIGlmIChzdHJlYW0ubWF0Y2goL1tcXHctLl0rKD89XFwoKS8pKSB7XG4gICAgICBpZiAoL14odXJsKC1wcmVmaXgpP3xkb21haW58cmVnZXhwKSQvLnRlc3Qoc3RyZWFtLmN1cnJlbnQoKS50b0xvd2VyQ2FzZSgpKSkge1xuICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuUGFyZW50aGVzaXplZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQoXCJ2YXJpYWJsZSBjYWxsZWVcIiwgXCJ2YXJpYWJsZVwiKTtcbiAgICB9IGVsc2UgaWYgKC9bXFx3XFxcXFxcLV0vLnRlc3QoY2gpKSB7XG4gICAgICBzdHJlYW0uZWF0V2hpbGUoL1tcXHdcXFxcXFwtXS8pO1xuICAgICAgcmV0dXJuIHJldChcInByb3BlcnR5XCIsIFwid29yZFwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHJldChudWxsLCBudWxsKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB0b2tlblN0cmluZyhxdW90ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICB2YXIgZXNjYXBlZCA9IGZhbHNlLCBjaDtcbiAgICAgIHdoaWxlICgoY2ggPSBzdHJlYW0ubmV4dCgpKSAhPSBudWxsKSB7XG4gICAgICAgIGlmIChjaCA9PSBxdW90ZSAmJiAhZXNjYXBlZCkge1xuICAgICAgICAgIGlmIChxdW90ZSA9PSBcIilcIikgc3RyZWFtLmJhY2tVcCgxKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBlc2NhcGVkID0gIWVzY2FwZWQgJiYgY2ggPT0gXCJcXFxcXCI7XG4gICAgICB9XG4gICAgICBpZiAoY2ggPT0gcXVvdGUgfHwgIWVzY2FwZWQgJiYgcXVvdGUgIT0gXCIpXCIpIHN0YXRlLnRva2VuaXplID0gbnVsbDtcbiAgICAgIHJldHVybiByZXQoXCJzdHJpbmdcIiwgXCJzdHJpbmdcIik7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRva2VuUGFyZW50aGVzaXplZChzdHJlYW0sIHN0YXRlKSB7XG4gICAgc3RyZWFtLm5leHQoKTsgLy8gTXVzdCBiZSAnKCdcbiAgICBpZiAoIXN0cmVhbS5tYXRjaCgvXFxzKltcXFwiXFwnKV0vLCBmYWxzZSkpXG4gICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuU3RyaW5nKFwiKVwiKTtcbiAgICBlbHNlXG4gICAgICBzdGF0ZS50b2tlbml6ZSA9IG51bGw7XG4gICAgcmV0dXJuIHJldChudWxsLCBcIihcIik7XG4gIH1cblxuICAvLyBDb250ZXh0IG1hbmFnZW1lbnRcblxuICBmdW5jdGlvbiBDb250ZXh0KHR5cGUsIGluZGVudCwgcHJldikge1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5pbmRlbnQgPSBpbmRlbnQ7XG4gICAgdGhpcy5wcmV2ID0gcHJldjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHB1c2hDb250ZXh0KHN0YXRlLCBzdHJlYW0sIHR5cGUsIGluZGVudCkge1xuICAgIHN0YXRlLmNvbnRleHQgPSBuZXcgQ29udGV4dCh0eXBlLCBzdHJlYW0uaW5kZW50YXRpb24oKSArIChpbmRlbnQgPT09IGZhbHNlID8gMCA6IGluZGVudFVuaXQpLCBzdGF0ZS5jb250ZXh0KTtcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBvcENvbnRleHQoc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUuY29udGV4dC5wcmV2KVxuICAgICAgc3RhdGUuY29udGV4dCA9IHN0YXRlLmNvbnRleHQucHJldjtcbiAgICByZXR1cm4gc3RhdGUuY29udGV4dC50eXBlO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFzcyh0eXBlLCBzdHJlYW0sIHN0YXRlKSB7XG4gICAgcmV0dXJuIHN0YXRlc1tzdGF0ZS5jb250ZXh0LnR5cGVdKHR5cGUsIHN0cmVhbSwgc3RhdGUpO1xuICB9XG4gIGZ1bmN0aW9uIHBvcEFuZFBhc3ModHlwZSwgc3RyZWFtLCBzdGF0ZSwgbikge1xuICAgIGZvciAodmFyIGkgPSBuIHx8IDE7IGkgPiAwOyBpLS0pXG4gICAgICBzdGF0ZS5jb250ZXh0ID0gc3RhdGUuY29udGV4dC5wcmV2O1xuICAgIHJldHVybiBwYXNzKHR5cGUsIHN0cmVhbSwgc3RhdGUpO1xuICB9XG5cbiAgLy8gUGFyc2VyXG5cbiAgZnVuY3Rpb24gd29yZEFzVmFsdWUoc3RyZWFtKSB7XG4gICAgdmFyIHdvcmQgPSBzdHJlYW0uY3VycmVudCgpLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKHZhbHVlS2V5d29yZHMuaGFzT3duUHJvcGVydHkod29yZCkpXG4gICAgICBvdmVycmlkZSA9IFwiYXRvbVwiO1xuICAgIGVsc2UgaWYgKGNvbG9yS2V5d29yZHMuaGFzT3duUHJvcGVydHkod29yZCkpXG4gICAgICBvdmVycmlkZSA9IFwia2V5d29yZFwiO1xuICAgIGVsc2VcbiAgICAgIG92ZXJyaWRlID0gXCJ2YXJpYWJsZVwiO1xuICB9XG5cbiAgdmFyIHN0YXRlcyA9IHt9O1xuXG4gIHN0YXRlcy50b3AgPSBmdW5jdGlvbih0eXBlLCBzdHJlYW0sIHN0YXRlKSB7XG4gICAgaWYgKHR5cGUgPT0gXCJ7XCIpIHtcbiAgICAgIHJldHVybiBwdXNoQ29udGV4dChzdGF0ZSwgc3RyZWFtLCBcImJsb2NrXCIpO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PSBcIn1cIiAmJiBzdGF0ZS5jb250ZXh0LnByZXYpIHtcbiAgICAgIHJldHVybiBwb3BDb250ZXh0KHN0YXRlKTtcbiAgICB9IGVsc2UgaWYgKHN1cHBvcnRzQXRDb21wb25lbnQgJiYgL0Bjb21wb25lbnQvaS50ZXN0KHR5cGUpKSB7XG4gICAgICByZXR1cm4gcHVzaENvbnRleHQoc3RhdGUsIHN0cmVhbSwgXCJhdENvbXBvbmVudEJsb2NrXCIpO1xuICAgIH0gZWxzZSBpZiAoL15AKC1tb3otKT9kb2N1bWVudCQvaS50ZXN0KHR5cGUpKSB7XG4gICAgICByZXR1cm4gcHVzaENvbnRleHQoc3RhdGUsIHN0cmVhbSwgXCJkb2N1bWVudFR5cGVzXCIpO1xuICAgIH0gZWxzZSBpZiAoL15AKG1lZGlhfHN1cHBvcnRzfCgtbW96LSk/ZG9jdW1lbnR8aW1wb3J0KSQvaS50ZXN0KHR5cGUpKSB7XG4gICAgICByZXR1cm4gcHVzaENvbnRleHQoc3RhdGUsIHN0cmVhbSwgXCJhdEJsb2NrXCIpO1xuICAgIH0gZWxzZSBpZiAoL15AKGZvbnQtZmFjZXxjb3VudGVyLXN0eWxlKS9pLnRlc3QodHlwZSkpIHtcbiAgICAgIHN0YXRlLnN0YXRlQXJnID0gdHlwZTtcbiAgICAgIHJldHVybiBcInJlc3RyaWN0ZWRfYXRCbG9ja19iZWZvcmVcIjtcbiAgICB9IGVsc2UgaWYgKC9eQCgtKG1venxtc3xvfHdlYmtpdCktKT9rZXlmcmFtZXMkL2kudGVzdCh0eXBlKSkge1xuICAgICAgcmV0dXJuIFwia2V5ZnJhbWVzXCI7XG4gICAgfSBlbHNlIGlmICh0eXBlICYmIHR5cGUuY2hhckF0KDApID09IFwiQFwiKSB7XG4gICAgICByZXR1cm4gcHVzaENvbnRleHQoc3RhdGUsIHN0cmVhbSwgXCJhdFwiKTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT0gXCJoYXNoXCIpIHtcbiAgICAgIG92ZXJyaWRlID0gXCJidWlsdGluXCI7XG4gICAgfSBlbHNlIGlmICh0eXBlID09IFwid29yZFwiKSB7XG4gICAgICBvdmVycmlkZSA9IFwidGFnXCI7XG4gICAgfSBlbHNlIGlmICh0eXBlID09IFwidmFyaWFibGUtZGVmaW5pdGlvblwiKSB7XG4gICAgICByZXR1cm4gXCJtYXliZXByb3BcIjtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT0gXCJpbnRlcnBvbGF0aW9uXCIpIHtcbiAgICAgIHJldHVybiBwdXNoQ29udGV4dChzdGF0ZSwgc3RyZWFtLCBcImludGVycG9sYXRpb25cIik7XG4gICAgfSBlbHNlIGlmICh0eXBlID09IFwiOlwiKSB7XG4gICAgICByZXR1cm4gXCJwc2V1ZG9cIjtcbiAgICB9IGVsc2UgaWYgKGFsbG93TmVzdGVkICYmIHR5cGUgPT0gXCIoXCIpIHtcbiAgICAgIHJldHVybiBwdXNoQ29udGV4dChzdGF0ZSwgc3RyZWFtLCBcInBhcmVuc1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0YXRlLmNvbnRleHQudHlwZTtcbiAgfTtcblxuICBzdGF0ZXMuYmxvY2sgPSBmdW5jdGlvbih0eXBlLCBzdHJlYW0sIHN0YXRlKSB7XG4gICAgaWYgKHR5cGUgPT0gXCJ3b3JkXCIpIHtcbiAgICAgIHZhciB3b3JkID0gc3RyZWFtLmN1cnJlbnQoKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKHByb3BlcnR5S2V5d29yZHMuaGFzT3duUHJvcGVydHkod29yZCkpIHtcbiAgICAgICAgb3ZlcnJpZGUgPSBcInByb3BlcnR5XCI7XG4gICAgICAgIHJldHVybiBcIm1heWJlcHJvcFwiO1xuICAgICAgfSBlbHNlIGlmIChub25TdGFuZGFyZFByb3BlcnR5S2V5d29yZHMuaGFzT3duUHJvcGVydHkod29yZCkpIHtcbiAgICAgICAgb3ZlcnJpZGUgPSBoaWdobGlnaHROb25TdGFuZGFyZFByb3BlcnR5S2V5d29yZHMgPyBcInN0cmluZy0yXCIgOiBcInByb3BlcnR5XCI7XG4gICAgICAgIHJldHVybiBcIm1heWJlcHJvcFwiO1xuICAgICAgfSBlbHNlIGlmIChhbGxvd05lc3RlZCkge1xuICAgICAgICBvdmVycmlkZSA9IHN0cmVhbS5tYXRjaCgvXlxccyo6KD86XFxzfCQpLywgZmFsc2UpID8gXCJwcm9wZXJ0eVwiIDogXCJ0YWdcIjtcbiAgICAgICAgcmV0dXJuIFwiYmxvY2tcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG92ZXJyaWRlICs9IFwiIGVycm9yXCI7XG4gICAgICAgIHJldHVybiBcIm1heWJlcHJvcFwiO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PSBcIm1ldGFcIikge1xuICAgICAgcmV0dXJuIFwiYmxvY2tcIjtcbiAgICB9IGVsc2UgaWYgKCFhbGxvd05lc3RlZCAmJiAodHlwZSA9PSBcImhhc2hcIiB8fCB0eXBlID09IFwicXVhbGlmaWVyXCIpKSB7XG4gICAgICBvdmVycmlkZSA9IFwiZXJyb3JcIjtcbiAgICAgIHJldHVybiBcImJsb2NrXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBzdGF0ZXMudG9wKHR5cGUsIHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cbiAgfTtcblxuICBzdGF0ZXMubWF5YmVwcm9wID0gZnVuY3Rpb24odHlwZSwgc3RyZWFtLCBzdGF0ZSkge1xuICAgIGlmICh0eXBlID09IFwiOlwiKSByZXR1cm4gcHVzaENvbnRleHQoc3RhdGUsIHN0cmVhbSwgXCJwcm9wXCIpO1xuICAgIHJldHVybiBwYXNzKHR5cGUsIHN0cmVhbSwgc3RhdGUpO1xuICB9O1xuXG4gIHN0YXRlcy5wcm9wID0gZnVuY3Rpb24odHlwZSwgc3RyZWFtLCBzdGF0ZSkge1xuICAgIGlmICh0eXBlID09IFwiO1wiKSByZXR1cm4gcG9wQ29udGV4dChzdGF0ZSk7XG4gICAgaWYgKHR5cGUgPT0gXCJ7XCIgJiYgYWxsb3dOZXN0ZWQpIHJldHVybiBwdXNoQ29udGV4dChzdGF0ZSwgc3RyZWFtLCBcInByb3BCbG9ja1wiKTtcbiAgICBpZiAodHlwZSA9PSBcIn1cIiB8fCB0eXBlID09IFwie1wiKSByZXR1cm4gcG9wQW5kUGFzcyh0eXBlLCBzdHJlYW0sIHN0YXRlKTtcbiAgICBpZiAodHlwZSA9PSBcIihcIikgcmV0dXJuIHB1c2hDb250ZXh0KHN0YXRlLCBzdHJlYW0sIFwicGFyZW5zXCIpO1xuXG4gICAgaWYgKHR5cGUgPT0gXCJoYXNoXCIgJiYgIS9eIyhbMC05YS1mQS1mXXszLDR9fFswLTlhLWZBLWZdezZ9fFswLTlhLWZBLWZdezh9KSQvLnRlc3Qoc3RyZWFtLmN1cnJlbnQoKSkpIHtcbiAgICAgIG92ZXJyaWRlICs9IFwiIGVycm9yXCI7XG4gICAgfSBlbHNlIGlmICh0eXBlID09IFwid29yZFwiKSB7XG4gICAgICB3b3JkQXNWYWx1ZShzdHJlYW0pO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PSBcImludGVycG9sYXRpb25cIikge1xuICAgICAgcmV0dXJuIHB1c2hDb250ZXh0KHN0YXRlLCBzdHJlYW0sIFwiaW50ZXJwb2xhdGlvblwiKTtcbiAgICB9XG4gICAgcmV0dXJuIFwicHJvcFwiO1xuICB9O1xuXG4gIHN0YXRlcy5wcm9wQmxvY2sgPSBmdW5jdGlvbih0eXBlLCBfc3RyZWFtLCBzdGF0ZSkge1xuICAgIGlmICh0eXBlID09IFwifVwiKSByZXR1cm4gcG9wQ29udGV4dChzdGF0ZSk7XG4gICAgaWYgKHR5cGUgPT0gXCJ3b3JkXCIpIHsgb3ZlcnJpZGUgPSBcInByb3BlcnR5XCI7IHJldHVybiBcIm1heWJlcHJvcFwiOyB9XG4gICAgcmV0dXJuIHN0YXRlLmNvbnRleHQudHlwZTtcbiAgfTtcblxuICBzdGF0ZXMucGFyZW5zID0gZnVuY3Rpb24odHlwZSwgc3RyZWFtLCBzdGF0ZSkge1xuICAgIGlmICh0eXBlID09IFwie1wiIHx8IHR5cGUgPT0gXCJ9XCIpIHJldHVybiBwb3BBbmRQYXNzKHR5cGUsIHN0cmVhbSwgc3RhdGUpO1xuICAgIGlmICh0eXBlID09IFwiKVwiKSByZXR1cm4gcG9wQ29udGV4dChzdGF0ZSk7XG4gICAgaWYgKHR5cGUgPT0gXCIoXCIpIHJldHVybiBwdXNoQ29udGV4dChzdGF0ZSwgc3RyZWFtLCBcInBhcmVuc1wiKTtcbiAgICBpZiAodHlwZSA9PSBcImludGVycG9sYXRpb25cIikgcmV0dXJuIHB1c2hDb250ZXh0KHN0YXRlLCBzdHJlYW0sIFwiaW50ZXJwb2xhdGlvblwiKTtcbiAgICBpZiAodHlwZSA9PSBcIndvcmRcIikgd29yZEFzVmFsdWUoc3RyZWFtKTtcbiAgICByZXR1cm4gXCJwYXJlbnNcIjtcbiAgfTtcblxuICBzdGF0ZXMucHNldWRvID0gZnVuY3Rpb24odHlwZSwgc3RyZWFtLCBzdGF0ZSkge1xuICAgIGlmICh0eXBlID09IFwibWV0YVwiKSByZXR1cm4gXCJwc2V1ZG9cIjtcblxuICAgIGlmICh0eXBlID09IFwid29yZFwiKSB7XG4gICAgICBvdmVycmlkZSA9IFwidmFyaWFibGUtM1wiO1xuICAgICAgcmV0dXJuIHN0YXRlLmNvbnRleHQudHlwZTtcbiAgICB9XG4gICAgcmV0dXJuIHBhc3ModHlwZSwgc3RyZWFtLCBzdGF0ZSk7XG4gIH07XG5cbiAgc3RhdGVzLmRvY3VtZW50VHlwZXMgPSBmdW5jdGlvbih0eXBlLCBzdHJlYW0sIHN0YXRlKSB7XG4gICAgaWYgKHR5cGUgPT0gXCJ3b3JkXCIgJiYgZG9jdW1lbnRUeXBlcy5oYXNPd25Qcm9wZXJ0eShzdHJlYW0uY3VycmVudCgpKSkge1xuICAgICAgb3ZlcnJpZGUgPSBcInRhZ1wiO1xuICAgICAgcmV0dXJuIHN0YXRlLmNvbnRleHQudHlwZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHN0YXRlcy5hdEJsb2NrKHR5cGUsIHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cbiAgfTtcblxuICBzdGF0ZXMuYXRCbG9jayA9IGZ1bmN0aW9uKHR5cGUsIHN0cmVhbSwgc3RhdGUpIHtcbiAgICBpZiAodHlwZSA9PSBcIihcIikgcmV0dXJuIHB1c2hDb250ZXh0KHN0YXRlLCBzdHJlYW0sIFwiYXRCbG9ja19wYXJlbnNcIik7XG4gICAgaWYgKHR5cGUgPT0gXCJ9XCIgfHwgdHlwZSA9PSBcIjtcIikgcmV0dXJuIHBvcEFuZFBhc3ModHlwZSwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgaWYgKHR5cGUgPT0gXCJ7XCIpIHJldHVybiBwb3BDb250ZXh0KHN0YXRlKSAmJiBwdXNoQ29udGV4dChzdGF0ZSwgc3RyZWFtLCBhbGxvd05lc3RlZCA/IFwiYmxvY2tcIiA6IFwidG9wXCIpO1xuXG4gICAgaWYgKHR5cGUgPT0gXCJpbnRlcnBvbGF0aW9uXCIpIHJldHVybiBwdXNoQ29udGV4dChzdGF0ZSwgc3RyZWFtLCBcImludGVycG9sYXRpb25cIik7XG5cbiAgICBpZiAodHlwZSA9PSBcIndvcmRcIikge1xuICAgICAgdmFyIHdvcmQgPSBzdHJlYW0uY3VycmVudCgpLnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAod29yZCA9PSBcIm9ubHlcIiB8fCB3b3JkID09IFwibm90XCIgfHwgd29yZCA9PSBcImFuZFwiIHx8IHdvcmQgPT0gXCJvclwiKVxuICAgICAgICBvdmVycmlkZSA9IFwia2V5d29yZFwiO1xuICAgICAgZWxzZSBpZiAobWVkaWFUeXBlcy5oYXNPd25Qcm9wZXJ0eSh3b3JkKSlcbiAgICAgICAgb3ZlcnJpZGUgPSBcImF0dHJpYnV0ZVwiO1xuICAgICAgZWxzZSBpZiAobWVkaWFGZWF0dXJlcy5oYXNPd25Qcm9wZXJ0eSh3b3JkKSlcbiAgICAgICAgb3ZlcnJpZGUgPSBcInByb3BlcnR5XCI7XG4gICAgICBlbHNlIGlmIChtZWRpYVZhbHVlS2V5d29yZHMuaGFzT3duUHJvcGVydHkod29yZCkpXG4gICAgICAgIG92ZXJyaWRlID0gXCJrZXl3b3JkXCI7XG4gICAgICBlbHNlIGlmIChwcm9wZXJ0eUtleXdvcmRzLmhhc093blByb3BlcnR5KHdvcmQpKVxuICAgICAgICBvdmVycmlkZSA9IFwicHJvcGVydHlcIjtcbiAgICAgIGVsc2UgaWYgKG5vblN0YW5kYXJkUHJvcGVydHlLZXl3b3Jkcy5oYXNPd25Qcm9wZXJ0eSh3b3JkKSlcbiAgICAgICAgb3ZlcnJpZGUgPSBoaWdobGlnaHROb25TdGFuZGFyZFByb3BlcnR5S2V5d29yZHMgPyBcInN0cmluZy0yXCIgOiBcInByb3BlcnR5XCI7XG4gICAgICBlbHNlIGlmICh2YWx1ZUtleXdvcmRzLmhhc093blByb3BlcnR5KHdvcmQpKVxuICAgICAgICBvdmVycmlkZSA9IFwiYXRvbVwiO1xuICAgICAgZWxzZSBpZiAoY29sb3JLZXl3b3Jkcy5oYXNPd25Qcm9wZXJ0eSh3b3JkKSlcbiAgICAgICAgb3ZlcnJpZGUgPSBcImtleXdvcmRcIjtcbiAgICAgIGVsc2VcbiAgICAgICAgb3ZlcnJpZGUgPSBcImVycm9yXCI7XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZS5jb250ZXh0LnR5cGU7XG4gIH07XG5cbiAgc3RhdGVzLmF0Q29tcG9uZW50QmxvY2sgPSBmdW5jdGlvbih0eXBlLCBzdHJlYW0sIHN0YXRlKSB7XG4gICAgaWYgKHR5cGUgPT0gXCJ9XCIpXG4gICAgICByZXR1cm4gcG9wQW5kUGFzcyh0eXBlLCBzdHJlYW0sIHN0YXRlKTtcbiAgICBpZiAodHlwZSA9PSBcIntcIilcbiAgICAgIHJldHVybiBwb3BDb250ZXh0KHN0YXRlKSAmJiBwdXNoQ29udGV4dChzdGF0ZSwgc3RyZWFtLCBhbGxvd05lc3RlZCA/IFwiYmxvY2tcIiA6IFwidG9wXCIsIGZhbHNlKTtcbiAgICBpZiAodHlwZSA9PSBcIndvcmRcIilcbiAgICAgIG92ZXJyaWRlID0gXCJlcnJvclwiO1xuICAgIHJldHVybiBzdGF0ZS5jb250ZXh0LnR5cGU7XG4gIH07XG5cbiAgc3RhdGVzLmF0QmxvY2tfcGFyZW5zID0gZnVuY3Rpb24odHlwZSwgc3RyZWFtLCBzdGF0ZSkge1xuICAgIGlmICh0eXBlID09IFwiKVwiKSByZXR1cm4gcG9wQ29udGV4dChzdGF0ZSk7XG4gICAgaWYgKHR5cGUgPT0gXCJ7XCIgfHwgdHlwZSA9PSBcIn1cIikgcmV0dXJuIHBvcEFuZFBhc3ModHlwZSwgc3RyZWFtLCBzdGF0ZSwgMik7XG4gICAgcmV0dXJuIHN0YXRlcy5hdEJsb2NrKHR5cGUsIHN0cmVhbSwgc3RhdGUpO1xuICB9O1xuXG4gIHN0YXRlcy5yZXN0cmljdGVkX2F0QmxvY2tfYmVmb3JlID0gZnVuY3Rpb24odHlwZSwgc3RyZWFtLCBzdGF0ZSkge1xuICAgIGlmICh0eXBlID09IFwie1wiKVxuICAgICAgcmV0dXJuIHB1c2hDb250ZXh0KHN0YXRlLCBzdHJlYW0sIFwicmVzdHJpY3RlZF9hdEJsb2NrXCIpO1xuICAgIGlmICh0eXBlID09IFwid29yZFwiICYmIHN0YXRlLnN0YXRlQXJnID09IFwiQGNvdW50ZXItc3R5bGVcIikge1xuICAgICAgb3ZlcnJpZGUgPSBcInZhcmlhYmxlXCI7XG4gICAgICByZXR1cm4gXCJyZXN0cmljdGVkX2F0QmxvY2tfYmVmb3JlXCI7XG4gICAgfVxuICAgIHJldHVybiBwYXNzKHR5cGUsIHN0cmVhbSwgc3RhdGUpO1xuICB9O1xuXG4gIHN0YXRlcy5yZXN0cmljdGVkX2F0QmxvY2sgPSBmdW5jdGlvbih0eXBlLCBzdHJlYW0sIHN0YXRlKSB7XG4gICAgaWYgKHR5cGUgPT0gXCJ9XCIpIHtcbiAgICAgIHN0YXRlLnN0YXRlQXJnID0gbnVsbDtcbiAgICAgIHJldHVybiBwb3BDb250ZXh0KHN0YXRlKTtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT0gXCJ3b3JkXCIpIHtcbiAgICAgIGlmICgoc3RhdGUuc3RhdGVBcmcgPT0gXCJAZm9udC1mYWNlXCIgJiYgIWZvbnRQcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KHN0cmVhbS5jdXJyZW50KCkudG9Mb3dlckNhc2UoKSkpIHx8XG4gICAgICAgICAgKHN0YXRlLnN0YXRlQXJnID09IFwiQGNvdW50ZXItc3R5bGVcIiAmJiAhY291bnRlckRlc2NyaXB0b3JzLmhhc093blByb3BlcnR5KHN0cmVhbS5jdXJyZW50KCkudG9Mb3dlckNhc2UoKSkpKVxuICAgICAgICBvdmVycmlkZSA9IFwiZXJyb3JcIjtcbiAgICAgIGVsc2VcbiAgICAgICAgb3ZlcnJpZGUgPSBcInByb3BlcnR5XCI7XG4gICAgICByZXR1cm4gXCJtYXliZXByb3BcIjtcbiAgICB9XG4gICAgcmV0dXJuIFwicmVzdHJpY3RlZF9hdEJsb2NrXCI7XG4gIH07XG5cbiAgc3RhdGVzLmtleWZyYW1lcyA9IGZ1bmN0aW9uKHR5cGUsIHN0cmVhbSwgc3RhdGUpIHtcbiAgICBpZiAodHlwZSA9PSBcIndvcmRcIikgeyBvdmVycmlkZSA9IFwidmFyaWFibGVcIjsgcmV0dXJuIFwia2V5ZnJhbWVzXCI7IH1cbiAgICBpZiAodHlwZSA9PSBcIntcIikgcmV0dXJuIHB1c2hDb250ZXh0KHN0YXRlLCBzdHJlYW0sIFwidG9wXCIpO1xuICAgIHJldHVybiBwYXNzKHR5cGUsIHN0cmVhbSwgc3RhdGUpO1xuICB9O1xuXG4gIHN0YXRlcy5hdCA9IGZ1bmN0aW9uKHR5cGUsIHN0cmVhbSwgc3RhdGUpIHtcbiAgICBpZiAodHlwZSA9PSBcIjtcIikgcmV0dXJuIHBvcENvbnRleHQoc3RhdGUpO1xuICAgIGlmICh0eXBlID09IFwie1wiIHx8IHR5cGUgPT0gXCJ9XCIpIHJldHVybiBwb3BBbmRQYXNzKHR5cGUsIHN0cmVhbSwgc3RhdGUpO1xuICAgIGlmICh0eXBlID09IFwid29yZFwiKSBvdmVycmlkZSA9IFwidGFnXCI7XG4gICAgZWxzZSBpZiAodHlwZSA9PSBcImhhc2hcIikgb3ZlcnJpZGUgPSBcImJ1aWx0aW5cIjtcbiAgICByZXR1cm4gXCJhdFwiO1xuICB9O1xuXG4gIHN0YXRlcy5pbnRlcnBvbGF0aW9uID0gZnVuY3Rpb24odHlwZSwgc3RyZWFtLCBzdGF0ZSkge1xuICAgIGlmICh0eXBlID09IFwifVwiKSByZXR1cm4gcG9wQ29udGV4dChzdGF0ZSk7XG4gICAgaWYgKHR5cGUgPT0gXCJ7XCIgfHwgdHlwZSA9PSBcIjtcIikgcmV0dXJuIHBvcEFuZFBhc3ModHlwZSwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgaWYgKHR5cGUgPT0gXCJ3b3JkXCIpIG92ZXJyaWRlID0gXCJ2YXJpYWJsZVwiO1xuICAgIGVsc2UgaWYgKHR5cGUgIT0gXCJ2YXJpYWJsZVwiICYmIHR5cGUgIT0gXCIoXCIgJiYgdHlwZSAhPSBcIilcIikgb3ZlcnJpZGUgPSBcImVycm9yXCI7XG4gICAgcmV0dXJuIFwiaW50ZXJwb2xhdGlvblwiO1xuICB9O1xuXG4gIHJldHVybiB7XG4gICAgc3RhcnRTdGF0ZTogZnVuY3Rpb24oYmFzZSkge1xuICAgICAgcmV0dXJuIHt0b2tlbml6ZTogbnVsbCxcbiAgICAgICAgICAgICAgc3RhdGU6IGlubGluZSA/IFwiYmxvY2tcIiA6IFwidG9wXCIsXG4gICAgICAgICAgICAgIHN0YXRlQXJnOiBudWxsLFxuICAgICAgICAgICAgICBjb250ZXh0OiBuZXcgQ29udGV4dChpbmxpbmUgPyBcImJsb2NrXCIgOiBcInRvcFwiLCBiYXNlIHx8IDAsIG51bGwpfTtcbiAgICB9LFxuXG4gICAgdG9rZW46IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIGlmICghc3RhdGUudG9rZW5pemUgJiYgc3RyZWFtLmVhdFNwYWNlKCkpIHJldHVybiBudWxsO1xuICAgICAgdmFyIHN0eWxlID0gKHN0YXRlLnRva2VuaXplIHx8IHRva2VuQmFzZSkoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICBpZiAoc3R5bGUgJiYgdHlwZW9mIHN0eWxlID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgdHlwZSA9IHN0eWxlWzFdO1xuICAgICAgICBzdHlsZSA9IHN0eWxlWzBdO1xuICAgICAgfVxuICAgICAgb3ZlcnJpZGUgPSBzdHlsZTtcbiAgICAgIGlmICh0eXBlICE9IFwiY29tbWVudFwiKVxuICAgICAgICBzdGF0ZS5zdGF0ZSA9IHN0YXRlc1tzdGF0ZS5zdGF0ZV0odHlwZSwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgICByZXR1cm4gb3ZlcnJpZGU7XG4gICAgfSxcblxuICAgIGluZGVudDogZnVuY3Rpb24oc3RhdGUsIHRleHRBZnRlcikge1xuICAgICAgdmFyIGN4ID0gc3RhdGUuY29udGV4dCwgY2ggPSB0ZXh0QWZ0ZXIgJiYgdGV4dEFmdGVyLmNoYXJBdCgwKTtcbiAgICAgIHZhciBpbmRlbnQgPSBjeC5pbmRlbnQ7XG4gICAgICBpZiAoY3gudHlwZSA9PSBcInByb3BcIiAmJiAoY2ggPT0gXCJ9XCIgfHwgY2ggPT0gXCIpXCIpKSBjeCA9IGN4LnByZXY7XG4gICAgICBpZiAoY3gucHJldikge1xuICAgICAgICBpZiAoY2ggPT0gXCJ9XCIgJiYgKGN4LnR5cGUgPT0gXCJibG9ja1wiIHx8IGN4LnR5cGUgPT0gXCJ0b3BcIiB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICBjeC50eXBlID09IFwiaW50ZXJwb2xhdGlvblwiIHx8IGN4LnR5cGUgPT0gXCJyZXN0cmljdGVkX2F0QmxvY2tcIikpIHtcbiAgICAgICAgICAvLyBSZXN1bWUgaW5kZW50YXRpb24gZnJvbSBwYXJlbnQgY29udGV4dC5cbiAgICAgICAgICBjeCA9IGN4LnByZXY7XG4gICAgICAgICAgaW5kZW50ID0gY3guaW5kZW50O1xuICAgICAgICB9IGVsc2UgaWYgKGNoID09IFwiKVwiICYmIChjeC50eXBlID09IFwicGFyZW5zXCIgfHwgY3gudHlwZSA9PSBcImF0QmxvY2tfcGFyZW5zXCIpIHx8XG4gICAgICAgICAgICBjaCA9PSBcIntcIiAmJiAoY3gudHlwZSA9PSBcImF0XCIgfHwgY3gudHlwZSA9PSBcImF0QmxvY2tcIikpIHtcbiAgICAgICAgICAvLyBEZWRlbnQgcmVsYXRpdmUgdG8gY3VycmVudCBjb250ZXh0LlxuICAgICAgICAgIGluZGVudCA9IE1hdGgubWF4KDAsIGN4LmluZGVudCAtIGluZGVudFVuaXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaW5kZW50O1xuICAgIH0sXG5cbiAgICBlbGVjdHJpY0NoYXJzOiBcIn1cIixcbiAgICBibG9ja0NvbW1lbnRTdGFydDogXCIvKlwiLFxuICAgIGJsb2NrQ29tbWVudEVuZDogXCIqL1wiLFxuICAgIGJsb2NrQ29tbWVudENvbnRpbnVlOiBcIiAqIFwiLFxuICAgIGxpbmVDb21tZW50OiBsaW5lQ29tbWVudCxcbiAgICBmb2xkOiBcImJyYWNlXCJcbiAgfTtcbn0pO1xuXG4gIGZ1bmN0aW9uIGtleVNldChhcnJheSkge1xuICAgIHZhciBrZXlzID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7ICsraSkge1xuICAgICAga2V5c1thcnJheVtpXS50b0xvd2VyQ2FzZSgpXSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBrZXlzO1xuICB9XG5cbiAgdmFyIGRvY3VtZW50VHlwZXNfID0gW1xuICAgIFwiZG9tYWluXCIsIFwicmVnZXhwXCIsIFwidXJsXCIsIFwidXJsLXByZWZpeFwiXG4gIF0sIGRvY3VtZW50VHlwZXMgPSBrZXlTZXQoZG9jdW1lbnRUeXBlc18pO1xuXG4gIHZhciBtZWRpYVR5cGVzXyA9IFtcbiAgICBcImFsbFwiLCBcImF1cmFsXCIsIFwiYnJhaWxsZVwiLCBcImhhbmRoZWxkXCIsIFwicHJpbnRcIiwgXCJwcm9qZWN0aW9uXCIsIFwic2NyZWVuXCIsXG4gICAgXCJ0dHlcIiwgXCJ0dlwiLCBcImVtYm9zc2VkXCJcbiAgXSwgbWVkaWFUeXBlcyA9IGtleVNldChtZWRpYVR5cGVzXyk7XG5cbiAgdmFyIG1lZGlhRmVhdHVyZXNfID0gW1xuICAgIFwid2lkdGhcIiwgXCJtaW4td2lkdGhcIiwgXCJtYXgtd2lkdGhcIiwgXCJoZWlnaHRcIiwgXCJtaW4taGVpZ2h0XCIsIFwibWF4LWhlaWdodFwiLFxuICAgIFwiZGV2aWNlLXdpZHRoXCIsIFwibWluLWRldmljZS13aWR0aFwiLCBcIm1heC1kZXZpY2Utd2lkdGhcIiwgXCJkZXZpY2UtaGVpZ2h0XCIsXG4gICAgXCJtaW4tZGV2aWNlLWhlaWdodFwiLCBcIm1heC1kZXZpY2UtaGVpZ2h0XCIsIFwiYXNwZWN0LXJhdGlvXCIsXG4gICAgXCJtaW4tYXNwZWN0LXJhdGlvXCIsIFwibWF4LWFzcGVjdC1yYXRpb1wiLCBcImRldmljZS1hc3BlY3QtcmF0aW9cIixcbiAgICBcIm1pbi1kZXZpY2UtYXNwZWN0LXJhdGlvXCIsIFwibWF4LWRldmljZS1hc3BlY3QtcmF0aW9cIiwgXCJjb2xvclwiLCBcIm1pbi1jb2xvclwiLFxuICAgIFwibWF4LWNvbG9yXCIsIFwiY29sb3ItaW5kZXhcIiwgXCJtaW4tY29sb3ItaW5kZXhcIiwgXCJtYXgtY29sb3ItaW5kZXhcIixcbiAgICBcIm1vbm9jaHJvbWVcIiwgXCJtaW4tbW9ub2Nocm9tZVwiLCBcIm1heC1tb25vY2hyb21lXCIsIFwicmVzb2x1dGlvblwiLFxuICAgIFwibWluLXJlc29sdXRpb25cIiwgXCJtYXgtcmVzb2x1dGlvblwiLCBcInNjYW5cIiwgXCJncmlkXCIsIFwib3JpZW50YXRpb25cIixcbiAgICBcImRldmljZS1waXhlbC1yYXRpb1wiLCBcIm1pbi1kZXZpY2UtcGl4ZWwtcmF0aW9cIiwgXCJtYXgtZGV2aWNlLXBpeGVsLXJhdGlvXCIsXG4gICAgXCJwb2ludGVyXCIsIFwiYW55LXBvaW50ZXJcIiwgXCJob3ZlclwiLCBcImFueS1ob3ZlclwiLCBcInByZWZlcnMtY29sb3Itc2NoZW1lXCJcbiAgXSwgbWVkaWFGZWF0dXJlcyA9IGtleVNldChtZWRpYUZlYXR1cmVzXyk7XG5cbiAgdmFyIG1lZGlhVmFsdWVLZXl3b3Jkc18gPSBbXG4gICAgXCJsYW5kc2NhcGVcIiwgXCJwb3J0cmFpdFwiLCBcIm5vbmVcIiwgXCJjb2Fyc2VcIiwgXCJmaW5lXCIsIFwib24tZGVtYW5kXCIsIFwiaG92ZXJcIixcbiAgICBcImludGVybGFjZVwiLCBcInByb2dyZXNzaXZlXCIsXG4gICAgXCJkYXJrXCIsIFwibGlnaHRcIlxuICBdLCBtZWRpYVZhbHVlS2V5d29yZHMgPSBrZXlTZXQobWVkaWFWYWx1ZUtleXdvcmRzXyk7XG5cbiAgdmFyIHByb3BlcnR5S2V5d29yZHNfID0gW1xuICAgIFwiYWxpZ24tY29udGVudFwiLCBcImFsaWduLWl0ZW1zXCIsIFwiYWxpZ24tc2VsZlwiLCBcImFsaWdubWVudC1hZGp1c3RcIixcbiAgICBcImFsaWdubWVudC1iYXNlbGluZVwiLCBcImFsbFwiLCBcImFuY2hvci1wb2ludFwiLCBcImFuaW1hdGlvblwiLCBcImFuaW1hdGlvbi1kZWxheVwiLFxuICAgIFwiYW5pbWF0aW9uLWRpcmVjdGlvblwiLCBcImFuaW1hdGlvbi1kdXJhdGlvblwiLCBcImFuaW1hdGlvbi1maWxsLW1vZGVcIixcbiAgICBcImFuaW1hdGlvbi1pdGVyYXRpb24tY291bnRcIiwgXCJhbmltYXRpb24tbmFtZVwiLCBcImFuaW1hdGlvbi1wbGF5LXN0YXRlXCIsXG4gICAgXCJhbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uXCIsIFwiYXBwZWFyYW5jZVwiLCBcImF6aW11dGhcIiwgXCJiYWNrZHJvcC1maWx0ZXJcIixcbiAgICBcImJhY2tmYWNlLXZpc2liaWxpdHlcIiwgXCJiYWNrZ3JvdW5kXCIsIFwiYmFja2dyb3VuZC1hdHRhY2htZW50XCIsXG4gICAgXCJiYWNrZ3JvdW5kLWJsZW5kLW1vZGVcIiwgXCJiYWNrZ3JvdW5kLWNsaXBcIiwgXCJiYWNrZ3JvdW5kLWNvbG9yXCIsXG4gICAgXCJiYWNrZ3JvdW5kLWltYWdlXCIsIFwiYmFja2dyb3VuZC1vcmlnaW5cIiwgXCJiYWNrZ3JvdW5kLXBvc2l0aW9uXCIsXG4gICAgXCJiYWNrZ3JvdW5kLXBvc2l0aW9uLXhcIiwgXCJiYWNrZ3JvdW5kLXBvc2l0aW9uLXlcIiwgXCJiYWNrZ3JvdW5kLXJlcGVhdFwiLFxuICAgIFwiYmFja2dyb3VuZC1zaXplXCIsIFwiYmFzZWxpbmUtc2hpZnRcIiwgXCJiaW5kaW5nXCIsIFwiYmxlZWRcIiwgXCJibG9jay1zaXplXCIsXG4gICAgXCJib29rbWFyay1sYWJlbFwiLCBcImJvb2ttYXJrLWxldmVsXCIsIFwiYm9va21hcmstc3RhdGVcIiwgXCJib29rbWFyay10YXJnZXRcIixcbiAgICBcImJvcmRlclwiLCBcImJvcmRlci1ib3R0b21cIiwgXCJib3JkZXItYm90dG9tLWNvbG9yXCIsIFwiYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1c1wiLFxuICAgIFwiYm9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXNcIiwgXCJib3JkZXItYm90dG9tLXN0eWxlXCIsIFwiYm9yZGVyLWJvdHRvbS13aWR0aFwiLFxuICAgIFwiYm9yZGVyLWNvbGxhcHNlXCIsIFwiYm9yZGVyLWNvbG9yXCIsIFwiYm9yZGVyLWltYWdlXCIsIFwiYm9yZGVyLWltYWdlLW91dHNldFwiLFxuICAgIFwiYm9yZGVyLWltYWdlLXJlcGVhdFwiLCBcImJvcmRlci1pbWFnZS1zbGljZVwiLCBcImJvcmRlci1pbWFnZS1zb3VyY2VcIixcbiAgICBcImJvcmRlci1pbWFnZS13aWR0aFwiLCBcImJvcmRlci1sZWZ0XCIsIFwiYm9yZGVyLWxlZnQtY29sb3JcIiwgXCJib3JkZXItbGVmdC1zdHlsZVwiLFxuICAgIFwiYm9yZGVyLWxlZnQtd2lkdGhcIiwgXCJib3JkZXItcmFkaXVzXCIsIFwiYm9yZGVyLXJpZ2h0XCIsIFwiYm9yZGVyLXJpZ2h0LWNvbG9yXCIsXG4gICAgXCJib3JkZXItcmlnaHQtc3R5bGVcIiwgXCJib3JkZXItcmlnaHQtd2lkdGhcIiwgXCJib3JkZXItc3BhY2luZ1wiLCBcImJvcmRlci1zdHlsZVwiLFxuICAgIFwiYm9yZGVyLXRvcFwiLCBcImJvcmRlci10b3AtY29sb3JcIiwgXCJib3JkZXItdG9wLWxlZnQtcmFkaXVzXCIsXG4gICAgXCJib3JkZXItdG9wLXJpZ2h0LXJhZGl1c1wiLCBcImJvcmRlci10b3Atc3R5bGVcIiwgXCJib3JkZXItdG9wLXdpZHRoXCIsXG4gICAgXCJib3JkZXItd2lkdGhcIiwgXCJib3R0b21cIiwgXCJib3gtZGVjb3JhdGlvbi1icmVha1wiLCBcImJveC1zaGFkb3dcIiwgXCJib3gtc2l6aW5nXCIsXG4gICAgXCJicmVhay1hZnRlclwiLCBcImJyZWFrLWJlZm9yZVwiLCBcImJyZWFrLWluc2lkZVwiLCBcImNhcHRpb24tc2lkZVwiLCBcImNhcmV0LWNvbG9yXCIsXG4gICAgXCJjbGVhclwiLCBcImNsaXBcIiwgXCJjb2xvclwiLCBcImNvbG9yLXByb2ZpbGVcIiwgXCJjb2x1bW4tY291bnRcIiwgXCJjb2x1bW4tZmlsbFwiLFxuICAgIFwiY29sdW1uLWdhcFwiLCBcImNvbHVtbi1ydWxlXCIsIFwiY29sdW1uLXJ1bGUtY29sb3JcIiwgXCJjb2x1bW4tcnVsZS1zdHlsZVwiLFxuICAgIFwiY29sdW1uLXJ1bGUtd2lkdGhcIiwgXCJjb2x1bW4tc3BhblwiLCBcImNvbHVtbi13aWR0aFwiLCBcImNvbHVtbnNcIiwgXCJjb250YWluXCIsXG4gICAgXCJjb250ZW50XCIsIFwiY291bnRlci1pbmNyZW1lbnRcIiwgXCJjb3VudGVyLXJlc2V0XCIsIFwiY3JvcFwiLCBcImN1ZVwiLCBcImN1ZS1hZnRlclwiLFxuICAgIFwiY3VlLWJlZm9yZVwiLCBcImN1cnNvclwiLCBcImRpcmVjdGlvblwiLCBcImRpc3BsYXlcIiwgXCJkb21pbmFudC1iYXNlbGluZVwiLFxuICAgIFwiZHJvcC1pbml0aWFsLWFmdGVyLWFkanVzdFwiLCBcImRyb3AtaW5pdGlhbC1hZnRlci1hbGlnblwiLFxuICAgIFwiZHJvcC1pbml0aWFsLWJlZm9yZS1hZGp1c3RcIiwgXCJkcm9wLWluaXRpYWwtYmVmb3JlLWFsaWduXCIsIFwiZHJvcC1pbml0aWFsLXNpemVcIixcbiAgICBcImRyb3AtaW5pdGlhbC12YWx1ZVwiLCBcImVsZXZhdGlvblwiLCBcImVtcHR5LWNlbGxzXCIsIFwiZml0XCIsIFwiZml0LXBvc2l0aW9uXCIsXG4gICAgXCJmbGV4XCIsIFwiZmxleC1iYXNpc1wiLCBcImZsZXgtZGlyZWN0aW9uXCIsIFwiZmxleC1mbG93XCIsIFwiZmxleC1ncm93XCIsXG4gICAgXCJmbGV4LXNocmlua1wiLCBcImZsZXgtd3JhcFwiLCBcImZsb2F0XCIsIFwiZmxvYXQtb2Zmc2V0XCIsIFwiZmxvdy1mcm9tXCIsIFwiZmxvdy1pbnRvXCIsXG4gICAgXCJmb250XCIsIFwiZm9udC1mYW1pbHlcIiwgXCJmb250LWZlYXR1cmUtc2V0dGluZ3NcIiwgXCJmb250LWtlcm5pbmdcIixcbiAgICBcImZvbnQtbGFuZ3VhZ2Utb3ZlcnJpZGVcIiwgXCJmb250LW9wdGljYWwtc2l6aW5nXCIsIFwiZm9udC1zaXplXCIsXG4gICAgXCJmb250LXNpemUtYWRqdXN0XCIsIFwiZm9udC1zdHJldGNoXCIsIFwiZm9udC1zdHlsZVwiLCBcImZvbnQtc3ludGhlc2lzXCIsXG4gICAgXCJmb250LXZhcmlhbnRcIiwgXCJmb250LXZhcmlhbnQtYWx0ZXJuYXRlc1wiLCBcImZvbnQtdmFyaWFudC1jYXBzXCIsXG4gICAgXCJmb250LXZhcmlhbnQtZWFzdC1hc2lhblwiLCBcImZvbnQtdmFyaWFudC1saWdhdHVyZXNcIiwgXCJmb250LXZhcmlhbnQtbnVtZXJpY1wiLFxuICAgIFwiZm9udC12YXJpYW50LXBvc2l0aW9uXCIsIFwiZm9udC12YXJpYXRpb24tc2V0dGluZ3NcIiwgXCJmb250LXdlaWdodFwiLCBcImdhcFwiLFxuICAgIFwiZ3JpZFwiLCBcImdyaWQtYXJlYVwiLCBcImdyaWQtYXV0by1jb2x1bW5zXCIsIFwiZ3JpZC1hdXRvLWZsb3dcIiwgXCJncmlkLWF1dG8tcm93c1wiLFxuICAgIFwiZ3JpZC1jb2x1bW5cIiwgXCJncmlkLWNvbHVtbi1lbmRcIiwgXCJncmlkLWNvbHVtbi1nYXBcIiwgXCJncmlkLWNvbHVtbi1zdGFydFwiLFxuICAgIFwiZ3JpZC1nYXBcIiwgXCJncmlkLXJvd1wiLCBcImdyaWQtcm93LWVuZFwiLCBcImdyaWQtcm93LWdhcFwiLCBcImdyaWQtcm93LXN0YXJ0XCIsXG4gICAgXCJncmlkLXRlbXBsYXRlXCIsIFwiZ3JpZC10ZW1wbGF0ZS1hcmVhc1wiLCBcImdyaWQtdGVtcGxhdGUtY29sdW1uc1wiLFxuICAgIFwiZ3JpZC10ZW1wbGF0ZS1yb3dzXCIsIFwiaGFuZ2luZy1wdW5jdHVhdGlvblwiLCBcImhlaWdodFwiLCBcImh5cGhlbnNcIiwgXCJpY29uXCIsXG4gICAgXCJpbWFnZS1vcmllbnRhdGlvblwiLCBcImltYWdlLXJlbmRlcmluZ1wiLCBcImltYWdlLXJlc29sdXRpb25cIiwgXCJpbmxpbmUtYm94LWFsaWduXCIsXG4gICAgXCJpbnNldFwiLCBcImluc2V0LWJsb2NrXCIsIFwiaW5zZXQtYmxvY2stZW5kXCIsIFwiaW5zZXQtYmxvY2stc3RhcnRcIiwgXCJpbnNldC1pbmxpbmVcIixcbiAgICBcImluc2V0LWlubGluZS1lbmRcIiwgXCJpbnNldC1pbmxpbmUtc3RhcnRcIiwgXCJpc29sYXRpb25cIiwgXCJqdXN0aWZ5LWNvbnRlbnRcIixcbiAgICBcImp1c3RpZnktaXRlbXNcIiwgXCJqdXN0aWZ5LXNlbGZcIiwgXCJsZWZ0XCIsIFwibGV0dGVyLXNwYWNpbmdcIiwgXCJsaW5lLWJyZWFrXCIsXG4gICAgXCJsaW5lLWhlaWdodFwiLCBcImxpbmUtaGVpZ2h0LXN0ZXBcIiwgXCJsaW5lLXN0YWNraW5nXCIsIFwibGluZS1zdGFja2luZy1ydWJ5XCIsXG4gICAgXCJsaW5lLXN0YWNraW5nLXNoaWZ0XCIsIFwibGluZS1zdGFja2luZy1zdHJhdGVneVwiLCBcImxpc3Qtc3R5bGVcIixcbiAgICBcImxpc3Qtc3R5bGUtaW1hZ2VcIiwgXCJsaXN0LXN0eWxlLXBvc2l0aW9uXCIsIFwibGlzdC1zdHlsZS10eXBlXCIsIFwibWFyZ2luXCIsXG4gICAgXCJtYXJnaW4tYm90dG9tXCIsIFwibWFyZ2luLWxlZnRcIiwgXCJtYXJnaW4tcmlnaHRcIiwgXCJtYXJnaW4tdG9wXCIsIFwibWFya3NcIixcbiAgICBcIm1hcnF1ZWUtZGlyZWN0aW9uXCIsIFwibWFycXVlZS1sb29wXCIsIFwibWFycXVlZS1wbGF5LWNvdW50XCIsIFwibWFycXVlZS1zcGVlZFwiLFxuICAgIFwibWFycXVlZS1zdHlsZVwiLCBcIm1hc2stY2xpcFwiLCBcIm1hc2stY29tcG9zaXRlXCIsIFwibWFzay1pbWFnZVwiLCBcIm1hc2stbW9kZVwiLFxuICAgIFwibWFzay1vcmlnaW5cIiwgXCJtYXNrLXBvc2l0aW9uXCIsIFwibWFzay1yZXBlYXRcIiwgXCJtYXNrLXNpemVcIixcIm1hc2stdHlwZVwiLFxuICAgIFwibWF4LWJsb2NrLXNpemVcIiwgXCJtYXgtaGVpZ2h0XCIsIFwibWF4LWlubGluZS1zaXplXCIsXG4gICAgXCJtYXgtd2lkdGhcIiwgXCJtaW4tYmxvY2stc2l6ZVwiLCBcIm1pbi1oZWlnaHRcIiwgXCJtaW4taW5saW5lLXNpemVcIiwgXCJtaW4td2lkdGhcIixcbiAgICBcIm1peC1ibGVuZC1tb2RlXCIsIFwibW92ZS10b1wiLCBcIm5hdi1kb3duXCIsIFwibmF2LWluZGV4XCIsIFwibmF2LWxlZnRcIiwgXCJuYXYtcmlnaHRcIixcbiAgICBcIm5hdi11cFwiLCBcIm9iamVjdC1maXRcIiwgXCJvYmplY3QtcG9zaXRpb25cIiwgXCJvZmZzZXRcIiwgXCJvZmZzZXQtYW5jaG9yXCIsXG4gICAgXCJvZmZzZXQtZGlzdGFuY2VcIiwgXCJvZmZzZXQtcGF0aFwiLCBcIm9mZnNldC1wb3NpdGlvblwiLCBcIm9mZnNldC1yb3RhdGVcIixcbiAgICBcIm9wYWNpdHlcIiwgXCJvcmRlclwiLCBcIm9ycGhhbnNcIiwgXCJvdXRsaW5lXCIsIFwib3V0bGluZS1jb2xvclwiLCBcIm91dGxpbmUtb2Zmc2V0XCIsXG4gICAgXCJvdXRsaW5lLXN0eWxlXCIsIFwib3V0bGluZS13aWR0aFwiLCBcIm92ZXJmbG93XCIsIFwib3ZlcmZsb3ctc3R5bGVcIixcbiAgICBcIm92ZXJmbG93LXdyYXBcIiwgXCJvdmVyZmxvdy14XCIsIFwib3ZlcmZsb3cteVwiLCBcInBhZGRpbmdcIiwgXCJwYWRkaW5nLWJvdHRvbVwiLFxuICAgIFwicGFkZGluZy1sZWZ0XCIsIFwicGFkZGluZy1yaWdodFwiLCBcInBhZGRpbmctdG9wXCIsIFwicGFnZVwiLCBcInBhZ2UtYnJlYWstYWZ0ZXJcIixcbiAgICBcInBhZ2UtYnJlYWstYmVmb3JlXCIsIFwicGFnZS1icmVhay1pbnNpZGVcIiwgXCJwYWdlLXBvbGljeVwiLCBcInBhdXNlXCIsXG4gICAgXCJwYXVzZS1hZnRlclwiLCBcInBhdXNlLWJlZm9yZVwiLCBcInBlcnNwZWN0aXZlXCIsIFwicGVyc3BlY3RpdmUtb3JpZ2luXCIsIFwicGl0Y2hcIixcbiAgICBcInBpdGNoLXJhbmdlXCIsIFwicGxhY2UtY29udGVudFwiLCBcInBsYWNlLWl0ZW1zXCIsIFwicGxhY2Utc2VsZlwiLCBcInBsYXktZHVyaW5nXCIsXG4gICAgXCJwb3NpdGlvblwiLCBcInByZXNlbnRhdGlvbi1sZXZlbFwiLCBcInB1bmN0dWF0aW9uLXRyaW1cIiwgXCJxdW90ZXNcIixcbiAgICBcInJlZ2lvbi1icmVhay1hZnRlclwiLCBcInJlZ2lvbi1icmVhay1iZWZvcmVcIiwgXCJyZWdpb24tYnJlYWstaW5zaWRlXCIsXG4gICAgXCJyZWdpb24tZnJhZ21lbnRcIiwgXCJyZW5kZXJpbmctaW50ZW50XCIsIFwicmVzaXplXCIsIFwicmVzdFwiLCBcInJlc3QtYWZ0ZXJcIixcbiAgICBcInJlc3QtYmVmb3JlXCIsIFwicmljaG5lc3NcIiwgXCJyaWdodFwiLCBcInJvdGF0ZVwiLCBcInJvdGF0aW9uXCIsIFwicm90YXRpb24tcG9pbnRcIixcbiAgICBcInJvdy1nYXBcIiwgXCJydWJ5LWFsaWduXCIsIFwicnVieS1vdmVyaGFuZ1wiLCBcInJ1YnktcG9zaXRpb25cIiwgXCJydWJ5LXNwYW5cIixcbiAgICBcInNjYWxlXCIsIFwic2Nyb2xsLWJlaGF2aW9yXCIsIFwic2Nyb2xsLW1hcmdpblwiLCBcInNjcm9sbC1tYXJnaW4tYmxvY2tcIixcbiAgICBcInNjcm9sbC1tYXJnaW4tYmxvY2stZW5kXCIsIFwic2Nyb2xsLW1hcmdpbi1ibG9jay1zdGFydFwiLCBcInNjcm9sbC1tYXJnaW4tYm90dG9tXCIsXG4gICAgXCJzY3JvbGwtbWFyZ2luLWlubGluZVwiLCBcInNjcm9sbC1tYXJnaW4taW5saW5lLWVuZFwiLFxuICAgIFwic2Nyb2xsLW1hcmdpbi1pbmxpbmUtc3RhcnRcIiwgXCJzY3JvbGwtbWFyZ2luLWxlZnRcIiwgXCJzY3JvbGwtbWFyZ2luLXJpZ2h0XCIsXG4gICAgXCJzY3JvbGwtbWFyZ2luLXRvcFwiLCBcInNjcm9sbC1wYWRkaW5nXCIsIFwic2Nyb2xsLXBhZGRpbmctYmxvY2tcIixcbiAgICBcInNjcm9sbC1wYWRkaW5nLWJsb2NrLWVuZFwiLCBcInNjcm9sbC1wYWRkaW5nLWJsb2NrLXN0YXJ0XCIsXG4gICAgXCJzY3JvbGwtcGFkZGluZy1ib3R0b21cIiwgXCJzY3JvbGwtcGFkZGluZy1pbmxpbmVcIiwgXCJzY3JvbGwtcGFkZGluZy1pbmxpbmUtZW5kXCIsXG4gICAgXCJzY3JvbGwtcGFkZGluZy1pbmxpbmUtc3RhcnRcIiwgXCJzY3JvbGwtcGFkZGluZy1sZWZ0XCIsIFwic2Nyb2xsLXBhZGRpbmctcmlnaHRcIixcbiAgICBcInNjcm9sbC1wYWRkaW5nLXRvcFwiLCBcInNjcm9sbC1zbmFwLWFsaWduXCIsIFwic2Nyb2xsLXNuYXAtdHlwZVwiLFxuICAgIFwic2hhcGUtaW1hZ2UtdGhyZXNob2xkXCIsIFwic2hhcGUtaW5zaWRlXCIsIFwic2hhcGUtbWFyZ2luXCIsIFwic2hhcGUtb3V0c2lkZVwiLFxuICAgIFwic2l6ZVwiLCBcInNwZWFrXCIsIFwic3BlYWstYXNcIiwgXCJzcGVhay1oZWFkZXJcIiwgXCJzcGVhay1udW1lcmFsXCIsXG4gICAgXCJzcGVhay1wdW5jdHVhdGlvblwiLCBcInNwZWVjaC1yYXRlXCIsIFwic3RyZXNzXCIsIFwic3RyaW5nLXNldFwiLCBcInRhYi1zaXplXCIsXG4gICAgXCJ0YWJsZS1sYXlvdXRcIiwgXCJ0YXJnZXRcIiwgXCJ0YXJnZXQtbmFtZVwiLCBcInRhcmdldC1uZXdcIiwgXCJ0YXJnZXQtcG9zaXRpb25cIixcbiAgICBcInRleHQtYWxpZ25cIiwgXCJ0ZXh0LWFsaWduLWxhc3RcIiwgXCJ0ZXh0LWNvbWJpbmUtdXByaWdodFwiLCBcInRleHQtZGVjb3JhdGlvblwiLFxuICAgIFwidGV4dC1kZWNvcmF0aW9uLWNvbG9yXCIsIFwidGV4dC1kZWNvcmF0aW9uLWxpbmVcIiwgXCJ0ZXh0LWRlY29yYXRpb24tc2tpcFwiLFxuICAgIFwidGV4dC1kZWNvcmF0aW9uLXNraXAtaW5rXCIsIFwidGV4dC1kZWNvcmF0aW9uLXN0eWxlXCIsIFwidGV4dC1lbXBoYXNpc1wiLFxuICAgIFwidGV4dC1lbXBoYXNpcy1jb2xvclwiLCBcInRleHQtZW1waGFzaXMtcG9zaXRpb25cIiwgXCJ0ZXh0LWVtcGhhc2lzLXN0eWxlXCIsXG4gICAgXCJ0ZXh0LWhlaWdodFwiLCBcInRleHQtaW5kZW50XCIsIFwidGV4dC1qdXN0aWZ5XCIsIFwidGV4dC1vcmllbnRhdGlvblwiLFxuICAgIFwidGV4dC1vdXRsaW5lXCIsIFwidGV4dC1vdmVyZmxvd1wiLCBcInRleHQtcmVuZGVyaW5nXCIsIFwidGV4dC1zaGFkb3dcIixcbiAgICBcInRleHQtc2l6ZS1hZGp1c3RcIiwgXCJ0ZXh0LXNwYWNlLWNvbGxhcHNlXCIsIFwidGV4dC10cmFuc2Zvcm1cIixcbiAgICBcInRleHQtdW5kZXJsaW5lLXBvc2l0aW9uXCIsIFwidGV4dC13cmFwXCIsIFwidG9wXCIsIFwidG91Y2gtYWN0aW9uXCIsIFwidHJhbnNmb3JtXCIsIFwidHJhbnNmb3JtLW9yaWdpblwiLFxuICAgIFwidHJhbnNmb3JtLXN0eWxlXCIsIFwidHJhbnNpdGlvblwiLCBcInRyYW5zaXRpb24tZGVsYXlcIiwgXCJ0cmFuc2l0aW9uLWR1cmF0aW9uXCIsXG4gICAgXCJ0cmFuc2l0aW9uLXByb3BlcnR5XCIsIFwidHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb25cIiwgXCJ0cmFuc2xhdGVcIixcbiAgICBcInVuaWNvZGUtYmlkaVwiLCBcInVzZXItc2VsZWN0XCIsIFwidmVydGljYWwtYWxpZ25cIiwgXCJ2aXNpYmlsaXR5XCIsIFwidm9pY2UtYmFsYW5jZVwiLFxuICAgIFwidm9pY2UtZHVyYXRpb25cIiwgXCJ2b2ljZS1mYW1pbHlcIiwgXCJ2b2ljZS1waXRjaFwiLCBcInZvaWNlLXJhbmdlXCIsIFwidm9pY2UtcmF0ZVwiLFxuICAgIFwidm9pY2Utc3RyZXNzXCIsIFwidm9pY2Utdm9sdW1lXCIsIFwidm9sdW1lXCIsIFwid2hpdGUtc3BhY2VcIiwgXCJ3aWRvd3NcIiwgXCJ3aWR0aFwiLFxuICAgIFwid2lsbC1jaGFuZ2VcIiwgXCJ3b3JkLWJyZWFrXCIsIFwid29yZC1zcGFjaW5nXCIsIFwid29yZC13cmFwXCIsIFwid3JpdGluZy1tb2RlXCIsIFwiei1pbmRleFwiLFxuICAgIC8vIFNWRy1zcGVjaWZpY1xuICAgIFwiY2xpcC1wYXRoXCIsIFwiY2xpcC1ydWxlXCIsIFwibWFza1wiLCBcImVuYWJsZS1iYWNrZ3JvdW5kXCIsIFwiZmlsdGVyXCIsIFwiZmxvb2QtY29sb3JcIixcbiAgICBcImZsb29kLW9wYWNpdHlcIiwgXCJsaWdodGluZy1jb2xvclwiLCBcInN0b3AtY29sb3JcIiwgXCJzdG9wLW9wYWNpdHlcIiwgXCJwb2ludGVyLWV2ZW50c1wiLFxuICAgIFwiY29sb3ItaW50ZXJwb2xhdGlvblwiLCBcImNvbG9yLWludGVycG9sYXRpb24tZmlsdGVyc1wiLFxuICAgIFwiY29sb3ItcmVuZGVyaW5nXCIsIFwiZmlsbFwiLCBcImZpbGwtb3BhY2l0eVwiLCBcImZpbGwtcnVsZVwiLCBcImltYWdlLXJlbmRlcmluZ1wiLFxuICAgIFwibWFya2VyXCIsIFwibWFya2VyLWVuZFwiLCBcIm1hcmtlci1taWRcIiwgXCJtYXJrZXItc3RhcnRcIiwgXCJwYWludC1vcmRlclwiLCBcInNoYXBlLXJlbmRlcmluZ1wiLCBcInN0cm9rZVwiLFxuICAgIFwic3Ryb2tlLWRhc2hhcnJheVwiLCBcInN0cm9rZS1kYXNob2Zmc2V0XCIsIFwic3Ryb2tlLWxpbmVjYXBcIiwgXCJzdHJva2UtbGluZWpvaW5cIixcbiAgICBcInN0cm9rZS1taXRlcmxpbWl0XCIsIFwic3Ryb2tlLW9wYWNpdHlcIiwgXCJzdHJva2Utd2lkdGhcIiwgXCJ0ZXh0LXJlbmRlcmluZ1wiLFxuICAgIFwiYmFzZWxpbmUtc2hpZnRcIiwgXCJkb21pbmFudC1iYXNlbGluZVwiLCBcImdseXBoLW9yaWVudGF0aW9uLWhvcml6b250YWxcIixcbiAgICBcImdseXBoLW9yaWVudGF0aW9uLXZlcnRpY2FsXCIsIFwidGV4dC1hbmNob3JcIiwgXCJ3cml0aW5nLW1vZGVcIixcbiAgXSwgcHJvcGVydHlLZXl3b3JkcyA9IGtleVNldChwcm9wZXJ0eUtleXdvcmRzXyk7XG5cbiAgdmFyIG5vblN0YW5kYXJkUHJvcGVydHlLZXl3b3Jkc18gPSBbXG4gICAgXCJib3JkZXItYmxvY2tcIiwgXCJib3JkZXItYmxvY2stY29sb3JcIiwgXCJib3JkZXItYmxvY2stZW5kXCIsXG4gICAgXCJib3JkZXItYmxvY2stZW5kLWNvbG9yXCIsIFwiYm9yZGVyLWJsb2NrLWVuZC1zdHlsZVwiLCBcImJvcmRlci1ibG9jay1lbmQtd2lkdGhcIixcbiAgICBcImJvcmRlci1ibG9jay1zdGFydFwiLCBcImJvcmRlci1ibG9jay1zdGFydC1jb2xvclwiLCBcImJvcmRlci1ibG9jay1zdGFydC1zdHlsZVwiLFxuICAgIFwiYm9yZGVyLWJsb2NrLXN0YXJ0LXdpZHRoXCIsIFwiYm9yZGVyLWJsb2NrLXN0eWxlXCIsIFwiYm9yZGVyLWJsb2NrLXdpZHRoXCIsXG4gICAgXCJib3JkZXItaW5saW5lXCIsIFwiYm9yZGVyLWlubGluZS1jb2xvclwiLCBcImJvcmRlci1pbmxpbmUtZW5kXCIsXG4gICAgXCJib3JkZXItaW5saW5lLWVuZC1jb2xvclwiLCBcImJvcmRlci1pbmxpbmUtZW5kLXN0eWxlXCIsXG4gICAgXCJib3JkZXItaW5saW5lLWVuZC13aWR0aFwiLCBcImJvcmRlci1pbmxpbmUtc3RhcnRcIiwgXCJib3JkZXItaW5saW5lLXN0YXJ0LWNvbG9yXCIsXG4gICAgXCJib3JkZXItaW5saW5lLXN0YXJ0LXN0eWxlXCIsIFwiYm9yZGVyLWlubGluZS1zdGFydC13aWR0aFwiLFxuICAgIFwiYm9yZGVyLWlubGluZS1zdHlsZVwiLCBcImJvcmRlci1pbmxpbmUtd2lkdGhcIiwgXCJtYXJnaW4tYmxvY2tcIixcbiAgICBcIm1hcmdpbi1ibG9jay1lbmRcIiwgXCJtYXJnaW4tYmxvY2stc3RhcnRcIiwgXCJtYXJnaW4taW5saW5lXCIsIFwibWFyZ2luLWlubGluZS1lbmRcIixcbiAgICBcIm1hcmdpbi1pbmxpbmUtc3RhcnRcIiwgXCJwYWRkaW5nLWJsb2NrXCIsIFwicGFkZGluZy1ibG9jay1lbmRcIixcbiAgICBcInBhZGRpbmctYmxvY2stc3RhcnRcIiwgXCJwYWRkaW5nLWlubGluZVwiLCBcInBhZGRpbmctaW5saW5lLWVuZFwiLFxuICAgIFwicGFkZGluZy1pbmxpbmUtc3RhcnRcIiwgXCJzY3JvbGwtc25hcC1zdG9wXCIsIFwic2Nyb2xsYmFyLTNkLWxpZ2h0LWNvbG9yXCIsXG4gICAgXCJzY3JvbGxiYXItYXJyb3ctY29sb3JcIiwgXCJzY3JvbGxiYXItYmFzZS1jb2xvclwiLCBcInNjcm9sbGJhci1kYXJrLXNoYWRvdy1jb2xvclwiLFxuICAgIFwic2Nyb2xsYmFyLWZhY2UtY29sb3JcIiwgXCJzY3JvbGxiYXItaGlnaGxpZ2h0LWNvbG9yXCIsIFwic2Nyb2xsYmFyLXNoYWRvdy1jb2xvclwiLFxuICAgIFwic2Nyb2xsYmFyLXRyYWNrLWNvbG9yXCIsIFwic2VhcmNoZmllbGQtY2FuY2VsLWJ1dHRvblwiLCBcInNlYXJjaGZpZWxkLWRlY29yYXRpb25cIixcbiAgICBcInNlYXJjaGZpZWxkLXJlc3VsdHMtYnV0dG9uXCIsIFwic2VhcmNoZmllbGQtcmVzdWx0cy1kZWNvcmF0aW9uXCIsIFwic2hhcGUtaW5zaWRlXCIsIFwiem9vbVwiXG4gIF0sIG5vblN0YW5kYXJkUHJvcGVydHlLZXl3b3JkcyA9IGtleVNldChub25TdGFuZGFyZFByb3BlcnR5S2V5d29yZHNfKTtcblxuICB2YXIgZm9udFByb3BlcnRpZXNfID0gW1xuICAgIFwiZm9udC1kaXNwbGF5XCIsIFwiZm9udC1mYW1pbHlcIiwgXCJzcmNcIiwgXCJ1bmljb2RlLXJhbmdlXCIsIFwiZm9udC12YXJpYW50XCIsXG4gICAgIFwiZm9udC1mZWF0dXJlLXNldHRpbmdzXCIsIFwiZm9udC1zdHJldGNoXCIsIFwiZm9udC13ZWlnaHRcIiwgXCJmb250LXN0eWxlXCJcbiAgXSwgZm9udFByb3BlcnRpZXMgPSBrZXlTZXQoZm9udFByb3BlcnRpZXNfKTtcblxuICB2YXIgY291bnRlckRlc2NyaXB0b3JzXyA9IFtcbiAgICBcImFkZGl0aXZlLXN5bWJvbHNcIiwgXCJmYWxsYmFja1wiLCBcIm5lZ2F0aXZlXCIsIFwicGFkXCIsIFwicHJlZml4XCIsIFwicmFuZ2VcIixcbiAgICBcInNwZWFrLWFzXCIsIFwic3VmZml4XCIsIFwic3ltYm9sc1wiLCBcInN5c3RlbVwiXG4gIF0sIGNvdW50ZXJEZXNjcmlwdG9ycyA9IGtleVNldChjb3VudGVyRGVzY3JpcHRvcnNfKTtcblxuICB2YXIgY29sb3JLZXl3b3Jkc18gPSBbXG4gICAgXCJhbGljZWJsdWVcIiwgXCJhbnRpcXVld2hpdGVcIiwgXCJhcXVhXCIsIFwiYXF1YW1hcmluZVwiLCBcImF6dXJlXCIsIFwiYmVpZ2VcIixcbiAgICBcImJpc3F1ZVwiLCBcImJsYWNrXCIsIFwiYmxhbmNoZWRhbG1vbmRcIiwgXCJibHVlXCIsIFwiYmx1ZXZpb2xldFwiLCBcImJyb3duXCIsXG4gICAgXCJidXJseXdvb2RcIiwgXCJjYWRldGJsdWVcIiwgXCJjaGFydHJldXNlXCIsIFwiY2hvY29sYXRlXCIsIFwiY29yYWxcIiwgXCJjb3JuZmxvd2VyYmx1ZVwiLFxuICAgIFwiY29ybnNpbGtcIiwgXCJjcmltc29uXCIsIFwiY3lhblwiLCBcImRhcmtibHVlXCIsIFwiZGFya2N5YW5cIiwgXCJkYXJrZ29sZGVucm9kXCIsXG4gICAgXCJkYXJrZ3JheVwiLCBcImRhcmtncmVlblwiLCBcImRhcmtraGFraVwiLCBcImRhcmttYWdlbnRhXCIsIFwiZGFya29saXZlZ3JlZW5cIixcbiAgICBcImRhcmtvcmFuZ2VcIiwgXCJkYXJrb3JjaGlkXCIsIFwiZGFya3JlZFwiLCBcImRhcmtzYWxtb25cIiwgXCJkYXJrc2VhZ3JlZW5cIixcbiAgICBcImRhcmtzbGF0ZWJsdWVcIiwgXCJkYXJrc2xhdGVncmF5XCIsIFwiZGFya3R1cnF1b2lzZVwiLCBcImRhcmt2aW9sZXRcIixcbiAgICBcImRlZXBwaW5rXCIsIFwiZGVlcHNreWJsdWVcIiwgXCJkaW1ncmF5XCIsIFwiZG9kZ2VyYmx1ZVwiLCBcImZpcmVicmlja1wiLFxuICAgIFwiZmxvcmFsd2hpdGVcIiwgXCJmb3Jlc3RncmVlblwiLCBcImZ1Y2hzaWFcIiwgXCJnYWluc2Jvcm9cIiwgXCJnaG9zdHdoaXRlXCIsXG4gICAgXCJnb2xkXCIsIFwiZ29sZGVucm9kXCIsIFwiZ3JheVwiLCBcImdyZXlcIiwgXCJncmVlblwiLCBcImdyZWVueWVsbG93XCIsIFwiaG9uZXlkZXdcIixcbiAgICBcImhvdHBpbmtcIiwgXCJpbmRpYW5yZWRcIiwgXCJpbmRpZ29cIiwgXCJpdm9yeVwiLCBcImtoYWtpXCIsIFwibGF2ZW5kZXJcIixcbiAgICBcImxhdmVuZGVyYmx1c2hcIiwgXCJsYXduZ3JlZW5cIiwgXCJsZW1vbmNoaWZmb25cIiwgXCJsaWdodGJsdWVcIiwgXCJsaWdodGNvcmFsXCIsXG4gICAgXCJsaWdodGN5YW5cIiwgXCJsaWdodGdvbGRlbnJvZHllbGxvd1wiLCBcImxpZ2h0Z3JheVwiLCBcImxpZ2h0Z3JlZW5cIiwgXCJsaWdodHBpbmtcIixcbiAgICBcImxpZ2h0c2FsbW9uXCIsIFwibGlnaHRzZWFncmVlblwiLCBcImxpZ2h0c2t5Ymx1ZVwiLCBcImxpZ2h0c2xhdGVncmF5XCIsXG4gICAgXCJsaWdodHN0ZWVsYmx1ZVwiLCBcImxpZ2h0eWVsbG93XCIsIFwibGltZVwiLCBcImxpbWVncmVlblwiLCBcImxpbmVuXCIsIFwibWFnZW50YVwiLFxuICAgIFwibWFyb29uXCIsIFwibWVkaXVtYXF1YW1hcmluZVwiLCBcIm1lZGl1bWJsdWVcIiwgXCJtZWRpdW1vcmNoaWRcIiwgXCJtZWRpdW1wdXJwbGVcIixcbiAgICBcIm1lZGl1bXNlYWdyZWVuXCIsIFwibWVkaXVtc2xhdGVibHVlXCIsIFwibWVkaXVtc3ByaW5nZ3JlZW5cIiwgXCJtZWRpdW10dXJxdW9pc2VcIixcbiAgICBcIm1lZGl1bXZpb2xldHJlZFwiLCBcIm1pZG5pZ2h0Ymx1ZVwiLCBcIm1pbnRjcmVhbVwiLCBcIm1pc3R5cm9zZVwiLCBcIm1vY2Nhc2luXCIsXG4gICAgXCJuYXZham93aGl0ZVwiLCBcIm5hdnlcIiwgXCJvbGRsYWNlXCIsIFwib2xpdmVcIiwgXCJvbGl2ZWRyYWJcIiwgXCJvcmFuZ2VcIiwgXCJvcmFuZ2VyZWRcIixcbiAgICBcIm9yY2hpZFwiLCBcInBhbGVnb2xkZW5yb2RcIiwgXCJwYWxlZ3JlZW5cIiwgXCJwYWxldHVycXVvaXNlXCIsIFwicGFsZXZpb2xldHJlZFwiLFxuICAgIFwicGFwYXlhd2hpcFwiLCBcInBlYWNocHVmZlwiLCBcInBlcnVcIiwgXCJwaW5rXCIsIFwicGx1bVwiLCBcInBvd2RlcmJsdWVcIixcbiAgICBcInB1cnBsZVwiLCBcInJlYmVjY2FwdXJwbGVcIiwgXCJyZWRcIiwgXCJyb3N5YnJvd25cIiwgXCJyb3lhbGJsdWVcIiwgXCJzYWRkbGVicm93blwiLFxuICAgIFwic2FsbW9uXCIsIFwic2FuZHlicm93blwiLCBcInNlYWdyZWVuXCIsIFwic2Vhc2hlbGxcIiwgXCJzaWVubmFcIiwgXCJzaWx2ZXJcIiwgXCJza3libHVlXCIsXG4gICAgXCJzbGF0ZWJsdWVcIiwgXCJzbGF0ZWdyYXlcIiwgXCJzbm93XCIsIFwic3ByaW5nZ3JlZW5cIiwgXCJzdGVlbGJsdWVcIiwgXCJ0YW5cIixcbiAgICBcInRlYWxcIiwgXCJ0aGlzdGxlXCIsIFwidG9tYXRvXCIsIFwidHVycXVvaXNlXCIsIFwidmlvbGV0XCIsIFwid2hlYXRcIiwgXCJ3aGl0ZVwiLFxuICAgIFwid2hpdGVzbW9rZVwiLCBcInllbGxvd1wiLCBcInllbGxvd2dyZWVuXCJcbiAgXSwgY29sb3JLZXl3b3JkcyA9IGtleVNldChjb2xvcktleXdvcmRzXyk7XG5cbiAgdmFyIHZhbHVlS2V5d29yZHNfID0gW1xuICAgIFwiYWJvdmVcIiwgXCJhYnNvbHV0ZVwiLCBcImFjdGl2ZWJvcmRlclwiLCBcImFkZGl0aXZlXCIsIFwiYWN0aXZlY2FwdGlvblwiLCBcImFmYXJcIixcbiAgICBcImFmdGVyLXdoaXRlLXNwYWNlXCIsIFwiYWhlYWRcIiwgXCJhbGlhc1wiLCBcImFsbFwiLCBcImFsbC1zY3JvbGxcIiwgXCJhbHBoYWJldGljXCIsIFwiYWx0ZXJuYXRlXCIsXG4gICAgXCJhbHdheXNcIiwgXCJhbWhhcmljXCIsIFwiYW1oYXJpYy1hYmVnZWRlXCIsIFwiYW50aWFsaWFzZWRcIiwgXCJhcHB3b3Jrc3BhY2VcIixcbiAgICBcImFyYWJpYy1pbmRpY1wiLCBcImFybWVuaWFuXCIsIFwiYXN0ZXJpc2tzXCIsIFwiYXR0clwiLCBcImF1dG9cIiwgXCJhdXRvLWZsb3dcIiwgXCJhdm9pZFwiLCBcImF2b2lkLWNvbHVtblwiLCBcImF2b2lkLXBhZ2VcIixcbiAgICBcImF2b2lkLXJlZ2lvblwiLCBcImF4aXMtcGFuXCIsIFwiYmFja2dyb3VuZFwiLCBcImJhY2t3YXJkc1wiLCBcImJhc2VsaW5lXCIsIFwiYmVsb3dcIiwgXCJiaWRpLW92ZXJyaWRlXCIsIFwiYmluYXJ5XCIsXG4gICAgXCJiZW5nYWxpXCIsIFwiYmxpbmtcIiwgXCJibG9ja1wiLCBcImJsb2NrLWF4aXNcIiwgXCJib2xkXCIsIFwiYm9sZGVyXCIsIFwiYm9yZGVyXCIsIFwiYm9yZGVyLWJveFwiLFxuICAgIFwiYm90aFwiLCBcImJvdHRvbVwiLCBcImJyZWFrXCIsIFwiYnJlYWstYWxsXCIsIFwiYnJlYWstd29yZFwiLCBcImJ1bGxldHNcIiwgXCJidXR0b25cIiwgXCJidXR0b24tYmV2ZWxcIixcbiAgICBcImJ1dHRvbmZhY2VcIiwgXCJidXR0b25oaWdobGlnaHRcIiwgXCJidXR0b25zaGFkb3dcIiwgXCJidXR0b250ZXh0XCIsIFwiY2FsY1wiLCBcImNhbWJvZGlhblwiLFxuICAgIFwiY2FwaXRhbGl6ZVwiLCBcImNhcHMtbG9jay1pbmRpY2F0b3JcIiwgXCJjYXB0aW9uXCIsIFwiY2FwdGlvbnRleHRcIiwgXCJjYXJldFwiLFxuICAgIFwiY2VsbFwiLCBcImNlbnRlclwiLCBcImNoZWNrYm94XCIsIFwiY2lyY2xlXCIsIFwiY2prLWRlY2ltYWxcIiwgXCJjamstZWFydGhseS1icmFuY2hcIixcbiAgICBcImNqay1oZWF2ZW5seS1zdGVtXCIsIFwiY2prLWlkZW9ncmFwaGljXCIsIFwiY2xlYXJcIiwgXCJjbGlwXCIsIFwiY2xvc2UtcXVvdGVcIixcbiAgICBcImNvbC1yZXNpemVcIiwgXCJjb2xsYXBzZVwiLCBcImNvbG9yXCIsIFwiY29sb3ItYnVyblwiLCBcImNvbG9yLWRvZGdlXCIsIFwiY29sdW1uXCIsIFwiY29sdW1uLXJldmVyc2VcIixcbiAgICBcImNvbXBhY3RcIiwgXCJjb25kZW5zZWRcIiwgXCJjb250YWluXCIsIFwiY29udGVudFwiLCBcImNvbnRlbnRzXCIsXG4gICAgXCJjb250ZW50LWJveFwiLCBcImNvbnRleHQtbWVudVwiLCBcImNvbnRpbnVvdXNcIiwgXCJjb3B5XCIsIFwiY291bnRlclwiLCBcImNvdW50ZXJzXCIsIFwiY292ZXJcIiwgXCJjcm9wXCIsXG4gICAgXCJjcm9zc1wiLCBcImNyb3NzaGFpclwiLCBcImN1cnJlbnRjb2xvclwiLCBcImN1cnNpdmVcIiwgXCJjeWNsaWNcIiwgXCJkYXJrZW5cIiwgXCJkYXNoZWRcIiwgXCJkZWNpbWFsXCIsXG4gICAgXCJkZWNpbWFsLWxlYWRpbmctemVyb1wiLCBcImRlZmF1bHRcIiwgXCJkZWZhdWx0LWJ1dHRvblwiLCBcImRlbnNlXCIsIFwiZGVzdGluYXRpb24tYXRvcFwiLFxuICAgIFwiZGVzdGluYXRpb24taW5cIiwgXCJkZXN0aW5hdGlvbi1vdXRcIiwgXCJkZXN0aW5hdGlvbi1vdmVyXCIsIFwiZGV2YW5hZ2FyaVwiLCBcImRpZmZlcmVuY2VcIixcbiAgICBcImRpc2NcIiwgXCJkaXNjYXJkXCIsIFwiZGlzY2xvc3VyZS1jbG9zZWRcIiwgXCJkaXNjbG9zdXJlLW9wZW5cIiwgXCJkb2N1bWVudFwiLFxuICAgIFwiZG90LWRhc2hcIiwgXCJkb3QtZG90LWRhc2hcIixcbiAgICBcImRvdHRlZFwiLCBcImRvdWJsZVwiLCBcImRvd25cIiwgXCJlLXJlc2l6ZVwiLCBcImVhc2VcIiwgXCJlYXNlLWluXCIsIFwiZWFzZS1pbi1vdXRcIiwgXCJlYXNlLW91dFwiLFxuICAgIFwiZWxlbWVudFwiLCBcImVsbGlwc2VcIiwgXCJlbGxpcHNpc1wiLCBcImVtYmVkXCIsIFwiZW5kXCIsIFwiZXRoaW9waWNcIiwgXCJldGhpb3BpYy1hYmVnZWRlXCIsXG4gICAgXCJldGhpb3BpYy1hYmVnZWRlLWFtLWV0XCIsIFwiZXRoaW9waWMtYWJlZ2VkZS1nZXpcIiwgXCJldGhpb3BpYy1hYmVnZWRlLXRpLWVyXCIsXG4gICAgXCJldGhpb3BpYy1hYmVnZWRlLXRpLWV0XCIsIFwiZXRoaW9waWMtaGFsZWhhbWUtYWEtZXJcIixcbiAgICBcImV0aGlvcGljLWhhbGVoYW1lLWFhLWV0XCIsIFwiZXRoaW9waWMtaGFsZWhhbWUtYW0tZXRcIixcbiAgICBcImV0aGlvcGljLWhhbGVoYW1lLWdlelwiLCBcImV0aGlvcGljLWhhbGVoYW1lLW9tLWV0XCIsXG4gICAgXCJldGhpb3BpYy1oYWxlaGFtZS1zaWQtZXRcIiwgXCJldGhpb3BpYy1oYWxlaGFtZS1zby1ldFwiLFxuICAgIFwiZXRoaW9waWMtaGFsZWhhbWUtdGktZXJcIiwgXCJldGhpb3BpYy1oYWxlaGFtZS10aS1ldFwiLCBcImV0aGlvcGljLWhhbGVoYW1lLXRpZ1wiLFxuICAgIFwiZXRoaW9waWMtbnVtZXJpY1wiLCBcImV3LXJlc2l6ZVwiLCBcImV4Y2x1c2lvblwiLCBcImV4cGFuZGVkXCIsIFwiZXh0ZW5kc1wiLCBcImV4dHJhLWNvbmRlbnNlZFwiLFxuICAgIFwiZXh0cmEtZXhwYW5kZWRcIiwgXCJmYW50YXN5XCIsIFwiZmFzdFwiLCBcImZpbGxcIiwgXCJmaWxsLWJveFwiLCBcImZpeGVkXCIsIFwiZmxhdFwiLCBcImZsZXhcIiwgXCJmbGV4LWVuZFwiLCBcImZsZXgtc3RhcnRcIiwgXCJmb290bm90ZXNcIixcbiAgICBcImZvcndhcmRzXCIsIFwiZnJvbVwiLCBcImdlb21ldHJpY1ByZWNpc2lvblwiLCBcImdlb3JnaWFuXCIsIFwiZ3JheXRleHRcIiwgXCJncmlkXCIsIFwiZ3Jvb3ZlXCIsXG4gICAgXCJndWphcmF0aVwiLCBcImd1cm11a2hpXCIsIFwiaGFuZFwiLCBcImhhbmd1bFwiLCBcImhhbmd1bC1jb25zb25hbnRcIiwgXCJoYXJkLWxpZ2h0XCIsIFwiaGVicmV3XCIsXG4gICAgXCJoZWxwXCIsIFwiaGlkZGVuXCIsIFwiaGlkZVwiLCBcImhpZ2hlclwiLCBcImhpZ2hsaWdodFwiLCBcImhpZ2hsaWdodHRleHRcIixcbiAgICBcImhpcmFnYW5hXCIsIFwiaGlyYWdhbmEtaXJvaGFcIiwgXCJob3Jpem9udGFsXCIsIFwiaHNsXCIsIFwiaHNsYVwiLCBcImh1ZVwiLCBcImljb25cIiwgXCJpZ25vcmVcIixcbiAgICBcImluYWN0aXZlYm9yZGVyXCIsIFwiaW5hY3RpdmVjYXB0aW9uXCIsIFwiaW5hY3RpdmVjYXB0aW9udGV4dFwiLCBcImluZmluaXRlXCIsXG4gICAgXCJpbmZvYmFja2dyb3VuZFwiLCBcImluZm90ZXh0XCIsIFwiaW5oZXJpdFwiLCBcImluaXRpYWxcIiwgXCJpbmxpbmVcIiwgXCJpbmxpbmUtYXhpc1wiLFxuICAgIFwiaW5saW5lLWJsb2NrXCIsIFwiaW5saW5lLWZsZXhcIiwgXCJpbmxpbmUtZ3JpZFwiLCBcImlubGluZS10YWJsZVwiLCBcImluc2V0XCIsIFwiaW5zaWRlXCIsIFwiaW50cmluc2ljXCIsIFwiaW52ZXJ0XCIsXG4gICAgXCJpdGFsaWNcIiwgXCJqYXBhbmVzZS1mb3JtYWxcIiwgXCJqYXBhbmVzZS1pbmZvcm1hbFwiLCBcImp1c3RpZnlcIiwgXCJrYW5uYWRhXCIsXG4gICAgXCJrYXRha2FuYVwiLCBcImthdGFrYW5hLWlyb2hhXCIsIFwia2VlcC1hbGxcIiwgXCJraG1lclwiLFxuICAgIFwia29yZWFuLWhhbmd1bC1mb3JtYWxcIiwgXCJrb3JlYW4taGFuamEtZm9ybWFsXCIsIFwia29yZWFuLWhhbmphLWluZm9ybWFsXCIsXG4gICAgXCJsYW5kc2NhcGVcIiwgXCJsYW9cIiwgXCJsYXJnZVwiLCBcImxhcmdlclwiLCBcImxlZnRcIiwgXCJsZXZlbFwiLCBcImxpZ2h0ZXJcIiwgXCJsaWdodGVuXCIsXG4gICAgXCJsaW5lLXRocm91Z2hcIiwgXCJsaW5lYXJcIiwgXCJsaW5lYXItZ3JhZGllbnRcIiwgXCJsaW5lc1wiLCBcImxpc3QtaXRlbVwiLCBcImxpc3Rib3hcIiwgXCJsaXN0aXRlbVwiLFxuICAgIFwibG9jYWxcIiwgXCJsb2dpY2FsXCIsIFwibG91ZFwiLCBcImxvd2VyXCIsIFwibG93ZXItYWxwaGFcIiwgXCJsb3dlci1hcm1lbmlhblwiLFxuICAgIFwibG93ZXItZ3JlZWtcIiwgXCJsb3dlci1oZXhhZGVjaW1hbFwiLCBcImxvd2VyLWxhdGluXCIsIFwibG93ZXItbm9yd2VnaWFuXCIsXG4gICAgXCJsb3dlci1yb21hblwiLCBcImxvd2VyY2FzZVwiLCBcImx0clwiLCBcImx1bWlub3NpdHlcIiwgXCJtYWxheWFsYW1cIiwgXCJtYW5pcHVsYXRpb25cIiwgXCJtYXRjaFwiLCBcIm1hdHJpeFwiLCBcIm1hdHJpeDNkXCIsXG4gICAgXCJtZWRpYS1jb250cm9scy1iYWNrZ3JvdW5kXCIsIFwibWVkaWEtY3VycmVudC10aW1lLWRpc3BsYXlcIixcbiAgICBcIm1lZGlhLWZ1bGxzY3JlZW4tYnV0dG9uXCIsIFwibWVkaWEtbXV0ZS1idXR0b25cIiwgXCJtZWRpYS1wbGF5LWJ1dHRvblwiLFxuICAgIFwibWVkaWEtcmV0dXJuLXRvLXJlYWx0aW1lLWJ1dHRvblwiLCBcIm1lZGlhLXJld2luZC1idXR0b25cIixcbiAgICBcIm1lZGlhLXNlZWstYmFjay1idXR0b25cIiwgXCJtZWRpYS1zZWVrLWZvcndhcmQtYnV0dG9uXCIsIFwibWVkaWEtc2xpZGVyXCIsXG4gICAgXCJtZWRpYS1zbGlkZXJ0aHVtYlwiLCBcIm1lZGlhLXRpbWUtcmVtYWluaW5nLWRpc3BsYXlcIiwgXCJtZWRpYS12b2x1bWUtc2xpZGVyXCIsXG4gICAgXCJtZWRpYS12b2x1bWUtc2xpZGVyLWNvbnRhaW5lclwiLCBcIm1lZGlhLXZvbHVtZS1zbGlkZXJ0aHVtYlwiLCBcIm1lZGl1bVwiLFxuICAgIFwibWVudVwiLCBcIm1lbnVsaXN0XCIsIFwibWVudWxpc3QtYnV0dG9uXCIsIFwibWVudWxpc3QtdGV4dFwiLFxuICAgIFwibWVudWxpc3QtdGV4dGZpZWxkXCIsIFwibWVudXRleHRcIiwgXCJtZXNzYWdlLWJveFwiLCBcIm1pZGRsZVwiLCBcIm1pbi1pbnRyaW5zaWNcIixcbiAgICBcIm1peFwiLCBcIm1vbmdvbGlhblwiLCBcIm1vbm9zcGFjZVwiLCBcIm1vdmVcIiwgXCJtdWx0aXBsZVwiLCBcIm11bHRpcGxlX21hc2tfaW1hZ2VzXCIsIFwibXVsdGlwbHlcIiwgXCJteWFubWFyXCIsIFwibi1yZXNpemVcIixcbiAgICBcIm5hcnJvd2VyXCIsIFwibmUtcmVzaXplXCIsIFwibmVzdy1yZXNpemVcIiwgXCJuby1jbG9zZS1xdW90ZVwiLCBcIm5vLWRyb3BcIixcbiAgICBcIm5vLW9wZW4tcXVvdGVcIiwgXCJuby1yZXBlYXRcIiwgXCJub25lXCIsIFwibm9ybWFsXCIsIFwibm90LWFsbG93ZWRcIiwgXCJub3dyYXBcIixcbiAgICBcIm5zLXJlc2l6ZVwiLCBcIm51bWJlcnNcIiwgXCJudW1lcmljXCIsIFwibnctcmVzaXplXCIsIFwibndzZS1yZXNpemVcIiwgXCJvYmxpcXVlXCIsIFwib2N0YWxcIiwgXCJvcGFjaXR5XCIsIFwib3Blbi1xdW90ZVwiLFxuICAgIFwib3B0aW1pemVMZWdpYmlsaXR5XCIsIFwib3B0aW1pemVTcGVlZFwiLCBcIm9yaXlhXCIsIFwib3JvbW9cIiwgXCJvdXRzZXRcIixcbiAgICBcIm91dHNpZGVcIiwgXCJvdXRzaWRlLXNoYXBlXCIsIFwib3ZlcmxheVwiLCBcIm92ZXJsaW5lXCIsIFwicGFkZGluZ1wiLCBcInBhZGRpbmctYm94XCIsXG4gICAgXCJwYWludGVkXCIsIFwicGFnZVwiLCBcInBhdXNlZFwiLCBcInBlcnNpYW5cIiwgXCJwZXJzcGVjdGl2ZVwiLCBcInBpbmNoLXpvb21cIiwgXCJwbHVzLWRhcmtlclwiLCBcInBsdXMtbGlnaHRlclwiLFxuICAgIFwicG9pbnRlclwiLCBcInBvbHlnb25cIiwgXCJwb3J0cmFpdFwiLCBcInByZVwiLCBcInByZS1saW5lXCIsIFwicHJlLXdyYXBcIiwgXCJwcmVzZXJ2ZS0zZFwiLFxuICAgIFwicHJvZ3Jlc3NcIiwgXCJwdXNoLWJ1dHRvblwiLCBcInJhZGlhbC1ncmFkaWVudFwiLCBcInJhZGlvXCIsIFwicmVhZC1vbmx5XCIsXG4gICAgXCJyZWFkLXdyaXRlXCIsIFwicmVhZC13cml0ZS1wbGFpbnRleHQtb25seVwiLCBcInJlY3RhbmdsZVwiLCBcInJlZ2lvblwiLFxuICAgIFwicmVsYXRpdmVcIiwgXCJyZXBlYXRcIiwgXCJyZXBlYXRpbmctbGluZWFyLWdyYWRpZW50XCIsXG4gICAgXCJyZXBlYXRpbmctcmFkaWFsLWdyYWRpZW50XCIsIFwicmVwZWF0LXhcIiwgXCJyZXBlYXQteVwiLCBcInJlc2V0XCIsIFwicmV2ZXJzZVwiLFxuICAgIFwicmdiXCIsIFwicmdiYVwiLCBcInJpZGdlXCIsIFwicmlnaHRcIiwgXCJyb3RhdGVcIiwgXCJyb3RhdGUzZFwiLCBcInJvdGF0ZVhcIiwgXCJyb3RhdGVZXCIsXG4gICAgXCJyb3RhdGVaXCIsIFwicm91bmRcIiwgXCJyb3dcIiwgXCJyb3ctcmVzaXplXCIsIFwicm93LXJldmVyc2VcIiwgXCJydGxcIiwgXCJydW4taW5cIiwgXCJydW5uaW5nXCIsXG4gICAgXCJzLXJlc2l6ZVwiLCBcInNhbnMtc2VyaWZcIiwgXCJzYXR1cmF0aW9uXCIsIFwic2NhbGVcIiwgXCJzY2FsZTNkXCIsIFwic2NhbGVYXCIsIFwic2NhbGVZXCIsIFwic2NhbGVaXCIsIFwic2NyZWVuXCIsXG4gICAgXCJzY3JvbGxcIiwgXCJzY3JvbGxiYXJcIiwgXCJzY3JvbGwtcG9zaXRpb25cIiwgXCJzZS1yZXNpemVcIiwgXCJzZWFyY2hmaWVsZFwiLFxuICAgIFwic2VhcmNoZmllbGQtY2FuY2VsLWJ1dHRvblwiLCBcInNlYXJjaGZpZWxkLWRlY29yYXRpb25cIixcbiAgICBcInNlYXJjaGZpZWxkLXJlc3VsdHMtYnV0dG9uXCIsIFwic2VhcmNoZmllbGQtcmVzdWx0cy1kZWNvcmF0aW9uXCIsIFwic2VsZi1zdGFydFwiLCBcInNlbGYtZW5kXCIsXG4gICAgXCJzZW1pLWNvbmRlbnNlZFwiLCBcInNlbWktZXhwYW5kZWRcIiwgXCJzZXBhcmF0ZVwiLCBcInNlcmlmXCIsIFwic2hvd1wiLCBcInNpZGFtYVwiLFxuICAgIFwic2ltcC1jaGluZXNlLWZvcm1hbFwiLCBcInNpbXAtY2hpbmVzZS1pbmZvcm1hbFwiLCBcInNpbmdsZVwiLFxuICAgIFwic2tld1wiLCBcInNrZXdYXCIsIFwic2tld1lcIiwgXCJza2lwLXdoaXRlLXNwYWNlXCIsIFwic2xpZGVcIiwgXCJzbGlkZXItaG9yaXpvbnRhbFwiLFxuICAgIFwic2xpZGVyLXZlcnRpY2FsXCIsIFwic2xpZGVydGh1bWItaG9yaXpvbnRhbFwiLCBcInNsaWRlcnRodW1iLXZlcnRpY2FsXCIsIFwic2xvd1wiLFxuICAgIFwic21hbGxcIiwgXCJzbWFsbC1jYXBzXCIsIFwic21hbGwtY2FwdGlvblwiLCBcInNtYWxsZXJcIiwgXCJzb2Z0LWxpZ2h0XCIsIFwic29saWRcIiwgXCJzb21hbGlcIixcbiAgICBcInNvdXJjZS1hdG9wXCIsIFwic291cmNlLWluXCIsIFwic291cmNlLW91dFwiLCBcInNvdXJjZS1vdmVyXCIsIFwic3BhY2VcIiwgXCJzcGFjZS1hcm91bmRcIiwgXCJzcGFjZS1iZXR3ZWVuXCIsIFwic3BhY2UtZXZlbmx5XCIsIFwic3BlbGwtb3V0XCIsIFwic3F1YXJlXCIsXG4gICAgXCJzcXVhcmUtYnV0dG9uXCIsIFwic3RhcnRcIiwgXCJzdGF0aWNcIiwgXCJzdGF0dXMtYmFyXCIsIFwic3RyZXRjaFwiLCBcInN0cm9rZVwiLCBcInN0cm9rZS1ib3hcIiwgXCJzdWJcIixcbiAgICBcInN1YnBpeGVsLWFudGlhbGlhc2VkXCIsIFwic3ZnX21hc2tzXCIsIFwic3VwZXJcIiwgXCJzdy1yZXNpemVcIiwgXCJzeW1ib2xpY1wiLCBcInN5bWJvbHNcIiwgXCJzeXN0ZW0tdWlcIiwgXCJ0YWJsZVwiLFxuICAgIFwidGFibGUtY2FwdGlvblwiLCBcInRhYmxlLWNlbGxcIiwgXCJ0YWJsZS1jb2x1bW5cIiwgXCJ0YWJsZS1jb2x1bW4tZ3JvdXBcIixcbiAgICBcInRhYmxlLWZvb3Rlci1ncm91cFwiLCBcInRhYmxlLWhlYWRlci1ncm91cFwiLCBcInRhYmxlLXJvd1wiLCBcInRhYmxlLXJvdy1ncm91cFwiLFxuICAgIFwidGFtaWxcIixcbiAgICBcInRlbHVndVwiLCBcInRleHRcIiwgXCJ0ZXh0LWJvdHRvbVwiLCBcInRleHQtdG9wXCIsIFwidGV4dGFyZWFcIiwgXCJ0ZXh0ZmllbGRcIiwgXCJ0aGFpXCIsXG4gICAgXCJ0aGlja1wiLCBcInRoaW5cIiwgXCJ0aHJlZWRkYXJrc2hhZG93XCIsIFwidGhyZWVkZmFjZVwiLCBcInRocmVlZGhpZ2hsaWdodFwiLFxuICAgIFwidGhyZWVkbGlnaHRzaGFkb3dcIiwgXCJ0aHJlZWRzaGFkb3dcIiwgXCJ0aWJldGFuXCIsIFwidGlncmVcIiwgXCJ0aWdyaW55YS1lclwiLFxuICAgIFwidGlncmlueWEtZXItYWJlZ2VkZVwiLCBcInRpZ3JpbnlhLWV0XCIsIFwidGlncmlueWEtZXQtYWJlZ2VkZVwiLCBcInRvXCIsIFwidG9wXCIsXG4gICAgXCJ0cmFkLWNoaW5lc2UtZm9ybWFsXCIsIFwidHJhZC1jaGluZXNlLWluZm9ybWFsXCIsIFwidHJhbnNmb3JtXCIsXG4gICAgXCJ0cmFuc2xhdGVcIiwgXCJ0cmFuc2xhdGUzZFwiLCBcInRyYW5zbGF0ZVhcIiwgXCJ0cmFuc2xhdGVZXCIsIFwidHJhbnNsYXRlWlwiLFxuICAgIFwidHJhbnNwYXJlbnRcIiwgXCJ1bHRyYS1jb25kZW5zZWRcIiwgXCJ1bHRyYS1leHBhbmRlZFwiLCBcInVuZGVybGluZVwiLCBcInVuaWRpcmVjdGlvbmFsLXBhblwiLCBcInVuc2V0XCIsIFwidXBcIixcbiAgICBcInVwcGVyLWFscGhhXCIsIFwidXBwZXItYXJtZW5pYW5cIiwgXCJ1cHBlci1ncmVla1wiLCBcInVwcGVyLWhleGFkZWNpbWFsXCIsXG4gICAgXCJ1cHBlci1sYXRpblwiLCBcInVwcGVyLW5vcndlZ2lhblwiLCBcInVwcGVyLXJvbWFuXCIsIFwidXBwZXJjYXNlXCIsIFwidXJkdVwiLCBcInVybFwiLFxuICAgIFwidmFyXCIsIFwidmVydGljYWxcIiwgXCJ2ZXJ0aWNhbC10ZXh0XCIsIFwidmlldy1ib3hcIiwgXCJ2aXNpYmxlXCIsIFwidmlzaWJsZUZpbGxcIiwgXCJ2aXNpYmxlUGFpbnRlZFwiLFxuICAgIFwidmlzaWJsZVN0cm9rZVwiLCBcInZpc3VhbFwiLCBcInctcmVzaXplXCIsIFwid2FpdFwiLCBcIndhdmVcIiwgXCJ3aWRlclwiLFxuICAgIFwid2luZG93XCIsIFwid2luZG93ZnJhbWVcIiwgXCJ3aW5kb3d0ZXh0XCIsIFwid29yZHNcIiwgXCJ3cmFwXCIsIFwid3JhcC1yZXZlcnNlXCIsIFwieC1sYXJnZVwiLCBcIngtc21hbGxcIiwgXCJ4b3JcIixcbiAgICBcInh4LWxhcmdlXCIsIFwieHgtc21hbGxcIlxuICBdLCB2YWx1ZUtleXdvcmRzID0ga2V5U2V0KHZhbHVlS2V5d29yZHNfKTtcblxuICB2YXIgYWxsV29yZHMgPSBkb2N1bWVudFR5cGVzXy5jb25jYXQobWVkaWFUeXBlc18pLmNvbmNhdChtZWRpYUZlYXR1cmVzXykuY29uY2F0KG1lZGlhVmFsdWVLZXl3b3Jkc18pXG4gICAgLmNvbmNhdChwcm9wZXJ0eUtleXdvcmRzXykuY29uY2F0KG5vblN0YW5kYXJkUHJvcGVydHlLZXl3b3Jkc18pLmNvbmNhdChjb2xvcktleXdvcmRzXylcbiAgICAuY29uY2F0KHZhbHVlS2V5d29yZHNfKTtcbiAgQ29kZU1pcnJvci5yZWdpc3RlckhlbHBlcihcImhpbnRXb3Jkc1wiLCBcImNzc1wiLCBhbGxXb3Jkcyk7XG5cbiAgZnVuY3Rpb24gdG9rZW5DQ29tbWVudChzdHJlYW0sIHN0YXRlKSB7XG4gICAgdmFyIG1heWJlRW5kID0gZmFsc2UsIGNoO1xuICAgIHdoaWxlICgoY2ggPSBzdHJlYW0ubmV4dCgpKSAhPSBudWxsKSB7XG4gICAgICBpZiAobWF5YmVFbmQgJiYgY2ggPT0gXCIvXCIpIHtcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSBudWxsO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIG1heWJlRW5kID0gKGNoID09IFwiKlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIFtcImNvbW1lbnRcIiwgXCJjb21tZW50XCJdO1xuICB9XG5cbiAgQ29kZU1pcnJvci5kZWZpbmVNSU1FKFwidGV4dC9jc3NcIiwge1xuICAgIGRvY3VtZW50VHlwZXM6IGRvY3VtZW50VHlwZXMsXG4gICAgbWVkaWFUeXBlczogbWVkaWFUeXBlcyxcbiAgICBtZWRpYUZlYXR1cmVzOiBtZWRpYUZlYXR1cmVzLFxuICAgIG1lZGlhVmFsdWVLZXl3b3JkczogbWVkaWFWYWx1ZUtleXdvcmRzLFxuICAgIHByb3BlcnR5S2V5d29yZHM6IHByb3BlcnR5S2V5d29yZHMsXG4gICAgbm9uU3RhbmRhcmRQcm9wZXJ0eUtleXdvcmRzOiBub25TdGFuZGFyZFByb3BlcnR5S2V5d29yZHMsXG4gICAgZm9udFByb3BlcnRpZXM6IGZvbnRQcm9wZXJ0aWVzLFxuICAgIGNvdW50ZXJEZXNjcmlwdG9yczogY291bnRlckRlc2NyaXB0b3JzLFxuICAgIGNvbG9yS2V5d29yZHM6IGNvbG9yS2V5d29yZHMsXG4gICAgdmFsdWVLZXl3b3JkczogdmFsdWVLZXl3b3JkcyxcbiAgICB0b2tlbkhvb2tzOiB7XG4gICAgICBcIi9cIjogZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgICBpZiAoIXN0cmVhbS5lYXQoXCIqXCIpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5DQ29tbWVudDtcbiAgICAgICAgcmV0dXJuIHRva2VuQ0NvbW1lbnQoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBuYW1lOiBcImNzc1wiXG4gIH0pO1xuXG4gIENvZGVNaXJyb3IuZGVmaW5lTUlNRShcInRleHQveC1zY3NzXCIsIHtcbiAgICBtZWRpYVR5cGVzOiBtZWRpYVR5cGVzLFxuICAgIG1lZGlhRmVhdHVyZXM6IG1lZGlhRmVhdHVyZXMsXG4gICAgbWVkaWFWYWx1ZUtleXdvcmRzOiBtZWRpYVZhbHVlS2V5d29yZHMsXG4gICAgcHJvcGVydHlLZXl3b3JkczogcHJvcGVydHlLZXl3b3JkcyxcbiAgICBub25TdGFuZGFyZFByb3BlcnR5S2V5d29yZHM6IG5vblN0YW5kYXJkUHJvcGVydHlLZXl3b3JkcyxcbiAgICBjb2xvcktleXdvcmRzOiBjb2xvcktleXdvcmRzLFxuICAgIHZhbHVlS2V5d29yZHM6IHZhbHVlS2V5d29yZHMsXG4gICAgZm9udFByb3BlcnRpZXM6IGZvbnRQcm9wZXJ0aWVzLFxuICAgIGFsbG93TmVzdGVkOiB0cnVlLFxuICAgIGxpbmVDb21tZW50OiBcIi8vXCIsXG4gICAgdG9rZW5Ib29rczoge1xuICAgICAgXCIvXCI6IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgICAgaWYgKHN0cmVhbS5lYXQoXCIvXCIpKSB7XG4gICAgICAgICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgICAgICAgIHJldHVybiBbXCJjb21tZW50XCIsIFwiY29tbWVudFwiXTtcbiAgICAgICAgfSBlbHNlIGlmIChzdHJlYW0uZWF0KFwiKlwiKSkge1xuICAgICAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5DQ29tbWVudDtcbiAgICAgICAgICByZXR1cm4gdG9rZW5DQ29tbWVudChzdHJlYW0sIHN0YXRlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gW1wib3BlcmF0b3JcIiwgXCJvcGVyYXRvclwiXTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwiOlwiOiBmdW5jdGlvbihzdHJlYW0pIHtcbiAgICAgICAgaWYgKHN0cmVhbS5tYXRjaCgvXFxzKlxcey8sIGZhbHNlKSlcbiAgICAgICAgICByZXR1cm4gW251bGwsIG51bGxdXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0sXG4gICAgICBcIiRcIjogZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgICAgIHN0cmVhbS5tYXRjaCgvXltcXHctXSsvKTtcbiAgICAgICAgaWYgKHN0cmVhbS5tYXRjaCgvXlxccyo6LywgZmFsc2UpKVxuICAgICAgICAgIHJldHVybiBbXCJ2YXJpYWJsZS0yXCIsIFwidmFyaWFibGUtZGVmaW5pdGlvblwiXTtcbiAgICAgICAgcmV0dXJuIFtcInZhcmlhYmxlLTJcIiwgXCJ2YXJpYWJsZVwiXTtcbiAgICAgIH0sXG4gICAgICBcIiNcIjogZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgICAgIGlmICghc3RyZWFtLmVhdChcIntcIikpIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIFtudWxsLCBcImludGVycG9sYXRpb25cIl07XG4gICAgICB9XG4gICAgfSxcbiAgICBuYW1lOiBcImNzc1wiLFxuICAgIGhlbHBlclR5cGU6IFwic2Nzc1wiXG4gIH0pO1xuXG4gIENvZGVNaXJyb3IuZGVmaW5lTUlNRShcInRleHQveC1sZXNzXCIsIHtcbiAgICBtZWRpYVR5cGVzOiBtZWRpYVR5cGVzLFxuICAgIG1lZGlhRmVhdHVyZXM6IG1lZGlhRmVhdHVyZXMsXG4gICAgbWVkaWFWYWx1ZUtleXdvcmRzOiBtZWRpYVZhbHVlS2V5d29yZHMsXG4gICAgcHJvcGVydHlLZXl3b3JkczogcHJvcGVydHlLZXl3b3JkcyxcbiAgICBub25TdGFuZGFyZFByb3BlcnR5S2V5d29yZHM6IG5vblN0YW5kYXJkUHJvcGVydHlLZXl3b3JkcyxcbiAgICBjb2xvcktleXdvcmRzOiBjb2xvcktleXdvcmRzLFxuICAgIHZhbHVlS2V5d29yZHM6IHZhbHVlS2V5d29yZHMsXG4gICAgZm9udFByb3BlcnRpZXM6IGZvbnRQcm9wZXJ0aWVzLFxuICAgIGFsbG93TmVzdGVkOiB0cnVlLFxuICAgIGxpbmVDb21tZW50OiBcIi8vXCIsXG4gICAgdG9rZW5Ib29rczoge1xuICAgICAgXCIvXCI6IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgICAgaWYgKHN0cmVhbS5lYXQoXCIvXCIpKSB7XG4gICAgICAgICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgICAgICAgIHJldHVybiBbXCJjb21tZW50XCIsIFwiY29tbWVudFwiXTtcbiAgICAgICAgfSBlbHNlIGlmIChzdHJlYW0uZWF0KFwiKlwiKSkge1xuICAgICAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5DQ29tbWVudDtcbiAgICAgICAgICByZXR1cm4gdG9rZW5DQ29tbWVudChzdHJlYW0sIHN0YXRlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gW1wib3BlcmF0b3JcIiwgXCJvcGVyYXRvclwiXTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwiQFwiOiBmdW5jdGlvbihzdHJlYW0pIHtcbiAgICAgICAgaWYgKHN0cmVhbS5lYXQoXCJ7XCIpKSByZXR1cm4gW251bGwsIFwiaW50ZXJwb2xhdGlvblwiXTtcbiAgICAgICAgaWYgKHN0cmVhbS5tYXRjaCgvXihjaGFyc2V0fGRvY3VtZW50fGZvbnQtZmFjZXxpbXBvcnR8KC0obW96fG1zfG98d2Via2l0KS0pP2tleWZyYW1lc3xtZWRpYXxuYW1lc3BhY2V8cGFnZXxzdXBwb3J0cylcXGIvaSwgZmFsc2UpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHN0cmVhbS5lYXRXaGlsZSgvW1xcd1xcXFxcXC1dLyk7XG4gICAgICAgIGlmIChzdHJlYW0ubWF0Y2goL15cXHMqOi8sIGZhbHNlKSlcbiAgICAgICAgICByZXR1cm4gW1widmFyaWFibGUtMlwiLCBcInZhcmlhYmxlLWRlZmluaXRpb25cIl07XG4gICAgICAgIHJldHVybiBbXCJ2YXJpYWJsZS0yXCIsIFwidmFyaWFibGVcIl07XG4gICAgICB9LFxuICAgICAgXCImXCI6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gW1wiYXRvbVwiLCBcImF0b21cIl07XG4gICAgICB9XG4gICAgfSxcbiAgICBuYW1lOiBcImNzc1wiLFxuICAgIGhlbHBlclR5cGU6IFwibGVzc1wiXG4gIH0pO1xuXG4gIENvZGVNaXJyb3IuZGVmaW5lTUlNRShcInRleHQveC1nc3NcIiwge1xuICAgIGRvY3VtZW50VHlwZXM6IGRvY3VtZW50VHlwZXMsXG4gICAgbWVkaWFUeXBlczogbWVkaWFUeXBlcyxcbiAgICBtZWRpYUZlYXR1cmVzOiBtZWRpYUZlYXR1cmVzLFxuICAgIHByb3BlcnR5S2V5d29yZHM6IHByb3BlcnR5S2V5d29yZHMsXG4gICAgbm9uU3RhbmRhcmRQcm9wZXJ0eUtleXdvcmRzOiBub25TdGFuZGFyZFByb3BlcnR5S2V5d29yZHMsXG4gICAgZm9udFByb3BlcnRpZXM6IGZvbnRQcm9wZXJ0aWVzLFxuICAgIGNvdW50ZXJEZXNjcmlwdG9yczogY291bnRlckRlc2NyaXB0b3JzLFxuICAgIGNvbG9yS2V5d29yZHM6IGNvbG9yS2V5d29yZHMsXG4gICAgdmFsdWVLZXl3b3JkczogdmFsdWVLZXl3b3JkcyxcbiAgICBzdXBwb3J0c0F0Q29tcG9uZW50OiB0cnVlLFxuICAgIHRva2VuSG9va3M6IHtcbiAgICAgIFwiL1wiOiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICAgIGlmICghc3RyZWFtLmVhdChcIipcIikpIHJldHVybiBmYWxzZTtcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkNDb21tZW50O1xuICAgICAgICByZXR1cm4gdG9rZW5DQ29tbWVudChzdHJlYW0sIHN0YXRlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG5hbWU6IFwiY3NzXCIsXG4gICAgaGVscGVyVHlwZTogXCJnc3NcIlxuICB9KTtcblxufSk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/codemirror/mode/css/css.js\n");

/***/ }),

/***/ "./node_modules/codemirror/mode/htmlmixed/htmlmixed.js":
/*!*************************************************************!*\
  !*** ./node_modules/codemirror/mode/htmlmixed/htmlmixed.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (true) // CommonJS\n    mod(__webpack_require__(/*! ../../lib/codemirror */ \"./node_modules/codemirror/lib/codemirror.js\"), __webpack_require__(/*! ../xml/xml */ \"./node_modules/codemirror/mode/xml/xml.js\"), __webpack_require__(/*! ../javascript/javascript */ \"./node_modules/codemirror/mode/javascript/javascript.js\"), __webpack_require__(/*! ../css/css */ \"./node_modules/codemirror/mode/css/css.js\"));\n  else {}\n})(function(CodeMirror) {\n  \"use strict\";\n\n  var defaultTags = {\n    script: [\n      [\"lang\", /(javascript|babel)/i, \"javascript\"],\n      [\"type\", /^(?:text|application)\\/(?:x-)?(?:java|ecma)script$|^module$|^$/i, \"javascript\"],\n      [\"type\", /./, \"text/plain\"],\n      [null, null, \"javascript\"]\n    ],\n    style:  [\n      [\"lang\", /^css$/i, \"css\"],\n      [\"type\", /^(text\\/)?(x-)?(stylesheet|css)$/i, \"css\"],\n      [\"type\", /./, \"text/plain\"],\n      [null, null, \"css\"]\n    ]\n  };\n\n  function maybeBackup(stream, pat, style) {\n    var cur = stream.current(), close = cur.search(pat);\n    if (close > -1) {\n      stream.backUp(cur.length - close);\n    } else if (cur.match(/<\\/?$/)) {\n      stream.backUp(cur.length);\n      if (!stream.match(pat, false)) stream.match(cur);\n    }\n    return style;\n  }\n\n  var attrRegexpCache = {};\n  function getAttrRegexp(attr) {\n    var regexp = attrRegexpCache[attr];\n    if (regexp) return regexp;\n    return attrRegexpCache[attr] = new RegExp(\"\\\\s+\" + attr + \"\\\\s*=\\\\s*('|\\\")?([^'\\\"]+)('|\\\")?\\\\s*\");\n  }\n\n  function getAttrValue(text, attr) {\n    var match = text.match(getAttrRegexp(attr))\n    return match ? /^\\s*(.*?)\\s*$/.exec(match[2])[1] : \"\"\n  }\n\n  function getTagRegexp(tagName, anchored) {\n    return new RegExp((anchored ? \"^\" : \"\") + \"<\\/\\s*\" + tagName + \"\\s*>\", \"i\");\n  }\n\n  function addTags(from, to) {\n    for (var tag in from) {\n      var dest = to[tag] || (to[tag] = []);\n      var source = from[tag];\n      for (var i = source.length - 1; i >= 0; i--)\n        dest.unshift(source[i])\n    }\n  }\n\n  function findMatchingMode(tagInfo, tagText) {\n    for (var i = 0; i < tagInfo.length; i++) {\n      var spec = tagInfo[i];\n      if (!spec[0] || spec[1].test(getAttrValue(tagText, spec[0]))) return spec[2];\n    }\n  }\n\n  CodeMirror.defineMode(\"htmlmixed\", function (config, parserConfig) {\n    var htmlMode = CodeMirror.getMode(config, {\n      name: \"xml\",\n      htmlMode: true,\n      multilineTagIndentFactor: parserConfig.multilineTagIndentFactor,\n      multilineTagIndentPastTag: parserConfig.multilineTagIndentPastTag,\n      allowMissingTagName: parserConfig.allowMissingTagName,\n    });\n\n    var tags = {};\n    var configTags = parserConfig && parserConfig.tags, configScript = parserConfig && parserConfig.scriptTypes;\n    addTags(defaultTags, tags);\n    if (configTags) addTags(configTags, tags);\n    if (configScript) for (var i = configScript.length - 1; i >= 0; i--)\n      tags.script.unshift([\"type\", configScript[i].matches, configScript[i].mode])\n\n    function html(stream, state) {\n      var style = htmlMode.token(stream, state.htmlState), tag = /\\btag\\b/.test(style), tagName\n      if (tag && !/[<>\\s\\/]/.test(stream.current()) &&\n          (tagName = state.htmlState.tagName && state.htmlState.tagName.toLowerCase()) &&\n          tags.hasOwnProperty(tagName)) {\n        state.inTag = tagName + \" \"\n      } else if (state.inTag && tag && />$/.test(stream.current())) {\n        var inTag = /^([\\S]+) (.*)/.exec(state.inTag)\n        state.inTag = null\n        var modeSpec = stream.current() == \">\" && findMatchingMode(tags[inTag[1]], inTag[2])\n        var mode = CodeMirror.getMode(config, modeSpec)\n        var endTagA = getTagRegexp(inTag[1], true), endTag = getTagRegexp(inTag[1], false);\n        state.token = function (stream, state) {\n          if (stream.match(endTagA, false)) {\n            state.token = html;\n            state.localState = state.localMode = null;\n            return null;\n          }\n          return maybeBackup(stream, endTag, state.localMode.token(stream, state.localState));\n        };\n        state.localMode = mode;\n        state.localState = CodeMirror.startState(mode, htmlMode.indent(state.htmlState, \"\", \"\"));\n      } else if (state.inTag) {\n        state.inTag += stream.current()\n        if (stream.eol()) state.inTag += \" \"\n      }\n      return style;\n    };\n\n    return {\n      startState: function () {\n        var state = CodeMirror.startState(htmlMode);\n        return {token: html, inTag: null, localMode: null, localState: null, htmlState: state};\n      },\n\n      copyState: function (state) {\n        var local;\n        if (state.localState) {\n          local = CodeMirror.copyState(state.localMode, state.localState);\n        }\n        return {token: state.token, inTag: state.inTag,\n                localMode: state.localMode, localState: local,\n                htmlState: CodeMirror.copyState(htmlMode, state.htmlState)};\n      },\n\n      token: function (stream, state) {\n        return state.token(stream, state);\n      },\n\n      indent: function (state, textAfter, line) {\n        if (!state.localMode || /^\\s*<\\//.test(textAfter))\n          return htmlMode.indent(state.htmlState, textAfter, line);\n        else if (state.localMode.indent)\n          return state.localMode.indent(state.localState, textAfter, line);\n        else\n          return CodeMirror.Pass;\n      },\n\n      innerMode: function (state) {\n        return {state: state.localState || state.htmlState, mode: state.localMode || htmlMode};\n      }\n    };\n  }, \"xml\", \"javascript\", \"css\");\n\n  CodeMirror.defineMIME(\"text/html\", \"htmlmixed\");\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29kZW1pcnJvci9tb2RlL2h0bWxtaXhlZC9odG1sbWl4ZWQuanM/ZDY5ZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBO0FBQ0EsTUFBTSxJQUF1RDtBQUM3RCxRQUFRLG1CQUFPLENBQUMseUVBQXNCLEdBQUcsbUJBQU8sQ0FBQyw2REFBWSxHQUFHLG1CQUFPLENBQUMseUZBQTBCLEdBQUcsbUJBQU8sQ0FBQyw2REFBWTtBQUN6SCxPQUFPLEVBR2E7QUFDcEIsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFFBQVE7QUFDN0M7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLG9CQUFvQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsUUFBUTtBQUNuRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2NvZGVtaXJyb3IvbW9kZS9odG1sbWl4ZWQvaHRtbG1peGVkLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29kZU1pcnJvciwgY29weXJpZ2h0IChjKSBieSBNYXJpam4gSGF2ZXJiZWtlIGFuZCBvdGhlcnNcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIGFuIE1JVCBsaWNlbnNlOiBodHRwczovL2NvZGVtaXJyb3IubmV0L0xJQ0VOU0VcblxuKGZ1bmN0aW9uKG1vZCkge1xuICBpZiAodHlwZW9mIGV4cG9ydHMgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlID09IFwib2JqZWN0XCIpIC8vIENvbW1vbkpTXG4gICAgbW9kKHJlcXVpcmUoXCIuLi8uLi9saWIvY29kZW1pcnJvclwiKSwgcmVxdWlyZShcIi4uL3htbC94bWxcIiksIHJlcXVpcmUoXCIuLi9qYXZhc2NyaXB0L2phdmFzY3JpcHRcIiksIHJlcXVpcmUoXCIuLi9jc3MvY3NzXCIpKTtcbiAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkgLy8gQU1EXG4gICAgZGVmaW5lKFtcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCIsIFwiLi4veG1sL3htbFwiLCBcIi4uL2phdmFzY3JpcHQvamF2YXNjcmlwdFwiLCBcIi4uL2Nzcy9jc3NcIl0sIG1vZCk7XG4gIGVsc2UgLy8gUGxhaW4gYnJvd3NlciBlbnZcbiAgICBtb2QoQ29kZU1pcnJvcik7XG59KShmdW5jdGlvbihDb2RlTWlycm9yKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIHZhciBkZWZhdWx0VGFncyA9IHtcbiAgICBzY3JpcHQ6IFtcbiAgICAgIFtcImxhbmdcIiwgLyhqYXZhc2NyaXB0fGJhYmVsKS9pLCBcImphdmFzY3JpcHRcIl0sXG4gICAgICBbXCJ0eXBlXCIsIC9eKD86dGV4dHxhcHBsaWNhdGlvbilcXC8oPzp4LSk/KD86amF2YXxlY21hKXNjcmlwdCR8Xm1vZHVsZSR8XiQvaSwgXCJqYXZhc2NyaXB0XCJdLFxuICAgICAgW1widHlwZVwiLCAvLi8sIFwidGV4dC9wbGFpblwiXSxcbiAgICAgIFtudWxsLCBudWxsLCBcImphdmFzY3JpcHRcIl1cbiAgICBdLFxuICAgIHN0eWxlOiAgW1xuICAgICAgW1wibGFuZ1wiLCAvXmNzcyQvaSwgXCJjc3NcIl0sXG4gICAgICBbXCJ0eXBlXCIsIC9eKHRleHRcXC8pPyh4LSk/KHN0eWxlc2hlZXR8Y3NzKSQvaSwgXCJjc3NcIl0sXG4gICAgICBbXCJ0eXBlXCIsIC8uLywgXCJ0ZXh0L3BsYWluXCJdLFxuICAgICAgW251bGwsIG51bGwsIFwiY3NzXCJdXG4gICAgXVxuICB9O1xuXG4gIGZ1bmN0aW9uIG1heWJlQmFja3VwKHN0cmVhbSwgcGF0LCBzdHlsZSkge1xuICAgIHZhciBjdXIgPSBzdHJlYW0uY3VycmVudCgpLCBjbG9zZSA9IGN1ci5zZWFyY2gocGF0KTtcbiAgICBpZiAoY2xvc2UgPiAtMSkge1xuICAgICAgc3RyZWFtLmJhY2tVcChjdXIubGVuZ3RoIC0gY2xvc2UpO1xuICAgIH0gZWxzZSBpZiAoY3VyLm1hdGNoKC88XFwvPyQvKSkge1xuICAgICAgc3RyZWFtLmJhY2tVcChjdXIubGVuZ3RoKTtcbiAgICAgIGlmICghc3RyZWFtLm1hdGNoKHBhdCwgZmFsc2UpKSBzdHJlYW0ubWF0Y2goY3VyKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0eWxlO1xuICB9XG5cbiAgdmFyIGF0dHJSZWdleHBDYWNoZSA9IHt9O1xuICBmdW5jdGlvbiBnZXRBdHRyUmVnZXhwKGF0dHIpIHtcbiAgICB2YXIgcmVnZXhwID0gYXR0clJlZ2V4cENhY2hlW2F0dHJdO1xuICAgIGlmIChyZWdleHApIHJldHVybiByZWdleHA7XG4gICAgcmV0dXJuIGF0dHJSZWdleHBDYWNoZVthdHRyXSA9IG5ldyBSZWdFeHAoXCJcXFxccytcIiArIGF0dHIgKyBcIlxcXFxzKj1cXFxccyooJ3xcXFwiKT8oW14nXFxcIl0rKSgnfFxcXCIpP1xcXFxzKlwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEF0dHJWYWx1ZSh0ZXh0LCBhdHRyKSB7XG4gICAgdmFyIG1hdGNoID0gdGV4dC5tYXRjaChnZXRBdHRyUmVnZXhwKGF0dHIpKVxuICAgIHJldHVybiBtYXRjaCA/IC9eXFxzKiguKj8pXFxzKiQvLmV4ZWMobWF0Y2hbMl0pWzFdIDogXCJcIlxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0VGFnUmVnZXhwKHRhZ05hbWUsIGFuY2hvcmVkKSB7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoKGFuY2hvcmVkID8gXCJeXCIgOiBcIlwiKSArIFwiPFxcL1xccypcIiArIHRhZ05hbWUgKyBcIlxccyo+XCIsIFwiaVwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZFRhZ3MoZnJvbSwgdG8pIHtcbiAgICBmb3IgKHZhciB0YWcgaW4gZnJvbSkge1xuICAgICAgdmFyIGRlc3QgPSB0b1t0YWddIHx8ICh0b1t0YWddID0gW10pO1xuICAgICAgdmFyIHNvdXJjZSA9IGZyb21bdGFnXTtcbiAgICAgIGZvciAodmFyIGkgPSBzb3VyY2UubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgIGRlc3QudW5zaGlmdChzb3VyY2VbaV0pXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZmluZE1hdGNoaW5nTW9kZSh0YWdJbmZvLCB0YWdUZXh0KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0YWdJbmZvLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc3BlYyA9IHRhZ0luZm9baV07XG4gICAgICBpZiAoIXNwZWNbMF0gfHwgc3BlY1sxXS50ZXN0KGdldEF0dHJWYWx1ZSh0YWdUZXh0LCBzcGVjWzBdKSkpIHJldHVybiBzcGVjWzJdO1xuICAgIH1cbiAgfVxuXG4gIENvZGVNaXJyb3IuZGVmaW5lTW9kZShcImh0bWxtaXhlZFwiLCBmdW5jdGlvbiAoY29uZmlnLCBwYXJzZXJDb25maWcpIHtcbiAgICB2YXIgaHRtbE1vZGUgPSBDb2RlTWlycm9yLmdldE1vZGUoY29uZmlnLCB7XG4gICAgICBuYW1lOiBcInhtbFwiLFxuICAgICAgaHRtbE1vZGU6IHRydWUsXG4gICAgICBtdWx0aWxpbmVUYWdJbmRlbnRGYWN0b3I6IHBhcnNlckNvbmZpZy5tdWx0aWxpbmVUYWdJbmRlbnRGYWN0b3IsXG4gICAgICBtdWx0aWxpbmVUYWdJbmRlbnRQYXN0VGFnOiBwYXJzZXJDb25maWcubXVsdGlsaW5lVGFnSW5kZW50UGFzdFRhZyxcbiAgICAgIGFsbG93TWlzc2luZ1RhZ05hbWU6IHBhcnNlckNvbmZpZy5hbGxvd01pc3NpbmdUYWdOYW1lLFxuICAgIH0pO1xuXG4gICAgdmFyIHRhZ3MgPSB7fTtcbiAgICB2YXIgY29uZmlnVGFncyA9IHBhcnNlckNvbmZpZyAmJiBwYXJzZXJDb25maWcudGFncywgY29uZmlnU2NyaXB0ID0gcGFyc2VyQ29uZmlnICYmIHBhcnNlckNvbmZpZy5zY3JpcHRUeXBlcztcbiAgICBhZGRUYWdzKGRlZmF1bHRUYWdzLCB0YWdzKTtcbiAgICBpZiAoY29uZmlnVGFncykgYWRkVGFncyhjb25maWdUYWdzLCB0YWdzKTtcbiAgICBpZiAoY29uZmlnU2NyaXB0KSBmb3IgKHZhciBpID0gY29uZmlnU2NyaXB0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgdGFncy5zY3JpcHQudW5zaGlmdChbXCJ0eXBlXCIsIGNvbmZpZ1NjcmlwdFtpXS5tYXRjaGVzLCBjb25maWdTY3JpcHRbaV0ubW9kZV0pXG5cbiAgICBmdW5jdGlvbiBodG1sKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIHZhciBzdHlsZSA9IGh0bWxNb2RlLnRva2VuKHN0cmVhbSwgc3RhdGUuaHRtbFN0YXRlKSwgdGFnID0gL1xcYnRhZ1xcYi8udGVzdChzdHlsZSksIHRhZ05hbWVcbiAgICAgIGlmICh0YWcgJiYgIS9bPD5cXHNcXC9dLy50ZXN0KHN0cmVhbS5jdXJyZW50KCkpICYmXG4gICAgICAgICAgKHRhZ05hbWUgPSBzdGF0ZS5odG1sU3RhdGUudGFnTmFtZSAmJiBzdGF0ZS5odG1sU3RhdGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpKSAmJlxuICAgICAgICAgIHRhZ3MuaGFzT3duUHJvcGVydHkodGFnTmFtZSkpIHtcbiAgICAgICAgc3RhdGUuaW5UYWcgPSB0YWdOYW1lICsgXCIgXCJcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUuaW5UYWcgJiYgdGFnICYmIC8+JC8udGVzdChzdHJlYW0uY3VycmVudCgpKSkge1xuICAgICAgICB2YXIgaW5UYWcgPSAvXihbXFxTXSspICguKikvLmV4ZWMoc3RhdGUuaW5UYWcpXG4gICAgICAgIHN0YXRlLmluVGFnID0gbnVsbFxuICAgICAgICB2YXIgbW9kZVNwZWMgPSBzdHJlYW0uY3VycmVudCgpID09IFwiPlwiICYmIGZpbmRNYXRjaGluZ01vZGUodGFnc1tpblRhZ1sxXV0sIGluVGFnWzJdKVxuICAgICAgICB2YXIgbW9kZSA9IENvZGVNaXJyb3IuZ2V0TW9kZShjb25maWcsIG1vZGVTcGVjKVxuICAgICAgICB2YXIgZW5kVGFnQSA9IGdldFRhZ1JlZ2V4cChpblRhZ1sxXSwgdHJ1ZSksIGVuZFRhZyA9IGdldFRhZ1JlZ2V4cChpblRhZ1sxXSwgZmFsc2UpO1xuICAgICAgICBzdGF0ZS50b2tlbiA9IGZ1bmN0aW9uIChzdHJlYW0sIHN0YXRlKSB7XG4gICAgICAgICAgaWYgKHN0cmVhbS5tYXRjaChlbmRUYWdBLCBmYWxzZSkpIHtcbiAgICAgICAgICAgIHN0YXRlLnRva2VuID0gaHRtbDtcbiAgICAgICAgICAgIHN0YXRlLmxvY2FsU3RhdGUgPSBzdGF0ZS5sb2NhbE1vZGUgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBtYXliZUJhY2t1cChzdHJlYW0sIGVuZFRhZywgc3RhdGUubG9jYWxNb2RlLnRva2VuKHN0cmVhbSwgc3RhdGUubG9jYWxTdGF0ZSkpO1xuICAgICAgICB9O1xuICAgICAgICBzdGF0ZS5sb2NhbE1vZGUgPSBtb2RlO1xuICAgICAgICBzdGF0ZS5sb2NhbFN0YXRlID0gQ29kZU1pcnJvci5zdGFydFN0YXRlKG1vZGUsIGh0bWxNb2RlLmluZGVudChzdGF0ZS5odG1sU3RhdGUsIFwiXCIsIFwiXCIpKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUuaW5UYWcpIHtcbiAgICAgICAgc3RhdGUuaW5UYWcgKz0gc3RyZWFtLmN1cnJlbnQoKVxuICAgICAgICBpZiAoc3RyZWFtLmVvbCgpKSBzdGF0ZS5pblRhZyArPSBcIiBcIlxuICAgICAgfVxuICAgICAgcmV0dXJuIHN0eWxlO1xuICAgIH07XG5cbiAgICByZXR1cm4ge1xuICAgICAgc3RhcnRTdGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3RhdGUgPSBDb2RlTWlycm9yLnN0YXJ0U3RhdGUoaHRtbE1vZGUpO1xuICAgICAgICByZXR1cm4ge3Rva2VuOiBodG1sLCBpblRhZzogbnVsbCwgbG9jYWxNb2RlOiBudWxsLCBsb2NhbFN0YXRlOiBudWxsLCBodG1sU3RhdGU6IHN0YXRlfTtcbiAgICAgIH0sXG5cbiAgICAgIGNvcHlTdGF0ZTogZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgIHZhciBsb2NhbDtcbiAgICAgICAgaWYgKHN0YXRlLmxvY2FsU3RhdGUpIHtcbiAgICAgICAgICBsb2NhbCA9IENvZGVNaXJyb3IuY29weVN0YXRlKHN0YXRlLmxvY2FsTW9kZSwgc3RhdGUubG9jYWxTdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHt0b2tlbjogc3RhdGUudG9rZW4sIGluVGFnOiBzdGF0ZS5pblRhZyxcbiAgICAgICAgICAgICAgICBsb2NhbE1vZGU6IHN0YXRlLmxvY2FsTW9kZSwgbG9jYWxTdGF0ZTogbG9jYWwsXG4gICAgICAgICAgICAgICAgaHRtbFN0YXRlOiBDb2RlTWlycm9yLmNvcHlTdGF0ZShodG1sTW9kZSwgc3RhdGUuaHRtbFN0YXRlKX07XG4gICAgICB9LFxuXG4gICAgICB0b2tlbjogZnVuY3Rpb24gKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlLnRva2VuKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgfSxcblxuICAgICAgaW5kZW50OiBmdW5jdGlvbiAoc3RhdGUsIHRleHRBZnRlciwgbGluZSkge1xuICAgICAgICBpZiAoIXN0YXRlLmxvY2FsTW9kZSB8fCAvXlxccyo8XFwvLy50ZXN0KHRleHRBZnRlcikpXG4gICAgICAgICAgcmV0dXJuIGh0bWxNb2RlLmluZGVudChzdGF0ZS5odG1sU3RhdGUsIHRleHRBZnRlciwgbGluZSk7XG4gICAgICAgIGVsc2UgaWYgKHN0YXRlLmxvY2FsTW9kZS5pbmRlbnQpXG4gICAgICAgICAgcmV0dXJuIHN0YXRlLmxvY2FsTW9kZS5pbmRlbnQoc3RhdGUubG9jYWxTdGF0ZSwgdGV4dEFmdGVyLCBsaW5lKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHJldHVybiBDb2RlTWlycm9yLlBhc3M7XG4gICAgICB9LFxuXG4gICAgICBpbm5lck1vZGU6IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICByZXR1cm4ge3N0YXRlOiBzdGF0ZS5sb2NhbFN0YXRlIHx8IHN0YXRlLmh0bWxTdGF0ZSwgbW9kZTogc3RhdGUubG9jYWxNb2RlIHx8IGh0bWxNb2RlfTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBcInhtbFwiLCBcImphdmFzY3JpcHRcIiwgXCJjc3NcIik7XG5cbiAgQ29kZU1pcnJvci5kZWZpbmVNSU1FKFwidGV4dC9odG1sXCIsIFwiaHRtbG1peGVkXCIpO1xufSk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/codemirror/mode/htmlmixed/htmlmixed.js\n");

/***/ }),

/***/ "./node_modules/codemirror/mode/javascript/javascript.js":
/*!***************************************************************!*\
  !*** ./node_modules/codemirror/mode/javascript/javascript.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (true) // CommonJS\n    mod(__webpack_require__(/*! ../../lib/codemirror */ \"./node_modules/codemirror/lib/codemirror.js\"));\n  else {}\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"javascript\", function(config, parserConfig) {\n  var indentUnit = config.indentUnit;\n  var statementIndent = parserConfig.statementIndent;\n  var jsonldMode = parserConfig.jsonld;\n  var jsonMode = parserConfig.json || jsonldMode;\n  var isTS = parserConfig.typescript;\n  var wordRE = parserConfig.wordCharacters || /[\\w$\\xa1-\\uffff]/;\n\n  // Tokenizer\n\n  var keywords = function(){\n    function kw(type) {return {type: type, style: \"keyword\"};}\n    var A = kw(\"keyword a\"), B = kw(\"keyword b\"), C = kw(\"keyword c\"), D = kw(\"keyword d\");\n    var operator = kw(\"operator\"), atom = {type: \"atom\", style: \"atom\"};\n\n    return {\n      \"if\": kw(\"if\"), \"while\": A, \"with\": A, \"else\": B, \"do\": B, \"try\": B, \"finally\": B,\n      \"return\": D, \"break\": D, \"continue\": D, \"new\": kw(\"new\"), \"delete\": C, \"void\": C, \"throw\": C,\n      \"debugger\": kw(\"debugger\"), \"var\": kw(\"var\"), \"const\": kw(\"var\"), \"let\": kw(\"var\"),\n      \"function\": kw(\"function\"), \"catch\": kw(\"catch\"),\n      \"for\": kw(\"for\"), \"switch\": kw(\"switch\"), \"case\": kw(\"case\"), \"default\": kw(\"default\"),\n      \"in\": operator, \"typeof\": operator, \"instanceof\": operator,\n      \"true\": atom, \"false\": atom, \"null\": atom, \"undefined\": atom, \"NaN\": atom, \"Infinity\": atom,\n      \"this\": kw(\"this\"), \"class\": kw(\"class\"), \"super\": kw(\"atom\"),\n      \"yield\": C, \"export\": kw(\"export\"), \"import\": kw(\"import\"), \"extends\": C,\n      \"await\": C\n    };\n  }();\n\n  var isOperatorChar = /[+\\-*&%=<>!?|~^@]/;\n  var isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)\"/;\n\n  function readRegexp(stream) {\n    var escaped = false, next, inSet = false;\n    while ((next = stream.next()) != null) {\n      if (!escaped) {\n        if (next == \"/\" && !inSet) return;\n        if (next == \"[\") inSet = true;\n        else if (inSet && next == \"]\") inSet = false;\n      }\n      escaped = !escaped && next == \"\\\\\";\n    }\n  }\n\n  // Used as scratch variables to communicate multiple values without\n  // consing up tons of objects.\n  var type, content;\n  function ret(tp, style, cont) {\n    type = tp; content = cont;\n    return style;\n  }\n  function tokenBase(stream, state) {\n    var ch = stream.next();\n    if (ch == '\"' || ch == \"'\") {\n      state.tokenize = tokenString(ch);\n      return state.tokenize(stream, state);\n    } else if (ch == \".\" && stream.match(/^\\d[\\d_]*(?:[eE][+\\-]?[\\d_]+)?/)) {\n      return ret(\"number\", \"number\");\n    } else if (ch == \".\" && stream.match(\"..\")) {\n      return ret(\"spread\", \"meta\");\n    } else if (/[\\[\\]{}\\(\\),;\\:\\.]/.test(ch)) {\n      return ret(ch);\n    } else if (ch == \"=\" && stream.eat(\">\")) {\n      return ret(\"=>\", \"operator\");\n    } else if (ch == \"0\" && stream.match(/^(?:x[\\dA-Fa-f_]+|o[0-7_]+|b[01_]+)n?/)) {\n      return ret(\"number\", \"number\");\n    } else if (/\\d/.test(ch)) {\n      stream.match(/^[\\d_]*(?:n|(?:\\.[\\d_]*)?(?:[eE][+\\-]?[\\d_]+)?)?/);\n      return ret(\"number\", \"number\");\n    } else if (ch == \"/\") {\n      if (stream.eat(\"*\")) {\n        state.tokenize = tokenComment;\n        return tokenComment(stream, state);\n      } else if (stream.eat(\"/\")) {\n        stream.skipToEnd();\n        return ret(\"comment\", \"comment\");\n      } else if (expressionAllowed(stream, state, 1)) {\n        readRegexp(stream);\n        stream.match(/^\\b(([gimyus])(?![gimyus]*\\2))+\\b/);\n        return ret(\"regexp\", \"string-2\");\n      } else {\n        stream.eat(\"=\");\n        return ret(\"operator\", \"operator\", stream.current());\n      }\n    } else if (ch == \"`\") {\n      state.tokenize = tokenQuasi;\n      return tokenQuasi(stream, state);\n    } else if (ch == \"#\" && stream.peek() == \"!\") {\n      stream.skipToEnd();\n      return ret(\"meta\", \"meta\");\n    } else if (ch == \"#\" && stream.eatWhile(wordRE)) {\n      return ret(\"variable\", \"property\")\n    } else if (ch == \"<\" && stream.match(\"!--\") ||\n               (ch == \"-\" && stream.match(\"->\") && !/\\S/.test(stream.string.slice(0, stream.start)))) {\n      stream.skipToEnd()\n      return ret(\"comment\", \"comment\")\n    } else if (isOperatorChar.test(ch)) {\n      if (ch != \">\" || !state.lexical || state.lexical.type != \">\") {\n        if (stream.eat(\"=\")) {\n          if (ch == \"!\" || ch == \"=\") stream.eat(\"=\")\n        } else if (/[<>*+\\-|&?]/.test(ch)) {\n          stream.eat(ch)\n          if (ch == \">\") stream.eat(ch)\n        }\n      }\n      if (ch == \"?\" && stream.eat(\".\")) return ret(\".\")\n      return ret(\"operator\", \"operator\", stream.current());\n    } else if (wordRE.test(ch)) {\n      stream.eatWhile(wordRE);\n      var word = stream.current()\n      if (state.lastType != \".\") {\n        if (keywords.propertyIsEnumerable(word)) {\n          var kw = keywords[word]\n          return ret(kw.type, kw.style, word)\n        }\n        if (word == \"async\" && stream.match(/^(\\s|\\/\\*([^*]|\\*(?!\\/))*?\\*\\/)*[\\[\\(\\w]/, false))\n          return ret(\"async\", \"keyword\", word)\n      }\n      return ret(\"variable\", \"variable\", word)\n    }\n  }\n\n  function tokenString(quote) {\n    return function(stream, state) {\n      var escaped = false, next;\n      if (jsonldMode && stream.peek() == \"@\" && stream.match(isJsonldKeyword)){\n        state.tokenize = tokenBase;\n        return ret(\"jsonld-keyword\", \"meta\");\n      }\n      while ((next = stream.next()) != null) {\n        if (next == quote && !escaped) break;\n        escaped = !escaped && next == \"\\\\\";\n      }\n      if (!escaped) state.tokenize = tokenBase;\n      return ret(\"string\", \"string\");\n    };\n  }\n\n  function tokenComment(stream, state) {\n    var maybeEnd = false, ch;\n    while (ch = stream.next()) {\n      if (ch == \"/\" && maybeEnd) {\n        state.tokenize = tokenBase;\n        break;\n      }\n      maybeEnd = (ch == \"*\");\n    }\n    return ret(\"comment\", \"comment\");\n  }\n\n  function tokenQuasi(stream, state) {\n    var escaped = false, next;\n    while ((next = stream.next()) != null) {\n      if (!escaped && (next == \"`\" || next == \"$\" && stream.eat(\"{\"))) {\n        state.tokenize = tokenBase;\n        break;\n      }\n      escaped = !escaped && next == \"\\\\\";\n    }\n    return ret(\"quasi\", \"string-2\", stream.current());\n  }\n\n  var brackets = \"([{}])\";\n  // This is a crude lookahead trick to try and notice that we're\n  // parsing the argument patterns for a fat-arrow function before we\n  // actually hit the arrow token. It only works if the arrow is on\n  // the same line as the arguments and there's no strange noise\n  // (comments) in between. Fallback is to only notice when we hit the\n  // arrow, and not declare the arguments as locals for the arrow\n  // body.\n  function findFatArrow(stream, state) {\n    if (state.fatArrowAt) state.fatArrowAt = null;\n    var arrow = stream.string.indexOf(\"=>\", stream.start);\n    if (arrow < 0) return;\n\n    if (isTS) { // Try to skip TypeScript return type declarations after the arguments\n      var m = /:\\s*(?:\\w+(?:<[^>]*>|\\[\\])?|\\{[^}]*\\})\\s*$/.exec(stream.string.slice(stream.start, arrow))\n      if (m) arrow = m.index\n    }\n\n    var depth = 0, sawSomething = false;\n    for (var pos = arrow - 1; pos >= 0; --pos) {\n      var ch = stream.string.charAt(pos);\n      var bracket = brackets.indexOf(ch);\n      if (bracket >= 0 && bracket < 3) {\n        if (!depth) { ++pos; break; }\n        if (--depth == 0) { if (ch == \"(\") sawSomething = true; break; }\n      } else if (bracket >= 3 && bracket < 6) {\n        ++depth;\n      } else if (wordRE.test(ch)) {\n        sawSomething = true;\n      } else if (/[\"'\\/`]/.test(ch)) {\n        for (;; --pos) {\n          if (pos == 0) return\n          var next = stream.string.charAt(pos - 1)\n          if (next == ch && stream.string.charAt(pos - 2) != \"\\\\\") { pos--; break }\n        }\n      } else if (sawSomething && !depth) {\n        ++pos;\n        break;\n      }\n    }\n    if (sawSomething && !depth) state.fatArrowAt = pos;\n  }\n\n  // Parser\n\n  var atomicTypes = {\"atom\": true, \"number\": true, \"variable\": true, \"string\": true, \"regexp\": true, \"this\": true, \"jsonld-keyword\": true};\n\n  function JSLexical(indented, column, type, align, prev, info) {\n    this.indented = indented;\n    this.column = column;\n    this.type = type;\n    this.prev = prev;\n    this.info = info;\n    if (align != null) this.align = align;\n  }\n\n  function inScope(state, varname) {\n    for (var v = state.localVars; v; v = v.next)\n      if (v.name == varname) return true;\n    for (var cx = state.context; cx; cx = cx.prev) {\n      for (var v = cx.vars; v; v = v.next)\n        if (v.name == varname) return true;\n    }\n  }\n\n  function parseJS(state, style, type, content, stream) {\n    var cc = state.cc;\n    // Communicate our context to the combinators.\n    // (Less wasteful than consing up a hundred closures on every call.)\n    cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc; cx.style = style;\n\n    if (!state.lexical.hasOwnProperty(\"align\"))\n      state.lexical.align = true;\n\n    while(true) {\n      var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;\n      if (combinator(type, content)) {\n        while(cc.length && cc[cc.length - 1].lex)\n          cc.pop()();\n        if (cx.marked) return cx.marked;\n        if (type == \"variable\" && inScope(state, content)) return \"variable-2\";\n        return style;\n      }\n    }\n  }\n\n  // Combinator utils\n\n  var cx = {state: null, column: null, marked: null, cc: null};\n  function pass() {\n    for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);\n  }\n  function cont() {\n    pass.apply(null, arguments);\n    return true;\n  }\n  function inList(name, list) {\n    for (var v = list; v; v = v.next) if (v.name == name) return true\n    return false;\n  }\n  function register(varname) {\n    var state = cx.state;\n    cx.marked = \"def\";\n    if (state.context) {\n      if (state.lexical.info == \"var\" && state.context && state.context.block) {\n        // FIXME function decls are also not block scoped\n        var newContext = registerVarScoped(varname, state.context)\n        if (newContext != null) {\n          state.context = newContext\n          return\n        }\n      } else if (!inList(varname, state.localVars)) {\n        state.localVars = new Var(varname, state.localVars)\n        return\n      }\n    }\n    // Fall through means this is global\n    if (parserConfig.globalVars && !inList(varname, state.globalVars))\n      state.globalVars = new Var(varname, state.globalVars)\n  }\n  function registerVarScoped(varname, context) {\n    if (!context) {\n      return null\n    } else if (context.block) {\n      var inner = registerVarScoped(varname, context.prev)\n      if (!inner) return null\n      if (inner == context.prev) return context\n      return new Context(inner, context.vars, true)\n    } else if (inList(varname, context.vars)) {\n      return context\n    } else {\n      return new Context(context.prev, new Var(varname, context.vars), false)\n    }\n  }\n\n  function isModifier(name) {\n    return name == \"public\" || name == \"private\" || name == \"protected\" || name == \"abstract\" || name == \"readonly\"\n  }\n\n  // Combinators\n\n  function Context(prev, vars, block) { this.prev = prev; this.vars = vars; this.block = block }\n  function Var(name, next) { this.name = name; this.next = next }\n\n  var defaultVars = new Var(\"this\", new Var(\"arguments\", null))\n  function pushcontext() {\n    cx.state.context = new Context(cx.state.context, cx.state.localVars, false)\n    cx.state.localVars = defaultVars\n  }\n  function pushblockcontext() {\n    cx.state.context = new Context(cx.state.context, cx.state.localVars, true)\n    cx.state.localVars = null\n  }\n  function popcontext() {\n    cx.state.localVars = cx.state.context.vars\n    cx.state.context = cx.state.context.prev\n  }\n  popcontext.lex = true\n  function pushlex(type, info) {\n    var result = function() {\n      var state = cx.state, indent = state.indented;\n      if (state.lexical.type == \"stat\") indent = state.lexical.indented;\n      else for (var outer = state.lexical; outer && outer.type == \")\" && outer.align; outer = outer.prev)\n        indent = outer.indented;\n      state.lexical = new JSLexical(indent, cx.stream.column(), type, null, state.lexical, info);\n    };\n    result.lex = true;\n    return result;\n  }\n  function poplex() {\n    var state = cx.state;\n    if (state.lexical.prev) {\n      if (state.lexical.type == \")\")\n        state.indented = state.lexical.indented;\n      state.lexical = state.lexical.prev;\n    }\n  }\n  poplex.lex = true;\n\n  function expect(wanted) {\n    function exp(type) {\n      if (type == wanted) return cont();\n      else if (wanted == \";\" || type == \"}\" || type == \")\" || type == \"]\") return pass();\n      else return cont(exp);\n    };\n    return exp;\n  }\n\n  function statement(type, value) {\n    if (type == \"var\") return cont(pushlex(\"vardef\", value), vardef, expect(\";\"), poplex);\n    if (type == \"keyword a\") return cont(pushlex(\"form\"), parenExpr, statement, poplex);\n    if (type == \"keyword b\") return cont(pushlex(\"form\"), statement, poplex);\n    if (type == \"keyword d\") return cx.stream.match(/^\\s*$/, false) ? cont() : cont(pushlex(\"stat\"), maybeexpression, expect(\";\"), poplex);\n    if (type == \"debugger\") return cont(expect(\";\"));\n    if (type == \"{\") return cont(pushlex(\"}\"), pushblockcontext, block, poplex, popcontext);\n    if (type == \";\") return cont();\n    if (type == \"if\") {\n      if (cx.state.lexical.info == \"else\" && cx.state.cc[cx.state.cc.length - 1] == poplex)\n        cx.state.cc.pop()();\n      return cont(pushlex(\"form\"), parenExpr, statement, poplex, maybeelse);\n    }\n    if (type == \"function\") return cont(functiondef);\n    if (type == \"for\") return cont(pushlex(\"form\"), forspec, statement, poplex);\n    if (type == \"class\" || (isTS && value == \"interface\")) {\n      cx.marked = \"keyword\"\n      return cont(pushlex(\"form\", type == \"class\" ? type : value), className, poplex)\n    }\n    if (type == \"variable\") {\n      if (isTS && value == \"declare\") {\n        cx.marked = \"keyword\"\n        return cont(statement)\n      } else if (isTS && (value == \"module\" || value == \"enum\" || value == \"type\") && cx.stream.match(/^\\s*\\w/, false)) {\n        cx.marked = \"keyword\"\n        if (value == \"enum\") return cont(enumdef);\n        else if (value == \"type\") return cont(typename, expect(\"operator\"), typeexpr, expect(\";\"));\n        else return cont(pushlex(\"form\"), pattern, expect(\"{\"), pushlex(\"}\"), block, poplex, poplex)\n      } else if (isTS && value == \"namespace\") {\n        cx.marked = \"keyword\"\n        return cont(pushlex(\"form\"), expression, statement, poplex)\n      } else if (isTS && value == \"abstract\") {\n        cx.marked = \"keyword\"\n        return cont(statement)\n      } else {\n        return cont(pushlex(\"stat\"), maybelabel);\n      }\n    }\n    if (type == \"switch\") return cont(pushlex(\"form\"), parenExpr, expect(\"{\"), pushlex(\"}\", \"switch\"), pushblockcontext,\n                                      block, poplex, poplex, popcontext);\n    if (type == \"case\") return cont(expression, expect(\":\"));\n    if (type == \"default\") return cont(expect(\":\"));\n    if (type == \"catch\") return cont(pushlex(\"form\"), pushcontext, maybeCatchBinding, statement, poplex, popcontext);\n    if (type == \"export\") return cont(pushlex(\"stat\"), afterExport, poplex);\n    if (type == \"import\") return cont(pushlex(\"stat\"), afterImport, poplex);\n    if (type == \"async\") return cont(statement)\n    if (value == \"@\") return cont(expression, statement)\n    return pass(pushlex(\"stat\"), expression, expect(\";\"), poplex);\n  }\n  function maybeCatchBinding(type) {\n    if (type == \"(\") return cont(funarg, expect(\")\"))\n  }\n  function expression(type, value) {\n    return expressionInner(type, value, false);\n  }\n  function expressionNoComma(type, value) {\n    return expressionInner(type, value, true);\n  }\n  function parenExpr(type) {\n    if (type != \"(\") return pass()\n    return cont(pushlex(\")\"), maybeexpression, expect(\")\"), poplex)\n  }\n  function expressionInner(type, value, noComma) {\n    if (cx.state.fatArrowAt == cx.stream.start) {\n      var body = noComma ? arrowBodyNoComma : arrowBody;\n      if (type == \"(\") return cont(pushcontext, pushlex(\")\"), commasep(funarg, \")\"), poplex, expect(\"=>\"), body, popcontext);\n      else if (type == \"variable\") return pass(pushcontext, pattern, expect(\"=>\"), body, popcontext);\n    }\n\n    var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;\n    if (atomicTypes.hasOwnProperty(type)) return cont(maybeop);\n    if (type == \"function\") return cont(functiondef, maybeop);\n    if (type == \"class\" || (isTS && value == \"interface\")) { cx.marked = \"keyword\"; return cont(pushlex(\"form\"), classExpression, poplex); }\n    if (type == \"keyword c\" || type == \"async\") return cont(noComma ? expressionNoComma : expression);\n    if (type == \"(\") return cont(pushlex(\")\"), maybeexpression, expect(\")\"), poplex, maybeop);\n    if (type == \"operator\" || type == \"spread\") return cont(noComma ? expressionNoComma : expression);\n    if (type == \"[\") return cont(pushlex(\"]\"), arrayLiteral, poplex, maybeop);\n    if (type == \"{\") return contCommasep(objprop, \"}\", null, maybeop);\n    if (type == \"quasi\") return pass(quasi, maybeop);\n    if (type == \"new\") return cont(maybeTarget(noComma));\n    if (type == \"import\") return cont(expression);\n    return cont();\n  }\n  function maybeexpression(type) {\n    if (type.match(/[;\\}\\)\\],]/)) return pass();\n    return pass(expression);\n  }\n\n  function maybeoperatorComma(type, value) {\n    if (type == \",\") return cont(maybeexpression);\n    return maybeoperatorNoComma(type, value, false);\n  }\n  function maybeoperatorNoComma(type, value, noComma) {\n    var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;\n    var expr = noComma == false ? expression : expressionNoComma;\n    if (type == \"=>\") return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);\n    if (type == \"operator\") {\n      if (/\\+\\+|--/.test(value) || isTS && value == \"!\") return cont(me);\n      if (isTS && value == \"<\" && cx.stream.match(/^([^<>]|<[^<>]*>)*>\\s*\\(/, false))\n        return cont(pushlex(\">\"), commasep(typeexpr, \">\"), poplex, me);\n      if (value == \"?\") return cont(expression, expect(\":\"), expr);\n      return cont(expr);\n    }\n    if (type == \"quasi\") { return pass(quasi, me); }\n    if (type == \";\") return;\n    if (type == \"(\") return contCommasep(expressionNoComma, \")\", \"call\", me);\n    if (type == \".\") return cont(property, me);\n    if (type == \"[\") return cont(pushlex(\"]\"), maybeexpression, expect(\"]\"), poplex, me);\n    if (isTS && value == \"as\") { cx.marked = \"keyword\"; return cont(typeexpr, me) }\n    if (type == \"regexp\") {\n      cx.state.lastType = cx.marked = \"operator\"\n      cx.stream.backUp(cx.stream.pos - cx.stream.start - 1)\n      return cont(expr)\n    }\n  }\n  function quasi(type, value) {\n    if (type != \"quasi\") return pass();\n    if (value.slice(value.length - 2) != \"${\") return cont(quasi);\n    return cont(expression, continueQuasi);\n  }\n  function continueQuasi(type) {\n    if (type == \"}\") {\n      cx.marked = \"string-2\";\n      cx.state.tokenize = tokenQuasi;\n      return cont(quasi);\n    }\n  }\n  function arrowBody(type) {\n    findFatArrow(cx.stream, cx.state);\n    return pass(type == \"{\" ? statement : expression);\n  }\n  function arrowBodyNoComma(type) {\n    findFatArrow(cx.stream, cx.state);\n    return pass(type == \"{\" ? statement : expressionNoComma);\n  }\n  function maybeTarget(noComma) {\n    return function(type) {\n      if (type == \".\") return cont(noComma ? targetNoComma : target);\n      else if (type == \"variable\" && isTS) return cont(maybeTypeArgs, noComma ? maybeoperatorNoComma : maybeoperatorComma)\n      else return pass(noComma ? expressionNoComma : expression);\n    };\n  }\n  function target(_, value) {\n    if (value == \"target\") { cx.marked = \"keyword\"; return cont(maybeoperatorComma); }\n  }\n  function targetNoComma(_, value) {\n    if (value == \"target\") { cx.marked = \"keyword\"; return cont(maybeoperatorNoComma); }\n  }\n  function maybelabel(type) {\n    if (type == \":\") return cont(poplex, statement);\n    return pass(maybeoperatorComma, expect(\";\"), poplex);\n  }\n  function property(type) {\n    if (type == \"variable\") {cx.marked = \"property\"; return cont();}\n  }\n  function objprop(type, value) {\n    if (type == \"async\") {\n      cx.marked = \"property\";\n      return cont(objprop);\n    } else if (type == \"variable\" || cx.style == \"keyword\") {\n      cx.marked = \"property\";\n      if (value == \"get\" || value == \"set\") return cont(getterSetter);\n      var m // Work around fat-arrow-detection complication for detecting typescript typed arrow params\n      if (isTS && cx.state.fatArrowAt == cx.stream.start && (m = cx.stream.match(/^\\s*:\\s*/, false)))\n        cx.state.fatArrowAt = cx.stream.pos + m[0].length\n      return cont(afterprop);\n    } else if (type == \"number\" || type == \"string\") {\n      cx.marked = jsonldMode ? \"property\" : (cx.style + \" property\");\n      return cont(afterprop);\n    } else if (type == \"jsonld-keyword\") {\n      return cont(afterprop);\n    } else if (isTS && isModifier(value)) {\n      cx.marked = \"keyword\"\n      return cont(objprop)\n    } else if (type == \"[\") {\n      return cont(expression, maybetype, expect(\"]\"), afterprop);\n    } else if (type == \"spread\") {\n      return cont(expressionNoComma, afterprop);\n    } else if (value == \"*\") {\n      cx.marked = \"keyword\";\n      return cont(objprop);\n    } else if (type == \":\") {\n      return pass(afterprop)\n    }\n  }\n  function getterSetter(type) {\n    if (type != \"variable\") return pass(afterprop);\n    cx.marked = \"property\";\n    return cont(functiondef);\n  }\n  function afterprop(type) {\n    if (type == \":\") return cont(expressionNoComma);\n    if (type == \"(\") return pass(functiondef);\n  }\n  function commasep(what, end, sep) {\n    function proceed(type, value) {\n      if (sep ? sep.indexOf(type) > -1 : type == \",\") {\n        var lex = cx.state.lexical;\n        if (lex.info == \"call\") lex.pos = (lex.pos || 0) + 1;\n        return cont(function(type, value) {\n          if (type == end || value == end) return pass()\n          return pass(what)\n        }, proceed);\n      }\n      if (type == end || value == end) return cont();\n      if (sep && sep.indexOf(\";\") > -1) return pass(what)\n      return cont(expect(end));\n    }\n    return function(type, value) {\n      if (type == end || value == end) return cont();\n      return pass(what, proceed);\n    };\n  }\n  function contCommasep(what, end, info) {\n    for (var i = 3; i < arguments.length; i++)\n      cx.cc.push(arguments[i]);\n    return cont(pushlex(end, info), commasep(what, end), poplex);\n  }\n  function block(type) {\n    if (type == \"}\") return cont();\n    return pass(statement, block);\n  }\n  function maybetype(type, value) {\n    if (isTS) {\n      if (type == \":\") return cont(typeexpr);\n      if (value == \"?\") return cont(maybetype);\n    }\n  }\n  function maybetypeOrIn(type, value) {\n    if (isTS && (type == \":\" || value == \"in\")) return cont(typeexpr)\n  }\n  function mayberettype(type) {\n    if (isTS && type == \":\") {\n      if (cx.stream.match(/^\\s*\\w+\\s+is\\b/, false)) return cont(expression, isKW, typeexpr)\n      else return cont(typeexpr)\n    }\n  }\n  function isKW(_, value) {\n    if (value == \"is\") {\n      cx.marked = \"keyword\"\n      return cont()\n    }\n  }\n  function typeexpr(type, value) {\n    if (value == \"keyof\" || value == \"typeof\" || value == \"infer\") {\n      cx.marked = \"keyword\"\n      return cont(value == \"typeof\" ? expressionNoComma : typeexpr)\n    }\n    if (type == \"variable\" || value == \"void\") {\n      cx.marked = \"type\"\n      return cont(afterType)\n    }\n    if (value == \"|\" || value == \"&\") return cont(typeexpr)\n    if (type == \"string\" || type == \"number\" || type == \"atom\") return cont(afterType);\n    if (type == \"[\") return cont(pushlex(\"]\"), commasep(typeexpr, \"]\", \",\"), poplex, afterType)\n    if (type == \"{\") return cont(pushlex(\"}\"), typeprops, poplex, afterType)\n    if (type == \"(\") return cont(commasep(typearg, \")\"), maybeReturnType, afterType)\n    if (type == \"<\") return cont(commasep(typeexpr, \">\"), typeexpr)\n  }\n  function maybeReturnType(type) {\n    if (type == \"=>\") return cont(typeexpr)\n  }\n  function typeprops(type) {\n    if (type == \"}\") return cont()\n    if (type == \",\" || type == \";\") return cont(typeprops)\n    return pass(typeprop, typeprops)\n  }\n  function typeprop(type, value) {\n    if (type == \"variable\" || cx.style == \"keyword\") {\n      cx.marked = \"property\"\n      return cont(typeprop)\n    } else if (value == \"?\" || type == \"number\" || type == \"string\") {\n      return cont(typeprop)\n    } else if (type == \":\") {\n      return cont(typeexpr)\n    } else if (type == \"[\") {\n      return cont(expect(\"variable\"), maybetypeOrIn, expect(\"]\"), typeprop)\n    } else if (type == \"(\") {\n      return pass(functiondecl, typeprop)\n    }\n  }\n  function typearg(type, value) {\n    if (type == \"variable\" && cx.stream.match(/^\\s*[?:]/, false) || value == \"?\") return cont(typearg)\n    if (type == \":\") return cont(typeexpr)\n    if (type == \"spread\") return cont(typearg)\n    return pass(typeexpr)\n  }\n  function afterType(type, value) {\n    if (value == \"<\") return cont(pushlex(\">\"), commasep(typeexpr, \">\"), poplex, afterType)\n    if (value == \"|\" || type == \".\" || value == \"&\") return cont(typeexpr)\n    if (type == \"[\") return cont(typeexpr, expect(\"]\"), afterType)\n    if (value == \"extends\" || value == \"implements\") { cx.marked = \"keyword\"; return cont(typeexpr) }\n    if (value == \"?\") return cont(typeexpr, expect(\":\"), typeexpr)\n  }\n  function maybeTypeArgs(_, value) {\n    if (value == \"<\") return cont(pushlex(\">\"), commasep(typeexpr, \">\"), poplex, afterType)\n  }\n  function typeparam() {\n    return pass(typeexpr, maybeTypeDefault)\n  }\n  function maybeTypeDefault(_, value) {\n    if (value == \"=\") return cont(typeexpr)\n  }\n  function vardef(_, value) {\n    if (value == \"enum\") {cx.marked = \"keyword\"; return cont(enumdef)}\n    return pass(pattern, maybetype, maybeAssign, vardefCont);\n  }\n  function pattern(type, value) {\n    if (isTS && isModifier(value)) { cx.marked = \"keyword\"; return cont(pattern) }\n    if (type == \"variable\") { register(value); return cont(); }\n    if (type == \"spread\") return cont(pattern);\n    if (type == \"[\") return contCommasep(eltpattern, \"]\");\n    if (type == \"{\") return contCommasep(proppattern, \"}\");\n  }\n  function proppattern(type, value) {\n    if (type == \"variable\" && !cx.stream.match(/^\\s*:/, false)) {\n      register(value);\n      return cont(maybeAssign);\n    }\n    if (type == \"variable\") cx.marked = \"property\";\n    if (type == \"spread\") return cont(pattern);\n    if (type == \"}\") return pass();\n    if (type == \"[\") return cont(expression, expect(']'), expect(':'), proppattern);\n    return cont(expect(\":\"), pattern, maybeAssign);\n  }\n  function eltpattern() {\n    return pass(pattern, maybeAssign)\n  }\n  function maybeAssign(_type, value) {\n    if (value == \"=\") return cont(expressionNoComma);\n  }\n  function vardefCont(type) {\n    if (type == \",\") return cont(vardef);\n  }\n  function maybeelse(type, value) {\n    if (type == \"keyword b\" && value == \"else\") return cont(pushlex(\"form\", \"else\"), statement, poplex);\n  }\n  function forspec(type, value) {\n    if (value == \"await\") return cont(forspec);\n    if (type == \"(\") return cont(pushlex(\")\"), forspec1, poplex);\n  }\n  function forspec1(type) {\n    if (type == \"var\") return cont(vardef, forspec2);\n    if (type == \"variable\") return cont(forspec2);\n    return pass(forspec2)\n  }\n  function forspec2(type, value) {\n    if (type == \")\") return cont()\n    if (type == \";\") return cont(forspec2)\n    if (value == \"in\" || value == \"of\") { cx.marked = \"keyword\"; return cont(expression, forspec2) }\n    return pass(expression, forspec2)\n  }\n  function functiondef(type, value) {\n    if (value == \"*\") {cx.marked = \"keyword\"; return cont(functiondef);}\n    if (type == \"variable\") {register(value); return cont(functiondef);}\n    if (type == \"(\") return cont(pushcontext, pushlex(\")\"), commasep(funarg, \")\"), poplex, mayberettype, statement, popcontext);\n    if (isTS && value == \"<\") return cont(pushlex(\">\"), commasep(typeparam, \">\"), poplex, functiondef)\n  }\n  function functiondecl(type, value) {\n    if (value == \"*\") {cx.marked = \"keyword\"; return cont(functiondecl);}\n    if (type == \"variable\") {register(value); return cont(functiondecl);}\n    if (type == \"(\") return cont(pushcontext, pushlex(\")\"), commasep(funarg, \")\"), poplex, mayberettype, popcontext);\n    if (isTS && value == \"<\") return cont(pushlex(\">\"), commasep(typeparam, \">\"), poplex, functiondecl)\n  }\n  function typename(type, value) {\n    if (type == \"keyword\" || type == \"variable\") {\n      cx.marked = \"type\"\n      return cont(typename)\n    } else if (value == \"<\") {\n      return cont(pushlex(\">\"), commasep(typeparam, \">\"), poplex)\n    }\n  }\n  function funarg(type, value) {\n    if (value == \"@\") cont(expression, funarg)\n    if (type == \"spread\") return cont(funarg);\n    if (isTS && isModifier(value)) { cx.marked = \"keyword\"; return cont(funarg); }\n    if (isTS && type == \"this\") return cont(maybetype, maybeAssign)\n    return pass(pattern, maybetype, maybeAssign);\n  }\n  function classExpression(type, value) {\n    // Class expressions may have an optional name.\n    if (type == \"variable\") return className(type, value);\n    return classNameAfter(type, value);\n  }\n  function className(type, value) {\n    if (type == \"variable\") {register(value); return cont(classNameAfter);}\n  }\n  function classNameAfter(type, value) {\n    if (value == \"<\") return cont(pushlex(\">\"), commasep(typeparam, \">\"), poplex, classNameAfter)\n    if (value == \"extends\" || value == \"implements\" || (isTS && type == \",\")) {\n      if (value == \"implements\") cx.marked = \"keyword\";\n      return cont(isTS ? typeexpr : expression, classNameAfter);\n    }\n    if (type == \"{\") return cont(pushlex(\"}\"), classBody, poplex);\n  }\n  function classBody(type, value) {\n    if (type == \"async\" ||\n        (type == \"variable\" &&\n         (value == \"static\" || value == \"get\" || value == \"set\" || (isTS && isModifier(value))) &&\n         cx.stream.match(/^\\s+[\\w$\\xa1-\\uffff]/, false))) {\n      cx.marked = \"keyword\";\n      return cont(classBody);\n    }\n    if (type == \"variable\" || cx.style == \"keyword\") {\n      cx.marked = \"property\";\n      return cont(classfield, classBody);\n    }\n    if (type == \"number\" || type == \"string\") return cont(classfield, classBody);\n    if (type == \"[\")\n      return cont(expression, maybetype, expect(\"]\"), classfield, classBody)\n    if (value == \"*\") {\n      cx.marked = \"keyword\";\n      return cont(classBody);\n    }\n    if (isTS && type == \"(\") return pass(functiondecl, classBody)\n    if (type == \";\" || type == \",\") return cont(classBody);\n    if (type == \"}\") return cont();\n    if (value == \"@\") return cont(expression, classBody)\n  }\n  function classfield(type, value) {\n    if (value == \"?\") return cont(classfield)\n    if (type == \":\") return cont(typeexpr, maybeAssign)\n    if (value == \"=\") return cont(expressionNoComma)\n    var context = cx.state.lexical.prev, isInterface = context && context.info == \"interface\"\n    return pass(isInterface ? functiondecl : functiondef)\n  }\n  function afterExport(type, value) {\n    if (value == \"*\") { cx.marked = \"keyword\"; return cont(maybeFrom, expect(\";\")); }\n    if (value == \"default\") { cx.marked = \"keyword\"; return cont(expression, expect(\";\")); }\n    if (type == \"{\") return cont(commasep(exportField, \"}\"), maybeFrom, expect(\";\"));\n    return pass(statement);\n  }\n  function exportField(type, value) {\n    if (value == \"as\") { cx.marked = \"keyword\"; return cont(expect(\"variable\")); }\n    if (type == \"variable\") return pass(expressionNoComma, exportField);\n  }\n  function afterImport(type) {\n    if (type == \"string\") return cont();\n    if (type == \"(\") return pass(expression);\n    return pass(importSpec, maybeMoreImports, maybeFrom);\n  }\n  function importSpec(type, value) {\n    if (type == \"{\") return contCommasep(importSpec, \"}\");\n    if (type == \"variable\") register(value);\n    if (value == \"*\") cx.marked = \"keyword\";\n    return cont(maybeAs);\n  }\n  function maybeMoreImports(type) {\n    if (type == \",\") return cont(importSpec, maybeMoreImports)\n  }\n  function maybeAs(_type, value) {\n    if (value == \"as\") { cx.marked = \"keyword\"; return cont(importSpec); }\n  }\n  function maybeFrom(_type, value) {\n    if (value == \"from\") { cx.marked = \"keyword\"; return cont(expression); }\n  }\n  function arrayLiteral(type) {\n    if (type == \"]\") return cont();\n    return pass(commasep(expressionNoComma, \"]\"));\n  }\n  function enumdef() {\n    return pass(pushlex(\"form\"), pattern, expect(\"{\"), pushlex(\"}\"), commasep(enummember, \"}\"), poplex, poplex)\n  }\n  function enummember() {\n    return pass(pattern, maybeAssign);\n  }\n\n  function isContinuedStatement(state, textAfter) {\n    return state.lastType == \"operator\" || state.lastType == \",\" ||\n      isOperatorChar.test(textAfter.charAt(0)) ||\n      /[,.]/.test(textAfter.charAt(0));\n  }\n\n  function expressionAllowed(stream, state, backUp) {\n    return state.tokenize == tokenBase &&\n      /^(?:operator|sof|keyword [bcd]|case|new|export|default|spread|[\\[{}\\(,;:]|=>)$/.test(state.lastType) ||\n      (state.lastType == \"quasi\" && /\\{\\s*$/.test(stream.string.slice(0, stream.pos - (backUp || 0))))\n  }\n\n  // Interface\n\n  return {\n    startState: function(basecolumn) {\n      var state = {\n        tokenize: tokenBase,\n        lastType: \"sof\",\n        cc: [],\n        lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, \"block\", false),\n        localVars: parserConfig.localVars,\n        context: parserConfig.localVars && new Context(null, null, false),\n        indented: basecolumn || 0\n      };\n      if (parserConfig.globalVars && typeof parserConfig.globalVars == \"object\")\n        state.globalVars = parserConfig.globalVars;\n      return state;\n    },\n\n    token: function(stream, state) {\n      if (stream.sol()) {\n        if (!state.lexical.hasOwnProperty(\"align\"))\n          state.lexical.align = false;\n        state.indented = stream.indentation();\n        findFatArrow(stream, state);\n      }\n      if (state.tokenize != tokenComment && stream.eatSpace()) return null;\n      var style = state.tokenize(stream, state);\n      if (type == \"comment\") return style;\n      state.lastType = type == \"operator\" && (content == \"++\" || content == \"--\") ? \"incdec\" : type;\n      return parseJS(state, style, type, content, stream);\n    },\n\n    indent: function(state, textAfter) {\n      if (state.tokenize == tokenComment || state.tokenize == tokenQuasi) return CodeMirror.Pass;\n      if (state.tokenize != tokenBase) return 0;\n      var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical, top\n      // Kludge to prevent 'maybelse' from blocking lexical scope pops\n      if (!/^\\s*else\\b/.test(textAfter)) for (var i = state.cc.length - 1; i >= 0; --i) {\n        var c = state.cc[i];\n        if (c == poplex) lexical = lexical.prev;\n        else if (c != maybeelse) break;\n      }\n      while ((lexical.type == \"stat\" || lexical.type == \"form\") &&\n             (firstChar == \"}\" || ((top = state.cc[state.cc.length - 1]) &&\n                                   (top == maybeoperatorComma || top == maybeoperatorNoComma) &&\n                                   !/^[,\\.=+\\-*:?[\\(]/.test(textAfter))))\n        lexical = lexical.prev;\n      if (statementIndent && lexical.type == \")\" && lexical.prev.type == \"stat\")\n        lexical = lexical.prev;\n      var type = lexical.type, closing = firstChar == type;\n\n      if (type == \"vardef\") return lexical.indented + (state.lastType == \"operator\" || state.lastType == \",\" ? lexical.info.length + 1 : 0);\n      else if (type == \"form\" && firstChar == \"{\") return lexical.indented;\n      else if (type == \"form\") return lexical.indented + indentUnit;\n      else if (type == \"stat\")\n        return lexical.indented + (isContinuedStatement(state, textAfter) ? statementIndent || indentUnit : 0);\n      else if (lexical.info == \"switch\" && !closing && parserConfig.doubleIndentSwitch != false)\n        return lexical.indented + (/^(?:case|default)\\b/.test(textAfter) ? indentUnit : 2 * indentUnit);\n      else if (lexical.align) return lexical.column + (closing ? 0 : 1);\n      else return lexical.indented + (closing ? 0 : indentUnit);\n    },\n\n    electricInput: /^\\s*(?:case .*?:|default:|\\{|\\})$/,\n    blockCommentStart: jsonMode ? null : \"/*\",\n    blockCommentEnd: jsonMode ? null : \"*/\",\n    blockCommentContinue: jsonMode ? null : \" * \",\n    lineComment: jsonMode ? null : \"//\",\n    fold: \"brace\",\n    closeBrackets: \"()[]{}''\\\"\\\"``\",\n\n    helperType: jsonMode ? \"json\" : \"javascript\",\n    jsonldMode: jsonldMode,\n    jsonMode: jsonMode,\n\n    expressionAllowed: expressionAllowed,\n\n    skipExpression: function(state) {\n      var top = state.cc[state.cc.length - 1]\n      if (top == expression || top == expressionNoComma) state.cc.pop()\n    }\n  };\n});\n\nCodeMirror.registerHelper(\"wordChars\", \"javascript\", /[\\w$]/);\n\nCodeMirror.defineMIME(\"text/javascript\", \"javascript\");\nCodeMirror.defineMIME(\"text/ecmascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/javascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/x-javascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/ecmascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/json\", {name: \"javascript\", json: true});\nCodeMirror.defineMIME(\"application/x-json\", {name: \"javascript\", json: true});\nCodeMirror.defineMIME(\"application/ld+json\", {name: \"javascript\", jsonld: true});\nCodeMirror.defineMIME(\"text/typescript\", { name: \"javascript\", typescript: true });\nCodeMirror.defineMIME(\"application/typescript\", { name: \"javascript\", typescript: true });\n\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29kZW1pcnJvci9tb2RlL2phdmFzY3JpcHQvamF2YXNjcmlwdC5qcz9mOWQ0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNLElBQXVEO0FBQzdELFFBQVEsbUJBQU8sQ0FBQyx5RUFBc0I7QUFDdEMsT0FBTyxFQUdhO0FBQ3BCLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHVCQUF1QixRQUFRO0FBQy9CO0FBQ0EsMkNBQTJDOztBQUUzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUssa0JBQWtCLE1BQU07QUFDN0I7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsY0FBYywyQkFBMkI7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEVBQTBFLElBQUk7QUFDOUUsdUNBQXVDO0FBQ3ZDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxRQUFRO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTCxnREFBZ0QsR0FBRztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCOztBQUUxQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQywrQkFBK0I7QUFDMUUsNkNBQTZDLCtCQUErQjtBQUM1RSw4Q0FBOEMsaUNBQWlDO0FBQy9FLDBDQUEwQyx1Q0FBdUM7QUFDakYsaURBQWlELHVDQUF1Qzs7QUFFeEYsQ0FBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9jb2RlbWlycm9yL21vZGUvamF2YXNjcmlwdC9qYXZhc2NyaXB0LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29kZU1pcnJvciwgY29weXJpZ2h0IChjKSBieSBNYXJpam4gSGF2ZXJiZWtlIGFuZCBvdGhlcnNcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIGFuIE1JVCBsaWNlbnNlOiBodHRwczovL2NvZGVtaXJyb3IubmV0L0xJQ0VOU0VcblxuKGZ1bmN0aW9uKG1vZCkge1xuICBpZiAodHlwZW9mIGV4cG9ydHMgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlID09IFwib2JqZWN0XCIpIC8vIENvbW1vbkpTXG4gICAgbW9kKHJlcXVpcmUoXCIuLi8uLi9saWIvY29kZW1pcnJvclwiKSk7XG4gIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIC8vIEFNRFxuICAgIGRlZmluZShbXCIuLi8uLi9saWIvY29kZW1pcnJvclwiXSwgbW9kKTtcbiAgZWxzZSAvLyBQbGFpbiBicm93c2VyIGVudlxuICAgIG1vZChDb2RlTWlycm9yKTtcbn0pKGZ1bmN0aW9uKENvZGVNaXJyb3IpIHtcblwidXNlIHN0cmljdFwiO1xuXG5Db2RlTWlycm9yLmRlZmluZU1vZGUoXCJqYXZhc2NyaXB0XCIsIGZ1bmN0aW9uKGNvbmZpZywgcGFyc2VyQ29uZmlnKSB7XG4gIHZhciBpbmRlbnRVbml0ID0gY29uZmlnLmluZGVudFVuaXQ7XG4gIHZhciBzdGF0ZW1lbnRJbmRlbnQgPSBwYXJzZXJDb25maWcuc3RhdGVtZW50SW5kZW50O1xuICB2YXIganNvbmxkTW9kZSA9IHBhcnNlckNvbmZpZy5qc29ubGQ7XG4gIHZhciBqc29uTW9kZSA9IHBhcnNlckNvbmZpZy5qc29uIHx8IGpzb25sZE1vZGU7XG4gIHZhciBpc1RTID0gcGFyc2VyQ29uZmlnLnR5cGVzY3JpcHQ7XG4gIHZhciB3b3JkUkUgPSBwYXJzZXJDb25maWcud29yZENoYXJhY3RlcnMgfHwgL1tcXHckXFx4YTEtXFx1ZmZmZl0vO1xuXG4gIC8vIFRva2VuaXplclxuXG4gIHZhciBrZXl3b3JkcyA9IGZ1bmN0aW9uKCl7XG4gICAgZnVuY3Rpb24ga3codHlwZSkge3JldHVybiB7dHlwZTogdHlwZSwgc3R5bGU6IFwia2V5d29yZFwifTt9XG4gICAgdmFyIEEgPSBrdyhcImtleXdvcmQgYVwiKSwgQiA9IGt3KFwia2V5d29yZCBiXCIpLCBDID0ga3coXCJrZXl3b3JkIGNcIiksIEQgPSBrdyhcImtleXdvcmQgZFwiKTtcbiAgICB2YXIgb3BlcmF0b3IgPSBrdyhcIm9wZXJhdG9yXCIpLCBhdG9tID0ge3R5cGU6IFwiYXRvbVwiLCBzdHlsZTogXCJhdG9tXCJ9O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIFwiaWZcIjoga3coXCJpZlwiKSwgXCJ3aGlsZVwiOiBBLCBcIndpdGhcIjogQSwgXCJlbHNlXCI6IEIsIFwiZG9cIjogQiwgXCJ0cnlcIjogQiwgXCJmaW5hbGx5XCI6IEIsXG4gICAgICBcInJldHVyblwiOiBELCBcImJyZWFrXCI6IEQsIFwiY29udGludWVcIjogRCwgXCJuZXdcIjoga3coXCJuZXdcIiksIFwiZGVsZXRlXCI6IEMsIFwidm9pZFwiOiBDLCBcInRocm93XCI6IEMsXG4gICAgICBcImRlYnVnZ2VyXCI6IGt3KFwiZGVidWdnZXJcIiksIFwidmFyXCI6IGt3KFwidmFyXCIpLCBcImNvbnN0XCI6IGt3KFwidmFyXCIpLCBcImxldFwiOiBrdyhcInZhclwiKSxcbiAgICAgIFwiZnVuY3Rpb25cIjoga3coXCJmdW5jdGlvblwiKSwgXCJjYXRjaFwiOiBrdyhcImNhdGNoXCIpLFxuICAgICAgXCJmb3JcIjoga3coXCJmb3JcIiksIFwic3dpdGNoXCI6IGt3KFwic3dpdGNoXCIpLCBcImNhc2VcIjoga3coXCJjYXNlXCIpLCBcImRlZmF1bHRcIjoga3coXCJkZWZhdWx0XCIpLFxuICAgICAgXCJpblwiOiBvcGVyYXRvciwgXCJ0eXBlb2ZcIjogb3BlcmF0b3IsIFwiaW5zdGFuY2VvZlwiOiBvcGVyYXRvcixcbiAgICAgIFwidHJ1ZVwiOiBhdG9tLCBcImZhbHNlXCI6IGF0b20sIFwibnVsbFwiOiBhdG9tLCBcInVuZGVmaW5lZFwiOiBhdG9tLCBcIk5hTlwiOiBhdG9tLCBcIkluZmluaXR5XCI6IGF0b20sXG4gICAgICBcInRoaXNcIjoga3coXCJ0aGlzXCIpLCBcImNsYXNzXCI6IGt3KFwiY2xhc3NcIiksIFwic3VwZXJcIjoga3coXCJhdG9tXCIpLFxuICAgICAgXCJ5aWVsZFwiOiBDLCBcImV4cG9ydFwiOiBrdyhcImV4cG9ydFwiKSwgXCJpbXBvcnRcIjoga3coXCJpbXBvcnRcIiksIFwiZXh0ZW5kc1wiOiBDLFxuICAgICAgXCJhd2FpdFwiOiBDXG4gICAgfTtcbiAgfSgpO1xuXG4gIHZhciBpc09wZXJhdG9yQ2hhciA9IC9bK1xcLSomJT08PiE/fH5eQF0vO1xuICB2YXIgaXNKc29ubGRLZXl3b3JkID0gL15AKGNvbnRleHR8aWR8dmFsdWV8bGFuZ3VhZ2V8dHlwZXxjb250YWluZXJ8bGlzdHxzZXR8cmV2ZXJzZXxpbmRleHxiYXNlfHZvY2FifGdyYXBoKVwiLztcblxuICBmdW5jdGlvbiByZWFkUmVnZXhwKHN0cmVhbSkge1xuICAgIHZhciBlc2NhcGVkID0gZmFsc2UsIG5leHQsIGluU2V0ID0gZmFsc2U7XG4gICAgd2hpbGUgKChuZXh0ID0gc3RyZWFtLm5leHQoKSkgIT0gbnVsbCkge1xuICAgICAgaWYgKCFlc2NhcGVkKSB7XG4gICAgICAgIGlmIChuZXh0ID09IFwiL1wiICYmICFpblNldCkgcmV0dXJuO1xuICAgICAgICBpZiAobmV4dCA9PSBcIltcIikgaW5TZXQgPSB0cnVlO1xuICAgICAgICBlbHNlIGlmIChpblNldCAmJiBuZXh0ID09IFwiXVwiKSBpblNldCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgZXNjYXBlZCA9ICFlc2NhcGVkICYmIG5leHQgPT0gXCJcXFxcXCI7XG4gICAgfVxuICB9XG5cbiAgLy8gVXNlZCBhcyBzY3JhdGNoIHZhcmlhYmxlcyB0byBjb21tdW5pY2F0ZSBtdWx0aXBsZSB2YWx1ZXMgd2l0aG91dFxuICAvLyBjb25zaW5nIHVwIHRvbnMgb2Ygb2JqZWN0cy5cbiAgdmFyIHR5cGUsIGNvbnRlbnQ7XG4gIGZ1bmN0aW9uIHJldCh0cCwgc3R5bGUsIGNvbnQpIHtcbiAgICB0eXBlID0gdHA7IGNvbnRlbnQgPSBjb250O1xuICAgIHJldHVybiBzdHlsZTtcbiAgfVxuICBmdW5jdGlvbiB0b2tlbkJhc2Uoc3RyZWFtLCBzdGF0ZSkge1xuICAgIHZhciBjaCA9IHN0cmVhbS5uZXh0KCk7XG4gICAgaWYgKGNoID09ICdcIicgfHwgY2ggPT0gXCInXCIpIHtcbiAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5TdHJpbmcoY2gpO1xuICAgICAgcmV0dXJuIHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuICAgIH0gZWxzZSBpZiAoY2ggPT0gXCIuXCIgJiYgc3RyZWFtLm1hdGNoKC9eXFxkW1xcZF9dKig/OltlRV1bK1xcLV0/W1xcZF9dKyk/LykpIHtcbiAgICAgIHJldHVybiByZXQoXCJudW1iZXJcIiwgXCJudW1iZXJcIik7XG4gICAgfSBlbHNlIGlmIChjaCA9PSBcIi5cIiAmJiBzdHJlYW0ubWF0Y2goXCIuLlwiKSkge1xuICAgICAgcmV0dXJuIHJldChcInNwcmVhZFwiLCBcIm1ldGFcIik7XG4gICAgfSBlbHNlIGlmICgvW1xcW1xcXXt9XFwoXFwpLDtcXDpcXC5dLy50ZXN0KGNoKSkge1xuICAgICAgcmV0dXJuIHJldChjaCk7XG4gICAgfSBlbHNlIGlmIChjaCA9PSBcIj1cIiAmJiBzdHJlYW0uZWF0KFwiPlwiKSkge1xuICAgICAgcmV0dXJuIHJldChcIj0+XCIsIFwib3BlcmF0b3JcIik7XG4gICAgfSBlbHNlIGlmIChjaCA9PSBcIjBcIiAmJiBzdHJlYW0ubWF0Y2goL14oPzp4W1xcZEEtRmEtZl9dK3xvWzAtN19dK3xiWzAxX10rKW4/LykpIHtcbiAgICAgIHJldHVybiByZXQoXCJudW1iZXJcIiwgXCJudW1iZXJcIik7XG4gICAgfSBlbHNlIGlmICgvXFxkLy50ZXN0KGNoKSkge1xuICAgICAgc3RyZWFtLm1hdGNoKC9eW1xcZF9dKig/Om58KD86XFwuW1xcZF9dKik/KD86W2VFXVsrXFwtXT9bXFxkX10rKT8pPy8pO1xuICAgICAgcmV0dXJuIHJldChcIm51bWJlclwiLCBcIm51bWJlclwiKTtcbiAgICB9IGVsc2UgaWYgKGNoID09IFwiL1wiKSB7XG4gICAgICBpZiAoc3RyZWFtLmVhdChcIipcIikpIHtcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkNvbW1lbnQ7XG4gICAgICAgIHJldHVybiB0b2tlbkNvbW1lbnQoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICB9IGVsc2UgaWYgKHN0cmVhbS5lYXQoXCIvXCIpKSB7XG4gICAgICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICAgICAgcmV0dXJuIHJldChcImNvbW1lbnRcIiwgXCJjb21tZW50XCIpO1xuICAgICAgfSBlbHNlIGlmIChleHByZXNzaW9uQWxsb3dlZChzdHJlYW0sIHN0YXRlLCAxKSkge1xuICAgICAgICByZWFkUmVnZXhwKHN0cmVhbSk7XG4gICAgICAgIHN0cmVhbS5tYXRjaCgvXlxcYigoW2dpbXl1c10pKD8hW2dpbXl1c10qXFwyKSkrXFxiLyk7XG4gICAgICAgIHJldHVybiByZXQoXCJyZWdleHBcIiwgXCJzdHJpbmctMlwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0cmVhbS5lYXQoXCI9XCIpO1xuICAgICAgICByZXR1cm4gcmV0KFwib3BlcmF0b3JcIiwgXCJvcGVyYXRvclwiLCBzdHJlYW0uY3VycmVudCgpKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNoID09IFwiYFwiKSB7XG4gICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuUXVhc2k7XG4gICAgICByZXR1cm4gdG9rZW5RdWFzaShzdHJlYW0sIHN0YXRlKTtcbiAgICB9IGVsc2UgaWYgKGNoID09IFwiI1wiICYmIHN0cmVhbS5wZWVrKCkgPT0gXCIhXCIpIHtcbiAgICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICAgIHJldHVybiByZXQoXCJtZXRhXCIsIFwibWV0YVwiKTtcbiAgICB9IGVsc2UgaWYgKGNoID09IFwiI1wiICYmIHN0cmVhbS5lYXRXaGlsZSh3b3JkUkUpKSB7XG4gICAgICByZXR1cm4gcmV0KFwidmFyaWFibGVcIiwgXCJwcm9wZXJ0eVwiKVxuICAgIH0gZWxzZSBpZiAoY2ggPT0gXCI8XCIgJiYgc3RyZWFtLm1hdGNoKFwiIS0tXCIpIHx8XG4gICAgICAgICAgICAgICAoY2ggPT0gXCItXCIgJiYgc3RyZWFtLm1hdGNoKFwiLT5cIikgJiYgIS9cXFMvLnRlc3Qoc3RyZWFtLnN0cmluZy5zbGljZSgwLCBzdHJlYW0uc3RhcnQpKSkpIHtcbiAgICAgIHN0cmVhbS5za2lwVG9FbmQoKVxuICAgICAgcmV0dXJuIHJldChcImNvbW1lbnRcIiwgXCJjb21tZW50XCIpXG4gICAgfSBlbHNlIGlmIChpc09wZXJhdG9yQ2hhci50ZXN0KGNoKSkge1xuICAgICAgaWYgKGNoICE9IFwiPlwiIHx8ICFzdGF0ZS5sZXhpY2FsIHx8IHN0YXRlLmxleGljYWwudHlwZSAhPSBcIj5cIikge1xuICAgICAgICBpZiAoc3RyZWFtLmVhdChcIj1cIikpIHtcbiAgICAgICAgICBpZiAoY2ggPT0gXCIhXCIgfHwgY2ggPT0gXCI9XCIpIHN0cmVhbS5lYXQoXCI9XCIpXG4gICAgICAgIH0gZWxzZSBpZiAoL1s8PiorXFwtfCY/XS8udGVzdChjaCkpIHtcbiAgICAgICAgICBzdHJlYW0uZWF0KGNoKVxuICAgICAgICAgIGlmIChjaCA9PSBcIj5cIikgc3RyZWFtLmVhdChjaClcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNoID09IFwiP1wiICYmIHN0cmVhbS5lYXQoXCIuXCIpKSByZXR1cm4gcmV0KFwiLlwiKVxuICAgICAgcmV0dXJuIHJldChcIm9wZXJhdG9yXCIsIFwib3BlcmF0b3JcIiwgc3RyZWFtLmN1cnJlbnQoKSk7XG4gICAgfSBlbHNlIGlmICh3b3JkUkUudGVzdChjaCkpIHtcbiAgICAgIHN0cmVhbS5lYXRXaGlsZSh3b3JkUkUpO1xuICAgICAgdmFyIHdvcmQgPSBzdHJlYW0uY3VycmVudCgpXG4gICAgICBpZiAoc3RhdGUubGFzdFR5cGUgIT0gXCIuXCIpIHtcbiAgICAgICAgaWYgKGtleXdvcmRzLnByb3BlcnR5SXNFbnVtZXJhYmxlKHdvcmQpKSB7XG4gICAgICAgICAgdmFyIGt3ID0ga2V5d29yZHNbd29yZF1cbiAgICAgICAgICByZXR1cm4gcmV0KGt3LnR5cGUsIGt3LnN0eWxlLCB3b3JkKVxuICAgICAgICB9XG4gICAgICAgIGlmICh3b3JkID09IFwiYXN5bmNcIiAmJiBzdHJlYW0ubWF0Y2goL14oXFxzfFxcL1xcKihbXipdfFxcKig/IVxcLykpKj9cXCpcXC8pKltcXFtcXChcXHddLywgZmFsc2UpKVxuICAgICAgICAgIHJldHVybiByZXQoXCJhc3luY1wiLCBcImtleXdvcmRcIiwgd29yZClcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQoXCJ2YXJpYWJsZVwiLCBcInZhcmlhYmxlXCIsIHdvcmQpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdG9rZW5TdHJpbmcocXVvdGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgdmFyIGVzY2FwZWQgPSBmYWxzZSwgbmV4dDtcbiAgICAgIGlmIChqc29ubGRNb2RlICYmIHN0cmVhbS5wZWVrKCkgPT0gXCJAXCIgJiYgc3RyZWFtLm1hdGNoKGlzSnNvbmxkS2V5d29yZCkpe1xuICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQmFzZTtcbiAgICAgICAgcmV0dXJuIHJldChcImpzb25sZC1rZXl3b3JkXCIsIFwibWV0YVwiKTtcbiAgICAgIH1cbiAgICAgIHdoaWxlICgobmV4dCA9IHN0cmVhbS5uZXh0KCkpICE9IG51bGwpIHtcbiAgICAgICAgaWYgKG5leHQgPT0gcXVvdGUgJiYgIWVzY2FwZWQpIGJyZWFrO1xuICAgICAgICBlc2NhcGVkID0gIWVzY2FwZWQgJiYgbmV4dCA9PSBcIlxcXFxcIjtcbiAgICAgIH1cbiAgICAgIGlmICghZXNjYXBlZCkgc3RhdGUudG9rZW5pemUgPSB0b2tlbkJhc2U7XG4gICAgICByZXR1cm4gcmV0KFwic3RyaW5nXCIsIFwic3RyaW5nXCIpO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiB0b2tlbkNvbW1lbnQoc3RyZWFtLCBzdGF0ZSkge1xuICAgIHZhciBtYXliZUVuZCA9IGZhbHNlLCBjaDtcbiAgICB3aGlsZSAoY2ggPSBzdHJlYW0ubmV4dCgpKSB7XG4gICAgICBpZiAoY2ggPT0gXCIvXCIgJiYgbWF5YmVFbmQpIHtcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkJhc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgbWF5YmVFbmQgPSAoY2ggPT0gXCIqXCIpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0KFwiY29tbWVudFwiLCBcImNvbW1lbnRcIik7XG4gIH1cblxuICBmdW5jdGlvbiB0b2tlblF1YXNpKHN0cmVhbSwgc3RhdGUpIHtcbiAgICB2YXIgZXNjYXBlZCA9IGZhbHNlLCBuZXh0O1xuICAgIHdoaWxlICgobmV4dCA9IHN0cmVhbS5uZXh0KCkpICE9IG51bGwpIHtcbiAgICAgIGlmICghZXNjYXBlZCAmJiAobmV4dCA9PSBcImBcIiB8fCBuZXh0ID09IFwiJFwiICYmIHN0cmVhbS5lYXQoXCJ7XCIpKSkge1xuICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQmFzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBlc2NhcGVkID0gIWVzY2FwZWQgJiYgbmV4dCA9PSBcIlxcXFxcIjtcbiAgICB9XG4gICAgcmV0dXJuIHJldChcInF1YXNpXCIsIFwic3RyaW5nLTJcIiwgc3RyZWFtLmN1cnJlbnQoKSk7XG4gIH1cblxuICB2YXIgYnJhY2tldHMgPSBcIihbe31dKVwiO1xuICAvLyBUaGlzIGlzIGEgY3J1ZGUgbG9va2FoZWFkIHRyaWNrIHRvIHRyeSBhbmQgbm90aWNlIHRoYXQgd2UncmVcbiAgLy8gcGFyc2luZyB0aGUgYXJndW1lbnQgcGF0dGVybnMgZm9yIGEgZmF0LWFycm93IGZ1bmN0aW9uIGJlZm9yZSB3ZVxuICAvLyBhY3R1YWxseSBoaXQgdGhlIGFycm93IHRva2VuLiBJdCBvbmx5IHdvcmtzIGlmIHRoZSBhcnJvdyBpcyBvblxuICAvLyB0aGUgc2FtZSBsaW5lIGFzIHRoZSBhcmd1bWVudHMgYW5kIHRoZXJlJ3Mgbm8gc3RyYW5nZSBub2lzZVxuICAvLyAoY29tbWVudHMpIGluIGJldHdlZW4uIEZhbGxiYWNrIGlzIHRvIG9ubHkgbm90aWNlIHdoZW4gd2UgaGl0IHRoZVxuICAvLyBhcnJvdywgYW5kIG5vdCBkZWNsYXJlIHRoZSBhcmd1bWVudHMgYXMgbG9jYWxzIGZvciB0aGUgYXJyb3dcbiAgLy8gYm9keS5cbiAgZnVuY3Rpb24gZmluZEZhdEFycm93KHN0cmVhbSwgc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUuZmF0QXJyb3dBdCkgc3RhdGUuZmF0QXJyb3dBdCA9IG51bGw7XG4gICAgdmFyIGFycm93ID0gc3RyZWFtLnN0cmluZy5pbmRleE9mKFwiPT5cIiwgc3RyZWFtLnN0YXJ0KTtcbiAgICBpZiAoYXJyb3cgPCAwKSByZXR1cm47XG5cbiAgICBpZiAoaXNUUykgeyAvLyBUcnkgdG8gc2tpcCBUeXBlU2NyaXB0IHJldHVybiB0eXBlIGRlY2xhcmF0aW9ucyBhZnRlciB0aGUgYXJndW1lbnRzXG4gICAgICB2YXIgbSA9IC86XFxzKig/OlxcdysoPzo8W14+XSo+fFxcW1xcXSk/fFxce1tefV0qXFx9KVxccyokLy5leGVjKHN0cmVhbS5zdHJpbmcuc2xpY2Uoc3RyZWFtLnN0YXJ0LCBhcnJvdykpXG4gICAgICBpZiAobSkgYXJyb3cgPSBtLmluZGV4XG4gICAgfVxuXG4gICAgdmFyIGRlcHRoID0gMCwgc2F3U29tZXRoaW5nID0gZmFsc2U7XG4gICAgZm9yICh2YXIgcG9zID0gYXJyb3cgLSAxOyBwb3MgPj0gMDsgLS1wb3MpIHtcbiAgICAgIHZhciBjaCA9IHN0cmVhbS5zdHJpbmcuY2hhckF0KHBvcyk7XG4gICAgICB2YXIgYnJhY2tldCA9IGJyYWNrZXRzLmluZGV4T2YoY2gpO1xuICAgICAgaWYgKGJyYWNrZXQgPj0gMCAmJiBicmFja2V0IDwgMykge1xuICAgICAgICBpZiAoIWRlcHRoKSB7ICsrcG9zOyBicmVhazsgfVxuICAgICAgICBpZiAoLS1kZXB0aCA9PSAwKSB7IGlmIChjaCA9PSBcIihcIikgc2F3U29tZXRoaW5nID0gdHJ1ZTsgYnJlYWs7IH1cbiAgICAgIH0gZWxzZSBpZiAoYnJhY2tldCA+PSAzICYmIGJyYWNrZXQgPCA2KSB7XG4gICAgICAgICsrZGVwdGg7XG4gICAgICB9IGVsc2UgaWYgKHdvcmRSRS50ZXN0KGNoKSkge1xuICAgICAgICBzYXdTb21ldGhpbmcgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmICgvW1wiJ1xcL2BdLy50ZXN0KGNoKSkge1xuICAgICAgICBmb3IgKDs7IC0tcG9zKSB7XG4gICAgICAgICAgaWYgKHBvcyA9PSAwKSByZXR1cm5cbiAgICAgICAgICB2YXIgbmV4dCA9IHN0cmVhbS5zdHJpbmcuY2hhckF0KHBvcyAtIDEpXG4gICAgICAgICAgaWYgKG5leHQgPT0gY2ggJiYgc3RyZWFtLnN0cmluZy5jaGFyQXQocG9zIC0gMikgIT0gXCJcXFxcXCIpIHsgcG9zLS07IGJyZWFrIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzYXdTb21ldGhpbmcgJiYgIWRlcHRoKSB7XG4gICAgICAgICsrcG9zO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNhd1NvbWV0aGluZyAmJiAhZGVwdGgpIHN0YXRlLmZhdEFycm93QXQgPSBwb3M7XG4gIH1cblxuICAvLyBQYXJzZXJcblxuICB2YXIgYXRvbWljVHlwZXMgPSB7XCJhdG9tXCI6IHRydWUsIFwibnVtYmVyXCI6IHRydWUsIFwidmFyaWFibGVcIjogdHJ1ZSwgXCJzdHJpbmdcIjogdHJ1ZSwgXCJyZWdleHBcIjogdHJ1ZSwgXCJ0aGlzXCI6IHRydWUsIFwianNvbmxkLWtleXdvcmRcIjogdHJ1ZX07XG5cbiAgZnVuY3Rpb24gSlNMZXhpY2FsKGluZGVudGVkLCBjb2x1bW4sIHR5cGUsIGFsaWduLCBwcmV2LCBpbmZvKSB7XG4gICAgdGhpcy5pbmRlbnRlZCA9IGluZGVudGVkO1xuICAgIHRoaXMuY29sdW1uID0gY29sdW1uO1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5wcmV2ID0gcHJldjtcbiAgICB0aGlzLmluZm8gPSBpbmZvO1xuICAgIGlmIChhbGlnbiAhPSBudWxsKSB0aGlzLmFsaWduID0gYWxpZ247XG4gIH1cblxuICBmdW5jdGlvbiBpblNjb3BlKHN0YXRlLCB2YXJuYW1lKSB7XG4gICAgZm9yICh2YXIgdiA9IHN0YXRlLmxvY2FsVmFyczsgdjsgdiA9IHYubmV4dClcbiAgICAgIGlmICh2Lm5hbWUgPT0gdmFybmFtZSkgcmV0dXJuIHRydWU7XG4gICAgZm9yICh2YXIgY3ggPSBzdGF0ZS5jb250ZXh0OyBjeDsgY3ggPSBjeC5wcmV2KSB7XG4gICAgICBmb3IgKHZhciB2ID0gY3gudmFyczsgdjsgdiA9IHYubmV4dClcbiAgICAgICAgaWYgKHYubmFtZSA9PSB2YXJuYW1lKSByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUpTKHN0YXRlLCBzdHlsZSwgdHlwZSwgY29udGVudCwgc3RyZWFtKSB7XG4gICAgdmFyIGNjID0gc3RhdGUuY2M7XG4gICAgLy8gQ29tbXVuaWNhdGUgb3VyIGNvbnRleHQgdG8gdGhlIGNvbWJpbmF0b3JzLlxuICAgIC8vIChMZXNzIHdhc3RlZnVsIHRoYW4gY29uc2luZyB1cCBhIGh1bmRyZWQgY2xvc3VyZXMgb24gZXZlcnkgY2FsbC4pXG4gICAgY3guc3RhdGUgPSBzdGF0ZTsgY3guc3RyZWFtID0gc3RyZWFtOyBjeC5tYXJrZWQgPSBudWxsLCBjeC5jYyA9IGNjOyBjeC5zdHlsZSA9IHN0eWxlO1xuXG4gICAgaWYgKCFzdGF0ZS5sZXhpY2FsLmhhc093blByb3BlcnR5KFwiYWxpZ25cIikpXG4gICAgICBzdGF0ZS5sZXhpY2FsLmFsaWduID0gdHJ1ZTtcblxuICAgIHdoaWxlKHRydWUpIHtcbiAgICAgIHZhciBjb21iaW5hdG9yID0gY2MubGVuZ3RoID8gY2MucG9wKCkgOiBqc29uTW9kZSA/IGV4cHJlc3Npb24gOiBzdGF0ZW1lbnQ7XG4gICAgICBpZiAoY29tYmluYXRvcih0eXBlLCBjb250ZW50KSkge1xuICAgICAgICB3aGlsZShjYy5sZW5ndGggJiYgY2NbY2MubGVuZ3RoIC0gMV0ubGV4KVxuICAgICAgICAgIGNjLnBvcCgpKCk7XG4gICAgICAgIGlmIChjeC5tYXJrZWQpIHJldHVybiBjeC5tYXJrZWQ7XG4gICAgICAgIGlmICh0eXBlID09IFwidmFyaWFibGVcIiAmJiBpblNjb3BlKHN0YXRlLCBjb250ZW50KSkgcmV0dXJuIFwidmFyaWFibGUtMlwiO1xuICAgICAgICByZXR1cm4gc3R5bGU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQ29tYmluYXRvciB1dGlsc1xuXG4gIHZhciBjeCA9IHtzdGF0ZTogbnVsbCwgY29sdW1uOiBudWxsLCBtYXJrZWQ6IG51bGwsIGNjOiBudWxsfTtcbiAgZnVuY3Rpb24gcGFzcygpIHtcbiAgICBmb3IgKHZhciBpID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBjeC5jYy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gIH1cbiAgZnVuY3Rpb24gY29udCgpIHtcbiAgICBwYXNzLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZnVuY3Rpb24gaW5MaXN0KG5hbWUsIGxpc3QpIHtcbiAgICBmb3IgKHZhciB2ID0gbGlzdDsgdjsgdiA9IHYubmV4dCkgaWYgKHYubmFtZSA9PSBuYW1lKSByZXR1cm4gdHJ1ZVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmdW5jdGlvbiByZWdpc3Rlcih2YXJuYW1lKSB7XG4gICAgdmFyIHN0YXRlID0gY3guc3RhdGU7XG4gICAgY3gubWFya2VkID0gXCJkZWZcIjtcbiAgICBpZiAoc3RhdGUuY29udGV4dCkge1xuICAgICAgaWYgKHN0YXRlLmxleGljYWwuaW5mbyA9PSBcInZhclwiICYmIHN0YXRlLmNvbnRleHQgJiYgc3RhdGUuY29udGV4dC5ibG9jaykge1xuICAgICAgICAvLyBGSVhNRSBmdW5jdGlvbiBkZWNscyBhcmUgYWxzbyBub3QgYmxvY2sgc2NvcGVkXG4gICAgICAgIHZhciBuZXdDb250ZXh0ID0gcmVnaXN0ZXJWYXJTY29wZWQodmFybmFtZSwgc3RhdGUuY29udGV4dClcbiAgICAgICAgaWYgKG5ld0NvbnRleHQgIT0gbnVsbCkge1xuICAgICAgICAgIHN0YXRlLmNvbnRleHQgPSBuZXdDb250ZXh0XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIWluTGlzdCh2YXJuYW1lLCBzdGF0ZS5sb2NhbFZhcnMpKSB7XG4gICAgICAgIHN0YXRlLmxvY2FsVmFycyA9IG5ldyBWYXIodmFybmFtZSwgc3RhdGUubG9jYWxWYXJzKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gRmFsbCB0aHJvdWdoIG1lYW5zIHRoaXMgaXMgZ2xvYmFsXG4gICAgaWYgKHBhcnNlckNvbmZpZy5nbG9iYWxWYXJzICYmICFpbkxpc3QodmFybmFtZSwgc3RhdGUuZ2xvYmFsVmFycykpXG4gICAgICBzdGF0ZS5nbG9iYWxWYXJzID0gbmV3IFZhcih2YXJuYW1lLCBzdGF0ZS5nbG9iYWxWYXJzKVxuICB9XG4gIGZ1bmN0aW9uIHJlZ2lzdGVyVmFyU2NvcGVkKHZhcm5hbWUsIGNvbnRleHQpIHtcbiAgICBpZiAoIWNvbnRleHQpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfSBlbHNlIGlmIChjb250ZXh0LmJsb2NrKSB7XG4gICAgICB2YXIgaW5uZXIgPSByZWdpc3RlclZhclNjb3BlZCh2YXJuYW1lLCBjb250ZXh0LnByZXYpXG4gICAgICBpZiAoIWlubmVyKSByZXR1cm4gbnVsbFxuICAgICAgaWYgKGlubmVyID09IGNvbnRleHQucHJldikgcmV0dXJuIGNvbnRleHRcbiAgICAgIHJldHVybiBuZXcgQ29udGV4dChpbm5lciwgY29udGV4dC52YXJzLCB0cnVlKVxuICAgIH0gZWxzZSBpZiAoaW5MaXN0KHZhcm5hbWUsIGNvbnRleHQudmFycykpIHtcbiAgICAgIHJldHVybiBjb250ZXh0XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgQ29udGV4dChjb250ZXh0LnByZXYsIG5ldyBWYXIodmFybmFtZSwgY29udGV4dC52YXJzKSwgZmFsc2UpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNNb2RpZmllcihuYW1lKSB7XG4gICAgcmV0dXJuIG5hbWUgPT0gXCJwdWJsaWNcIiB8fCBuYW1lID09IFwicHJpdmF0ZVwiIHx8IG5hbWUgPT0gXCJwcm90ZWN0ZWRcIiB8fCBuYW1lID09IFwiYWJzdHJhY3RcIiB8fCBuYW1lID09IFwicmVhZG9ubHlcIlxuICB9XG5cbiAgLy8gQ29tYmluYXRvcnNcblxuICBmdW5jdGlvbiBDb250ZXh0KHByZXYsIHZhcnMsIGJsb2NrKSB7IHRoaXMucHJldiA9IHByZXY7IHRoaXMudmFycyA9IHZhcnM7IHRoaXMuYmxvY2sgPSBibG9jayB9XG4gIGZ1bmN0aW9uIFZhcihuYW1lLCBuZXh0KSB7IHRoaXMubmFtZSA9IG5hbWU7IHRoaXMubmV4dCA9IG5leHQgfVxuXG4gIHZhciBkZWZhdWx0VmFycyA9IG5ldyBWYXIoXCJ0aGlzXCIsIG5ldyBWYXIoXCJhcmd1bWVudHNcIiwgbnVsbCkpXG4gIGZ1bmN0aW9uIHB1c2hjb250ZXh0KCkge1xuICAgIGN4LnN0YXRlLmNvbnRleHQgPSBuZXcgQ29udGV4dChjeC5zdGF0ZS5jb250ZXh0LCBjeC5zdGF0ZS5sb2NhbFZhcnMsIGZhbHNlKVxuICAgIGN4LnN0YXRlLmxvY2FsVmFycyA9IGRlZmF1bHRWYXJzXG4gIH1cbiAgZnVuY3Rpb24gcHVzaGJsb2NrY29udGV4dCgpIHtcbiAgICBjeC5zdGF0ZS5jb250ZXh0ID0gbmV3IENvbnRleHQoY3guc3RhdGUuY29udGV4dCwgY3guc3RhdGUubG9jYWxWYXJzLCB0cnVlKVxuICAgIGN4LnN0YXRlLmxvY2FsVmFycyA9IG51bGxcbiAgfVxuICBmdW5jdGlvbiBwb3Bjb250ZXh0KCkge1xuICAgIGN4LnN0YXRlLmxvY2FsVmFycyA9IGN4LnN0YXRlLmNvbnRleHQudmFyc1xuICAgIGN4LnN0YXRlLmNvbnRleHQgPSBjeC5zdGF0ZS5jb250ZXh0LnByZXZcbiAgfVxuICBwb3Bjb250ZXh0LmxleCA9IHRydWVcbiAgZnVuY3Rpb24gcHVzaGxleCh0eXBlLCBpbmZvKSB7XG4gICAgdmFyIHJlc3VsdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHN0YXRlID0gY3guc3RhdGUsIGluZGVudCA9IHN0YXRlLmluZGVudGVkO1xuICAgICAgaWYgKHN0YXRlLmxleGljYWwudHlwZSA9PSBcInN0YXRcIikgaW5kZW50ID0gc3RhdGUubGV4aWNhbC5pbmRlbnRlZDtcbiAgICAgIGVsc2UgZm9yICh2YXIgb3V0ZXIgPSBzdGF0ZS5sZXhpY2FsOyBvdXRlciAmJiBvdXRlci50eXBlID09IFwiKVwiICYmIG91dGVyLmFsaWduOyBvdXRlciA9IG91dGVyLnByZXYpXG4gICAgICAgIGluZGVudCA9IG91dGVyLmluZGVudGVkO1xuICAgICAgc3RhdGUubGV4aWNhbCA9IG5ldyBKU0xleGljYWwoaW5kZW50LCBjeC5zdHJlYW0uY29sdW1uKCksIHR5cGUsIG51bGwsIHN0YXRlLmxleGljYWwsIGluZm8pO1xuICAgIH07XG4gICAgcmVzdWx0LmxleCA9IHRydWU7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBmdW5jdGlvbiBwb3BsZXgoKSB7XG4gICAgdmFyIHN0YXRlID0gY3guc3RhdGU7XG4gICAgaWYgKHN0YXRlLmxleGljYWwucHJldikge1xuICAgICAgaWYgKHN0YXRlLmxleGljYWwudHlwZSA9PSBcIilcIilcbiAgICAgICAgc3RhdGUuaW5kZW50ZWQgPSBzdGF0ZS5sZXhpY2FsLmluZGVudGVkO1xuICAgICAgc3RhdGUubGV4aWNhbCA9IHN0YXRlLmxleGljYWwucHJldjtcbiAgICB9XG4gIH1cbiAgcG9wbGV4LmxleCA9IHRydWU7XG5cbiAgZnVuY3Rpb24gZXhwZWN0KHdhbnRlZCkge1xuICAgIGZ1bmN0aW9uIGV4cCh0eXBlKSB7XG4gICAgICBpZiAodHlwZSA9PSB3YW50ZWQpIHJldHVybiBjb250KCk7XG4gICAgICBlbHNlIGlmICh3YW50ZWQgPT0gXCI7XCIgfHwgdHlwZSA9PSBcIn1cIiB8fCB0eXBlID09IFwiKVwiIHx8IHR5cGUgPT0gXCJdXCIpIHJldHVybiBwYXNzKCk7XG4gICAgICBlbHNlIHJldHVybiBjb250KGV4cCk7XG4gICAgfTtcbiAgICByZXR1cm4gZXhwO1xuICB9XG5cbiAgZnVuY3Rpb24gc3RhdGVtZW50KHR5cGUsIHZhbHVlKSB7XG4gICAgaWYgKHR5cGUgPT0gXCJ2YXJcIikgcmV0dXJuIGNvbnQocHVzaGxleChcInZhcmRlZlwiLCB2YWx1ZSksIHZhcmRlZiwgZXhwZWN0KFwiO1wiKSwgcG9wbGV4KTtcbiAgICBpZiAodHlwZSA9PSBcImtleXdvcmQgYVwiKSByZXR1cm4gY29udChwdXNobGV4KFwiZm9ybVwiKSwgcGFyZW5FeHByLCBzdGF0ZW1lbnQsIHBvcGxleCk7XG4gICAgaWYgKHR5cGUgPT0gXCJrZXl3b3JkIGJcIikgcmV0dXJuIGNvbnQocHVzaGxleChcImZvcm1cIiksIHN0YXRlbWVudCwgcG9wbGV4KTtcbiAgICBpZiAodHlwZSA9PSBcImtleXdvcmQgZFwiKSByZXR1cm4gY3guc3RyZWFtLm1hdGNoKC9eXFxzKiQvLCBmYWxzZSkgPyBjb250KCkgOiBjb250KHB1c2hsZXgoXCJzdGF0XCIpLCBtYXliZWV4cHJlc3Npb24sIGV4cGVjdChcIjtcIiksIHBvcGxleCk7XG4gICAgaWYgKHR5cGUgPT0gXCJkZWJ1Z2dlclwiKSByZXR1cm4gY29udChleHBlY3QoXCI7XCIpKTtcbiAgICBpZiAodHlwZSA9PSBcIntcIikgcmV0dXJuIGNvbnQocHVzaGxleChcIn1cIiksIHB1c2hibG9ja2NvbnRleHQsIGJsb2NrLCBwb3BsZXgsIHBvcGNvbnRleHQpO1xuICAgIGlmICh0eXBlID09IFwiO1wiKSByZXR1cm4gY29udCgpO1xuICAgIGlmICh0eXBlID09IFwiaWZcIikge1xuICAgICAgaWYgKGN4LnN0YXRlLmxleGljYWwuaW5mbyA9PSBcImVsc2VcIiAmJiBjeC5zdGF0ZS5jY1tjeC5zdGF0ZS5jYy5sZW5ndGggLSAxXSA9PSBwb3BsZXgpXG4gICAgICAgIGN4LnN0YXRlLmNjLnBvcCgpKCk7XG4gICAgICByZXR1cm4gY29udChwdXNobGV4KFwiZm9ybVwiKSwgcGFyZW5FeHByLCBzdGF0ZW1lbnQsIHBvcGxleCwgbWF5YmVlbHNlKTtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gY29udChmdW5jdGlvbmRlZik7XG4gICAgaWYgKHR5cGUgPT0gXCJmb3JcIikgcmV0dXJuIGNvbnQocHVzaGxleChcImZvcm1cIiksIGZvcnNwZWMsIHN0YXRlbWVudCwgcG9wbGV4KTtcbiAgICBpZiAodHlwZSA9PSBcImNsYXNzXCIgfHwgKGlzVFMgJiYgdmFsdWUgPT0gXCJpbnRlcmZhY2VcIikpIHtcbiAgICAgIGN4Lm1hcmtlZCA9IFwia2V5d29yZFwiXG4gICAgICByZXR1cm4gY29udChwdXNobGV4KFwiZm9ybVwiLCB0eXBlID09IFwiY2xhc3NcIiA/IHR5cGUgOiB2YWx1ZSksIGNsYXNzTmFtZSwgcG9wbGV4KVxuICAgIH1cbiAgICBpZiAodHlwZSA9PSBcInZhcmlhYmxlXCIpIHtcbiAgICAgIGlmIChpc1RTICYmIHZhbHVlID09IFwiZGVjbGFyZVwiKSB7XG4gICAgICAgIGN4Lm1hcmtlZCA9IFwia2V5d29yZFwiXG4gICAgICAgIHJldHVybiBjb250KHN0YXRlbWVudClcbiAgICAgIH0gZWxzZSBpZiAoaXNUUyAmJiAodmFsdWUgPT0gXCJtb2R1bGVcIiB8fCB2YWx1ZSA9PSBcImVudW1cIiB8fCB2YWx1ZSA9PSBcInR5cGVcIikgJiYgY3guc3RyZWFtLm1hdGNoKC9eXFxzKlxcdy8sIGZhbHNlKSkge1xuICAgICAgICBjeC5tYXJrZWQgPSBcImtleXdvcmRcIlxuICAgICAgICBpZiAodmFsdWUgPT0gXCJlbnVtXCIpIHJldHVybiBjb250KGVudW1kZWYpO1xuICAgICAgICBlbHNlIGlmICh2YWx1ZSA9PSBcInR5cGVcIikgcmV0dXJuIGNvbnQodHlwZW5hbWUsIGV4cGVjdChcIm9wZXJhdG9yXCIpLCB0eXBlZXhwciwgZXhwZWN0KFwiO1wiKSk7XG4gICAgICAgIGVsc2UgcmV0dXJuIGNvbnQocHVzaGxleChcImZvcm1cIiksIHBhdHRlcm4sIGV4cGVjdChcIntcIiksIHB1c2hsZXgoXCJ9XCIpLCBibG9jaywgcG9wbGV4LCBwb3BsZXgpXG4gICAgICB9IGVsc2UgaWYgKGlzVFMgJiYgdmFsdWUgPT0gXCJuYW1lc3BhY2VcIikge1xuICAgICAgICBjeC5tYXJrZWQgPSBcImtleXdvcmRcIlxuICAgICAgICByZXR1cm4gY29udChwdXNobGV4KFwiZm9ybVwiKSwgZXhwcmVzc2lvbiwgc3RhdGVtZW50LCBwb3BsZXgpXG4gICAgICB9IGVsc2UgaWYgKGlzVFMgJiYgdmFsdWUgPT0gXCJhYnN0cmFjdFwiKSB7XG4gICAgICAgIGN4Lm1hcmtlZCA9IFwia2V5d29yZFwiXG4gICAgICAgIHJldHVybiBjb250KHN0YXRlbWVudClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjb250KHB1c2hsZXgoXCJzdGF0XCIpLCBtYXliZWxhYmVsKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGUgPT0gXCJzd2l0Y2hcIikgcmV0dXJuIGNvbnQocHVzaGxleChcImZvcm1cIiksIHBhcmVuRXhwciwgZXhwZWN0KFwie1wiKSwgcHVzaGxleChcIn1cIiwgXCJzd2l0Y2hcIiksIHB1c2hibG9ja2NvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrLCBwb3BsZXgsIHBvcGxleCwgcG9wY29udGV4dCk7XG4gICAgaWYgKHR5cGUgPT0gXCJjYXNlXCIpIHJldHVybiBjb250KGV4cHJlc3Npb24sIGV4cGVjdChcIjpcIikpO1xuICAgIGlmICh0eXBlID09IFwiZGVmYXVsdFwiKSByZXR1cm4gY29udChleHBlY3QoXCI6XCIpKTtcbiAgICBpZiAodHlwZSA9PSBcImNhdGNoXCIpIHJldHVybiBjb250KHB1c2hsZXgoXCJmb3JtXCIpLCBwdXNoY29udGV4dCwgbWF5YmVDYXRjaEJpbmRpbmcsIHN0YXRlbWVudCwgcG9wbGV4LCBwb3Bjb250ZXh0KTtcbiAgICBpZiAodHlwZSA9PSBcImV4cG9ydFwiKSByZXR1cm4gY29udChwdXNobGV4KFwic3RhdFwiKSwgYWZ0ZXJFeHBvcnQsIHBvcGxleCk7XG4gICAgaWYgKHR5cGUgPT0gXCJpbXBvcnRcIikgcmV0dXJuIGNvbnQocHVzaGxleChcInN0YXRcIiksIGFmdGVySW1wb3J0LCBwb3BsZXgpO1xuICAgIGlmICh0eXBlID09IFwiYXN5bmNcIikgcmV0dXJuIGNvbnQoc3RhdGVtZW50KVxuICAgIGlmICh2YWx1ZSA9PSBcIkBcIikgcmV0dXJuIGNvbnQoZXhwcmVzc2lvbiwgc3RhdGVtZW50KVxuICAgIHJldHVybiBwYXNzKHB1c2hsZXgoXCJzdGF0XCIpLCBleHByZXNzaW9uLCBleHBlY3QoXCI7XCIpLCBwb3BsZXgpO1xuICB9XG4gIGZ1bmN0aW9uIG1heWJlQ2F0Y2hCaW5kaW5nKHR5cGUpIHtcbiAgICBpZiAodHlwZSA9PSBcIihcIikgcmV0dXJuIGNvbnQoZnVuYXJnLCBleHBlY3QoXCIpXCIpKVxuICB9XG4gIGZ1bmN0aW9uIGV4cHJlc3Npb24odHlwZSwgdmFsdWUpIHtcbiAgICByZXR1cm4gZXhwcmVzc2lvbklubmVyKHR5cGUsIHZhbHVlLCBmYWxzZSk7XG4gIH1cbiAgZnVuY3Rpb24gZXhwcmVzc2lvbk5vQ29tbWEodHlwZSwgdmFsdWUpIHtcbiAgICByZXR1cm4gZXhwcmVzc2lvbklubmVyKHR5cGUsIHZhbHVlLCB0cnVlKTtcbiAgfVxuICBmdW5jdGlvbiBwYXJlbkV4cHIodHlwZSkge1xuICAgIGlmICh0eXBlICE9IFwiKFwiKSByZXR1cm4gcGFzcygpXG4gICAgcmV0dXJuIGNvbnQocHVzaGxleChcIilcIiksIG1heWJlZXhwcmVzc2lvbiwgZXhwZWN0KFwiKVwiKSwgcG9wbGV4KVxuICB9XG4gIGZ1bmN0aW9uIGV4cHJlc3Npb25Jbm5lcih0eXBlLCB2YWx1ZSwgbm9Db21tYSkge1xuICAgIGlmIChjeC5zdGF0ZS5mYXRBcnJvd0F0ID09IGN4LnN0cmVhbS5zdGFydCkge1xuICAgICAgdmFyIGJvZHkgPSBub0NvbW1hID8gYXJyb3dCb2R5Tm9Db21tYSA6IGFycm93Qm9keTtcbiAgICAgIGlmICh0eXBlID09IFwiKFwiKSByZXR1cm4gY29udChwdXNoY29udGV4dCwgcHVzaGxleChcIilcIiksIGNvbW1hc2VwKGZ1bmFyZywgXCIpXCIpLCBwb3BsZXgsIGV4cGVjdChcIj0+XCIpLCBib2R5LCBwb3Bjb250ZXh0KTtcbiAgICAgIGVsc2UgaWYgKHR5cGUgPT0gXCJ2YXJpYWJsZVwiKSByZXR1cm4gcGFzcyhwdXNoY29udGV4dCwgcGF0dGVybiwgZXhwZWN0KFwiPT5cIiksIGJvZHksIHBvcGNvbnRleHQpO1xuICAgIH1cblxuICAgIHZhciBtYXliZW9wID0gbm9Db21tYSA/IG1heWJlb3BlcmF0b3JOb0NvbW1hIDogbWF5YmVvcGVyYXRvckNvbW1hO1xuICAgIGlmIChhdG9taWNUeXBlcy5oYXNPd25Qcm9wZXJ0eSh0eXBlKSkgcmV0dXJuIGNvbnQobWF5YmVvcCk7XG4gICAgaWYgKHR5cGUgPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gY29udChmdW5jdGlvbmRlZiwgbWF5YmVvcCk7XG4gICAgaWYgKHR5cGUgPT0gXCJjbGFzc1wiIHx8IChpc1RTICYmIHZhbHVlID09IFwiaW50ZXJmYWNlXCIpKSB7IGN4Lm1hcmtlZCA9IFwia2V5d29yZFwiOyByZXR1cm4gY29udChwdXNobGV4KFwiZm9ybVwiKSwgY2xhc3NFeHByZXNzaW9uLCBwb3BsZXgpOyB9XG4gICAgaWYgKHR5cGUgPT0gXCJrZXl3b3JkIGNcIiB8fCB0eXBlID09IFwiYXN5bmNcIikgcmV0dXJuIGNvbnQobm9Db21tYSA/IGV4cHJlc3Npb25Ob0NvbW1hIDogZXhwcmVzc2lvbik7XG4gICAgaWYgKHR5cGUgPT0gXCIoXCIpIHJldHVybiBjb250KHB1c2hsZXgoXCIpXCIpLCBtYXliZWV4cHJlc3Npb24sIGV4cGVjdChcIilcIiksIHBvcGxleCwgbWF5YmVvcCk7XG4gICAgaWYgKHR5cGUgPT0gXCJvcGVyYXRvclwiIHx8IHR5cGUgPT0gXCJzcHJlYWRcIikgcmV0dXJuIGNvbnQobm9Db21tYSA/IGV4cHJlc3Npb25Ob0NvbW1hIDogZXhwcmVzc2lvbik7XG4gICAgaWYgKHR5cGUgPT0gXCJbXCIpIHJldHVybiBjb250KHB1c2hsZXgoXCJdXCIpLCBhcnJheUxpdGVyYWwsIHBvcGxleCwgbWF5YmVvcCk7XG4gICAgaWYgKHR5cGUgPT0gXCJ7XCIpIHJldHVybiBjb250Q29tbWFzZXAob2JqcHJvcCwgXCJ9XCIsIG51bGwsIG1heWJlb3ApO1xuICAgIGlmICh0eXBlID09IFwicXVhc2lcIikgcmV0dXJuIHBhc3MocXVhc2ksIG1heWJlb3ApO1xuICAgIGlmICh0eXBlID09IFwibmV3XCIpIHJldHVybiBjb250KG1heWJlVGFyZ2V0KG5vQ29tbWEpKTtcbiAgICBpZiAodHlwZSA9PSBcImltcG9ydFwiKSByZXR1cm4gY29udChleHByZXNzaW9uKTtcbiAgICByZXR1cm4gY29udCgpO1xuICB9XG4gIGZ1bmN0aW9uIG1heWJlZXhwcmVzc2lvbih0eXBlKSB7XG4gICAgaWYgKHR5cGUubWF0Y2goL1s7XFx9XFwpXFxdLF0vKSkgcmV0dXJuIHBhc3MoKTtcbiAgICByZXR1cm4gcGFzcyhleHByZXNzaW9uKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1heWJlb3BlcmF0b3JDb21tYSh0eXBlLCB2YWx1ZSkge1xuICAgIGlmICh0eXBlID09IFwiLFwiKSByZXR1cm4gY29udChtYXliZWV4cHJlc3Npb24pO1xuICAgIHJldHVybiBtYXliZW9wZXJhdG9yTm9Db21tYSh0eXBlLCB2YWx1ZSwgZmFsc2UpO1xuICB9XG4gIGZ1bmN0aW9uIG1heWJlb3BlcmF0b3JOb0NvbW1hKHR5cGUsIHZhbHVlLCBub0NvbW1hKSB7XG4gICAgdmFyIG1lID0gbm9Db21tYSA9PSBmYWxzZSA/IG1heWJlb3BlcmF0b3JDb21tYSA6IG1heWJlb3BlcmF0b3JOb0NvbW1hO1xuICAgIHZhciBleHByID0gbm9Db21tYSA9PSBmYWxzZSA/IGV4cHJlc3Npb24gOiBleHByZXNzaW9uTm9Db21tYTtcbiAgICBpZiAodHlwZSA9PSBcIj0+XCIpIHJldHVybiBjb250KHB1c2hjb250ZXh0LCBub0NvbW1hID8gYXJyb3dCb2R5Tm9Db21tYSA6IGFycm93Qm9keSwgcG9wY29udGV4dCk7XG4gICAgaWYgKHR5cGUgPT0gXCJvcGVyYXRvclwiKSB7XG4gICAgICBpZiAoL1xcK1xcK3wtLS8udGVzdCh2YWx1ZSkgfHwgaXNUUyAmJiB2YWx1ZSA9PSBcIiFcIikgcmV0dXJuIGNvbnQobWUpO1xuICAgICAgaWYgKGlzVFMgJiYgdmFsdWUgPT0gXCI8XCIgJiYgY3guc3RyZWFtLm1hdGNoKC9eKFtePD5dfDxbXjw+XSo+KSo+XFxzKlxcKC8sIGZhbHNlKSlcbiAgICAgICAgcmV0dXJuIGNvbnQocHVzaGxleChcIj5cIiksIGNvbW1hc2VwKHR5cGVleHByLCBcIj5cIiksIHBvcGxleCwgbWUpO1xuICAgICAgaWYgKHZhbHVlID09IFwiP1wiKSByZXR1cm4gY29udChleHByZXNzaW9uLCBleHBlY3QoXCI6XCIpLCBleHByKTtcbiAgICAgIHJldHVybiBjb250KGV4cHIpO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PSBcInF1YXNpXCIpIHsgcmV0dXJuIHBhc3MocXVhc2ksIG1lKTsgfVxuICAgIGlmICh0eXBlID09IFwiO1wiKSByZXR1cm47XG4gICAgaWYgKHR5cGUgPT0gXCIoXCIpIHJldHVybiBjb250Q29tbWFzZXAoZXhwcmVzc2lvbk5vQ29tbWEsIFwiKVwiLCBcImNhbGxcIiwgbWUpO1xuICAgIGlmICh0eXBlID09IFwiLlwiKSByZXR1cm4gY29udChwcm9wZXJ0eSwgbWUpO1xuICAgIGlmICh0eXBlID09IFwiW1wiKSByZXR1cm4gY29udChwdXNobGV4KFwiXVwiKSwgbWF5YmVleHByZXNzaW9uLCBleHBlY3QoXCJdXCIpLCBwb3BsZXgsIG1lKTtcbiAgICBpZiAoaXNUUyAmJiB2YWx1ZSA9PSBcImFzXCIpIHsgY3gubWFya2VkID0gXCJrZXl3b3JkXCI7IHJldHVybiBjb250KHR5cGVleHByLCBtZSkgfVxuICAgIGlmICh0eXBlID09IFwicmVnZXhwXCIpIHtcbiAgICAgIGN4LnN0YXRlLmxhc3RUeXBlID0gY3gubWFya2VkID0gXCJvcGVyYXRvclwiXG4gICAgICBjeC5zdHJlYW0uYmFja1VwKGN4LnN0cmVhbS5wb3MgLSBjeC5zdHJlYW0uc3RhcnQgLSAxKVxuICAgICAgcmV0dXJuIGNvbnQoZXhwcilcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcXVhc2kodHlwZSwgdmFsdWUpIHtcbiAgICBpZiAodHlwZSAhPSBcInF1YXNpXCIpIHJldHVybiBwYXNzKCk7XG4gICAgaWYgKHZhbHVlLnNsaWNlKHZhbHVlLmxlbmd0aCAtIDIpICE9IFwiJHtcIikgcmV0dXJuIGNvbnQocXVhc2kpO1xuICAgIHJldHVybiBjb250KGV4cHJlc3Npb24sIGNvbnRpbnVlUXVhc2kpO1xuICB9XG4gIGZ1bmN0aW9uIGNvbnRpbnVlUXVhc2kodHlwZSkge1xuICAgIGlmICh0eXBlID09IFwifVwiKSB7XG4gICAgICBjeC5tYXJrZWQgPSBcInN0cmluZy0yXCI7XG4gICAgICBjeC5zdGF0ZS50b2tlbml6ZSA9IHRva2VuUXVhc2k7XG4gICAgICByZXR1cm4gY29udChxdWFzaSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGFycm93Qm9keSh0eXBlKSB7XG4gICAgZmluZEZhdEFycm93KGN4LnN0cmVhbSwgY3guc3RhdGUpO1xuICAgIHJldHVybiBwYXNzKHR5cGUgPT0gXCJ7XCIgPyBzdGF0ZW1lbnQgOiBleHByZXNzaW9uKTtcbiAgfVxuICBmdW5jdGlvbiBhcnJvd0JvZHlOb0NvbW1hKHR5cGUpIHtcbiAgICBmaW5kRmF0QXJyb3coY3guc3RyZWFtLCBjeC5zdGF0ZSk7XG4gICAgcmV0dXJuIHBhc3ModHlwZSA9PSBcIntcIiA/IHN0YXRlbWVudCA6IGV4cHJlc3Npb25Ob0NvbW1hKTtcbiAgfVxuICBmdW5jdGlvbiBtYXliZVRhcmdldChub0NvbW1hKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgIGlmICh0eXBlID09IFwiLlwiKSByZXR1cm4gY29udChub0NvbW1hID8gdGFyZ2V0Tm9Db21tYSA6IHRhcmdldCk7XG4gICAgICBlbHNlIGlmICh0eXBlID09IFwidmFyaWFibGVcIiAmJiBpc1RTKSByZXR1cm4gY29udChtYXliZVR5cGVBcmdzLCBub0NvbW1hID8gbWF5YmVvcGVyYXRvck5vQ29tbWEgOiBtYXliZW9wZXJhdG9yQ29tbWEpXG4gICAgICBlbHNlIHJldHVybiBwYXNzKG5vQ29tbWEgPyBleHByZXNzaW9uTm9Db21tYSA6IGV4cHJlc3Npb24pO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gdGFyZ2V0KF8sIHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09IFwidGFyZ2V0XCIpIHsgY3gubWFya2VkID0gXCJrZXl3b3JkXCI7IHJldHVybiBjb250KG1heWJlb3BlcmF0b3JDb21tYSk7IH1cbiAgfVxuICBmdW5jdGlvbiB0YXJnZXROb0NvbW1hKF8sIHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09IFwidGFyZ2V0XCIpIHsgY3gubWFya2VkID0gXCJrZXl3b3JkXCI7IHJldHVybiBjb250KG1heWJlb3BlcmF0b3JOb0NvbW1hKTsgfVxuICB9XG4gIGZ1bmN0aW9uIG1heWJlbGFiZWwodHlwZSkge1xuICAgIGlmICh0eXBlID09IFwiOlwiKSByZXR1cm4gY29udChwb3BsZXgsIHN0YXRlbWVudCk7XG4gICAgcmV0dXJuIHBhc3MobWF5YmVvcGVyYXRvckNvbW1hLCBleHBlY3QoXCI7XCIpLCBwb3BsZXgpO1xuICB9XG4gIGZ1bmN0aW9uIHByb3BlcnR5KHR5cGUpIHtcbiAgICBpZiAodHlwZSA9PSBcInZhcmlhYmxlXCIpIHtjeC5tYXJrZWQgPSBcInByb3BlcnR5XCI7IHJldHVybiBjb250KCk7fVxuICB9XG4gIGZ1bmN0aW9uIG9ianByb3AodHlwZSwgdmFsdWUpIHtcbiAgICBpZiAodHlwZSA9PSBcImFzeW5jXCIpIHtcbiAgICAgIGN4Lm1hcmtlZCA9IFwicHJvcGVydHlcIjtcbiAgICAgIHJldHVybiBjb250KG9ianByb3ApO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PSBcInZhcmlhYmxlXCIgfHwgY3guc3R5bGUgPT0gXCJrZXl3b3JkXCIpIHtcbiAgICAgIGN4Lm1hcmtlZCA9IFwicHJvcGVydHlcIjtcbiAgICAgIGlmICh2YWx1ZSA9PSBcImdldFwiIHx8IHZhbHVlID09IFwic2V0XCIpIHJldHVybiBjb250KGdldHRlclNldHRlcik7XG4gICAgICB2YXIgbSAvLyBXb3JrIGFyb3VuZCBmYXQtYXJyb3ctZGV0ZWN0aW9uIGNvbXBsaWNhdGlvbiBmb3IgZGV0ZWN0aW5nIHR5cGVzY3JpcHQgdHlwZWQgYXJyb3cgcGFyYW1zXG4gICAgICBpZiAoaXNUUyAmJiBjeC5zdGF0ZS5mYXRBcnJvd0F0ID09IGN4LnN0cmVhbS5zdGFydCAmJiAobSA9IGN4LnN0cmVhbS5tYXRjaCgvXlxccyo6XFxzKi8sIGZhbHNlKSkpXG4gICAgICAgIGN4LnN0YXRlLmZhdEFycm93QXQgPSBjeC5zdHJlYW0ucG9zICsgbVswXS5sZW5ndGhcbiAgICAgIHJldHVybiBjb250KGFmdGVycHJvcCk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09IFwibnVtYmVyXCIgfHwgdHlwZSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICBjeC5tYXJrZWQgPSBqc29ubGRNb2RlID8gXCJwcm9wZXJ0eVwiIDogKGN4LnN0eWxlICsgXCIgcHJvcGVydHlcIik7XG4gICAgICByZXR1cm4gY29udChhZnRlcnByb3ApO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PSBcImpzb25sZC1rZXl3b3JkXCIpIHtcbiAgICAgIHJldHVybiBjb250KGFmdGVycHJvcCk7XG4gICAgfSBlbHNlIGlmIChpc1RTICYmIGlzTW9kaWZpZXIodmFsdWUpKSB7XG4gICAgICBjeC5tYXJrZWQgPSBcImtleXdvcmRcIlxuICAgICAgcmV0dXJuIGNvbnQob2JqcHJvcClcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT0gXCJbXCIpIHtcbiAgICAgIHJldHVybiBjb250KGV4cHJlc3Npb24sIG1heWJldHlwZSwgZXhwZWN0KFwiXVwiKSwgYWZ0ZXJwcm9wKTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT0gXCJzcHJlYWRcIikge1xuICAgICAgcmV0dXJuIGNvbnQoZXhwcmVzc2lvbk5vQ29tbWEsIGFmdGVycHJvcCk7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSA9PSBcIipcIikge1xuICAgICAgY3gubWFya2VkID0gXCJrZXl3b3JkXCI7XG4gICAgICByZXR1cm4gY29udChvYmpwcm9wKTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT0gXCI6XCIpIHtcbiAgICAgIHJldHVybiBwYXNzKGFmdGVycHJvcClcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZ2V0dGVyU2V0dGVyKHR5cGUpIHtcbiAgICBpZiAodHlwZSAhPSBcInZhcmlhYmxlXCIpIHJldHVybiBwYXNzKGFmdGVycHJvcCk7XG4gICAgY3gubWFya2VkID0gXCJwcm9wZXJ0eVwiO1xuICAgIHJldHVybiBjb250KGZ1bmN0aW9uZGVmKTtcbiAgfVxuICBmdW5jdGlvbiBhZnRlcnByb3AodHlwZSkge1xuICAgIGlmICh0eXBlID09IFwiOlwiKSByZXR1cm4gY29udChleHByZXNzaW9uTm9Db21tYSk7XG4gICAgaWYgKHR5cGUgPT0gXCIoXCIpIHJldHVybiBwYXNzKGZ1bmN0aW9uZGVmKTtcbiAgfVxuICBmdW5jdGlvbiBjb21tYXNlcCh3aGF0LCBlbmQsIHNlcCkge1xuICAgIGZ1bmN0aW9uIHByb2NlZWQodHlwZSwgdmFsdWUpIHtcbiAgICAgIGlmIChzZXAgPyBzZXAuaW5kZXhPZih0eXBlKSA+IC0xIDogdHlwZSA9PSBcIixcIikge1xuICAgICAgICB2YXIgbGV4ID0gY3guc3RhdGUubGV4aWNhbDtcbiAgICAgICAgaWYgKGxleC5pbmZvID09IFwiY2FsbFwiKSBsZXgucG9zID0gKGxleC5wb3MgfHwgMCkgKyAxO1xuICAgICAgICByZXR1cm4gY29udChmdW5jdGlvbih0eXBlLCB2YWx1ZSkge1xuICAgICAgICAgIGlmICh0eXBlID09IGVuZCB8fCB2YWx1ZSA9PSBlbmQpIHJldHVybiBwYXNzKClcbiAgICAgICAgICByZXR1cm4gcGFzcyh3aGF0KVxuICAgICAgICB9LCBwcm9jZWVkKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlID09IGVuZCB8fCB2YWx1ZSA9PSBlbmQpIHJldHVybiBjb250KCk7XG4gICAgICBpZiAoc2VwICYmIHNlcC5pbmRleE9mKFwiO1wiKSA+IC0xKSByZXR1cm4gcGFzcyh3aGF0KVxuICAgICAgcmV0dXJuIGNvbnQoZXhwZWN0KGVuZCkpO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24odHlwZSwgdmFsdWUpIHtcbiAgICAgIGlmICh0eXBlID09IGVuZCB8fCB2YWx1ZSA9PSBlbmQpIHJldHVybiBjb250KCk7XG4gICAgICByZXR1cm4gcGFzcyh3aGF0LCBwcm9jZWVkKTtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGNvbnRDb21tYXNlcCh3aGF0LCBlbmQsIGluZm8pIHtcbiAgICBmb3IgKHZhciBpID0gMzsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcbiAgICAgIGN4LmNjLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgICByZXR1cm4gY29udChwdXNobGV4KGVuZCwgaW5mbyksIGNvbW1hc2VwKHdoYXQsIGVuZCksIHBvcGxleCk7XG4gIH1cbiAgZnVuY3Rpb24gYmxvY2sodHlwZSkge1xuICAgIGlmICh0eXBlID09IFwifVwiKSByZXR1cm4gY29udCgpO1xuICAgIHJldHVybiBwYXNzKHN0YXRlbWVudCwgYmxvY2spO1xuICB9XG4gIGZ1bmN0aW9uIG1heWJldHlwZSh0eXBlLCB2YWx1ZSkge1xuICAgIGlmIChpc1RTKSB7XG4gICAgICBpZiAodHlwZSA9PSBcIjpcIikgcmV0dXJuIGNvbnQodHlwZWV4cHIpO1xuICAgICAgaWYgKHZhbHVlID09IFwiP1wiKSByZXR1cm4gY29udChtYXliZXR5cGUpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBtYXliZXR5cGVPckluKHR5cGUsIHZhbHVlKSB7XG4gICAgaWYgKGlzVFMgJiYgKHR5cGUgPT0gXCI6XCIgfHwgdmFsdWUgPT0gXCJpblwiKSkgcmV0dXJuIGNvbnQodHlwZWV4cHIpXG4gIH1cbiAgZnVuY3Rpb24gbWF5YmVyZXR0eXBlKHR5cGUpIHtcbiAgICBpZiAoaXNUUyAmJiB0eXBlID09IFwiOlwiKSB7XG4gICAgICBpZiAoY3guc3RyZWFtLm1hdGNoKC9eXFxzKlxcdytcXHMraXNcXGIvLCBmYWxzZSkpIHJldHVybiBjb250KGV4cHJlc3Npb24sIGlzS1csIHR5cGVleHByKVxuICAgICAgZWxzZSByZXR1cm4gY29udCh0eXBlZXhwcilcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gaXNLVyhfLCB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PSBcImlzXCIpIHtcbiAgICAgIGN4Lm1hcmtlZCA9IFwia2V5d29yZFwiXG4gICAgICByZXR1cm4gY29udCgpXG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHR5cGVleHByKHR5cGUsIHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09IFwia2V5b2ZcIiB8fCB2YWx1ZSA9PSBcInR5cGVvZlwiIHx8IHZhbHVlID09IFwiaW5mZXJcIikge1xuICAgICAgY3gubWFya2VkID0gXCJrZXl3b3JkXCJcbiAgICAgIHJldHVybiBjb250KHZhbHVlID09IFwidHlwZW9mXCIgPyBleHByZXNzaW9uTm9Db21tYSA6IHR5cGVleHByKVxuICAgIH1cbiAgICBpZiAodHlwZSA9PSBcInZhcmlhYmxlXCIgfHwgdmFsdWUgPT0gXCJ2b2lkXCIpIHtcbiAgICAgIGN4Lm1hcmtlZCA9IFwidHlwZVwiXG4gICAgICByZXR1cm4gY29udChhZnRlclR5cGUpXG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PSBcInxcIiB8fCB2YWx1ZSA9PSBcIiZcIikgcmV0dXJuIGNvbnQodHlwZWV4cHIpXG4gICAgaWYgKHR5cGUgPT0gXCJzdHJpbmdcIiB8fCB0eXBlID09IFwibnVtYmVyXCIgfHwgdHlwZSA9PSBcImF0b21cIikgcmV0dXJuIGNvbnQoYWZ0ZXJUeXBlKTtcbiAgICBpZiAodHlwZSA9PSBcIltcIikgcmV0dXJuIGNvbnQocHVzaGxleChcIl1cIiksIGNvbW1hc2VwKHR5cGVleHByLCBcIl1cIiwgXCIsXCIpLCBwb3BsZXgsIGFmdGVyVHlwZSlcbiAgICBpZiAodHlwZSA9PSBcIntcIikgcmV0dXJuIGNvbnQocHVzaGxleChcIn1cIiksIHR5cGVwcm9wcywgcG9wbGV4LCBhZnRlclR5cGUpXG4gICAgaWYgKHR5cGUgPT0gXCIoXCIpIHJldHVybiBjb250KGNvbW1hc2VwKHR5cGVhcmcsIFwiKVwiKSwgbWF5YmVSZXR1cm5UeXBlLCBhZnRlclR5cGUpXG4gICAgaWYgKHR5cGUgPT0gXCI8XCIpIHJldHVybiBjb250KGNvbW1hc2VwKHR5cGVleHByLCBcIj5cIiksIHR5cGVleHByKVxuICB9XG4gIGZ1bmN0aW9uIG1heWJlUmV0dXJuVHlwZSh0eXBlKSB7XG4gICAgaWYgKHR5cGUgPT0gXCI9PlwiKSByZXR1cm4gY29udCh0eXBlZXhwcilcbiAgfVxuICBmdW5jdGlvbiB0eXBlcHJvcHModHlwZSkge1xuICAgIGlmICh0eXBlID09IFwifVwiKSByZXR1cm4gY29udCgpXG4gICAgaWYgKHR5cGUgPT0gXCIsXCIgfHwgdHlwZSA9PSBcIjtcIikgcmV0dXJuIGNvbnQodHlwZXByb3BzKVxuICAgIHJldHVybiBwYXNzKHR5cGVwcm9wLCB0eXBlcHJvcHMpXG4gIH1cbiAgZnVuY3Rpb24gdHlwZXByb3AodHlwZSwgdmFsdWUpIHtcbiAgICBpZiAodHlwZSA9PSBcInZhcmlhYmxlXCIgfHwgY3guc3R5bGUgPT0gXCJrZXl3b3JkXCIpIHtcbiAgICAgIGN4Lm1hcmtlZCA9IFwicHJvcGVydHlcIlxuICAgICAgcmV0dXJuIGNvbnQodHlwZXByb3ApXG4gICAgfSBlbHNlIGlmICh2YWx1ZSA9PSBcIj9cIiB8fCB0eXBlID09IFwibnVtYmVyXCIgfHwgdHlwZSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gY29udCh0eXBlcHJvcClcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT0gXCI6XCIpIHtcbiAgICAgIHJldHVybiBjb250KHR5cGVleHByKVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PSBcIltcIikge1xuICAgICAgcmV0dXJuIGNvbnQoZXhwZWN0KFwidmFyaWFibGVcIiksIG1heWJldHlwZU9ySW4sIGV4cGVjdChcIl1cIiksIHR5cGVwcm9wKVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PSBcIihcIikge1xuICAgICAgcmV0dXJuIHBhc3MoZnVuY3Rpb25kZWNsLCB0eXBlcHJvcClcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gdHlwZWFyZyh0eXBlLCB2YWx1ZSkge1xuICAgIGlmICh0eXBlID09IFwidmFyaWFibGVcIiAmJiBjeC5zdHJlYW0ubWF0Y2goL15cXHMqWz86XS8sIGZhbHNlKSB8fCB2YWx1ZSA9PSBcIj9cIikgcmV0dXJuIGNvbnQodHlwZWFyZylcbiAgICBpZiAodHlwZSA9PSBcIjpcIikgcmV0dXJuIGNvbnQodHlwZWV4cHIpXG4gICAgaWYgKHR5cGUgPT0gXCJzcHJlYWRcIikgcmV0dXJuIGNvbnQodHlwZWFyZylcbiAgICByZXR1cm4gcGFzcyh0eXBlZXhwcilcbiAgfVxuICBmdW5jdGlvbiBhZnRlclR5cGUodHlwZSwgdmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT0gXCI8XCIpIHJldHVybiBjb250KHB1c2hsZXgoXCI+XCIpLCBjb21tYXNlcCh0eXBlZXhwciwgXCI+XCIpLCBwb3BsZXgsIGFmdGVyVHlwZSlcbiAgICBpZiAodmFsdWUgPT0gXCJ8XCIgfHwgdHlwZSA9PSBcIi5cIiB8fCB2YWx1ZSA9PSBcIiZcIikgcmV0dXJuIGNvbnQodHlwZWV4cHIpXG4gICAgaWYgKHR5cGUgPT0gXCJbXCIpIHJldHVybiBjb250KHR5cGVleHByLCBleHBlY3QoXCJdXCIpLCBhZnRlclR5cGUpXG4gICAgaWYgKHZhbHVlID09IFwiZXh0ZW5kc1wiIHx8IHZhbHVlID09IFwiaW1wbGVtZW50c1wiKSB7IGN4Lm1hcmtlZCA9IFwia2V5d29yZFwiOyByZXR1cm4gY29udCh0eXBlZXhwcikgfVxuICAgIGlmICh2YWx1ZSA9PSBcIj9cIikgcmV0dXJuIGNvbnQodHlwZWV4cHIsIGV4cGVjdChcIjpcIiksIHR5cGVleHByKVxuICB9XG4gIGZ1bmN0aW9uIG1heWJlVHlwZUFyZ3MoXywgdmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT0gXCI8XCIpIHJldHVybiBjb250KHB1c2hsZXgoXCI+XCIpLCBjb21tYXNlcCh0eXBlZXhwciwgXCI+XCIpLCBwb3BsZXgsIGFmdGVyVHlwZSlcbiAgfVxuICBmdW5jdGlvbiB0eXBlcGFyYW0oKSB7XG4gICAgcmV0dXJuIHBhc3ModHlwZWV4cHIsIG1heWJlVHlwZURlZmF1bHQpXG4gIH1cbiAgZnVuY3Rpb24gbWF5YmVUeXBlRGVmYXVsdChfLCB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PSBcIj1cIikgcmV0dXJuIGNvbnQodHlwZWV4cHIpXG4gIH1cbiAgZnVuY3Rpb24gdmFyZGVmKF8sIHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09IFwiZW51bVwiKSB7Y3gubWFya2VkID0gXCJrZXl3b3JkXCI7IHJldHVybiBjb250KGVudW1kZWYpfVxuICAgIHJldHVybiBwYXNzKHBhdHRlcm4sIG1heWJldHlwZSwgbWF5YmVBc3NpZ24sIHZhcmRlZkNvbnQpO1xuICB9XG4gIGZ1bmN0aW9uIHBhdHRlcm4odHlwZSwgdmFsdWUpIHtcbiAgICBpZiAoaXNUUyAmJiBpc01vZGlmaWVyKHZhbHVlKSkgeyBjeC5tYXJrZWQgPSBcImtleXdvcmRcIjsgcmV0dXJuIGNvbnQocGF0dGVybikgfVxuICAgIGlmICh0eXBlID09IFwidmFyaWFibGVcIikgeyByZWdpc3Rlcih2YWx1ZSk7IHJldHVybiBjb250KCk7IH1cbiAgICBpZiAodHlwZSA9PSBcInNwcmVhZFwiKSByZXR1cm4gY29udChwYXR0ZXJuKTtcbiAgICBpZiAodHlwZSA9PSBcIltcIikgcmV0dXJuIGNvbnRDb21tYXNlcChlbHRwYXR0ZXJuLCBcIl1cIik7XG4gICAgaWYgKHR5cGUgPT0gXCJ7XCIpIHJldHVybiBjb250Q29tbWFzZXAocHJvcHBhdHRlcm4sIFwifVwiKTtcbiAgfVxuICBmdW5jdGlvbiBwcm9wcGF0dGVybih0eXBlLCB2YWx1ZSkge1xuICAgIGlmICh0eXBlID09IFwidmFyaWFibGVcIiAmJiAhY3guc3RyZWFtLm1hdGNoKC9eXFxzKjovLCBmYWxzZSkpIHtcbiAgICAgIHJlZ2lzdGVyKHZhbHVlKTtcbiAgICAgIHJldHVybiBjb250KG1heWJlQXNzaWduKTtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT0gXCJ2YXJpYWJsZVwiKSBjeC5tYXJrZWQgPSBcInByb3BlcnR5XCI7XG4gICAgaWYgKHR5cGUgPT0gXCJzcHJlYWRcIikgcmV0dXJuIGNvbnQocGF0dGVybik7XG4gICAgaWYgKHR5cGUgPT0gXCJ9XCIpIHJldHVybiBwYXNzKCk7XG4gICAgaWYgKHR5cGUgPT0gXCJbXCIpIHJldHVybiBjb250KGV4cHJlc3Npb24sIGV4cGVjdCgnXScpLCBleHBlY3QoJzonKSwgcHJvcHBhdHRlcm4pO1xuICAgIHJldHVybiBjb250KGV4cGVjdChcIjpcIiksIHBhdHRlcm4sIG1heWJlQXNzaWduKTtcbiAgfVxuICBmdW5jdGlvbiBlbHRwYXR0ZXJuKCkge1xuICAgIHJldHVybiBwYXNzKHBhdHRlcm4sIG1heWJlQXNzaWduKVxuICB9XG4gIGZ1bmN0aW9uIG1heWJlQXNzaWduKF90eXBlLCB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PSBcIj1cIikgcmV0dXJuIGNvbnQoZXhwcmVzc2lvbk5vQ29tbWEpO1xuICB9XG4gIGZ1bmN0aW9uIHZhcmRlZkNvbnQodHlwZSkge1xuICAgIGlmICh0eXBlID09IFwiLFwiKSByZXR1cm4gY29udCh2YXJkZWYpO1xuICB9XG4gIGZ1bmN0aW9uIG1heWJlZWxzZSh0eXBlLCB2YWx1ZSkge1xuICAgIGlmICh0eXBlID09IFwia2V5d29yZCBiXCIgJiYgdmFsdWUgPT0gXCJlbHNlXCIpIHJldHVybiBjb250KHB1c2hsZXgoXCJmb3JtXCIsIFwiZWxzZVwiKSwgc3RhdGVtZW50LCBwb3BsZXgpO1xuICB9XG4gIGZ1bmN0aW9uIGZvcnNwZWModHlwZSwgdmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT0gXCJhd2FpdFwiKSByZXR1cm4gY29udChmb3JzcGVjKTtcbiAgICBpZiAodHlwZSA9PSBcIihcIikgcmV0dXJuIGNvbnQocHVzaGxleChcIilcIiksIGZvcnNwZWMxLCBwb3BsZXgpO1xuICB9XG4gIGZ1bmN0aW9uIGZvcnNwZWMxKHR5cGUpIHtcbiAgICBpZiAodHlwZSA9PSBcInZhclwiKSByZXR1cm4gY29udCh2YXJkZWYsIGZvcnNwZWMyKTtcbiAgICBpZiAodHlwZSA9PSBcInZhcmlhYmxlXCIpIHJldHVybiBjb250KGZvcnNwZWMyKTtcbiAgICByZXR1cm4gcGFzcyhmb3JzcGVjMilcbiAgfVxuICBmdW5jdGlvbiBmb3JzcGVjMih0eXBlLCB2YWx1ZSkge1xuICAgIGlmICh0eXBlID09IFwiKVwiKSByZXR1cm4gY29udCgpXG4gICAgaWYgKHR5cGUgPT0gXCI7XCIpIHJldHVybiBjb250KGZvcnNwZWMyKVxuICAgIGlmICh2YWx1ZSA9PSBcImluXCIgfHwgdmFsdWUgPT0gXCJvZlwiKSB7IGN4Lm1hcmtlZCA9IFwia2V5d29yZFwiOyByZXR1cm4gY29udChleHByZXNzaW9uLCBmb3JzcGVjMikgfVxuICAgIHJldHVybiBwYXNzKGV4cHJlc3Npb24sIGZvcnNwZWMyKVxuICB9XG4gIGZ1bmN0aW9uIGZ1bmN0aW9uZGVmKHR5cGUsIHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09IFwiKlwiKSB7Y3gubWFya2VkID0gXCJrZXl3b3JkXCI7IHJldHVybiBjb250KGZ1bmN0aW9uZGVmKTt9XG4gICAgaWYgKHR5cGUgPT0gXCJ2YXJpYWJsZVwiKSB7cmVnaXN0ZXIodmFsdWUpOyByZXR1cm4gY29udChmdW5jdGlvbmRlZik7fVxuICAgIGlmICh0eXBlID09IFwiKFwiKSByZXR1cm4gY29udChwdXNoY29udGV4dCwgcHVzaGxleChcIilcIiksIGNvbW1hc2VwKGZ1bmFyZywgXCIpXCIpLCBwb3BsZXgsIG1heWJlcmV0dHlwZSwgc3RhdGVtZW50LCBwb3Bjb250ZXh0KTtcbiAgICBpZiAoaXNUUyAmJiB2YWx1ZSA9PSBcIjxcIikgcmV0dXJuIGNvbnQocHVzaGxleChcIj5cIiksIGNvbW1hc2VwKHR5cGVwYXJhbSwgXCI+XCIpLCBwb3BsZXgsIGZ1bmN0aW9uZGVmKVxuICB9XG4gIGZ1bmN0aW9uIGZ1bmN0aW9uZGVjbCh0eXBlLCB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PSBcIipcIikge2N4Lm1hcmtlZCA9IFwia2V5d29yZFwiOyByZXR1cm4gY29udChmdW5jdGlvbmRlY2wpO31cbiAgICBpZiAodHlwZSA9PSBcInZhcmlhYmxlXCIpIHtyZWdpc3Rlcih2YWx1ZSk7IHJldHVybiBjb250KGZ1bmN0aW9uZGVjbCk7fVxuICAgIGlmICh0eXBlID09IFwiKFwiKSByZXR1cm4gY29udChwdXNoY29udGV4dCwgcHVzaGxleChcIilcIiksIGNvbW1hc2VwKGZ1bmFyZywgXCIpXCIpLCBwb3BsZXgsIG1heWJlcmV0dHlwZSwgcG9wY29udGV4dCk7XG4gICAgaWYgKGlzVFMgJiYgdmFsdWUgPT0gXCI8XCIpIHJldHVybiBjb250KHB1c2hsZXgoXCI+XCIpLCBjb21tYXNlcCh0eXBlcGFyYW0sIFwiPlwiKSwgcG9wbGV4LCBmdW5jdGlvbmRlY2wpXG4gIH1cbiAgZnVuY3Rpb24gdHlwZW5hbWUodHlwZSwgdmFsdWUpIHtcbiAgICBpZiAodHlwZSA9PSBcImtleXdvcmRcIiB8fCB0eXBlID09IFwidmFyaWFibGVcIikge1xuICAgICAgY3gubWFya2VkID0gXCJ0eXBlXCJcbiAgICAgIHJldHVybiBjb250KHR5cGVuYW1lKVxuICAgIH0gZWxzZSBpZiAodmFsdWUgPT0gXCI8XCIpIHtcbiAgICAgIHJldHVybiBjb250KHB1c2hsZXgoXCI+XCIpLCBjb21tYXNlcCh0eXBlcGFyYW0sIFwiPlwiKSwgcG9wbGV4KVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBmdW5hcmcodHlwZSwgdmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT0gXCJAXCIpIGNvbnQoZXhwcmVzc2lvbiwgZnVuYXJnKVxuICAgIGlmICh0eXBlID09IFwic3ByZWFkXCIpIHJldHVybiBjb250KGZ1bmFyZyk7XG4gICAgaWYgKGlzVFMgJiYgaXNNb2RpZmllcih2YWx1ZSkpIHsgY3gubWFya2VkID0gXCJrZXl3b3JkXCI7IHJldHVybiBjb250KGZ1bmFyZyk7IH1cbiAgICBpZiAoaXNUUyAmJiB0eXBlID09IFwidGhpc1wiKSByZXR1cm4gY29udChtYXliZXR5cGUsIG1heWJlQXNzaWduKVxuICAgIHJldHVybiBwYXNzKHBhdHRlcm4sIG1heWJldHlwZSwgbWF5YmVBc3NpZ24pO1xuICB9XG4gIGZ1bmN0aW9uIGNsYXNzRXhwcmVzc2lvbih0eXBlLCB2YWx1ZSkge1xuICAgIC8vIENsYXNzIGV4cHJlc3Npb25zIG1heSBoYXZlIGFuIG9wdGlvbmFsIG5hbWUuXG4gICAgaWYgKHR5cGUgPT0gXCJ2YXJpYWJsZVwiKSByZXR1cm4gY2xhc3NOYW1lKHR5cGUsIHZhbHVlKTtcbiAgICByZXR1cm4gY2xhc3NOYW1lQWZ0ZXIodHlwZSwgdmFsdWUpO1xuICB9XG4gIGZ1bmN0aW9uIGNsYXNzTmFtZSh0eXBlLCB2YWx1ZSkge1xuICAgIGlmICh0eXBlID09IFwidmFyaWFibGVcIikge3JlZ2lzdGVyKHZhbHVlKTsgcmV0dXJuIGNvbnQoY2xhc3NOYW1lQWZ0ZXIpO31cbiAgfVxuICBmdW5jdGlvbiBjbGFzc05hbWVBZnRlcih0eXBlLCB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PSBcIjxcIikgcmV0dXJuIGNvbnQocHVzaGxleChcIj5cIiksIGNvbW1hc2VwKHR5cGVwYXJhbSwgXCI+XCIpLCBwb3BsZXgsIGNsYXNzTmFtZUFmdGVyKVxuICAgIGlmICh2YWx1ZSA9PSBcImV4dGVuZHNcIiB8fCB2YWx1ZSA9PSBcImltcGxlbWVudHNcIiB8fCAoaXNUUyAmJiB0eXBlID09IFwiLFwiKSkge1xuICAgICAgaWYgKHZhbHVlID09IFwiaW1wbGVtZW50c1wiKSBjeC5tYXJrZWQgPSBcImtleXdvcmRcIjtcbiAgICAgIHJldHVybiBjb250KGlzVFMgPyB0eXBlZXhwciA6IGV4cHJlc3Npb24sIGNsYXNzTmFtZUFmdGVyKTtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT0gXCJ7XCIpIHJldHVybiBjb250KHB1c2hsZXgoXCJ9XCIpLCBjbGFzc0JvZHksIHBvcGxleCk7XG4gIH1cbiAgZnVuY3Rpb24gY2xhc3NCb2R5KHR5cGUsIHZhbHVlKSB7XG4gICAgaWYgKHR5cGUgPT0gXCJhc3luY1wiIHx8XG4gICAgICAgICh0eXBlID09IFwidmFyaWFibGVcIiAmJlxuICAgICAgICAgKHZhbHVlID09IFwic3RhdGljXCIgfHwgdmFsdWUgPT0gXCJnZXRcIiB8fCB2YWx1ZSA9PSBcInNldFwiIHx8IChpc1RTICYmIGlzTW9kaWZpZXIodmFsdWUpKSkgJiZcbiAgICAgICAgIGN4LnN0cmVhbS5tYXRjaCgvXlxccytbXFx3JFxceGExLVxcdWZmZmZdLywgZmFsc2UpKSkge1xuICAgICAgY3gubWFya2VkID0gXCJrZXl3b3JkXCI7XG4gICAgICByZXR1cm4gY29udChjbGFzc0JvZHkpO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PSBcInZhcmlhYmxlXCIgfHwgY3guc3R5bGUgPT0gXCJrZXl3b3JkXCIpIHtcbiAgICAgIGN4Lm1hcmtlZCA9IFwicHJvcGVydHlcIjtcbiAgICAgIHJldHVybiBjb250KGNsYXNzZmllbGQsIGNsYXNzQm9keSk7XG4gICAgfVxuICAgIGlmICh0eXBlID09IFwibnVtYmVyXCIgfHwgdHlwZSA9PSBcInN0cmluZ1wiKSByZXR1cm4gY29udChjbGFzc2ZpZWxkLCBjbGFzc0JvZHkpO1xuICAgIGlmICh0eXBlID09IFwiW1wiKVxuICAgICAgcmV0dXJuIGNvbnQoZXhwcmVzc2lvbiwgbWF5YmV0eXBlLCBleHBlY3QoXCJdXCIpLCBjbGFzc2ZpZWxkLCBjbGFzc0JvZHkpXG4gICAgaWYgKHZhbHVlID09IFwiKlwiKSB7XG4gICAgICBjeC5tYXJrZWQgPSBcImtleXdvcmRcIjtcbiAgICAgIHJldHVybiBjb250KGNsYXNzQm9keSk7XG4gICAgfVxuICAgIGlmIChpc1RTICYmIHR5cGUgPT0gXCIoXCIpIHJldHVybiBwYXNzKGZ1bmN0aW9uZGVjbCwgY2xhc3NCb2R5KVxuICAgIGlmICh0eXBlID09IFwiO1wiIHx8IHR5cGUgPT0gXCIsXCIpIHJldHVybiBjb250KGNsYXNzQm9keSk7XG4gICAgaWYgKHR5cGUgPT0gXCJ9XCIpIHJldHVybiBjb250KCk7XG4gICAgaWYgKHZhbHVlID09IFwiQFwiKSByZXR1cm4gY29udChleHByZXNzaW9uLCBjbGFzc0JvZHkpXG4gIH1cbiAgZnVuY3Rpb24gY2xhc3NmaWVsZCh0eXBlLCB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PSBcIj9cIikgcmV0dXJuIGNvbnQoY2xhc3NmaWVsZClcbiAgICBpZiAodHlwZSA9PSBcIjpcIikgcmV0dXJuIGNvbnQodHlwZWV4cHIsIG1heWJlQXNzaWduKVxuICAgIGlmICh2YWx1ZSA9PSBcIj1cIikgcmV0dXJuIGNvbnQoZXhwcmVzc2lvbk5vQ29tbWEpXG4gICAgdmFyIGNvbnRleHQgPSBjeC5zdGF0ZS5sZXhpY2FsLnByZXYsIGlzSW50ZXJmYWNlID0gY29udGV4dCAmJiBjb250ZXh0LmluZm8gPT0gXCJpbnRlcmZhY2VcIlxuICAgIHJldHVybiBwYXNzKGlzSW50ZXJmYWNlID8gZnVuY3Rpb25kZWNsIDogZnVuY3Rpb25kZWYpXG4gIH1cbiAgZnVuY3Rpb24gYWZ0ZXJFeHBvcnQodHlwZSwgdmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT0gXCIqXCIpIHsgY3gubWFya2VkID0gXCJrZXl3b3JkXCI7IHJldHVybiBjb250KG1heWJlRnJvbSwgZXhwZWN0KFwiO1wiKSk7IH1cbiAgICBpZiAodmFsdWUgPT0gXCJkZWZhdWx0XCIpIHsgY3gubWFya2VkID0gXCJrZXl3b3JkXCI7IHJldHVybiBjb250KGV4cHJlc3Npb24sIGV4cGVjdChcIjtcIikpOyB9XG4gICAgaWYgKHR5cGUgPT0gXCJ7XCIpIHJldHVybiBjb250KGNvbW1hc2VwKGV4cG9ydEZpZWxkLCBcIn1cIiksIG1heWJlRnJvbSwgZXhwZWN0KFwiO1wiKSk7XG4gICAgcmV0dXJuIHBhc3Moc3RhdGVtZW50KTtcbiAgfVxuICBmdW5jdGlvbiBleHBvcnRGaWVsZCh0eXBlLCB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PSBcImFzXCIpIHsgY3gubWFya2VkID0gXCJrZXl3b3JkXCI7IHJldHVybiBjb250KGV4cGVjdChcInZhcmlhYmxlXCIpKTsgfVxuICAgIGlmICh0eXBlID09IFwidmFyaWFibGVcIikgcmV0dXJuIHBhc3MoZXhwcmVzc2lvbk5vQ29tbWEsIGV4cG9ydEZpZWxkKTtcbiAgfVxuICBmdW5jdGlvbiBhZnRlckltcG9ydCh0eXBlKSB7XG4gICAgaWYgKHR5cGUgPT0gXCJzdHJpbmdcIikgcmV0dXJuIGNvbnQoKTtcbiAgICBpZiAodHlwZSA9PSBcIihcIikgcmV0dXJuIHBhc3MoZXhwcmVzc2lvbik7XG4gICAgcmV0dXJuIHBhc3MoaW1wb3J0U3BlYywgbWF5YmVNb3JlSW1wb3J0cywgbWF5YmVGcm9tKTtcbiAgfVxuICBmdW5jdGlvbiBpbXBvcnRTcGVjKHR5cGUsIHZhbHVlKSB7XG4gICAgaWYgKHR5cGUgPT0gXCJ7XCIpIHJldHVybiBjb250Q29tbWFzZXAoaW1wb3J0U3BlYywgXCJ9XCIpO1xuICAgIGlmICh0eXBlID09IFwidmFyaWFibGVcIikgcmVnaXN0ZXIodmFsdWUpO1xuICAgIGlmICh2YWx1ZSA9PSBcIipcIikgY3gubWFya2VkID0gXCJrZXl3b3JkXCI7XG4gICAgcmV0dXJuIGNvbnQobWF5YmVBcyk7XG4gIH1cbiAgZnVuY3Rpb24gbWF5YmVNb3JlSW1wb3J0cyh0eXBlKSB7XG4gICAgaWYgKHR5cGUgPT0gXCIsXCIpIHJldHVybiBjb250KGltcG9ydFNwZWMsIG1heWJlTW9yZUltcG9ydHMpXG4gIH1cbiAgZnVuY3Rpb24gbWF5YmVBcyhfdHlwZSwgdmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT0gXCJhc1wiKSB7IGN4Lm1hcmtlZCA9IFwia2V5d29yZFwiOyByZXR1cm4gY29udChpbXBvcnRTcGVjKTsgfVxuICB9XG4gIGZ1bmN0aW9uIG1heWJlRnJvbShfdHlwZSwgdmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT0gXCJmcm9tXCIpIHsgY3gubWFya2VkID0gXCJrZXl3b3JkXCI7IHJldHVybiBjb250KGV4cHJlc3Npb24pOyB9XG4gIH1cbiAgZnVuY3Rpb24gYXJyYXlMaXRlcmFsKHR5cGUpIHtcbiAgICBpZiAodHlwZSA9PSBcIl1cIikgcmV0dXJuIGNvbnQoKTtcbiAgICByZXR1cm4gcGFzcyhjb21tYXNlcChleHByZXNzaW9uTm9Db21tYSwgXCJdXCIpKTtcbiAgfVxuICBmdW5jdGlvbiBlbnVtZGVmKCkge1xuICAgIHJldHVybiBwYXNzKHB1c2hsZXgoXCJmb3JtXCIpLCBwYXR0ZXJuLCBleHBlY3QoXCJ7XCIpLCBwdXNobGV4KFwifVwiKSwgY29tbWFzZXAoZW51bW1lbWJlciwgXCJ9XCIpLCBwb3BsZXgsIHBvcGxleClcbiAgfVxuICBmdW5jdGlvbiBlbnVtbWVtYmVyKCkge1xuICAgIHJldHVybiBwYXNzKHBhdHRlcm4sIG1heWJlQXNzaWduKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzQ29udGludWVkU3RhdGVtZW50KHN0YXRlLCB0ZXh0QWZ0ZXIpIHtcbiAgICByZXR1cm4gc3RhdGUubGFzdFR5cGUgPT0gXCJvcGVyYXRvclwiIHx8IHN0YXRlLmxhc3RUeXBlID09IFwiLFwiIHx8XG4gICAgICBpc09wZXJhdG9yQ2hhci50ZXN0KHRleHRBZnRlci5jaGFyQXQoMCkpIHx8XG4gICAgICAvWywuXS8udGVzdCh0ZXh0QWZ0ZXIuY2hhckF0KDApKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGV4cHJlc3Npb25BbGxvd2VkKHN0cmVhbSwgc3RhdGUsIGJhY2tVcCkge1xuICAgIHJldHVybiBzdGF0ZS50b2tlbml6ZSA9PSB0b2tlbkJhc2UgJiZcbiAgICAgIC9eKD86b3BlcmF0b3J8c29mfGtleXdvcmQgW2JjZF18Y2FzZXxuZXd8ZXhwb3J0fGRlZmF1bHR8c3ByZWFkfFtcXFt7fVxcKCw7Ol18PT4pJC8udGVzdChzdGF0ZS5sYXN0VHlwZSkgfHxcbiAgICAgIChzdGF0ZS5sYXN0VHlwZSA9PSBcInF1YXNpXCIgJiYgL1xce1xccyokLy50ZXN0KHN0cmVhbS5zdHJpbmcuc2xpY2UoMCwgc3RyZWFtLnBvcyAtIChiYWNrVXAgfHwgMCkpKSlcbiAgfVxuXG4gIC8vIEludGVyZmFjZVxuXG4gIHJldHVybiB7XG4gICAgc3RhcnRTdGF0ZTogZnVuY3Rpb24oYmFzZWNvbHVtbikge1xuICAgICAgdmFyIHN0YXRlID0ge1xuICAgICAgICB0b2tlbml6ZTogdG9rZW5CYXNlLFxuICAgICAgICBsYXN0VHlwZTogXCJzb2ZcIixcbiAgICAgICAgY2M6IFtdLFxuICAgICAgICBsZXhpY2FsOiBuZXcgSlNMZXhpY2FsKChiYXNlY29sdW1uIHx8IDApIC0gaW5kZW50VW5pdCwgMCwgXCJibG9ja1wiLCBmYWxzZSksXG4gICAgICAgIGxvY2FsVmFyczogcGFyc2VyQ29uZmlnLmxvY2FsVmFycyxcbiAgICAgICAgY29udGV4dDogcGFyc2VyQ29uZmlnLmxvY2FsVmFycyAmJiBuZXcgQ29udGV4dChudWxsLCBudWxsLCBmYWxzZSksXG4gICAgICAgIGluZGVudGVkOiBiYXNlY29sdW1uIHx8IDBcbiAgICAgIH07XG4gICAgICBpZiAocGFyc2VyQ29uZmlnLmdsb2JhbFZhcnMgJiYgdHlwZW9mIHBhcnNlckNvbmZpZy5nbG9iYWxWYXJzID09IFwib2JqZWN0XCIpXG4gICAgICAgIHN0YXRlLmdsb2JhbFZhcnMgPSBwYXJzZXJDb25maWcuZ2xvYmFsVmFycztcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9LFxuXG4gICAgdG9rZW46IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIGlmIChzdHJlYW0uc29sKCkpIHtcbiAgICAgICAgaWYgKCFzdGF0ZS5sZXhpY2FsLmhhc093blByb3BlcnR5KFwiYWxpZ25cIikpXG4gICAgICAgICAgc3RhdGUubGV4aWNhbC5hbGlnbiA9IGZhbHNlO1xuICAgICAgICBzdGF0ZS5pbmRlbnRlZCA9IHN0cmVhbS5pbmRlbnRhdGlvbigpO1xuICAgICAgICBmaW5kRmF0QXJyb3coc3RyZWFtLCBzdGF0ZSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUudG9rZW5pemUgIT0gdG9rZW5Db21tZW50ICYmIHN0cmVhbS5lYXRTcGFjZSgpKSByZXR1cm4gbnVsbDtcbiAgICAgIHZhciBzdHlsZSA9IHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgaWYgKHR5cGUgPT0gXCJjb21tZW50XCIpIHJldHVybiBzdHlsZTtcbiAgICAgIHN0YXRlLmxhc3RUeXBlID0gdHlwZSA9PSBcIm9wZXJhdG9yXCIgJiYgKGNvbnRlbnQgPT0gXCIrK1wiIHx8IGNvbnRlbnQgPT0gXCItLVwiKSA/IFwiaW5jZGVjXCIgOiB0eXBlO1xuICAgICAgcmV0dXJuIHBhcnNlSlMoc3RhdGUsIHN0eWxlLCB0eXBlLCBjb250ZW50LCBzdHJlYW0pO1xuICAgIH0sXG5cbiAgICBpbmRlbnQ6IGZ1bmN0aW9uKHN0YXRlLCB0ZXh0QWZ0ZXIpIHtcbiAgICAgIGlmIChzdGF0ZS50b2tlbml6ZSA9PSB0b2tlbkNvbW1lbnQgfHwgc3RhdGUudG9rZW5pemUgPT0gdG9rZW5RdWFzaSkgcmV0dXJuIENvZGVNaXJyb3IuUGFzcztcbiAgICAgIGlmIChzdGF0ZS50b2tlbml6ZSAhPSB0b2tlbkJhc2UpIHJldHVybiAwO1xuICAgICAgdmFyIGZpcnN0Q2hhciA9IHRleHRBZnRlciAmJiB0ZXh0QWZ0ZXIuY2hhckF0KDApLCBsZXhpY2FsID0gc3RhdGUubGV4aWNhbCwgdG9wXG4gICAgICAvLyBLbHVkZ2UgdG8gcHJldmVudCAnbWF5YmVsc2UnIGZyb20gYmxvY2tpbmcgbGV4aWNhbCBzY29wZSBwb3BzXG4gICAgICBpZiAoIS9eXFxzKmVsc2VcXGIvLnRlc3QodGV4dEFmdGVyKSkgZm9yICh2YXIgaSA9IHN0YXRlLmNjLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBjID0gc3RhdGUuY2NbaV07XG4gICAgICAgIGlmIChjID09IHBvcGxleCkgbGV4aWNhbCA9IGxleGljYWwucHJldjtcbiAgICAgICAgZWxzZSBpZiAoYyAhPSBtYXliZWVsc2UpIGJyZWFrO1xuICAgICAgfVxuICAgICAgd2hpbGUgKChsZXhpY2FsLnR5cGUgPT0gXCJzdGF0XCIgfHwgbGV4aWNhbC50eXBlID09IFwiZm9ybVwiKSAmJlxuICAgICAgICAgICAgIChmaXJzdENoYXIgPT0gXCJ9XCIgfHwgKCh0b3AgPSBzdGF0ZS5jY1tzdGF0ZS5jYy5sZW5ndGggLSAxXSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHRvcCA9PSBtYXliZW9wZXJhdG9yQ29tbWEgfHwgdG9wID09IG1heWJlb3BlcmF0b3JOb0NvbW1hKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhL15bLFxcLj0rXFwtKjo/W1xcKF0vLnRlc3QodGV4dEFmdGVyKSkpKVxuICAgICAgICBsZXhpY2FsID0gbGV4aWNhbC5wcmV2O1xuICAgICAgaWYgKHN0YXRlbWVudEluZGVudCAmJiBsZXhpY2FsLnR5cGUgPT0gXCIpXCIgJiYgbGV4aWNhbC5wcmV2LnR5cGUgPT0gXCJzdGF0XCIpXG4gICAgICAgIGxleGljYWwgPSBsZXhpY2FsLnByZXY7XG4gICAgICB2YXIgdHlwZSA9IGxleGljYWwudHlwZSwgY2xvc2luZyA9IGZpcnN0Q2hhciA9PSB0eXBlO1xuXG4gICAgICBpZiAodHlwZSA9PSBcInZhcmRlZlwiKSByZXR1cm4gbGV4aWNhbC5pbmRlbnRlZCArIChzdGF0ZS5sYXN0VHlwZSA9PSBcIm9wZXJhdG9yXCIgfHwgc3RhdGUubGFzdFR5cGUgPT0gXCIsXCIgPyBsZXhpY2FsLmluZm8ubGVuZ3RoICsgMSA6IDApO1xuICAgICAgZWxzZSBpZiAodHlwZSA9PSBcImZvcm1cIiAmJiBmaXJzdENoYXIgPT0gXCJ7XCIpIHJldHVybiBsZXhpY2FsLmluZGVudGVkO1xuICAgICAgZWxzZSBpZiAodHlwZSA9PSBcImZvcm1cIikgcmV0dXJuIGxleGljYWwuaW5kZW50ZWQgKyBpbmRlbnRVbml0O1xuICAgICAgZWxzZSBpZiAodHlwZSA9PSBcInN0YXRcIilcbiAgICAgICAgcmV0dXJuIGxleGljYWwuaW5kZW50ZWQgKyAoaXNDb250aW51ZWRTdGF0ZW1lbnQoc3RhdGUsIHRleHRBZnRlcikgPyBzdGF0ZW1lbnRJbmRlbnQgfHwgaW5kZW50VW5pdCA6IDApO1xuICAgICAgZWxzZSBpZiAobGV4aWNhbC5pbmZvID09IFwic3dpdGNoXCIgJiYgIWNsb3NpbmcgJiYgcGFyc2VyQ29uZmlnLmRvdWJsZUluZGVudFN3aXRjaCAhPSBmYWxzZSlcbiAgICAgICAgcmV0dXJuIGxleGljYWwuaW5kZW50ZWQgKyAoL14oPzpjYXNlfGRlZmF1bHQpXFxiLy50ZXN0KHRleHRBZnRlcikgPyBpbmRlbnRVbml0IDogMiAqIGluZGVudFVuaXQpO1xuICAgICAgZWxzZSBpZiAobGV4aWNhbC5hbGlnbikgcmV0dXJuIGxleGljYWwuY29sdW1uICsgKGNsb3NpbmcgPyAwIDogMSk7XG4gICAgICBlbHNlIHJldHVybiBsZXhpY2FsLmluZGVudGVkICsgKGNsb3NpbmcgPyAwIDogaW5kZW50VW5pdCk7XG4gICAgfSxcblxuICAgIGVsZWN0cmljSW5wdXQ6IC9eXFxzKig/OmNhc2UgLio/OnxkZWZhdWx0OnxcXHt8XFx9KSQvLFxuICAgIGJsb2NrQ29tbWVudFN0YXJ0OiBqc29uTW9kZSA/IG51bGwgOiBcIi8qXCIsXG4gICAgYmxvY2tDb21tZW50RW5kOiBqc29uTW9kZSA/IG51bGwgOiBcIiovXCIsXG4gICAgYmxvY2tDb21tZW50Q29udGludWU6IGpzb25Nb2RlID8gbnVsbCA6IFwiICogXCIsXG4gICAgbGluZUNvbW1lbnQ6IGpzb25Nb2RlID8gbnVsbCA6IFwiLy9cIixcbiAgICBmb2xkOiBcImJyYWNlXCIsXG4gICAgY2xvc2VCcmFja2V0czogXCIoKVtde30nJ1xcXCJcXFwiYGBcIixcblxuICAgIGhlbHBlclR5cGU6IGpzb25Nb2RlID8gXCJqc29uXCIgOiBcImphdmFzY3JpcHRcIixcbiAgICBqc29ubGRNb2RlOiBqc29ubGRNb2RlLFxuICAgIGpzb25Nb2RlOiBqc29uTW9kZSxcblxuICAgIGV4cHJlc3Npb25BbGxvd2VkOiBleHByZXNzaW9uQWxsb3dlZCxcblxuICAgIHNraXBFeHByZXNzaW9uOiBmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgdmFyIHRvcCA9IHN0YXRlLmNjW3N0YXRlLmNjLmxlbmd0aCAtIDFdXG4gICAgICBpZiAodG9wID09IGV4cHJlc3Npb24gfHwgdG9wID09IGV4cHJlc3Npb25Ob0NvbW1hKSBzdGF0ZS5jYy5wb3AoKVxuICAgIH1cbiAgfTtcbn0pO1xuXG5Db2RlTWlycm9yLnJlZ2lzdGVySGVscGVyKFwid29yZENoYXJzXCIsIFwiamF2YXNjcmlwdFwiLCAvW1xcdyRdLyk7XG5cbkNvZGVNaXJyb3IuZGVmaW5lTUlNRShcInRleHQvamF2YXNjcmlwdFwiLCBcImphdmFzY3JpcHRcIik7XG5Db2RlTWlycm9yLmRlZmluZU1JTUUoXCJ0ZXh0L2VjbWFzY3JpcHRcIiwgXCJqYXZhc2NyaXB0XCIpO1xuQ29kZU1pcnJvci5kZWZpbmVNSU1FKFwiYXBwbGljYXRpb24vamF2YXNjcmlwdFwiLCBcImphdmFzY3JpcHRcIik7XG5Db2RlTWlycm9yLmRlZmluZU1JTUUoXCJhcHBsaWNhdGlvbi94LWphdmFzY3JpcHRcIiwgXCJqYXZhc2NyaXB0XCIpO1xuQ29kZU1pcnJvci5kZWZpbmVNSU1FKFwiYXBwbGljYXRpb24vZWNtYXNjcmlwdFwiLCBcImphdmFzY3JpcHRcIik7XG5Db2RlTWlycm9yLmRlZmluZU1JTUUoXCJhcHBsaWNhdGlvbi9qc29uXCIsIHtuYW1lOiBcImphdmFzY3JpcHRcIiwganNvbjogdHJ1ZX0pO1xuQ29kZU1pcnJvci5kZWZpbmVNSU1FKFwiYXBwbGljYXRpb24veC1qc29uXCIsIHtuYW1lOiBcImphdmFzY3JpcHRcIiwganNvbjogdHJ1ZX0pO1xuQ29kZU1pcnJvci5kZWZpbmVNSU1FKFwiYXBwbGljYXRpb24vbGQranNvblwiLCB7bmFtZTogXCJqYXZhc2NyaXB0XCIsIGpzb25sZDogdHJ1ZX0pO1xuQ29kZU1pcnJvci5kZWZpbmVNSU1FKFwidGV4dC90eXBlc2NyaXB0XCIsIHsgbmFtZTogXCJqYXZhc2NyaXB0XCIsIHR5cGVzY3JpcHQ6IHRydWUgfSk7XG5Db2RlTWlycm9yLmRlZmluZU1JTUUoXCJhcHBsaWNhdGlvbi90eXBlc2NyaXB0XCIsIHsgbmFtZTogXCJqYXZhc2NyaXB0XCIsIHR5cGVzY3JpcHQ6IHRydWUgfSk7XG5cbn0pO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/codemirror/mode/javascript/javascript.js\n");

/***/ }),

/***/ "./node_modules/codemirror/mode/xml/xml.js":
/*!*************************************************!*\
  !*** ./node_modules/codemirror/mode/xml/xml.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (true) // CommonJS\n    mod(__webpack_require__(/*! ../../lib/codemirror */ \"./node_modules/codemirror/lib/codemirror.js\"));\n  else {}\n})(function(CodeMirror) {\n\"use strict\";\n\nvar htmlConfig = {\n  autoSelfClosers: {'area': true, 'base': true, 'br': true, 'col': true, 'command': true,\n                    'embed': true, 'frame': true, 'hr': true, 'img': true, 'input': true,\n                    'keygen': true, 'link': true, 'meta': true, 'param': true, 'source': true,\n                    'track': true, 'wbr': true, 'menuitem': true},\n  implicitlyClosed: {'dd': true, 'li': true, 'optgroup': true, 'option': true, 'p': true,\n                     'rp': true, 'rt': true, 'tbody': true, 'td': true, 'tfoot': true,\n                     'th': true, 'tr': true},\n  contextGrabbers: {\n    'dd': {'dd': true, 'dt': true},\n    'dt': {'dd': true, 'dt': true},\n    'li': {'li': true},\n    'option': {'option': true, 'optgroup': true},\n    'optgroup': {'optgroup': true},\n    'p': {'address': true, 'article': true, 'aside': true, 'blockquote': true, 'dir': true,\n          'div': true, 'dl': true, 'fieldset': true, 'footer': true, 'form': true,\n          'h1': true, 'h2': true, 'h3': true, 'h4': true, 'h5': true, 'h6': true,\n          'header': true, 'hgroup': true, 'hr': true, 'menu': true, 'nav': true, 'ol': true,\n          'p': true, 'pre': true, 'section': true, 'table': true, 'ul': true},\n    'rp': {'rp': true, 'rt': true},\n    'rt': {'rp': true, 'rt': true},\n    'tbody': {'tbody': true, 'tfoot': true},\n    'td': {'td': true, 'th': true},\n    'tfoot': {'tbody': true},\n    'th': {'td': true, 'th': true},\n    'thead': {'tbody': true, 'tfoot': true},\n    'tr': {'tr': true}\n  },\n  doNotIndent: {\"pre\": true},\n  allowUnquoted: true,\n  allowMissing: true,\n  caseFold: true\n}\n\nvar xmlConfig = {\n  autoSelfClosers: {},\n  implicitlyClosed: {},\n  contextGrabbers: {},\n  doNotIndent: {},\n  allowUnquoted: false,\n  allowMissing: false,\n  allowMissingTagName: false,\n  caseFold: false\n}\n\nCodeMirror.defineMode(\"xml\", function(editorConf, config_) {\n  var indentUnit = editorConf.indentUnit\n  var config = {}\n  var defaults = config_.htmlMode ? htmlConfig : xmlConfig\n  for (var prop in defaults) config[prop] = defaults[prop]\n  for (var prop in config_) config[prop] = config_[prop]\n\n  // Return variables for tokenizers\n  var type, setStyle;\n\n  function inText(stream, state) {\n    function chain(parser) {\n      state.tokenize = parser;\n      return parser(stream, state);\n    }\n\n    var ch = stream.next();\n    if (ch == \"<\") {\n      if (stream.eat(\"!\")) {\n        if (stream.eat(\"[\")) {\n          if (stream.match(\"CDATA[\")) return chain(inBlock(\"atom\", \"]]>\"));\n          else return null;\n        } else if (stream.match(\"--\")) {\n          return chain(inBlock(\"comment\", \"-->\"));\n        } else if (stream.match(\"DOCTYPE\", true, true)) {\n          stream.eatWhile(/[\\w\\._\\-]/);\n          return chain(doctype(1));\n        } else {\n          return null;\n        }\n      } else if (stream.eat(\"?\")) {\n        stream.eatWhile(/[\\w\\._\\-]/);\n        state.tokenize = inBlock(\"meta\", \"?>\");\n        return \"meta\";\n      } else {\n        type = stream.eat(\"/\") ? \"closeTag\" : \"openTag\";\n        state.tokenize = inTag;\n        return \"tag bracket\";\n      }\n    } else if (ch == \"&\") {\n      var ok;\n      if (stream.eat(\"#\")) {\n        if (stream.eat(\"x\")) {\n          ok = stream.eatWhile(/[a-fA-F\\d]/) && stream.eat(\";\");\n        } else {\n          ok = stream.eatWhile(/[\\d]/) && stream.eat(\";\");\n        }\n      } else {\n        ok = stream.eatWhile(/[\\w\\.\\-:]/) && stream.eat(\";\");\n      }\n      return ok ? \"atom\" : \"error\";\n    } else {\n      stream.eatWhile(/[^&<]/);\n      return null;\n    }\n  }\n  inText.isInText = true;\n\n  function inTag(stream, state) {\n    var ch = stream.next();\n    if (ch == \">\" || (ch == \"/\" && stream.eat(\">\"))) {\n      state.tokenize = inText;\n      type = ch == \">\" ? \"endTag\" : \"selfcloseTag\";\n      return \"tag bracket\";\n    } else if (ch == \"=\") {\n      type = \"equals\";\n      return null;\n    } else if (ch == \"<\") {\n      state.tokenize = inText;\n      state.state = baseState;\n      state.tagName = state.tagStart = null;\n      var next = state.tokenize(stream, state);\n      return next ? next + \" tag error\" : \"tag error\";\n    } else if (/[\\'\\\"]/.test(ch)) {\n      state.tokenize = inAttribute(ch);\n      state.stringStartCol = stream.column();\n      return state.tokenize(stream, state);\n    } else {\n      stream.match(/^[^\\s\\u00a0=<>\\\"\\']*[^\\s\\u00a0=<>\\\"\\'\\/]/);\n      return \"word\";\n    }\n  }\n\n  function inAttribute(quote) {\n    var closure = function(stream, state) {\n      while (!stream.eol()) {\n        if (stream.next() == quote) {\n          state.tokenize = inTag;\n          break;\n        }\n      }\n      return \"string\";\n    };\n    closure.isInAttribute = true;\n    return closure;\n  }\n\n  function inBlock(style, terminator) {\n    return function(stream, state) {\n      while (!stream.eol()) {\n        if (stream.match(terminator)) {\n          state.tokenize = inText;\n          break;\n        }\n        stream.next();\n      }\n      return style;\n    }\n  }\n\n  function doctype(depth) {\n    return function(stream, state) {\n      var ch;\n      while ((ch = stream.next()) != null) {\n        if (ch == \"<\") {\n          state.tokenize = doctype(depth + 1);\n          return state.tokenize(stream, state);\n        } else if (ch == \">\") {\n          if (depth == 1) {\n            state.tokenize = inText;\n            break;\n          } else {\n            state.tokenize = doctype(depth - 1);\n            return state.tokenize(stream, state);\n          }\n        }\n      }\n      return \"meta\";\n    };\n  }\n\n  function Context(state, tagName, startOfLine) {\n    this.prev = state.context;\n    this.tagName = tagName || \"\";\n    this.indent = state.indented;\n    this.startOfLine = startOfLine;\n    if (config.doNotIndent.hasOwnProperty(tagName) || (state.context && state.context.noIndent))\n      this.noIndent = true;\n  }\n  function popContext(state) {\n    if (state.context) state.context = state.context.prev;\n  }\n  function maybePopContext(state, nextTagName) {\n    var parentTagName;\n    while (true) {\n      if (!state.context) {\n        return;\n      }\n      parentTagName = state.context.tagName;\n      if (!config.contextGrabbers.hasOwnProperty(parentTagName) ||\n          !config.contextGrabbers[parentTagName].hasOwnProperty(nextTagName)) {\n        return;\n      }\n      popContext(state);\n    }\n  }\n\n  function baseState(type, stream, state) {\n    if (type == \"openTag\") {\n      state.tagStart = stream.column();\n      return tagNameState;\n    } else if (type == \"closeTag\") {\n      return closeTagNameState;\n    } else {\n      return baseState;\n    }\n  }\n  function tagNameState(type, stream, state) {\n    if (type == \"word\") {\n      state.tagName = stream.current();\n      setStyle = \"tag\";\n      return attrState;\n    } else if (config.allowMissingTagName && type == \"endTag\") {\n      setStyle = \"tag bracket\";\n      return attrState(type, stream, state);\n    } else {\n      setStyle = \"error\";\n      return tagNameState;\n    }\n  }\n  function closeTagNameState(type, stream, state) {\n    if (type == \"word\") {\n      var tagName = stream.current();\n      if (state.context && state.context.tagName != tagName &&\n          config.implicitlyClosed.hasOwnProperty(state.context.tagName))\n        popContext(state);\n      if ((state.context && state.context.tagName == tagName) || config.matchClosing === false) {\n        setStyle = \"tag\";\n        return closeState;\n      } else {\n        setStyle = \"tag error\";\n        return closeStateErr;\n      }\n    } else if (config.allowMissingTagName && type == \"endTag\") {\n      setStyle = \"tag bracket\";\n      return closeState(type, stream, state);\n    } else {\n      setStyle = \"error\";\n      return closeStateErr;\n    }\n  }\n\n  function closeState(type, _stream, state) {\n    if (type != \"endTag\") {\n      setStyle = \"error\";\n      return closeState;\n    }\n    popContext(state);\n    return baseState;\n  }\n  function closeStateErr(type, stream, state) {\n    setStyle = \"error\";\n    return closeState(type, stream, state);\n  }\n\n  function attrState(type, _stream, state) {\n    if (type == \"word\") {\n      setStyle = \"attribute\";\n      return attrEqState;\n    } else if (type == \"endTag\" || type == \"selfcloseTag\") {\n      var tagName = state.tagName, tagStart = state.tagStart;\n      state.tagName = state.tagStart = null;\n      if (type == \"selfcloseTag\" ||\n          config.autoSelfClosers.hasOwnProperty(tagName)) {\n        maybePopContext(state, tagName);\n      } else {\n        maybePopContext(state, tagName);\n        state.context = new Context(state, tagName, tagStart == state.indented);\n      }\n      return baseState;\n    }\n    setStyle = \"error\";\n    return attrState;\n  }\n  function attrEqState(type, stream, state) {\n    if (type == \"equals\") return attrValueState;\n    if (!config.allowMissing) setStyle = \"error\";\n    return attrState(type, stream, state);\n  }\n  function attrValueState(type, stream, state) {\n    if (type == \"string\") return attrContinuedState;\n    if (type == \"word\" && config.allowUnquoted) {setStyle = \"string\"; return attrState;}\n    setStyle = \"error\";\n    return attrState(type, stream, state);\n  }\n  function attrContinuedState(type, stream, state) {\n    if (type == \"string\") return attrContinuedState;\n    return attrState(type, stream, state);\n  }\n\n  return {\n    startState: function(baseIndent) {\n      var state = {tokenize: inText,\n                   state: baseState,\n                   indented: baseIndent || 0,\n                   tagName: null, tagStart: null,\n                   context: null}\n      if (baseIndent != null) state.baseIndent = baseIndent\n      return state\n    },\n\n    token: function(stream, state) {\n      if (!state.tagName && stream.sol())\n        state.indented = stream.indentation();\n\n      if (stream.eatSpace()) return null;\n      type = null;\n      var style = state.tokenize(stream, state);\n      if ((style || type) && style != \"comment\") {\n        setStyle = null;\n        state.state = state.state(type || style, stream, state);\n        if (setStyle)\n          style = setStyle == \"error\" ? style + \" error\" : setStyle;\n      }\n      return style;\n    },\n\n    indent: function(state, textAfter, fullLine) {\n      var context = state.context;\n      // Indent multi-line strings (e.g. css).\n      if (state.tokenize.isInAttribute) {\n        if (state.tagStart == state.indented)\n          return state.stringStartCol + 1;\n        else\n          return state.indented + indentUnit;\n      }\n      if (context && context.noIndent) return CodeMirror.Pass;\n      if (state.tokenize != inTag && state.tokenize != inText)\n        return fullLine ? fullLine.match(/^(\\s*)/)[0].length : 0;\n      // Indent the starts of attribute names.\n      if (state.tagName) {\n        if (config.multilineTagIndentPastTag !== false)\n          return state.tagStart + state.tagName.length + 2;\n        else\n          return state.tagStart + indentUnit * (config.multilineTagIndentFactor || 1);\n      }\n      if (config.alignCDATA && /<!\\[CDATA\\[/.test(textAfter)) return 0;\n      var tagAfter = textAfter && /^<(\\/)?([\\w_:\\.-]*)/.exec(textAfter);\n      if (tagAfter && tagAfter[1]) { // Closing tag spotted\n        while (context) {\n          if (context.tagName == tagAfter[2]) {\n            context = context.prev;\n            break;\n          } else if (config.implicitlyClosed.hasOwnProperty(context.tagName)) {\n            context = context.prev;\n          } else {\n            break;\n          }\n        }\n      } else if (tagAfter) { // Opening tag spotted\n        while (context) {\n          var grabbers = config.contextGrabbers[context.tagName];\n          if (grabbers && grabbers.hasOwnProperty(tagAfter[2]))\n            context = context.prev;\n          else\n            break;\n        }\n      }\n      while (context && context.prev && !context.startOfLine)\n        context = context.prev;\n      if (context) return context.indent + indentUnit;\n      else return state.baseIndent || 0;\n    },\n\n    electricInput: /<\\/[\\s\\w:]+>$/,\n    blockCommentStart: \"<!--\",\n    blockCommentEnd: \"-->\",\n\n    configuration: config.htmlMode ? \"html\" : \"xml\",\n    helperType: config.htmlMode ? \"html\" : \"xml\",\n\n    skipAttribute: function(state) {\n      if (state.state == attrValueState)\n        state.state = attrState\n    },\n\n    xmlCurrentTag: function(state) {\n      return state.tagName ? {name: state.tagName, close: state.type == \"closeTag\"} : null\n    },\n\n    xmlCurrentContext: function(state) {\n      var context = []\n      for (var cx = state.context; cx; cx = cx.prev)\n        context.push(cx.tagName)\n      return context.reverse()\n    }\n  };\n});\n\nCodeMirror.defineMIME(\"text/xml\", \"xml\");\nCodeMirror.defineMIME(\"application/xml\", \"xml\");\nif (!CodeMirror.mimeModes.hasOwnProperty(\"text/html\"))\n  CodeMirror.defineMIME(\"text/html\", {name: \"xml\", htmlMode: true});\n\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29kZW1pcnJvci9tb2RlL3htbC94bWwuanM/ZDVlMCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBO0FBQ0EsTUFBTSxJQUF1RDtBQUM3RCxRQUFRLG1CQUFPLENBQUMseUVBQXNCO0FBQ3RDLE9BQU8sRUFHYTtBQUNwQixDQUFDO0FBQ0Q7O0FBRUE7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRSxxQkFBcUI7QUFDckI7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQSxXQUFXLHVCQUF1QjtBQUNsQyxXQUFXLHVCQUF1QjtBQUNsQyxXQUFXLFdBQVc7QUFDdEIsZUFBZSxpQ0FBaUM7QUFDaEQsaUJBQWlCLGlCQUFpQjtBQUNsQyxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFO0FBQzdFLFdBQVcsdUJBQXVCO0FBQ2xDLFdBQVcsdUJBQXVCO0FBQ2xDLGNBQWMsNkJBQTZCO0FBQzNDLFdBQVcsdUJBQXVCO0FBQ2xDLGNBQWMsY0FBYztBQUM1QixXQUFXLHVCQUF1QjtBQUNsQyxjQUFjLDZCQUE2QjtBQUMzQyxXQUFXO0FBQ1gsR0FBRztBQUNILGdCQUFnQixZQUFZO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCO0FBQ3JCLHNCQUFzQjtBQUN0QixxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0QsU0FBUztBQUNULHVEQUF1RDtBQUN2RDtBQUNBLE9BQU87QUFDUCwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELG9CQUFvQjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsT0FBTyxxQkFBcUI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsOEJBQThCLHFEQUFxRDtBQUNuRixLQUFLOztBQUVMO0FBQ0E7QUFDQSxrQ0FBa0MsSUFBSTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLDRCQUE0Qjs7QUFFbEUsQ0FBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9jb2RlbWlycm9yL21vZGUveG1sL3htbC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvZGVNaXJyb3IsIGNvcHlyaWdodCAoYykgYnkgTWFyaWpuIEhhdmVyYmVrZSBhbmQgb3RoZXJzXG4vLyBEaXN0cmlidXRlZCB1bmRlciBhbiBNSVQgbGljZW5zZTogaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC9MSUNFTlNFXG5cbihmdW5jdGlvbihtb2QpIHtcbiAgaWYgKHR5cGVvZiBleHBvcnRzID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZSA9PSBcIm9iamVjdFwiKSAvLyBDb21tb25KU1xuICAgIG1vZChyZXF1aXJlKFwiLi4vLi4vbGliL2NvZGVtaXJyb3JcIikpO1xuICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSAvLyBBTURcbiAgICBkZWZpbmUoW1wiLi4vLi4vbGliL2NvZGVtaXJyb3JcIl0sIG1vZCk7XG4gIGVsc2UgLy8gUGxhaW4gYnJvd3NlciBlbnZcbiAgICBtb2QoQ29kZU1pcnJvcik7XG59KShmdW5jdGlvbihDb2RlTWlycm9yKSB7XG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGh0bWxDb25maWcgPSB7XG4gIGF1dG9TZWxmQ2xvc2VyczogeydhcmVhJzogdHJ1ZSwgJ2Jhc2UnOiB0cnVlLCAnYnInOiB0cnVlLCAnY29sJzogdHJ1ZSwgJ2NvbW1hbmQnOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAnZW1iZWQnOiB0cnVlLCAnZnJhbWUnOiB0cnVlLCAnaHInOiB0cnVlLCAnaW1nJzogdHJ1ZSwgJ2lucHV0JzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgJ2tleWdlbic6IHRydWUsICdsaW5rJzogdHJ1ZSwgJ21ldGEnOiB0cnVlLCAncGFyYW0nOiB0cnVlLCAnc291cmNlJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgJ3RyYWNrJzogdHJ1ZSwgJ3dicic6IHRydWUsICdtZW51aXRlbSc6IHRydWV9LFxuICBpbXBsaWNpdGx5Q2xvc2VkOiB7J2RkJzogdHJ1ZSwgJ2xpJzogdHJ1ZSwgJ29wdGdyb3VwJzogdHJ1ZSwgJ29wdGlvbic6IHRydWUsICdwJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICdycCc6IHRydWUsICdydCc6IHRydWUsICd0Ym9keSc6IHRydWUsICd0ZCc6IHRydWUsICd0Zm9vdCc6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAndGgnOiB0cnVlLCAndHInOiB0cnVlfSxcbiAgY29udGV4dEdyYWJiZXJzOiB7XG4gICAgJ2RkJzogeydkZCc6IHRydWUsICdkdCc6IHRydWV9LFxuICAgICdkdCc6IHsnZGQnOiB0cnVlLCAnZHQnOiB0cnVlfSxcbiAgICAnbGknOiB7J2xpJzogdHJ1ZX0sXG4gICAgJ29wdGlvbic6IHsnb3B0aW9uJzogdHJ1ZSwgJ29wdGdyb3VwJzogdHJ1ZX0sXG4gICAgJ29wdGdyb3VwJzogeydvcHRncm91cCc6IHRydWV9LFxuICAgICdwJzogeydhZGRyZXNzJzogdHJ1ZSwgJ2FydGljbGUnOiB0cnVlLCAnYXNpZGUnOiB0cnVlLCAnYmxvY2txdW90ZSc6IHRydWUsICdkaXInOiB0cnVlLFxuICAgICAgICAgICdkaXYnOiB0cnVlLCAnZGwnOiB0cnVlLCAnZmllbGRzZXQnOiB0cnVlLCAnZm9vdGVyJzogdHJ1ZSwgJ2Zvcm0nOiB0cnVlLFxuICAgICAgICAgICdoMSc6IHRydWUsICdoMic6IHRydWUsICdoMyc6IHRydWUsICdoNCc6IHRydWUsICdoNSc6IHRydWUsICdoNic6IHRydWUsXG4gICAgICAgICAgJ2hlYWRlcic6IHRydWUsICdoZ3JvdXAnOiB0cnVlLCAnaHInOiB0cnVlLCAnbWVudSc6IHRydWUsICduYXYnOiB0cnVlLCAnb2wnOiB0cnVlLFxuICAgICAgICAgICdwJzogdHJ1ZSwgJ3ByZSc6IHRydWUsICdzZWN0aW9uJzogdHJ1ZSwgJ3RhYmxlJzogdHJ1ZSwgJ3VsJzogdHJ1ZX0sXG4gICAgJ3JwJzogeydycCc6IHRydWUsICdydCc6IHRydWV9LFxuICAgICdydCc6IHsncnAnOiB0cnVlLCAncnQnOiB0cnVlfSxcbiAgICAndGJvZHknOiB7J3Rib2R5JzogdHJ1ZSwgJ3Rmb290JzogdHJ1ZX0sXG4gICAgJ3RkJzogeyd0ZCc6IHRydWUsICd0aCc6IHRydWV9LFxuICAgICd0Zm9vdCc6IHsndGJvZHknOiB0cnVlfSxcbiAgICAndGgnOiB7J3RkJzogdHJ1ZSwgJ3RoJzogdHJ1ZX0sXG4gICAgJ3RoZWFkJzogeyd0Ym9keSc6IHRydWUsICd0Zm9vdCc6IHRydWV9LFxuICAgICd0cic6IHsndHInOiB0cnVlfVxuICB9LFxuICBkb05vdEluZGVudDoge1wicHJlXCI6IHRydWV9LFxuICBhbGxvd1VucXVvdGVkOiB0cnVlLFxuICBhbGxvd01pc3Npbmc6IHRydWUsXG4gIGNhc2VGb2xkOiB0cnVlXG59XG5cbnZhciB4bWxDb25maWcgPSB7XG4gIGF1dG9TZWxmQ2xvc2Vyczoge30sXG4gIGltcGxpY2l0bHlDbG9zZWQ6IHt9LFxuICBjb250ZXh0R3JhYmJlcnM6IHt9LFxuICBkb05vdEluZGVudDoge30sXG4gIGFsbG93VW5xdW90ZWQ6IGZhbHNlLFxuICBhbGxvd01pc3Npbmc6IGZhbHNlLFxuICBhbGxvd01pc3NpbmdUYWdOYW1lOiBmYWxzZSxcbiAgY2FzZUZvbGQ6IGZhbHNlXG59XG5cbkNvZGVNaXJyb3IuZGVmaW5lTW9kZShcInhtbFwiLCBmdW5jdGlvbihlZGl0b3JDb25mLCBjb25maWdfKSB7XG4gIHZhciBpbmRlbnRVbml0ID0gZWRpdG9yQ29uZi5pbmRlbnRVbml0XG4gIHZhciBjb25maWcgPSB7fVxuICB2YXIgZGVmYXVsdHMgPSBjb25maWdfLmh0bWxNb2RlID8gaHRtbENvbmZpZyA6IHhtbENvbmZpZ1xuICBmb3IgKHZhciBwcm9wIGluIGRlZmF1bHRzKSBjb25maWdbcHJvcF0gPSBkZWZhdWx0c1twcm9wXVxuICBmb3IgKHZhciBwcm9wIGluIGNvbmZpZ18pIGNvbmZpZ1twcm9wXSA9IGNvbmZpZ19bcHJvcF1cblxuICAvLyBSZXR1cm4gdmFyaWFibGVzIGZvciB0b2tlbml6ZXJzXG4gIHZhciB0eXBlLCBzZXRTdHlsZTtcblxuICBmdW5jdGlvbiBpblRleHQoc3RyZWFtLCBzdGF0ZSkge1xuICAgIGZ1bmN0aW9uIGNoYWluKHBhcnNlcikge1xuICAgICAgc3RhdGUudG9rZW5pemUgPSBwYXJzZXI7XG4gICAgICByZXR1cm4gcGFyc2VyKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cblxuICAgIHZhciBjaCA9IHN0cmVhbS5uZXh0KCk7XG4gICAgaWYgKGNoID09IFwiPFwiKSB7XG4gICAgICBpZiAoc3RyZWFtLmVhdChcIiFcIikpIHtcbiAgICAgICAgaWYgKHN0cmVhbS5lYXQoXCJbXCIpKSB7XG4gICAgICAgICAgaWYgKHN0cmVhbS5tYXRjaChcIkNEQVRBW1wiKSkgcmV0dXJuIGNoYWluKGluQmxvY2soXCJhdG9tXCIsIFwiXV0+XCIpKTtcbiAgICAgICAgICBlbHNlIHJldHVybiBudWxsO1xuICAgICAgICB9IGVsc2UgaWYgKHN0cmVhbS5tYXRjaChcIi0tXCIpKSB7XG4gICAgICAgICAgcmV0dXJuIGNoYWluKGluQmxvY2soXCJjb21tZW50XCIsIFwiLS0+XCIpKTtcbiAgICAgICAgfSBlbHNlIGlmIChzdHJlYW0ubWF0Y2goXCJET0NUWVBFXCIsIHRydWUsIHRydWUpKSB7XG4gICAgICAgICAgc3RyZWFtLmVhdFdoaWxlKC9bXFx3XFwuX1xcLV0vKTtcbiAgICAgICAgICByZXR1cm4gY2hhaW4oZG9jdHlwZSgxKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc3RyZWFtLmVhdChcIj9cIikpIHtcbiAgICAgICAgc3RyZWFtLmVhdFdoaWxlKC9bXFx3XFwuX1xcLV0vKTtcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSBpbkJsb2NrKFwibWV0YVwiLCBcIj8+XCIpO1xuICAgICAgICByZXR1cm4gXCJtZXRhXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlID0gc3RyZWFtLmVhdChcIi9cIikgPyBcImNsb3NlVGFnXCIgOiBcIm9wZW5UYWdcIjtcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSBpblRhZztcbiAgICAgICAgcmV0dXJuIFwidGFnIGJyYWNrZXRcIjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNoID09IFwiJlwiKSB7XG4gICAgICB2YXIgb2s7XG4gICAgICBpZiAoc3RyZWFtLmVhdChcIiNcIikpIHtcbiAgICAgICAgaWYgKHN0cmVhbS5lYXQoXCJ4XCIpKSB7XG4gICAgICAgICAgb2sgPSBzdHJlYW0uZWF0V2hpbGUoL1thLWZBLUZcXGRdLykgJiYgc3RyZWFtLmVhdChcIjtcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2sgPSBzdHJlYW0uZWF0V2hpbGUoL1tcXGRdLykgJiYgc3RyZWFtLmVhdChcIjtcIik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9rID0gc3RyZWFtLmVhdFdoaWxlKC9bXFx3XFwuXFwtOl0vKSAmJiBzdHJlYW0uZWF0KFwiO1wiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvayA/IFwiYXRvbVwiIDogXCJlcnJvclwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHJlYW0uZWF0V2hpbGUoL1teJjxdLyk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbiAgaW5UZXh0LmlzSW5UZXh0ID0gdHJ1ZTtcblxuICBmdW5jdGlvbiBpblRhZyhzdHJlYW0sIHN0YXRlKSB7XG4gICAgdmFyIGNoID0gc3RyZWFtLm5leHQoKTtcbiAgICBpZiAoY2ggPT0gXCI+XCIgfHwgKGNoID09IFwiL1wiICYmIHN0cmVhbS5lYXQoXCI+XCIpKSkge1xuICAgICAgc3RhdGUudG9rZW5pemUgPSBpblRleHQ7XG4gICAgICB0eXBlID0gY2ggPT0gXCI+XCIgPyBcImVuZFRhZ1wiIDogXCJzZWxmY2xvc2VUYWdcIjtcbiAgICAgIHJldHVybiBcInRhZyBicmFja2V0XCI7XG4gICAgfSBlbHNlIGlmIChjaCA9PSBcIj1cIikge1xuICAgICAgdHlwZSA9IFwiZXF1YWxzXCI7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2UgaWYgKGNoID09IFwiPFwiKSB7XG4gICAgICBzdGF0ZS50b2tlbml6ZSA9IGluVGV4dDtcbiAgICAgIHN0YXRlLnN0YXRlID0gYmFzZVN0YXRlO1xuICAgICAgc3RhdGUudGFnTmFtZSA9IHN0YXRlLnRhZ1N0YXJ0ID0gbnVsbDtcbiAgICAgIHZhciBuZXh0ID0gc3RhdGUudG9rZW5pemUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICByZXR1cm4gbmV4dCA/IG5leHQgKyBcIiB0YWcgZXJyb3JcIiA6IFwidGFnIGVycm9yXCI7XG4gICAgfSBlbHNlIGlmICgvW1xcJ1xcXCJdLy50ZXN0KGNoKSkge1xuICAgICAgc3RhdGUudG9rZW5pemUgPSBpbkF0dHJpYnV0ZShjaCk7XG4gICAgICBzdGF0ZS5zdHJpbmdTdGFydENvbCA9IHN0cmVhbS5jb2x1bW4oKTtcbiAgICAgIHJldHVybiBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyZWFtLm1hdGNoKC9eW15cXHNcXHUwMGEwPTw+XFxcIlxcJ10qW15cXHNcXHUwMGEwPTw+XFxcIlxcJ1xcL10vKTtcbiAgICAgIHJldHVybiBcIndvcmRcIjtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbkF0dHJpYnV0ZShxdW90ZSkge1xuICAgIHZhciBjbG9zdXJlID0gZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgd2hpbGUgKCFzdHJlYW0uZW9sKCkpIHtcbiAgICAgICAgaWYgKHN0cmVhbS5uZXh0KCkgPT0gcXVvdGUpIHtcbiAgICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IGluVGFnO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgICB9O1xuICAgIGNsb3N1cmUuaXNJbkF0dHJpYnV0ZSA9IHRydWU7XG4gICAgcmV0dXJuIGNsb3N1cmU7XG4gIH1cblxuICBmdW5jdGlvbiBpbkJsb2NrKHN0eWxlLCB0ZXJtaW5hdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIHdoaWxlICghc3RyZWFtLmVvbCgpKSB7XG4gICAgICAgIGlmIChzdHJlYW0ubWF0Y2godGVybWluYXRvcikpIHtcbiAgICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IGluVGV4dDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0eWxlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRvY3R5cGUoZGVwdGgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgdmFyIGNoO1xuICAgICAgd2hpbGUgKChjaCA9IHN0cmVhbS5uZXh0KCkpICE9IG51bGwpIHtcbiAgICAgICAgaWYgKGNoID09IFwiPFwiKSB7XG4gICAgICAgICAgc3RhdGUudG9rZW5pemUgPSBkb2N0eXBlKGRlcHRoICsgMSk7XG4gICAgICAgICAgcmV0dXJuIHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgICB9IGVsc2UgaWYgKGNoID09IFwiPlwiKSB7XG4gICAgICAgICAgaWYgKGRlcHRoID09IDEpIHtcbiAgICAgICAgICAgIHN0YXRlLnRva2VuaXplID0gaW5UZXh0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRlLnRva2VuaXplID0gZG9jdHlwZShkZXB0aCAtIDEpO1xuICAgICAgICAgICAgcmV0dXJuIHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIFwibWV0YVwiO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBDb250ZXh0KHN0YXRlLCB0YWdOYW1lLCBzdGFydE9mTGluZSkge1xuICAgIHRoaXMucHJldiA9IHN0YXRlLmNvbnRleHQ7XG4gICAgdGhpcy50YWdOYW1lID0gdGFnTmFtZSB8fCBcIlwiO1xuICAgIHRoaXMuaW5kZW50ID0gc3RhdGUuaW5kZW50ZWQ7XG4gICAgdGhpcy5zdGFydE9mTGluZSA9IHN0YXJ0T2ZMaW5lO1xuICAgIGlmIChjb25maWcuZG9Ob3RJbmRlbnQuaGFzT3duUHJvcGVydHkodGFnTmFtZSkgfHwgKHN0YXRlLmNvbnRleHQgJiYgc3RhdGUuY29udGV4dC5ub0luZGVudCkpXG4gICAgICB0aGlzLm5vSW5kZW50ID0gdHJ1ZTtcbiAgfVxuICBmdW5jdGlvbiBwb3BDb250ZXh0KHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlLmNvbnRleHQpIHN0YXRlLmNvbnRleHQgPSBzdGF0ZS5jb250ZXh0LnByZXY7XG4gIH1cbiAgZnVuY3Rpb24gbWF5YmVQb3BDb250ZXh0KHN0YXRlLCBuZXh0VGFnTmFtZSkge1xuICAgIHZhciBwYXJlbnRUYWdOYW1lO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAoIXN0YXRlLmNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcGFyZW50VGFnTmFtZSA9IHN0YXRlLmNvbnRleHQudGFnTmFtZTtcbiAgICAgIGlmICghY29uZmlnLmNvbnRleHRHcmFiYmVycy5oYXNPd25Qcm9wZXJ0eShwYXJlbnRUYWdOYW1lKSB8fFxuICAgICAgICAgICFjb25maWcuY29udGV4dEdyYWJiZXJzW3BhcmVudFRhZ05hbWVdLmhhc093blByb3BlcnR5KG5leHRUYWdOYW1lKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBwb3BDb250ZXh0KHN0YXRlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBiYXNlU3RhdGUodHlwZSwgc3RyZWFtLCBzdGF0ZSkge1xuICAgIGlmICh0eXBlID09IFwib3BlblRhZ1wiKSB7XG4gICAgICBzdGF0ZS50YWdTdGFydCA9IHN0cmVhbS5jb2x1bW4oKTtcbiAgICAgIHJldHVybiB0YWdOYW1lU3RhdGU7XG4gICAgfSBlbHNlIGlmICh0eXBlID09IFwiY2xvc2VUYWdcIikge1xuICAgICAgcmV0dXJuIGNsb3NlVGFnTmFtZVN0YXRlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYmFzZVN0YXRlO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB0YWdOYW1lU3RhdGUodHlwZSwgc3RyZWFtLCBzdGF0ZSkge1xuICAgIGlmICh0eXBlID09IFwid29yZFwiKSB7XG4gICAgICBzdGF0ZS50YWdOYW1lID0gc3RyZWFtLmN1cnJlbnQoKTtcbiAgICAgIHNldFN0eWxlID0gXCJ0YWdcIjtcbiAgICAgIHJldHVybiBhdHRyU3RhdGU7XG4gICAgfSBlbHNlIGlmIChjb25maWcuYWxsb3dNaXNzaW5nVGFnTmFtZSAmJiB0eXBlID09IFwiZW5kVGFnXCIpIHtcbiAgICAgIHNldFN0eWxlID0gXCJ0YWcgYnJhY2tldFwiO1xuICAgICAgcmV0dXJuIGF0dHJTdGF0ZSh0eXBlLCBzdHJlYW0sIHN0YXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0U3R5bGUgPSBcImVycm9yXCI7XG4gICAgICByZXR1cm4gdGFnTmFtZVN0YXRlO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBjbG9zZVRhZ05hbWVTdGF0ZSh0eXBlLCBzdHJlYW0sIHN0YXRlKSB7XG4gICAgaWYgKHR5cGUgPT0gXCJ3b3JkXCIpIHtcbiAgICAgIHZhciB0YWdOYW1lID0gc3RyZWFtLmN1cnJlbnQoKTtcbiAgICAgIGlmIChzdGF0ZS5jb250ZXh0ICYmIHN0YXRlLmNvbnRleHQudGFnTmFtZSAhPSB0YWdOYW1lICYmXG4gICAgICAgICAgY29uZmlnLmltcGxpY2l0bHlDbG9zZWQuaGFzT3duUHJvcGVydHkoc3RhdGUuY29udGV4dC50YWdOYW1lKSlcbiAgICAgICAgcG9wQ29udGV4dChzdGF0ZSk7XG4gICAgICBpZiAoKHN0YXRlLmNvbnRleHQgJiYgc3RhdGUuY29udGV4dC50YWdOYW1lID09IHRhZ05hbWUpIHx8IGNvbmZpZy5tYXRjaENsb3NpbmcgPT09IGZhbHNlKSB7XG4gICAgICAgIHNldFN0eWxlID0gXCJ0YWdcIjtcbiAgICAgICAgcmV0dXJuIGNsb3NlU3RhdGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRTdHlsZSA9IFwidGFnIGVycm9yXCI7XG4gICAgICAgIHJldHVybiBjbG9zZVN0YXRlRXJyO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY29uZmlnLmFsbG93TWlzc2luZ1RhZ05hbWUgJiYgdHlwZSA9PSBcImVuZFRhZ1wiKSB7XG4gICAgICBzZXRTdHlsZSA9IFwidGFnIGJyYWNrZXRcIjtcbiAgICAgIHJldHVybiBjbG9zZVN0YXRlKHR5cGUsIHN0cmVhbSwgc3RhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRTdHlsZSA9IFwiZXJyb3JcIjtcbiAgICAgIHJldHVybiBjbG9zZVN0YXRlRXJyO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNsb3NlU3RhdGUodHlwZSwgX3N0cmVhbSwgc3RhdGUpIHtcbiAgICBpZiAodHlwZSAhPSBcImVuZFRhZ1wiKSB7XG4gICAgICBzZXRTdHlsZSA9IFwiZXJyb3JcIjtcbiAgICAgIHJldHVybiBjbG9zZVN0YXRlO1xuICAgIH1cbiAgICBwb3BDb250ZXh0KHN0YXRlKTtcbiAgICByZXR1cm4gYmFzZVN0YXRlO1xuICB9XG4gIGZ1bmN0aW9uIGNsb3NlU3RhdGVFcnIodHlwZSwgc3RyZWFtLCBzdGF0ZSkge1xuICAgIHNldFN0eWxlID0gXCJlcnJvclwiO1xuICAgIHJldHVybiBjbG9zZVN0YXRlKHR5cGUsIHN0cmVhbSwgc3RhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gYXR0clN0YXRlKHR5cGUsIF9zdHJlYW0sIHN0YXRlKSB7XG4gICAgaWYgKHR5cGUgPT0gXCJ3b3JkXCIpIHtcbiAgICAgIHNldFN0eWxlID0gXCJhdHRyaWJ1dGVcIjtcbiAgICAgIHJldHVybiBhdHRyRXFTdGF0ZTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT0gXCJlbmRUYWdcIiB8fCB0eXBlID09IFwic2VsZmNsb3NlVGFnXCIpIHtcbiAgICAgIHZhciB0YWdOYW1lID0gc3RhdGUudGFnTmFtZSwgdGFnU3RhcnQgPSBzdGF0ZS50YWdTdGFydDtcbiAgICAgIHN0YXRlLnRhZ05hbWUgPSBzdGF0ZS50YWdTdGFydCA9IG51bGw7XG4gICAgICBpZiAodHlwZSA9PSBcInNlbGZjbG9zZVRhZ1wiIHx8XG4gICAgICAgICAgY29uZmlnLmF1dG9TZWxmQ2xvc2Vycy5oYXNPd25Qcm9wZXJ0eSh0YWdOYW1lKSkge1xuICAgICAgICBtYXliZVBvcENvbnRleHQoc3RhdGUsIHRhZ05hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWF5YmVQb3BDb250ZXh0KHN0YXRlLCB0YWdOYW1lKTtcbiAgICAgICAgc3RhdGUuY29udGV4dCA9IG5ldyBDb250ZXh0KHN0YXRlLCB0YWdOYW1lLCB0YWdTdGFydCA9PSBzdGF0ZS5pbmRlbnRlZCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZVN0YXRlO1xuICAgIH1cbiAgICBzZXRTdHlsZSA9IFwiZXJyb3JcIjtcbiAgICByZXR1cm4gYXR0clN0YXRlO1xuICB9XG4gIGZ1bmN0aW9uIGF0dHJFcVN0YXRlKHR5cGUsIHN0cmVhbSwgc3RhdGUpIHtcbiAgICBpZiAodHlwZSA9PSBcImVxdWFsc1wiKSByZXR1cm4gYXR0clZhbHVlU3RhdGU7XG4gICAgaWYgKCFjb25maWcuYWxsb3dNaXNzaW5nKSBzZXRTdHlsZSA9IFwiZXJyb3JcIjtcbiAgICByZXR1cm4gYXR0clN0YXRlKHR5cGUsIHN0cmVhbSwgc3RhdGUpO1xuICB9XG4gIGZ1bmN0aW9uIGF0dHJWYWx1ZVN0YXRlKHR5cGUsIHN0cmVhbSwgc3RhdGUpIHtcbiAgICBpZiAodHlwZSA9PSBcInN0cmluZ1wiKSByZXR1cm4gYXR0ckNvbnRpbnVlZFN0YXRlO1xuICAgIGlmICh0eXBlID09IFwid29yZFwiICYmIGNvbmZpZy5hbGxvd1VucXVvdGVkKSB7c2V0U3R5bGUgPSBcInN0cmluZ1wiOyByZXR1cm4gYXR0clN0YXRlO31cbiAgICBzZXRTdHlsZSA9IFwiZXJyb3JcIjtcbiAgICByZXR1cm4gYXR0clN0YXRlKHR5cGUsIHN0cmVhbSwgc3RhdGUpO1xuICB9XG4gIGZ1bmN0aW9uIGF0dHJDb250aW51ZWRTdGF0ZSh0eXBlLCBzdHJlYW0sIHN0YXRlKSB7XG4gICAgaWYgKHR5cGUgPT0gXCJzdHJpbmdcIikgcmV0dXJuIGF0dHJDb250aW51ZWRTdGF0ZTtcbiAgICByZXR1cm4gYXR0clN0YXRlKHR5cGUsIHN0cmVhbSwgc3RhdGUpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBzdGFydFN0YXRlOiBmdW5jdGlvbihiYXNlSW5kZW50KSB7XG4gICAgICB2YXIgc3RhdGUgPSB7dG9rZW5pemU6IGluVGV4dCxcbiAgICAgICAgICAgICAgICAgICBzdGF0ZTogYmFzZVN0YXRlLFxuICAgICAgICAgICAgICAgICAgIGluZGVudGVkOiBiYXNlSW5kZW50IHx8IDAsXG4gICAgICAgICAgICAgICAgICAgdGFnTmFtZTogbnVsbCwgdGFnU3RhcnQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgY29udGV4dDogbnVsbH1cbiAgICAgIGlmIChiYXNlSW5kZW50ICE9IG51bGwpIHN0YXRlLmJhc2VJbmRlbnQgPSBiYXNlSW5kZW50XG4gICAgICByZXR1cm4gc3RhdGVcbiAgICB9LFxuXG4gICAgdG9rZW46IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIGlmICghc3RhdGUudGFnTmFtZSAmJiBzdHJlYW0uc29sKCkpXG4gICAgICAgIHN0YXRlLmluZGVudGVkID0gc3RyZWFtLmluZGVudGF0aW9uKCk7XG5cbiAgICAgIGlmIChzdHJlYW0uZWF0U3BhY2UoKSkgcmV0dXJuIG51bGw7XG4gICAgICB0eXBlID0gbnVsbDtcbiAgICAgIHZhciBzdHlsZSA9IHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgaWYgKChzdHlsZSB8fCB0eXBlKSAmJiBzdHlsZSAhPSBcImNvbW1lbnRcIikge1xuICAgICAgICBzZXRTdHlsZSA9IG51bGw7XG4gICAgICAgIHN0YXRlLnN0YXRlID0gc3RhdGUuc3RhdGUodHlwZSB8fCBzdHlsZSwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgICAgIGlmIChzZXRTdHlsZSlcbiAgICAgICAgICBzdHlsZSA9IHNldFN0eWxlID09IFwiZXJyb3JcIiA/IHN0eWxlICsgXCIgZXJyb3JcIiA6IHNldFN0eWxlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0eWxlO1xuICAgIH0sXG5cbiAgICBpbmRlbnQ6IGZ1bmN0aW9uKHN0YXRlLCB0ZXh0QWZ0ZXIsIGZ1bGxMaW5lKSB7XG4gICAgICB2YXIgY29udGV4dCA9IHN0YXRlLmNvbnRleHQ7XG4gICAgICAvLyBJbmRlbnQgbXVsdGktbGluZSBzdHJpbmdzIChlLmcuIGNzcykuXG4gICAgICBpZiAoc3RhdGUudG9rZW5pemUuaXNJbkF0dHJpYnV0ZSkge1xuICAgICAgICBpZiAoc3RhdGUudGFnU3RhcnQgPT0gc3RhdGUuaW5kZW50ZWQpXG4gICAgICAgICAgcmV0dXJuIHN0YXRlLnN0cmluZ1N0YXJ0Q29sICsgMTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHJldHVybiBzdGF0ZS5pbmRlbnRlZCArIGluZGVudFVuaXQ7XG4gICAgICB9XG4gICAgICBpZiAoY29udGV4dCAmJiBjb250ZXh0Lm5vSW5kZW50KSByZXR1cm4gQ29kZU1pcnJvci5QYXNzO1xuICAgICAgaWYgKHN0YXRlLnRva2VuaXplICE9IGluVGFnICYmIHN0YXRlLnRva2VuaXplICE9IGluVGV4dClcbiAgICAgICAgcmV0dXJuIGZ1bGxMaW5lID8gZnVsbExpbmUubWF0Y2goL14oXFxzKikvKVswXS5sZW5ndGggOiAwO1xuICAgICAgLy8gSW5kZW50IHRoZSBzdGFydHMgb2YgYXR0cmlidXRlIG5hbWVzLlxuICAgICAgaWYgKHN0YXRlLnRhZ05hbWUpIHtcbiAgICAgICAgaWYgKGNvbmZpZy5tdWx0aWxpbmVUYWdJbmRlbnRQYXN0VGFnICE9PSBmYWxzZSlcbiAgICAgICAgICByZXR1cm4gc3RhdGUudGFnU3RhcnQgKyBzdGF0ZS50YWdOYW1lLmxlbmd0aCArIDI7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICByZXR1cm4gc3RhdGUudGFnU3RhcnQgKyBpbmRlbnRVbml0ICogKGNvbmZpZy5tdWx0aWxpbmVUYWdJbmRlbnRGYWN0b3IgfHwgMSk7XG4gICAgICB9XG4gICAgICBpZiAoY29uZmlnLmFsaWduQ0RBVEEgJiYgLzwhXFxbQ0RBVEFcXFsvLnRlc3QodGV4dEFmdGVyKSkgcmV0dXJuIDA7XG4gICAgICB2YXIgdGFnQWZ0ZXIgPSB0ZXh0QWZ0ZXIgJiYgL148KFxcLyk/KFtcXHdfOlxcLi1dKikvLmV4ZWModGV4dEFmdGVyKTtcbiAgICAgIGlmICh0YWdBZnRlciAmJiB0YWdBZnRlclsxXSkgeyAvLyBDbG9zaW5nIHRhZyBzcG90dGVkXG4gICAgICAgIHdoaWxlIChjb250ZXh0KSB7XG4gICAgICAgICAgaWYgKGNvbnRleHQudGFnTmFtZSA9PSB0YWdBZnRlclsyXSkge1xuICAgICAgICAgICAgY29udGV4dCA9IGNvbnRleHQucHJldjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY29uZmlnLmltcGxpY2l0bHlDbG9zZWQuaGFzT3duUHJvcGVydHkoY29udGV4dC50YWdOYW1lKSkge1xuICAgICAgICAgICAgY29udGV4dCA9IGNvbnRleHQucHJldjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRhZ0FmdGVyKSB7IC8vIE9wZW5pbmcgdGFnIHNwb3R0ZWRcbiAgICAgICAgd2hpbGUgKGNvbnRleHQpIHtcbiAgICAgICAgICB2YXIgZ3JhYmJlcnMgPSBjb25maWcuY29udGV4dEdyYWJiZXJzW2NvbnRleHQudGFnTmFtZV07XG4gICAgICAgICAgaWYgKGdyYWJiZXJzICYmIGdyYWJiZXJzLmhhc093blByb3BlcnR5KHRhZ0FmdGVyWzJdKSlcbiAgICAgICAgICAgIGNvbnRleHQgPSBjb250ZXh0LnByZXY7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdoaWxlIChjb250ZXh0ICYmIGNvbnRleHQucHJldiAmJiAhY29udGV4dC5zdGFydE9mTGluZSlcbiAgICAgICAgY29udGV4dCA9IGNvbnRleHQucHJldjtcbiAgICAgIGlmIChjb250ZXh0KSByZXR1cm4gY29udGV4dC5pbmRlbnQgKyBpbmRlbnRVbml0O1xuICAgICAgZWxzZSByZXR1cm4gc3RhdGUuYmFzZUluZGVudCB8fCAwO1xuICAgIH0sXG5cbiAgICBlbGVjdHJpY0lucHV0OiAvPFxcL1tcXHNcXHc6XSs+JC8sXG4gICAgYmxvY2tDb21tZW50U3RhcnQ6IFwiPCEtLVwiLFxuICAgIGJsb2NrQ29tbWVudEVuZDogXCItLT5cIixcblxuICAgIGNvbmZpZ3VyYXRpb246IGNvbmZpZy5odG1sTW9kZSA/IFwiaHRtbFwiIDogXCJ4bWxcIixcbiAgICBoZWxwZXJUeXBlOiBjb25maWcuaHRtbE1vZGUgPyBcImh0bWxcIiA6IFwieG1sXCIsXG5cbiAgICBza2lwQXR0cmlidXRlOiBmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgaWYgKHN0YXRlLnN0YXRlID09IGF0dHJWYWx1ZVN0YXRlKVxuICAgICAgICBzdGF0ZS5zdGF0ZSA9IGF0dHJTdGF0ZVxuICAgIH0sXG5cbiAgICB4bWxDdXJyZW50VGFnOiBmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgcmV0dXJuIHN0YXRlLnRhZ05hbWUgPyB7bmFtZTogc3RhdGUudGFnTmFtZSwgY2xvc2U6IHN0YXRlLnR5cGUgPT0gXCJjbG9zZVRhZ1wifSA6IG51bGxcbiAgICB9LFxuXG4gICAgeG1sQ3VycmVudENvbnRleHQ6IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgICB2YXIgY29udGV4dCA9IFtdXG4gICAgICBmb3IgKHZhciBjeCA9IHN0YXRlLmNvbnRleHQ7IGN4OyBjeCA9IGN4LnByZXYpXG4gICAgICAgIGNvbnRleHQucHVzaChjeC50YWdOYW1lKVxuICAgICAgcmV0dXJuIGNvbnRleHQucmV2ZXJzZSgpXG4gICAgfVxuICB9O1xufSk7XG5cbkNvZGVNaXJyb3IuZGVmaW5lTUlNRShcInRleHQveG1sXCIsIFwieG1sXCIpO1xuQ29kZU1pcnJvci5kZWZpbmVNSU1FKFwiYXBwbGljYXRpb24veG1sXCIsIFwieG1sXCIpO1xuaWYgKCFDb2RlTWlycm9yLm1pbWVNb2Rlcy5oYXNPd25Qcm9wZXJ0eShcInRleHQvaHRtbFwiKSlcbiAgQ29kZU1pcnJvci5kZWZpbmVNSU1FKFwidGV4dC9odG1sXCIsIHtuYW1lOiBcInhtbFwiLCBodG1sTW9kZTogdHJ1ZX0pO1xuXG59KTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/codemirror/mode/xml/xml.js\n");

/***/ }),

/***/ "./node_modules/codemirror/theme/shadowfox.css":
/*!*****************************************************!*\
  !*** ./node_modules/codemirror/theme/shadowfox.css ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\nvar content = __webpack_require__(/*! !../../css-loader??ref--10-1!../../postcss-loader/src??ref--10-2!./shadowfox.css */ \"./node_modules/css-loader/index.js?!./node_modules/postcss-loader/src/index.js?!./node_modules/codemirror/theme/shadowfox.css\");\n\nif(typeof content === 'string') content = [[module.i, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = __webpack_require__(/*! ../../style-loader/lib/addStyles.js */ \"./node_modules/style-loader/lib/addStyles.js\")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(false) {}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29kZW1pcnJvci90aGVtZS9zaGFkb3dmb3guY3NzPzYyMTQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUNBLGNBQWMsbUJBQU8sQ0FBQyx1TkFBcUc7O0FBRTNILDRDQUE0QyxRQUFTOztBQUVyRDtBQUNBOzs7O0FBSUEsZUFBZTs7QUFFZjtBQUNBOztBQUVBLGFBQWEsbUJBQU8sQ0FBQyx5RkFBc0M7O0FBRTNEOztBQUVBLEdBQUcsS0FBVSxFQUFFIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2NvZGVtaXJyb3IvdGhlbWUvc2hhZG93Zm94LmNzcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9jc3MtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTEwLTEhLi4vLi4vcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9yZWYtLTEwLTIhLi9zaGFkb3dmb3guY3NzXCIpO1xuXG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcblxudmFyIHRyYW5zZm9ybTtcbnZhciBpbnNlcnRJbnRvO1xuXG5cblxudmFyIG9wdGlvbnMgPSB7XCJobXJcIjp0cnVlfVxuXG5vcHRpb25zLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVxub3B0aW9ucy5pbnNlcnRJbnRvID0gdW5kZWZpbmVkO1xuXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi8uLi9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcblxuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG5cbmlmKG1vZHVsZS5ob3QpIHtcblx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uL2Nzcy1sb2FkZXIvaW5kZXguanM/P3JlZi0tMTAtMSEuLi8uLi9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3JlZi0tMTAtMiEuL3NoYWRvd2ZveC5jc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9jc3MtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTEwLTEhLi4vLi4vcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9yZWYtLTEwLTIhLi9zaGFkb3dmb3guY3NzXCIpO1xuXG5cdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cblx0XHR2YXIgbG9jYWxzID0gKGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdHZhciBrZXksIGlkeCA9IDA7XG5cblx0XHRcdGZvcihrZXkgaW4gYSkge1xuXHRcdFx0XHRpZighYiB8fCBhW2tleV0gIT09IGJba2V5XSkgcmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRpZHgrKztcblx0XHRcdH1cblxuXHRcdFx0Zm9yKGtleSBpbiBiKSBpZHgtLTtcblxuXHRcdFx0cmV0dXJuIGlkeCA9PT0gMDtcblx0XHR9KGNvbnRlbnQubG9jYWxzLCBuZXdDb250ZW50LmxvY2FscykpO1xuXG5cdFx0aWYoIWxvY2FscykgdGhyb3cgbmV3IEVycm9yKCdBYm9ydGluZyBDU1MgSE1SIGR1ZSB0byBjaGFuZ2VkIGNzcy1tb2R1bGVzIGxvY2Fscy4nKTtcblxuXHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0fSk7XG5cblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/codemirror/theme/shadowfox.css\n");

/***/ }),

/***/ "./node_modules/css-loader/index.js?!./node_modules/postcss-loader/src/index.js?!./node_modules/codemirror/lib/codemirror.css":
/*!**************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader??ref--10-1!./node_modules/postcss-loader/src??ref--10-2!./node_modules/codemirror/lib/codemirror.css ***!
  \**************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(/*! ../../css-loader/lib/css-base.js */ \"./node_modules/css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.i, \"/* BASICS */\\n\\n.CodeMirror {\\n  /* Set height, width, borders, and global font properties here */\\n  font-family: monospace;\\n  height: 300px;\\n  color: black;\\n  direction: ltr;\\n}\\n\\n/* PADDING */\\n\\n.CodeMirror-lines {\\n  padding: 4px 0; /* Vertical padding around content */\\n}\\n.CodeMirror pre.CodeMirror-line,\\n.CodeMirror pre.CodeMirror-line-like {\\n  padding: 0 4px; /* Horizontal padding of content */\\n}\\n\\n.CodeMirror-scrollbar-filler, .CodeMirror-gutter-filler {\\n  background-color: transparent; /* The little square between H and V scrollbars */\\n}\\n\\n/* GUTTER */\\n\\n.CodeMirror-gutters {\\n  border-right: 1px solid #ddd;\\n  background-color: #f7f7f7;\\n  white-space: nowrap;\\n}\\n.CodeMirror-linenumbers {}\\n.CodeMirror-linenumber {\\n  padding: 0 3px 0 5px;\\n  min-width: 20px;\\n  text-align: right;\\n  color: #999;\\n  white-space: nowrap;\\n}\\n\\n.CodeMirror-guttermarker { color: black; }\\n.CodeMirror-guttermarker-subtle { color: #999; }\\n\\n/* CURSOR */\\n\\n.CodeMirror-cursor {\\n  border-left: 1px solid black;\\n  border-right: none;\\n  width: 0;\\n}\\n/* Shown when moving in bi-directional text */\\n.CodeMirror div.CodeMirror-secondarycursor {\\n  border-left: 1px solid silver;\\n}\\n.cm-fat-cursor .CodeMirror-cursor {\\n  width: auto;\\n  border: 0 !important;\\n  background: #7e7;\\n}\\n.cm-fat-cursor div.CodeMirror-cursors {\\n  z-index: 1;\\n}\\n.cm-fat-cursor-mark {\\n  background-color: rgba(20, 255, 20, 0.5);\\n  -webkit-animation: blink 1.06s steps(1) infinite;\\n  animation: blink 1.06s steps(1) infinite;\\n}\\n.cm-animate-fat-cursor {\\n  width: auto;\\n  border: 0;\\n  -webkit-animation: blink 1.06s steps(1) infinite;\\n  animation: blink 1.06s steps(1) infinite;\\n  background-color: #7e7;\\n}\\n@-webkit-keyframes blink {\\n  0% {}\\n  50% { background-color: transparent; }\\n  100% {}\\n}\\n@keyframes blink {\\n  0% {}\\n  50% { background-color: transparent; }\\n  100% {}\\n}\\n\\n/* Can style cursor different in overwrite (non-insert) mode */\\n.CodeMirror-overwrite .CodeMirror-cursor {}\\n\\n.cm-tab { display: inline-block; text-decoration: inherit; }\\n\\n.CodeMirror-rulers {\\n  position: absolute;\\n  left: 0; right: 0; top: -50px; bottom: 0;\\n  overflow: hidden;\\n}\\n.CodeMirror-ruler {\\n  border-left: 1px solid #ccc;\\n  top: 0; bottom: 0;\\n  position: absolute;\\n}\\n\\n/* DEFAULT THEME */\\n\\n.cm-s-default .cm-header {color: blue;}\\n.cm-s-default .cm-quote {color: #090;}\\n.cm-negative {color: #d44;}\\n.cm-positive {color: #292;}\\n.cm-header, .cm-strong {font-weight: bold;}\\n.cm-em {font-style: italic;}\\n.cm-link {text-decoration: underline;}\\n.cm-strikethrough {text-decoration: line-through;}\\n\\n.cm-s-default .cm-keyword {color: #708;}\\n.cm-s-default .cm-atom {color: #219;}\\n.cm-s-default .cm-number {color: #164;}\\n.cm-s-default .cm-def {color: #00f;}\\n.cm-s-default .cm-variable,\\n.cm-s-default .cm-punctuation,\\n.cm-s-default .cm-property,\\n.cm-s-default .cm-operator {}\\n.cm-s-default .cm-variable-2 {color: #05a;}\\n.cm-s-default .cm-variable-3, .cm-s-default .cm-type {color: #085;}\\n.cm-s-default .cm-comment {color: #a50;}\\n.cm-s-default .cm-string {color: #a11;}\\n.cm-s-default .cm-string-2 {color: #f50;}\\n.cm-s-default .cm-meta {color: #555;}\\n.cm-s-default .cm-qualifier {color: #555;}\\n.cm-s-default .cm-builtin {color: #30a;}\\n.cm-s-default .cm-bracket {color: #997;}\\n.cm-s-default .cm-tag {color: #170;}\\n.cm-s-default .cm-attribute {color: #00c;}\\n.cm-s-default .cm-hr {color: #999;}\\n.cm-s-default .cm-link {color: #00c;}\\n\\n.cm-s-default .cm-error {color: #f00;}\\n.cm-invalidchar {color: #f00;}\\n\\n.CodeMirror-composing { border-bottom: 2px solid; }\\n\\n/* Default styles for common addons */\\n\\ndiv.CodeMirror span.CodeMirror-matchingbracket {color: #0b0;}\\ndiv.CodeMirror span.CodeMirror-nonmatchingbracket {color: #a22;}\\n.CodeMirror-matchingtag { background: rgba(255, 150, 0, .3); }\\n.CodeMirror-activeline-background {background: #e8f2ff;}\\n\\n/* STOP */\\n\\n/* The rest of this file contains styles related to the mechanics of\\n   the editor. You probably shouldn't touch them. */\\n\\n.CodeMirror {\\n  position: relative;\\n  overflow: hidden;\\n  background: white;\\n}\\n\\n.CodeMirror-scroll {\\n  overflow: scroll !important; /* Things will break if this is overridden */\\n  /* 50px is the magic margin used to hide the element's real scrollbars */\\n  /* See overflow: hidden in .CodeMirror */\\n  margin-bottom: -50px; margin-right: -50px;\\n  padding-bottom: 50px;\\n  height: 100%;\\n  outline: none; /* Prevent dragging from highlighting the element */\\n  position: relative;\\n}\\n.CodeMirror-sizer {\\n  position: relative;\\n  border-right: 50px solid transparent;\\n}\\n\\n/* The fake, visible scrollbars. Used to force redraw during scrolling\\n   before actual scrolling happens, thus preventing shaking and\\n   flickering artifacts. */\\n.CodeMirror-vscrollbar, .CodeMirror-hscrollbar, .CodeMirror-scrollbar-filler, .CodeMirror-gutter-filler {\\n  position: absolute;\\n  z-index: 6;\\n  display: none;\\n  outline: none;\\n}\\n.CodeMirror-vscrollbar {\\n  right: 0; top: 0;\\n  overflow-x: hidden;\\n  overflow-y: scroll;\\n}\\n.CodeMirror-hscrollbar {\\n  bottom: 0; left: 0;\\n  overflow-y: hidden;\\n  overflow-x: scroll;\\n}\\n.CodeMirror-scrollbar-filler {\\n  right: 0; bottom: 0;\\n}\\n.CodeMirror-gutter-filler {\\n  left: 0; bottom: 0;\\n}\\n\\n.CodeMirror-gutters {\\n  position: absolute; left: 0; top: 0;\\n  min-height: 100%;\\n  z-index: 3;\\n}\\n.CodeMirror-gutter {\\n  white-space: normal;\\n  height: 100%;\\n  display: inline-block;\\n  vertical-align: top;\\n  margin-bottom: -50px;\\n}\\n.CodeMirror-gutter-wrapper {\\n  position: absolute;\\n  z-index: 4;\\n  background: none !important;\\n  border: none !important;\\n}\\n.CodeMirror-gutter-background {\\n  position: absolute;\\n  top: 0; bottom: 0;\\n  z-index: 4;\\n}\\n.CodeMirror-gutter-elt {\\n  position: absolute;\\n  cursor: default;\\n  z-index: 4;\\n}\\n.CodeMirror-gutter-wrapper ::-moz-selection { background-color: transparent }\\n.CodeMirror-gutter-wrapper ::selection { background-color: transparent }\\n.CodeMirror-gutter-wrapper ::-moz-selection { background-color: transparent }\\n\\n.CodeMirror-lines {\\n  cursor: text;\\n  min-height: 1px; /* prevents collapsing before first draw */\\n}\\n.CodeMirror pre.CodeMirror-line,\\n.CodeMirror pre.CodeMirror-line-like {\\n  /* Reset some styles that the rest of the page might have set */ border-radius: 0;\\n  border-width: 0;\\n  background: transparent;\\n  font-family: inherit;\\n  font-size: inherit;\\n  margin: 0;\\n  white-space: pre;\\n  word-wrap: normal;\\n  line-height: inherit;\\n  color: inherit;\\n  z-index: 2;\\n  position: relative;\\n  overflow: visible;\\n  -webkit-tap-highlight-color: transparent;\\n  font-variant-ligatures: contextual;\\n}\\n.CodeMirror-wrap pre.CodeMirror-line,\\n.CodeMirror-wrap pre.CodeMirror-line-like {\\n  word-wrap: break-word;\\n  white-space: pre-wrap;\\n  word-break: normal;\\n}\\n\\n.CodeMirror-linebackground {\\n  position: absolute;\\n  left: 0; right: 0; top: 0; bottom: 0;\\n  z-index: 0;\\n}\\n\\n.CodeMirror-linewidget {\\n  position: relative;\\n  z-index: 2;\\n  padding: 0.1px; /* Force widget margins to stay inside of the container */\\n}\\n\\n.CodeMirror-widget {}\\n\\n.CodeMirror-rtl pre { direction: rtl; }\\n\\n.CodeMirror-code {\\n  outline: none;\\n}\\n\\n/* Force content-box sizing for the elements where we expect it */\\n.CodeMirror-scroll,\\n.CodeMirror-sizer,\\n.CodeMirror-gutter,\\n.CodeMirror-gutters,\\n.CodeMirror-linenumber {\\n  box-sizing: content-box;\\n}\\n\\n.CodeMirror-measure {\\n  position: absolute;\\n  width: 100%;\\n  height: 0;\\n  overflow: hidden;\\n  visibility: hidden;\\n}\\n\\n.CodeMirror-cursor {\\n  position: absolute;\\n  pointer-events: none;\\n}\\n.CodeMirror-measure pre { position: static; }\\n\\ndiv.CodeMirror-cursors {\\n  visibility: hidden;\\n  position: relative;\\n  z-index: 3;\\n}\\ndiv.CodeMirror-dragcursors {\\n  visibility: visible;\\n}\\n\\n.CodeMirror-focused div.CodeMirror-cursors {\\n  visibility: visible;\\n}\\n\\n.CodeMirror-selected { background: #d9d9d9; }\\n.CodeMirror-focused .CodeMirror-selected { background: #d7d4f0; }\\n.CodeMirror-crosshair { cursor: crosshair; }\\n.CodeMirror-line::-moz-selection, .CodeMirror-line > span::-moz-selection, .CodeMirror-line > span > span::-moz-selection { background: #d7d4f0; }\\n.CodeMirror-line::selection, .CodeMirror-line > span::selection, .CodeMirror-line > span > span::selection { background: #d7d4f0; }\\n.CodeMirror-line::-moz-selection, .CodeMirror-line > span::-moz-selection, .CodeMirror-line > span > span::-moz-selection { background: #d7d4f0; }\\n\\n.cm-searching {\\n  background-color: #ffa;\\n  background-color: rgba(255, 255, 0, .4);\\n}\\n\\n/* Used to force a border model for a node */\\n.cm-force-border { padding-right: .1px; }\\n\\n@media print {\\n  /* Hide the cursor when printing */\\n  .CodeMirror div.CodeMirror-cursors {\\n    visibility: hidden;\\n  }\\n}\\n\\n/* See issue #2901 */\\n.cm-tab-wrap-hack:after { content: ''; }\\n\\n/* Help users use markselection to safely style text background */\\nspan.CodeMirror-selectedtext { background: none; }\\n\", \"\"]);\n\n// exports\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29kZW1pcnJvci9saWIvY29kZW1pcnJvci5jc3M/YzVjNCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSwyQkFBMkIsbUJBQU8sQ0FBQyxtRkFBa0M7QUFDckU7OztBQUdBO0FBQ0EsY0FBYyxRQUFTLGdDQUFnQyxnR0FBZ0csa0JBQWtCLGlCQUFpQixtQkFBbUIsR0FBRyx3Q0FBd0MsbUJBQW1CLHlDQUF5QywwRUFBMEUsbUJBQW1CLHVDQUF1Qyw2REFBNkQsa0NBQWtDLHNEQUFzRCx5Q0FBeUMsaUNBQWlDLDhCQUE4Qix3QkFBd0IsR0FBRyw0QkFBNEIsMEJBQTBCLHlCQUF5QixvQkFBb0Isc0JBQXNCLGdCQUFnQix3QkFBd0IsR0FBRyw4QkFBOEIsY0FBYyxFQUFFLG1DQUFtQyxhQUFhLEVBQUUsd0NBQXdDLGlDQUFpQyx1QkFBdUIsYUFBYSxHQUFHLDhGQUE4RixrQ0FBa0MsR0FBRyxxQ0FBcUMsZ0JBQWdCLHlCQUF5QixxQkFBcUIsR0FBRyx5Q0FBeUMsZUFBZSxHQUFHLHVCQUF1Qiw2Q0FBNkMscURBQXFELDZDQUE2QyxHQUFHLDBCQUEwQixnQkFBZ0IsY0FBYyxxREFBcUQsNkNBQTZDLDJCQUEyQixHQUFHLDRCQUE0QixTQUFTLFNBQVMsK0JBQStCLEVBQUUsV0FBVyxHQUFHLG9CQUFvQixTQUFTLFNBQVMsK0JBQStCLEVBQUUsV0FBVyxHQUFHLGdIQUFnSCxhQUFhLHVCQUF1QiwwQkFBMEIsRUFBRSx3QkFBd0IsdUJBQXVCLFlBQVksVUFBVSxZQUFZLFdBQVcscUJBQXFCLEdBQUcscUJBQXFCLGdDQUFnQyxXQUFXLFdBQVcsdUJBQXVCLEdBQUcscURBQXFELGFBQWEsMkJBQTJCLGFBQWEsZ0JBQWdCLGFBQWEsZ0JBQWdCLGFBQWEsMEJBQTBCLG1CQUFtQixVQUFVLG9CQUFvQixZQUFZLDRCQUE0QixxQkFBcUIsK0JBQStCLCtCQUErQixhQUFhLDBCQUEwQixhQUFhLDRCQUE0QixhQUFhLHlCQUF5QixhQUFhLHlIQUF5SCxnQ0FBZ0MsYUFBYSx3REFBd0QsYUFBYSw2QkFBNkIsYUFBYSw0QkFBNEIsYUFBYSw4QkFBOEIsYUFBYSwwQkFBMEIsYUFBYSwrQkFBK0IsYUFBYSw2QkFBNkIsYUFBYSw2QkFBNkIsYUFBYSx5QkFBeUIsYUFBYSwrQkFBK0IsYUFBYSx3QkFBd0IsYUFBYSwwQkFBMEIsYUFBYSw2QkFBNkIsYUFBYSxtQkFBbUIsYUFBYSwyQkFBMkIsMEJBQTBCLEVBQUUsOEZBQThGLGFBQWEscURBQXFELGFBQWEsMkJBQTJCLG1DQUFtQyxFQUFFLHFDQUFxQyxxQkFBcUIsNkpBQTZKLHVCQUF1QixxQkFBcUIsc0JBQXNCLEdBQUcsd0JBQXdCLGdDQUFnQyxpTUFBaU0scUJBQXFCLHlCQUF5QixpQkFBaUIsa0JBQWtCLDRFQUE0RSxHQUFHLHFCQUFxQix1QkFBdUIseUNBQXlDLEdBQUcsbVJBQW1SLHVCQUF1QixlQUFlLGtCQUFrQixrQkFBa0IsR0FBRywwQkFBMEIsYUFBYSxRQUFRLHVCQUF1Qix1QkFBdUIsR0FBRywwQkFBMEIsY0FBYyxTQUFTLHVCQUF1Qix1QkFBdUIsR0FBRyxnQ0FBZ0MsYUFBYSxXQUFXLEdBQUcsNkJBQTZCLFlBQVksV0FBVyxHQUFHLHlCQUF5Qix1QkFBdUIsU0FBUyxRQUFRLHFCQUFxQixlQUFlLEdBQUcsc0JBQXNCLHdCQUF3QixpQkFBaUIsMEJBQTBCLHdCQUF3Qix5QkFBeUIsR0FBRyw4QkFBOEIsdUJBQXVCLGVBQWUsZ0NBQWdDLDRCQUE0QixHQUFHLGlDQUFpQyx1QkFBdUIsV0FBVyxXQUFXLGVBQWUsR0FBRywwQkFBMEIsdUJBQXVCLG9CQUFvQixlQUFlLEdBQUcsK0NBQStDLGdDQUFnQywwQ0FBMEMsZ0NBQWdDLCtDQUErQyxnQ0FBZ0MsdUJBQXVCLGlCQUFpQixvQkFBb0IsK0NBQStDLDBFQUEwRSxzRkFBc0Ysb0JBQW9CLDRCQUE0Qix5QkFBeUIsdUJBQXVCLGNBQWMscUJBQXFCLHNCQUFzQix5QkFBeUIsbUJBQW1CLGVBQWUsdUJBQXVCLHNCQUFzQiw2Q0FBNkMsdUNBQXVDLEdBQUcsb0ZBQW9GLDBCQUEwQiwwQkFBMEIsdUJBQXVCLEdBQUcsZ0NBQWdDLHVCQUF1QixZQUFZLFVBQVUsUUFBUSxXQUFXLGVBQWUsR0FBRyw0QkFBNEIsdUJBQXVCLGVBQWUsbUJBQW1CLDhEQUE4RCx5QkFBeUIseUJBQXlCLGdCQUFnQixFQUFFLHNCQUFzQixrQkFBa0IsR0FBRyxvTEFBb0wsNEJBQTRCLEdBQUcseUJBQXlCLHVCQUF1QixnQkFBZ0IsY0FBYyxxQkFBcUIsdUJBQXVCLEdBQUcsd0JBQXdCLHVCQUF1Qix5QkFBeUIsR0FBRywyQkFBMkIsa0JBQWtCLEVBQUUsNEJBQTRCLHVCQUF1Qix1QkFBdUIsZUFBZSxHQUFHLDhCQUE4Qix3QkFBd0IsR0FBRyxnREFBZ0Qsd0JBQXdCLEdBQUcsMEJBQTBCLHFCQUFxQixFQUFFLDRDQUE0QyxxQkFBcUIsRUFBRSx5QkFBeUIsbUJBQW1CLEVBQUUsNkhBQTZILHFCQUFxQixFQUFFLDhHQUE4RyxxQkFBcUIsRUFBRSw2SEFBNkgscUJBQXFCLEVBQUUsbUJBQW1CLDJCQUEyQiw0Q0FBNEMsR0FBRyxxRUFBcUUscUJBQXFCLEVBQUUsa0JBQWtCLCtFQUErRSx5QkFBeUIsS0FBSyxHQUFHLG9EQUFvRCxhQUFhLEVBQUUsc0dBQXNHLGtCQUFrQixFQUFFOztBQUUveVIiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz8hLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPyEuL25vZGVfbW9kdWxlcy9jb2RlbWlycm9yL2xpYi9jb2RlbWlycm9yLmNzcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKShmYWxzZSk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIvKiBCQVNJQ1MgKi9cXG5cXG4uQ29kZU1pcnJvciB7XFxuICAvKiBTZXQgaGVpZ2h0LCB3aWR0aCwgYm9yZGVycywgYW5kIGdsb2JhbCBmb250IHByb3BlcnRpZXMgaGVyZSAqL1xcbiAgZm9udC1mYW1pbHk6IG1vbm9zcGFjZTtcXG4gIGhlaWdodDogMzAwcHg7XFxuICBjb2xvcjogYmxhY2s7XFxuICBkaXJlY3Rpb246IGx0cjtcXG59XFxuXFxuLyogUEFERElORyAqL1xcblxcbi5Db2RlTWlycm9yLWxpbmVzIHtcXG4gIHBhZGRpbmc6IDRweCAwOyAvKiBWZXJ0aWNhbCBwYWRkaW5nIGFyb3VuZCBjb250ZW50ICovXFxufVxcbi5Db2RlTWlycm9yIHByZS5Db2RlTWlycm9yLWxpbmUsXFxuLkNvZGVNaXJyb3IgcHJlLkNvZGVNaXJyb3ItbGluZS1saWtlIHtcXG4gIHBhZGRpbmc6IDAgNHB4OyAvKiBIb3Jpem9udGFsIHBhZGRpbmcgb2YgY29udGVudCAqL1xcbn1cXG5cXG4uQ29kZU1pcnJvci1zY3JvbGxiYXItZmlsbGVyLCAuQ29kZU1pcnJvci1ndXR0ZXItZmlsbGVyIHtcXG4gIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50OyAvKiBUaGUgbGl0dGxlIHNxdWFyZSBiZXR3ZWVuIEggYW5kIFYgc2Nyb2xsYmFycyAqL1xcbn1cXG5cXG4vKiBHVVRURVIgKi9cXG5cXG4uQ29kZU1pcnJvci1ndXR0ZXJzIHtcXG4gIGJvcmRlci1yaWdodDogMXB4IHNvbGlkICNkZGQ7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZjdmN2Y3O1xcbiAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcXG59XFxuLkNvZGVNaXJyb3ItbGluZW51bWJlcnMge31cXG4uQ29kZU1pcnJvci1saW5lbnVtYmVyIHtcXG4gIHBhZGRpbmc6IDAgM3B4IDAgNXB4O1xcbiAgbWluLXdpZHRoOiAyMHB4O1xcbiAgdGV4dC1hbGlnbjogcmlnaHQ7XFxuICBjb2xvcjogIzk5OTtcXG4gIHdoaXRlLXNwYWNlOiBub3dyYXA7XFxufVxcblxcbi5Db2RlTWlycm9yLWd1dHRlcm1hcmtlciB7IGNvbG9yOiBibGFjazsgfVxcbi5Db2RlTWlycm9yLWd1dHRlcm1hcmtlci1zdWJ0bGUgeyBjb2xvcjogIzk5OTsgfVxcblxcbi8qIENVUlNPUiAqL1xcblxcbi5Db2RlTWlycm9yLWN1cnNvciB7XFxuICBib3JkZXItbGVmdDogMXB4IHNvbGlkIGJsYWNrO1xcbiAgYm9yZGVyLXJpZ2h0OiBub25lO1xcbiAgd2lkdGg6IDA7XFxufVxcbi8qIFNob3duIHdoZW4gbW92aW5nIGluIGJpLWRpcmVjdGlvbmFsIHRleHQgKi9cXG4uQ29kZU1pcnJvciBkaXYuQ29kZU1pcnJvci1zZWNvbmRhcnljdXJzb3Ige1xcbiAgYm9yZGVyLWxlZnQ6IDFweCBzb2xpZCBzaWx2ZXI7XFxufVxcbi5jbS1mYXQtY3Vyc29yIC5Db2RlTWlycm9yLWN1cnNvciB7XFxuICB3aWR0aDogYXV0bztcXG4gIGJvcmRlcjogMCAhaW1wb3J0YW50O1xcbiAgYmFja2dyb3VuZDogIzdlNztcXG59XFxuLmNtLWZhdC1jdXJzb3IgZGl2LkNvZGVNaXJyb3ItY3Vyc29ycyB7XFxuICB6LWluZGV4OiAxO1xcbn1cXG4uY20tZmF0LWN1cnNvci1tYXJrIHtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjAsIDI1NSwgMjAsIDAuNSk7XFxuICAtd2Via2l0LWFuaW1hdGlvbjogYmxpbmsgMS4wNnMgc3RlcHMoMSkgaW5maW5pdGU7XFxuICBhbmltYXRpb246IGJsaW5rIDEuMDZzIHN0ZXBzKDEpIGluZmluaXRlO1xcbn1cXG4uY20tYW5pbWF0ZS1mYXQtY3Vyc29yIHtcXG4gIHdpZHRoOiBhdXRvO1xcbiAgYm9yZGVyOiAwO1xcbiAgLXdlYmtpdC1hbmltYXRpb246IGJsaW5rIDEuMDZzIHN0ZXBzKDEpIGluZmluaXRlO1xcbiAgYW5pbWF0aW9uOiBibGluayAxLjA2cyBzdGVwcygxKSBpbmZpbml0ZTtcXG4gIGJhY2tncm91bmQtY29sb3I6ICM3ZTc7XFxufVxcbkAtd2Via2l0LWtleWZyYW1lcyBibGluayB7XFxuICAwJSB7fVxcbiAgNTAlIHsgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7IH1cXG4gIDEwMCUge31cXG59XFxuQGtleWZyYW1lcyBibGluayB7XFxuICAwJSB7fVxcbiAgNTAlIHsgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7IH1cXG4gIDEwMCUge31cXG59XFxuXFxuLyogQ2FuIHN0eWxlIGN1cnNvciBkaWZmZXJlbnQgaW4gb3ZlcndyaXRlIChub24taW5zZXJ0KSBtb2RlICovXFxuLkNvZGVNaXJyb3Itb3ZlcndyaXRlIC5Db2RlTWlycm9yLWN1cnNvciB7fVxcblxcbi5jbS10YWIgeyBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7IHRleHQtZGVjb3JhdGlvbjogaW5oZXJpdDsgfVxcblxcbi5Db2RlTWlycm9yLXJ1bGVycyB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICBsZWZ0OiAwOyByaWdodDogMDsgdG9wOiAtNTBweDsgYm90dG9tOiAwO1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXG59XFxuLkNvZGVNaXJyb3ItcnVsZXIge1xcbiAgYm9yZGVyLWxlZnQ6IDFweCBzb2xpZCAjY2NjO1xcbiAgdG9wOiAwOyBib3R0b206IDA7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxufVxcblxcbi8qIERFRkFVTFQgVEhFTUUgKi9cXG5cXG4uY20tcy1kZWZhdWx0IC5jbS1oZWFkZXIge2NvbG9yOiBibHVlO31cXG4uY20tcy1kZWZhdWx0IC5jbS1xdW90ZSB7Y29sb3I6ICMwOTA7fVxcbi5jbS1uZWdhdGl2ZSB7Y29sb3I6ICNkNDQ7fVxcbi5jbS1wb3NpdGl2ZSB7Y29sb3I6ICMyOTI7fVxcbi5jbS1oZWFkZXIsIC5jbS1zdHJvbmcge2ZvbnQtd2VpZ2h0OiBib2xkO31cXG4uY20tZW0ge2ZvbnQtc3R5bGU6IGl0YWxpYzt9XFxuLmNtLWxpbmsge3RleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lO31cXG4uY20tc3RyaWtldGhyb3VnaCB7dGV4dC1kZWNvcmF0aW9uOiBsaW5lLXRocm91Z2g7fVxcblxcbi5jbS1zLWRlZmF1bHQgLmNtLWtleXdvcmQge2NvbG9yOiAjNzA4O31cXG4uY20tcy1kZWZhdWx0IC5jbS1hdG9tIHtjb2xvcjogIzIxOTt9XFxuLmNtLXMtZGVmYXVsdCAuY20tbnVtYmVyIHtjb2xvcjogIzE2NDt9XFxuLmNtLXMtZGVmYXVsdCAuY20tZGVmIHtjb2xvcjogIzAwZjt9XFxuLmNtLXMtZGVmYXVsdCAuY20tdmFyaWFibGUsXFxuLmNtLXMtZGVmYXVsdCAuY20tcHVuY3R1YXRpb24sXFxuLmNtLXMtZGVmYXVsdCAuY20tcHJvcGVydHksXFxuLmNtLXMtZGVmYXVsdCAuY20tb3BlcmF0b3Ige31cXG4uY20tcy1kZWZhdWx0IC5jbS12YXJpYWJsZS0yIHtjb2xvcjogIzA1YTt9XFxuLmNtLXMtZGVmYXVsdCAuY20tdmFyaWFibGUtMywgLmNtLXMtZGVmYXVsdCAuY20tdHlwZSB7Y29sb3I6ICMwODU7fVxcbi5jbS1zLWRlZmF1bHQgLmNtLWNvbW1lbnQge2NvbG9yOiAjYTUwO31cXG4uY20tcy1kZWZhdWx0IC5jbS1zdHJpbmcge2NvbG9yOiAjYTExO31cXG4uY20tcy1kZWZhdWx0IC5jbS1zdHJpbmctMiB7Y29sb3I6ICNmNTA7fVxcbi5jbS1zLWRlZmF1bHQgLmNtLW1ldGEge2NvbG9yOiAjNTU1O31cXG4uY20tcy1kZWZhdWx0IC5jbS1xdWFsaWZpZXIge2NvbG9yOiAjNTU1O31cXG4uY20tcy1kZWZhdWx0IC5jbS1idWlsdGluIHtjb2xvcjogIzMwYTt9XFxuLmNtLXMtZGVmYXVsdCAuY20tYnJhY2tldCB7Y29sb3I6ICM5OTc7fVxcbi5jbS1zLWRlZmF1bHQgLmNtLXRhZyB7Y29sb3I6ICMxNzA7fVxcbi5jbS1zLWRlZmF1bHQgLmNtLWF0dHJpYnV0ZSB7Y29sb3I6ICMwMGM7fVxcbi5jbS1zLWRlZmF1bHQgLmNtLWhyIHtjb2xvcjogIzk5OTt9XFxuLmNtLXMtZGVmYXVsdCAuY20tbGluayB7Y29sb3I6ICMwMGM7fVxcblxcbi5jbS1zLWRlZmF1bHQgLmNtLWVycm9yIHtjb2xvcjogI2YwMDt9XFxuLmNtLWludmFsaWRjaGFyIHtjb2xvcjogI2YwMDt9XFxuXFxuLkNvZGVNaXJyb3ItY29tcG9zaW5nIHsgYm9yZGVyLWJvdHRvbTogMnB4IHNvbGlkOyB9XFxuXFxuLyogRGVmYXVsdCBzdHlsZXMgZm9yIGNvbW1vbiBhZGRvbnMgKi9cXG5cXG5kaXYuQ29kZU1pcnJvciBzcGFuLkNvZGVNaXJyb3ItbWF0Y2hpbmdicmFja2V0IHtjb2xvcjogIzBiMDt9XFxuZGl2LkNvZGVNaXJyb3Igc3Bhbi5Db2RlTWlycm9yLW5vbm1hdGNoaW5nYnJhY2tldCB7Y29sb3I6ICNhMjI7fVxcbi5Db2RlTWlycm9yLW1hdGNoaW5ndGFnIHsgYmFja2dyb3VuZDogcmdiYSgyNTUsIDE1MCwgMCwgLjMpOyB9XFxuLkNvZGVNaXJyb3ItYWN0aXZlbGluZS1iYWNrZ3JvdW5kIHtiYWNrZ3JvdW5kOiAjZThmMmZmO31cXG5cXG4vKiBTVE9QICovXFxuXFxuLyogVGhlIHJlc3Qgb2YgdGhpcyBmaWxlIGNvbnRhaW5zIHN0eWxlcyByZWxhdGVkIHRvIHRoZSBtZWNoYW5pY3Mgb2ZcXG4gICB0aGUgZWRpdG9yLiBZb3UgcHJvYmFibHkgc2hvdWxkbid0IHRvdWNoIHRoZW0uICovXFxuXFxuLkNvZGVNaXJyb3Ige1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gIGJhY2tncm91bmQ6IHdoaXRlO1xcbn1cXG5cXG4uQ29kZU1pcnJvci1zY3JvbGwge1xcbiAgb3ZlcmZsb3c6IHNjcm9sbCAhaW1wb3J0YW50OyAvKiBUaGluZ3Mgd2lsbCBicmVhayBpZiB0aGlzIGlzIG92ZXJyaWRkZW4gKi9cXG4gIC8qIDUwcHggaXMgdGhlIG1hZ2ljIG1hcmdpbiB1c2VkIHRvIGhpZGUgdGhlIGVsZW1lbnQncyByZWFsIHNjcm9sbGJhcnMgKi9cXG4gIC8qIFNlZSBvdmVyZmxvdzogaGlkZGVuIGluIC5Db2RlTWlycm9yICovXFxuICBtYXJnaW4tYm90dG9tOiAtNTBweDsgbWFyZ2luLXJpZ2h0OiAtNTBweDtcXG4gIHBhZGRpbmctYm90dG9tOiA1MHB4O1xcbiAgaGVpZ2h0OiAxMDAlO1xcbiAgb3V0bGluZTogbm9uZTsgLyogUHJldmVudCBkcmFnZ2luZyBmcm9tIGhpZ2hsaWdodGluZyB0aGUgZWxlbWVudCAqL1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbn1cXG4uQ29kZU1pcnJvci1zaXplciB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICBib3JkZXItcmlnaHQ6IDUwcHggc29saWQgdHJhbnNwYXJlbnQ7XFxufVxcblxcbi8qIFRoZSBmYWtlLCB2aXNpYmxlIHNjcm9sbGJhcnMuIFVzZWQgdG8gZm9yY2UgcmVkcmF3IGR1cmluZyBzY3JvbGxpbmdcXG4gICBiZWZvcmUgYWN0dWFsIHNjcm9sbGluZyBoYXBwZW5zLCB0aHVzIHByZXZlbnRpbmcgc2hha2luZyBhbmRcXG4gICBmbGlja2VyaW5nIGFydGlmYWN0cy4gKi9cXG4uQ29kZU1pcnJvci12c2Nyb2xsYmFyLCAuQ29kZU1pcnJvci1oc2Nyb2xsYmFyLCAuQ29kZU1pcnJvci1zY3JvbGxiYXItZmlsbGVyLCAuQ29kZU1pcnJvci1ndXR0ZXItZmlsbGVyIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHotaW5kZXg6IDY7XFxuICBkaXNwbGF5OiBub25lO1xcbiAgb3V0bGluZTogbm9uZTtcXG59XFxuLkNvZGVNaXJyb3ItdnNjcm9sbGJhciB7XFxuICByaWdodDogMDsgdG9wOiAwO1xcbiAgb3ZlcmZsb3cteDogaGlkZGVuO1xcbiAgb3ZlcmZsb3cteTogc2Nyb2xsO1xcbn1cXG4uQ29kZU1pcnJvci1oc2Nyb2xsYmFyIHtcXG4gIGJvdHRvbTogMDsgbGVmdDogMDtcXG4gIG92ZXJmbG93LXk6IGhpZGRlbjtcXG4gIG92ZXJmbG93LXg6IHNjcm9sbDtcXG59XFxuLkNvZGVNaXJyb3Itc2Nyb2xsYmFyLWZpbGxlciB7XFxuICByaWdodDogMDsgYm90dG9tOiAwO1xcbn1cXG4uQ29kZU1pcnJvci1ndXR0ZXItZmlsbGVyIHtcXG4gIGxlZnQ6IDA7IGJvdHRvbTogMDtcXG59XFxuXFxuLkNvZGVNaXJyb3ItZ3V0dGVycyB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7IGxlZnQ6IDA7IHRvcDogMDtcXG4gIG1pbi1oZWlnaHQ6IDEwMCU7XFxuICB6LWluZGV4OiAzO1xcbn1cXG4uQ29kZU1pcnJvci1ndXR0ZXIge1xcbiAgd2hpdGUtc3BhY2U6IG5vcm1hbDtcXG4gIGhlaWdodDogMTAwJTtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIHZlcnRpY2FsLWFsaWduOiB0b3A7XFxuICBtYXJnaW4tYm90dG9tOiAtNTBweDtcXG59XFxuLkNvZGVNaXJyb3ItZ3V0dGVyLXdyYXBwZXIge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgei1pbmRleDogNDtcXG4gIGJhY2tncm91bmQ6IG5vbmUgIWltcG9ydGFudDtcXG4gIGJvcmRlcjogbm9uZSAhaW1wb3J0YW50O1xcbn1cXG4uQ29kZU1pcnJvci1ndXR0ZXItYmFja2dyb3VuZCB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB0b3A6IDA7IGJvdHRvbTogMDtcXG4gIHotaW5kZXg6IDQ7XFxufVxcbi5Db2RlTWlycm9yLWd1dHRlci1lbHQge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgY3Vyc29yOiBkZWZhdWx0O1xcbiAgei1pbmRleDogNDtcXG59XFxuLkNvZGVNaXJyb3ItZ3V0dGVyLXdyYXBwZXIgOjotbW96LXNlbGVjdGlvbiB7IGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50IH1cXG4uQ29kZU1pcnJvci1ndXR0ZXItd3JhcHBlciA6OnNlbGVjdGlvbiB7IGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50IH1cXG4uQ29kZU1pcnJvci1ndXR0ZXItd3JhcHBlciA6Oi1tb3otc2VsZWN0aW9uIHsgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQgfVxcblxcbi5Db2RlTWlycm9yLWxpbmVzIHtcXG4gIGN1cnNvcjogdGV4dDtcXG4gIG1pbi1oZWlnaHQ6IDFweDsgLyogcHJldmVudHMgY29sbGFwc2luZyBiZWZvcmUgZmlyc3QgZHJhdyAqL1xcbn1cXG4uQ29kZU1pcnJvciBwcmUuQ29kZU1pcnJvci1saW5lLFxcbi5Db2RlTWlycm9yIHByZS5Db2RlTWlycm9yLWxpbmUtbGlrZSB7XFxuICAvKiBSZXNldCBzb21lIHN0eWxlcyB0aGF0IHRoZSByZXN0IG9mIHRoZSBwYWdlIG1pZ2h0IGhhdmUgc2V0ICovIGJvcmRlci1yYWRpdXM6IDA7XFxuICBib3JkZXItd2lkdGg6IDA7XFxuICBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcXG4gIGZvbnQtZmFtaWx5OiBpbmhlcml0O1xcbiAgZm9udC1zaXplOiBpbmhlcml0O1xcbiAgbWFyZ2luOiAwO1xcbiAgd2hpdGUtc3BhY2U6IHByZTtcXG4gIHdvcmQtd3JhcDogbm9ybWFsO1xcbiAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7XFxuICBjb2xvcjogaW5oZXJpdDtcXG4gIHotaW5kZXg6IDI7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICBvdmVyZmxvdzogdmlzaWJsZTtcXG4gIC13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICBmb250LXZhcmlhbnQtbGlnYXR1cmVzOiBjb250ZXh0dWFsO1xcbn1cXG4uQ29kZU1pcnJvci13cmFwIHByZS5Db2RlTWlycm9yLWxpbmUsXFxuLkNvZGVNaXJyb3Itd3JhcCBwcmUuQ29kZU1pcnJvci1saW5lLWxpa2Uge1xcbiAgd29yZC13cmFwOiBicmVhay13b3JkO1xcbiAgd2hpdGUtc3BhY2U6IHByZS13cmFwO1xcbiAgd29yZC1icmVhazogbm9ybWFsO1xcbn1cXG5cXG4uQ29kZU1pcnJvci1saW5lYmFja2dyb3VuZCB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICBsZWZ0OiAwOyByaWdodDogMDsgdG9wOiAwOyBib3R0b206IDA7XFxuICB6LWluZGV4OiAwO1xcbn1cXG5cXG4uQ29kZU1pcnJvci1saW5ld2lkZ2V0IHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIHotaW5kZXg6IDI7XFxuICBwYWRkaW5nOiAwLjFweDsgLyogRm9yY2Ugd2lkZ2V0IG1hcmdpbnMgdG8gc3RheSBpbnNpZGUgb2YgdGhlIGNvbnRhaW5lciAqL1xcbn1cXG5cXG4uQ29kZU1pcnJvci13aWRnZXQge31cXG5cXG4uQ29kZU1pcnJvci1ydGwgcHJlIHsgZGlyZWN0aW9uOiBydGw7IH1cXG5cXG4uQ29kZU1pcnJvci1jb2RlIHtcXG4gIG91dGxpbmU6IG5vbmU7XFxufVxcblxcbi8qIEZvcmNlIGNvbnRlbnQtYm94IHNpemluZyBmb3IgdGhlIGVsZW1lbnRzIHdoZXJlIHdlIGV4cGVjdCBpdCAqL1xcbi5Db2RlTWlycm9yLXNjcm9sbCxcXG4uQ29kZU1pcnJvci1zaXplcixcXG4uQ29kZU1pcnJvci1ndXR0ZXIsXFxuLkNvZGVNaXJyb3ItZ3V0dGVycyxcXG4uQ29kZU1pcnJvci1saW5lbnVtYmVyIHtcXG4gIGJveC1zaXppbmc6IGNvbnRlbnQtYm94O1xcbn1cXG5cXG4uQ29kZU1pcnJvci1tZWFzdXJlIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgaGVpZ2h0OiAwO1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gIHZpc2liaWxpdHk6IGhpZGRlbjtcXG59XFxuXFxuLkNvZGVNaXJyb3ItY3Vyc29yIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHBvaW50ZXItZXZlbnRzOiBub25lO1xcbn1cXG4uQ29kZU1pcnJvci1tZWFzdXJlIHByZSB7IHBvc2l0aW9uOiBzdGF0aWM7IH1cXG5cXG5kaXYuQ29kZU1pcnJvci1jdXJzb3JzIHtcXG4gIHZpc2liaWxpdHk6IGhpZGRlbjtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIHotaW5kZXg6IDM7XFxufVxcbmRpdi5Db2RlTWlycm9yLWRyYWdjdXJzb3JzIHtcXG4gIHZpc2liaWxpdHk6IHZpc2libGU7XFxufVxcblxcbi5Db2RlTWlycm9yLWZvY3VzZWQgZGl2LkNvZGVNaXJyb3ItY3Vyc29ycyB7XFxuICB2aXNpYmlsaXR5OiB2aXNpYmxlO1xcbn1cXG5cXG4uQ29kZU1pcnJvci1zZWxlY3RlZCB7IGJhY2tncm91bmQ6ICNkOWQ5ZDk7IH1cXG4uQ29kZU1pcnJvci1mb2N1c2VkIC5Db2RlTWlycm9yLXNlbGVjdGVkIHsgYmFja2dyb3VuZDogI2Q3ZDRmMDsgfVxcbi5Db2RlTWlycm9yLWNyb3NzaGFpciB7IGN1cnNvcjogY3Jvc3NoYWlyOyB9XFxuLkNvZGVNaXJyb3ItbGluZTo6LW1vei1zZWxlY3Rpb24sIC5Db2RlTWlycm9yLWxpbmUgPiBzcGFuOjotbW96LXNlbGVjdGlvbiwgLkNvZGVNaXJyb3ItbGluZSA+IHNwYW4gPiBzcGFuOjotbW96LXNlbGVjdGlvbiB7IGJhY2tncm91bmQ6ICNkN2Q0ZjA7IH1cXG4uQ29kZU1pcnJvci1saW5lOjpzZWxlY3Rpb24sIC5Db2RlTWlycm9yLWxpbmUgPiBzcGFuOjpzZWxlY3Rpb24sIC5Db2RlTWlycm9yLWxpbmUgPiBzcGFuID4gc3Bhbjo6c2VsZWN0aW9uIHsgYmFja2dyb3VuZDogI2Q3ZDRmMDsgfVxcbi5Db2RlTWlycm9yLWxpbmU6Oi1tb3otc2VsZWN0aW9uLCAuQ29kZU1pcnJvci1saW5lID4gc3Bhbjo6LW1vei1zZWxlY3Rpb24sIC5Db2RlTWlycm9yLWxpbmUgPiBzcGFuID4gc3Bhbjo6LW1vei1zZWxlY3Rpb24geyBiYWNrZ3JvdW5kOiAjZDdkNGYwOyB9XFxuXFxuLmNtLXNlYXJjaGluZyB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZhO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNTUsIDI1NSwgMCwgLjQpO1xcbn1cXG5cXG4vKiBVc2VkIHRvIGZvcmNlIGEgYm9yZGVyIG1vZGVsIGZvciBhIG5vZGUgKi9cXG4uY20tZm9yY2UtYm9yZGVyIHsgcGFkZGluZy1yaWdodDogLjFweDsgfVxcblxcbkBtZWRpYSBwcmludCB7XFxuICAvKiBIaWRlIHRoZSBjdXJzb3Igd2hlbiBwcmludGluZyAqL1xcbiAgLkNvZGVNaXJyb3IgZGl2LkNvZGVNaXJyb3ItY3Vyc29ycyB7XFxuICAgIHZpc2liaWxpdHk6IGhpZGRlbjtcXG4gIH1cXG59XFxuXFxuLyogU2VlIGlzc3VlICMyOTAxICovXFxuLmNtLXRhYi13cmFwLWhhY2s6YWZ0ZXIgeyBjb250ZW50OiAnJzsgfVxcblxcbi8qIEhlbHAgdXNlcnMgdXNlIG1hcmtzZWxlY3Rpb24gdG8gc2FmZWx5IHN0eWxlIHRleHQgYmFja2dyb3VuZCAqL1xcbnNwYW4uQ29kZU1pcnJvci1zZWxlY3RlZHRleHQgeyBiYWNrZ3JvdW5kOiBub25lOyB9XFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/css-loader/index.js?!./node_modules/postcss-loader/src/index.js?!./node_modules/codemirror/lib/codemirror.css\n");

/***/ }),

/***/ "./node_modules/css-loader/index.js?!./node_modules/postcss-loader/src/index.js?!./node_modules/codemirror/theme/shadowfox.css":
/*!***************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader??ref--10-1!./node_modules/postcss-loader/src??ref--10-2!./node_modules/codemirror/theme/shadowfox.css ***!
  \***************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(/*! ../../css-loader/lib/css-base.js */ \"./node_modules/css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.i, \"/*\\n\\n    Name:       shadowfox\\n    Author:     overdodactyl (http://github.com/overdodactyl)\\n\\n    Original shadowfox color scheme by Firefox\\n\\n*/\\n\\n.cm-s-shadowfox.CodeMirror { background: #2a2a2e; color: #b1b1b3; }\\n.cm-s-shadowfox div.CodeMirror-selected { background: #353B48; }\\n.cm-s-shadowfox .CodeMirror-line::-moz-selection, .cm-s-shadowfox .CodeMirror-line > span::-moz-selection, .cm-s-shadowfox .CodeMirror-line > span > span::-moz-selection { background: #353B48; }\\n.cm-s-shadowfox .CodeMirror-line::selection, .cm-s-shadowfox .CodeMirror-line > span::selection, .cm-s-shadowfox .CodeMirror-line > span > span::selection { background: #353B48; }\\n.cm-s-shadowfox .CodeMirror-line::-moz-selection, .cm-s-shadowfox .CodeMirror-line > span::-moz-selection, .cm-s-shadowfox .CodeMirror-line > span > span::-moz-selection { background: #353B48; }\\n.cm-s-shadowfox .CodeMirror-gutters { background: #0c0c0d ; border-right: 1px solid #0c0c0d; }\\n.cm-s-shadowfox .CodeMirror-guttermarker { color: #555; }\\n.cm-s-shadowfox .CodeMirror-linenumber { color: #939393; }\\n.cm-s-shadowfox .CodeMirror-cursor { border-left: 1px solid #fff; }\\n\\n.cm-s-shadowfox span.cm-comment { color: #939393; }\\n.cm-s-shadowfox span.cm-atom { color: #FF7DE9; }\\n.cm-s-shadowfox span.cm-quote { color: #FF7DE9; }\\n.cm-s-shadowfox span.cm-builtin { color: #FF7DE9; }\\n.cm-s-shadowfox span.cm-attribute { color: #FF7DE9; }\\n.cm-s-shadowfox span.cm-keyword { color: #FF7DE9; }\\n.cm-s-shadowfox span.cm-error { color: #FF7DE9; }\\n\\n.cm-s-shadowfox span.cm-number { color: #6B89FF; }\\n.cm-s-shadowfox span.cm-string { color: #6B89FF; }\\n.cm-s-shadowfox span.cm-string-2 { color: #6B89FF; }\\n\\n.cm-s-shadowfox span.cm-meta { color: #939393; }\\n.cm-s-shadowfox span.cm-hr { color: #939393; }\\n\\n.cm-s-shadowfox span.cm-header { color: #75BFFF; }\\n.cm-s-shadowfox span.cm-qualifier { color: #75BFFF; }\\n.cm-s-shadowfox span.cm-variable-2 { color: #75BFFF; }\\n\\n.cm-s-shadowfox span.cm-property { color: #86DE74; }\\n\\n.cm-s-shadowfox span.cm-def { color: #75BFFF; }\\n.cm-s-shadowfox span.cm-bracket { color: #75BFFF; }\\n.cm-s-shadowfox span.cm-tag { color: #75BFFF; }\\n.cm-s-shadowfox span.cm-link:visited { color: #75BFFF; }\\n\\n.cm-s-shadowfox span.cm-variable { color: #B98EFF; }\\n.cm-s-shadowfox span.cm-variable-3 { color: #d7d7db; }\\n.cm-s-shadowfox span.cm-link { color: #737373; }\\n.cm-s-shadowfox span.cm-operator { color: #b1b1b3; }\\n.cm-s-shadowfox span.cm-special { color: #d7d7db; }\\n\\n.cm-s-shadowfox .CodeMirror-activeline-background { background: rgba(185, 215, 253, .15) }\\n.cm-s-shadowfox .CodeMirror-matchingbracket { outline: solid 1px rgba(255, 255, 255, .25); color: white !important; }\\n\", \"\"]);\n\n// exports\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29kZW1pcnJvci90aGVtZS9zaGFkb3dmb3guY3NzPzMxNDMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsMkJBQTJCLG1CQUFPLENBQUMsbUZBQWtDO0FBQ3JFOzs7QUFHQTtBQUNBLGNBQWMsUUFBUyx5TEFBeUwscUJBQXFCLGdCQUFnQixFQUFFLDJDQUEyQyxxQkFBcUIsRUFBRSw2S0FBNksscUJBQXFCLEVBQUUsOEpBQThKLHFCQUFxQixFQUFFLDZLQUE2SyxxQkFBcUIsRUFBRSx1Q0FBdUMsc0JBQXNCLGlDQUFpQyxFQUFFLDRDQUE0QyxhQUFhLEVBQUUsMENBQTBDLGdCQUFnQixFQUFFLHNDQUFzQyw2QkFBNkIsRUFBRSxxQ0FBcUMsZ0JBQWdCLEVBQUUsZ0NBQWdDLGdCQUFnQixFQUFFLGlDQUFpQyxnQkFBZ0IsRUFBRSxtQ0FBbUMsZ0JBQWdCLEVBQUUscUNBQXFDLGdCQUFnQixFQUFFLG1DQUFtQyxnQkFBZ0IsRUFBRSxpQ0FBaUMsZ0JBQWdCLEVBQUUsb0NBQW9DLGdCQUFnQixFQUFFLGtDQUFrQyxnQkFBZ0IsRUFBRSxvQ0FBb0MsZ0JBQWdCLEVBQUUsa0NBQWtDLGdCQUFnQixFQUFFLDhCQUE4QixnQkFBZ0IsRUFBRSxvQ0FBb0MsZ0JBQWdCLEVBQUUscUNBQXFDLGdCQUFnQixFQUFFLHNDQUFzQyxnQkFBZ0IsRUFBRSxzQ0FBc0MsZ0JBQWdCLEVBQUUsaUNBQWlDLGdCQUFnQixFQUFFLG1DQUFtQyxnQkFBZ0IsRUFBRSwrQkFBK0IsZ0JBQWdCLEVBQUUsd0NBQXdDLGdCQUFnQixFQUFFLHNDQUFzQyxnQkFBZ0IsRUFBRSxzQ0FBc0MsZ0JBQWdCLEVBQUUsZ0NBQWdDLGdCQUFnQixFQUFFLG9DQUFvQyxnQkFBZ0IsRUFBRSxtQ0FBbUMsZ0JBQWdCLEVBQUUsdURBQXVELHVDQUF1QywrQ0FBK0MsNkNBQTZDLHlCQUF5QixFQUFFOztBQUV4cEYiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz8hLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPyEuL25vZGVfbW9kdWxlcy9jb2RlbWlycm9yL3RoZW1lL3NoYWRvd2ZveC5jc3MuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoZmFsc2UpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLypcXG5cXG4gICAgTmFtZTogICAgICAgc2hhZG93Zm94XFxuICAgIEF1dGhvcjogICAgIG92ZXJkb2RhY3R5bCAoaHR0cDovL2dpdGh1Yi5jb20vb3ZlcmRvZGFjdHlsKVxcblxcbiAgICBPcmlnaW5hbCBzaGFkb3dmb3ggY29sb3Igc2NoZW1lIGJ5IEZpcmVmb3hcXG5cXG4qL1xcblxcbi5jbS1zLXNoYWRvd2ZveC5Db2RlTWlycm9yIHsgYmFja2dyb3VuZDogIzJhMmEyZTsgY29sb3I6ICNiMWIxYjM7IH1cXG4uY20tcy1zaGFkb3dmb3ggZGl2LkNvZGVNaXJyb3Itc2VsZWN0ZWQgeyBiYWNrZ3JvdW5kOiAjMzUzQjQ4OyB9XFxuLmNtLXMtc2hhZG93Zm94IC5Db2RlTWlycm9yLWxpbmU6Oi1tb3otc2VsZWN0aW9uLCAuY20tcy1zaGFkb3dmb3ggLkNvZGVNaXJyb3ItbGluZSA+IHNwYW46Oi1tb3otc2VsZWN0aW9uLCAuY20tcy1zaGFkb3dmb3ggLkNvZGVNaXJyb3ItbGluZSA+IHNwYW4gPiBzcGFuOjotbW96LXNlbGVjdGlvbiB7IGJhY2tncm91bmQ6ICMzNTNCNDg7IH1cXG4uY20tcy1zaGFkb3dmb3ggLkNvZGVNaXJyb3ItbGluZTo6c2VsZWN0aW9uLCAuY20tcy1zaGFkb3dmb3ggLkNvZGVNaXJyb3ItbGluZSA+IHNwYW46OnNlbGVjdGlvbiwgLmNtLXMtc2hhZG93Zm94IC5Db2RlTWlycm9yLWxpbmUgPiBzcGFuID4gc3Bhbjo6c2VsZWN0aW9uIHsgYmFja2dyb3VuZDogIzM1M0I0ODsgfVxcbi5jbS1zLXNoYWRvd2ZveCAuQ29kZU1pcnJvci1saW5lOjotbW96LXNlbGVjdGlvbiwgLmNtLXMtc2hhZG93Zm94IC5Db2RlTWlycm9yLWxpbmUgPiBzcGFuOjotbW96LXNlbGVjdGlvbiwgLmNtLXMtc2hhZG93Zm94IC5Db2RlTWlycm9yLWxpbmUgPiBzcGFuID4gc3Bhbjo6LW1vei1zZWxlY3Rpb24geyBiYWNrZ3JvdW5kOiAjMzUzQjQ4OyB9XFxuLmNtLXMtc2hhZG93Zm94IC5Db2RlTWlycm9yLWd1dHRlcnMgeyBiYWNrZ3JvdW5kOiAjMGMwYzBkIDsgYm9yZGVyLXJpZ2h0OiAxcHggc29saWQgIzBjMGMwZDsgfVxcbi5jbS1zLXNoYWRvd2ZveCAuQ29kZU1pcnJvci1ndXR0ZXJtYXJrZXIgeyBjb2xvcjogIzU1NTsgfVxcbi5jbS1zLXNoYWRvd2ZveCAuQ29kZU1pcnJvci1saW5lbnVtYmVyIHsgY29sb3I6ICM5MzkzOTM7IH1cXG4uY20tcy1zaGFkb3dmb3ggLkNvZGVNaXJyb3ItY3Vyc29yIHsgYm9yZGVyLWxlZnQ6IDFweCBzb2xpZCAjZmZmOyB9XFxuXFxuLmNtLXMtc2hhZG93Zm94IHNwYW4uY20tY29tbWVudCB7IGNvbG9yOiAjOTM5MzkzOyB9XFxuLmNtLXMtc2hhZG93Zm94IHNwYW4uY20tYXRvbSB7IGNvbG9yOiAjRkY3REU5OyB9XFxuLmNtLXMtc2hhZG93Zm94IHNwYW4uY20tcXVvdGUgeyBjb2xvcjogI0ZGN0RFOTsgfVxcbi5jbS1zLXNoYWRvd2ZveCBzcGFuLmNtLWJ1aWx0aW4geyBjb2xvcjogI0ZGN0RFOTsgfVxcbi5jbS1zLXNoYWRvd2ZveCBzcGFuLmNtLWF0dHJpYnV0ZSB7IGNvbG9yOiAjRkY3REU5OyB9XFxuLmNtLXMtc2hhZG93Zm94IHNwYW4uY20ta2V5d29yZCB7IGNvbG9yOiAjRkY3REU5OyB9XFxuLmNtLXMtc2hhZG93Zm94IHNwYW4uY20tZXJyb3IgeyBjb2xvcjogI0ZGN0RFOTsgfVxcblxcbi5jbS1zLXNoYWRvd2ZveCBzcGFuLmNtLW51bWJlciB7IGNvbG9yOiAjNkI4OUZGOyB9XFxuLmNtLXMtc2hhZG93Zm94IHNwYW4uY20tc3RyaW5nIHsgY29sb3I6ICM2Qjg5RkY7IH1cXG4uY20tcy1zaGFkb3dmb3ggc3Bhbi5jbS1zdHJpbmctMiB7IGNvbG9yOiAjNkI4OUZGOyB9XFxuXFxuLmNtLXMtc2hhZG93Zm94IHNwYW4uY20tbWV0YSB7IGNvbG9yOiAjOTM5MzkzOyB9XFxuLmNtLXMtc2hhZG93Zm94IHNwYW4uY20taHIgeyBjb2xvcjogIzkzOTM5MzsgfVxcblxcbi5jbS1zLXNoYWRvd2ZveCBzcGFuLmNtLWhlYWRlciB7IGNvbG9yOiAjNzVCRkZGOyB9XFxuLmNtLXMtc2hhZG93Zm94IHNwYW4uY20tcXVhbGlmaWVyIHsgY29sb3I6ICM3NUJGRkY7IH1cXG4uY20tcy1zaGFkb3dmb3ggc3Bhbi5jbS12YXJpYWJsZS0yIHsgY29sb3I6ICM3NUJGRkY7IH1cXG5cXG4uY20tcy1zaGFkb3dmb3ggc3Bhbi5jbS1wcm9wZXJ0eSB7IGNvbG9yOiAjODZERTc0OyB9XFxuXFxuLmNtLXMtc2hhZG93Zm94IHNwYW4uY20tZGVmIHsgY29sb3I6ICM3NUJGRkY7IH1cXG4uY20tcy1zaGFkb3dmb3ggc3Bhbi5jbS1icmFja2V0IHsgY29sb3I6ICM3NUJGRkY7IH1cXG4uY20tcy1zaGFkb3dmb3ggc3Bhbi5jbS10YWcgeyBjb2xvcjogIzc1QkZGRjsgfVxcbi5jbS1zLXNoYWRvd2ZveCBzcGFuLmNtLWxpbms6dmlzaXRlZCB7IGNvbG9yOiAjNzVCRkZGOyB9XFxuXFxuLmNtLXMtc2hhZG93Zm94IHNwYW4uY20tdmFyaWFibGUgeyBjb2xvcjogI0I5OEVGRjsgfVxcbi5jbS1zLXNoYWRvd2ZveCBzcGFuLmNtLXZhcmlhYmxlLTMgeyBjb2xvcjogI2Q3ZDdkYjsgfVxcbi5jbS1zLXNoYWRvd2ZveCBzcGFuLmNtLWxpbmsgeyBjb2xvcjogIzczNzM3MzsgfVxcbi5jbS1zLXNoYWRvd2ZveCBzcGFuLmNtLW9wZXJhdG9yIHsgY29sb3I6ICNiMWIxYjM7IH1cXG4uY20tcy1zaGFkb3dmb3ggc3Bhbi5jbS1zcGVjaWFsIHsgY29sb3I6ICNkN2Q3ZGI7IH1cXG5cXG4uY20tcy1zaGFkb3dmb3ggLkNvZGVNaXJyb3ItYWN0aXZlbGluZS1iYWNrZ3JvdW5kIHsgYmFja2dyb3VuZDogcmdiYSgxODUsIDIxNSwgMjUzLCAuMTUpIH1cXG4uY20tcy1zaGFkb3dmb3ggLkNvZGVNaXJyb3ItbWF0Y2hpbmdicmFja2V0IHsgb3V0bGluZTogc29saWQgMXB4IHJnYmEoMjU1LCAyNTUsIDI1NSwgLjI1KTsgY29sb3I6IHdoaXRlICFpbXBvcnRhbnQ7IH1cXG5cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/css-loader/index.js?!./node_modules/postcss-loader/src/index.js?!./node_modules/codemirror/theme/shadowfox.css\n");

/***/ }),

/***/ "./node_modules/css-loader/index.js?!./node_modules/postcss-loader/src/index.js?!./node_modules/filepond/dist/filepond.min.css":
/*!***************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader??ref--10-1!./node_modules/postcss-loader/src??ref--10-2!./node_modules/filepond/dist/filepond.min.css ***!
  \***************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(/*! ../../css-loader/lib/css-base.js */ \"./node_modules/css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.i, \"/*!\\n * FilePond 4.25.1\\n * Licensed under MIT, https://opensource.org/licenses/MIT/\\n * Please visit https://pqina.nl/filepond/ for details.\\n */\\n\\n/* eslint-disable */\\n.filepond--assistant{position:absolute;overflow:hidden;height:1px;width:1px;padding:0;border:0;clip:rect(1px,1px,1px,1px);-webkit-clip-path:inset(50%);clip-path:inset(50%);white-space:nowrap}.filepond--browser.filepond--browser{position:absolute;margin:0;padding:0;left:1em;top:1.75em;width:calc(100% - 2em);opacity:0;font-size:0}.filepond--data{position:absolute;width:0;height:0;padding:0;margin:0;border:none;visibility:hidden;pointer-events:none;contain:strict}.filepond--drip{position:absolute;top:0;left:0;right:0;bottom:0;overflow:hidden;opacity:.1;pointer-events:none;border-radius:.5em;background:rgba(0,0,0,.01)}.filepond--drip-blob{-webkit-transform-origin:center center;transform-origin:center center;width:8em;height:8em;margin-left:-4em;margin-top:-4em;background:#292625;border-radius:50%}.filepond--drip-blob,.filepond--drop-label{position:absolute;top:0;left:0;will-change:transform,opacity}.filepond--drop-label{right:0;margin:0;color:#4f4f4f;display:flex;justify-content:center;align-items:center;height:0;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.filepond--drop-label.filepond--drop-label label{display:block;margin:0;padding:.5em}.filepond--drop-label label{cursor:default;font-size:.875em;font-weight:400;text-align:center;line-height:1.5}.filepond--label-action{text-decoration:underline;-webkit-text-decoration-skip:ink;text-decoration-skip-ink:auto;-webkit-text-decoration-color:#a7a4a4;text-decoration-color:#a7a4a4;cursor:pointer}.filepond--root[data-disabled] .filepond--drop-label label{opacity:.5}.filepond--file-action-button.filepond--file-action-button{font-size:1em;width:1.625em;height:1.625em;font-family:inherit;line-height:inherit;margin:0;padding:0;border:none;outline:none;will-change:transform,opacity}.filepond--file-action-button.filepond--file-action-button span{position:absolute;overflow:hidden;height:1px;width:1px;padding:0;border:0;clip:rect(1px,1px,1px,1px);-webkit-clip-path:inset(50%);clip-path:inset(50%);white-space:nowrap}.filepond--file-action-button.filepond--file-action-button svg{width:100%;height:100%}.filepond--file-action-button.filepond--file-action-button:after{position:absolute;left:-.75em;right:-.75em;top:-.75em;bottom:-.75em;content:\\\"\\\"}.filepond--file-action-button{cursor:auto;color:#fff;border-radius:50%;background-color:rgba(0,0,0,.5);background-image:none;box-shadow:0 0 0 0 hsla(0,0%,100%,0);transition:box-shadow .25s ease-in}.filepond--file-action-button:focus,.filepond--file-action-button:hover{box-shadow:0 0 0 .125em hsla(0,0%,100%,.9)}.filepond--file-action-button[disabled]{color:hsla(0,0%,100%,.5);background-color:rgba(0,0,0,.25)}.filepond--file-action-button[hidden]{display:none}.filepond--action-edit-item.filepond--action-edit-item{width:2em;height:2em;padding:.1875em}.filepond--action-edit-item.filepond--action-edit-item[data-align*=center]{margin-left:-.1875em}.filepond--action-edit-item.filepond--action-edit-item[data-align*=bottom]{margin-bottom:-.1875em}.filepond--action-edit-item-alt{border:none;line-height:inherit;background:transparent;font-family:inherit;color:inherit;outline:none;padding:0;margin:0 0 0 .25em;pointer-events:all;position:absolute}.filepond--action-edit-item-alt svg{width:1.3125em;height:1.3125em}.filepond--action-edit-item-alt span{font-size:0;opacity:0}.filepond--file-info{position:static;display:flex;flex-direction:column;align-items:flex-start;flex:1;margin:0 .5em 0 0;min-width:0;will-change:transform,opacity;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.filepond--file-info *{margin:0}.filepond--file-info .filepond--file-info-main{font-size:.75em;line-height:1.2;text-overflow:ellipsis;overflow:hidden;white-space:nowrap;width:100%}.filepond--file-info .filepond--file-info-sub{font-size:.625em;opacity:.5;transition:opacity .25s ease-in-out;white-space:nowrap}.filepond--file-info .filepond--file-info-sub:empty{display:none}.filepond--file-status{position:static;display:flex;flex-direction:column;align-items:flex-end;flex-grow:0;flex-shrink:0;margin:0;min-width:2.25em;text-align:right;will-change:transform,opacity;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.filepond--file-status *{margin:0;white-space:nowrap}.filepond--file-status .filepond--file-status-main{font-size:.75em;line-height:1.2}.filepond--file-status .filepond--file-status-sub{font-size:.625em;opacity:.5;transition:opacity .25s ease-in-out}.filepond--file-wrapper.filepond--file-wrapper{border:none;margin:0;padding:0;min-width:0;height:100%}.filepond--file-wrapper.filepond--file-wrapper>legend{position:absolute;overflow:hidden;height:1px;width:1px;padding:0;border:0;clip:rect(1px,1px,1px,1px);-webkit-clip-path:inset(50%);clip-path:inset(50%);white-space:nowrap}.filepond--file{position:static;display:flex;height:100%;align-items:flex-start;padding:.5625em;color:#fff;border-radius:.5em}.filepond--file .filepond--file-status{margin-left:auto;margin-right:2.25em}.filepond--file .filepond--processing-complete-indicator{pointer-events:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;z-index:3}.filepond--file .filepond--file-action-button,.filepond--file .filepond--processing-complete-indicator,.filepond--file .filepond--progress-indicator{position:absolute}.filepond--file [data-align*=left]{left:.5625em}.filepond--file [data-align*=right]{right:.5625em}.filepond--file [data-align*=center]{left:calc(50% - .8125em)}.filepond--file [data-align*=bottom]{bottom:1.125em}.filepond--file [data-align=center]{top:calc(50% - .8125em)}.filepond--file .filepond--progress-indicator{margin-top:.1875em}.filepond--file .filepond--progress-indicator[data-align*=right]{margin-right:.1875em}.filepond--file .filepond--progress-indicator[data-align*=left]{margin-left:.1875em}[data-filepond-item-state*=error] .filepond--file-info,[data-filepond-item-state*=invalid] .filepond--file-info,[data-filepond-item-state=cancelled] .filepond--file-info{margin-right:2.25em}[data-filepond-item-state~=processing] .filepond--file-status-sub{opacity:0}[data-filepond-item-state~=processing] .filepond--action-abort-item-processing~.filepond--file-status .filepond--file-status-sub{opacity:.5}[data-filepond-item-state=processing-error] .filepond--file-status-sub{opacity:0}[data-filepond-item-state=processing-error] .filepond--action-retry-item-processing~.filepond--file-status .filepond--file-status-sub{opacity:.5}[data-filepond-item-state=processing-complete] .filepond--action-revert-item-processing svg{-webkit-animation:fall .5s linear .125s both;animation:fall .5s linear .125s both}[data-filepond-item-state=processing-complete] .filepond--file-status-sub{opacity:.5}[data-filepond-item-state=processing-complete] .filepond--file-info-sub,[data-filepond-item-state=processing-complete] .filepond--processing-complete-indicator:not([style*=hidden])~.filepond--file-status .filepond--file-status-sub{opacity:0}[data-filepond-item-state=processing-complete] .filepond--action-revert-item-processing~.filepond--file-info .filepond--file-info-sub{opacity:.5}[data-filepond-item-state*=error] .filepond--file-wrapper,[data-filepond-item-state*=error] .filepond--panel,[data-filepond-item-state*=invalid] .filepond--file-wrapper,[data-filepond-item-state*=invalid] .filepond--panel{-webkit-animation:shake .65s linear both;animation:shake .65s linear both}[data-filepond-item-state*=busy] .filepond--progress-indicator svg{-webkit-animation:spin 1s linear infinite;animation:spin 1s linear infinite}@-webkit-keyframes spin{0%{-webkit-transform:rotate(0deg);transform:rotate(0deg)}to{-webkit-transform:rotate(1turn);transform:rotate(1turn)}}@keyframes spin{0%{-webkit-transform:rotate(0deg);transform:rotate(0deg)}to{-webkit-transform:rotate(1turn);transform:rotate(1turn)}}@-webkit-keyframes shake{10%,90%{-webkit-transform:translateX(-.0625em);transform:translateX(-.0625em)}20%,80%{-webkit-transform:translateX(.125em);transform:translateX(.125em)}30%,50%,70%{-webkit-transform:translateX(-.25em);transform:translateX(-.25em)}40%,60%{-webkit-transform:translateX(.25em);transform:translateX(.25em)}}@keyframes shake{10%,90%{-webkit-transform:translateX(-.0625em);transform:translateX(-.0625em)}20%,80%{-webkit-transform:translateX(.125em);transform:translateX(.125em)}30%,50%,70%{-webkit-transform:translateX(-.25em);transform:translateX(-.25em)}40%,60%{-webkit-transform:translateX(.25em);transform:translateX(.25em)}}@-webkit-keyframes fall{0%{opacity:0;-webkit-transform:scale(.5);transform:scale(.5);-webkit-animation-timing-function:ease-out;animation-timing-function:ease-out}70%{opacity:1;-webkit-transform:scale(1.1);transform:scale(1.1);-webkit-animation-timing-function:ease-in-out;animation-timing-function:ease-in-out}to{-webkit-transform:scale(1);transform:scale(1);-webkit-animation-timing-function:ease-out;animation-timing-function:ease-out}}@keyframes fall{0%{opacity:0;-webkit-transform:scale(.5);transform:scale(.5);-webkit-animation-timing-function:ease-out;animation-timing-function:ease-out}70%{opacity:1;-webkit-transform:scale(1.1);transform:scale(1.1);-webkit-animation-timing-function:ease-in-out;animation-timing-function:ease-in-out}to{-webkit-transform:scale(1);transform:scale(1);-webkit-animation-timing-function:ease-out;animation-timing-function:ease-out}}.filepond--hopper[data-hopper-state=drag-over]>*{pointer-events:none}.filepond--hopper[data-hopper-state=drag-over]:after{content:\\\"\\\";position:absolute;left:0;top:0;right:0;bottom:0;z-index:100}.filepond--progress-indicator{z-index:103}.filepond--file-action-button{z-index:102}.filepond--file-status{z-index:101}.filepond--file-info{z-index:100}.filepond--item{position:absolute;top:0;left:0;right:0;z-index:1;padding:0;margin:.25em;will-change:transform,opacity}.filepond--item>.filepond--panel{z-index:-1}.filepond--item>.filepond--panel .filepond--panel-bottom{box-shadow:0 .0625em .125em -.0625em rgba(0,0,0,.25)}.filepond--item>.filepond--file-wrapper,.filepond--item>.filepond--panel{transition:opacity .15s ease-out}.filepond--item[data-drag-state]{cursor:-webkit-grab;cursor:grab}.filepond--item[data-drag-state]>.filepond--panel{transition:box-shadow .125s ease-in-out;box-shadow:0 0 0 transparent}.filepond--item[data-drag-state=drag]{cursor:-webkit-grabbing;cursor:grabbing}.filepond--item[data-drag-state=drag]>.filepond--panel{box-shadow:0 .125em .3125em rgba(0,0,0,.325)}.filepond--item[data-drag-state]:not([data-drag-state=idle]){z-index:2}.filepond--item-panel{background-color:#64605e}[data-filepond-item-state=processing-complete] .filepond--item-panel{background-color:#369763}[data-filepond-item-state*=error] .filepond--item-panel,[data-filepond-item-state*=invalid] .filepond--item-panel{background-color:#c44e47}.filepond--item-panel{border-radius:.5em;transition:background-color .25s}.filepond--list-scroller{position:absolute;top:0;left:0;right:0;margin:0;will-change:transform}.filepond--list-scroller[data-state=overflow]{overflow-y:scroll;overflow-x:hidden;-webkit-overflow-scrolling:touch;-webkit-mask:linear-gradient(180deg,#000 calc(100% - .5em),transparent);mask:linear-gradient(180deg,#000 calc(100% - .5em),transparent)}.filepond--list-scroller[data-state=overflow] .filepond--list{bottom:0;right:0}.filepond--list-scroller::-webkit-scrollbar{background:transparent}.filepond--list-scroller::-webkit-scrollbar:vertical{width:1em}.filepond--list-scroller::-webkit-scrollbar:horizontal{height:0}.filepond--list-scroller::-webkit-scrollbar-thumb{background-color:rgba(0,0,0,.3);border-radius:99999px;border:.3125em solid transparent;background-clip:content-box}.filepond--list.filepond--list{position:absolute;top:0;margin:0;padding:0;list-style-type:none;will-change:transform}.filepond--list{left:.75em;right:.75em}.filepond--root[data-style-panel-layout~=integrated]{width:100%;height:100%;max-width:none;margin:0}.filepond--root[data-style-panel-layout~=circle] .filepond--panel-root,.filepond--root[data-style-panel-layout~=integrated] .filepond--panel-root{border-radius:0}.filepond--root[data-style-panel-layout~=circle] .filepond--panel-root>*,.filepond--root[data-style-panel-layout~=integrated] .filepond--panel-root>*{display:none}.filepond--root[data-style-panel-layout~=circle] .filepond--drop-label,.filepond--root[data-style-panel-layout~=integrated] .filepond--drop-label{bottom:0;height:auto;display:flex;justify-content:center;align-items:center;z-index:7}.filepond--root[data-style-panel-layout~=circle] .filepond--item-panel,.filepond--root[data-style-panel-layout~=integrated] .filepond--item-panel{display:none}.filepond--root[data-style-panel-layout~=compact] .filepond--list-scroller,.filepond--root[data-style-panel-layout~=integrated] .filepond--list-scroller{overflow:hidden;height:100%;margin-top:0;margin-bottom:0}.filepond--root[data-style-panel-layout~=compact] .filepond--list,.filepond--root[data-style-panel-layout~=integrated] .filepond--list{left:0;right:0;height:100%}.filepond--root[data-style-panel-layout~=compact] .filepond--item,.filepond--root[data-style-panel-layout~=integrated] .filepond--item{margin:0}.filepond--root[data-style-panel-layout~=compact] .filepond--file-wrapper,.filepond--root[data-style-panel-layout~=integrated] .filepond--file-wrapper{height:100%}.filepond--root[data-style-panel-layout~=compact] .filepond--drop-label,.filepond--root[data-style-panel-layout~=integrated] .filepond--drop-label{z-index:7}.filepond--root[data-style-panel-layout~=circle]{border-radius:99999rem;overflow:hidden}.filepond--root[data-style-panel-layout~=circle]>.filepond--panel{border-radius:inherit}.filepond--root[data-style-panel-layout~=circle] .filepond--file-info,.filepond--root[data-style-panel-layout~=circle] .filepond--file-status,.filepond--root[data-style-panel-layout~=circle]>.filepond--panel>*{display:none}.filepond--root[data-style-panel-layout~=circle] .filepond--action-edit-item{opacity:1!important;visibility:visible!important}@media not all and (min-resolution:0.001dpcm){@supports (-webkit-appearance:none) and (stroke-color:transparent){.filepond--root[data-style-panel-layout~=circle]{will-change:transform}}}.filepond--panel-root{border-radius:.5em;background-color:#f1f0ef}.filepond--panel{position:absolute;left:0;top:0;right:0;margin:0;height:100%!important;pointer-events:none}.filepond-panel:not([data-scalable=false]){height:auto!important}.filepond--panel[data-scalable=false]>div{display:none}.filepond--panel[data-scalable=true]{-webkit-transform-style:preserve-3d;transform-style:preserve-3d;background-color:transparent!important;border:none!important}.filepond--panel-bottom,.filepond--panel-center,.filepond--panel-top{position:absolute;left:0;top:0;right:0;margin:0;padding:0}.filepond--panel-bottom,.filepond--panel-top{height:.5em}.filepond--panel-top{border-bottom-left-radius:0!important;border-bottom-right-radius:0!important;border-bottom:none!important}.filepond--panel-top:after{content:\\\"\\\";position:absolute;height:2px;left:0;right:0;bottom:-1px;background-color:inherit}.filepond--panel-bottom,.filepond--panel-center{will-change:transform;-webkit-backface-visibility:hidden;backface-visibility:hidden;-webkit-transform-origin:left top;transform-origin:left top;-webkit-transform:translate3d(0,.5em,0);transform:translate3d(0,.5em,0)}.filepond--panel-bottom{border-top-left-radius:0!important;border-top-right-radius:0!important;border-top:none!important}.filepond--panel-bottom:before{content:\\\"\\\";position:absolute;height:2px;left:0;right:0;top:-1px;background-color:inherit}.filepond--panel-center{height:100px!important;border-top:none!important;border-bottom:none!important;border-radius:0!important}.filepond--panel-center:not([style]){visibility:hidden}.filepond--progress-indicator{position:static;width:1.25em;height:1.25em;color:#fff;margin:0;pointer-events:none;will-change:transform,opacity}.filepond--progress-indicator svg{width:100%;height:100%;vertical-align:top;transform-box:fill-box}.filepond--progress-indicator path{fill:none;stroke:currentColor}.filepond--list-scroller{z-index:6}.filepond--drop-label{z-index:5}.filepond--drip{z-index:3}.filepond--root>.filepond--panel{z-index:2}.filepond--browser{z-index:1}.filepond--root{box-sizing:border-box;position:relative;margin-bottom:1em;font-size:1rem;line-height:normal;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol;font-weight:450;text-align:left;text-rendering:optimizeLegibility;direction:ltr;contain:layout style size}.filepond--root *{box-sizing:inherit;line-height:inherit}.filepond--root :not(text){font-size:inherit}.filepond--root[data-disabled]{pointer-events:none}.filepond--root[data-disabled] .filepond--list-scroller{pointer-events:all}.filepond--root[data-disabled] .filepond--list{pointer-events:none}.filepond--root .filepond--drop-label{min-height:4.75em}.filepond--root .filepond--list-scroller{margin-top:1em;margin-bottom:1em}.filepond--root .filepond--credits{position:absolute;right:0;opacity:.175;line-height:.85;font-size:11px;color:inherit;text-decoration:none;z-index:3;bottom:-14px}.filepond--root .filepond--credits[style]{top:0;bottom:auto;margin-top:14px}\", \"\"]);\n\n// exports\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmlsZXBvbmQvZGlzdC9maWxlcG9uZC5taW4uY3NzPzEyOTciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsMkJBQTJCLG1CQUFPLENBQUMsbUZBQWtDO0FBQ3JFOzs7QUFHQTtBQUNBLGNBQWMsUUFBUyxvTUFBb00sa0JBQWtCLGdCQUFnQixXQUFXLFVBQVUsVUFBVSxTQUFTLDJCQUEyQiw2QkFBNkIscUJBQXFCLG1CQUFtQixxQ0FBcUMsa0JBQWtCLFNBQVMsVUFBVSxTQUFTLFdBQVcsdUJBQXVCLFVBQVUsWUFBWSxnQkFBZ0Isa0JBQWtCLFFBQVEsU0FBUyxVQUFVLFNBQVMsWUFBWSxrQkFBa0Isb0JBQW9CLGVBQWUsZ0JBQWdCLGtCQUFrQixNQUFNLE9BQU8sUUFBUSxTQUFTLGdCQUFnQixXQUFXLG9CQUFvQixtQkFBbUIsMkJBQTJCLHFCQUFxQix1Q0FBdUMsK0JBQStCLFVBQVUsV0FBVyxpQkFBaUIsZ0JBQWdCLG1CQUFtQixrQkFBa0IsMkNBQTJDLGtCQUFrQixNQUFNLE9BQU8sOEJBQThCLHNCQUFzQixRQUFRLFNBQVMsY0FBYyxhQUFhLHVCQUF1QixtQkFBbUIsU0FBUyx5QkFBeUIsc0JBQXNCLHFCQUFxQixpQkFBaUIsaURBQWlELGNBQWMsU0FBUyxhQUFhLDRCQUE0QixlQUFlLGlCQUFpQixnQkFBZ0Isa0JBQWtCLGdCQUFnQix3QkFBd0IsMEJBQTBCLGlDQUFpQyw4QkFBOEIsc0NBQXNDLDhCQUE4QixlQUFlLDJEQUEyRCxXQUFXLDJEQUEyRCxjQUFjLGNBQWMsZUFBZSxvQkFBb0Isb0JBQW9CLFNBQVMsVUFBVSxZQUFZLGFBQWEsOEJBQThCLGdFQUFnRSxrQkFBa0IsZ0JBQWdCLFdBQVcsVUFBVSxVQUFVLFNBQVMsMkJBQTJCLDZCQUE2QixxQkFBcUIsbUJBQW1CLCtEQUErRCxXQUFXLFlBQVksaUVBQWlFLGtCQUFrQixZQUFZLGFBQWEsV0FBVyxjQUFjLGFBQWEsOEJBQThCLFlBQVks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VyxPQUFPLFFBQVEsWUFBWSx5QkFBeUIsZ0RBQWdELHNCQUFzQixtQ0FBbUMsMkJBQTJCLGtDQUFrQywwQkFBMEIsd0NBQXdDLGdDQUFnQyx3QkFBd0IsbUNBQW1DLG9DQUFvQywwQkFBMEIsK0JBQStCLGFBQWEsa0JBQWtCLFdBQVcsT0FBTyxRQUFRLFNBQVMseUJBQXlCLHdCQUF3Qix1QkFBdUIsMEJBQTBCLDZCQUE2QiwwQkFBMEIscUNBQXFDLGtCQUFrQiw4QkFBOEIsZ0JBQWdCLGFBQWEsY0FBYyxXQUFXLFNBQVMsb0JBQW9CLDhCQUE4QixrQ0FBa0MsV0FBVyxZQUFZLG1CQUFtQix1QkFBdUIsbUNBQW1DLFVBQVUsb0JBQW9CLHlCQUF5QixVQUFVLHNCQUFzQixVQUFVLGdCQUFnQixVQUFVLGlDQUFpQyxVQUFVLG1CQUFtQixVQUFVLGdCQUFnQixzQkFBc0Isa0JBQWtCLGtCQUFrQixlQUFlLG1CQUFtQix5SUFBeUksZ0JBQWdCLGdCQUFnQixrQ0FBa0MsY0FBYywwQkFBMEIsa0JBQWtCLG1CQUFtQixvQkFBb0IsMkJBQTJCLGtCQUFrQiwrQkFBK0Isb0JBQW9CLHdEQUF3RCxtQkFBbUIsK0NBQStDLG9CQUFvQixzQ0FBc0Msa0JBQWtCLHlDQUF5QyxlQUFlLGtCQUFrQixtQ0FBbUMsa0JBQWtCLFFBQVEsYUFBYSxnQkFBZ0IsZUFBZSxjQUFjLHFCQUFxQixVQUFVLGFBQWEsMENBQTBDLE1BQU0sWUFBWSxnQkFBZ0I7O0FBRW5raUIiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz8hLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPyEuL25vZGVfbW9kdWxlcy9maWxlcG9uZC9kaXN0L2ZpbGVwb25kLm1pbi5jc3MuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoZmFsc2UpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLyohXFxuICogRmlsZVBvbmQgNC4yNS4xXFxuICogTGljZW5zZWQgdW5kZXIgTUlULCBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC9cXG4gKiBQbGVhc2UgdmlzaXQgaHR0cHM6Ly9wcWluYS5ubC9maWxlcG9uZC8gZm9yIGRldGFpbHMuXFxuICovXFxuXFxuLyogZXNsaW50LWRpc2FibGUgKi9cXG4uZmlsZXBvbmQtLWFzc2lzdGFudHtwb3NpdGlvbjphYnNvbHV0ZTtvdmVyZmxvdzpoaWRkZW47aGVpZ2h0OjFweDt3aWR0aDoxcHg7cGFkZGluZzowO2JvcmRlcjowO2NsaXA6cmVjdCgxcHgsMXB4LDFweCwxcHgpOy13ZWJraXQtY2xpcC1wYXRoOmluc2V0KDUwJSk7Y2xpcC1wYXRoOmluc2V0KDUwJSk7d2hpdGUtc3BhY2U6bm93cmFwfS5maWxlcG9uZC0tYnJvd3Nlci5maWxlcG9uZC0tYnJvd3Nlcntwb3NpdGlvbjphYnNvbHV0ZTttYXJnaW46MDtwYWRkaW5nOjA7bGVmdDoxZW07dG9wOjEuNzVlbTt3aWR0aDpjYWxjKDEwMCUgLSAyZW0pO29wYWNpdHk6MDtmb250LXNpemU6MH0uZmlsZXBvbmQtLWRhdGF7cG9zaXRpb246YWJzb2x1dGU7d2lkdGg6MDtoZWlnaHQ6MDtwYWRkaW5nOjA7bWFyZ2luOjA7Ym9yZGVyOm5vbmU7dmlzaWJpbGl0eTpoaWRkZW47cG9pbnRlci1ldmVudHM6bm9uZTtjb250YWluOnN0cmljdH0uZmlsZXBvbmQtLWRyaXB7cG9zaXRpb246YWJzb2x1dGU7dG9wOjA7bGVmdDowO3JpZ2h0OjA7Ym90dG9tOjA7b3ZlcmZsb3c6aGlkZGVuO29wYWNpdHk6LjE7cG9pbnRlci1ldmVudHM6bm9uZTtib3JkZXItcmFkaXVzOi41ZW07YmFja2dyb3VuZDpyZ2JhKDAsMCwwLC4wMSl9LmZpbGVwb25kLS1kcmlwLWJsb2J7LXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luOmNlbnRlciBjZW50ZXI7dHJhbnNmb3JtLW9yaWdpbjpjZW50ZXIgY2VudGVyO3dpZHRoOjhlbTtoZWlnaHQ6OGVtO21hcmdpbi1sZWZ0Oi00ZW07bWFyZ2luLXRvcDotNGVtO2JhY2tncm91bmQ6IzI5MjYyNTtib3JkZXItcmFkaXVzOjUwJX0uZmlsZXBvbmQtLWRyaXAtYmxvYiwuZmlsZXBvbmQtLWRyb3AtbGFiZWx7cG9zaXRpb246YWJzb2x1dGU7dG9wOjA7bGVmdDowO3dpbGwtY2hhbmdlOnRyYW5zZm9ybSxvcGFjaXR5fS5maWxlcG9uZC0tZHJvcC1sYWJlbHtyaWdodDowO21hcmdpbjowO2NvbG9yOiM0ZjRmNGY7ZGlzcGxheTpmbGV4O2p1c3RpZnktY29udGVudDpjZW50ZXI7YWxpZ24taXRlbXM6Y2VudGVyO2hlaWdodDowOy13ZWJraXQtdXNlci1zZWxlY3Q6bm9uZTstbW96LXVzZXItc2VsZWN0Om5vbmU7LW1zLXVzZXItc2VsZWN0Om5vbmU7dXNlci1zZWxlY3Q6bm9uZX0uZmlsZXBvbmQtLWRyb3AtbGFiZWwuZmlsZXBvbmQtLWRyb3AtbGFiZWwgbGFiZWx7ZGlzcGxheTpibG9jazttYXJnaW46MDtwYWRkaW5nOi41ZW19LmZpbGVwb25kLS1kcm9wLWxhYmVsIGxhYmVse2N1cnNvcjpkZWZhdWx0O2ZvbnQtc2l6ZTouODc1ZW07Zm9udC13ZWlnaHQ6NDAwO3RleHQtYWxpZ246Y2VudGVyO2xpbmUtaGVpZ2h0OjEuNX0uZmlsZXBvbmQtLWxhYmVsLWFjdGlvbnt0ZXh0LWRlY29yYXRpb246dW5kZXJsaW5lOy13ZWJraXQtdGV4dC1kZWNvcmF0aW9uLXNraXA6aW5rO3RleHQtZGVjb3JhdGlvbi1za2lwLWluazphdXRvOy13ZWJraXQtdGV4dC1kZWNvcmF0aW9uLWNvbG9yOiNhN2E0YTQ7dGV4dC1kZWNvcmF0aW9uLWNvbG9yOiNhN2E0YTQ7Y3Vyc29yOnBvaW50ZXJ9LmZpbGVwb25kLS1yb290W2RhdGEtZGlzYWJsZWRdIC5maWxlcG9uZC0tZHJvcC1sYWJlbCBsYWJlbHtvcGFjaXR5Oi41fS5maWxlcG9uZC0tZmlsZS1hY3Rpb24tYnV0dG9uLmZpbGVwb25kLS1maWxlLWFjdGlvbi1idXR0b257Zm9udC1zaXplOjFlbTt3aWR0aDoxLjYyNWVtO2hlaWdodDoxLjYyNWVtO2ZvbnQtZmFtaWx5OmluaGVyaXQ7bGluZS1oZWlnaHQ6aW5oZXJpdDttYXJnaW46MDtwYWRkaW5nOjA7Ym9yZGVyOm5vbmU7b3V0bGluZTpub25lO3dpbGwtY2hhbmdlOnRyYW5zZm9ybSxvcGFjaXR5fS5maWxlcG9uZC0tZmlsZS1hY3Rpb24tYnV0dG9uLmZpbGVwb25kLS1maWxlLWFjdGlvbi1idXR0b24gc3Bhbntwb3NpdGlvbjphYnNvbHV0ZTtvdmVyZmxvdzpoaWRkZW47aGVpZ2h0OjFweDt3aWR0aDoxcHg7cGFkZGluZzowO2JvcmRlcjowO2NsaXA6cmVjdCgxcHgsMXB4LDFweCwxcHgpOy13ZWJraXQtY2xpcC1wYXRoOmluc2V0KDUwJSk7Y2xpcC1wYXRoOmluc2V0KDUwJSk7d2hpdGUtc3BhY2U6bm93cmFwfS5maWxlcG9uZC0tZmlsZS1hY3Rpb24tYnV0dG9uLmZpbGVwb25kLS1maWxlLWFjdGlvbi1idXR0b24gc3Zne3dpZHRoOjEwMCU7aGVpZ2h0OjEwMCV9LmZpbGVwb25kLS1maWxlLWFjdGlvbi1idXR0b24uZmlsZXBvbmQtLWZpbGUtYWN0aW9uLWJ1dHRvbjphZnRlcntwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0Oi0uNzVlbTtyaWdodDotLjc1ZW07dG9wOi0uNzVlbTtib3R0b206LS43NWVtO2NvbnRlbnQ6XFxcIlxcXCJ9LmZpbGVwb25kLS1maWxlLWFjdGlvbi1idXR0b257Y3Vyc29yOmF1dG87Y29sb3I6I2ZmZjtib3JkZXItcmFkaXVzOjUwJTtiYWNrZ3JvdW5kLWNvbG9yOnJnYmEoMCwwLDAsLjUpO2JhY2tncm91bmQtaW1hZ2U6bm9uZTtib3gtc2hhZG93OjAgMCAwIDAgaHNsYSgwLDAlLDEwMCUsMCk7dHJhbnNpdGlvbjpib3gtc2hhZG93IC4yNXMgZWFzZS1pbn0uZmlsZXBvbmQtLWZpbGUtYWN0aW9uLWJ1dHRvbjpmb2N1cywuZmlsZXBvbmQtLWZpbGUtYWN0aW9uLWJ1dHRvbjpob3Zlcntib3gtc2hhZG93OjAgMCAwIC4xMjVlbSBoc2xhKDAsMCUsMTAwJSwuOSl9LmZpbGVwb25kLS1maWxlLWFjdGlvbi1idXR0b25bZGlzYWJsZWRde2NvbG9yOmhzbGEoMCwwJSwxMDAlLC41KTtiYWNrZ3JvdW5kLWNvbG9yOnJnYmEoMCwwLDAsLjI1KX0uZmlsZXBvbmQtLWZpbGUtYWN0aW9uLWJ1dHRvbltoaWRkZW5de2Rpc3BsYXk6bm9uZX0uZmlsZXBvbmQtLWFjdGlvbi1lZGl0LWl0ZW0uZmlsZXBvbmQtLWFjdGlvbi1lZGl0LWl0ZW17d2lkdGg6MmVtO2hlaWdodDoyZW07cGFkZGluZzouMTg3NWVtfS5maWxlcG9uZC0tYWN0aW9uLWVkaXQtaXRlbS5maWxlcG9uZC0tYWN0aW9uLWVkaXQtaXRlbVtkYXRhLWFsaWduKj1jZW50ZXJde21hcmdpbi1sZWZ0Oi0uMTg3NWVtfS5maWxlcG9uZC0tYWN0aW9uLWVkaXQtaXRlbS5maWxlcG9uZC0tYWN0aW9uLWVkaXQtaXRlbVtkYXRhLWFsaWduKj1ib3R0b21de21hcmdpbi1ib3R0b206LS4xODc1ZW19LmZpbGVwb25kLS1hY3Rpb24tZWRpdC1pdGVtLWFsdHtib3JkZXI6bm9uZTtsaW5lLWhlaWdodDppbmhlcml0O2JhY2tncm91bmQ6dHJhbnNwYXJlbnQ7Zm9udC1mYW1pbHk6aW5oZXJpdDtjb2xvcjppbmhlcml0O291dGxpbmU6bm9uZTtwYWRkaW5nOjA7bWFyZ2luOjAgMCAwIC4yNWVtO3BvaW50ZXItZXZlbnRzOmFsbDtwb3NpdGlvbjphYnNvbHV0ZX0uZmlsZXBvbmQtLWFjdGlvbi1lZGl0LWl0ZW0tYWx0IHN2Z3t3aWR0aDoxLjMxMjVlbTtoZWlnaHQ6MS4zMTI1ZW19LmZpbGVwb25kLS1hY3Rpb24tZWRpdC1pdGVtLWFsdCBzcGFue2ZvbnQtc2l6ZTowO29wYWNpdHk6MH0uZmlsZXBvbmQtLWZpbGUtaW5mb3twb3NpdGlvbjpzdGF0aWM7ZGlzcGxheTpmbGV4O2ZsZXgtZGlyZWN0aW9uOmNvbHVtbjthbGlnbi1pdGVtczpmbGV4LXN0YXJ0O2ZsZXg6MTttYXJnaW46MCAuNWVtIDAgMDttaW4td2lkdGg6MDt3aWxsLWNoYW5nZTp0cmFuc2Zvcm0sb3BhY2l0eTtwb2ludGVyLWV2ZW50czpub25lOy13ZWJraXQtdXNlci1zZWxlY3Q6bm9uZTstbW96LXVzZXItc2VsZWN0Om5vbmU7LW1zLXVzZXItc2VsZWN0Om5vbmU7dXNlci1zZWxlY3Q6bm9uZX0uZmlsZXBvbmQtLWZpbGUtaW5mbyAqe21hcmdpbjowfS5maWxlcG9uZC0tZmlsZS1pbmZvIC5maWxlcG9uZC0tZmlsZS1pbmZvLW1haW57Zm9udC1zaXplOi43NWVtO2xpbmUtaGVpZ2h0OjEuMjt0ZXh0LW92ZXJmbG93OmVsbGlwc2lzO292ZXJmbG93OmhpZGRlbjt3aGl0ZS1zcGFjZTpub3dyYXA7d2lkdGg6MTAwJX0uZmlsZXBvbmQtLWZpbGUtaW5mbyAuZmlsZXBvbmQtLWZpbGUtaW5mby1zdWJ7Zm9udC1zaXplOi42MjVlbTtvcGFjaXR5Oi41O3RyYW5zaXRpb246b3BhY2l0eSAuMjVzIGVhc2UtaW4tb3V0O3doaXRlLXNwYWNlOm5vd3JhcH0uZmlsZXBvbmQtLWZpbGUtaW5mbyAuZmlsZXBvbmQtLWZpbGUtaW5mby1zdWI6ZW1wdHl7ZGlzcGxheTpub25lfS5maWxlcG9uZC0tZmlsZS1zdGF0dXN7cG9zaXRpb246c3RhdGljO2Rpc3BsYXk6ZmxleDtmbGV4LWRpcmVjdGlvbjpjb2x1bW47YWxpZ24taXRlbXM6ZmxleC1lbmQ7ZmxleC1ncm93OjA7ZmxleC1zaHJpbms6MDttYXJnaW46MDttaW4td2lkdGg6Mi4yNWVtO3RleHQtYWxpZ246cmlnaHQ7d2lsbC1jaGFuZ2U6dHJhbnNmb3JtLG9wYWNpdHk7cG9pbnRlci1ldmVudHM6bm9uZTstd2Via2l0LXVzZXItc2VsZWN0Om5vbmU7LW1vei11c2VyLXNlbGVjdDpub25lOy1tcy11c2VyLXNlbGVjdDpub25lO3VzZXItc2VsZWN0Om5vbmV9LmZpbGVwb25kLS1maWxlLXN0YXR1cyAqe21hcmdpbjowO3doaXRlLXNwYWNlOm5vd3JhcH0uZmlsZXBvbmQtLWZpbGUtc3RhdHVzIC5maWxlcG9uZC0tZmlsZS1zdGF0dXMtbWFpbntmb250LXNpemU6Ljc1ZW07bGluZS1oZWlnaHQ6MS4yfS5maWxlcG9uZC0tZmlsZS1zdGF0dXMgLmZpbGVwb25kLS1maWxlLXN0YXR1cy1zdWJ7Zm9udC1zaXplOi42MjVlbTtvcGFjaXR5Oi41O3RyYW5zaXRpb246b3BhY2l0eSAuMjVzIGVhc2UtaW4tb3V0fS5maWxlcG9uZC0tZmlsZS13cmFwcGVyLmZpbGVwb25kLS1maWxlLXdyYXBwZXJ7Ym9yZGVyOm5vbmU7bWFyZ2luOjA7cGFkZGluZzowO21pbi13aWR0aDowO2hlaWdodDoxMDAlfS5maWxlcG9uZC0tZmlsZS13cmFwcGVyLmZpbGVwb25kLS1maWxlLXdyYXBwZXI+bGVnZW5ke3Bvc2l0aW9uOmFic29sdXRlO292ZXJmbG93OmhpZGRlbjtoZWlnaHQ6MXB4O3dpZHRoOjFweDtwYWRkaW5nOjA7Ym9yZGVyOjA7Y2xpcDpyZWN0KDFweCwxcHgsMXB4LDFweCk7LXdlYmtpdC1jbGlwLXBhdGg6aW5zZXQoNTAlKTtjbGlwLXBhdGg6aW5zZXQoNTAlKTt3aGl0ZS1zcGFjZTpub3dyYXB9LmZpbGVwb25kLS1maWxle3Bvc2l0aW9uOnN0YXRpYztkaXNwbGF5OmZsZXg7aGVpZ2h0OjEwMCU7YWxpZ24taXRlbXM6ZmxleC1zdGFydDtwYWRkaW5nOi41NjI1ZW07Y29sb3I6I2ZmZjtib3JkZXItcmFkaXVzOi41ZW19LmZpbGVwb25kLS1maWxlIC5maWxlcG9uZC0tZmlsZS1zdGF0dXN7bWFyZ2luLWxlZnQ6YXV0bzttYXJnaW4tcmlnaHQ6Mi4yNWVtfS5maWxlcG9uZC0tZmlsZSAuZmlsZXBvbmQtLXByb2Nlc3NpbmctY29tcGxldGUtaW5kaWNhdG9ye3BvaW50ZXItZXZlbnRzOm5vbmU7LXdlYmtpdC11c2VyLXNlbGVjdDpub25lOy1tb3otdXNlci1zZWxlY3Q6bm9uZTstbXMtdXNlci1zZWxlY3Q6bm9uZTt1c2VyLXNlbGVjdDpub25lO3otaW5kZXg6M30uZmlsZXBvbmQtLWZpbGUgLmZpbGVwb25kLS1maWxlLWFjdGlvbi1idXR0b24sLmZpbGVwb25kLS1maWxlIC5maWxlcG9uZC0tcHJvY2Vzc2luZy1jb21wbGV0ZS1pbmRpY2F0b3IsLmZpbGVwb25kLS1maWxlIC5maWxlcG9uZC0tcHJvZ3Jlc3MtaW5kaWNhdG9ye3Bvc2l0aW9uOmFic29sdXRlfS5maWxlcG9uZC0tZmlsZSBbZGF0YS1hbGlnbio9bGVmdF17bGVmdDouNTYyNWVtfS5maWxlcG9uZC0tZmlsZSBbZGF0YS1hbGlnbio9cmlnaHRde3JpZ2h0Oi41NjI1ZW19LmZpbGVwb25kLS1maWxlIFtkYXRhLWFsaWduKj1jZW50ZXJde2xlZnQ6Y2FsYyg1MCUgLSAuODEyNWVtKX0uZmlsZXBvbmQtLWZpbGUgW2RhdGEtYWxpZ24qPWJvdHRvbV17Ym90dG9tOjEuMTI1ZW19LmZpbGVwb25kLS1maWxlIFtkYXRhLWFsaWduPWNlbnRlcl17dG9wOmNhbGMoNTAlIC0gLjgxMjVlbSl9LmZpbGVwb25kLS1maWxlIC5maWxlcG9uZC0tcHJvZ3Jlc3MtaW5kaWNhdG9ye21hcmdpbi10b3A6LjE4NzVlbX0uZmlsZXBvbmQtLWZpbGUgLmZpbGVwb25kLS1wcm9ncmVzcy1pbmRpY2F0b3JbZGF0YS1hbGlnbio9cmlnaHRde21hcmdpbi1yaWdodDouMTg3NWVtfS5maWxlcG9uZC0tZmlsZSAuZmlsZXBvbmQtLXByb2dyZXNzLWluZGljYXRvcltkYXRhLWFsaWduKj1sZWZ0XXttYXJnaW4tbGVmdDouMTg3NWVtfVtkYXRhLWZpbGVwb25kLWl0ZW0tc3RhdGUqPWVycm9yXSAuZmlsZXBvbmQtLWZpbGUtaW5mbyxbZGF0YS1maWxlcG9uZC1pdGVtLXN0YXRlKj1pbnZhbGlkXSAuZmlsZXBvbmQtLWZpbGUtaW5mbyxbZGF0YS1maWxlcG9uZC1pdGVtLXN0YXRlPWNhbmNlbGxlZF0gLmZpbGVwb25kLS1maWxlLWluZm97bWFyZ2luLXJpZ2h0OjIuMjVlbX1bZGF0YS1maWxlcG9uZC1pdGVtLXN0YXRlfj1wcm9jZXNzaW5nXSAuZmlsZXBvbmQtLWZpbGUtc3RhdHVzLXN1YntvcGFjaXR5OjB9W2RhdGEtZmlsZXBvbmQtaXRlbS1zdGF0ZX49cHJvY2Vzc2luZ10gLmZpbGVwb25kLS1hY3Rpb24tYWJvcnQtaXRlbS1wcm9jZXNzaW5nfi5maWxlcG9uZC0tZmlsZS1zdGF0dXMgLmZpbGVwb25kLS1maWxlLXN0YXR1cy1zdWJ7b3BhY2l0eTouNX1bZGF0YS1maWxlcG9uZC1pdGVtLXN0YXRlPXByb2Nlc3NpbmctZXJyb3JdIC5maWxlcG9uZC0tZmlsZS1zdGF0dXMtc3Vie29wYWNpdHk6MH1bZGF0YS1maWxlcG9uZC1pdGVtLXN0YXRlPXByb2Nlc3NpbmctZXJyb3JdIC5maWxlcG9uZC0tYWN0aW9uLXJldHJ5LWl0ZW0tcHJvY2Vzc2luZ34uZmlsZXBvbmQtLWZpbGUtc3RhdHVzIC5maWxlcG9uZC0tZmlsZS1zdGF0dXMtc3Vie29wYWNpdHk6LjV9W2RhdGEtZmlsZXBvbmQtaXRlbS1zdGF0ZT1wcm9jZXNzaW5nLWNvbXBsZXRlXSAuZmlsZXBvbmQtLWFjdGlvbi1yZXZlcnQtaXRlbS1wcm9jZXNzaW5nIHN2Z3std2Via2l0LWFuaW1hdGlvbjpmYWxsIC41cyBsaW5lYXIgLjEyNXMgYm90aDthbmltYXRpb246ZmFsbCAuNXMgbGluZWFyIC4xMjVzIGJvdGh9W2RhdGEtZmlsZXBvbmQtaXRlbS1zdGF0ZT1wcm9jZXNzaW5nLWNvbXBsZXRlXSAuZmlsZXBvbmQtLWZpbGUtc3RhdHVzLXN1YntvcGFjaXR5Oi41fVtkYXRhLWZpbGVwb25kLWl0ZW0tc3RhdGU9cHJvY2Vzc2luZy1jb21wbGV0ZV0gLmZpbGVwb25kLS1maWxlLWluZm8tc3ViLFtkYXRhLWZpbGVwb25kLWl0ZW0tc3RhdGU9cHJvY2Vzc2luZy1jb21wbGV0ZV0gLmZpbGVwb25kLS1wcm9jZXNzaW5nLWNvbXBsZXRlLWluZGljYXRvcjpub3QoW3N0eWxlKj1oaWRkZW5dKX4uZmlsZXBvbmQtLWZpbGUtc3RhdHVzIC5maWxlcG9uZC0tZmlsZS1zdGF0dXMtc3Vie29wYWNpdHk6MH1bZGF0YS1maWxlcG9uZC1pdGVtLXN0YXRlPXByb2Nlc3NpbmctY29tcGxldGVdIC5maWxlcG9uZC0tYWN0aW9uLXJldmVydC1pdGVtLXByb2Nlc3Npbmd+LmZpbGVwb25kLS1maWxlLWluZm8gLmZpbGVwb25kLS1maWxlLWluZm8tc3Vie29wYWNpdHk6LjV9W2RhdGEtZmlsZXBvbmQtaXRlbS1zdGF0ZSo9ZXJyb3JdIC5maWxlcG9uZC0tZmlsZS13cmFwcGVyLFtkYXRhLWZpbGVwb25kLWl0ZW0tc3RhdGUqPWVycm9yXSAuZmlsZXBvbmQtLXBhbmVsLFtkYXRhLWZpbGVwb25kLWl0ZW0tc3RhdGUqPWludmFsaWRdIC5maWxlcG9uZC0tZmlsZS13cmFwcGVyLFtkYXRhLWZpbGVwb25kLWl0ZW0tc3RhdGUqPWludmFsaWRdIC5maWxlcG9uZC0tcGFuZWx7LXdlYmtpdC1hbmltYXRpb246c2hha2UgLjY1cyBsaW5lYXIgYm90aDthbmltYXRpb246c2hha2UgLjY1cyBsaW5lYXIgYm90aH1bZGF0YS1maWxlcG9uZC1pdGVtLXN0YXRlKj1idXN5XSAuZmlsZXBvbmQtLXByb2dyZXNzLWluZGljYXRvciBzdmd7LXdlYmtpdC1hbmltYXRpb246c3BpbiAxcyBsaW5lYXIgaW5maW5pdGU7YW5pbWF0aW9uOnNwaW4gMXMgbGluZWFyIGluZmluaXRlfUAtd2Via2l0LWtleWZyYW1lcyBzcGluezAley13ZWJraXQtdHJhbnNmb3JtOnJvdGF0ZSgwZGVnKTt0cmFuc2Zvcm06cm90YXRlKDBkZWcpfXRvey13ZWJraXQtdHJhbnNmb3JtOnJvdGF0ZSgxdHVybik7dHJhbnNmb3JtOnJvdGF0ZSgxdHVybil9fUBrZXlmcmFtZXMgc3BpbnswJXstd2Via2l0LXRyYW5zZm9ybTpyb3RhdGUoMGRlZyk7dHJhbnNmb3JtOnJvdGF0ZSgwZGVnKX10b3std2Via2l0LXRyYW5zZm9ybTpyb3RhdGUoMXR1cm4pO3RyYW5zZm9ybTpyb3RhdGUoMXR1cm4pfX1ALXdlYmtpdC1rZXlmcmFtZXMgc2hha2V7MTAlLDkwJXstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVYKC0uMDYyNWVtKTt0cmFuc2Zvcm06dHJhbnNsYXRlWCgtLjA2MjVlbSl9MjAlLDgwJXstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVYKC4xMjVlbSk7dHJhbnNmb3JtOnRyYW5zbGF0ZVgoLjEyNWVtKX0zMCUsNTAlLDcwJXstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVYKC0uMjVlbSk7dHJhbnNmb3JtOnRyYW5zbGF0ZVgoLS4yNWVtKX00MCUsNjAley13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVgoLjI1ZW0pO3RyYW5zZm9ybTp0cmFuc2xhdGVYKC4yNWVtKX19QGtleWZyYW1lcyBzaGFrZXsxMCUsOTAley13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVgoLS4wNjI1ZW0pO3RyYW5zZm9ybTp0cmFuc2xhdGVYKC0uMDYyNWVtKX0yMCUsODAley13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVgoLjEyNWVtKTt0cmFuc2Zvcm06dHJhbnNsYXRlWCguMTI1ZW0pfTMwJSw1MCUsNzAley13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVgoLS4yNWVtKTt0cmFuc2Zvcm06dHJhbnNsYXRlWCgtLjI1ZW0pfTQwJSw2MCV7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWCguMjVlbSk7dHJhbnNmb3JtOnRyYW5zbGF0ZVgoLjI1ZW0pfX1ALXdlYmtpdC1rZXlmcmFtZXMgZmFsbHswJXtvcGFjaXR5OjA7LXdlYmtpdC10cmFuc2Zvcm06c2NhbGUoLjUpO3RyYW5zZm9ybTpzY2FsZSguNSk7LXdlYmtpdC1hbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOmVhc2Utb3V0O2FuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246ZWFzZS1vdXR9NzAle29wYWNpdHk6MTstd2Via2l0LXRyYW5zZm9ybTpzY2FsZSgxLjEpO3RyYW5zZm9ybTpzY2FsZSgxLjEpOy13ZWJraXQtYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjplYXNlLWluLW91dDthbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOmVhc2UtaW4tb3V0fXRvey13ZWJraXQtdHJhbnNmb3JtOnNjYWxlKDEpO3RyYW5zZm9ybTpzY2FsZSgxKTstd2Via2l0LWFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246ZWFzZS1vdXQ7YW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjplYXNlLW91dH19QGtleWZyYW1lcyBmYWxsezAle29wYWNpdHk6MDstd2Via2l0LXRyYW5zZm9ybTpzY2FsZSguNSk7dHJhbnNmb3JtOnNjYWxlKC41KTstd2Via2l0LWFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246ZWFzZS1vdXQ7YW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjplYXNlLW91dH03MCV7b3BhY2l0eToxOy13ZWJraXQtdHJhbnNmb3JtOnNjYWxlKDEuMSk7dHJhbnNmb3JtOnNjYWxlKDEuMSk7LXdlYmtpdC1hbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOmVhc2UtaW4tb3V0O2FuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246ZWFzZS1pbi1vdXR9dG97LXdlYmtpdC10cmFuc2Zvcm06c2NhbGUoMSk7dHJhbnNmb3JtOnNjYWxlKDEpOy13ZWJraXQtYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjplYXNlLW91dDthbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOmVhc2Utb3V0fX0uZmlsZXBvbmQtLWhvcHBlcltkYXRhLWhvcHBlci1zdGF0ZT1kcmFnLW92ZXJdPip7cG9pbnRlci1ldmVudHM6bm9uZX0uZmlsZXBvbmQtLWhvcHBlcltkYXRhLWhvcHBlci1zdGF0ZT1kcmFnLW92ZXJdOmFmdGVye2NvbnRlbnQ6XFxcIlxcXCI7cG9zaXRpb246YWJzb2x1dGU7bGVmdDowO3RvcDowO3JpZ2h0OjA7Ym90dG9tOjA7ei1pbmRleDoxMDB9LmZpbGVwb25kLS1wcm9ncmVzcy1pbmRpY2F0b3J7ei1pbmRleDoxMDN9LmZpbGVwb25kLS1maWxlLWFjdGlvbi1idXR0b257ei1pbmRleDoxMDJ9LmZpbGVwb25kLS1maWxlLXN0YXR1c3t6LWluZGV4OjEwMX0uZmlsZXBvbmQtLWZpbGUtaW5mb3t6LWluZGV4OjEwMH0uZmlsZXBvbmQtLWl0ZW17cG9zaXRpb246YWJzb2x1dGU7dG9wOjA7bGVmdDowO3JpZ2h0OjA7ei1pbmRleDoxO3BhZGRpbmc6MDttYXJnaW46LjI1ZW07d2lsbC1jaGFuZ2U6dHJhbnNmb3JtLG9wYWNpdHl9LmZpbGVwb25kLS1pdGVtPi5maWxlcG9uZC0tcGFuZWx7ei1pbmRleDotMX0uZmlsZXBvbmQtLWl0ZW0+LmZpbGVwb25kLS1wYW5lbCAuZmlsZXBvbmQtLXBhbmVsLWJvdHRvbXtib3gtc2hhZG93OjAgLjA2MjVlbSAuMTI1ZW0gLS4wNjI1ZW0gcmdiYSgwLDAsMCwuMjUpfS5maWxlcG9uZC0taXRlbT4uZmlsZXBvbmQtLWZpbGUtd3JhcHBlciwuZmlsZXBvbmQtLWl0ZW0+LmZpbGVwb25kLS1wYW5lbHt0cmFuc2l0aW9uOm9wYWNpdHkgLjE1cyBlYXNlLW91dH0uZmlsZXBvbmQtLWl0ZW1bZGF0YS1kcmFnLXN0YXRlXXtjdXJzb3I6LXdlYmtpdC1ncmFiO2N1cnNvcjpncmFifS5maWxlcG9uZC0taXRlbVtkYXRhLWRyYWctc3RhdGVdPi5maWxlcG9uZC0tcGFuZWx7dHJhbnNpdGlvbjpib3gtc2hhZG93IC4xMjVzIGVhc2UtaW4tb3V0O2JveC1zaGFkb3c6MCAwIDAgdHJhbnNwYXJlbnR9LmZpbGVwb25kLS1pdGVtW2RhdGEtZHJhZy1zdGF0ZT1kcmFnXXtjdXJzb3I6LXdlYmtpdC1ncmFiYmluZztjdXJzb3I6Z3JhYmJpbmd9LmZpbGVwb25kLS1pdGVtW2RhdGEtZHJhZy1zdGF0ZT1kcmFnXT4uZmlsZXBvbmQtLXBhbmVse2JveC1zaGFkb3c6MCAuMTI1ZW0gLjMxMjVlbSByZ2JhKDAsMCwwLC4zMjUpfS5maWxlcG9uZC0taXRlbVtkYXRhLWRyYWctc3RhdGVdOm5vdChbZGF0YS1kcmFnLXN0YXRlPWlkbGVdKXt6LWluZGV4OjJ9LmZpbGVwb25kLS1pdGVtLXBhbmVse2JhY2tncm91bmQtY29sb3I6IzY0NjA1ZX1bZGF0YS1maWxlcG9uZC1pdGVtLXN0YXRlPXByb2Nlc3NpbmctY29tcGxldGVdIC5maWxlcG9uZC0taXRlbS1wYW5lbHtiYWNrZ3JvdW5kLWNvbG9yOiMzNjk3NjN9W2RhdGEtZmlsZXBvbmQtaXRlbS1zdGF0ZSo9ZXJyb3JdIC5maWxlcG9uZC0taXRlbS1wYW5lbCxbZGF0YS1maWxlcG9uZC1pdGVtLXN0YXRlKj1pbnZhbGlkXSAuZmlsZXBvbmQtLWl0ZW0tcGFuZWx7YmFja2dyb3VuZC1jb2xvcjojYzQ0ZTQ3fS5maWxlcG9uZC0taXRlbS1wYW5lbHtib3JkZXItcmFkaXVzOi41ZW07dHJhbnNpdGlvbjpiYWNrZ3JvdW5kLWNvbG9yIC4yNXN9LmZpbGVwb25kLS1saXN0LXNjcm9sbGVye3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO2xlZnQ6MDtyaWdodDowO21hcmdpbjowO3dpbGwtY2hhbmdlOnRyYW5zZm9ybX0uZmlsZXBvbmQtLWxpc3Qtc2Nyb2xsZXJbZGF0YS1zdGF0ZT1vdmVyZmxvd117b3ZlcmZsb3cteTpzY3JvbGw7b3ZlcmZsb3cteDpoaWRkZW47LXdlYmtpdC1vdmVyZmxvdy1zY3JvbGxpbmc6dG91Y2g7LXdlYmtpdC1tYXNrOmxpbmVhci1ncmFkaWVudCgxODBkZWcsIzAwMCBjYWxjKDEwMCUgLSAuNWVtKSx0cmFuc3BhcmVudCk7bWFzazpsaW5lYXItZ3JhZGllbnQoMTgwZGVnLCMwMDAgY2FsYygxMDAlIC0gLjVlbSksdHJhbnNwYXJlbnQpfS5maWxlcG9uZC0tbGlzdC1zY3JvbGxlcltkYXRhLXN0YXRlPW92ZXJmbG93XSAuZmlsZXBvbmQtLWxpc3R7Ym90dG9tOjA7cmlnaHQ6MH0uZmlsZXBvbmQtLWxpc3Qtc2Nyb2xsZXI6Oi13ZWJraXQtc2Nyb2xsYmFye2JhY2tncm91bmQ6dHJhbnNwYXJlbnR9LmZpbGVwb25kLS1saXN0LXNjcm9sbGVyOjotd2Via2l0LXNjcm9sbGJhcjp2ZXJ0aWNhbHt3aWR0aDoxZW19LmZpbGVwb25kLS1saXN0LXNjcm9sbGVyOjotd2Via2l0LXNjcm9sbGJhcjpob3Jpem9udGFse2hlaWdodDowfS5maWxlcG9uZC0tbGlzdC1zY3JvbGxlcjo6LXdlYmtpdC1zY3JvbGxiYXItdGh1bWJ7YmFja2dyb3VuZC1jb2xvcjpyZ2JhKDAsMCwwLC4zKTtib3JkZXItcmFkaXVzOjk5OTk5cHg7Ym9yZGVyOi4zMTI1ZW0gc29saWQgdHJhbnNwYXJlbnQ7YmFja2dyb3VuZC1jbGlwOmNvbnRlbnQtYm94fS5maWxlcG9uZC0tbGlzdC5maWxlcG9uZC0tbGlzdHtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDttYXJnaW46MDtwYWRkaW5nOjA7bGlzdC1zdHlsZS10eXBlOm5vbmU7d2lsbC1jaGFuZ2U6dHJhbnNmb3JtfS5maWxlcG9uZC0tbGlzdHtsZWZ0Oi43NWVtO3JpZ2h0Oi43NWVtfS5maWxlcG9uZC0tcm9vdFtkYXRhLXN0eWxlLXBhbmVsLWxheW91dH49aW50ZWdyYXRlZF17d2lkdGg6MTAwJTtoZWlnaHQ6MTAwJTttYXgtd2lkdGg6bm9uZTttYXJnaW46MH0uZmlsZXBvbmQtLXJvb3RbZGF0YS1zdHlsZS1wYW5lbC1sYXlvdXR+PWNpcmNsZV0gLmZpbGVwb25kLS1wYW5lbC1yb290LC5maWxlcG9uZC0tcm9vdFtkYXRhLXN0eWxlLXBhbmVsLWxheW91dH49aW50ZWdyYXRlZF0gLmZpbGVwb25kLS1wYW5lbC1yb290e2JvcmRlci1yYWRpdXM6MH0uZmlsZXBvbmQtLXJvb3RbZGF0YS1zdHlsZS1wYW5lbC1sYXlvdXR+PWNpcmNsZV0gLmZpbGVwb25kLS1wYW5lbC1yb290PiosLmZpbGVwb25kLS1yb290W2RhdGEtc3R5bGUtcGFuZWwtbGF5b3V0fj1pbnRlZ3JhdGVkXSAuZmlsZXBvbmQtLXBhbmVsLXJvb3Q+KntkaXNwbGF5Om5vbmV9LmZpbGVwb25kLS1yb290W2RhdGEtc3R5bGUtcGFuZWwtbGF5b3V0fj1jaXJjbGVdIC5maWxlcG9uZC0tZHJvcC1sYWJlbCwuZmlsZXBvbmQtLXJvb3RbZGF0YS1zdHlsZS1wYW5lbC1sYXlvdXR+PWludGVncmF0ZWRdIC5maWxlcG9uZC0tZHJvcC1sYWJlbHtib3R0b206MDtoZWlnaHQ6YXV0bztkaXNwbGF5OmZsZXg7anVzdGlmeS1jb250ZW50OmNlbnRlcjthbGlnbi1pdGVtczpjZW50ZXI7ei1pbmRleDo3fS5maWxlcG9uZC0tcm9vdFtkYXRhLXN0eWxlLXBhbmVsLWxheW91dH49Y2lyY2xlXSAuZmlsZXBvbmQtLWl0ZW0tcGFuZWwsLmZpbGVwb25kLS1yb290W2RhdGEtc3R5bGUtcGFuZWwtbGF5b3V0fj1pbnRlZ3JhdGVkXSAuZmlsZXBvbmQtLWl0ZW0tcGFuZWx7ZGlzcGxheTpub25lfS5maWxlcG9uZC0tcm9vdFtkYXRhLXN0eWxlLXBhbmVsLWxheW91dH49Y29tcGFjdF0gLmZpbGVwb25kLS1saXN0LXNjcm9sbGVyLC5maWxlcG9uZC0tcm9vdFtkYXRhLXN0eWxlLXBhbmVsLWxheW91dH49aW50ZWdyYXRlZF0gLmZpbGVwb25kLS1saXN0LXNjcm9sbGVye292ZXJmbG93OmhpZGRlbjtoZWlnaHQ6MTAwJTttYXJnaW4tdG9wOjA7bWFyZ2luLWJvdHRvbTowfS5maWxlcG9uZC0tcm9vdFtkYXRhLXN0eWxlLXBhbmVsLWxheW91dH49Y29tcGFjdF0gLmZpbGVwb25kLS1saXN0LC5maWxlcG9uZC0tcm9vdFtkYXRhLXN0eWxlLXBhbmVsLWxheW91dH49aW50ZWdyYXRlZF0gLmZpbGVwb25kLS1saXN0e2xlZnQ6MDtyaWdodDowO2hlaWdodDoxMDAlfS5maWxlcG9uZC0tcm9vdFtkYXRhLXN0eWxlLXBhbmVsLWxheW91dH49Y29tcGFjdF0gLmZpbGVwb25kLS1pdGVtLC5maWxlcG9uZC0tcm9vdFtkYXRhLXN0eWxlLXBhbmVsLWxheW91dH49aW50ZWdyYXRlZF0gLmZpbGVwb25kLS1pdGVte21hcmdpbjowfS5maWxlcG9uZC0tcm9vdFtkYXRhLXN0eWxlLXBhbmVsLWxheW91dH49Y29tcGFjdF0gLmZpbGVwb25kLS1maWxlLXdyYXBwZXIsLmZpbGVwb25kLS1yb290W2RhdGEtc3R5bGUtcGFuZWwtbGF5b3V0fj1pbnRlZ3JhdGVkXSAuZmlsZXBvbmQtLWZpbGUtd3JhcHBlcntoZWlnaHQ6MTAwJX0uZmlsZXBvbmQtLXJvb3RbZGF0YS1zdHlsZS1wYW5lbC1sYXlvdXR+PWNvbXBhY3RdIC5maWxlcG9uZC0tZHJvcC1sYWJlbCwuZmlsZXBvbmQtLXJvb3RbZGF0YS1zdHlsZS1wYW5lbC1sYXlvdXR+PWludGVncmF0ZWRdIC5maWxlcG9uZC0tZHJvcC1sYWJlbHt6LWluZGV4Ojd9LmZpbGVwb25kLS1yb290W2RhdGEtc3R5bGUtcGFuZWwtbGF5b3V0fj1jaXJjbGVde2JvcmRlci1yYWRpdXM6OTk5OTlyZW07b3ZlcmZsb3c6aGlkZGVufS5maWxlcG9uZC0tcm9vdFtkYXRhLXN0eWxlLXBhbmVsLWxheW91dH49Y2lyY2xlXT4uZmlsZXBvbmQtLXBhbmVse2JvcmRlci1yYWRpdXM6aW5oZXJpdH0uZmlsZXBvbmQtLXJvb3RbZGF0YS1zdHlsZS1wYW5lbC1sYXlvdXR+PWNpcmNsZV0gLmZpbGVwb25kLS1maWxlLWluZm8sLmZpbGVwb25kLS1yb290W2RhdGEtc3R5bGUtcGFuZWwtbGF5b3V0fj1jaXJjbGVdIC5maWxlcG9uZC0tZmlsZS1zdGF0dXMsLmZpbGVwb25kLS1yb290W2RhdGEtc3R5bGUtcGFuZWwtbGF5b3V0fj1jaXJjbGVdPi5maWxlcG9uZC0tcGFuZWw+KntkaXNwbGF5Om5vbmV9LmZpbGVwb25kLS1yb290W2RhdGEtc3R5bGUtcGFuZWwtbGF5b3V0fj1jaXJjbGVdIC5maWxlcG9uZC0tYWN0aW9uLWVkaXQtaXRlbXtvcGFjaXR5OjEhaW1wb3J0YW50O3Zpc2liaWxpdHk6dmlzaWJsZSFpbXBvcnRhbnR9QG1lZGlhIG5vdCBhbGwgYW5kIChtaW4tcmVzb2x1dGlvbjowLjAwMWRwY20pe0BzdXBwb3J0cyAoLXdlYmtpdC1hcHBlYXJhbmNlOm5vbmUpIGFuZCAoc3Ryb2tlLWNvbG9yOnRyYW5zcGFyZW50KXsuZmlsZXBvbmQtLXJvb3RbZGF0YS1zdHlsZS1wYW5lbC1sYXlvdXR+PWNpcmNsZV17d2lsbC1jaGFuZ2U6dHJhbnNmb3JtfX19LmZpbGVwb25kLS1wYW5lbC1yb290e2JvcmRlci1yYWRpdXM6LjVlbTtiYWNrZ3JvdW5kLWNvbG9yOiNmMWYwZWZ9LmZpbGVwb25kLS1wYW5lbHtwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0OjA7dG9wOjA7cmlnaHQ6MDttYXJnaW46MDtoZWlnaHQ6MTAwJSFpbXBvcnRhbnQ7cG9pbnRlci1ldmVudHM6bm9uZX0uZmlsZXBvbmQtcGFuZWw6bm90KFtkYXRhLXNjYWxhYmxlPWZhbHNlXSl7aGVpZ2h0OmF1dG8haW1wb3J0YW50fS5maWxlcG9uZC0tcGFuZWxbZGF0YS1zY2FsYWJsZT1mYWxzZV0+ZGl2e2Rpc3BsYXk6bm9uZX0uZmlsZXBvbmQtLXBhbmVsW2RhdGEtc2NhbGFibGU9dHJ1ZV17LXdlYmtpdC10cmFuc2Zvcm0tc3R5bGU6cHJlc2VydmUtM2Q7dHJhbnNmb3JtLXN0eWxlOnByZXNlcnZlLTNkO2JhY2tncm91bmQtY29sb3I6dHJhbnNwYXJlbnQhaW1wb3J0YW50O2JvcmRlcjpub25lIWltcG9ydGFudH0uZmlsZXBvbmQtLXBhbmVsLWJvdHRvbSwuZmlsZXBvbmQtLXBhbmVsLWNlbnRlciwuZmlsZXBvbmQtLXBhbmVsLXRvcHtwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0OjA7dG9wOjA7cmlnaHQ6MDttYXJnaW46MDtwYWRkaW5nOjB9LmZpbGVwb25kLS1wYW5lbC1ib3R0b20sLmZpbGVwb25kLS1wYW5lbC10b3B7aGVpZ2h0Oi41ZW19LmZpbGVwb25kLS1wYW5lbC10b3B7Ym9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czowIWltcG9ydGFudDtib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czowIWltcG9ydGFudDtib3JkZXItYm90dG9tOm5vbmUhaW1wb3J0YW50fS5maWxlcG9uZC0tcGFuZWwtdG9wOmFmdGVye2NvbnRlbnQ6XFxcIlxcXCI7cG9zaXRpb246YWJzb2x1dGU7aGVpZ2h0OjJweDtsZWZ0OjA7cmlnaHQ6MDtib3R0b206LTFweDtiYWNrZ3JvdW5kLWNvbG9yOmluaGVyaXR9LmZpbGVwb25kLS1wYW5lbC1ib3R0b20sLmZpbGVwb25kLS1wYW5lbC1jZW50ZXJ7d2lsbC1jaGFuZ2U6dHJhbnNmb3JtOy13ZWJraXQtYmFja2ZhY2UtdmlzaWJpbGl0eTpoaWRkZW47YmFja2ZhY2UtdmlzaWJpbGl0eTpoaWRkZW47LXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luOmxlZnQgdG9wO3RyYW5zZm9ybS1vcmlnaW46bGVmdCB0b3A7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlM2QoMCwuNWVtLDApO3RyYW5zZm9ybTp0cmFuc2xhdGUzZCgwLC41ZW0sMCl9LmZpbGVwb25kLS1wYW5lbC1ib3R0b217Ym9yZGVyLXRvcC1sZWZ0LXJhZGl1czowIWltcG9ydGFudDtib3JkZXItdG9wLXJpZ2h0LXJhZGl1czowIWltcG9ydGFudDtib3JkZXItdG9wOm5vbmUhaW1wb3J0YW50fS5maWxlcG9uZC0tcGFuZWwtYm90dG9tOmJlZm9yZXtjb250ZW50OlxcXCJcXFwiO3Bvc2l0aW9uOmFic29sdXRlO2hlaWdodDoycHg7bGVmdDowO3JpZ2h0OjA7dG9wOi0xcHg7YmFja2dyb3VuZC1jb2xvcjppbmhlcml0fS5maWxlcG9uZC0tcGFuZWwtY2VudGVye2hlaWdodDoxMDBweCFpbXBvcnRhbnQ7Ym9yZGVyLXRvcDpub25lIWltcG9ydGFudDtib3JkZXItYm90dG9tOm5vbmUhaW1wb3J0YW50O2JvcmRlci1yYWRpdXM6MCFpbXBvcnRhbnR9LmZpbGVwb25kLS1wYW5lbC1jZW50ZXI6bm90KFtzdHlsZV0pe3Zpc2liaWxpdHk6aGlkZGVufS5maWxlcG9uZC0tcHJvZ3Jlc3MtaW5kaWNhdG9ye3Bvc2l0aW9uOnN0YXRpYzt3aWR0aDoxLjI1ZW07aGVpZ2h0OjEuMjVlbTtjb2xvcjojZmZmO21hcmdpbjowO3BvaW50ZXItZXZlbnRzOm5vbmU7d2lsbC1jaGFuZ2U6dHJhbnNmb3JtLG9wYWNpdHl9LmZpbGVwb25kLS1wcm9ncmVzcy1pbmRpY2F0b3Igc3Zne3dpZHRoOjEwMCU7aGVpZ2h0OjEwMCU7dmVydGljYWwtYWxpZ246dG9wO3RyYW5zZm9ybS1ib3g6ZmlsbC1ib3h9LmZpbGVwb25kLS1wcm9ncmVzcy1pbmRpY2F0b3IgcGF0aHtmaWxsOm5vbmU7c3Ryb2tlOmN1cnJlbnRDb2xvcn0uZmlsZXBvbmQtLWxpc3Qtc2Nyb2xsZXJ7ei1pbmRleDo2fS5maWxlcG9uZC0tZHJvcC1sYWJlbHt6LWluZGV4OjV9LmZpbGVwb25kLS1kcmlwe3otaW5kZXg6M30uZmlsZXBvbmQtLXJvb3Q+LmZpbGVwb25kLS1wYW5lbHt6LWluZGV4OjJ9LmZpbGVwb25kLS1icm93c2Vye3otaW5kZXg6MX0uZmlsZXBvbmQtLXJvb3R7Ym94LXNpemluZzpib3JkZXItYm94O3Bvc2l0aW9uOnJlbGF0aXZlO21hcmdpbi1ib3R0b206MWVtO2ZvbnQtc2l6ZToxcmVtO2xpbmUtaGVpZ2h0Om5vcm1hbDtmb250LWZhbWlseTotYXBwbGUtc3lzdGVtLEJsaW5rTWFjU3lzdGVtRm9udCxTZWdvZSBVSSxSb2JvdG8sSGVsdmV0aWNhLEFyaWFsLHNhbnMtc2VyaWYsQXBwbGUgQ29sb3IgRW1vamksU2Vnb2UgVUkgRW1vamksU2Vnb2UgVUkgU3ltYm9sO2ZvbnQtd2VpZ2h0OjQ1MDt0ZXh0LWFsaWduOmxlZnQ7dGV4dC1yZW5kZXJpbmc6b3B0aW1pemVMZWdpYmlsaXR5O2RpcmVjdGlvbjpsdHI7Y29udGFpbjpsYXlvdXQgc3R5bGUgc2l6ZX0uZmlsZXBvbmQtLXJvb3QgKntib3gtc2l6aW5nOmluaGVyaXQ7bGluZS1oZWlnaHQ6aW5oZXJpdH0uZmlsZXBvbmQtLXJvb3QgOm5vdCh0ZXh0KXtmb250LXNpemU6aW5oZXJpdH0uZmlsZXBvbmQtLXJvb3RbZGF0YS1kaXNhYmxlZF17cG9pbnRlci1ldmVudHM6bm9uZX0uZmlsZXBvbmQtLXJvb3RbZGF0YS1kaXNhYmxlZF0gLmZpbGVwb25kLS1saXN0LXNjcm9sbGVye3BvaW50ZXItZXZlbnRzOmFsbH0uZmlsZXBvbmQtLXJvb3RbZGF0YS1kaXNhYmxlZF0gLmZpbGVwb25kLS1saXN0e3BvaW50ZXItZXZlbnRzOm5vbmV9LmZpbGVwb25kLS1yb290IC5maWxlcG9uZC0tZHJvcC1sYWJlbHttaW4taGVpZ2h0OjQuNzVlbX0uZmlsZXBvbmQtLXJvb3QgLmZpbGVwb25kLS1saXN0LXNjcm9sbGVye21hcmdpbi10b3A6MWVtO21hcmdpbi1ib3R0b206MWVtfS5maWxlcG9uZC0tcm9vdCAuZmlsZXBvbmQtLWNyZWRpdHN7cG9zaXRpb246YWJzb2x1dGU7cmlnaHQ6MDtvcGFjaXR5Oi4xNzU7bGluZS1oZWlnaHQ6Ljg1O2ZvbnQtc2l6ZToxMXB4O2NvbG9yOmluaGVyaXQ7dGV4dC1kZWNvcmF0aW9uOm5vbmU7ei1pbmRleDozO2JvdHRvbTotMTRweH0uZmlsZXBvbmQtLXJvb3QgLmZpbGVwb25kLS1jcmVkaXRzW3N0eWxlXXt0b3A6MDtib3R0b206YXV0bzttYXJnaW4tdG9wOjE0cHh9XCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/css-loader/index.js?!./node_modules/postcss-loader/src/index.js?!./node_modules/filepond/dist/filepond.min.css\n");

/***/ }),

/***/ "./node_modules/css-loader/lib/css-base.js":
/*!*************************************************!*\
  !*** ./node_modules/css-loader/lib/css-base.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function(useSourceMap) {\n\tvar list = [];\n\n\t// return the list of modules as css string\n\tlist.toString = function toString() {\n\t\treturn this.map(function (item) {\n\t\t\tvar content = cssWithMappingToString(item, useSourceMap);\n\t\t\tif(item[2]) {\n\t\t\t\treturn \"@media \" + item[2] + \"{\" + content + \"}\";\n\t\t\t} else {\n\t\t\t\treturn content;\n\t\t\t}\n\t\t}).join(\"\");\n\t};\n\n\t// import a list of modules into the list\n\tlist.i = function(modules, mediaQuery) {\n\t\tif(typeof modules === \"string\")\n\t\t\tmodules = [[null, modules, \"\"]];\n\t\tvar alreadyImportedModules = {};\n\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\tvar id = this[i][0];\n\t\t\tif(typeof id === \"number\")\n\t\t\t\talreadyImportedModules[id] = true;\n\t\t}\n\t\tfor(i = 0; i < modules.length; i++) {\n\t\t\tvar item = modules[i];\n\t\t\t// skip already imported module\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\n\t\t\t\tif(mediaQuery && !item[2]) {\n\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t} else if(mediaQuery) {\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\n\t\t\t\t}\n\t\t\t\tlist.push(item);\n\t\t\t}\n\t\t}\n\t};\n\treturn list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n\tvar content = item[1] || '';\n\tvar cssMapping = item[3];\n\tif (!cssMapping) {\n\t\treturn content;\n\t}\n\n\tif (useSourceMap && typeof btoa === 'function') {\n\t\tvar sourceMapping = toComment(cssMapping);\n\t\tvar sourceURLs = cssMapping.sources.map(function (source) {\n\t\t\treturn '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'\n\t\t});\n\n\t\treturn [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n\t}\n\n\treturn [content].join('\\n');\n}\n\n// Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n\t// eslint-disable-next-line no-undef\n\tvar base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n\tvar data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n\n\treturn '/*# ' + data + ' */';\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanM/MjM1MCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGdCQUFnQjtBQUNuRCxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0JBQW9CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxjQUFjOztBQUVsRTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbi8vIGNzcyBiYXNlIGNvZGUsIGluamVjdGVkIGJ5IHRoZSBjc3MtbG9hZGVyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHVzZVNvdXJjZU1hcCkge1xuXHR2YXIgbGlzdCA9IFtdO1xuXG5cdC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcblx0bGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuXHRcdFx0dmFyIGNvbnRlbnQgPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCk7XG5cdFx0XHRpZihpdGVtWzJdKSB7XG5cdFx0XHRcdHJldHVybiBcIkBtZWRpYSBcIiArIGl0ZW1bMl0gKyBcIntcIiArIGNvbnRlbnQgKyBcIn1cIjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiBjb250ZW50O1xuXHRcdFx0fVxuXHRcdH0pLmpvaW4oXCJcIik7XG5cdH07XG5cblx0Ly8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3Rcblx0bGlzdC5pID0gZnVuY3Rpb24obW9kdWxlcywgbWVkaWFRdWVyeSkge1xuXHRcdGlmKHR5cGVvZiBtb2R1bGVzID09PSBcInN0cmluZ1wiKVxuXHRcdFx0bW9kdWxlcyA9IFtbbnVsbCwgbW9kdWxlcywgXCJcIl1dO1xuXHRcdHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpZCA9IHRoaXNbaV1bMF07XG5cdFx0XHRpZih0eXBlb2YgaWQgPT09IFwibnVtYmVyXCIpXG5cdFx0XHRcdGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcblx0XHR9XG5cdFx0Zm9yKGkgPSAwOyBpIDwgbW9kdWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSBtb2R1bGVzW2ldO1xuXHRcdFx0Ly8gc2tpcCBhbHJlYWR5IGltcG9ydGVkIG1vZHVsZVxuXHRcdFx0Ly8gdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBub3QgMTAwJSBwZXJmZWN0IGZvciB3ZWlyZCBtZWRpYSBxdWVyeSBjb21iaW5hdGlvbnNcblx0XHRcdC8vICB3aGVuIGEgbW9kdWxlIGlzIGltcG9ydGVkIG11bHRpcGxlIHRpbWVzIHdpdGggZGlmZmVyZW50IG1lZGlhIHF1ZXJpZXMuXG5cdFx0XHQvLyAgSSBob3BlIHRoaXMgd2lsbCBuZXZlciBvY2N1ciAoSGV5IHRoaXMgd2F5IHdlIGhhdmUgc21hbGxlciBidW5kbGVzKVxuXHRcdFx0aWYodHlwZW9mIGl0ZW1bMF0gIT09IFwibnVtYmVyXCIgfHwgIWFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcblx0XHRcdFx0aWYobWVkaWFRdWVyeSAmJiAhaXRlbVsyXSkge1xuXHRcdFx0XHRcdGl0ZW1bMl0gPSBtZWRpYVF1ZXJ5O1xuXHRcdFx0XHR9IGVsc2UgaWYobWVkaWFRdWVyeSkge1xuXHRcdFx0XHRcdGl0ZW1bMl0gPSBcIihcIiArIGl0ZW1bMl0gKyBcIikgYW5kIChcIiArIG1lZGlhUXVlcnkgKyBcIilcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRsaXN0LnB1c2goaXRlbSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHRyZXR1cm4gbGlzdDtcbn07XG5cbmZ1bmN0aW9uIGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKSB7XG5cdHZhciBjb250ZW50ID0gaXRlbVsxXSB8fCAnJztcblx0dmFyIGNzc01hcHBpbmcgPSBpdGVtWzNdO1xuXHRpZiAoIWNzc01hcHBpbmcpIHtcblx0XHRyZXR1cm4gY29udGVudDtcblx0fVxuXG5cdGlmICh1c2VTb3VyY2VNYXAgJiYgdHlwZW9mIGJ0b2EgPT09ICdmdW5jdGlvbicpIHtcblx0XHR2YXIgc291cmNlTWFwcGluZyA9IHRvQ29tbWVudChjc3NNYXBwaW5nKTtcblx0XHR2YXIgc291cmNlVVJMcyA9IGNzc01hcHBpbmcuc291cmNlcy5tYXAoZnVuY3Rpb24gKHNvdXJjZSkge1xuXHRcdFx0cmV0dXJuICcvKiMgc291cmNlVVJMPScgKyBjc3NNYXBwaW5nLnNvdXJjZVJvb3QgKyBzb3VyY2UgKyAnICovJ1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIFtjb250ZW50XS5jb25jYXQoc291cmNlVVJMcykuY29uY2F0KFtzb3VyY2VNYXBwaW5nXSkuam9pbignXFxuJyk7XG5cdH1cblxuXHRyZXR1cm4gW2NvbnRlbnRdLmpvaW4oJ1xcbicpO1xufVxuXG4vLyBBZGFwdGVkIGZyb20gY29udmVydC1zb3VyY2UtbWFwIChNSVQpXG5mdW5jdGlvbiB0b0NvbW1lbnQoc291cmNlTWFwKSB7XG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuXHR2YXIgYmFzZTY0ID0gYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKTtcblx0dmFyIGRhdGEgPSAnc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsJyArIGJhc2U2NDtcblxuXHRyZXR1cm4gJy8qIyAnICsgZGF0YSArICcgKi8nO1xufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/css-loader/lib/css-base.js\n");

/***/ }),

/***/ "./node_modules/filepond-plugin-file-validate-size/dist/filepond-plugin-file-validate-size.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/filepond-plugin-file-validate-size/dist/filepond-plugin-file-validate-size.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\n * FilePondPluginFileValidateSize 2.2.1\n * Licensed under MIT, https://opensource.org/licenses/MIT/\n * Please visit https://pqina.nl/filepond/ for details.\n */\n\n/* eslint-disable */\n\n(function(global, factory) {\n   true\n    ? (module.exports = factory())\n    : undefined;\n})(this, function() {\n  'use strict';\n\n  var plugin = function plugin(_ref) {\n    var addFilter = _ref.addFilter,\n      utils = _ref.utils;\n    // get quick reference to Type utils\n    var Type = utils.Type,\n      replaceInString = utils.replaceInString,\n      toNaturalFileSize = utils.toNaturalFileSize;\n\n    // filtering if an item is allowed in hopper\n    addFilter('ALLOW_HOPPER_ITEM', function(file, _ref2) {\n      var query = _ref2.query;\n      if (!query('GET_ALLOW_FILE_SIZE_VALIDATION')) {\n        return true;\n      }\n\n      var sizeMax = query('GET_MAX_FILE_SIZE');\n      if (sizeMax !== null && file.size >= sizeMax) {\n        return false;\n      }\n\n      var sizeMin = query('GET_MIN_FILE_SIZE');\n      if (sizeMin !== null && file.size <= sizeMin) {\n        return false;\n      }\n\n      return true;\n    });\n\n    // called for each file that is loaded\n    // right before it is set to the item state\n    // should return a promise\n    addFilter('LOAD_FILE', function(file, _ref3) {\n      var query = _ref3.query;\n      return new Promise(function(resolve, reject) {\n        // if not allowed, all fine, exit\n        if (!query('GET_ALLOW_FILE_SIZE_VALIDATION')) {\n          return resolve(file);\n        }\n\n        // check if file should be filtered\n        var fileFilter = query('GET_FILE_VALIDATE_SIZE_FILTER');\n        if (fileFilter && !fileFilter(file)) {\n          return resolve(file);\n        }\n\n        // reject or resolve based on file size\n        var sizeMax = query('GET_MAX_FILE_SIZE');\n        if (sizeMax !== null && file.size >= sizeMax) {\n          reject({\n            status: {\n              main: query('GET_LABEL_MAX_FILE_SIZE_EXCEEDED'),\n              sub: replaceInString(query('GET_LABEL_MAX_FILE_SIZE'), {\n                filesize: toNaturalFileSize(sizeMax)\n              })\n            }\n          });\n\n          return;\n        }\n\n        // reject or resolve based on file size\n        var sizeMin = query('GET_MIN_FILE_SIZE');\n        if (sizeMin !== null && file.size <= sizeMin) {\n          reject({\n            status: {\n              main: query('GET_LABEL_MIN_FILE_SIZE_EXCEEDED'),\n              sub: replaceInString(query('GET_LABEL_MIN_FILE_SIZE'), {\n                filesize: toNaturalFileSize(sizeMin)\n              })\n            }\n          });\n\n          return;\n        }\n\n        // returns the current option value\n        var totalSizeMax = query('GET_MAX_TOTAL_FILE_SIZE');\n        if (totalSizeMax !== null) {\n          // get the current total file size\n          var currentTotalSize = query('GET_ACTIVE_ITEMS').reduce(function(\n            total,\n            item\n          ) {\n            return total + item.fileSize;\n          },\n          0);\n\n          // get the size of the new file\n          if (currentTotalSize > totalSizeMax) {\n            reject({\n              status: {\n                main: query('GET_LABEL_MAX_TOTAL_FILE_SIZE_EXCEEDED'),\n\n                sub: replaceInString(query('GET_LABEL_MAX_TOTAL_FILE_SIZE'), {\n                  filesize: toNaturalFileSize(totalSizeMax)\n                })\n              }\n            });\n\n            return;\n          }\n        }\n\n        // file is fine, let's pass it back\n        resolve(file);\n      });\n    });\n\n    return {\n      options: {\n        // Enable or disable file type validation\n        allowFileSizeValidation: [true, Type.BOOLEAN],\n\n        // Max individual file size in bytes\n        maxFileSize: [null, Type.INT],\n\n        // Min individual file size in bytes\n        minFileSize: [null, Type.INT],\n\n        // Max total file size in bytes\n        maxTotalFileSize: [null, Type.INT],\n\n        // Filter the files that need to be validated for size\n        fileValidateSizeFilter: [null, Type.FUNCTION],\n\n        // error labels\n        labelMinFileSizeExceeded: ['File is too small', Type.STRING],\n        labelMinFileSize: ['Minimum file size is {filesize}', Type.STRING],\n\n        labelMaxFileSizeExceeded: ['File is too large', Type.STRING],\n        labelMaxFileSize: ['Maximum file size is {filesize}', Type.STRING],\n\n        labelMaxTotalFileSizeExceeded: [\n          'Maximum total size exceeded',\n          Type.STRING\n        ],\n\n        labelMaxTotalFileSize: [\n          'Maximum total file size is {filesize}',\n          Type.STRING\n        ]\n      }\n    };\n  };\n\n  // fire pluginloaded event if running in browser, this allows registering the plugin when using async script tags\n  var isBrowser =\n    typeof window !== 'undefined' && typeof window.document !== 'undefined';\n  if (isBrowser) {\n    document.dispatchEvent(\n      new CustomEvent('FilePond:pluginloaded', { detail: plugin })\n    );\n  }\n\n  return plugin;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmlsZXBvbmQtcGx1Z2luLWZpbGUtdmFsaWRhdGUtc2l6ZS9kaXN0L2ZpbGVwb25kLXBsdWdpbi1maWxlLXZhbGlkYXRlLXNpemUuanM/M2I5NiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsRUFBRSxLQUE0RDtBQUM5RDtBQUNBLE1BQU0sU0FHb0Q7QUFDMUQsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsV0FBVzs7QUFFWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxXQUFXOztBQUVYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrREFBa0QsU0FBUzs7QUFFM0Q7QUFDQSxrREFBa0QsU0FBUzs7QUFFM0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1Q0FBdUMsU0FBUztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsaUJBQWlCO0FBQ2pFO0FBQ0E7O0FBRUE7QUFDQSxDQUFDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2ZpbGVwb25kLXBsdWdpbi1maWxlLXZhbGlkYXRlLXNpemUvZGlzdC9maWxlcG9uZC1wbHVnaW4tZmlsZS12YWxpZGF0ZS1zaXplLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBGaWxlUG9uZFBsdWdpbkZpbGVWYWxpZGF0ZVNpemUgMi4yLjFcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCwgaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQvXG4gKiBQbGVhc2UgdmlzaXQgaHR0cHM6Ly9wcWluYS5ubC9maWxlcG9uZC8gZm9yIGRldGFpbHMuXG4gKi9cblxuLyogZXNsaW50LWRpc2FibGUgKi9cblxuKGZ1bmN0aW9uKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcbiAgICA/IChtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSlcbiAgICA6IHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZFxuICAgID8gZGVmaW5lKGZhY3RvcnkpXG4gICAgOiAoKGdsb2JhbCA9IGdsb2JhbCB8fCBzZWxmKSxcbiAgICAgIChnbG9iYWwuRmlsZVBvbmRQbHVnaW5GaWxlVmFsaWRhdGVTaXplID0gZmFjdG9yeSgpKSk7XG59KSh0aGlzLCBmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBwbHVnaW4gPSBmdW5jdGlvbiBwbHVnaW4oX3JlZikge1xuICAgIHZhciBhZGRGaWx0ZXIgPSBfcmVmLmFkZEZpbHRlcixcbiAgICAgIHV0aWxzID0gX3JlZi51dGlscztcbiAgICAvLyBnZXQgcXVpY2sgcmVmZXJlbmNlIHRvIFR5cGUgdXRpbHNcbiAgICB2YXIgVHlwZSA9IHV0aWxzLlR5cGUsXG4gICAgICByZXBsYWNlSW5TdHJpbmcgPSB1dGlscy5yZXBsYWNlSW5TdHJpbmcsXG4gICAgICB0b05hdHVyYWxGaWxlU2l6ZSA9IHV0aWxzLnRvTmF0dXJhbEZpbGVTaXplO1xuXG4gICAgLy8gZmlsdGVyaW5nIGlmIGFuIGl0ZW0gaXMgYWxsb3dlZCBpbiBob3BwZXJcbiAgICBhZGRGaWx0ZXIoJ0FMTE9XX0hPUFBFUl9JVEVNJywgZnVuY3Rpb24oZmlsZSwgX3JlZjIpIHtcbiAgICAgIHZhciBxdWVyeSA9IF9yZWYyLnF1ZXJ5O1xuICAgICAgaWYgKCFxdWVyeSgnR0VUX0FMTE9XX0ZJTEVfU0laRV9WQUxJREFUSU9OJykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBzaXplTWF4ID0gcXVlcnkoJ0dFVF9NQVhfRklMRV9TSVpFJyk7XG4gICAgICBpZiAoc2l6ZU1heCAhPT0gbnVsbCAmJiBmaWxlLnNpemUgPj0gc2l6ZU1heCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciBzaXplTWluID0gcXVlcnkoJ0dFVF9NSU5fRklMRV9TSVpFJyk7XG4gICAgICBpZiAoc2l6ZU1pbiAhPT0gbnVsbCAmJiBmaWxlLnNpemUgPD0gc2l6ZU1pbikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuXG4gICAgLy8gY2FsbGVkIGZvciBlYWNoIGZpbGUgdGhhdCBpcyBsb2FkZWRcbiAgICAvLyByaWdodCBiZWZvcmUgaXQgaXMgc2V0IHRvIHRoZSBpdGVtIHN0YXRlXG4gICAgLy8gc2hvdWxkIHJldHVybiBhIHByb21pc2VcbiAgICBhZGRGaWx0ZXIoJ0xPQURfRklMRScsIGZ1bmN0aW9uKGZpbGUsIF9yZWYzKSB7XG4gICAgICB2YXIgcXVlcnkgPSBfcmVmMy5xdWVyeTtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgLy8gaWYgbm90IGFsbG93ZWQsIGFsbCBmaW5lLCBleGl0XG4gICAgICAgIGlmICghcXVlcnkoJ0dFVF9BTExPV19GSUxFX1NJWkVfVkFMSURBVElPTicpKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc29sdmUoZmlsZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjaGVjayBpZiBmaWxlIHNob3VsZCBiZSBmaWx0ZXJlZFxuICAgICAgICB2YXIgZmlsZUZpbHRlciA9IHF1ZXJ5KCdHRVRfRklMRV9WQUxJREFURV9TSVpFX0ZJTFRFUicpO1xuICAgICAgICBpZiAoZmlsZUZpbHRlciAmJiAhZmlsZUZpbHRlcihmaWxlKSkge1xuICAgICAgICAgIHJldHVybiByZXNvbHZlKGZpbGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVqZWN0IG9yIHJlc29sdmUgYmFzZWQgb24gZmlsZSBzaXplXG4gICAgICAgIHZhciBzaXplTWF4ID0gcXVlcnkoJ0dFVF9NQVhfRklMRV9TSVpFJyk7XG4gICAgICAgIGlmIChzaXplTWF4ICE9PSBudWxsICYmIGZpbGUuc2l6ZSA+PSBzaXplTWF4KSB7XG4gICAgICAgICAgcmVqZWN0KHtcbiAgICAgICAgICAgIHN0YXR1czoge1xuICAgICAgICAgICAgICBtYWluOiBxdWVyeSgnR0VUX0xBQkVMX01BWF9GSUxFX1NJWkVfRVhDRUVERUQnKSxcbiAgICAgICAgICAgICAgc3ViOiByZXBsYWNlSW5TdHJpbmcocXVlcnkoJ0dFVF9MQUJFTF9NQVhfRklMRV9TSVpFJyksIHtcbiAgICAgICAgICAgICAgICBmaWxlc2l6ZTogdG9OYXR1cmFsRmlsZVNpemUoc2l6ZU1heClcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlamVjdCBvciByZXNvbHZlIGJhc2VkIG9uIGZpbGUgc2l6ZVxuICAgICAgICB2YXIgc2l6ZU1pbiA9IHF1ZXJ5KCdHRVRfTUlOX0ZJTEVfU0laRScpO1xuICAgICAgICBpZiAoc2l6ZU1pbiAhPT0gbnVsbCAmJiBmaWxlLnNpemUgPD0gc2l6ZU1pbikge1xuICAgICAgICAgIHJlamVjdCh7XG4gICAgICAgICAgICBzdGF0dXM6IHtcbiAgICAgICAgICAgICAgbWFpbjogcXVlcnkoJ0dFVF9MQUJFTF9NSU5fRklMRV9TSVpFX0VYQ0VFREVEJyksXG4gICAgICAgICAgICAgIHN1YjogcmVwbGFjZUluU3RyaW5nKHF1ZXJ5KCdHRVRfTEFCRUxfTUlOX0ZJTEVfU0laRScpLCB7XG4gICAgICAgICAgICAgICAgZmlsZXNpemU6IHRvTmF0dXJhbEZpbGVTaXplKHNpemVNaW4pXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXR1cm5zIHRoZSBjdXJyZW50IG9wdGlvbiB2YWx1ZVxuICAgICAgICB2YXIgdG90YWxTaXplTWF4ID0gcXVlcnkoJ0dFVF9NQVhfVE9UQUxfRklMRV9TSVpFJyk7XG4gICAgICAgIGlmICh0b3RhbFNpemVNYXggIT09IG51bGwpIHtcbiAgICAgICAgICAvLyBnZXQgdGhlIGN1cnJlbnQgdG90YWwgZmlsZSBzaXplXG4gICAgICAgICAgdmFyIGN1cnJlbnRUb3RhbFNpemUgPSBxdWVyeSgnR0VUX0FDVElWRV9JVEVNUycpLnJlZHVjZShmdW5jdGlvbihcbiAgICAgICAgICAgIHRvdGFsLFxuICAgICAgICAgICAgaXRlbVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIHRvdGFsICsgaXRlbS5maWxlU2l6ZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIDApO1xuXG4gICAgICAgICAgLy8gZ2V0IHRoZSBzaXplIG9mIHRoZSBuZXcgZmlsZVxuICAgICAgICAgIGlmIChjdXJyZW50VG90YWxTaXplID4gdG90YWxTaXplTWF4KSB7XG4gICAgICAgICAgICByZWplY3Qoe1xuICAgICAgICAgICAgICBzdGF0dXM6IHtcbiAgICAgICAgICAgICAgICBtYWluOiBxdWVyeSgnR0VUX0xBQkVMX01BWF9UT1RBTF9GSUxFX1NJWkVfRVhDRUVERUQnKSxcblxuICAgICAgICAgICAgICAgIHN1YjogcmVwbGFjZUluU3RyaW5nKHF1ZXJ5KCdHRVRfTEFCRUxfTUFYX1RPVEFMX0ZJTEVfU0laRScpLCB7XG4gICAgICAgICAgICAgICAgICBmaWxlc2l6ZTogdG9OYXR1cmFsRmlsZVNpemUodG90YWxTaXplTWF4KVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmlsZSBpcyBmaW5lLCBsZXQncyBwYXNzIGl0IGJhY2tcbiAgICAgICAgcmVzb2x2ZShmaWxlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgLy8gRW5hYmxlIG9yIGRpc2FibGUgZmlsZSB0eXBlIHZhbGlkYXRpb25cbiAgICAgICAgYWxsb3dGaWxlU2l6ZVZhbGlkYXRpb246IFt0cnVlLCBUeXBlLkJPT0xFQU5dLFxuXG4gICAgICAgIC8vIE1heCBpbmRpdmlkdWFsIGZpbGUgc2l6ZSBpbiBieXRlc1xuICAgICAgICBtYXhGaWxlU2l6ZTogW251bGwsIFR5cGUuSU5UXSxcblxuICAgICAgICAvLyBNaW4gaW5kaXZpZHVhbCBmaWxlIHNpemUgaW4gYnl0ZXNcbiAgICAgICAgbWluRmlsZVNpemU6IFtudWxsLCBUeXBlLklOVF0sXG5cbiAgICAgICAgLy8gTWF4IHRvdGFsIGZpbGUgc2l6ZSBpbiBieXRlc1xuICAgICAgICBtYXhUb3RhbEZpbGVTaXplOiBbbnVsbCwgVHlwZS5JTlRdLFxuXG4gICAgICAgIC8vIEZpbHRlciB0aGUgZmlsZXMgdGhhdCBuZWVkIHRvIGJlIHZhbGlkYXRlZCBmb3Igc2l6ZVxuICAgICAgICBmaWxlVmFsaWRhdGVTaXplRmlsdGVyOiBbbnVsbCwgVHlwZS5GVU5DVElPTl0sXG5cbiAgICAgICAgLy8gZXJyb3IgbGFiZWxzXG4gICAgICAgIGxhYmVsTWluRmlsZVNpemVFeGNlZWRlZDogWydGaWxlIGlzIHRvbyBzbWFsbCcsIFR5cGUuU1RSSU5HXSxcbiAgICAgICAgbGFiZWxNaW5GaWxlU2l6ZTogWydNaW5pbXVtIGZpbGUgc2l6ZSBpcyB7ZmlsZXNpemV9JywgVHlwZS5TVFJJTkddLFxuXG4gICAgICAgIGxhYmVsTWF4RmlsZVNpemVFeGNlZWRlZDogWydGaWxlIGlzIHRvbyBsYXJnZScsIFR5cGUuU1RSSU5HXSxcbiAgICAgICAgbGFiZWxNYXhGaWxlU2l6ZTogWydNYXhpbXVtIGZpbGUgc2l6ZSBpcyB7ZmlsZXNpemV9JywgVHlwZS5TVFJJTkddLFxuXG4gICAgICAgIGxhYmVsTWF4VG90YWxGaWxlU2l6ZUV4Y2VlZGVkOiBbXG4gICAgICAgICAgJ01heGltdW0gdG90YWwgc2l6ZSBleGNlZWRlZCcsXG4gICAgICAgICAgVHlwZS5TVFJJTkdcbiAgICAgICAgXSxcblxuICAgICAgICBsYWJlbE1heFRvdGFsRmlsZVNpemU6IFtcbiAgICAgICAgICAnTWF4aW11bSB0b3RhbCBmaWxlIHNpemUgaXMge2ZpbGVzaXplfScsXG4gICAgICAgICAgVHlwZS5TVFJJTkdcbiAgICAgICAgXVxuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgLy8gZmlyZSBwbHVnaW5sb2FkZWQgZXZlbnQgaWYgcnVubmluZyBpbiBicm93c2VyLCB0aGlzIGFsbG93cyByZWdpc3RlcmluZyB0aGUgcGx1Z2luIHdoZW4gdXNpbmcgYXN5bmMgc2NyaXB0IHRhZ3NcbiAgdmFyIGlzQnJvd3NlciA9XG4gICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCc7XG4gIGlmIChpc0Jyb3dzZXIpIHtcbiAgICBkb2N1bWVudC5kaXNwYXRjaEV2ZW50KFxuICAgICAgbmV3IEN1c3RvbUV2ZW50KCdGaWxlUG9uZDpwbHVnaW5sb2FkZWQnLCB7IGRldGFpbDogcGx1Z2luIH0pXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiBwbHVnaW47XG59KTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/filepond-plugin-file-validate-size/dist/filepond-plugin-file-validate-size.js\n");

/***/ }),

/***/ "./node_modules/filepond-plugin-file-validate-type/dist/filepond-plugin-file-validate-type.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/filepond-plugin-file-validate-type/dist/filepond-plugin-file-validate-type.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\n * FilePondPluginFileValidateType 1.2.5\n * Licensed under MIT, https://opensource.org/licenses/MIT/\n * Please visit https://pqina.nl/filepond/ for details.\n */\n\n/* eslint-disable */\n\n(function(global, factory) {\n   true\n    ? (module.exports = factory())\n    : undefined;\n})(this, function() {\n  'use strict';\n\n  var plugin = function plugin(_ref) {\n    var addFilter = _ref.addFilter,\n      utils = _ref.utils;\n    // get quick reference to Type utils\n    var Type = utils.Type,\n      isString = utils.isString,\n      replaceInString = utils.replaceInString,\n      guesstimateMimeType = utils.guesstimateMimeType,\n      getExtensionFromFilename = utils.getExtensionFromFilename,\n      getFilenameFromURL = utils.getFilenameFromURL;\n\n    var mimeTypeMatchesWildCard = function mimeTypeMatchesWildCard(\n      mimeType,\n      wildcard\n    ) {\n      var mimeTypeGroup = (/^[^/]+/.exec(mimeType) || []).pop(); // image/png -> image\n      var wildcardGroup = wildcard.slice(0, -2); // image/* -> image\n      return mimeTypeGroup === wildcardGroup;\n    };\n\n    var isValidMimeType = function isValidMimeType(\n      acceptedTypes,\n      userInputType\n    ) {\n      return acceptedTypes.some(function(acceptedType) {\n        // accepted is wildcard mime type\n        if (/\\*$/.test(acceptedType)) {\n          return mimeTypeMatchesWildCard(userInputType, acceptedType);\n        }\n\n        // is normal mime type\n        return acceptedType === userInputType;\n      });\n    };\n\n    var getItemType = function getItemType(item) {\n      // if the item is a url we guess the mime type by the extension\n      var type = '';\n      if (isString(item)) {\n        var filename = getFilenameFromURL(item);\n        var extension = getExtensionFromFilename(filename);\n        if (extension) {\n          type = guesstimateMimeType(extension);\n        }\n      } else {\n        type = item.type;\n      }\n\n      return type;\n    };\n\n    var validateFile = function validateFile(\n      item,\n      acceptedFileTypes,\n      typeDetector\n    ) {\n      // no types defined, everything is allowed \\o/\n      if (acceptedFileTypes.length === 0) {\n        return true;\n      }\n\n      // gets the item type\n      var type = getItemType(item);\n\n      // no type detector, test now\n      if (!typeDetector) {\n        return isValidMimeType(acceptedFileTypes, type);\n      }\n\n      // use type detector\n      return new Promise(function(resolve, reject) {\n        typeDetector(item, type)\n          .then(function(detectedType) {\n            if (isValidMimeType(acceptedFileTypes, detectedType)) {\n              resolve();\n            } else {\n              reject();\n            }\n          })\n          .catch(reject);\n      });\n    };\n\n    var applyMimeTypeMap = function applyMimeTypeMap(map) {\n      return function(acceptedFileType) {\n        return map[acceptedFileType] === null\n          ? false\n          : map[acceptedFileType] || acceptedFileType;\n      };\n    };\n\n    // setup attribute mapping for accept\n    addFilter('SET_ATTRIBUTE_TO_OPTION_MAP', function(map) {\n      return Object.assign(map, {\n        accept: 'acceptedFileTypes'\n      });\n    });\n\n    // filtering if an item is allowed in hopper\n    addFilter('ALLOW_HOPPER_ITEM', function(file, _ref2) {\n      var query = _ref2.query;\n      // if we are not doing file type validation exit\n      if (!query('GET_ALLOW_FILE_TYPE_VALIDATION')) {\n        return true;\n      }\n\n      // we validate the file against the accepted file types\n      return validateFile(file, query('GET_ACCEPTED_FILE_TYPES'));\n    });\n\n    // called for each file that is loaded\n    // right before it is set to the item state\n    // should return a promise\n    addFilter('LOAD_FILE', function(file, _ref3) {\n      var query = _ref3.query;\n      return new Promise(function(resolve, reject) {\n        if (!query('GET_ALLOW_FILE_TYPE_VALIDATION')) {\n          resolve(file);\n          return;\n        }\n\n        var acceptedFileTypes = query('GET_ACCEPTED_FILE_TYPES');\n\n        // custom type detector method\n        var typeDetector = query('GET_FILE_VALIDATE_TYPE_DETECT_TYPE');\n\n        // if invalid, exit here\n        var validationResult = validateFile(\n          file,\n          acceptedFileTypes,\n          typeDetector\n        );\n\n        var handleRejection = function handleRejection() {\n          var acceptedFileTypesMapped = acceptedFileTypes\n            .map(\n              applyMimeTypeMap(\n                query('GET_FILE_VALIDATE_TYPE_LABEL_EXPECTED_TYPES_MAP')\n              )\n            )\n            .filter(function(label) {\n              return label !== false;\n            });\n\n          reject({\n            status: {\n              main: query('GET_LABEL_FILE_TYPE_NOT_ALLOWED'),\n              sub: replaceInString(\n                query('GET_FILE_VALIDATE_TYPE_LABEL_EXPECTED_TYPES'),\n                {\n                  allTypes: acceptedFileTypesMapped.join(', '),\n                  allButLastType: acceptedFileTypesMapped\n                    .slice(0, -1)\n                    .join(', '),\n                  lastType:\n                    acceptedFileTypesMapped[acceptedFileTypesMapped.length - 1]\n                }\n              )\n            }\n          });\n        };\n\n        // has returned new filename immidiately\n        if (typeof validationResult === 'boolean') {\n          if (!validationResult) {\n            return handleRejection();\n          }\n          return resolve(file);\n        }\n\n        // is promise\n        validationResult\n          .then(function() {\n            resolve(file);\n          })\n          .catch(handleRejection);\n      });\n    });\n\n    // expose plugin\n    return {\n      // default options\n      options: {\n        // Enable or disable file type validation\n        allowFileTypeValidation: [true, Type.BOOLEAN],\n\n        // What file types to accept\n        acceptedFileTypes: [[], Type.ARRAY],\n        // - must be comma separated\n        // - mime types: image/png, image/jpeg, image/gif\n        // - extensions: .png, .jpg, .jpeg ( not enabled yet )\n        // - wildcards: image/*\n\n        // label to show when a type is not allowed\n        labelFileTypeNotAllowed: ['File is of invalid type', Type.STRING],\n\n        // nicer label\n        fileValidateTypeLabelExpectedTypes: [\n          'Expects {allButLastType} or {lastType}',\n          Type.STRING\n        ],\n\n        // map mime types to extensions\n        fileValidateTypeLabelExpectedTypesMap: [{}, Type.OBJECT],\n\n        // Custom function to detect type of file\n        fileValidateTypeDetectType: [null, Type.FUNCTION]\n      }\n    };\n  };\n\n  // fire pluginloaded event if running in browser, this allows registering the plugin when using async script tags\n  var isBrowser =\n    typeof window !== 'undefined' && typeof window.document !== 'undefined';\n  if (isBrowser) {\n    document.dispatchEvent(\n      new CustomEvent('FilePond:pluginloaded', { detail: plugin })\n    );\n  }\n\n  return plugin;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmlsZXBvbmQtcGx1Z2luLWZpbGUtdmFsaWRhdGUtdHlwZS9kaXN0L2ZpbGVwb25kLXBsdWdpbi1maWxlLXZhbGlkYXRlLXR5cGUuanM/MTk0MiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsRUFBRSxLQUE0RDtBQUM5RDtBQUNBLE1BQU0sU0FHb0Q7QUFDMUQsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFLGdEQUFnRDtBQUNoRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLGVBQWUsS0FBSyxTQUFTO0FBQ2pEO0FBQ0E7O0FBRUE7QUFDQSxrREFBa0Q7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxpQkFBaUI7QUFDakU7QUFDQTs7QUFFQTtBQUNBLENBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmlsZXBvbmQtcGx1Z2luLWZpbGUtdmFsaWRhdGUtdHlwZS9kaXN0L2ZpbGVwb25kLXBsdWdpbi1maWxlLXZhbGlkYXRlLXR5cGUuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIEZpbGVQb25kUGx1Z2luRmlsZVZhbGlkYXRlVHlwZSAxLjIuNVxuICogTGljZW5zZWQgdW5kZXIgTUlULCBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC9cbiAqIFBsZWFzZSB2aXNpdCBodHRwczovL3BxaW5hLm5sL2ZpbGVwb25kLyBmb3IgZGV0YWlscy5cbiAqL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuXG4oZnVuY3Rpb24oZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xuICAgID8gKG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpKVxuICAgIDogdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kXG4gICAgPyBkZWZpbmUoZmFjdG9yeSlcbiAgICA6ICgoZ2xvYmFsID0gZ2xvYmFsIHx8IHNlbGYpLFxuICAgICAgKGdsb2JhbC5GaWxlUG9uZFBsdWdpbkZpbGVWYWxpZGF0ZVR5cGUgPSBmYWN0b3J5KCkpKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIHBsdWdpbiA9IGZ1bmN0aW9uIHBsdWdpbihfcmVmKSB7XG4gICAgdmFyIGFkZEZpbHRlciA9IF9yZWYuYWRkRmlsdGVyLFxuICAgICAgdXRpbHMgPSBfcmVmLnV0aWxzO1xuICAgIC8vIGdldCBxdWljayByZWZlcmVuY2UgdG8gVHlwZSB1dGlsc1xuICAgIHZhciBUeXBlID0gdXRpbHMuVHlwZSxcbiAgICAgIGlzU3RyaW5nID0gdXRpbHMuaXNTdHJpbmcsXG4gICAgICByZXBsYWNlSW5TdHJpbmcgPSB1dGlscy5yZXBsYWNlSW5TdHJpbmcsXG4gICAgICBndWVzc3RpbWF0ZU1pbWVUeXBlID0gdXRpbHMuZ3Vlc3N0aW1hdGVNaW1lVHlwZSxcbiAgICAgIGdldEV4dGVuc2lvbkZyb21GaWxlbmFtZSA9IHV0aWxzLmdldEV4dGVuc2lvbkZyb21GaWxlbmFtZSxcbiAgICAgIGdldEZpbGVuYW1lRnJvbVVSTCA9IHV0aWxzLmdldEZpbGVuYW1lRnJvbVVSTDtcblxuICAgIHZhciBtaW1lVHlwZU1hdGNoZXNXaWxkQ2FyZCA9IGZ1bmN0aW9uIG1pbWVUeXBlTWF0Y2hlc1dpbGRDYXJkKFxuICAgICAgbWltZVR5cGUsXG4gICAgICB3aWxkY2FyZFxuICAgICkge1xuICAgICAgdmFyIG1pbWVUeXBlR3JvdXAgPSAoL15bXi9dKy8uZXhlYyhtaW1lVHlwZSkgfHwgW10pLnBvcCgpOyAvLyBpbWFnZS9wbmcgLT4gaW1hZ2VcbiAgICAgIHZhciB3aWxkY2FyZEdyb3VwID0gd2lsZGNhcmQuc2xpY2UoMCwgLTIpOyAvLyBpbWFnZS8qIC0+IGltYWdlXG4gICAgICByZXR1cm4gbWltZVR5cGVHcm91cCA9PT0gd2lsZGNhcmRHcm91cDtcbiAgICB9O1xuXG4gICAgdmFyIGlzVmFsaWRNaW1lVHlwZSA9IGZ1bmN0aW9uIGlzVmFsaWRNaW1lVHlwZShcbiAgICAgIGFjY2VwdGVkVHlwZXMsXG4gICAgICB1c2VySW5wdXRUeXBlXG4gICAgKSB7XG4gICAgICByZXR1cm4gYWNjZXB0ZWRUeXBlcy5zb21lKGZ1bmN0aW9uKGFjY2VwdGVkVHlwZSkge1xuICAgICAgICAvLyBhY2NlcHRlZCBpcyB3aWxkY2FyZCBtaW1lIHR5cGVcbiAgICAgICAgaWYgKC9cXCokLy50ZXN0KGFjY2VwdGVkVHlwZSkpIHtcbiAgICAgICAgICByZXR1cm4gbWltZVR5cGVNYXRjaGVzV2lsZENhcmQodXNlcklucHV0VHlwZSwgYWNjZXB0ZWRUeXBlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlzIG5vcm1hbCBtaW1lIHR5cGVcbiAgICAgICAgcmV0dXJuIGFjY2VwdGVkVHlwZSA9PT0gdXNlcklucHV0VHlwZTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICB2YXIgZ2V0SXRlbVR5cGUgPSBmdW5jdGlvbiBnZXRJdGVtVHlwZShpdGVtKSB7XG4gICAgICAvLyBpZiB0aGUgaXRlbSBpcyBhIHVybCB3ZSBndWVzcyB0aGUgbWltZSB0eXBlIGJ5IHRoZSBleHRlbnNpb25cbiAgICAgIHZhciB0eXBlID0gJyc7XG4gICAgICBpZiAoaXNTdHJpbmcoaXRlbSkpIHtcbiAgICAgICAgdmFyIGZpbGVuYW1lID0gZ2V0RmlsZW5hbWVGcm9tVVJMKGl0ZW0pO1xuICAgICAgICB2YXIgZXh0ZW5zaW9uID0gZ2V0RXh0ZW5zaW9uRnJvbUZpbGVuYW1lKGZpbGVuYW1lKTtcbiAgICAgICAgaWYgKGV4dGVuc2lvbikge1xuICAgICAgICAgIHR5cGUgPSBndWVzc3RpbWF0ZU1pbWVUeXBlKGV4dGVuc2lvbik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHR5cGUgPSBpdGVtLnR5cGU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0eXBlO1xuICAgIH07XG5cbiAgICB2YXIgdmFsaWRhdGVGaWxlID0gZnVuY3Rpb24gdmFsaWRhdGVGaWxlKFxuICAgICAgaXRlbSxcbiAgICAgIGFjY2VwdGVkRmlsZVR5cGVzLFxuICAgICAgdHlwZURldGVjdG9yXG4gICAgKSB7XG4gICAgICAvLyBubyB0eXBlcyBkZWZpbmVkLCBldmVyeXRoaW5nIGlzIGFsbG93ZWQgXFxvL1xuICAgICAgaWYgKGFjY2VwdGVkRmlsZVR5cGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gZ2V0cyB0aGUgaXRlbSB0eXBlXG4gICAgICB2YXIgdHlwZSA9IGdldEl0ZW1UeXBlKGl0ZW0pO1xuXG4gICAgICAvLyBubyB0eXBlIGRldGVjdG9yLCB0ZXN0IG5vd1xuICAgICAgaWYgKCF0eXBlRGV0ZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIGlzVmFsaWRNaW1lVHlwZShhY2NlcHRlZEZpbGVUeXBlcywgdHlwZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIHVzZSB0eXBlIGRldGVjdG9yXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHR5cGVEZXRlY3RvcihpdGVtLCB0eXBlKVxuICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKGRldGVjdGVkVHlwZSkge1xuICAgICAgICAgICAgaWYgKGlzVmFsaWRNaW1lVHlwZShhY2NlcHRlZEZpbGVUeXBlcywgZGV0ZWN0ZWRUeXBlKSkge1xuICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZWplY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICAgIC5jYXRjaChyZWplY3QpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHZhciBhcHBseU1pbWVUeXBlTWFwID0gZnVuY3Rpb24gYXBwbHlNaW1lVHlwZU1hcChtYXApIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihhY2NlcHRlZEZpbGVUeXBlKSB7XG4gICAgICAgIHJldHVybiBtYXBbYWNjZXB0ZWRGaWxlVHlwZV0gPT09IG51bGxcbiAgICAgICAgICA/IGZhbHNlXG4gICAgICAgICAgOiBtYXBbYWNjZXB0ZWRGaWxlVHlwZV0gfHwgYWNjZXB0ZWRGaWxlVHlwZTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIC8vIHNldHVwIGF0dHJpYnV0ZSBtYXBwaW5nIGZvciBhY2NlcHRcbiAgICBhZGRGaWx0ZXIoJ1NFVF9BVFRSSUJVVEVfVE9fT1BUSU9OX01BUCcsIGZ1bmN0aW9uKG1hcCkge1xuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obWFwLCB7XG4gICAgICAgIGFjY2VwdDogJ2FjY2VwdGVkRmlsZVR5cGVzJ1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvLyBmaWx0ZXJpbmcgaWYgYW4gaXRlbSBpcyBhbGxvd2VkIGluIGhvcHBlclxuICAgIGFkZEZpbHRlcignQUxMT1dfSE9QUEVSX0lURU0nLCBmdW5jdGlvbihmaWxlLCBfcmVmMikge1xuICAgICAgdmFyIHF1ZXJ5ID0gX3JlZjIucXVlcnk7XG4gICAgICAvLyBpZiB3ZSBhcmUgbm90IGRvaW5nIGZpbGUgdHlwZSB2YWxpZGF0aW9uIGV4aXRcbiAgICAgIGlmICghcXVlcnkoJ0dFVF9BTExPV19GSUxFX1RZUEVfVkFMSURBVElPTicpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyB3ZSB2YWxpZGF0ZSB0aGUgZmlsZSBhZ2FpbnN0IHRoZSBhY2NlcHRlZCBmaWxlIHR5cGVzXG4gICAgICByZXR1cm4gdmFsaWRhdGVGaWxlKGZpbGUsIHF1ZXJ5KCdHRVRfQUNDRVBURURfRklMRV9UWVBFUycpKTtcbiAgICB9KTtcblxuICAgIC8vIGNhbGxlZCBmb3IgZWFjaCBmaWxlIHRoYXQgaXMgbG9hZGVkXG4gICAgLy8gcmlnaHQgYmVmb3JlIGl0IGlzIHNldCB0byB0aGUgaXRlbSBzdGF0ZVxuICAgIC8vIHNob3VsZCByZXR1cm4gYSBwcm9taXNlXG4gICAgYWRkRmlsdGVyKCdMT0FEX0ZJTEUnLCBmdW5jdGlvbihmaWxlLCBfcmVmMykge1xuICAgICAgdmFyIHF1ZXJ5ID0gX3JlZjMucXVlcnk7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGlmICghcXVlcnkoJ0dFVF9BTExPV19GSUxFX1RZUEVfVkFMSURBVElPTicpKSB7XG4gICAgICAgICAgcmVzb2x2ZShmaWxlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYWNjZXB0ZWRGaWxlVHlwZXMgPSBxdWVyeSgnR0VUX0FDQ0VQVEVEX0ZJTEVfVFlQRVMnKTtcblxuICAgICAgICAvLyBjdXN0b20gdHlwZSBkZXRlY3RvciBtZXRob2RcbiAgICAgICAgdmFyIHR5cGVEZXRlY3RvciA9IHF1ZXJ5KCdHRVRfRklMRV9WQUxJREFURV9UWVBFX0RFVEVDVF9UWVBFJyk7XG5cbiAgICAgICAgLy8gaWYgaW52YWxpZCwgZXhpdCBoZXJlXG4gICAgICAgIHZhciB2YWxpZGF0aW9uUmVzdWx0ID0gdmFsaWRhdGVGaWxlKFxuICAgICAgICAgIGZpbGUsXG4gICAgICAgICAgYWNjZXB0ZWRGaWxlVHlwZXMsXG4gICAgICAgICAgdHlwZURldGVjdG9yXG4gICAgICAgICk7XG5cbiAgICAgICAgdmFyIGhhbmRsZVJlamVjdGlvbiA9IGZ1bmN0aW9uIGhhbmRsZVJlamVjdGlvbigpIHtcbiAgICAgICAgICB2YXIgYWNjZXB0ZWRGaWxlVHlwZXNNYXBwZWQgPSBhY2NlcHRlZEZpbGVUeXBlc1xuICAgICAgICAgICAgLm1hcChcbiAgICAgICAgICAgICAgYXBwbHlNaW1lVHlwZU1hcChcbiAgICAgICAgICAgICAgICBxdWVyeSgnR0VUX0ZJTEVfVkFMSURBVEVfVFlQRV9MQUJFTF9FWFBFQ1RFRF9UWVBFU19NQVAnKVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKGxhYmVsKSB7XG4gICAgICAgICAgICAgIHJldHVybiBsYWJlbCAhPT0gZmFsc2U7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIHJlamVjdCh7XG4gICAgICAgICAgICBzdGF0dXM6IHtcbiAgICAgICAgICAgICAgbWFpbjogcXVlcnkoJ0dFVF9MQUJFTF9GSUxFX1RZUEVfTk9UX0FMTE9XRUQnKSxcbiAgICAgICAgICAgICAgc3ViOiByZXBsYWNlSW5TdHJpbmcoXG4gICAgICAgICAgICAgICAgcXVlcnkoJ0dFVF9GSUxFX1ZBTElEQVRFX1RZUEVfTEFCRUxfRVhQRUNURURfVFlQRVMnKSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBhbGxUeXBlczogYWNjZXB0ZWRGaWxlVHlwZXNNYXBwZWQuam9pbignLCAnKSxcbiAgICAgICAgICAgICAgICAgIGFsbEJ1dExhc3RUeXBlOiBhY2NlcHRlZEZpbGVUeXBlc01hcHBlZFxuICAgICAgICAgICAgICAgICAgICAuc2xpY2UoMCwgLTEpXG4gICAgICAgICAgICAgICAgICAgIC5qb2luKCcsICcpLFxuICAgICAgICAgICAgICAgICAgbGFzdFR5cGU6XG4gICAgICAgICAgICAgICAgICAgIGFjY2VwdGVkRmlsZVR5cGVzTWFwcGVkW2FjY2VwdGVkRmlsZVR5cGVzTWFwcGVkLmxlbmd0aCAtIDFdXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gaGFzIHJldHVybmVkIG5ldyBmaWxlbmFtZSBpbW1pZGlhdGVseVxuICAgICAgICBpZiAodHlwZW9mIHZhbGlkYXRpb25SZXN1bHQgPT09ICdib29sZWFuJykge1xuICAgICAgICAgIGlmICghdmFsaWRhdGlvblJlc3VsdCkge1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZVJlamVjdGlvbigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzb2x2ZShmaWxlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlzIHByb21pc2VcbiAgICAgICAgdmFsaWRhdGlvblJlc3VsdFxuICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmVzb2x2ZShmaWxlKTtcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5jYXRjaChoYW5kbGVSZWplY3Rpb24pO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvLyBleHBvc2UgcGx1Z2luXG4gICAgcmV0dXJuIHtcbiAgICAgIC8vIGRlZmF1bHQgb3B0aW9uc1xuICAgICAgb3B0aW9uczoge1xuICAgICAgICAvLyBFbmFibGUgb3IgZGlzYWJsZSBmaWxlIHR5cGUgdmFsaWRhdGlvblxuICAgICAgICBhbGxvd0ZpbGVUeXBlVmFsaWRhdGlvbjogW3RydWUsIFR5cGUuQk9PTEVBTl0sXG5cbiAgICAgICAgLy8gV2hhdCBmaWxlIHR5cGVzIHRvIGFjY2VwdFxuICAgICAgICBhY2NlcHRlZEZpbGVUeXBlczogW1tdLCBUeXBlLkFSUkFZXSxcbiAgICAgICAgLy8gLSBtdXN0IGJlIGNvbW1hIHNlcGFyYXRlZFxuICAgICAgICAvLyAtIG1pbWUgdHlwZXM6IGltYWdlL3BuZywgaW1hZ2UvanBlZywgaW1hZ2UvZ2lmXG4gICAgICAgIC8vIC0gZXh0ZW5zaW9uczogLnBuZywgLmpwZywgLmpwZWcgKCBub3QgZW5hYmxlZCB5ZXQgKVxuICAgICAgICAvLyAtIHdpbGRjYXJkczogaW1hZ2UvKlxuXG4gICAgICAgIC8vIGxhYmVsIHRvIHNob3cgd2hlbiBhIHR5cGUgaXMgbm90IGFsbG93ZWRcbiAgICAgICAgbGFiZWxGaWxlVHlwZU5vdEFsbG93ZWQ6IFsnRmlsZSBpcyBvZiBpbnZhbGlkIHR5cGUnLCBUeXBlLlNUUklOR10sXG5cbiAgICAgICAgLy8gbmljZXIgbGFiZWxcbiAgICAgICAgZmlsZVZhbGlkYXRlVHlwZUxhYmVsRXhwZWN0ZWRUeXBlczogW1xuICAgICAgICAgICdFeHBlY3RzIHthbGxCdXRMYXN0VHlwZX0gb3Ige2xhc3RUeXBlfScsXG4gICAgICAgICAgVHlwZS5TVFJJTkdcbiAgICAgICAgXSxcblxuICAgICAgICAvLyBtYXAgbWltZSB0eXBlcyB0byBleHRlbnNpb25zXG4gICAgICAgIGZpbGVWYWxpZGF0ZVR5cGVMYWJlbEV4cGVjdGVkVHlwZXNNYXA6IFt7fSwgVHlwZS5PQkpFQ1RdLFxuXG4gICAgICAgIC8vIEN1c3RvbSBmdW5jdGlvbiB0byBkZXRlY3QgdHlwZSBvZiBmaWxlXG4gICAgICAgIGZpbGVWYWxpZGF0ZVR5cGVEZXRlY3RUeXBlOiBbbnVsbCwgVHlwZS5GVU5DVElPTl1cbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIC8vIGZpcmUgcGx1Z2lubG9hZGVkIGV2ZW50IGlmIHJ1bm5pbmcgaW4gYnJvd3NlciwgdGhpcyBhbGxvd3MgcmVnaXN0ZXJpbmcgdGhlIHBsdWdpbiB3aGVuIHVzaW5nIGFzeW5jIHNjcmlwdCB0YWdzXG4gIHZhciBpc0Jyb3dzZXIgPVxuICAgIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnO1xuICBpZiAoaXNCcm93c2VyKSB7XG4gICAgZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChcbiAgICAgIG5ldyBDdXN0b21FdmVudCgnRmlsZVBvbmQ6cGx1Z2lubG9hZGVkJywgeyBkZXRhaWw6IHBsdWdpbiB9KVxuICAgICk7XG4gIH1cblxuICByZXR1cm4gcGx1Z2luO1xufSk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/filepond-plugin-file-validate-type/dist/filepond-plugin-file-validate-type.js\n");

/***/ }),

/***/ "./node_modules/filepond/dist/filepond.js":
/*!************************************************!*\
  !*** ./node_modules/filepond/dist/filepond.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\n * FilePond 4.25.1\n * Licensed under MIT, https://opensource.org/licenses/MIT/\n * Please visit https://pqina.nl/filepond/ for details.\n */\n\n/* eslint-disable */\n\n(function(global, factory) {\n   true\n    ? factory(exports)\n    : undefined;\n})(this, function(exports) {\n  'use strict';\n\n  var isNode = function isNode(value) {\n    return value instanceof HTMLElement;\n  };\n\n  var createStore = function createStore(initialState) {\n    var queries =\n      arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    var actions =\n      arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    // internal state\n    var state = Object.assign({}, initialState);\n\n    // contains all actions for next frame, is clear when actions are requested\n    var actionQueue = [];\n    var dispatchQueue = [];\n\n    // returns a duplicate of the current state\n    var getState = function getState() {\n      return Object.assign({}, state);\n    };\n\n    // returns a duplicate of the actions array and clears the actions array\n    var processActionQueue = function processActionQueue() {\n      // create copy of actions queue\n      var queue = [].concat(actionQueue);\n\n      // clear actions queue (we don't want no double actions)\n      actionQueue.length = 0;\n\n      return queue;\n    };\n\n    // processes actions that might block the main UI thread\n    var processDispatchQueue = function processDispatchQueue() {\n      // create copy of actions queue\n      var queue = [].concat(dispatchQueue);\n\n      // clear actions queue (we don't want no double actions)\n      dispatchQueue.length = 0;\n\n      // now dispatch these actions\n      queue.forEach(function(_ref) {\n        var type = _ref.type,\n          data = _ref.data;\n        dispatch(type, data);\n      });\n    };\n\n    // adds a new action, calls its handler and\n    var dispatch = function dispatch(type, data, isBlocking) {\n      // is blocking action (should never block if document is hidden)\n      if (isBlocking && !document.hidden) {\n        dispatchQueue.push({ type: type, data: data });\n        return;\n      }\n\n      // if this action has a handler, handle the action\n      if (actionHandlers[type]) {\n        actionHandlers[type](data);\n      }\n\n      // now add action\n      actionQueue.push({\n        type: type,\n        data: data\n      });\n    };\n\n    var query = function query(str) {\n      var _queryHandles;\n      for (\n        var _len = arguments.length,\n          args = new Array(_len > 1 ? _len - 1 : 0),\n          _key = 1;\n        _key < _len;\n        _key++\n      ) {\n        args[_key - 1] = arguments[_key];\n      }\n      return queryHandles[str]\n        ? (_queryHandles = queryHandles)[str].apply(_queryHandles, args)\n        : null;\n    };\n\n    var api = {\n      getState: getState,\n      processActionQueue: processActionQueue,\n      processDispatchQueue: processDispatchQueue,\n      dispatch: dispatch,\n      query: query\n    };\n\n    var queryHandles = {};\n    queries.forEach(function(query) {\n      queryHandles = Object.assign({}, query(state), {}, queryHandles);\n    });\n\n    var actionHandlers = {};\n    actions.forEach(function(action) {\n      actionHandlers = Object.assign(\n        {},\n        action(dispatch, query, state),\n        {},\n        actionHandlers\n      );\n    });\n\n    return api;\n  };\n\n  var defineProperty = function defineProperty(obj, property, definition) {\n    if (typeof definition === 'function') {\n      obj[property] = definition;\n      return;\n    }\n    Object.defineProperty(obj, property, Object.assign({}, definition));\n  };\n\n  var forin = function forin(obj, cb) {\n    for (var key in obj) {\n      if (!obj.hasOwnProperty(key)) {\n        continue;\n      }\n\n      cb(key, obj[key]);\n    }\n  };\n\n  var createObject = function createObject(definition) {\n    var obj = {};\n    forin(definition, function(property) {\n      defineProperty(obj, property, definition[property]);\n    });\n    return obj;\n  };\n\n  var attr = function attr(node, name) {\n    var value =\n      arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    if (value === null) {\n      return node.getAttribute(name) || node.hasAttribute(name);\n    }\n    node.setAttribute(name, value);\n  };\n\n  var ns = 'http://www.w3.org/2000/svg';\n  var svgElements = ['svg', 'path']; // only svg elements used\n\n  var isSVGElement = function isSVGElement(tag) {\n    return svgElements.includes(tag);\n  };\n\n  var createElement = function createElement(tag, className) {\n    var attributes =\n      arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    if (typeof className === 'object') {\n      attributes = className;\n      className = null;\n    }\n    var element = isSVGElement(tag)\n      ? document.createElementNS(ns, tag)\n      : document.createElement(tag);\n    if (className) {\n      if (isSVGElement(tag)) {\n        attr(element, 'class', className);\n      } else {\n        element.className = className;\n      }\n    }\n    forin(attributes, function(name, value) {\n      attr(element, name, value);\n    });\n    return element;\n  };\n\n  var appendChild = function appendChild(parent) {\n    return function(child, index) {\n      if (typeof index !== 'undefined' && parent.children[index]) {\n        parent.insertBefore(child, parent.children[index]);\n      } else {\n        parent.appendChild(child);\n      }\n    };\n  };\n\n  var appendChildView = function appendChildView(parent, childViews) {\n    return function(view, index) {\n      if (typeof index !== 'undefined') {\n        childViews.splice(index, 0, view);\n      } else {\n        childViews.push(view);\n      }\n\n      return view;\n    };\n  };\n\n  var removeChildView = function removeChildView(parent, childViews) {\n    return function(view) {\n      // remove from child views\n      childViews.splice(childViews.indexOf(view), 1);\n\n      // remove the element\n      if (view.element.parentNode) {\n        parent.removeChild(view.element);\n      }\n\n      return view;\n    };\n  };\n\n  var IS_BROWSER = (function() {\n    return (\n      typeof window !== 'undefined' && typeof window.document !== 'undefined'\n    );\n  })();\n  var isBrowser = function isBrowser() {\n    return IS_BROWSER;\n  };\n\n  var testElement = isBrowser() ? createElement('svg') : {};\n  var getChildCount =\n    'children' in testElement\n      ? function(el) {\n          return el.children.length;\n        }\n      : function(el) {\n          return el.childNodes.length;\n        };\n\n  var getViewRect = function getViewRect(\n    elementRect,\n    childViews,\n    offset,\n    scale\n  ) {\n    var left = offset[0] || elementRect.left;\n    var top = offset[1] || elementRect.top;\n    var right = left + elementRect.width;\n    var bottom = top + elementRect.height * (scale[1] || 1);\n\n    var rect = {\n      // the rectangle of the element itself\n      element: Object.assign({}, elementRect),\n\n      // the rectangle of the element expanded to contain its children, does not include any margins\n      inner: {\n        left: elementRect.left,\n        top: elementRect.top,\n        right: elementRect.right,\n        bottom: elementRect.bottom\n      },\n\n      // the rectangle of the element expanded to contain its children including own margin and child margins\n      // margins will be added after we've recalculated the size\n      outer: {\n        left: left,\n        top: top,\n        right: right,\n        bottom: bottom\n      }\n    };\n\n    // expand rect to fit all child rectangles\n    childViews\n      .filter(function(childView) {\n        return !childView.isRectIgnored();\n      })\n      .map(function(childView) {\n        return childView.rect;\n      })\n      .forEach(function(childViewRect) {\n        expandRect(rect.inner, Object.assign({}, childViewRect.inner));\n        expandRect(rect.outer, Object.assign({}, childViewRect.outer));\n      });\n\n    // calculate inner width and height\n    calculateRectSize(rect.inner);\n\n    // append additional margin (top and left margins are included in top and left automatically)\n    rect.outer.bottom += rect.element.marginBottom;\n    rect.outer.right += rect.element.marginRight;\n\n    // calculate outer width and height\n    calculateRectSize(rect.outer);\n\n    return rect;\n  };\n\n  var expandRect = function expandRect(parent, child) {\n    // adjust for parent offset\n    child.top += parent.top;\n    child.right += parent.left;\n    child.bottom += parent.top;\n    child.left += parent.left;\n\n    if (child.bottom > parent.bottom) {\n      parent.bottom = child.bottom;\n    }\n\n    if (child.right > parent.right) {\n      parent.right = child.right;\n    }\n  };\n\n  var calculateRectSize = function calculateRectSize(rect) {\n    rect.width = rect.right - rect.left;\n    rect.height = rect.bottom - rect.top;\n  };\n\n  var isNumber = function isNumber(value) {\n    return typeof value === 'number';\n  };\n\n  /**\n   * Determines if position is at destination\n   * @param position\n   * @param destination\n   * @param velocity\n   * @param errorMargin\n   * @returns {boolean}\n   */\n  var thereYet = function thereYet(position, destination, velocity) {\n    var errorMargin =\n      arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.001;\n    return (\n      Math.abs(position - destination) < errorMargin &&\n      Math.abs(velocity) < errorMargin\n    );\n  };\n\n  /**\n   * Spring animation\n   */\n  var spring =\n    // default options\n    function spring() // method definition\n    {\n      var _ref =\n          arguments.length > 0 && arguments[0] !== undefined\n            ? arguments[0]\n            : {},\n        _ref$stiffness = _ref.stiffness,\n        stiffness = _ref$stiffness === void 0 ? 0.5 : _ref$stiffness,\n        _ref$damping = _ref.damping,\n        damping = _ref$damping === void 0 ? 0.75 : _ref$damping,\n        _ref$mass = _ref.mass,\n        mass = _ref$mass === void 0 ? 10 : _ref$mass;\n      var target = null;\n      var position = null;\n      var velocity = 0;\n      var resting = false;\n\n      // updates spring state\n      var interpolate = function interpolate(ts, skipToEndState) {\n        // in rest, don't animate\n        if (resting) return;\n\n        // need at least a target or position to do springy things\n        if (!(isNumber(target) && isNumber(position))) {\n          resting = true;\n          velocity = 0;\n          return;\n        }\n\n        // calculate spring force\n        var f = -(position - target) * stiffness;\n\n        // update velocity by adding force based on mass\n        velocity += f / mass;\n\n        // update position by adding velocity\n        position += velocity;\n\n        // slow down based on amount of damping\n        velocity *= damping;\n\n        // we've arrived if we're near target and our velocity is near zero\n        if (thereYet(position, target, velocity) || skipToEndState) {\n          position = target;\n          velocity = 0;\n          resting = true;\n\n          // we done\n          api.onupdate(position);\n          api.oncomplete(position);\n        } else {\n          // progress update\n          api.onupdate(position);\n        }\n      };\n\n      /**\n       * Set new target value\n       * @param value\n       */\n      var setTarget = function setTarget(value) {\n        // if currently has no position, set target and position to this value\n        if (isNumber(value) && !isNumber(position)) {\n          position = value;\n        }\n\n        // next target value will not be animated to\n        if (target === null) {\n          target = value;\n          position = value;\n        }\n\n        // let start moving to target\n        target = value;\n\n        // already at target\n        if (position === target || typeof target === 'undefined') {\n          // now resting as target is current position, stop moving\n          resting = true;\n          velocity = 0;\n\n          // done!\n          api.onupdate(position);\n          api.oncomplete(position);\n\n          return;\n        }\n\n        resting = false;\n      };\n\n      // need 'api' to call onupdate callback\n      var api = createObject({\n        interpolate: interpolate,\n        target: {\n          set: setTarget,\n          get: function get() {\n            return target;\n          }\n        },\n\n        resting: {\n          get: function get() {\n            return resting;\n          }\n        },\n\n        onupdate: function onupdate(value) {},\n        oncomplete: function oncomplete(value) {}\n      });\n\n      return api;\n    };\n\n  var easeLinear = function easeLinear(t) {\n    return t;\n  };\n  var easeInOutQuad = function easeInOutQuad(t) {\n    return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;\n  };\n\n  var tween =\n    // default values\n    function tween() // method definition\n    {\n      var _ref =\n          arguments.length > 0 && arguments[0] !== undefined\n            ? arguments[0]\n            : {},\n        _ref$duration = _ref.duration,\n        duration = _ref$duration === void 0 ? 500 : _ref$duration,\n        _ref$easing = _ref.easing,\n        easing = _ref$easing === void 0 ? easeInOutQuad : _ref$easing,\n        _ref$delay = _ref.delay,\n        delay = _ref$delay === void 0 ? 0 : _ref$delay;\n      var start = null;\n      var t;\n      var p;\n      var resting = true;\n      var reverse = false;\n      var target = null;\n\n      var interpolate = function interpolate(ts, skipToEndState) {\n        if (resting || target === null) return;\n\n        if (start === null) {\n          start = ts;\n        }\n\n        if (ts - start < delay) return;\n\n        t = ts - start - delay;\n\n        if (t >= duration || skipToEndState) {\n          t = 1;\n          p = reverse ? 0 : 1;\n          api.onupdate(p * target);\n          api.oncomplete(p * target);\n          resting = true;\n        } else {\n          p = t / duration;\n          api.onupdate((t >= 0 ? easing(reverse ? 1 - p : p) : 0) * target);\n        }\n      };\n\n      // need 'api' to call onupdate callback\n      var api = createObject({\n        interpolate: interpolate,\n        target: {\n          get: function get() {\n            return reverse ? 0 : target;\n          },\n          set: function set(value) {\n            // is initial value\n            if (target === null) {\n              target = value;\n              api.onupdate(value);\n              api.oncomplete(value);\n              return;\n            }\n\n            // want to tween to a smaller value and have a current value\n            if (value < target) {\n              target = 1;\n              reverse = true;\n            } else {\n              // not tweening to a smaller value\n              reverse = false;\n              target = value;\n            }\n\n            // let's go!\n            resting = false;\n            start = null;\n          }\n        },\n\n        resting: {\n          get: function get() {\n            return resting;\n          }\n        },\n\n        onupdate: function onupdate(value) {},\n        oncomplete: function oncomplete(value) {}\n      });\n\n      return api;\n    };\n\n  var animator = {\n    spring: spring,\n    tween: tween\n  };\n\n  /*\n                       { type: 'spring', stiffness: .5, damping: .75, mass: 10 };\n                       { translation: { type: 'spring', ... }, ... }\n                       { translation: { x: { type: 'spring', ... } } }\n                      */\n  var createAnimator = function createAnimator(definition, category, property) {\n    // default is single definition\n    // we check if transform is set, if so, we check if property is set\n    var def =\n      definition[category] && typeof definition[category][property] === 'object'\n        ? definition[category][property]\n        : definition[category] || definition;\n\n    var type = typeof def === 'string' ? def : def.type;\n    var props = typeof def === 'object' ? Object.assign({}, def) : {};\n\n    return animator[type] ? animator[type](props) : null;\n  };\n\n  var addGetSet = function addGetSet(keys, obj, props) {\n    var overwrite =\n      arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    obj = Array.isArray(obj) ? obj : [obj];\n    obj.forEach(function(o) {\n      keys.forEach(function(key) {\n        var name = key;\n        var getter = function getter() {\n          return props[key];\n        };\n        var setter = function setter(value) {\n          return (props[key] = value);\n        };\n\n        if (typeof key === 'object') {\n          name = key.key;\n          getter = key.getter || getter;\n          setter = key.setter || setter;\n        }\n\n        if (o[name] && !overwrite) {\n          return;\n        }\n\n        o[name] = {\n          get: getter,\n          set: setter\n        };\n      });\n    });\n  };\n\n  // add to state,\n  // add getters and setters to internal and external api (if not set)\n  // setup animators\n\n  var animations = function animations(_ref) {\n    var mixinConfig = _ref.mixinConfig,\n      viewProps = _ref.viewProps,\n      viewInternalAPI = _ref.viewInternalAPI,\n      viewExternalAPI = _ref.viewExternalAPI;\n    // initial properties\n    var initialProps = Object.assign({}, viewProps);\n\n    // list of all active animations\n    var animations = [];\n\n    // setup animators\n    forin(mixinConfig, function(property, animation) {\n      var animator = createAnimator(animation);\n      if (!animator) {\n        return;\n      }\n\n      // when the animator updates, update the view state value\n      animator.onupdate = function(value) {\n        viewProps[property] = value;\n      };\n\n      // set animator target\n      animator.target = initialProps[property];\n\n      // when value is set, set the animator target value\n      var prop = {\n        key: property,\n        setter: function setter(value) {\n          // if already at target, we done!\n          if (animator.target === value) {\n            return;\n          }\n\n          animator.target = value;\n        },\n        getter: function getter() {\n          return viewProps[property];\n        }\n      };\n\n      // add getters and setters\n      addGetSet([prop], [viewInternalAPI, viewExternalAPI], viewProps, true);\n\n      // add it to the list for easy updating from the _write method\n      animations.push(animator);\n    });\n\n    // expose internal write api\n    return {\n      write: function write(ts) {\n        var skipToEndState = document.hidden;\n        var resting = true;\n        animations.forEach(function(animation) {\n          if (!animation.resting) resting = false;\n          animation.interpolate(ts, skipToEndState);\n        });\n        return resting;\n      },\n      destroy: function destroy() {}\n    };\n  };\n\n  var addEvent = function addEvent(element) {\n    return function(type, fn) {\n      element.addEventListener(type, fn);\n    };\n  };\n\n  var removeEvent = function removeEvent(element) {\n    return function(type, fn) {\n      element.removeEventListener(type, fn);\n    };\n  };\n\n  // mixin\n  var listeners = function listeners(_ref) {\n    var mixinConfig = _ref.mixinConfig,\n      viewProps = _ref.viewProps,\n      viewInternalAPI = _ref.viewInternalAPI,\n      viewExternalAPI = _ref.viewExternalAPI,\n      viewState = _ref.viewState,\n      view = _ref.view;\n    var events = [];\n\n    var add = addEvent(view.element);\n    var remove = removeEvent(view.element);\n\n    viewExternalAPI.on = function(type, fn) {\n      events.push({\n        type: type,\n        fn: fn\n      });\n\n      add(type, fn);\n    };\n\n    viewExternalAPI.off = function(type, fn) {\n      events.splice(\n        events.findIndex(function(event) {\n          return event.type === type && event.fn === fn;\n        }),\n        1\n      );\n\n      remove(type, fn);\n    };\n\n    return {\n      write: function write() {\n        // not busy\n        return true;\n      },\n      destroy: function destroy() {\n        events.forEach(function(event) {\n          remove(event.type, event.fn);\n        });\n      }\n    };\n  };\n\n  // add to external api and link to props\n\n  var apis = function apis(_ref) {\n    var mixinConfig = _ref.mixinConfig,\n      viewProps = _ref.viewProps,\n      viewExternalAPI = _ref.viewExternalAPI;\n    addGetSet(mixinConfig, viewExternalAPI, viewProps);\n  };\n\n  var isDefined = function isDefined(value) {\n    return value != null;\n  };\n\n  // add to state,\n  // add getters and setters to internal and external api (if not set)\n  // set initial state based on props in viewProps\n  // apply as transforms each frame\n\n  var defaults = {\n    opacity: 1,\n    scaleX: 1,\n    scaleY: 1,\n    translateX: 0,\n    translateY: 0,\n    rotateX: 0,\n    rotateY: 0,\n    rotateZ: 0,\n    originX: 0,\n    originY: 0\n  };\n\n  var styles = function styles(_ref) {\n    var mixinConfig = _ref.mixinConfig,\n      viewProps = _ref.viewProps,\n      viewInternalAPI = _ref.viewInternalAPI,\n      viewExternalAPI = _ref.viewExternalAPI,\n      view = _ref.view;\n    // initial props\n    var initialProps = Object.assign({}, viewProps);\n\n    // current props\n    var currentProps = {};\n\n    // we will add those properties to the external API and link them to the viewState\n    addGetSet(mixinConfig, [viewInternalAPI, viewExternalAPI], viewProps);\n\n    // override rect on internal and external rect getter so it takes in account transforms\n    var getOffset = function getOffset() {\n      return [viewProps['translateX'] || 0, viewProps['translateY'] || 0];\n    };\n\n    var getScale = function getScale() {\n      return [viewProps['scaleX'] || 0, viewProps['scaleY'] || 0];\n    };\n    var getRect = function getRect() {\n      return view.rect\n        ? getViewRect(view.rect, view.childViews, getOffset(), getScale())\n        : null;\n    };\n    viewInternalAPI.rect = { get: getRect };\n    viewExternalAPI.rect = { get: getRect };\n\n    // apply view props\n    mixinConfig.forEach(function(key) {\n      viewProps[key] =\n        typeof initialProps[key] === 'undefined'\n          ? defaults[key]\n          : initialProps[key];\n    });\n\n    // expose api\n    return {\n      write: function write() {\n        // see if props have changed\n        if (!propsHaveChanged(currentProps, viewProps)) {\n          return;\n        }\n\n        // moves element to correct position on screen\n        applyStyles(view.element, viewProps);\n\n        // store new transforms\n        Object.assign(currentProps, Object.assign({}, viewProps));\n\n        // no longer busy\n        return true;\n      },\n      destroy: function destroy() {}\n    };\n  };\n\n  var propsHaveChanged = function propsHaveChanged(currentProps, newProps) {\n    // different amount of keys\n    if (Object.keys(currentProps).length !== Object.keys(newProps).length) {\n      return true;\n    }\n\n    // lets analyze the individual props\n    for (var prop in newProps) {\n      if (newProps[prop] !== currentProps[prop]) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  var applyStyles = function applyStyles(element, _ref2) {\n    var opacity = _ref2.opacity,\n      perspective = _ref2.perspective,\n      translateX = _ref2.translateX,\n      translateY = _ref2.translateY,\n      scaleX = _ref2.scaleX,\n      scaleY = _ref2.scaleY,\n      rotateX = _ref2.rotateX,\n      rotateY = _ref2.rotateY,\n      rotateZ = _ref2.rotateZ,\n      originX = _ref2.originX,\n      originY = _ref2.originY,\n      width = _ref2.width,\n      height = _ref2.height;\n\n    var transforms = '';\n    var styles = '';\n\n    // handle transform origin\n    if (isDefined(originX) || isDefined(originY)) {\n      styles +=\n        'transform-origin: ' + (originX || 0) + 'px ' + (originY || 0) + 'px;';\n    }\n\n    // transform order is relevant\n    // 0. perspective\n    if (isDefined(perspective)) {\n      transforms += 'perspective(' + perspective + 'px) ';\n    }\n\n    // 1. translate\n    if (isDefined(translateX) || isDefined(translateY)) {\n      transforms +=\n        'translate3d(' +\n        (translateX || 0) +\n        'px, ' +\n        (translateY || 0) +\n        'px, 0) ';\n    }\n\n    // 2. scale\n    if (isDefined(scaleX) || isDefined(scaleY)) {\n      transforms +=\n        'scale3d(' +\n        (isDefined(scaleX) ? scaleX : 1) +\n        ', ' +\n        (isDefined(scaleY) ? scaleY : 1) +\n        ', 1) ';\n    }\n\n    // 3. rotate\n    if (isDefined(rotateZ)) {\n      transforms += 'rotateZ(' + rotateZ + 'rad) ';\n    }\n\n    if (isDefined(rotateX)) {\n      transforms += 'rotateX(' + rotateX + 'rad) ';\n    }\n\n    if (isDefined(rotateY)) {\n      transforms += 'rotateY(' + rotateY + 'rad) ';\n    }\n\n    // add transforms\n    if (transforms.length) {\n      styles += 'transform:' + transforms + ';';\n    }\n\n    // add opacity\n    if (isDefined(opacity)) {\n      styles += 'opacity:' + opacity + ';';\n\n      // if we reach zero, we make the element inaccessible\n      if (opacity === 0) {\n        styles += 'visibility:hidden;';\n      }\n\n      // if we're below 100% opacity this element can't be clicked\n      if (opacity < 1) {\n        styles += 'pointer-events:none;';\n      }\n    }\n\n    // add height\n    if (isDefined(height)) {\n      styles += 'height:' + height + 'px;';\n    }\n\n    // add width\n    if (isDefined(width)) {\n      styles += 'width:' + width + 'px;';\n    }\n\n    // apply styles\n    var elementCurrentStyle = element.elementCurrentStyle || '';\n\n    // if new styles does not match current styles, lets update!\n    if (\n      styles.length !== elementCurrentStyle.length ||\n      styles !== elementCurrentStyle\n    ) {\n      element.style.cssText = styles;\n      // store current styles so we can compare them to new styles later on\n      // _not_ getting the style value is faster\n      element.elementCurrentStyle = styles;\n    }\n  };\n\n  var Mixins = {\n    styles: styles,\n    listeners: listeners,\n    animations: animations,\n    apis: apis\n  };\n\n  var updateRect = function updateRect() {\n    var rect =\n      arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var element =\n      arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var style =\n      arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    if (!element.layoutCalculated) {\n      rect.paddingTop = parseInt(style.paddingTop, 10) || 0;\n      rect.marginTop = parseInt(style.marginTop, 10) || 0;\n      rect.marginRight = parseInt(style.marginRight, 10) || 0;\n      rect.marginBottom = parseInt(style.marginBottom, 10) || 0;\n      rect.marginLeft = parseInt(style.marginLeft, 10) || 0;\n      element.layoutCalculated = true;\n    }\n\n    rect.left = element.offsetLeft || 0;\n    rect.top = element.offsetTop || 0;\n    rect.width = element.offsetWidth || 0;\n    rect.height = element.offsetHeight || 0;\n\n    rect.right = rect.left + rect.width;\n    rect.bottom = rect.top + rect.height;\n\n    rect.scrollTop = element.scrollTop;\n\n    rect.hidden = element.offsetParent === null;\n\n    return rect;\n  };\n\n  var createView =\n    // default view definition\n    function createView() {\n      var _ref =\n          arguments.length > 0 && arguments[0] !== undefined\n            ? arguments[0]\n            : {},\n        _ref$tag = _ref.tag,\n        tag = _ref$tag === void 0 ? 'div' : _ref$tag,\n        _ref$name = _ref.name,\n        name = _ref$name === void 0 ? null : _ref$name,\n        _ref$attributes = _ref.attributes,\n        attributes = _ref$attributes === void 0 ? {} : _ref$attributes,\n        _ref$read = _ref.read,\n        read = _ref$read === void 0 ? function() {} : _ref$read,\n        _ref$write = _ref.write,\n        write = _ref$write === void 0 ? function() {} : _ref$write,\n        _ref$create = _ref.create,\n        create = _ref$create === void 0 ? function() {} : _ref$create,\n        _ref$destroy = _ref.destroy,\n        destroy = _ref$destroy === void 0 ? function() {} : _ref$destroy,\n        _ref$filterFrameActio = _ref.filterFrameActionsForChild,\n        filterFrameActionsForChild =\n          _ref$filterFrameActio === void 0\n            ? function(child, actions) {\n                return actions;\n              }\n            : _ref$filterFrameActio,\n        _ref$didCreateView = _ref.didCreateView,\n        didCreateView =\n          _ref$didCreateView === void 0 ? function() {} : _ref$didCreateView,\n        _ref$didWriteView = _ref.didWriteView,\n        didWriteView =\n          _ref$didWriteView === void 0 ? function() {} : _ref$didWriteView,\n        _ref$ignoreRect = _ref.ignoreRect,\n        ignoreRect = _ref$ignoreRect === void 0 ? false : _ref$ignoreRect,\n        _ref$ignoreRectUpdate = _ref.ignoreRectUpdate,\n        ignoreRectUpdate =\n          _ref$ignoreRectUpdate === void 0 ? false : _ref$ignoreRectUpdate,\n        _ref$mixins = _ref.mixins,\n        mixins = _ref$mixins === void 0 ? [] : _ref$mixins;\n      return function(\n        // each view requires reference to store\n        store\n      ) {\n        var props =\n          arguments.length > 1 && arguments[1] !== undefined\n            ? arguments[1]\n            : {};\n        // root element should not be changed\n        var element = createElement(tag, 'filepond--' + name, attributes);\n\n        // style reference should also not be changed\n        var style = window.getComputedStyle(element, null);\n\n        // element rectangle\n        var rect = updateRect();\n        var frameRect = null;\n\n        // rest state\n        var isResting = false;\n\n        // pretty self explanatory\n        var childViews = [];\n\n        // loaded mixins\n        var activeMixins = [];\n\n        // references to created children\n        var ref = {};\n\n        // state used for each instance\n        var state = {};\n\n        // list of writers that will be called to update this view\n        var writers = [\n          write // default writer\n        ];\n\n        var readers = [\n          read // default reader\n        ];\n\n        var destroyers = [\n          destroy // default destroy\n        ];\n\n        // core view methods\n        var getElement = function getElement() {\n          return element;\n        };\n        var getChildViews = function getChildViews() {\n          return childViews.concat();\n        };\n        var getReference = function getReference() {\n          return ref;\n        };\n        var createChildView = function createChildView(store) {\n          return function(view, props) {\n            return view(store, props);\n          };\n        };\n        var getRect = function getRect() {\n          if (frameRect) {\n            return frameRect;\n          }\n          frameRect = getViewRect(rect, childViews, [0, 0], [1, 1]);\n          return frameRect;\n        };\n        var getStyle = function getStyle() {\n          return style;\n        };\n\n        /**\n         * Read data from DOM\n         * @private\n         */\n        var _read = function _read() {\n          frameRect = null;\n\n          // read child views\n          childViews.forEach(function(child) {\n            return child._read();\n          });\n\n          var shouldUpdate = !(ignoreRectUpdate && rect.width && rect.height);\n          if (shouldUpdate) {\n            updateRect(rect, element, style);\n          }\n\n          // readers\n          var api = { root: internalAPI, props: props, rect: rect };\n          readers.forEach(function(reader) {\n            return reader(api);\n          });\n        };\n\n        /**\n         * Write data to DOM\n         * @private\n         */\n        var _write = function _write(ts, frameActions, shouldOptimize) {\n          // if no actions, we assume that the view is resting\n          var resting = frameActions.length === 0;\n\n          // writers\n          writers.forEach(function(writer) {\n            var writerResting = writer({\n              props: props,\n              root: internalAPI,\n              actions: frameActions,\n              timestamp: ts,\n              shouldOptimize: shouldOptimize\n            });\n\n            if (writerResting === false) {\n              resting = false;\n            }\n          });\n\n          // run mixins\n          activeMixins.forEach(function(mixin) {\n            // if one of the mixins is still busy after write operation, we are not resting\n            var mixinResting = mixin.write(ts);\n            if (mixinResting === false) {\n              resting = false;\n            }\n          });\n\n          // updates child views that are currently attached to the DOM\n          childViews\n            .filter(function(child) {\n              return !!child.element.parentNode;\n            })\n            .forEach(function(child) {\n              // if a child view is not resting, we are not resting\n              var childResting = child._write(\n                ts,\n                filterFrameActionsForChild(child, frameActions),\n                shouldOptimize\n              );\n\n              if (!childResting) {\n                resting = false;\n              }\n            });\n\n          // append new elements to DOM and update those\n          childViews\n            //.filter(child => !child.element.parentNode)\n            .forEach(function(child, index) {\n              // skip\n              if (child.element.parentNode) {\n                return;\n              }\n\n              // append to DOM\n              internalAPI.appendChild(child.element, index);\n\n              // call read (need to know the size of these elements)\n              child._read();\n\n              // re-call write\n              child._write(\n                ts,\n                filterFrameActionsForChild(child, frameActions),\n                shouldOptimize\n              );\n\n              // we just added somthing to the dom, no rest\n              resting = false;\n            });\n\n          // update resting state\n          isResting = resting;\n\n          didWriteView({\n            props: props,\n            root: internalAPI,\n            actions: frameActions,\n            timestamp: ts\n          });\n\n          // let parent know if we are resting\n          return resting;\n        };\n\n        var _destroy = function _destroy() {\n          activeMixins.forEach(function(mixin) {\n            return mixin.destroy();\n          });\n          destroyers.forEach(function(destroyer) {\n            destroyer({ root: internalAPI, props: props });\n          });\n          childViews.forEach(function(child) {\n            return child._destroy();\n          });\n        };\n\n        // sharedAPI\n        var sharedAPIDefinition = {\n          element: {\n            get: getElement\n          },\n\n          style: {\n            get: getStyle\n          },\n\n          childViews: {\n            get: getChildViews\n          }\n        };\n\n        // private API definition\n        var internalAPIDefinition = Object.assign({}, sharedAPIDefinition, {\n          rect: {\n            get: getRect\n          },\n\n          // access to custom children references\n          ref: {\n            get: getReference\n          },\n\n          // dom modifiers\n          is: function is(needle) {\n            return name === needle;\n          },\n          appendChild: appendChild(element),\n          createChildView: createChildView(store),\n          linkView: function linkView(view) {\n            childViews.push(view);\n            return view;\n          },\n          unlinkView: function unlinkView(view) {\n            childViews.splice(childViews.indexOf(view), 1);\n          },\n          appendChildView: appendChildView(element, childViews),\n          removeChildView: removeChildView(element, childViews),\n          registerWriter: function registerWriter(writer) {\n            return writers.push(writer);\n          },\n          registerReader: function registerReader(reader) {\n            return readers.push(reader);\n          },\n          registerDestroyer: function registerDestroyer(destroyer) {\n            return destroyers.push(destroyer);\n          },\n          invalidateLayout: function invalidateLayout() {\n            return (element.layoutCalculated = false);\n          },\n\n          // access to data store\n          dispatch: store.dispatch,\n          query: store.query\n        });\n\n        // public view API methods\n        var externalAPIDefinition = {\n          element: {\n            get: getElement\n          },\n\n          childViews: {\n            get: getChildViews\n          },\n\n          rect: {\n            get: getRect\n          },\n\n          resting: {\n            get: function get() {\n              return isResting;\n            }\n          },\n\n          isRectIgnored: function isRectIgnored() {\n            return ignoreRect;\n          },\n          _read: _read,\n          _write: _write,\n          _destroy: _destroy\n        };\n\n        // mixin API methods\n        var mixinAPIDefinition = Object.assign({}, sharedAPIDefinition, {\n          rect: {\n            get: function get() {\n              return rect;\n            }\n          }\n        });\n\n        // add mixin functionality\n        Object.keys(mixins)\n          .sort(function(a, b) {\n            // move styles to the back of the mixin list (so adjustments of other mixins are applied to the props correctly)\n            if (a === 'styles') {\n              return 1;\n            } else if (b === 'styles') {\n              return -1;\n            }\n            return 0;\n          })\n          .forEach(function(key) {\n            var mixinAPI = Mixins[key]({\n              mixinConfig: mixins[key],\n              viewProps: props,\n              viewState: state,\n              viewInternalAPI: internalAPIDefinition,\n              viewExternalAPI: externalAPIDefinition,\n              view: createObject(mixinAPIDefinition)\n            });\n\n            if (mixinAPI) {\n              activeMixins.push(mixinAPI);\n            }\n          });\n\n        // construct private api\n        var internalAPI = createObject(internalAPIDefinition);\n\n        // create the view\n        create({\n          root: internalAPI,\n          props: props\n        });\n\n        // append created child views to root node\n        var childCount = getChildCount(element); // need to know the current child count so appending happens in correct order\n        childViews.forEach(function(child, index) {\n          internalAPI.appendChild(child.element, childCount + index);\n        });\n\n        // call did create\n        didCreateView(internalAPI);\n\n        // expose public api\n        return createObject(externalAPIDefinition);\n      };\n    };\n\n  var createPainter = function createPainter(read, write) {\n    var fps =\n      arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 60;\n\n    var name = '__framePainter';\n\n    // set global painter\n    if (window[name]) {\n      window[name].readers.push(read);\n      window[name].writers.push(write);\n      return;\n    }\n\n    window[name] = {\n      readers: [read],\n      writers: [write]\n    };\n\n    var painter = window[name];\n\n    var interval = 1000 / fps;\n    var last = null;\n    var id = null;\n    var requestTick = null;\n    var cancelTick = null;\n\n    var setTimerType = function setTimerType() {\n      if (document.hidden) {\n        requestTick = function requestTick() {\n          return window.setTimeout(function() {\n            return tick(performance.now());\n          }, interval);\n        };\n        cancelTick = function cancelTick() {\n          return window.clearTimeout(id);\n        };\n      } else {\n        requestTick = function requestTick() {\n          return window.requestAnimationFrame(tick);\n        };\n        cancelTick = function cancelTick() {\n          return window.cancelAnimationFrame(id);\n        };\n      }\n    };\n\n    document.addEventListener('visibilitychange', function() {\n      if (cancelTick) cancelTick();\n      setTimerType();\n      tick(performance.now());\n    });\n\n    var tick = function tick(ts) {\n      // queue next tick\n      id = requestTick(tick);\n\n      // limit fps\n      if (!last) {\n        last = ts;\n      }\n\n      var delta = ts - last;\n\n      if (delta <= interval) {\n        // skip frame\n        return;\n      }\n\n      // align next frame\n      last = ts - (delta % interval);\n\n      // update view\n      painter.readers.forEach(function(read) {\n        return read();\n      });\n      painter.writers.forEach(function(write) {\n        return write(ts);\n      });\n    };\n\n    setTimerType();\n    tick(performance.now());\n\n    return {\n      pause: function pause() {\n        cancelTick(id);\n      }\n    };\n  };\n\n  var createRoute = function createRoute(routes, fn) {\n    return function(_ref) {\n      var root = _ref.root,\n        props = _ref.props,\n        _ref$actions = _ref.actions,\n        actions = _ref$actions === void 0 ? [] : _ref$actions,\n        timestamp = _ref.timestamp,\n        shouldOptimize = _ref.shouldOptimize;\n      actions\n        .filter(function(action) {\n          return routes[action.type];\n        })\n        .forEach(function(action) {\n          return routes[action.type]({\n            root: root,\n            props: props,\n            action: action.data,\n            timestamp: timestamp,\n            shouldOptimize: shouldOptimize\n          });\n        });\n\n      if (fn) {\n        fn({\n          root: root,\n          props: props,\n          actions: actions,\n          timestamp: timestamp,\n          shouldOptimize: shouldOptimize\n        });\n      }\n    };\n  };\n\n  var insertBefore = function insertBefore(newNode, referenceNode) {\n    return referenceNode.parentNode.insertBefore(newNode, referenceNode);\n  };\n\n  var insertAfter = function insertAfter(newNode, referenceNode) {\n    return referenceNode.parentNode.insertBefore(\n      newNode,\n      referenceNode.nextSibling\n    );\n  };\n\n  var isArray = function isArray(value) {\n    return Array.isArray(value);\n  };\n\n  var isEmpty = function isEmpty(value) {\n    return value == null;\n  };\n\n  var trim = function trim(str) {\n    return str.trim();\n  };\n\n  var toString = function toString(value) {\n    return '' + value;\n  };\n\n  var toArray = function toArray(value) {\n    var splitter =\n      arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ',';\n    if (isEmpty(value)) {\n      return [];\n    }\n    if (isArray(value)) {\n      return value;\n    }\n    return toString(value)\n      .split(splitter)\n      .map(trim)\n      .filter(function(str) {\n        return str.length;\n      });\n  };\n\n  var isBoolean = function isBoolean(value) {\n    return typeof value === 'boolean';\n  };\n\n  var toBoolean = function toBoolean(value) {\n    return isBoolean(value) ? value : value === 'true';\n  };\n\n  var isString = function isString(value) {\n    return typeof value === 'string';\n  };\n\n  var toNumber = function toNumber(value) {\n    return isNumber(value)\n      ? value\n      : isString(value)\n      ? toString(value).replace(/[a-z]+/gi, '')\n      : 0;\n  };\n\n  var toInt = function toInt(value) {\n    return parseInt(toNumber(value), 10);\n  };\n\n  var toFloat = function toFloat(value) {\n    return parseFloat(toNumber(value));\n  };\n\n  var isInt = function isInt(value) {\n    return isNumber(value) && isFinite(value) && Math.floor(value) === value;\n  };\n\n  var toBytes = function toBytes(value) {\n    var base =\n      arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;\n    // is in bytes\n    if (isInt(value)) {\n      return value;\n    }\n\n    // is natural file size\n    var naturalFileSize = toString(value).trim();\n\n    // if is value in megabytes\n    if (/MB$/i.test(naturalFileSize)) {\n      naturalFileSize = naturalFileSize.replace(/MB$i/, '').trim();\n      return toInt(naturalFileSize) * base * base;\n    }\n\n    // if is value in kilobytes\n    if (/KB/i.test(naturalFileSize)) {\n      naturalFileSize = naturalFileSize.replace(/KB$i/, '').trim();\n      return toInt(naturalFileSize) * base;\n    }\n\n    return toInt(naturalFileSize);\n  };\n\n  var isFunction = function isFunction(value) {\n    return typeof value === 'function';\n  };\n\n  var toFunctionReference = function toFunctionReference(string) {\n    var ref = self;\n    var levels = string.split('.');\n    var level = null;\n    while ((level = levels.shift())) {\n      ref = ref[level];\n      if (!ref) {\n        return null;\n      }\n    }\n    return ref;\n  };\n\n  var methods = {\n    process: 'POST',\n    patch: 'PATCH',\n    revert: 'DELETE',\n    fetch: 'GET',\n    restore: 'GET',\n    load: 'GET'\n  };\n\n  var createServerAPI = function createServerAPI(outline) {\n    var api = {};\n\n    api.url = isString(outline) ? outline : outline.url || '';\n    api.timeout = outline.timeout ? parseInt(outline.timeout, 10) : 0;\n    api.headers = outline.headers ? outline.headers : {};\n\n    forin(methods, function(key) {\n      api[key] = createAction(\n        key,\n        outline[key],\n        methods[key],\n        api.timeout,\n        api.headers\n      );\n    });\n\n    // special treatment for remove\n    api.remove = outline.remove || null;\n\n    // remove generic headers from api object\n    delete api.headers;\n\n    return api;\n  };\n\n  var createAction = function createAction(\n    name,\n    outline,\n    method,\n    timeout,\n    headers\n  ) {\n    // is explicitely set to null so disable\n    if (outline === null) {\n      return null;\n    }\n\n    // if is custom function, done! Dev handles everything.\n    if (typeof outline === 'function') {\n      return outline;\n    }\n\n    // build action object\n    var action = {\n      url: method === 'GET' || method === 'PATCH' ? '?' + name + '=' : '',\n      method: method,\n      headers: headers,\n      withCredentials: false,\n      timeout: timeout,\n      onload: null,\n      ondata: null,\n      onerror: null\n    };\n\n    // is a single url\n    if (isString(outline)) {\n      action.url = outline;\n      return action;\n    }\n\n    // overwrite\n    Object.assign(action, outline);\n\n    // see if should reformat headers;\n    if (isString(action.headers)) {\n      var parts = action.headers.split(/:(.+)/);\n      action.headers = {\n        header: parts[0],\n        value: parts[1]\n      };\n    }\n\n    // if is bool withCredentials\n    action.withCredentials = toBoolean(action.withCredentials);\n\n    return action;\n  };\n\n  var toServerAPI = function toServerAPI(value) {\n    return createServerAPI(value);\n  };\n\n  var isNull = function isNull(value) {\n    return value === null;\n  };\n\n  var isObject = function isObject(value) {\n    return typeof value === 'object' && value !== null;\n  };\n\n  var isAPI = function isAPI(value) {\n    return (\n      isObject(value) &&\n      isString(value.url) &&\n      isObject(value.process) &&\n      isObject(value.revert) &&\n      isObject(value.restore) &&\n      isObject(value.fetch)\n    );\n  };\n\n  var getType = function getType(value) {\n    if (isArray(value)) {\n      return 'array';\n    }\n\n    if (isNull(value)) {\n      return 'null';\n    }\n\n    if (isInt(value)) {\n      return 'int';\n    }\n\n    if (/^[0-9]+ ?(?:GB|MB|KB)$/gi.test(value)) {\n      return 'bytes';\n    }\n\n    if (isAPI(value)) {\n      return 'api';\n    }\n\n    return typeof value;\n  };\n\n  var replaceSingleQuotes = function replaceSingleQuotes(str) {\n    return str\n      .replace(/{\\s*'/g, '{\"')\n      .replace(/'\\s*}/g, '\"}')\n      .replace(/'\\s*:/g, '\":')\n      .replace(/:\\s*'/g, ':\"')\n      .replace(/,\\s*'/g, ',\"')\n      .replace(/'\\s*,/g, '\",');\n  };\n\n  var conversionTable = {\n    array: toArray,\n    boolean: toBoolean,\n    int: function int(value) {\n      return getType(value) === 'bytes' ? toBytes(value) : toInt(value);\n    },\n    number: toFloat,\n    float: toFloat,\n    bytes: toBytes,\n    string: function string(value) {\n      return isFunction(value) ? value : toString(value);\n    },\n    function: function _function(value) {\n      return toFunctionReference(value);\n    },\n    serverapi: toServerAPI,\n    object: function object(value) {\n      try {\n        return JSON.parse(replaceSingleQuotes(value));\n      } catch (e) {\n        return null;\n      }\n    }\n  };\n\n  var convertTo = function convertTo(value, type) {\n    return conversionTable[type](value);\n  };\n\n  var getValueByType = function getValueByType(\n    newValue,\n    defaultValue,\n    valueType\n  ) {\n    // can always assign default value\n    if (newValue === defaultValue) {\n      return newValue;\n    }\n\n    // get the type of the new value\n    var newValueType = getType(newValue);\n\n    // is valid type?\n    if (newValueType !== valueType) {\n      // is string input, let's attempt to convert\n      var convertedValue = convertTo(newValue, valueType);\n\n      // what is the type now\n      newValueType = getType(convertedValue);\n\n      // no valid conversions found\n      if (convertedValue === null) {\n        throw 'Trying to assign value with incorrect type to \"' +\n          option +\n          '\", allowed type: \"' +\n          valueType +\n          '\"';\n      } else {\n        newValue = convertedValue;\n      }\n    }\n\n    // assign new value\n    return newValue;\n  };\n\n  var createOption = function createOption(defaultValue, valueType) {\n    var currentValue = defaultValue;\n    return {\n      enumerable: true,\n      get: function get() {\n        return currentValue;\n      },\n      set: function set(newValue) {\n        currentValue = getValueByType(newValue, defaultValue, valueType);\n      }\n    };\n  };\n\n  var createOptions = function createOptions(options) {\n    var obj = {};\n    forin(options, function(prop) {\n      var optionDefinition = options[prop];\n      obj[prop] = createOption(optionDefinition[0], optionDefinition[1]);\n    });\n    return createObject(obj);\n  };\n\n  var createInitialState = function createInitialState(options) {\n    return {\n      // model\n      items: [],\n\n      // timeout used for calling update items\n      listUpdateTimeout: null,\n\n      // timeout used for stacking metadata updates\n      itemUpdateTimeout: null,\n\n      // queue of items waiting to be processed\n      processingQueue: [],\n\n      // options\n      options: createOptions(options)\n    };\n  };\n\n  var fromCamels = function fromCamels(string) {\n    var separator =\n      arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '-';\n    return string\n      .split(/(?=[A-Z])/)\n      .map(function(part) {\n        return part.toLowerCase();\n      })\n      .join(separator);\n  };\n\n  var createOptionAPI = function createOptionAPI(store, options) {\n    var obj = {};\n    forin(options, function(key) {\n      obj[key] = {\n        get: function get() {\n          return store.getState().options[key];\n        },\n        set: function set(value) {\n          store.dispatch('SET_' + fromCamels(key, '_').toUpperCase(), {\n            value: value\n          });\n        }\n      };\n    });\n    return obj;\n  };\n\n  var createOptionActions = function createOptionActions(options) {\n    return function(dispatch, query, state) {\n      var obj = {};\n      forin(options, function(key) {\n        var name = fromCamels(key, '_').toUpperCase();\n\n        obj['SET_' + name] = function(action) {\n          try {\n            state.options[key] = action.value;\n          } catch (e) {} // nope, failed\n\n          // we successfully set the value of this option\n          dispatch('DID_SET_' + name, { value: state.options[key] });\n        };\n      });\n      return obj;\n    };\n  };\n\n  var createOptionQueries = function createOptionQueries(options) {\n    return function(state) {\n      var obj = {};\n      forin(options, function(key) {\n        obj['GET_' + fromCamels(key, '_').toUpperCase()] = function(action) {\n          return state.options[key];\n        };\n      });\n      return obj;\n    };\n  };\n\n  var InteractionMethod = {\n    API: 1,\n    DROP: 2,\n    BROWSE: 3,\n    PASTE: 4,\n    NONE: 5\n  };\n\n  var getUniqueId = function getUniqueId() {\n    return Math.random()\n      .toString(36)\n      .substr(2, 9);\n  };\n\n  function _typeof(obj) {\n    if (typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol') {\n      _typeof = function(obj) {\n        return typeof obj;\n      };\n    } else {\n      _typeof = function(obj) {\n        return obj &&\n          typeof Symbol === 'function' &&\n          obj.constructor === Symbol &&\n          obj !== Symbol.prototype\n          ? 'symbol'\n          : typeof obj;\n      };\n    }\n\n    return _typeof(obj);\n  }\n\n  var REACT_ELEMENT_TYPE;\n\n  function _jsx(type, props, key, children) {\n    if (!REACT_ELEMENT_TYPE) {\n      REACT_ELEMENT_TYPE =\n        (typeof Symbol === 'function' &&\n          Symbol['for'] &&\n          Symbol['for']('react.element')) ||\n        0xeac7;\n    }\n\n    var defaultProps = type && type.defaultProps;\n    var childrenLength = arguments.length - 3;\n\n    if (!props && childrenLength !== 0) {\n      props = {\n        children: void 0\n      };\n    }\n\n    if (props && defaultProps) {\n      for (var propName in defaultProps) {\n        if (props[propName] === void 0) {\n          props[propName] = defaultProps[propName];\n        }\n      }\n    } else if (!props) {\n      props = defaultProps || {};\n    }\n\n    if (childrenLength === 1) {\n      props.children = children;\n    } else if (childrenLength > 1) {\n      var childArray = new Array(childrenLength);\n\n      for (var i = 0; i < childrenLength; i++) {\n        childArray[i] = arguments[i + 3];\n      }\n\n      props.children = childArray;\n    }\n\n    return {\n      $$typeof: REACT_ELEMENT_TYPE,\n      type: type,\n      key: key === undefined ? null : '' + key,\n      ref: null,\n      props: props,\n      _owner: null\n    };\n  }\n\n  function _asyncIterator(iterable) {\n    var method;\n\n    if (typeof Symbol !== 'undefined') {\n      if (Symbol.asyncIterator) {\n        method = iterable[Symbol.asyncIterator];\n        if (method != null) return method.call(iterable);\n      }\n\n      if (Symbol.iterator) {\n        method = iterable[Symbol.iterator];\n        if (method != null) return method.call(iterable);\n      }\n    }\n\n    throw new TypeError('Object is not async iterable');\n  }\n\n  function _AwaitValue(value) {\n    this.wrapped = value;\n  }\n\n  function _AsyncGenerator(gen) {\n    var front, back;\n\n    function send(key, arg) {\n      return new Promise(function(resolve, reject) {\n        var request = {\n          key: key,\n          arg: arg,\n          resolve: resolve,\n          reject: reject,\n          next: null\n        };\n\n        if (back) {\n          back = back.next = request;\n        } else {\n          front = back = request;\n          resume(key, arg);\n        }\n      });\n    }\n\n    function resume(key, arg) {\n      try {\n        var result = gen[key](arg);\n        var value = result.value;\n        var wrappedAwait = value instanceof _AwaitValue;\n        Promise.resolve(wrappedAwait ? value.wrapped : value).then(\n          function(arg) {\n            if (wrappedAwait) {\n              resume('next', arg);\n              return;\n            }\n\n            settle(result.done ? 'return' : 'normal', arg);\n          },\n          function(err) {\n            resume('throw', err);\n          }\n        );\n      } catch (err) {\n        settle('throw', err);\n      }\n    }\n\n    function settle(type, value) {\n      switch (type) {\n        case 'return':\n          front.resolve({\n            value: value,\n            done: true\n          });\n          break;\n\n        case 'throw':\n          front.reject(value);\n          break;\n\n        default:\n          front.resolve({\n            value: value,\n            done: false\n          });\n          break;\n      }\n\n      front = front.next;\n\n      if (front) {\n        resume(front.key, front.arg);\n      } else {\n        back = null;\n      }\n    }\n\n    this._invoke = send;\n\n    if (typeof gen.return !== 'function') {\n      this.return = undefined;\n    }\n  }\n\n  if (typeof Symbol === 'function' && Symbol.asyncIterator) {\n    _AsyncGenerator.prototype[Symbol.asyncIterator] = function() {\n      return this;\n    };\n  }\n\n  _AsyncGenerator.prototype.next = function(arg) {\n    return this._invoke('next', arg);\n  };\n\n  _AsyncGenerator.prototype.throw = function(arg) {\n    return this._invoke('throw', arg);\n  };\n\n  _AsyncGenerator.prototype.return = function(arg) {\n    return this._invoke('return', arg);\n  };\n\n  function _wrapAsyncGenerator(fn) {\n    return function() {\n      return new _AsyncGenerator(fn.apply(this, arguments));\n    };\n  }\n\n  function _awaitAsyncGenerator(value) {\n    return new _AwaitValue(value);\n  }\n\n  function _asyncGeneratorDelegate(inner, awaitWrap) {\n    var iter = {},\n      waiting = false;\n\n    function pump(key, value) {\n      waiting = true;\n      value = new Promise(function(resolve) {\n        resolve(inner[key](value));\n      });\n      return {\n        done: false,\n        value: awaitWrap(value)\n      };\n    }\n\n    if (typeof Symbol === 'function' && Symbol.iterator) {\n      iter[Symbol.iterator] = function() {\n        return this;\n      };\n    }\n\n    iter.next = function(value) {\n      if (waiting) {\n        waiting = false;\n        return value;\n      }\n\n      return pump('next', value);\n    };\n\n    if (typeof inner.throw === 'function') {\n      iter.throw = function(value) {\n        if (waiting) {\n          waiting = false;\n          throw value;\n        }\n\n        return pump('throw', value);\n      };\n    }\n\n    if (typeof inner.return === 'function') {\n      iter.return = function(value) {\n        return pump('return', value);\n      };\n    }\n\n    return iter;\n  }\n\n  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n    try {\n      var info = gen[key](arg);\n      var value = info.value;\n    } catch (error) {\n      reject(error);\n      return;\n    }\n\n    if (info.done) {\n      resolve(value);\n    } else {\n      Promise.resolve(value).then(_next, _throw);\n    }\n  }\n\n  function _asyncToGenerator(fn) {\n    return function() {\n      var self = this,\n        args = arguments;\n      return new Promise(function(resolve, reject) {\n        var gen = fn.apply(self, args);\n\n        function _next(value) {\n          asyncGeneratorStep(\n            gen,\n            resolve,\n            reject,\n            _next,\n            _throw,\n            'next',\n            value\n          );\n        }\n\n        function _throw(err) {\n          asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'throw', err);\n        }\n\n        _next(undefined);\n      });\n    };\n  }\n\n  function _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError('Cannot call a class as a function');\n    }\n  }\n\n  function _defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if ('value' in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  function _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n  }\n\n  function _defineEnumerableProperties(obj, descs) {\n    for (var key in descs) {\n      var desc = descs[key];\n      desc.configurable = desc.enumerable = true;\n      if ('value' in desc) desc.writable = true;\n      Object.defineProperty(obj, key, desc);\n    }\n\n    if (Object.getOwnPropertySymbols) {\n      var objectSymbols = Object.getOwnPropertySymbols(descs);\n\n      for (var i = 0; i < objectSymbols.length; i++) {\n        var sym = objectSymbols[i];\n        var desc = descs[sym];\n        desc.configurable = desc.enumerable = true;\n        if ('value' in desc) desc.writable = true;\n        Object.defineProperty(obj, sym, desc);\n      }\n    }\n\n    return obj;\n  }\n\n  function _defaults(obj, defaults) {\n    var keys = Object.getOwnPropertyNames(defaults);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      var value = Object.getOwnPropertyDescriptor(defaults, key);\n\n      if (value && value.configurable && obj[key] === undefined) {\n        Object.defineProperty(obj, key, value);\n      }\n    }\n\n    return obj;\n  }\n\n  function _defineProperty(obj, key, value) {\n    if (key in obj) {\n      Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n    } else {\n      obj[key] = value;\n    }\n\n    return obj;\n  }\n\n  function _extends() {\n    _extends =\n      Object.assign ||\n      function(target) {\n        for (var i = 1; i < arguments.length; i++) {\n          var source = arguments[i];\n\n          for (var key in source) {\n            if (Object.prototype.hasOwnProperty.call(source, key)) {\n              target[key] = source[key];\n            }\n          }\n        }\n\n        return target;\n      };\n\n    return _extends.apply(this, arguments);\n  }\n\n  function _objectSpread(target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i] != null ? arguments[i] : {};\n      var ownKeys = Object.keys(source);\n\n      if (typeof Object.getOwnPropertySymbols === 'function') {\n        ownKeys = ownKeys.concat(\n          Object.getOwnPropertySymbols(source).filter(function(sym) {\n            return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n          })\n        );\n      }\n\n      ownKeys.forEach(function(key) {\n        _defineProperty(target, key, source[key]);\n      });\n    }\n\n    return target;\n  }\n\n  function ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n\n    if (Object.getOwnPropertySymbols) {\n      var symbols = Object.getOwnPropertySymbols(object);\n      if (enumerableOnly)\n        symbols = symbols.filter(function(sym) {\n          return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n        });\n      keys.push.apply(keys, symbols);\n    }\n\n    return keys;\n  }\n\n  function _objectSpread2(target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i] != null ? arguments[i] : {};\n\n      if (i % 2) {\n        ownKeys(source, true).forEach(function(key) {\n          _defineProperty(target, key, source[key]);\n        });\n      } else if (Object.getOwnPropertyDescriptors) {\n        Object.defineProperties(\n          target,\n          Object.getOwnPropertyDescriptors(source)\n        );\n      } else {\n        ownKeys(source).forEach(function(key) {\n          Object.defineProperty(\n            target,\n            key,\n            Object.getOwnPropertyDescriptor(source, key)\n          );\n        });\n      }\n    }\n\n    return target;\n  }\n\n  function _inherits(subClass, superClass) {\n    if (typeof superClass !== 'function' && superClass !== null) {\n      throw new TypeError('Super expression must either be null or a function');\n    }\n\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n      constructor: {\n        value: subClass,\n        writable: true,\n        configurable: true\n      }\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n  }\n\n  function _inheritsLoose(subClass, superClass) {\n    subClass.prototype = Object.create(superClass.prototype);\n    subClass.prototype.constructor = subClass;\n    subClass.__proto__ = superClass;\n  }\n\n  function _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf\n      ? Object.getPrototypeOf\n      : function _getPrototypeOf(o) {\n          return o.__proto__ || Object.getPrototypeOf(o);\n        };\n    return _getPrototypeOf(o);\n  }\n\n  function _setPrototypeOf(o, p) {\n    _setPrototypeOf =\n      Object.setPrototypeOf ||\n      function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n      };\n\n    return _setPrototypeOf(o, p);\n  }\n\n  function isNativeReflectConstruct() {\n    if (typeof Reflect === 'undefined' || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === 'function') return true;\n\n    try {\n      Date.prototype.toString.call(Reflect.construct(Date, [], function() {}));\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  function _construct(Parent, args, Class) {\n    if (isNativeReflectConstruct()) {\n      _construct = Reflect.construct;\n    } else {\n      _construct = function _construct(Parent, args, Class) {\n        var a = [null];\n        a.push.apply(a, args);\n        var Constructor = Function.bind.apply(Parent, a);\n        var instance = new Constructor();\n        if (Class) _setPrototypeOf(instance, Class.prototype);\n        return instance;\n      };\n    }\n\n    return _construct.apply(null, arguments);\n  }\n\n  function _isNativeFunction(fn) {\n    return Function.toString.call(fn).indexOf('[native code]') !== -1;\n  }\n\n  function _wrapNativeSuper(Class) {\n    var _cache = typeof Map === 'function' ? new Map() : undefined;\n\n    _wrapNativeSuper = function _wrapNativeSuper(Class) {\n      if (Class === null || !_isNativeFunction(Class)) return Class;\n\n      if (typeof Class !== 'function') {\n        throw new TypeError(\n          'Super expression must either be null or a function'\n        );\n      }\n\n      if (typeof _cache !== 'undefined') {\n        if (_cache.has(Class)) return _cache.get(Class);\n\n        _cache.set(Class, Wrapper);\n      }\n\n      function Wrapper() {\n        return _construct(Class, arguments, _getPrototypeOf(this).constructor);\n      }\n\n      Wrapper.prototype = Object.create(Class.prototype, {\n        constructor: {\n          value: Wrapper,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      });\n      return _setPrototypeOf(Wrapper, Class);\n    };\n\n    return _wrapNativeSuper(Class);\n  }\n\n  function _instanceof(left, right) {\n    if (\n      right != null &&\n      typeof Symbol !== 'undefined' &&\n      right[Symbol.hasInstance]\n    ) {\n      return !!right[Symbol.hasInstance](left);\n    } else {\n      return left instanceof right;\n    }\n  }\n\n  function _interopRequireDefault(obj) {\n    return obj && obj.__esModule\n      ? obj\n      : {\n          default: obj\n        };\n  }\n\n  function _interopRequireWildcard(obj) {\n    if (obj && obj.__esModule) {\n      return obj;\n    } else {\n      var newObj = {};\n\n      if (obj != null) {\n        for (var key in obj) {\n          if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            var desc =\n              Object.defineProperty && Object.getOwnPropertyDescriptor\n                ? Object.getOwnPropertyDescriptor(obj, key)\n                : {};\n\n            if (desc.get || desc.set) {\n              Object.defineProperty(newObj, key, desc);\n            } else {\n              newObj[key] = obj[key];\n            }\n          }\n        }\n      }\n\n      newObj.default = obj;\n      return newObj;\n    }\n  }\n\n  function _newArrowCheck(innerThis, boundThis) {\n    if (innerThis !== boundThis) {\n      throw new TypeError('Cannot instantiate an arrow function');\n    }\n  }\n\n  function _objectDestructuringEmpty(obj) {\n    if (obj == null) throw new TypeError('Cannot destructure undefined');\n  }\n\n  function _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n\n    for (i = 0; i < sourceKeys.length; i++) {\n      key = sourceKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      target[key] = source[key];\n    }\n\n    return target;\n  }\n\n  function _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n\n    var key, i;\n\n    if (Object.getOwnPropertySymbols) {\n      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n      for (i = 0; i < sourceSymbolKeys.length; i++) {\n        key = sourceSymbolKeys[i];\n        if (excluded.indexOf(key) >= 0) continue;\n        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n        target[key] = source[key];\n      }\n    }\n\n    return target;\n  }\n\n  function _assertThisInitialized(self) {\n    if (self === void 0) {\n      throw new ReferenceError(\n        \"this hasn't been initialised - super() hasn't been called\"\n      );\n    }\n\n    return self;\n  }\n\n  function _possibleConstructorReturn(self, call) {\n    if (call && (typeof call === 'object' || typeof call === 'function')) {\n      return call;\n    }\n\n    return _assertThisInitialized(self);\n  }\n\n  function _superPropBase(object, property) {\n    while (!Object.prototype.hasOwnProperty.call(object, property)) {\n      object = _getPrototypeOf(object);\n      if (object === null) break;\n    }\n\n    return object;\n  }\n\n  function _get(target, property, receiver) {\n    if (typeof Reflect !== 'undefined' && Reflect.get) {\n      _get = Reflect.get;\n    } else {\n      _get = function _get(target, property, receiver) {\n        var base = _superPropBase(target, property);\n\n        if (!base) return;\n        var desc = Object.getOwnPropertyDescriptor(base, property);\n\n        if (desc.get) {\n          return desc.get.call(receiver);\n        }\n\n        return desc.value;\n      };\n    }\n\n    return _get(target, property, receiver || target);\n  }\n\n  function set(target, property, value, receiver) {\n    if (typeof Reflect !== 'undefined' && Reflect.set) {\n      set = Reflect.set;\n    } else {\n      set = function set(target, property, value, receiver) {\n        var base = _superPropBase(target, property);\n\n        var desc;\n\n        if (base) {\n          desc = Object.getOwnPropertyDescriptor(base, property);\n\n          if (desc.set) {\n            desc.set.call(receiver, value);\n            return true;\n          } else if (!desc.writable) {\n            return false;\n          }\n        }\n\n        desc = Object.getOwnPropertyDescriptor(receiver, property);\n\n        if (desc) {\n          if (!desc.writable) {\n            return false;\n          }\n\n          desc.value = value;\n          Object.defineProperty(receiver, property, desc);\n        } else {\n          _defineProperty(receiver, property, value);\n        }\n\n        return true;\n      };\n    }\n\n    return set(target, property, value, receiver);\n  }\n\n  function _set(target, property, value, receiver, isStrict) {\n    var s = set(target, property, value, receiver || target);\n\n    if (!s && isStrict) {\n      throw new Error('failed to set property');\n    }\n\n    return value;\n  }\n\n  function _taggedTemplateLiteral(strings, raw) {\n    if (!raw) {\n      raw = strings.slice(0);\n    }\n\n    return Object.freeze(\n      Object.defineProperties(strings, {\n        raw: {\n          value: Object.freeze(raw)\n        }\n      })\n    );\n  }\n\n  function _taggedTemplateLiteralLoose(strings, raw) {\n    if (!raw) {\n      raw = strings.slice(0);\n    }\n\n    strings.raw = raw;\n    return strings;\n  }\n\n  function _temporalRef(val, name) {\n    if (val === _temporalUndefined) {\n      throw new ReferenceError(name + ' is not defined - temporal dead zone');\n    } else {\n      return val;\n    }\n  }\n\n  function _readOnlyError(name) {\n    throw new Error('\"' + name + '\" is read-only');\n  }\n\n  function _classNameTDZError(name) {\n    throw new Error(\n      'Class \"' + name + '\" cannot be referenced in computed property keys.'\n    );\n  }\n\n  var _temporalUndefined = {};\n\n  function _slicedToArray(arr, i) {\n    return (\n      _arrayWithHoles(arr) ||\n      _iterableToArrayLimit(arr, i) ||\n      _nonIterableRest()\n    );\n  }\n\n  function _slicedToArrayLoose(arr, i) {\n    return (\n      _arrayWithHoles(arr) ||\n      _iterableToArrayLimitLoose(arr, i) ||\n      _nonIterableRest()\n    );\n  }\n\n  function _toArray(arr) {\n    return _arrayWithHoles(arr) || _iterableToArray(arr) || _nonIterableRest();\n  }\n\n  function _toConsumableArray(arr) {\n    return (\n      _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread()\n    );\n  }\n\n  function _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) {\n      for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++)\n        arr2[i] = arr[i];\n\n      return arr2;\n    }\n  }\n\n  function _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n  }\n\n  function _iterableToArray(iter) {\n    if (\n      Symbol.iterator in Object(iter) ||\n      Object.prototype.toString.call(iter) === '[object Arguments]'\n    )\n      return Array.from(iter);\n  }\n\n  function _iterableToArrayLimit(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (\n        var _i = arr[Symbol.iterator](), _s;\n        !(_n = (_s = _i.next()).done);\n        _n = true\n      ) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i['return'] != null) _i['return']();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  function _iterableToArrayLimitLoose(arr, i) {\n    var _arr = [];\n\n    for (\n      var _iterator = arr[Symbol.iterator](), _step;\n      !(_step = _iterator.next()).done;\n\n    ) {\n      _arr.push(_step.value);\n\n      if (i && _arr.length === i) break;\n    }\n\n    return _arr;\n  }\n\n  function _nonIterableSpread() {\n    throw new TypeError('Invalid attempt to spread non-iterable instance');\n  }\n\n  function _nonIterableRest() {\n    throw new TypeError('Invalid attempt to destructure non-iterable instance');\n  }\n\n  function _skipFirstGeneratorNext(fn) {\n    return function() {\n      var it = fn.apply(this, arguments);\n      it.next();\n      return it;\n    };\n  }\n\n  function _toPrimitive(input, hint) {\n    if (typeof input !== 'object' || input === null) return input;\n    var prim = input[Symbol.toPrimitive];\n\n    if (prim !== undefined) {\n      var res = prim.call(input, hint || 'default');\n      if (typeof res !== 'object') return res;\n      throw new TypeError('@@toPrimitive must return a primitive value.');\n    }\n\n    return (hint === 'string' ? String : Number)(input);\n  }\n\n  function _toPropertyKey(arg) {\n    var key = _toPrimitive(arg, 'string');\n\n    return typeof key === 'symbol' ? key : String(key);\n  }\n\n  function _initializerWarningHelper(descriptor, context) {\n    throw new Error(\n      'Decorating class property failed. Please ensure that ' +\n        'proposal-class-properties is enabled and set to use loose mode. ' +\n        'To use proposal-class-properties in spec mode with decorators, wait for ' +\n        'the next major version of decorators in stage 2.'\n    );\n  }\n\n  function _initializerDefineProperty(target, property, descriptor, context) {\n    if (!descriptor) return;\n    Object.defineProperty(target, property, {\n      enumerable: descriptor.enumerable,\n      configurable: descriptor.configurable,\n      writable: descriptor.writable,\n      value: descriptor.initializer\n        ? descriptor.initializer.call(context)\n        : void 0\n    });\n  }\n\n  function _applyDecoratedDescriptor(\n    target,\n    property,\n    decorators,\n    descriptor,\n    context\n  ) {\n    var desc = {};\n    Object.keys(descriptor).forEach(function(key) {\n      desc[key] = descriptor[key];\n    });\n    desc.enumerable = !!desc.enumerable;\n    desc.configurable = !!desc.configurable;\n\n    if ('value' in desc || desc.initializer) {\n      desc.writable = true;\n    }\n\n    desc = decorators\n      .slice()\n      .reverse()\n      .reduce(function(desc, decorator) {\n        return decorator(target, property, desc) || desc;\n      }, desc);\n\n    if (context && desc.initializer !== void 0) {\n      desc.value = desc.initializer ? desc.initializer.call(context) : void 0;\n      desc.initializer = undefined;\n    }\n\n    if (desc.initializer === void 0) {\n      Object.defineProperty(target, property, desc);\n      desc = null;\n    }\n\n    return desc;\n  }\n\n  var id = 0;\n\n  function _classPrivateFieldLooseKey(name) {\n    return '__private_' + id++ + '_' + name;\n  }\n\n  function _classPrivateFieldLooseBase(receiver, privateKey) {\n    if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {\n      throw new TypeError('attempted to use private field on non-instance');\n    }\n\n    return receiver;\n  }\n\n  function _classPrivateFieldGet(receiver, privateMap) {\n    var descriptor = privateMap.get(receiver);\n\n    if (!descriptor) {\n      throw new TypeError('attempted to get private field on non-instance');\n    }\n\n    if (descriptor.get) {\n      return descriptor.get.call(receiver);\n    }\n\n    return descriptor.value;\n  }\n\n  function _classPrivateFieldSet(receiver, privateMap, value) {\n    var descriptor = privateMap.get(receiver);\n\n    if (!descriptor) {\n      throw new TypeError('attempted to set private field on non-instance');\n    }\n\n    if (descriptor.set) {\n      descriptor.set.call(receiver, value);\n    } else {\n      if (!descriptor.writable) {\n        throw new TypeError('attempted to set read only private field');\n      }\n\n      descriptor.value = value;\n    }\n\n    return value;\n  }\n\n  function _classPrivateFieldDestructureSet(receiver, privateMap) {\n    if (!privateMap.has(receiver)) {\n      throw new TypeError('attempted to set private field on non-instance');\n    }\n\n    var descriptor = privateMap.get(receiver);\n\n    if (descriptor.set) {\n      if (!('__destrObj' in descriptor)) {\n        descriptor.__destrObj = {\n          set value(v) {\n            descriptor.set.call(receiver, v);\n          }\n        };\n      }\n\n      return descriptor.__destrObj;\n    } else {\n      if (!descriptor.writable) {\n        throw new TypeError('attempted to set read only private field');\n      }\n\n      return descriptor;\n    }\n  }\n\n  function _classStaticPrivateFieldSpecGet(\n    receiver,\n    classConstructor,\n    descriptor\n  ) {\n    if (receiver !== classConstructor) {\n      throw new TypeError('Private static access of wrong provenance');\n    }\n\n    return descriptor.value;\n  }\n\n  function _classStaticPrivateFieldSpecSet(\n    receiver,\n    classConstructor,\n    descriptor,\n    value\n  ) {\n    if (receiver !== classConstructor) {\n      throw new TypeError('Private static access of wrong provenance');\n    }\n\n    if (!descriptor.writable) {\n      throw new TypeError('attempted to set read only private field');\n    }\n\n    descriptor.value = value;\n    return value;\n  }\n\n  function _classStaticPrivateMethodGet(receiver, classConstructor, method) {\n    if (receiver !== classConstructor) {\n      throw new TypeError('Private static access of wrong provenance');\n    }\n\n    return method;\n  }\n\n  function _classStaticPrivateMethodSet() {\n    throw new TypeError('attempted to set read only static private field');\n  }\n\n  function _decorate(decorators, factory, superClass, mixins) {\n    var api = _getDecoratorsApi();\n\n    if (mixins) {\n      for (var i = 0; i < mixins.length; i++) {\n        api = mixins[i](api);\n      }\n    }\n\n    var r = factory(function initialize(O) {\n      api.initializeInstanceElements(O, decorated.elements);\n    }, superClass);\n    var decorated = api.decorateClass(\n      _coalesceClassElements(r.d.map(_createElementDescriptor)),\n      decorators\n    );\n    api.initializeClassElements(r.F, decorated.elements);\n    return api.runClassFinishers(r.F, decorated.finishers);\n  }\n\n  function _getDecoratorsApi() {\n    _getDecoratorsApi = function() {\n      return api;\n    };\n\n    var api = {\n      elementsDefinitionOrder: [['method'], ['field']],\n      initializeInstanceElements: function(O, elements) {\n        ['method', 'field'].forEach(function(kind) {\n          elements.forEach(function(element) {\n            if (element.kind === kind && element.placement === 'own') {\n              this.defineClassElement(O, element);\n            }\n          }, this);\n        }, this);\n      },\n      initializeClassElements: function(F, elements) {\n        var proto = F.prototype;\n        ['method', 'field'].forEach(function(kind) {\n          elements.forEach(function(element) {\n            var placement = element.placement;\n\n            if (\n              element.kind === kind &&\n              (placement === 'static' || placement === 'prototype')\n            ) {\n              var receiver = placement === 'static' ? F : proto;\n              this.defineClassElement(receiver, element);\n            }\n          }, this);\n        }, this);\n      },\n      defineClassElement: function(receiver, element) {\n        var descriptor = element.descriptor;\n\n        if (element.kind === 'field') {\n          var initializer = element.initializer;\n          descriptor = {\n            enumerable: descriptor.enumerable,\n            writable: descriptor.writable,\n            configurable: descriptor.configurable,\n            value: initializer === void 0 ? void 0 : initializer.call(receiver)\n          };\n        }\n\n        Object.defineProperty(receiver, element.key, descriptor);\n      },\n      decorateClass: function(elements, decorators) {\n        var newElements = [];\n        var finishers = [];\n        var placements = {\n          static: [],\n          prototype: [],\n          own: []\n        };\n        elements.forEach(function(element) {\n          this.addElementPlacement(element, placements);\n        }, this);\n        elements.forEach(function(element) {\n          if (!_hasDecorators(element)) return newElements.push(element);\n          var elementFinishersExtras = this.decorateElement(\n            element,\n            placements\n          );\n          newElements.push(elementFinishersExtras.element);\n          newElements.push.apply(newElements, elementFinishersExtras.extras);\n          finishers.push.apply(finishers, elementFinishersExtras.finishers);\n        }, this);\n\n        if (!decorators) {\n          return {\n            elements: newElements,\n            finishers: finishers\n          };\n        }\n\n        var result = this.decorateConstructor(newElements, decorators);\n        finishers.push.apply(finishers, result.finishers);\n        result.finishers = finishers;\n        return result;\n      },\n      addElementPlacement: function(element, placements, silent) {\n        var keys = placements[element.placement];\n\n        if (!silent && keys.indexOf(element.key) !== -1) {\n          throw new TypeError('Duplicated element (' + element.key + ')');\n        }\n\n        keys.push(element.key);\n      },\n      decorateElement: function(element, placements) {\n        var extras = [];\n        var finishers = [];\n\n        for (\n          var decorators = element.decorators, i = decorators.length - 1;\n          i >= 0;\n          i--\n        ) {\n          var keys = placements[element.placement];\n          keys.splice(keys.indexOf(element.key), 1);\n          var elementObject = this.fromElementDescriptor(element);\n          var elementFinisherExtras = this.toElementFinisherExtras(\n            (0, decorators[i])(elementObject) || elementObject\n          );\n          element = elementFinisherExtras.element;\n          this.addElementPlacement(element, placements);\n\n          if (elementFinisherExtras.finisher) {\n            finishers.push(elementFinisherExtras.finisher);\n          }\n\n          var newExtras = elementFinisherExtras.extras;\n\n          if (newExtras) {\n            for (var j = 0; j < newExtras.length; j++) {\n              this.addElementPlacement(newExtras[j], placements);\n            }\n\n            extras.push.apply(extras, newExtras);\n          }\n        }\n\n        return {\n          element: element,\n          finishers: finishers,\n          extras: extras\n        };\n      },\n      decorateConstructor: function(elements, decorators) {\n        var finishers = [];\n\n        for (var i = decorators.length - 1; i >= 0; i--) {\n          var obj = this.fromClassDescriptor(elements);\n          var elementsAndFinisher = this.toClassDescriptor(\n            (0, decorators[i])(obj) || obj\n          );\n\n          if (elementsAndFinisher.finisher !== undefined) {\n            finishers.push(elementsAndFinisher.finisher);\n          }\n\n          if (elementsAndFinisher.elements !== undefined) {\n            elements = elementsAndFinisher.elements;\n\n            for (var j = 0; j < elements.length - 1; j++) {\n              for (var k = j + 1; k < elements.length; k++) {\n                if (\n                  elements[j].key === elements[k].key &&\n                  elements[j].placement === elements[k].placement\n                ) {\n                  throw new TypeError(\n                    'Duplicated element (' + elements[j].key + ')'\n                  );\n                }\n              }\n            }\n          }\n        }\n\n        return {\n          elements: elements,\n          finishers: finishers\n        };\n      },\n      fromElementDescriptor: function(element) {\n        var obj = {\n          kind: element.kind,\n          key: element.key,\n          placement: element.placement,\n          descriptor: element.descriptor\n        };\n        var desc = {\n          value: 'Descriptor',\n          configurable: true\n        };\n        Object.defineProperty(obj, Symbol.toStringTag, desc);\n        if (element.kind === 'field') obj.initializer = element.initializer;\n        return obj;\n      },\n      toElementDescriptors: function(elementObjects) {\n        if (elementObjects === undefined) return;\n        return _toArray(elementObjects).map(function(elementObject) {\n          var element = this.toElementDescriptor(elementObject);\n          this.disallowProperty(\n            elementObject,\n            'finisher',\n            'An element descriptor'\n          );\n          this.disallowProperty(\n            elementObject,\n            'extras',\n            'An element descriptor'\n          );\n          return element;\n        }, this);\n      },\n      toElementDescriptor: function(elementObject) {\n        var kind = String(elementObject.kind);\n\n        if (kind !== 'method' && kind !== 'field') {\n          throw new TypeError(\n            'An element descriptor\\'s .kind property must be either \"method\" or' +\n              ' \"field\", but a decorator created an element descriptor with' +\n              ' .kind \"' +\n              kind +\n              '\"'\n          );\n        }\n\n        var key = _toPropertyKey(elementObject.key);\n\n        var placement = String(elementObject.placement);\n\n        if (\n          placement !== 'static' &&\n          placement !== 'prototype' &&\n          placement !== 'own'\n        ) {\n          throw new TypeError(\n            'An element descriptor\\'s .placement property must be one of \"static\",' +\n              ' \"prototype\" or \"own\", but a decorator created an element descriptor' +\n              ' with .placement \"' +\n              placement +\n              '\"'\n          );\n        }\n\n        var descriptor = elementObject.descriptor;\n        this.disallowProperty(\n          elementObject,\n          'elements',\n          'An element descriptor'\n        );\n        var element = {\n          kind: kind,\n          key: key,\n          placement: placement,\n          descriptor: Object.assign({}, descriptor)\n        };\n\n        if (kind !== 'field') {\n          this.disallowProperty(\n            elementObject,\n            'initializer',\n            'A method descriptor'\n          );\n        } else {\n          this.disallowProperty(\n            descriptor,\n            'get',\n            'The property descriptor of a field descriptor'\n          );\n          this.disallowProperty(\n            descriptor,\n            'set',\n            'The property descriptor of a field descriptor'\n          );\n          this.disallowProperty(\n            descriptor,\n            'value',\n            'The property descriptor of a field descriptor'\n          );\n          element.initializer = elementObject.initializer;\n        }\n\n        return element;\n      },\n      toElementFinisherExtras: function(elementObject) {\n        var element = this.toElementDescriptor(elementObject);\n\n        var finisher = _optionalCallableProperty(elementObject, 'finisher');\n\n        var extras = this.toElementDescriptors(elementObject.extras);\n        return {\n          element: element,\n          finisher: finisher,\n          extras: extras\n        };\n      },\n      fromClassDescriptor: function(elements) {\n        var obj = {\n          kind: 'class',\n          elements: elements.map(this.fromElementDescriptor, this)\n        };\n        var desc = {\n          value: 'Descriptor',\n          configurable: true\n        };\n        Object.defineProperty(obj, Symbol.toStringTag, desc);\n        return obj;\n      },\n      toClassDescriptor: function(obj) {\n        var kind = String(obj.kind);\n\n        if (kind !== 'class') {\n          throw new TypeError(\n            'A class descriptor\\'s .kind property must be \"class\", but a decorator' +\n              ' created a class descriptor with .kind \"' +\n              kind +\n              '\"'\n          );\n        }\n\n        this.disallowProperty(obj, 'key', 'A class descriptor');\n        this.disallowProperty(obj, 'placement', 'A class descriptor');\n        this.disallowProperty(obj, 'descriptor', 'A class descriptor');\n        this.disallowProperty(obj, 'initializer', 'A class descriptor');\n        this.disallowProperty(obj, 'extras', 'A class descriptor');\n\n        var finisher = _optionalCallableProperty(obj, 'finisher');\n\n        var elements = this.toElementDescriptors(obj.elements);\n        return {\n          elements: elements,\n          finisher: finisher\n        };\n      },\n      runClassFinishers: function(constructor, finishers) {\n        for (var i = 0; i < finishers.length; i++) {\n          var newConstructor = (0, finishers[i])(constructor);\n\n          if (newConstructor !== undefined) {\n            if (typeof newConstructor !== 'function') {\n              throw new TypeError('Finishers must return a constructor.');\n            }\n\n            constructor = newConstructor;\n          }\n        }\n\n        return constructor;\n      },\n      disallowProperty: function(obj, name, objectType) {\n        if (obj[name] !== undefined) {\n          throw new TypeError(\n            objectType + \" can't have a .\" + name + ' property.'\n          );\n        }\n      }\n    };\n    return api;\n  }\n\n  function _createElementDescriptor(def) {\n    var key = _toPropertyKey(def.key);\n\n    var descriptor;\n\n    if (def.kind === 'method') {\n      descriptor = {\n        value: def.value,\n        writable: true,\n        configurable: true,\n        enumerable: false\n      };\n    } else if (def.kind === 'get') {\n      descriptor = {\n        get: def.value,\n        configurable: true,\n        enumerable: false\n      };\n    } else if (def.kind === 'set') {\n      descriptor = {\n        set: def.value,\n        configurable: true,\n        enumerable: false\n      };\n    } else if (def.kind === 'field') {\n      descriptor = {\n        configurable: true,\n        writable: true,\n        enumerable: true\n      };\n    }\n\n    var element = {\n      kind: def.kind === 'field' ? 'field' : 'method',\n      key: key,\n      placement: def.static\n        ? 'static'\n        : def.kind === 'field'\n        ? 'own'\n        : 'prototype',\n      descriptor: descriptor\n    };\n    if (def.decorators) element.decorators = def.decorators;\n    if (def.kind === 'field') element.initializer = def.value;\n    return element;\n  }\n\n  function _coalesceGetterSetter(element, other) {\n    if (element.descriptor.get !== undefined) {\n      other.descriptor.get = element.descriptor.get;\n    } else {\n      other.descriptor.set = element.descriptor.set;\n    }\n  }\n\n  function _coalesceClassElements(elements) {\n    var newElements = [];\n\n    var isSameElement = function(other) {\n      return (\n        other.kind === 'method' &&\n        other.key === element.key &&\n        other.placement === element.placement\n      );\n    };\n\n    for (var i = 0; i < elements.length; i++) {\n      var element = elements[i];\n      var other;\n\n      if (\n        element.kind === 'method' &&\n        (other = newElements.find(isSameElement))\n      ) {\n        if (\n          _isDataDescriptor(element.descriptor) ||\n          _isDataDescriptor(other.descriptor)\n        ) {\n          if (_hasDecorators(element) || _hasDecorators(other)) {\n            throw new ReferenceError(\n              'Duplicated methods (' + element.key + \") can't be decorated.\"\n            );\n          }\n\n          other.descriptor = element.descriptor;\n        } else {\n          if (_hasDecorators(element)) {\n            if (_hasDecorators(other)) {\n              throw new ReferenceError(\n                \"Decorators can't be placed on different accessors with for \" +\n                  'the same property (' +\n                  element.key +\n                  ').'\n              );\n            }\n\n            other.decorators = element.decorators;\n          }\n\n          _coalesceGetterSetter(element, other);\n        }\n      } else {\n        newElements.push(element);\n      }\n    }\n\n    return newElements;\n  }\n\n  function _hasDecorators(element) {\n    return element.decorators && element.decorators.length;\n  }\n\n  function _isDataDescriptor(desc) {\n    return (\n      desc !== undefined &&\n      !(desc.value === undefined && desc.writable === undefined)\n    );\n  }\n\n  function _optionalCallableProperty(obj, name) {\n    var value = obj[name];\n\n    if (value !== undefined && typeof value !== 'function') {\n      throw new TypeError(\"Expected '\" + name + \"' to be a function\");\n    }\n\n    return value;\n  }\n\n  function _classPrivateMethodGet(receiver, privateSet, fn) {\n    if (!privateSet.has(receiver)) {\n      throw new TypeError('attempted to get private field on non-instance');\n    }\n\n    return fn;\n  }\n\n  function _classPrivateMethodSet() {\n    throw new TypeError('attempted to reassign private method');\n  }\n\n  function _wrapRegExp(re, groups) {\n    _wrapRegExp = function(re, groups) {\n      return new BabelRegExp(re, groups);\n    };\n\n    var _RegExp = _wrapNativeSuper(RegExp);\n\n    var _super = RegExp.prototype;\n\n    var _groups = new WeakMap();\n\n    function BabelRegExp(re, groups) {\n      var _this = _RegExp.call(this, re);\n\n      _groups.set(_this, groups);\n\n      return _this;\n    }\n\n    _inherits(BabelRegExp, _RegExp);\n\n    BabelRegExp.prototype.exec = function(str) {\n      var result = _super.exec.call(this, str);\n\n      if (result) result.groups = buildGroups(result, this);\n      return result;\n    };\n\n    BabelRegExp.prototype[Symbol.replace] = function(str, substitution) {\n      if (typeof substitution === 'string') {\n        var groups = _groups.get(this);\n\n        return _super[Symbol.replace].call(\n          this,\n          str,\n          substitution.replace(/\\$<([^>]+)>/g, function(_, name) {\n            return '$' + groups[name];\n          })\n        );\n      } else if (typeof substitution === 'function') {\n        var _this = this;\n\n        return _super[Symbol.replace].call(this, str, function() {\n          var args = [];\n          args.push.apply(args, arguments);\n\n          if (typeof args[args.length - 1] !== 'object') {\n            args.push(buildGroups(args, _this));\n          }\n\n          return substitution.apply(this, args);\n        });\n      } else {\n        return _super[Symbol.replace].call(this, str, substitution);\n      }\n    };\n\n    function buildGroups(result, re) {\n      var g = _groups.get(re);\n\n      return Object.keys(g).reduce(function(groups, name) {\n        groups[name] = result[g[name]];\n        return groups;\n      }, Object.create(null));\n    }\n\n    return _wrapRegExp.apply(this, arguments);\n  }\n\n  var arrayRemove = function arrayRemove(arr, index) {\n    return arr.splice(index, 1);\n  };\n\n  var run = function run(cb, sync) {\n    if (sync) {\n      cb();\n    } else if (document.hidden) {\n      Promise.resolve(1).then(cb);\n    } else {\n      setTimeout(cb, 0);\n    }\n  };\n\n  var on = function on() {\n    var listeners = [];\n    var off = function off(event, cb) {\n      arrayRemove(\n        listeners,\n        listeners.findIndex(function(listener) {\n          return listener.event === event && (listener.cb === cb || !cb);\n        })\n      );\n    };\n    var _fire = function fire(event, args, sync) {\n      listeners\n        .filter(function(listener) {\n          return listener.event === event;\n        })\n        .map(function(listener) {\n          return listener.cb;\n        })\n        .forEach(function(cb) {\n          return run(function() {\n            return cb.apply(void 0, _toConsumableArray(args));\n          }, sync);\n        });\n    };\n    return {\n      fireSync: function fireSync(event) {\n        for (\n          var _len = arguments.length,\n            args = new Array(_len > 1 ? _len - 1 : 0),\n            _key = 1;\n          _key < _len;\n          _key++\n        ) {\n          args[_key - 1] = arguments[_key];\n        }\n        _fire(event, args, true);\n      },\n      fire: function fire(event) {\n        for (\n          var _len2 = arguments.length,\n            args = new Array(_len2 > 1 ? _len2 - 1 : 0),\n            _key2 = 1;\n          _key2 < _len2;\n          _key2++\n        ) {\n          args[_key2 - 1] = arguments[_key2];\n        }\n        _fire(event, args, false);\n      },\n      on: function on(event, cb) {\n        listeners.push({ event: event, cb: cb });\n      },\n      onOnce: function onOnce(event, _cb) {\n        listeners.push({\n          event: event,\n          cb: function cb() {\n            off(event, _cb);\n            _cb.apply(void 0, arguments);\n          }\n        });\n      },\n      off: off\n    };\n  };\n\n  var copyObjectPropertiesToObject = function copyObjectPropertiesToObject(\n    src,\n    target,\n    excluded\n  ) {\n    Object.getOwnPropertyNames(src)\n      .filter(function(property) {\n        return !excluded.includes(property);\n      })\n      .forEach(function(key) {\n        return Object.defineProperty(\n          target,\n          key,\n          Object.getOwnPropertyDescriptor(src, key)\n        );\n      });\n  };\n\n  var PRIVATE = [\n    'fire',\n    'process',\n    'revert',\n    'load',\n    'on',\n    'off',\n    'onOnce',\n    'retryLoad',\n    'extend',\n    'archive',\n    'archived',\n    'release',\n    'released',\n    'requestProcessing',\n    'freeze'\n  ];\n\n  var createItemAPI = function createItemAPI(item) {\n    var api = {};\n    copyObjectPropertiesToObject(item, api, PRIVATE);\n    return api;\n  };\n\n  var removeReleasedItems = function removeReleasedItems(items) {\n    items.forEach(function(item, index) {\n      if (item.released) {\n        arrayRemove(items, index);\n      }\n    });\n  };\n\n  var ItemStatus = {\n    INIT: 1,\n    IDLE: 2,\n    PROCESSING_QUEUED: 9,\n    PROCESSING: 3,\n    PROCESSING_COMPLETE: 5,\n    PROCESSING_ERROR: 6,\n    PROCESSING_REVERT_ERROR: 10,\n    LOADING: 7,\n    LOAD_ERROR: 8\n  };\n\n  var FileOrigin = {\n    INPUT: 1,\n    LIMBO: 2,\n    LOCAL: 3\n  };\n\n  var getNonNumeric = function getNonNumeric(str) {\n    return /[^0-9]+/.exec(str);\n  };\n\n  var getDecimalSeparator = function getDecimalSeparator() {\n    return getNonNumeric((1.1).toLocaleString())[0];\n  };\n\n  var getThousandsSeparator = function getThousandsSeparator() {\n    // Added for browsers that do not return the thousands separator (happend on native browser Android 4.4.4)\n    // We check against the normal toString output and if they're the same return a comma when decimal separator is a dot\n    var decimalSeparator = getDecimalSeparator();\n    var thousandsStringWithSeparator = (1000.0).toLocaleString();\n    var thousandsStringWithoutSeparator = (1000.0).toString();\n    if (thousandsStringWithSeparator !== thousandsStringWithoutSeparator) {\n      return getNonNumeric(thousandsStringWithSeparator)[0];\n    }\n    return decimalSeparator === '.' ? ',' : '.';\n  };\n\n  var Type = {\n    BOOLEAN: 'boolean',\n    INT: 'int',\n    NUMBER: 'number',\n    STRING: 'string',\n    ARRAY: 'array',\n    OBJECT: 'object',\n    FUNCTION: 'function',\n    ACTION: 'action',\n    SERVER_API: 'serverapi',\n    REGEX: 'regex'\n  };\n\n  // all registered filters\n  var filters = [];\n\n  // loops over matching filters and passes options to each filter, returning the mapped results\n  var applyFilterChain = function applyFilterChain(key, value, utils) {\n    return new Promise(function(resolve, reject) {\n      // find matching filters for this key\n      var matchingFilters = filters\n        .filter(function(f) {\n          return f.key === key;\n        })\n        .map(function(f) {\n          return f.cb;\n        });\n\n      // resolve now\n      if (matchingFilters.length === 0) {\n        resolve(value);\n        return;\n      }\n\n      // first filter to kick things of\n      var initialFilter = matchingFilters.shift();\n\n      // chain filters\n      matchingFilters\n        .reduce(\n          // loop over promises passing value to next promise\n          function(current, next) {\n            return current.then(function(value) {\n              return next(value, utils);\n            });\n          },\n\n          // call initial filter, will return a promise\n          initialFilter(value, utils)\n\n          // all executed\n        )\n        .then(function(value) {\n          return resolve(value);\n        })\n        .catch(function(error) {\n          return reject(error);\n        });\n    });\n  };\n\n  var applyFilters = function applyFilters(key, value, utils) {\n    return filters\n      .filter(function(f) {\n        return f.key === key;\n      })\n      .map(function(f) {\n        return f.cb(value, utils);\n      });\n  };\n\n  // adds a new filter to the list\n  var addFilter = function addFilter(key, cb) {\n    return filters.push({ key: key, cb: cb });\n  };\n\n  var extendDefaultOptions = function extendDefaultOptions(additionalOptions) {\n    return Object.assign(defaultOptions, additionalOptions);\n  };\n\n  var getOptions = function getOptions() {\n    return Object.assign({}, defaultOptions);\n  };\n\n  var setOptions = function setOptions(opts) {\n    forin(opts, function(key, value) {\n      // key does not exist, so this option cannot be set\n      if (!defaultOptions[key]) {\n        return;\n      }\n      defaultOptions[key][0] = getValueByType(\n        value,\n        defaultOptions[key][0],\n        defaultOptions[key][1]\n      );\n    });\n  };\n\n  // default options on app\n  var defaultOptions = {\n    // the id to add to the root element\n    id: [null, Type.STRING],\n\n    // input field name to use\n    name: ['filepond', Type.STRING],\n\n    // disable the field\n    disabled: [false, Type.BOOLEAN],\n\n    // classname to put on wrapper\n    className: [null, Type.STRING],\n\n    // is the field required\n    required: [false, Type.BOOLEAN],\n\n    // Allow media capture when value is set\n    captureMethod: [null, Type.STRING],\n    // - \"camera\", \"microphone\" or \"camcorder\",\n    // - Does not work with multiple on apple devices\n    // - If set, acceptedFileTypes must be made to match with media wildcard \"image/*\", \"audio/*\" or \"video/*\"\n\n    // sync `acceptedFileTypes` property with `accept` attribute\n    allowSyncAcceptAttribute: [true, Type.BOOLEAN],\n\n    // Feature toggles\n    allowDrop: [true, Type.BOOLEAN], // Allow dropping of files\n    allowBrowse: [true, Type.BOOLEAN], // Allow browsing the file system\n    allowPaste: [true, Type.BOOLEAN], // Allow pasting files\n    allowMultiple: [false, Type.BOOLEAN], // Allow multiple files (disabled by default, as multiple attribute is also required on input to allow multiple)\n    allowReplace: [true, Type.BOOLEAN], // Allow dropping a file on other file to replace it (only works when multiple is set to false)\n    allowRevert: [true, Type.BOOLEAN], // Allows user to revert file upload\n    allowRemove: [true, Type.BOOLEAN], // Allow user to remove a file\n    allowProcess: [true, Type.BOOLEAN], // Allows user to process a file, when set to false, this removes the file upload button\n    allowReorder: [false, Type.BOOLEAN], // Allow reordering of files\n    allowDirectoriesOnly: [false, Type.BOOLEAN], // Allow only selecting directories with browse (no support for filtering dnd at this point)\n\n    // Revert mode\n    forceRevert: [false, Type.BOOLEAN], // Set to 'force' to require the file to be reverted before removal\n\n    // Input requirements\n    maxFiles: [null, Type.INT], // Max number of files\n    checkValidity: [false, Type.BOOLEAN], // Enables custom validity messages\n\n    // Where to put file\n    itemInsertLocationFreedom: [true, Type.BOOLEAN], // Set to false to always add items to begin or end of list\n    itemInsertLocation: ['before', Type.STRING], // Default index in list to add items that have been dropped at the top of the list\n    itemInsertInterval: [75, Type.INT],\n\n    // Drag 'n Drop related\n    dropOnPage: [false, Type.BOOLEAN], // Allow dropping of files anywhere on page (prevents browser from opening file if dropped outside of Up)\n    dropOnElement: [true, Type.BOOLEAN], // Drop needs to happen on element (set to false to also load drops outside of Up)\n    dropValidation: [false, Type.BOOLEAN], // Enable or disable validating files on drop\n    ignoredFiles: [['.ds_store', 'thumbs.db', 'desktop.ini'], Type.ARRAY],\n\n    // Upload related\n    instantUpload: [true, Type.BOOLEAN], // Should upload files immediately on drop\n    maxParallelUploads: [2, Type.INT], // Maximum files to upload in parallel\n\n    // Chunks\n    chunkUploads: [false, Type.BOOLEAN], // Enable chunked uploads\n    chunkForce: [false, Type.BOOLEAN], // Force use of chunk uploads even for files smaller than chunk size\n    chunkSize: [5000000, Type.INT], // Size of chunks (5MB default)\n    chunkRetryDelays: [[500, 1000, 3000], Type.Array], // Amount of times to retry upload of a chunk when it fails\n\n    // The server api end points to use for uploading (see docs)\n    server: [null, Type.SERVER_API],\n\n    // File size calculations, can set to 1024, this is only used for display, properties use file size base 1000\n    fileSizeBase: [1000, Type.INT],\n\n    // Labels and status messages\n    labelDecimalSeparator: [getDecimalSeparator(), Type.STRING], // Default is locale separator\n    labelThousandsSeparator: [getThousandsSeparator(), Type.STRING], // Default is locale separator\n\n    labelIdle: [\n      'Drag & Drop your files or <span class=\"filepond--label-action\">Browse</span>',\n      Type.STRING\n    ],\n    labelInvalidField: ['Field contains invalid files', Type.STRING],\n    labelFileWaitingForSize: ['Waiting for size', Type.STRING],\n    labelFileSizeNotAvailable: ['Size not available', Type.STRING],\n    labelFileCountSingular: ['file in list', Type.STRING],\n    labelFileCountPlural: ['files in list', Type.STRING],\n    labelFileLoading: ['Loading', Type.STRING],\n    labelFileAdded: ['Added', Type.STRING], // assistive only\n    labelFileLoadError: ['Error during load', Type.STRING],\n    labelFileRemoved: ['Removed', Type.STRING], // assistive only\n    labelFileRemoveError: ['Error during remove', Type.STRING],\n    labelFileProcessing: ['Uploading', Type.STRING],\n    labelFileProcessingComplete: ['Upload complete', Type.STRING],\n    labelFileProcessingAborted: ['Upload cancelled', Type.STRING],\n    labelFileProcessingError: ['Error during upload', Type.STRING],\n    labelFileProcessingRevertError: ['Error during revert', Type.STRING],\n\n    labelTapToCancel: ['tap to cancel', Type.STRING],\n    labelTapToRetry: ['tap to retry', Type.STRING],\n    labelTapToUndo: ['tap to undo', Type.STRING],\n\n    labelButtonRemoveItem: ['Remove', Type.STRING],\n    labelButtonAbortItemLoad: ['Abort', Type.STRING],\n    labelButtonRetryItemLoad: ['Retry', Type.STRING],\n    labelButtonAbortItemProcessing: ['Cancel', Type.STRING],\n    labelButtonUndoItemProcessing: ['Undo', Type.STRING],\n    labelButtonRetryItemProcessing: ['Retry', Type.STRING],\n    labelButtonProcessItem: ['Upload', Type.STRING],\n\n    // make sure width and height plus viewpox are even numbers so icons are nicely centered\n    iconRemove: [\n      '<svg width=\"26\" height=\"26\" viewBox=\"0 0 26 26\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M11.586 13l-2.293 2.293a1 1 0 0 0 1.414 1.414L13 14.414l2.293 2.293a1 1 0 0 0 1.414-1.414L14.414 13l2.293-2.293a1 1 0 0 0-1.414-1.414L13 11.586l-2.293-2.293a1 1 0 0 0-1.414 1.414L11.586 13z\" fill=\"currentColor\" fill-rule=\"nonzero\"/></svg>',\n      Type.STRING\n    ],\n\n    iconProcess: [\n      '<svg width=\"26\" height=\"26\" viewBox=\"0 0 26 26\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M14 10.414v3.585a1 1 0 0 1-2 0v-3.585l-1.293 1.293a1 1 0 0 1-1.414-1.415l3-3a1 1 0 0 1 1.414 0l3 3a1 1 0 0 1-1.414 1.415L14 10.414zM9 18a1 1 0 0 1 0-2h8a1 1 0 0 1 0 2H9z\" fill=\"currentColor\" fill-rule=\"evenodd\"/></svg>',\n      Type.STRING\n    ],\n\n    iconRetry: [\n      '<svg width=\"26\" height=\"26\" viewBox=\"0 0 26 26\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M10.81 9.185l-.038.02A4.997 4.997 0 0 0 8 13.683a5 5 0 0 0 5 5 5 5 0 0 0 5-5 1 1 0 0 1 2 0A7 7 0 1 1 9.722 7.496l-.842-.21a.999.999 0 1 1 .484-1.94l3.23.806c.535.133.86.675.73 1.21l-.804 3.233a.997.997 0 0 1-1.21.73.997.997 0 0 1-.73-1.21l.23-.928v-.002z\" fill=\"currentColor\" fill-rule=\"nonzero\"/></svg>',\n      Type.STRING\n    ],\n\n    iconUndo: [\n      '<svg width=\"26\" height=\"26\" viewBox=\"0 0 26 26\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M9.185 10.81l.02-.038A4.997 4.997 0 0 1 13.683 8a5 5 0 0 1 5 5 5 5 0 0 1-5 5 1 1 0 0 0 0 2A7 7 0 1 0 7.496 9.722l-.21-.842a.999.999 0 1 0-1.94.484l.806 3.23c.133.535.675.86 1.21.73l3.233-.803a.997.997 0 0 0 .73-1.21.997.997 0 0 0-1.21-.73l-.928.23-.002-.001z\" fill=\"currentColor\" fill-rule=\"nonzero\"/></svg>',\n      Type.STRING\n    ],\n\n    iconDone: [\n      '<svg width=\"26\" height=\"26\" viewBox=\"0 0 26 26\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M18.293 9.293a1 1 0 0 1 1.414 1.414l-7.002 7a1 1 0 0 1-1.414 0l-3.998-4a1 1 0 1 1 1.414-1.414L12 15.586l6.294-6.293z\" fill=\"currentColor\" fill-rule=\"nonzero\"/></svg>',\n      Type.STRING\n    ],\n\n    // event handlers\n    oninit: [null, Type.FUNCTION],\n    onwarning: [null, Type.FUNCTION],\n    onerror: [null, Type.FUNCTION],\n    onactivatefile: [null, Type.FUNCTION],\n    oninitfile: [null, Type.FUNCTION],\n    onaddfilestart: [null, Type.FUNCTION],\n    onaddfileprogress: [null, Type.FUNCTION],\n    onaddfile: [null, Type.FUNCTION],\n    onprocessfilestart: [null, Type.FUNCTION],\n    onprocessfileprogress: [null, Type.FUNCTION],\n    onprocessfileabort: [null, Type.FUNCTION],\n    onprocessfilerevert: [null, Type.FUNCTION],\n    onprocessfile: [null, Type.FUNCTION],\n    onprocessfiles: [null, Type.FUNCTION],\n    onremovefile: [null, Type.FUNCTION],\n    onpreparefile: [null, Type.FUNCTION],\n    onupdatefiles: [null, Type.FUNCTION],\n    onreorderfiles: [null, Type.FUNCTION],\n\n    // hooks\n    beforeDropFile: [null, Type.FUNCTION],\n    beforeAddFile: [null, Type.FUNCTION],\n    beforeRemoveFile: [null, Type.FUNCTION],\n    beforePrepareFile: [null, Type.FUNCTION],\n\n    // styles\n    stylePanelLayout: [null, Type.STRING], // null 'integrated', 'compact', 'circle'\n    stylePanelAspectRatio: [null, Type.STRING], // null or '3:2' or 1\n    styleItemPanelAspectRatio: [null, Type.STRING],\n    styleButtonRemoveItemPosition: ['left', Type.STRING],\n    styleButtonProcessItemPosition: ['right', Type.STRING],\n    styleLoadIndicatorPosition: ['right', Type.STRING],\n    styleProgressIndicatorPosition: ['right', Type.STRING],\n    styleButtonRemoveItemAlign: [false, Type.BOOLEAN],\n\n    // custom initial files array\n    files: [[], Type.ARRAY],\n\n    // show support by displaying credits\n    credits: [['https://pqina.nl/', 'Powered by PQINA'], Type.ARRAY]\n  };\n\n  var getItemByQuery = function getItemByQuery(items, query) {\n    // just return first index\n    if (isEmpty(query)) {\n      return items[0] || null;\n    }\n\n    // query is index\n    if (isInt(query)) {\n      return items[query] || null;\n    }\n\n    // if query is item, get the id\n    if (typeof query === 'object') {\n      query = query.id;\n    }\n\n    // assume query is a string and return item by id\n    return (\n      items.find(function(item) {\n        return item.id === query;\n      }) || null\n    );\n  };\n\n  var getNumericAspectRatioFromString = function getNumericAspectRatioFromString(\n    aspectRatio\n  ) {\n    if (isEmpty(aspectRatio)) {\n      return aspectRatio;\n    }\n    if (/:/.test(aspectRatio)) {\n      var parts = aspectRatio.split(':');\n      return parts[1] / parts[0];\n    }\n    return parseFloat(aspectRatio);\n  };\n\n  var getActiveItems = function getActiveItems(items) {\n    return items.filter(function(item) {\n      return !item.archived;\n    });\n  };\n\n  var Status = {\n    EMPTY: 0,\n    IDLE: 1, // waiting\n    ERROR: 2, // a file is in error state\n    BUSY: 3, // busy processing or loading\n    READY: 4 // all files uploaded\n  };\n\n  var ITEM_ERROR = [\n    ItemStatus.LOAD_ERROR,\n    ItemStatus.PROCESSING_ERROR,\n    ItemStatus.PROCESSING_REVERT_ERROR\n  ];\n  var ITEM_BUSY = [\n    ItemStatus.LOADING,\n    ItemStatus.PROCESSING,\n    ItemStatus.PROCESSING_QUEUED,\n    ItemStatus.INIT\n  ];\n  var ITEM_READY = [ItemStatus.PROCESSING_COMPLETE];\n\n  var isItemInErrorState = function isItemInErrorState(item) {\n    return ITEM_ERROR.includes(item.status);\n  };\n  var isItemInBusyState = function isItemInBusyState(item) {\n    return ITEM_BUSY.includes(item.status);\n  };\n  var isItemInReadyState = function isItemInReadyState(item) {\n    return ITEM_READY.includes(item.status);\n  };\n\n  var queries = function queries(state) {\n    return {\n      GET_STATUS: function GET_STATUS() {\n        var items = getActiveItems(state.items);\n        var EMPTY = Status.EMPTY,\n          ERROR = Status.ERROR,\n          BUSY = Status.BUSY,\n          IDLE = Status.IDLE,\n          READY = Status.READY;\n\n        if (items.length === 0) return EMPTY;\n\n        if (items.some(isItemInErrorState)) return ERROR;\n\n        if (items.some(isItemInBusyState)) return BUSY;\n\n        if (items.some(isItemInReadyState)) return READY;\n\n        return IDLE;\n      },\n\n      GET_ITEM: function GET_ITEM(query) {\n        return getItemByQuery(state.items, query);\n      },\n\n      GET_ACTIVE_ITEM: function GET_ACTIVE_ITEM(query) {\n        return getItemByQuery(getActiveItems(state.items), query);\n      },\n\n      GET_ACTIVE_ITEMS: function GET_ACTIVE_ITEMS() {\n        return getActiveItems(state.items);\n      },\n\n      GET_ITEMS: function GET_ITEMS() {\n        return state.items;\n      },\n\n      GET_ITEM_NAME: function GET_ITEM_NAME(query) {\n        var item = getItemByQuery(state.items, query);\n        return item ? item.filename : null;\n      },\n\n      GET_ITEM_SIZE: function GET_ITEM_SIZE(query) {\n        var item = getItemByQuery(state.items, query);\n        return item ? item.fileSize : null;\n      },\n\n      GET_STYLES: function GET_STYLES() {\n        return Object.keys(state.options)\n          .filter(function(key) {\n            return /^style/.test(key);\n          })\n          .map(function(option) {\n            return {\n              name: option,\n              value: state.options[option]\n            };\n          });\n      },\n\n      GET_PANEL_ASPECT_RATIO: function GET_PANEL_ASPECT_RATIO() {\n        var isShapeCircle = /circle/.test(state.options.stylePanelLayout);\n        var aspectRatio = isShapeCircle\n          ? 1\n          : getNumericAspectRatioFromString(\n              state.options.stylePanelAspectRatio\n            );\n        return aspectRatio;\n      },\n\n      GET_ITEM_PANEL_ASPECT_RATIO: function GET_ITEM_PANEL_ASPECT_RATIO() {\n        return state.options.styleItemPanelAspectRatio;\n      },\n\n      GET_ITEMS_BY_STATUS: function GET_ITEMS_BY_STATUS(status) {\n        return getActiveItems(state.items).filter(function(item) {\n          return item.status === status;\n        });\n      },\n\n      GET_TOTAL_ITEMS: function GET_TOTAL_ITEMS() {\n        return getActiveItems(state.items).length;\n      },\n\n      IS_ASYNC: function IS_ASYNC() {\n        return (\n          isObject(state.options.server) &&\n          (isObject(state.options.server.process) ||\n            isFunction(state.options.server.process))\n        );\n      }\n    };\n  };\n\n  var hasRoomForItem = function hasRoomForItem(state) {\n    var count = getActiveItems(state.items).length;\n\n    // if cannot have multiple items, to add one item it should currently not contain items\n    if (!state.options.allowMultiple) {\n      return count === 0;\n    }\n\n    // if allows multiple items, we check if a max item count has been set, if not, there's no limit\n    var maxFileCount = state.options.maxFiles;\n    if (maxFileCount === null) {\n      return true;\n    }\n\n    // we check if the current count is smaller than the max count, if so, another file can still be added\n    if (count < maxFileCount) {\n      return true;\n    }\n\n    // no more room for another file\n    return false;\n  };\n\n  var limit = function limit(value, min, max) {\n    return Math.max(Math.min(max, value), min);\n  };\n\n  var arrayInsert = function arrayInsert(arr, index, item) {\n    return arr.splice(index, 0, item);\n  };\n\n  var insertItem = function insertItem(items, item, index) {\n    if (isEmpty(item)) {\n      return null;\n    }\n\n    // if index is undefined, append\n    if (typeof index === 'undefined') {\n      items.push(item);\n      return item;\n    }\n\n    // limit the index to the size of the items array\n    index = limit(index, 0, items.length);\n\n    // add item to array\n    arrayInsert(items, index, item);\n\n    // expose\n    return item;\n  };\n\n  var isBase64DataURI = function isBase64DataURI(str) {\n    return /^\\s*data:([a-z]+\\/[a-z0-9-+.]+(;[a-z-]+=[a-z0-9-]+)?)?(;base64)?,([a-z0-9!$&',()*+;=\\-._~:@\\/?%\\s]*)\\s*$/i.test(\n      str\n    );\n  };\n\n  var getFilenameFromURL = function getFilenameFromURL(url) {\n    return url\n      .split('/')\n      .pop()\n      .split('?')\n      .shift();\n  };\n\n  var getExtensionFromFilename = function getExtensionFromFilename(name) {\n    return name.split('.').pop();\n  };\n\n  var guesstimateExtension = function guesstimateExtension(type) {\n    // if no extension supplied, exit here\n    if (typeof type !== 'string') {\n      return '';\n    }\n\n    // get subtype\n    var subtype = type.split('/').pop();\n\n    // is svg subtype\n    if (/svg/.test(subtype)) {\n      return 'svg';\n    }\n\n    if (/zip|compressed/.test(subtype)) {\n      return 'zip';\n    }\n\n    if (/plain/.test(subtype)) {\n      return 'txt';\n    }\n\n    if (/msword/.test(subtype)) {\n      return 'doc';\n    }\n\n    // if is valid subtype\n    if (/[a-z]+/.test(subtype)) {\n      // always use jpg extension\n      if (subtype === 'jpeg') {\n        return 'jpg';\n      }\n\n      // return subtype\n      return subtype;\n    }\n\n    return '';\n  };\n\n  var leftPad = function leftPad(value) {\n    var padding =\n      arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n    return (padding + value).slice(-padding.length);\n  };\n\n  var getDateString = function getDateString() {\n    var date =\n      arguments.length > 0 && arguments[0] !== undefined\n        ? arguments[0]\n        : new Date();\n    return (\n      date.getFullYear() +\n      '-' +\n      leftPad(date.getMonth() + 1, '00') +\n      '-' +\n      leftPad(date.getDate(), '00') +\n      '_' +\n      leftPad(date.getHours(), '00') +\n      '-' +\n      leftPad(date.getMinutes(), '00') +\n      '-' +\n      leftPad(date.getSeconds(), '00')\n    );\n  };\n\n  var getFileFromBlob = function getFileFromBlob(blob, filename) {\n    var type =\n      arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    var extension =\n      arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    var file =\n      typeof type === 'string'\n        ? blob.slice(0, blob.size, type)\n        : blob.slice(0, blob.size, blob.type);\n    file.lastModifiedDate = new Date();\n\n    // copy relative path\n    if (blob._relativePath) file._relativePath = blob._relativePath;\n\n    // if blob has name property, use as filename if no filename supplied\n    if (!isString(filename)) {\n      filename = getDateString();\n    }\n\n    // if filename supplied but no extension and filename has extension\n    if (filename && extension === null && getExtensionFromFilename(filename)) {\n      file.name = filename;\n    } else {\n      extension = extension || guesstimateExtension(file.type);\n      file.name = filename + (extension ? '.' + extension : '');\n    }\n\n    return file;\n  };\n\n  var getBlobBuilder = function getBlobBuilder() {\n    return (window.BlobBuilder =\n      window.BlobBuilder ||\n      window.WebKitBlobBuilder ||\n      window.MozBlobBuilder ||\n      window.MSBlobBuilder);\n  };\n\n  var createBlob = function createBlob(arrayBuffer, mimeType) {\n    var BB = getBlobBuilder();\n\n    if (BB) {\n      var bb = new BB();\n      bb.append(arrayBuffer);\n      return bb.getBlob(mimeType);\n    }\n\n    return new Blob([arrayBuffer], {\n      type: mimeType\n    });\n  };\n\n  var getBlobFromByteStringWithMimeType = function getBlobFromByteStringWithMimeType(\n    byteString,\n    mimeType\n  ) {\n    var ab = new ArrayBuffer(byteString.length);\n    var ia = new Uint8Array(ab);\n\n    for (var i = 0; i < byteString.length; i++) {\n      ia[i] = byteString.charCodeAt(i);\n    }\n\n    return createBlob(ab, mimeType);\n  };\n\n  var getMimeTypeFromBase64DataURI = function getMimeTypeFromBase64DataURI(\n    dataURI\n  ) {\n    return (/^data:(.+);/.exec(dataURI) || [])[1] || null;\n  };\n\n  var getBase64DataFromBase64DataURI = function getBase64DataFromBase64DataURI(\n    dataURI\n  ) {\n    // get data part of string (remove data:image/jpeg...,)\n    var data = dataURI.split(',')[1];\n\n    // remove any whitespace as that causes InvalidCharacterError in IE\n    return data.replace(/\\s/g, '');\n  };\n\n  var getByteStringFromBase64DataURI = function getByteStringFromBase64DataURI(\n    dataURI\n  ) {\n    return atob(getBase64DataFromBase64DataURI(dataURI));\n  };\n\n  var getBlobFromBase64DataURI = function getBlobFromBase64DataURI(dataURI) {\n    var mimeType = getMimeTypeFromBase64DataURI(dataURI);\n    var byteString = getByteStringFromBase64DataURI(dataURI);\n\n    return getBlobFromByteStringWithMimeType(byteString, mimeType);\n  };\n\n  var getFileFromBase64DataURI = function getFileFromBase64DataURI(\n    dataURI,\n    filename,\n    extension\n  ) {\n    return getFileFromBlob(\n      getBlobFromBase64DataURI(dataURI),\n      filename,\n      null,\n      extension\n    );\n  };\n\n  var getFileNameFromHeader = function getFileNameFromHeader(header) {\n    // test if is content disposition header, if not exit\n    if (!/^content-disposition:/i.test(header)) return null;\n\n    // get filename parts\n    var matches = header\n      .split(/filename=|filename\\*=.+''/)\n      .splice(1)\n      .map(function(name) {\n        return name.trim().replace(/^[\"']|[;\"']{0,2}$/g, '');\n      })\n      .filter(function(name) {\n        return name.length;\n      });\n\n    return matches.length ? decodeURI(matches[matches.length - 1]) : null;\n  };\n\n  var getFileSizeFromHeader = function getFileSizeFromHeader(header) {\n    if (/content-length:/i.test(header)) {\n      var size = header.match(/[0-9]+/)[0];\n      return size ? parseInt(size, 10) : null;\n    }\n    return null;\n  };\n\n  var getTranfserIdFromHeader = function getTranfserIdFromHeader(header) {\n    if (/x-content-transfer-id:/i.test(header)) {\n      var id = (header.split(':')[1] || '').trim();\n      return id || null;\n    }\n    return null;\n  };\n\n  var getFileInfoFromHeaders = function getFileInfoFromHeaders(headers) {\n    var info = {\n      source: null,\n      name: null,\n      size: null\n    };\n\n    var rows = headers.split('\\n');\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n    try {\n      for (\n        var _iterator = rows[Symbol.iterator](), _step;\n        !(_iteratorNormalCompletion = (_step = _iterator.next()).done);\n        _iteratorNormalCompletion = true\n      ) {\n        var header = _step.value;\n\n        var name = getFileNameFromHeader(header);\n        if (name) {\n          info.name = name;\n          continue;\n        }\n\n        var size = getFileSizeFromHeader(header);\n        if (size) {\n          info.size = size;\n          continue;\n        }\n\n        var source = getTranfserIdFromHeader(header);\n        if (source) {\n          info.source = source;\n          continue;\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    return info;\n  };\n\n  var createFileLoader = function createFileLoader(fetchFn) {\n    var state = {\n      source: null,\n      complete: false,\n      progress: 0,\n      size: null,\n      timestamp: null,\n      duration: 0,\n      request: null\n    };\n\n    var getProgress = function getProgress() {\n      return state.progress;\n    };\n    var abort = function abort() {\n      if (state.request && state.request.abort) {\n        state.request.abort();\n      }\n    };\n\n    // load source\n    var load = function load() {\n      // get quick reference\n      var source = state.source;\n\n      api.fire('init', source);\n\n      // Load Files\n      if (source instanceof File) {\n        api.fire('load', source);\n      } else if (source instanceof Blob) {\n        // Load blobs, set default name to current date\n        api.fire('load', getFileFromBlob(source, source.name));\n      } else if (isBase64DataURI(source)) {\n        // Load base 64, set default name to current date\n        api.fire('load', getFileFromBase64DataURI(source));\n      } else {\n        // Deal as if is external URL, let's load it!\n        loadURL(source);\n      }\n    };\n\n    // loads a url\n    var loadURL = function loadURL(url) {\n      // is remote url and no fetch method supplied\n      if (!fetchFn) {\n        api.fire('error', {\n          type: 'error',\n          body: \"Can't load URL\",\n          code: 400\n        });\n\n        return;\n      }\n\n      // set request start\n      state.timestamp = Date.now();\n\n      // load file\n      state.request = fetchFn(\n        url,\n        function(response) {\n          // update duration\n          state.duration = Date.now() - state.timestamp;\n\n          // done!\n          state.complete = true;\n\n          // turn blob response into a file\n          if (response instanceof Blob) {\n            response = getFileFromBlob(\n              response,\n              response.name || getFilenameFromURL(url)\n            );\n          }\n\n          api.fire(\n            'load',\n            // if has received blob, we go with blob, if no response, we return null\n            response instanceof Blob\n              ? response\n              : response\n              ? response.body\n              : null\n          );\n        },\n        function(error) {\n          api.fire(\n            'error',\n            typeof error === 'string'\n              ? {\n                  type: 'error',\n                  code: 0,\n                  body: error\n                }\n              : error\n          );\n        },\n        function(computable, current, total) {\n          // collected some meta data already\n          if (total) {\n            state.size = total;\n          }\n\n          // update duration\n          state.duration = Date.now() - state.timestamp;\n\n          // if we can't compute progress, we're not going to fire progress events\n          if (!computable) {\n            state.progress = null;\n            return;\n          }\n\n          // update progress percentage\n          state.progress = current / total;\n\n          // expose\n          api.fire('progress', state.progress);\n        },\n        function() {\n          api.fire('abort');\n        },\n        function(response) {\n          var fileinfo = getFileInfoFromHeaders(\n            typeof response === 'string' ? response : response.headers\n          );\n          api.fire('meta', {\n            size: state.size || fileinfo.size,\n            filename: fileinfo.name,\n            source: fileinfo.source\n          });\n        }\n      );\n    };\n\n    var api = Object.assign({}, on(), {\n      setSource: function setSource(source) {\n        return (state.source = source);\n      },\n      getProgress: getProgress, // file load progress\n      abort: abort, // abort file load\n      load: load // start load\n    });\n\n    return api;\n  };\n\n  var isGet = function isGet(method) {\n    return /GET|HEAD/.test(method);\n  };\n\n  var sendRequest = function sendRequest(data, url, options) {\n    var api = {\n      onheaders: function onheaders() {},\n      onprogress: function onprogress() {},\n      onload: function onload() {},\n      ontimeout: function ontimeout() {},\n      onerror: function onerror() {},\n      onabort: function onabort() {},\n      abort: function abort() {\n        aborted = true;\n        xhr.abort();\n      }\n    };\n\n    // timeout identifier, only used when timeout is defined\n    var aborted = false;\n    var headersReceived = false;\n\n    // set default options\n    options = Object.assign(\n      {\n        method: 'POST',\n        headers: {},\n        withCredentials: false\n      },\n      options\n    );\n\n    // encode url\n    url = encodeURI(url);\n\n    // if method is GET, add any received data to url\n\n    if (isGet(options.method) && data) {\n      url =\n        '' +\n        url +\n        encodeURIComponent(\n          typeof data === 'string' ? data : JSON.stringify(data)\n        );\n    }\n\n    // create request\n    var xhr = new XMLHttpRequest();\n\n    // progress of load\n    var process = isGet(options.method) ? xhr : xhr.upload;\n    process.onprogress = function(e) {\n      // no progress event when aborted ( onprogress is called once after abort() )\n      if (aborted) {\n        return;\n      }\n\n      api.onprogress(e.lengthComputable, e.loaded, e.total);\n    };\n\n    // tries to get header info to the app as fast as possible\n    xhr.onreadystatechange = function() {\n      // not interesting in these states ('unsent' and 'openend' as they don't give us any additional info)\n      if (xhr.readyState < 2) {\n        return;\n      }\n\n      // no server response\n      if (xhr.readyState === 4 && xhr.status === 0) {\n        return;\n      }\n\n      if (headersReceived) {\n        return;\n      }\n\n      headersReceived = true;\n\n      // we've probably received some useful data in response headers\n      api.onheaders(xhr);\n    };\n\n    // load successful\n    xhr.onload = function() {\n      // is classified as valid response\n      if (xhr.status >= 200 && xhr.status < 300) {\n        api.onload(xhr);\n      } else {\n        api.onerror(xhr);\n      }\n    };\n\n    // error during load\n    xhr.onerror = function() {\n      return api.onerror(xhr);\n    };\n\n    // request aborted\n    xhr.onabort = function() {\n      aborted = true;\n      api.onabort();\n    };\n\n    // request timeout\n    xhr.ontimeout = function() {\n      return api.ontimeout(xhr);\n    };\n\n    // open up open up!\n    xhr.open(options.method, url, true);\n\n    // set timeout if defined (do it after open so IE11 plays ball)\n    if (isInt(options.timeout)) {\n      xhr.timeout = options.timeout;\n    }\n\n    // add headers\n    Object.keys(options.headers).forEach(function(key) {\n      var value = unescape(encodeURIComponent(options.headers[key]));\n      xhr.setRequestHeader(key, value);\n    });\n\n    // set type of response\n    if (options.responseType) {\n      xhr.responseType = options.responseType;\n    }\n\n    // set credentials\n    if (options.withCredentials) {\n      xhr.withCredentials = true;\n    }\n\n    // let's send our data\n    xhr.send(data);\n\n    return api;\n  };\n\n  var createResponse = function createResponse(type, code, body, headers) {\n    return {\n      type: type,\n      code: code,\n      body: body,\n      headers: headers\n    };\n  };\n\n  var createTimeoutResponse = function createTimeoutResponse(cb) {\n    return function(xhr) {\n      cb(createResponse('error', 0, 'Timeout', xhr.getAllResponseHeaders()));\n    };\n  };\n\n  var hasQS = function hasQS(str) {\n    return /\\?/.test(str);\n  };\n  var buildURL = function buildURL() {\n    var url = '';\n    for (\n      var _len = arguments.length, parts = new Array(_len), _key = 0;\n      _key < _len;\n      _key++\n    ) {\n      parts[_key] = arguments[_key];\n    }\n    parts.forEach(function(part) {\n      url += hasQS(url) && hasQS(part) ? part.replace(/\\?/, '&') : part;\n    });\n    return url;\n  };\n\n  var createFetchFunction = function createFetchFunction() {\n    var apiUrl =\n      arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    var action = arguments.length > 1 ? arguments[1] : undefined;\n    // custom handler (should also handle file, load, error, progress and abort)\n    if (typeof action === 'function') {\n      return action;\n    }\n\n    // no action supplied\n    if (!action || !isString(action.url)) {\n      return null;\n    }\n\n    // set onload hanlder\n    var onload =\n      action.onload ||\n      function(res) {\n        return res;\n      };\n    var onerror =\n      action.onerror ||\n      function(res) {\n        return null;\n      };\n\n    // internal handler\n    return function(url, load, error, progress, abort, headers) {\n      // do local or remote request based on if the url is external\n      var request = sendRequest(\n        url,\n        buildURL(apiUrl, action.url),\n        Object.assign({}, action, {\n          responseType: 'blob'\n        })\n      );\n\n      request.onload = function(xhr) {\n        // get headers\n        var headers = xhr.getAllResponseHeaders();\n\n        // get filename\n        var filename =\n          getFileInfoFromHeaders(headers).name || getFilenameFromURL(url);\n\n        // create response\n        load(\n          createResponse(\n            'load',\n            xhr.status,\n            action.method === 'HEAD'\n              ? null\n              : getFileFromBlob(onload(xhr.response), filename),\n            headers\n          )\n        );\n      };\n\n      request.onerror = function(xhr) {\n        error(\n          createResponse(\n            'error',\n            xhr.status,\n            onerror(xhr.response) || xhr.statusText,\n            xhr.getAllResponseHeaders()\n          )\n        );\n      };\n\n      request.onheaders = function(xhr) {\n        headers(\n          createResponse(\n            'headers',\n            xhr.status,\n            null,\n            xhr.getAllResponseHeaders()\n          )\n        );\n      };\n\n      request.ontimeout = createTimeoutResponse(error);\n      request.onprogress = progress;\n      request.onabort = abort;\n\n      // should return request\n      return request;\n    };\n  };\n\n  var ChunkStatus = {\n    QUEUED: 0,\n    COMPLETE: 1,\n    PROCESSING: 2,\n    ERROR: 3,\n    WAITING: 4\n  };\n\n  /*\n                                                       function signature:\n                                                         (file, metadata, load, error, progress, abort, transfer, options) => {\n                                                           return {\n                                                           abort:() => {}\n                                                         }\n                                                       }\n                                                       */\n\n  // apiUrl, action, name, file, metadata, load, error, progress, abort, transfer, options\n  var processFileChunked = function processFileChunked(\n    apiUrl,\n    action,\n    name,\n    file,\n    metadata,\n    load,\n    error,\n    progress,\n    abort,\n    transfer,\n    options\n  ) {\n    // all chunks\n    var chunks = [];\n    var chunkTransferId = options.chunkTransferId,\n      chunkServer = options.chunkServer,\n      chunkSize = options.chunkSize,\n      chunkRetryDelays = options.chunkRetryDelays;\n\n    // default state\n    var state = {\n      serverId: chunkTransferId,\n      aborted: false\n    };\n\n    // set onload handlers\n    var ondata =\n      action.ondata ||\n      function(fd) {\n        return fd;\n      };\n    var onload =\n      action.onload ||\n      function(xhr, method) {\n        return method === 'HEAD'\n          ? xhr.getResponseHeader('Upload-Offset')\n          : xhr.response;\n      };\n    var onerror =\n      action.onerror ||\n      function(res) {\n        return null;\n      };\n\n    // create server hook\n    var requestTransferId = function requestTransferId(cb) {\n      var formData = new FormData();\n\n      // add metadata under same name\n      if (isObject(metadata)) formData.append(name, JSON.stringify(metadata));\n\n      var headers =\n        typeof action.headers === 'function'\n          ? action.headers(file, metadata)\n          : Object.assign({}, action.headers, {\n              'Upload-Length': file.size\n            });\n\n      var requestParams = Object.assign({}, action, {\n        headers: headers\n      });\n\n      // send request object\n      var request = sendRequest(\n        ondata(formData),\n        buildURL(apiUrl, action.url),\n        requestParams\n      );\n\n      request.onload = function(xhr) {\n        return cb(onload(xhr, requestParams.method));\n      };\n\n      request.onerror = function(xhr) {\n        return error(\n          createResponse(\n            'error',\n            xhr.status,\n            onerror(xhr.response) || xhr.statusText,\n            xhr.getAllResponseHeaders()\n          )\n        );\n      };\n\n      request.ontimeout = createTimeoutResponse(error);\n    };\n\n    var requestTransferOffset = function requestTransferOffset(cb) {\n      var requestUrl = buildURL(apiUrl, chunkServer.url, state.serverId);\n\n      var headers =\n        typeof action.headers === 'function'\n          ? action.headers(state.serverId)\n          : Object.assign({}, action.headers);\n\n      var requestParams = {\n        headers: headers,\n        method: 'HEAD'\n      };\n\n      var request = sendRequest(null, requestUrl, requestParams);\n\n      request.onload = function(xhr) {\n        return cb(onload(xhr, requestParams.method));\n      };\n\n      request.onerror = function(xhr) {\n        return error(\n          createResponse(\n            'error',\n            xhr.status,\n            onerror(xhr.response) || xhr.statusText,\n            xhr.getAllResponseHeaders()\n          )\n        );\n      };\n\n      request.ontimeout = createTimeoutResponse(error);\n    };\n\n    // create chunks\n    var lastChunkIndex = Math.floor(file.size / chunkSize);\n    for (var i = 0; i <= lastChunkIndex; i++) {\n      var offset = i * chunkSize;\n      var data = file.slice(\n        offset,\n        offset + chunkSize,\n        'application/offset+octet-stream'\n      );\n      chunks[i] = {\n        index: i,\n        size: data.size,\n        offset: offset,\n        data: data,\n        file: file,\n        progress: 0,\n        retries: _toConsumableArray(chunkRetryDelays),\n        status: ChunkStatus.QUEUED,\n        error: null,\n        request: null,\n        timeout: null\n      };\n    }\n\n    var completeProcessingChunks = function completeProcessingChunks() {\n      return load(state.serverId);\n    };\n\n    var canProcessChunk = function canProcessChunk(chunk) {\n      return (\n        chunk.status === ChunkStatus.QUEUED ||\n        chunk.status === ChunkStatus.ERROR\n      );\n    };\n\n    var processChunk = function processChunk(chunk) {\n      // processing is paused, wait here\n      if (state.aborted) return;\n\n      // get next chunk to process\n      chunk = chunk || chunks.find(canProcessChunk);\n\n      // no more chunks to process\n      if (!chunk) {\n        // all done?\n        if (\n          chunks.every(function(chunk) {\n            return chunk.status === ChunkStatus.COMPLETE;\n          })\n        ) {\n          completeProcessingChunks();\n        }\n\n        // no chunk to handle\n        return;\n      }\n\n      // now processing this chunk\n      chunk.status = ChunkStatus.PROCESSING;\n      chunk.progress = null;\n\n      // allow parsing of formdata\n      var ondata =\n        chunkServer.ondata ||\n        function(fd) {\n          return fd;\n        };\n      var onerror =\n        chunkServer.onerror ||\n        function(res) {\n          return null;\n        };\n\n      // send request object\n      var requestUrl = buildURL(apiUrl, chunkServer.url, state.serverId);\n\n      var headers =\n        typeof chunkServer.headers === 'function'\n          ? chunkServer.headers(chunk)\n          : Object.assign({}, chunkServer.headers, {\n              'Content-Type': 'application/offset+octet-stream',\n              'Upload-Offset': chunk.offset,\n              'Upload-Length': file.size,\n              'Upload-Name': file.name\n            });\n\n      var request = (chunk.request = sendRequest(\n        ondata(chunk.data),\n        requestUrl,\n        Object.assign({}, chunkServer, {\n          headers: headers\n        })\n      ));\n\n      request.onload = function() {\n        // done!\n        chunk.status = ChunkStatus.COMPLETE;\n\n        // remove request reference\n        chunk.request = null;\n\n        // start processing more chunks\n        processChunks();\n      };\n\n      request.onprogress = function(lengthComputable, loaded, total) {\n        chunk.progress = lengthComputable ? loaded : null;\n        updateTotalProgress();\n      };\n\n      request.onerror = function(xhr) {\n        chunk.status = ChunkStatus.ERROR;\n        chunk.request = null;\n        chunk.error = onerror(xhr.response) || xhr.statusText;\n        if (!retryProcessChunk(chunk)) {\n          error(\n            createResponse(\n              'error',\n              xhr.status,\n              onerror(xhr.response) || xhr.statusText,\n              xhr.getAllResponseHeaders()\n            )\n          );\n        }\n      };\n\n      request.ontimeout = function(xhr) {\n        chunk.status = ChunkStatus.ERROR;\n        chunk.request = null;\n        if (!retryProcessChunk(chunk)) {\n          createTimeoutResponse(error)(xhr);\n        }\n      };\n\n      request.onabort = function() {\n        chunk.status = ChunkStatus.QUEUED;\n        chunk.request = null;\n        abort();\n      };\n    };\n\n    var retryProcessChunk = function retryProcessChunk(chunk) {\n      // no more retries left\n      if (chunk.retries.length === 0) return false;\n\n      // new retry\n      chunk.status = ChunkStatus.WAITING;\n      clearTimeout(chunk.timeout);\n      chunk.timeout = setTimeout(function() {\n        processChunk(chunk);\n      }, chunk.retries.shift());\n\n      // we're going to retry\n      return true;\n    };\n\n    var updateTotalProgress = function updateTotalProgress() {\n      // calculate total progress fraction\n      var totalBytesTransfered = chunks.reduce(function(p, chunk) {\n        if (p === null || chunk.progress === null) return null;\n        return p + chunk.progress;\n      }, 0);\n\n      // can't compute progress\n      if (totalBytesTransfered === null) return progress(false, 0, 0);\n\n      // calculate progress values\n      var totalSize = chunks.reduce(function(total, chunk) {\n        return total + chunk.size;\n      }, 0);\n\n      // can update progress indicator\n      progress(true, totalBytesTransfered, totalSize);\n    };\n\n    // process new chunks\n    var processChunks = function processChunks() {\n      var totalProcessing = chunks.filter(function(chunk) {\n        return chunk.status === ChunkStatus.PROCESSING;\n      }).length;\n      if (totalProcessing >= 1) return;\n      processChunk();\n    };\n\n    var abortChunks = function abortChunks() {\n      chunks.forEach(function(chunk) {\n        clearTimeout(chunk.timeout);\n        if (chunk.request) {\n          chunk.request.abort();\n        }\n      });\n    };\n\n    // let's go!\n    if (!state.serverId) {\n      requestTransferId(function(serverId) {\n        // stop here if aborted, might have happened in between request and callback\n        if (state.aborted) return;\n\n        // pass back to item so we can use it if something goes wrong\n        transfer(serverId);\n\n        // store internally\n        state.serverId = serverId;\n        processChunks();\n      });\n    } else {\n      requestTransferOffset(function(offset) {\n        // stop here if aborted, might have happened in between request and callback\n        if (state.aborted) return;\n\n        // mark chunks with lower offset as complete\n        chunks\n          .filter(function(chunk) {\n            return chunk.offset < offset;\n          })\n          .forEach(function(chunk) {\n            chunk.status = ChunkStatus.COMPLETE;\n            chunk.progress = chunk.size;\n          });\n\n        // continue processing\n        processChunks();\n      });\n    }\n\n    return {\n      abort: function abort() {\n        state.aborted = true;\n        abortChunks();\n      }\n    };\n  };\n\n  /*\n                                                               function signature:\n                                                                 (file, metadata, load, error, progress, abort) => {\n                                                                   return {\n                                                                   abort:() => {}\n                                                                 }\n                                                               }\n                                                               */\n  var createFileProcessorFunction = function createFileProcessorFunction(\n    apiUrl,\n    action,\n    name,\n    options\n  ) {\n    return function(file, metadata, load, error, progress, abort, transfer) {\n      // no file received\n      if (!file) return;\n\n      // if was passed a file, and we can chunk it, exit here\n      var canChunkUpload = options.chunkUploads;\n      var shouldChunkUpload = canChunkUpload && file.size > options.chunkSize;\n      var willChunkUpload =\n        canChunkUpload && (shouldChunkUpload || options.chunkForce);\n      if (file instanceof Blob && willChunkUpload)\n        return processFileChunked(\n          apiUrl,\n          action,\n          name,\n          file,\n          metadata,\n          load,\n          error,\n          progress,\n          abort,\n          transfer,\n          options\n        );\n\n      // set handlers\n      var ondata =\n        action.ondata ||\n        function(fd) {\n          return fd;\n        };\n      var onload =\n        action.onload ||\n        function(res) {\n          return res;\n        };\n      var onerror =\n        action.onerror ||\n        function(res) {\n          return null;\n        };\n\n      // create formdata object\n      var formData = new FormData();\n\n      // add metadata under same name\n      if (isObject(metadata)) {\n        formData.append(name, JSON.stringify(metadata));\n      }\n\n      // Turn into an array of objects so no matter what the input, we can handle it the same way\n      (file instanceof Blob ? [{ name: null, file: file }] : file).forEach(\n        function(item) {\n          formData.append(\n            name,\n            item.file,\n            item.name === null\n              ? item.file.name\n              : '' + item.name + item.file.name\n          );\n        }\n      );\n\n      // send request object\n      var request = sendRequest(\n        ondata(formData),\n        buildURL(apiUrl, action.url),\n        action\n      );\n      request.onload = function(xhr) {\n        load(\n          createResponse(\n            'load',\n            xhr.status,\n            onload(xhr.response),\n            xhr.getAllResponseHeaders()\n          )\n        );\n      };\n\n      request.onerror = function(xhr) {\n        error(\n          createResponse(\n            'error',\n            xhr.status,\n            onerror(xhr.response) || xhr.statusText,\n            xhr.getAllResponseHeaders()\n          )\n        );\n      };\n\n      request.ontimeout = createTimeoutResponse(error);\n      request.onprogress = progress;\n      request.onabort = abort;\n\n      // should return request\n      return request;\n    };\n  };\n\n  var createProcessorFunction = function createProcessorFunction() {\n    var apiUrl =\n      arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    var action = arguments.length > 1 ? arguments[1] : undefined;\n    var name = arguments.length > 2 ? arguments[2] : undefined;\n    var options = arguments.length > 3 ? arguments[3] : undefined;\n\n    // custom handler (should also handle file, load, error, progress and abort)\n    if (typeof action === 'function')\n      return function() {\n        for (\n          var _len = arguments.length, params = new Array(_len), _key = 0;\n          _key < _len;\n          _key++\n        ) {\n          params[_key] = arguments[_key];\n        }\n        return action.apply(void 0, [name].concat(params, [options]));\n      };\n\n    // no action supplied\n    if (!action || !isString(action.url)) return null;\n\n    // internal handler\n    return createFileProcessorFunction(apiUrl, action, name, options);\n  };\n\n  /*\n                                                      function signature:\n                                                      (uniqueFileId, load, error) => { }\n                                                      */\n  var createRevertFunction = function createRevertFunction() {\n    var apiUrl =\n      arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    var action = arguments.length > 1 ? arguments[1] : undefined;\n    // is custom implementation\n    if (typeof action === 'function') {\n      return action;\n    }\n\n    // no action supplied, return stub function, interface will work, but file won't be removed\n    if (!action || !isString(action.url)) {\n      return function(uniqueFileId, load) {\n        return load();\n      };\n    }\n\n    // set onload hanlder\n    var onload =\n      action.onload ||\n      function(res) {\n        return res;\n      };\n    var onerror =\n      action.onerror ||\n      function(res) {\n        return null;\n      };\n\n    // internal implementation\n    return function(uniqueFileId, load, error) {\n      var request = sendRequest(\n        uniqueFileId,\n        apiUrl + action.url,\n        action // contains method, headers and withCredentials properties\n      );\n      request.onload = function(xhr) {\n        load(\n          createResponse(\n            'load',\n            xhr.status,\n            onload(xhr.response),\n            xhr.getAllResponseHeaders()\n          )\n        );\n      };\n\n      request.onerror = function(xhr) {\n        error(\n          createResponse(\n            'error',\n            xhr.status,\n            onerror(xhr.response) || xhr.statusText,\n            xhr.getAllResponseHeaders()\n          )\n        );\n      };\n\n      request.ontimeout = createTimeoutResponse(error);\n\n      return request;\n    };\n  };\n\n  var getRandomNumber = function getRandomNumber() {\n    var min =\n      arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var max =\n      arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    return min + Math.random() * (max - min);\n  };\n\n  var createPerceivedPerformanceUpdater = function createPerceivedPerformanceUpdater(\n    cb\n  ) {\n    var duration =\n      arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;\n    var offset =\n      arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var tickMin =\n      arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 25;\n    var tickMax =\n      arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 250;\n    var timeout = null;\n    var start = Date.now();\n\n    var tick = function tick() {\n      var runtime = Date.now() - start;\n      var delay = getRandomNumber(tickMin, tickMax);\n\n      if (runtime + delay > duration) {\n        delay = runtime + delay - duration;\n      }\n\n      var progress = runtime / duration;\n      if (progress >= 1 || document.hidden) {\n        cb(1);\n        return;\n      }\n\n      cb(progress);\n\n      timeout = setTimeout(tick, delay);\n    };\n\n    tick();\n\n    return {\n      clear: function clear() {\n        clearTimeout(timeout);\n      }\n    };\n  };\n\n  var createFileProcessor = function createFileProcessor(processFn) {\n    var state = {\n      complete: false,\n      perceivedProgress: 0,\n      perceivedPerformanceUpdater: null,\n      progress: null,\n      timestamp: null,\n      perceivedDuration: 0,\n      duration: 0,\n      request: null,\n      response: null\n    };\n\n    var process = function process(file, metadata) {\n      var progressFn = function progressFn() {\n        // we've not yet started the real download, stop here\n        // the request might not go through, for instance, there might be some server trouble\n        // if state.progress is null, the server does not allow computing progress and we show the spinner instead\n        if (state.duration === 0 || state.progress === null) return;\n\n        // as we're now processing, fire the progress event\n        api.fire('progress', api.getProgress());\n      };\n\n      var completeFn = function completeFn() {\n        state.complete = true;\n        api.fire('load-perceived', state.response.body);\n      };\n\n      // let's start processing\n      api.fire('start');\n\n      // set request start\n      state.timestamp = Date.now();\n\n      // create perceived performance progress indicator\n      state.perceivedPerformanceUpdater = createPerceivedPerformanceUpdater(\n        function(progress) {\n          state.perceivedProgress = progress;\n          state.perceivedDuration = Date.now() - state.timestamp;\n\n          progressFn();\n\n          // if fake progress is done, and a response has been received,\n          // and we've not yet called the complete method\n          if (\n            state.response &&\n            state.perceivedProgress === 1 &&\n            !state.complete\n          ) {\n            // we done!\n            completeFn();\n          }\n        },\n        // random delay as in a list of files you start noticing\n        // files uploading at the exact same speed\n        getRandomNumber(750, 1500)\n      );\n\n      // remember request so we can abort it later\n      state.request = processFn(\n        // the file to process\n        file,\n\n        // the metadata to send along\n        metadata,\n\n        // callbacks (load, error, progress, abort, transfer)\n        // load expects the body to be a server id if\n        // you want to make use of revert\n        function(response) {\n          // we put the response in state so we can access\n          // it outside of this method\n          state.response = isObject(response)\n            ? response\n            : {\n                type: 'load',\n                code: 200,\n                body: '' + response,\n                headers: {}\n              };\n\n          // update duration\n          state.duration = Date.now() - state.timestamp;\n\n          // force progress to 1 as we're now done\n          state.progress = 1;\n\n          // actual load is done let's share results\n          api.fire('load', state.response.body);\n\n          // we are really done\n          // if perceived progress is 1 ( wait for perceived progress to complete )\n          // or if server does not support progress ( null )\n          if (state.perceivedProgress === 1) {\n            completeFn();\n          }\n        },\n\n        // error is expected to be an object with type, code, body\n        function(error) {\n          // cancel updater\n          state.perceivedPerformanceUpdater.clear();\n\n          // update others about this error\n          api.fire(\n            'error',\n            isObject(error)\n              ? error\n              : {\n                  type: 'error',\n                  code: 0,\n                  body: '' + error\n                }\n          );\n        },\n\n        // actual processing progress\n        function(computable, current, total) {\n          // update actual duration\n          state.duration = Date.now() - state.timestamp;\n\n          // update actual progress\n          state.progress = computable ? current / total : null;\n\n          progressFn();\n        },\n\n        // abort does not expect a value\n        function() {\n          // stop updater\n          state.perceivedPerformanceUpdater.clear();\n\n          // fire the abort event so we can switch visuals\n          api.fire('abort', state.response ? state.response.body : null);\n        },\n\n        // register the id for this transfer\n        function(transferId) {\n          api.fire('transfer', transferId);\n        }\n      );\n    };\n\n    var abort = function abort() {\n      // no request running, can't abort\n      if (!state.request) return;\n\n      // stop updater\n      state.perceivedPerformanceUpdater.clear();\n\n      // abort actual request\n      if (state.request.abort) state.request.abort();\n\n      // if has response object, we've completed the request\n      state.complete = true;\n    };\n\n    var reset = function reset() {\n      abort();\n      state.complete = false;\n      state.perceivedProgress = 0;\n      state.progress = 0;\n      state.timestamp = null;\n      state.perceivedDuration = 0;\n      state.duration = 0;\n      state.request = null;\n      state.response = null;\n    };\n\n    var getProgress = function getProgress() {\n      return state.progress\n        ? Math.min(state.progress, state.perceivedProgress)\n        : null;\n    };\n    var getDuration = function getDuration() {\n      return Math.min(state.duration, state.perceivedDuration);\n    };\n\n    var api = Object.assign({}, on(), {\n      process: process, // start processing file\n      abort: abort, // abort active process request\n      getProgress: getProgress,\n      getDuration: getDuration,\n      reset: reset\n    });\n\n    return api;\n  };\n\n  var getFilenameWithoutExtension = function getFilenameWithoutExtension(name) {\n    return name.substr(0, name.lastIndexOf('.')) || name;\n  };\n\n  var createFileStub = function createFileStub(source) {\n    var data = [source.name, source.size, source.type];\n\n    // is blob or base64, then we need to set the name\n    if (source instanceof Blob || isBase64DataURI(source)) {\n      data[0] = source.name || getDateString();\n    } else if (isBase64DataURI(source)) {\n      // if is base64 data uri we need to determine the average size and type\n      data[1] = source.length;\n      data[2] = getMimeTypeFromBase64DataURI(source);\n    } else if (isString(source)) {\n      // url\n      data[0] = getFilenameFromURL(source);\n      data[1] = 0;\n      data[2] = 'application/octet-stream';\n    }\n\n    return {\n      name: data[0],\n      size: data[1],\n      type: data[2]\n    };\n  };\n\n  var isFile = function isFile(value) {\n    return !!(value instanceof File || (value instanceof Blob && value.name));\n  };\n\n  var deepCloneObject = function deepCloneObject(src) {\n    if (!isObject(src)) return src;\n    var target = isArray(src) ? [] : {};\n    for (var key in src) {\n      if (!src.hasOwnProperty(key)) continue;\n      var v = src[key];\n      target[key] = v && isObject(v) ? deepCloneObject(v) : v;\n    }\n    return target;\n  };\n\n  var createItem = function createItem() {\n    var origin =\n      arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    var serverFileReference =\n      arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    var file =\n      arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    // unique id for this item, is used to identify the item across views\n    var id = getUniqueId();\n\n    /**\n     * Internal item state\n     */\n    var state = {\n      // is archived\n      archived: false,\n\n      // if is frozen, no longer fires events\n      frozen: false,\n\n      // removed from view\n      released: false,\n\n      // original source\n      source: null,\n\n      // file model reference\n      file: file,\n\n      // id of file on server\n      serverFileReference: serverFileReference,\n\n      // id of file transfer on server\n      transferId: null,\n\n      // is aborted\n      processingAborted: false,\n\n      // current item status\n      status: serverFileReference\n        ? ItemStatus.PROCESSING_COMPLETE\n        : ItemStatus.INIT,\n\n      // active processes\n      activeLoader: null,\n      activeProcessor: null\n    };\n\n    // callback used when abort processing is called to link back to the resolve method\n    var abortProcessingRequestComplete = null;\n\n    /**\n     * Externally added item metadata\n     */\n    var metadata = {};\n\n    // item data\n    var setStatus = function setStatus(status) {\n      return (state.status = status);\n    };\n\n    // fire event unless the item has been archived\n    var fire = function fire(event) {\n      if (state.released || state.frozen) return;\n      for (\n        var _len = arguments.length,\n          params = new Array(_len > 1 ? _len - 1 : 0),\n          _key = 1;\n        _key < _len;\n        _key++\n      ) {\n        params[_key - 1] = arguments[_key];\n      }\n      api.fire.apply(api, [event].concat(params));\n    };\n\n    // file data\n    var getFileExtension = function getFileExtension() {\n      return getExtensionFromFilename(state.file.name);\n    };\n    var getFileType = function getFileType() {\n      return state.file.type;\n    };\n    var getFileSize = function getFileSize() {\n      return state.file.size;\n    };\n    var getFile = function getFile() {\n      return state.file;\n    };\n\n    //\n    // logic to load a file\n    //\n    var load = function load(source, loader, onload) {\n      // remember the original item source\n      state.source = source;\n\n      // source is known\n      api.fireSync('init');\n\n      // file stub is already there\n      if (state.file) {\n        api.fireSync('load-skip');\n        return;\n      }\n\n      // set a stub file object while loading the actual data\n      state.file = createFileStub(source);\n\n      // starts loading\n      loader.on('init', function() {\n        fire('load-init');\n      });\n\n      // we'eve received a size indication, let's update the stub\n      loader.on('meta', function(meta) {\n        // set size of file stub\n        state.file.size = meta.size;\n\n        // set name of file stub\n        state.file.filename = meta.filename;\n\n        // if has received source, we done\n        if (meta.source) {\n          origin = FileOrigin.LIMBO;\n          state.serverFileReference = meta.source;\n          state.status = ItemStatus.PROCESSING_COMPLETE;\n        }\n\n        // size has been updated\n        fire('load-meta');\n      });\n\n      // the file is now loading we need to update the progress indicators\n      loader.on('progress', function(progress) {\n        setStatus(ItemStatus.LOADING);\n\n        fire('load-progress', progress);\n      });\n\n      // an error was thrown while loading the file, we need to switch to error state\n      loader.on('error', function(error) {\n        setStatus(ItemStatus.LOAD_ERROR);\n\n        fire('load-request-error', error);\n      });\n\n      // user or another process aborted the file load (cannot retry)\n      loader.on('abort', function() {\n        setStatus(ItemStatus.INIT);\n        fire('load-abort');\n      });\n\n      // done loading\n      loader.on('load', function(file) {\n        // as we've now loaded the file the loader is no longer required\n        state.activeLoader = null;\n\n        // called when file has loaded succesfully\n        var success = function success(result) {\n          // set (possibly) transformed file\n          state.file = isFile(result) ? result : state.file;\n\n          // file received\n          if (origin === FileOrigin.LIMBO && state.serverFileReference) {\n            setStatus(ItemStatus.PROCESSING_COMPLETE);\n          } else {\n            setStatus(ItemStatus.IDLE);\n          }\n\n          fire('load');\n        };\n\n        var error = function error(result) {\n          // set original file\n          state.file = file;\n          fire('load-meta');\n\n          setStatus(ItemStatus.LOAD_ERROR);\n          fire('load-file-error', result);\n        };\n\n        // if we already have a server file reference, we don't need to call the onload method\n        if (state.serverFileReference) {\n          success(file);\n          return;\n        }\n\n        // no server id, let's give this file the full treatment\n        onload(file, success, error);\n      });\n\n      // set loader source data\n      loader.setSource(source);\n\n      // set as active loader\n      state.activeLoader = loader;\n\n      // load the source data\n      loader.load();\n    };\n\n    var retryLoad = function retryLoad() {\n      if (!state.activeLoader) {\n        return;\n      }\n      state.activeLoader.load();\n    };\n\n    var abortLoad = function abortLoad() {\n      if (state.activeLoader) {\n        state.activeLoader.abort();\n        return;\n      }\n      setStatus(ItemStatus.INIT);\n      fire('load-abort');\n    };\n\n    //\n    // logic to process a file\n    //\n    var process = function process(processor, onprocess) {\n      // processing was aborted\n      if (state.processingAborted) {\n        state.processingAborted = false;\n        return;\n      }\n\n      // now processing\n      setStatus(ItemStatus.PROCESSING);\n\n      // reset abort callback\n      abortProcessingRequestComplete = null;\n\n      // if no file loaded we'll wait for the load event\n      if (!(state.file instanceof Blob)) {\n        api.on('load', function() {\n          process(processor, onprocess);\n        });\n        return;\n      }\n\n      // setup processor\n      processor.on('load', function(serverFileReference) {\n        // need this id to be able to revert the upload\n        state.transferId = null;\n        state.serverFileReference = serverFileReference;\n      });\n\n      // register transfer id\n      processor.on('transfer', function(transferId) {\n        // need this id to be able to revert the upload\n        state.transferId = transferId;\n      });\n\n      processor.on('load-perceived', function(serverFileReference) {\n        // no longer required\n        state.activeProcessor = null;\n\n        // need this id to be able to rever the upload\n        state.transferId = null;\n        state.serverFileReference = serverFileReference;\n\n        setStatus(ItemStatus.PROCESSING_COMPLETE);\n        fire('process-complete', serverFileReference);\n      });\n\n      processor.on('start', function() {\n        fire('process-start');\n      });\n\n      processor.on('error', function(error) {\n        state.activeProcessor = null;\n        setStatus(ItemStatus.PROCESSING_ERROR);\n        fire('process-error', error);\n      });\n\n      processor.on('abort', function(serverFileReference) {\n        state.activeProcessor = null;\n\n        // if file was uploaded but processing was cancelled during perceived processor time store file reference\n        state.transferId = null;\n        state.serverFileReference = serverFileReference;\n\n        setStatus(ItemStatus.IDLE);\n        fire('process-abort');\n\n        // has timeout so doesn't interfere with remove action\n        if (abortProcessingRequestComplete) {\n          abortProcessingRequestComplete();\n        }\n      });\n\n      processor.on('progress', function(progress) {\n        fire('process-progress', progress);\n      });\n\n      // when successfully transformed\n      var success = function success(file) {\n        // if was archived in the mean time, don't process\n        if (state.archived) return;\n\n        // process file!\n        processor.process(file, Object.assign({}, metadata));\n      };\n\n      // something went wrong during transform phase\n      var error = console.error;\n\n      // start processing the file\n      onprocess(state.file, success, error);\n\n      // set as active processor\n      state.activeProcessor = processor;\n    };\n\n    var requestProcessing = function requestProcessing() {\n      state.processingAborted = false;\n      setStatus(ItemStatus.PROCESSING_QUEUED);\n    };\n\n    var abortProcessing = function abortProcessing() {\n      return new Promise(function(resolve) {\n        if (!state.activeProcessor) {\n          state.processingAborted = true;\n\n          setStatus(ItemStatus.IDLE);\n          fire('process-abort');\n\n          resolve();\n          return;\n        }\n\n        abortProcessingRequestComplete = function abortProcessingRequestComplete() {\n          resolve();\n        };\n\n        state.activeProcessor.abort();\n      });\n    };\n\n    //\n    // logic to revert a processed file\n    //\n    var revert = function revert(revertFileUpload, forceRevert) {\n      return new Promise(function(resolve, reject) {\n        // cannot revert without a server id for this process\n        if (state.serverFileReference === null) {\n          resolve();\n          return;\n        }\n\n        // revert the upload (fire and forget)\n        revertFileUpload(\n          state.serverFileReference,\n          function() {\n            // reset file server id as now it's no available on the server\n            state.serverFileReference = null;\n            resolve();\n          },\n          function(error) {\n            // don't set error state when reverting is optional, it will always resolve\n            if (!forceRevert) {\n              resolve();\n              return;\n            }\n\n            // oh no errors\n            setStatus(ItemStatus.PROCESSING_REVERT_ERROR);\n            fire('process-revert-error');\n            reject(error);\n          }\n        );\n\n        // fire event\n        setStatus(ItemStatus.IDLE);\n        fire('process-revert');\n      });\n    };\n\n    // exposed methods\n    var _setMetadata = function setMetadata(key, value, silent) {\n      var keys = key.split('.');\n      var root = keys[0];\n      var last = keys.pop();\n      var data = metadata;\n      keys.forEach(function(key) {\n        return (data = data[key]);\n      });\n\n      // compare old value against new value, if they're the same, we're not updating\n      if (JSON.stringify(data[last]) === JSON.stringify(value)) return;\n\n      // update value\n      data[last] = value;\n\n      // don't fire update\n      if (silent) return;\n\n      // fire update\n      fire('metadata-update', {\n        key: root,\n        value: metadata[root]\n      });\n    };\n\n    var getMetadata = function getMetadata(key) {\n      return deepCloneObject(key ? metadata[key] : metadata);\n    };\n\n    var api = Object.assign(\n      {\n        id: {\n          get: function get() {\n            return id;\n          }\n        },\n        origin: {\n          get: function get() {\n            return origin;\n          }\n        },\n        serverId: {\n          get: function get() {\n            return state.serverFileReference;\n          }\n        },\n        transferId: {\n          get: function get() {\n            return state.transferId;\n          }\n        },\n        status: {\n          get: function get() {\n            return state.status;\n          }\n        },\n        filename: {\n          get: function get() {\n            return state.file.name;\n          }\n        },\n        filenameWithoutExtension: {\n          get: function get() {\n            return getFilenameWithoutExtension(state.file.name);\n          }\n        },\n        fileExtension: { get: getFileExtension },\n        fileType: { get: getFileType },\n        fileSize: { get: getFileSize },\n        file: { get: getFile },\n        relativePath: {\n          get: function get() {\n            return state.file._relativePath;\n          }\n        },\n\n        source: {\n          get: function get() {\n            return state.source;\n          }\n        },\n\n        getMetadata: getMetadata,\n        setMetadata: function setMetadata(key, value, silent) {\n          if (isObject(key)) {\n            var data = key;\n            Object.keys(data).forEach(function(key) {\n              _setMetadata(key, data[key], value);\n            });\n            return key;\n          }\n          _setMetadata(key, value, silent);\n          return value;\n        },\n\n        extend: function extend(name, handler) {\n          return (itemAPI[name] = handler);\n        },\n\n        abortLoad: abortLoad,\n        retryLoad: retryLoad,\n        requestProcessing: requestProcessing,\n        abortProcessing: abortProcessing,\n\n        load: load,\n        process: process,\n        revert: revert\n      },\n\n      on(),\n      {\n        freeze: function freeze() {\n          return (state.frozen = true);\n        },\n\n        release: function release() {\n          return (state.released = true);\n        },\n        released: {\n          get: function get() {\n            return state.released;\n          }\n        },\n\n        archive: function archive() {\n          return (state.archived = true);\n        },\n        archived: {\n          get: function get() {\n            return state.archived;\n          }\n        }\n      }\n    );\n\n    // create it here instead of returning it instantly so we can extend it later\n    var itemAPI = createObject(api);\n\n    return itemAPI;\n  };\n\n  var getItemIndexByQuery = function getItemIndexByQuery(items, query) {\n    // just return first index\n    if (isEmpty(query)) {\n      return 0;\n    }\n\n    // invalid queries\n    if (!isString(query)) {\n      return -1;\n    }\n\n    // return item by id (or -1 if not found)\n    return items.findIndex(function(item) {\n      return item.id === query;\n    });\n  };\n\n  var getItemById = function getItemById(items, itemId) {\n    var index = getItemIndexByQuery(items, itemId);\n    if (index < 0) {\n      return;\n    }\n    return items[index] || null;\n  };\n\n  var fetchBlob = function fetchBlob(\n    url,\n    load,\n    error,\n    progress,\n    abort,\n    headers\n  ) {\n    var request = sendRequest(null, url, {\n      method: 'GET',\n      responseType: 'blob'\n    });\n\n    request.onload = function(xhr) {\n      // get headers\n      var headers = xhr.getAllResponseHeaders();\n\n      // get filename\n      var filename =\n        getFileInfoFromHeaders(headers).name || getFilenameFromURL(url);\n\n      // create response\n      load(\n        createResponse(\n          'load',\n          xhr.status,\n          getFileFromBlob(xhr.response, filename),\n          headers\n        )\n      );\n    };\n\n    request.onerror = function(xhr) {\n      error(\n        createResponse(\n          'error',\n          xhr.status,\n          xhr.statusText,\n          xhr.getAllResponseHeaders()\n        )\n      );\n    };\n\n    request.onheaders = function(xhr) {\n      headers(\n        createResponse('headers', xhr.status, null, xhr.getAllResponseHeaders())\n      );\n    };\n\n    request.ontimeout = createTimeoutResponse(error);\n    request.onprogress = progress;\n    request.onabort = abort;\n\n    // should return request\n    return request;\n  };\n\n  var getDomainFromURL = function getDomainFromURL(url) {\n    if (url.indexOf('//') === 0) {\n      url = location.protocol + url;\n    }\n    return url\n      .toLowerCase()\n      .replace('blob:', '')\n      .replace(/([a-z])?:\\/\\//, '$1')\n      .split('/')[0];\n  };\n\n  var isExternalURL = function isExternalURL(url) {\n    return (\n      (url.indexOf(':') > -1 || url.indexOf('//') > -1) &&\n      getDomainFromURL(location.href) !== getDomainFromURL(url)\n    );\n  };\n\n  var dynamicLabel = function dynamicLabel(label) {\n    return function() {\n      return isFunction(label) ? label.apply(void 0, arguments) : label;\n    };\n  };\n\n  var isMockItem = function isMockItem(item) {\n    return !isFile(item.file);\n  };\n\n  var listUpdated = function listUpdated(dispatch, state) {\n    clearTimeout(state.listUpdateTimeout);\n    state.listUpdateTimeout = setTimeout(function() {\n      dispatch('DID_UPDATE_ITEMS', { items: getActiveItems(state.items) });\n    }, 0);\n  };\n\n  var optionalPromise = function optionalPromise(fn) {\n    for (\n      var _len = arguments.length,\n        params = new Array(_len > 1 ? _len - 1 : 0),\n        _key = 1;\n      _key < _len;\n      _key++\n    ) {\n      params[_key - 1] = arguments[_key];\n    }\n    return new Promise(function(resolve) {\n      if (!fn) {\n        return resolve(true);\n      }\n\n      var result = fn.apply(void 0, params);\n\n      if (result == null) {\n        return resolve(true);\n      }\n\n      if (typeof result === 'boolean') {\n        return resolve(result);\n      }\n\n      if (typeof result.then === 'function') {\n        result.then(resolve);\n      }\n    });\n  };\n\n  var sortItems = function sortItems(state, compare) {\n    state.items.sort(function(a, b) {\n      return compare(createItemAPI(a), createItemAPI(b));\n    });\n  };\n\n  // returns item based on state\n  var getItemByQueryFromState = function getItemByQueryFromState(\n    state,\n    itemHandler\n  ) {\n    return function() {\n      var _ref =\n        arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var query = _ref.query,\n        _ref$success = _ref.success,\n        success = _ref$success === void 0 ? function() {} : _ref$success,\n        _ref$failure = _ref.failure,\n        failure = _ref$failure === void 0 ? function() {} : _ref$failure,\n        options = _objectWithoutProperties(_ref, [\n          'query',\n          'success',\n          'failure'\n        ]);\n      var item = getItemByQuery(state.items, query);\n      if (!item) {\n        failure({\n          error: createResponse('error', 0, 'Item not found'),\n\n          file: null\n        });\n\n        return;\n      }\n      itemHandler(item, success, failure, options || {});\n    };\n  };\n\n  var actions = function actions(dispatch, query, state) {\n    return {\n      /**\n       * Aborts all ongoing processes\n       */\n      ABORT_ALL: function ABORT_ALL() {\n        getActiveItems(state.items).forEach(function(item) {\n          item.freeze();\n          item.abortLoad();\n          item.abortProcessing();\n        });\n      },\n\n      /**\n       * Sets initial files\n       */\n      DID_SET_FILES: function DID_SET_FILES(_ref2) {\n        var _ref2$value = _ref2.value,\n          value = _ref2$value === void 0 ? [] : _ref2$value;\n\n        // map values to file objects\n        var files = value.map(function(file) {\n          return {\n            source: file.source ? file.source : file,\n            options: file.options\n          };\n        });\n\n        // loop over files, if file is in list, leave it be, if not, remove\n        // test if items should be moved\n        var activeItems = getActiveItems(state.items);\n\n        activeItems.forEach(function(item) {\n          // if item not is in new value, remove\n          if (\n            !files.find(function(file) {\n              return file.source === item.source || file.source === item.file;\n            })\n          ) {\n            dispatch('REMOVE_ITEM', { query: item, remove: false });\n          }\n        });\n\n        // add new files\n        activeItems = getActiveItems(state.items);\n        files.forEach(function(file, index) {\n          // if file is already in list\n          if (\n            activeItems.find(function(item) {\n              return item.source === file.source || item.file === file.source;\n            })\n          )\n            return;\n\n          // not in list, add\n          dispatch(\n            'ADD_ITEM',\n            Object.assign({}, file, {\n              interactionMethod: InteractionMethod.NONE,\n              index: index\n            })\n          );\n        });\n      },\n\n      DID_UPDATE_ITEM_METADATA: function DID_UPDATE_ITEM_METADATA(_ref3) {\n        var id = _ref3.id,\n          action = _ref3.action;\n\n        // if is called multiple times in close succession we combined all calls together to save resources\n        clearTimeout(state.itemUpdateTimeout);\n        state.itemUpdateTimeout = setTimeout(function() {\n          var item = getItemById(state.items, id);\n\n          // only revert and attempt to upload when we're uploading to a server\n          if (!query('IS_ASYNC')) {\n            // should we update the output data\n            applyFilterChain('SHOULD_PREPARE_OUTPUT', false, {\n              item: item,\n              query: query,\n              action: action\n            }).then(function(shouldPrepareOutput) {\n              // plugins determined the output data should be prepared (or not), can be adjusted with beforePrepareOutput hook\n              var beforePrepareFile = query('GET_BEFORE_PREPARE_FILE');\n              if (beforePrepareFile)\n                shouldPrepareOutput = beforePrepareFile(\n                  item,\n                  shouldPrepareOutput\n                );\n\n              if (!shouldPrepareOutput) return;\n\n              dispatch(\n                'REQUEST_PREPARE_OUTPUT',\n                {\n                  query: id,\n                  item: item,\n                  success: function success(file) {\n                    dispatch('DID_PREPARE_OUTPUT', { id: id, file: file });\n                  }\n                },\n                true\n              );\n            });\n\n            return;\n          }\n\n          // for async scenarios\n          var upload = function upload() {\n            // we push this forward a bit so the interface is updated correctly\n            setTimeout(function() {\n              dispatch('REQUEST_ITEM_PROCESSING', { query: id });\n            }, 32);\n          };\n\n          var revert = function revert(doUpload) {\n            item\n              .revert(\n                createRevertFunction(\n                  state.options.server.url,\n                  state.options.server.revert\n                ),\n                query('GET_FORCE_REVERT')\n              )\n              .then(doUpload ? upload : function() {})\n              .catch(function() {});\n          };\n\n          var abort = function abort(doUpload) {\n            item.abortProcessing().then(doUpload ? upload : function() {});\n          };\n\n          // if we should re-upload the file immediately\n          if (item.status === ItemStatus.PROCESSING_COMPLETE) {\n            return revert(state.options.instantUpload);\n          }\n\n          // if currently uploading, cancel upload\n          if (item.status === ItemStatus.PROCESSING) {\n            return abort(state.options.instantUpload);\n          }\n\n          if (state.options.instantUpload) {\n            upload();\n          }\n        }, 0);\n      },\n\n      MOVE_ITEM: function MOVE_ITEM(_ref4) {\n        var query = _ref4.query,\n          index = _ref4.index;\n        var item = getItemByQuery(state.items, query);\n        if (!item) return;\n        var currentIndex = state.items.indexOf(item);\n        index = limit(index, 0, state.items.length - 1);\n        if (currentIndex === index) return;\n        state.items.splice(index, 0, state.items.splice(currentIndex, 1)[0]);\n      },\n\n      SORT: function SORT(_ref5) {\n        var compare = _ref5.compare;\n        sortItems(state, compare);\n        dispatch('DID_SORT_ITEMS', {\n          items: query('GET_ACTIVE_ITEMS')\n        });\n      },\n\n      ADD_ITEMS: function ADD_ITEMS(_ref6) {\n        var items = _ref6.items,\n          index = _ref6.index,\n          interactionMethod = _ref6.interactionMethod,\n          _ref6$success = _ref6.success,\n          success = _ref6$success === void 0 ? function() {} : _ref6$success,\n          _ref6$failure = _ref6.failure,\n          failure = _ref6$failure === void 0 ? function() {} : _ref6$failure;\n\n        var currentIndex = index;\n\n        if (index === -1 || typeof index === 'undefined') {\n          var insertLocation = query('GET_ITEM_INSERT_LOCATION');\n          var totalItems = query('GET_TOTAL_ITEMS');\n          currentIndex = insertLocation === 'before' ? 0 : totalItems;\n        }\n\n        var ignoredFiles = query('GET_IGNORED_FILES');\n        var isValidFile = function isValidFile(source) {\n          return isFile(source)\n            ? !ignoredFiles.includes(source.name.toLowerCase())\n            : !isEmpty(source);\n        };\n        var validItems = items.filter(isValidFile);\n\n        var promises = validItems.map(function(source) {\n          return new Promise(function(resolve, reject) {\n            dispatch('ADD_ITEM', {\n              interactionMethod: interactionMethod,\n              source: source.source || source,\n              success: resolve,\n              failure: reject,\n              index: currentIndex++,\n              options: source.options || {}\n            });\n          });\n        });\n\n        Promise.all(promises)\n          .then(success)\n          .catch(failure);\n      },\n\n      /**\n       * @param source\n       * @param index\n       * @param interactionMethod\n       */\n      ADD_ITEM: function ADD_ITEM(_ref7) {\n        var source = _ref7.source,\n          _ref7$index = _ref7.index,\n          index = _ref7$index === void 0 ? -1 : _ref7$index,\n          interactionMethod = _ref7.interactionMethod,\n          _ref7$success = _ref7.success,\n          success = _ref7$success === void 0 ? function() {} : _ref7$success,\n          _ref7$failure = _ref7.failure,\n          failure = _ref7$failure === void 0 ? function() {} : _ref7$failure,\n          _ref7$options = _ref7.options,\n          options = _ref7$options === void 0 ? {} : _ref7$options;\n\n        // if no source supplied\n        if (isEmpty(source)) {\n          failure({\n            error: createResponse('error', 0, 'No source'),\n\n            file: null\n          });\n\n          return;\n        }\n\n        // filter out invalid file items, used to filter dropped directory contents\n        if (\n          isFile(source) &&\n          state.options.ignoredFiles.includes(source.name.toLowerCase())\n        ) {\n          // fail silently\n          return;\n        }\n\n        // test if there's still room in the list of files\n        if (!hasRoomForItem(state)) {\n          // if multiple allowed, we can't replace\n          // or if only a single item is allowed but we're not allowed to replace it we exit\n          if (\n            state.options.allowMultiple ||\n            (!state.options.allowMultiple && !state.options.allowReplace)\n          ) {\n            var error = createResponse('warning', 0, 'Max files');\n\n            dispatch('DID_THROW_MAX_FILES', {\n              source: source,\n              error: error\n            });\n\n            failure({ error: error, file: null });\n\n            return;\n          }\n\n          // let's replace the item\n          // id of first item we're about to remove\n          var _item = getActiveItems(state.items)[0];\n\n          // if has been processed remove it from the server as well\n          if (\n            _item.status === ItemStatus.PROCESSING_COMPLETE ||\n            _item.status === ItemStatus.PROCESSING_REVERT_ERROR\n          ) {\n            var forceRevert = query('GET_FORCE_REVERT');\n            _item\n              .revert(\n                createRevertFunction(\n                  state.options.server.url,\n                  state.options.server.revert\n                ),\n                forceRevert\n              )\n              .then(function() {\n                if (!forceRevert) return;\n\n                // try to add now\n                dispatch('ADD_ITEM', {\n                  source: source,\n                  index: index,\n                  interactionMethod: interactionMethod,\n                  success: success,\n                  failure: failure,\n                  options: options\n                });\n              })\n              .catch(function() {}); // no need to handle this catch state for now\n\n            if (forceRevert) return;\n          }\n\n          // remove first item as it will be replaced by this item\n          dispatch('REMOVE_ITEM', { query: _item.id });\n        }\n\n        // where did the file originate\n        var origin =\n          options.type === 'local'\n            ? FileOrigin.LOCAL\n            : options.type === 'limbo'\n            ? FileOrigin.LIMBO\n            : FileOrigin.INPUT;\n\n        // create a new blank item\n        var item = createItem(\n          // where did this file come from\n          origin,\n\n          // an input file never has a server file reference\n          origin === FileOrigin.INPUT ? null : source,\n\n          // file mock data, if defined\n          options.file\n        );\n\n        // set initial meta data\n        Object.keys(options.metadata || {}).forEach(function(key) {\n          item.setMetadata(key, options.metadata[key]);\n        });\n\n        // created the item, let plugins add methods\n        applyFilters('DID_CREATE_ITEM', item, {\n          query: query,\n          dispatch: dispatch\n        });\n\n        // where to insert new items\n        var itemInsertLocation = query('GET_ITEM_INSERT_LOCATION');\n\n        // adjust index if is not allowed to pick location\n        if (!state.options.itemInsertLocationFreedom) {\n          index = itemInsertLocation === 'before' ? -1 : state.items.length;\n        }\n\n        // add item to list\n        insertItem(state.items, item, index);\n\n        // sort items in list\n        if (isFunction(itemInsertLocation) && source) {\n          sortItems(state, itemInsertLocation);\n        }\n\n        // get a quick reference to the item id\n        var id = item.id;\n\n        // observe item events\n        item.on('init', function() {\n          dispatch('DID_INIT_ITEM', { id: id });\n        });\n\n        item.on('load-init', function() {\n          dispatch('DID_START_ITEM_LOAD', { id: id });\n        });\n\n        item.on('load-meta', function() {\n          dispatch('DID_UPDATE_ITEM_META', { id: id });\n        });\n\n        item.on('load-progress', function(progress) {\n          dispatch('DID_UPDATE_ITEM_LOAD_PROGRESS', {\n            id: id,\n            progress: progress\n          });\n        });\n\n        item.on('load-request-error', function(error) {\n          var mainStatus = dynamicLabel(state.options.labelFileLoadError)(\n            error\n          );\n\n          // is client error, no way to recover\n          if (error.code >= 400 && error.code < 500) {\n            dispatch('DID_THROW_ITEM_INVALID', {\n              id: id,\n              error: error,\n              status: {\n                main: mainStatus,\n                sub: error.code + ' (' + error.body + ')'\n              }\n            });\n\n            // reject the file so can be dealt with through API\n            failure({ error: error, file: createItemAPI(item) });\n            return;\n          }\n\n          // is possible server error, so might be possible to retry\n          dispatch('DID_THROW_ITEM_LOAD_ERROR', {\n            id: id,\n            error: error,\n            status: {\n              main: mainStatus,\n              sub: state.options.labelTapToRetry\n            }\n          });\n        });\n\n        item.on('load-file-error', function(error) {\n          dispatch('DID_THROW_ITEM_INVALID', {\n            id: id,\n            error: error.status,\n            status: error.status\n          });\n\n          failure({ error: error.status, file: createItemAPI(item) });\n        });\n\n        item.on('load-abort', function() {\n          dispatch('REMOVE_ITEM', { query: id });\n        });\n\n        item.on('load-skip', function() {\n          dispatch('COMPLETE_LOAD_ITEM', {\n            query: id,\n            item: item,\n            data: {\n              source: source,\n              success: success\n            }\n          });\n        });\n\n        item.on('load', function() {\n          var handleAdd = function handleAdd(shouldAdd) {\n            // no should not add this file\n            if (!shouldAdd) {\n              dispatch('REMOVE_ITEM', {\n                query: id\n              });\n\n              return;\n            }\n\n            // now interested in metadata updates\n            item.on('metadata-update', function(change) {\n              dispatch('DID_UPDATE_ITEM_METADATA', { id: id, change: change });\n            });\n\n            // let plugins decide if the output data should be prepared at this point\n            // means we'll do this and wait for idle state\n            applyFilterChain('SHOULD_PREPARE_OUTPUT', false, {\n              item: item,\n              query: query\n            }).then(function(shouldPrepareOutput) {\n              // plugins determined the output data should be prepared (or not), can be adjusted with beforePrepareOutput hook\n              var beforePrepareFile = query('GET_BEFORE_PREPARE_FILE');\n              if (beforePrepareFile)\n                shouldPrepareOutput = beforePrepareFile(\n                  item,\n                  shouldPrepareOutput\n                );\n\n              var loadComplete = function loadComplete() {\n                dispatch('COMPLETE_LOAD_ITEM', {\n                  query: id,\n                  item: item,\n                  data: {\n                    source: source,\n                    success: success\n                  }\n                });\n\n                listUpdated(dispatch, state);\n              };\n\n              // exit\n              if (shouldPrepareOutput) {\n                // wait for idle state and then run PREPARE_OUTPUT\n                dispatch(\n                  'REQUEST_PREPARE_OUTPUT',\n                  {\n                    query: id,\n                    item: item,\n                    success: function success(file) {\n                      dispatch('DID_PREPARE_OUTPUT', { id: id, file: file });\n                      loadComplete();\n                    }\n                  },\n                  true\n                );\n\n                return;\n              }\n\n              loadComplete();\n            });\n          };\n\n          // item loaded, allow plugins to\n          // - read data (quickly)\n          // - add metadata\n          applyFilterChain('DID_LOAD_ITEM', item, {\n            query: query,\n            dispatch: dispatch\n          })\n            .then(function() {\n              optionalPromise(\n                query('GET_BEFORE_ADD_FILE'),\n                createItemAPI(item)\n              ).then(handleAdd);\n            })\n            .catch(function() {\n              handleAdd(false);\n            });\n        });\n\n        item.on('process-start', function() {\n          dispatch('DID_START_ITEM_PROCESSING', { id: id });\n        });\n\n        item.on('process-progress', function(progress) {\n          dispatch('DID_UPDATE_ITEM_PROCESS_PROGRESS', {\n            id: id,\n            progress: progress\n          });\n        });\n\n        item.on('process-error', function(error) {\n          dispatch('DID_THROW_ITEM_PROCESSING_ERROR', {\n            id: id,\n            error: error,\n            status: {\n              main: dynamicLabel(state.options.labelFileProcessingError)(error),\n              sub: state.options.labelTapToRetry\n            }\n          });\n        });\n\n        item.on('process-revert-error', function(error) {\n          dispatch('DID_THROW_ITEM_PROCESSING_REVERT_ERROR', {\n            id: id,\n            error: error,\n            status: {\n              main: dynamicLabel(state.options.labelFileProcessingRevertError)(\n                error\n              ),\n              sub: state.options.labelTapToRetry\n            }\n          });\n        });\n\n        item.on('process-complete', function(serverFileReference) {\n          dispatch('DID_COMPLETE_ITEM_PROCESSING', {\n            id: id,\n            error: null,\n            serverFileReference: serverFileReference\n          });\n\n          dispatch('DID_DEFINE_VALUE', { id: id, value: serverFileReference });\n        });\n\n        item.on('process-abort', function() {\n          dispatch('DID_ABORT_ITEM_PROCESSING', { id: id });\n        });\n\n        item.on('process-revert', function() {\n          dispatch('DID_REVERT_ITEM_PROCESSING', { id: id });\n          dispatch('DID_DEFINE_VALUE', { id: id, value: null });\n        });\n\n        // let view know the item has been inserted\n        dispatch('DID_ADD_ITEM', {\n          id: id,\n          index: index,\n          interactionMethod: interactionMethod\n        });\n\n        listUpdated(dispatch, state);\n\n        // start loading the source\n        var _ref8 = state.options.server || {},\n          url = _ref8.url,\n          load = _ref8.load,\n          restore = _ref8.restore,\n          fetch = _ref8.fetch;\n\n        item.load(\n          source,\n\n          // this creates a function that loads the file based on the type of file (string, base64, blob, file) and location of file (local, remote, limbo)\n          createFileLoader(\n            origin === FileOrigin.INPUT\n              ? // input, if is remote, see if should use custom fetch, else use default fetchBlob\n                isString(source) && isExternalURL(source)\n                ? fetch\n                  ? createFetchFunction(url, fetch)\n                  : fetchBlob // remote url\n                : fetchBlob // try to fetch url\n              : // limbo or local\n              origin === FileOrigin.LIMBO\n              ? createFetchFunction(url, restore) // limbo\n              : createFetchFunction(url, load) // local\n          ),\n\n          // called when the file is loaded so it can be piped through the filters\n          function(file, success, error) {\n            // let's process the file\n            applyFilterChain('LOAD_FILE', file, { query: query })\n              .then(success)\n              .catch(error);\n          }\n        );\n      },\n\n      REQUEST_PREPARE_OUTPUT: function REQUEST_PREPARE_OUTPUT(_ref9) {\n        var item = _ref9.item,\n          success = _ref9.success,\n          _ref9$failure = _ref9.failure,\n          failure = _ref9$failure === void 0 ? function() {} : _ref9$failure;\n\n        // error response if item archived\n        var err = {\n          error: createResponse('error', 0, 'Item not found'),\n\n          file: null\n        };\n\n        // don't handle archived items, an item could have been archived (load aborted) while waiting to be prepared\n        if (item.archived) return failure(err);\n\n        // allow plugins to alter the file data\n        applyFilterChain('PREPARE_OUTPUT', item.file, {\n          query: query,\n          item: item\n        }).then(function(result) {\n          applyFilterChain('COMPLETE_PREPARE_OUTPUT', result, {\n            query: query,\n            item: item\n          }).then(function(result) {\n            // don't handle archived items, an item could have been archived (load aborted) while being prepared\n            if (item.archived) return failure(err);\n\n            // we done!\n            success(result);\n          });\n        });\n      },\n\n      COMPLETE_LOAD_ITEM: function COMPLETE_LOAD_ITEM(_ref10) {\n        var item = _ref10.item,\n          data = _ref10.data;\n        var success = data.success,\n          source = data.source;\n\n        // sort items in list\n        var itemInsertLocation = query('GET_ITEM_INSERT_LOCATION');\n        if (isFunction(itemInsertLocation) && source) {\n          sortItems(state, itemInsertLocation);\n        }\n\n        // let interface know the item has loaded\n        dispatch('DID_LOAD_ITEM', {\n          id: item.id,\n          error: null,\n          serverFileReference: item.origin === FileOrigin.INPUT ? null : source\n        });\n\n        // item has been successfully loaded and added to the\n        // list of items so can now be safely returned for use\n        success(createItemAPI(item));\n\n        // if this is a local server file we need to show a different state\n        if (item.origin === FileOrigin.LOCAL) {\n          dispatch('DID_LOAD_LOCAL_ITEM', { id: item.id });\n          return;\n        }\n\n        // if is a temp server file we prevent async upload call here (as the file is already on the server)\n        if (item.origin === FileOrigin.LIMBO) {\n          dispatch('DID_COMPLETE_ITEM_PROCESSING', {\n            id: item.id,\n            error: null,\n            serverFileReference: source\n          });\n\n          dispatch('DID_DEFINE_VALUE', {\n            id: item.id,\n            value: source\n          });\n\n          return;\n        }\n\n        // id we are allowed to upload the file immediately, lets do it\n        if (query('IS_ASYNC') && state.options.instantUpload) {\n          dispatch('REQUEST_ITEM_PROCESSING', { query: item.id });\n        }\n      },\n\n      RETRY_ITEM_LOAD: getItemByQueryFromState(state, function(item) {\n        // try loading the source one more time\n        item.retryLoad();\n      }),\n\n      REQUEST_ITEM_PREPARE: getItemByQueryFromState(state, function(\n        item,\n        _success,\n        failure\n      ) {\n        dispatch(\n          'REQUEST_PREPARE_OUTPUT',\n          {\n            query: item.id,\n            item: item,\n            success: function success(file) {\n              dispatch('DID_PREPARE_OUTPUT', { id: item.id, file: file });\n              _success({\n                file: item,\n                output: file\n              });\n            },\n            failure: failure\n          },\n          true\n        );\n      }),\n\n      REQUEST_ITEM_PROCESSING: getItemByQueryFromState(state, function(\n        item,\n        success,\n        failure\n      ) {\n        // cannot be queued (or is already queued)\n        var itemCanBeQueuedForProcessing =\n          // waiting for something\n          item.status === ItemStatus.IDLE ||\n          // processing went wrong earlier\n          item.status === ItemStatus.PROCESSING_ERROR;\n\n        // not ready to be processed\n        if (!itemCanBeQueuedForProcessing) {\n          var processNow = function processNow() {\n            return dispatch('REQUEST_ITEM_PROCESSING', {\n              query: item,\n              success: success,\n              failure: failure\n            });\n          };\n\n          var process = function process() {\n            return document.hidden ? processNow() : setTimeout(processNow, 32);\n          };\n\n          // if already done processing or tried to revert but didn't work, try again\n          if (\n            item.status === ItemStatus.PROCESSING_COMPLETE ||\n            item.status === ItemStatus.PROCESSING_REVERT_ERROR\n          ) {\n            item\n              .revert(\n                createRevertFunction(\n                  state.options.server.url,\n                  state.options.server.revert\n                ),\n                query('GET_FORCE_REVERT')\n              )\n              .then(process)\n              .catch(function() {}); // don't continue with processing if something went wrong\n          } else if (item.status === ItemStatus.PROCESSING) {\n            item.abortProcessing().then(process);\n          }\n\n          return;\n        }\n\n        // already queued for processing\n        if (item.status === ItemStatus.PROCESSING_QUEUED) return;\n\n        item.requestProcessing();\n\n        dispatch('DID_REQUEST_ITEM_PROCESSING', { id: item.id });\n\n        dispatch(\n          'PROCESS_ITEM',\n          { query: item, success: success, failure: failure },\n          true\n        );\n      }),\n\n      PROCESS_ITEM: getItemByQueryFromState(state, function(\n        item,\n        success,\n        failure\n      ) {\n        var maxParallelUploads = query('GET_MAX_PARALLEL_UPLOADS');\n        var totalCurrentUploads = query(\n          'GET_ITEMS_BY_STATUS',\n          ItemStatus.PROCESSING\n        ).length;\n\n        // queue and wait till queue is freed up\n        if (totalCurrentUploads === maxParallelUploads) {\n          // queue for later processing\n          state.processingQueue.push({\n            id: item.id,\n            success: success,\n            failure: failure\n          });\n\n          // stop it!\n          return;\n        }\n\n        // if was not queued or is already processing exit here\n        if (item.status === ItemStatus.PROCESSING) return;\n\n        var processNext = function processNext() {\n          // process queueud items\n          var queueEntry = state.processingQueue.shift();\n\n          // no items left\n          if (!queueEntry) return;\n\n          // get item reference\n          var id = queueEntry.id,\n            success = queueEntry.success,\n            failure = queueEntry.failure;\n          var itemReference = getItemByQuery(state.items, id);\n\n          // if item was archived while in queue, jump to next\n          if (!itemReference || itemReference.archived) {\n            processNext();\n            return;\n          }\n\n          // process queued item\n          dispatch(\n            'PROCESS_ITEM',\n            { query: id, success: success, failure: failure },\n            true\n          );\n        };\n\n        // we done function\n        item.onOnce('process-complete', function() {\n          success(createItemAPI(item));\n          processNext();\n\n          // All items processed? No errors?\n          var allItemsProcessed =\n            query('GET_ITEMS_BY_STATUS', ItemStatus.PROCESSING_COMPLETE)\n              .length === state.items.length;\n          if (allItemsProcessed) {\n            dispatch('DID_COMPLETE_ITEM_PROCESSING_ALL');\n          }\n        });\n\n        // we error function\n        item.onOnce('process-error', function(error) {\n          failure({ error: error, file: createItemAPI(item) });\n          processNext();\n        });\n\n        // start file processing\n        var options = state.options;\n        item.process(\n          createFileProcessor(\n            createProcessorFunction(\n              options.server.url,\n              options.server.process,\n              options.name,\n              {\n                chunkTransferId: item.transferId,\n                chunkServer: options.server.patch,\n                chunkUploads: options.chunkUploads,\n                chunkForce: options.chunkForce,\n                chunkSize: options.chunkSize,\n                chunkRetryDelays: options.chunkRetryDelays\n              }\n            )\n          ),\n\n          // called when the file is about to be processed so it can be piped through the transform filters\n          function(file, success, error) {\n            // allow plugins to alter the file data\n            applyFilterChain('PREPARE_OUTPUT', file, {\n              query: query,\n              item: item\n            })\n              .then(function(file) {\n                dispatch('DID_PREPARE_OUTPUT', { id: item.id, file: file });\n\n                success(file);\n              })\n              .catch(error);\n          }\n        );\n      }),\n\n      RETRY_ITEM_PROCESSING: getItemByQueryFromState(state, function(item) {\n        dispatch('REQUEST_ITEM_PROCESSING', { query: item });\n      }),\n\n      REQUEST_REMOVE_ITEM: getItemByQueryFromState(state, function(item) {\n        optionalPromise(\n          query('GET_BEFORE_REMOVE_FILE'),\n          createItemAPI(item)\n        ).then(function(shouldRemove) {\n          if (!shouldRemove) {\n            return;\n          }\n          dispatch('REMOVE_ITEM', { query: item });\n        });\n      }),\n\n      RELEASE_ITEM: getItemByQueryFromState(state, function(item) {\n        item.release();\n      }),\n\n      REMOVE_ITEM: getItemByQueryFromState(state, function(\n        item,\n        success,\n        failure,\n        options\n      ) {\n        var removeFromView = function removeFromView() {\n          // get id reference\n          var id = item.id;\n\n          // archive the item, this does not remove it from the list\n          getItemById(state.items, id).archive();\n\n          // tell the view the item has been removed\n          dispatch('DID_REMOVE_ITEM', { error: null, id: id, item: item });\n\n          // now the list has been modified\n          listUpdated(dispatch, state);\n\n          // correctly removed\n          success(createItemAPI(item));\n        };\n\n        // if this is a local file and the server.remove function has been configured, send source there so dev can remove file from server\n        var server = state.options.server;\n        if (\n          item.origin === FileOrigin.LOCAL &&\n          server &&\n          isFunction(server.remove) &&\n          options.remove !== false\n        ) {\n          dispatch('DID_START_ITEM_REMOVE', { id: item.id });\n\n          server.remove(\n            item.source,\n            function() {\n              return removeFromView();\n            },\n            function(status) {\n              dispatch('DID_THROW_ITEM_REMOVE_ERROR', {\n                id: item.id,\n                error: createResponse('error', 0, status, null),\n                status: {\n                  main: dynamicLabel(state.options.labelFileRemoveError)(\n                    status\n                  ),\n                  sub: state.options.labelTapToRetry\n                }\n              });\n            }\n          );\n        } else {\n          // if is requesting revert and can revert need to call revert handler (not calling request_ because that would also trigger beforeRemoveHook)\n          if (\n            options.revert &&\n            item.origin !== FileOrigin.LOCAL &&\n            item.serverId !== null\n          ) {\n            item.revert(\n              createRevertFunction(\n                state.options.server.url,\n                state.options.server.revert\n              ),\n              query('GET_FORCE_REVERT')\n            );\n          }\n\n          // can now safely remove from view\n          removeFromView();\n        }\n      }),\n\n      ABORT_ITEM_LOAD: getItemByQueryFromState(state, function(item) {\n        item.abortLoad();\n      }),\n\n      ABORT_ITEM_PROCESSING: getItemByQueryFromState(state, function(item) {\n        // test if is already processed\n        if (item.serverId) {\n          dispatch('REVERT_ITEM_PROCESSING', { id: item.id });\n          return;\n        }\n\n        // abort\n        item.abortProcessing().then(function() {\n          var shouldRemove = state.options.instantUpload;\n          if (shouldRemove) {\n            dispatch('REMOVE_ITEM', { query: item.id });\n          }\n        });\n      }),\n\n      REQUEST_REVERT_ITEM_PROCESSING: getItemByQueryFromState(state, function(\n        item\n      ) {\n        // not instant uploading, revert immediately\n        if (!state.options.instantUpload) {\n          dispatch('REVERT_ITEM_PROCESSING', { query: item });\n          return;\n        }\n\n        // if we're instant uploading the file will also be removed if we revert,\n        // so if a before remove file hook is defined we need to run it now\n        var handleRevert = function handleRevert(shouldRevert) {\n          if (!shouldRevert) return;\n          dispatch('REVERT_ITEM_PROCESSING', { query: item });\n        };\n\n        var fn = query('GET_BEFORE_REMOVE_FILE');\n        if (!fn) {\n          return handleRevert(true);\n        }\n\n        var requestRemoveResult = fn(createItemAPI(item));\n        if (requestRemoveResult == null) {\n          // undefined or null\n          return handleRevert(true);\n        }\n\n        if (typeof requestRemoveResult === 'boolean') {\n          return handleRevert(requestRemoveResult);\n        }\n\n        if (typeof requestRemoveResult.then === 'function') {\n          requestRemoveResult.then(handleRevert);\n        }\n      }),\n\n      REVERT_ITEM_PROCESSING: getItemByQueryFromState(state, function(item) {\n        item\n          .revert(\n            createRevertFunction(\n              state.options.server.url,\n              state.options.server.revert\n            ),\n            query('GET_FORCE_REVERT')\n          )\n          .then(function() {\n            var shouldRemove = state.options.instantUpload || isMockItem(item);\n            if (shouldRemove) {\n              dispatch('REMOVE_ITEM', { query: item.id });\n            }\n          })\n          .catch(function() {});\n      }),\n\n      SET_OPTIONS: function SET_OPTIONS(_ref11) {\n        var options = _ref11.options;\n        forin(options, function(key, value) {\n          dispatch('SET_' + fromCamels(key, '_').toUpperCase(), {\n            value: value\n          });\n        });\n      }\n    };\n  };\n\n  var formatFilename = function formatFilename(name) {\n    return name;\n  };\n\n  var createElement$1 = function createElement(tagName) {\n    return document.createElement(tagName);\n  };\n\n  var text = function text(node, value) {\n    var textNode = node.childNodes[0];\n    if (!textNode) {\n      textNode = document.createTextNode(value);\n      node.appendChild(textNode);\n    } else if (value !== textNode.nodeValue) {\n      textNode.nodeValue = value;\n    }\n  };\n\n  var polarToCartesian = function polarToCartesian(\n    centerX,\n    centerY,\n    radius,\n    angleInDegrees\n  ) {\n    var angleInRadians = (((angleInDegrees % 360) - 90) * Math.PI) / 180.0;\n    return {\n      x: centerX + radius * Math.cos(angleInRadians),\n      y: centerY + radius * Math.sin(angleInRadians)\n    };\n  };\n\n  var describeArc = function describeArc(\n    x,\n    y,\n    radius,\n    startAngle,\n    endAngle,\n    arcSweep\n  ) {\n    var start = polarToCartesian(x, y, radius, endAngle);\n    var end = polarToCartesian(x, y, radius, startAngle);\n    return [\n      'M',\n      start.x,\n      start.y,\n      'A',\n      radius,\n      radius,\n      0,\n      arcSweep,\n      0,\n      end.x,\n      end.y\n    ].join(' ');\n  };\n\n  var percentageArc = function percentageArc(x, y, radius, from, to) {\n    var arcSweep = 1;\n    if (to > from && to - from <= 0.5) {\n      arcSweep = 0;\n    }\n    if (from > to && from - to >= 0.5) {\n      arcSweep = 0;\n    }\n    return describeArc(\n      x,\n      y,\n      radius,\n      Math.min(0.9999, from) * 360,\n      Math.min(0.9999, to) * 360,\n      arcSweep\n    );\n  };\n\n  var create = function create(_ref) {\n    var root = _ref.root,\n      props = _ref.props;\n    // start at 0\n    props.spin = false;\n    props.progress = 0;\n    props.opacity = 0;\n\n    // svg\n    var svg = createElement('svg');\n    root.ref.path = createElement('path', {\n      'stroke-width': 2,\n      'stroke-linecap': 'round'\n    });\n\n    svg.appendChild(root.ref.path);\n\n    root.ref.svg = svg;\n\n    root.appendChild(svg);\n  };\n\n  var write = function write(_ref2) {\n    var root = _ref2.root,\n      props = _ref2.props;\n\n    if (props.opacity === 0) {\n      return;\n    }\n\n    if (props.align) {\n      root.element.dataset.align = props.align;\n    }\n\n    // get width of stroke\n    var ringStrokeWidth = parseInt(attr(root.ref.path, 'stroke-width'), 10);\n\n    // calculate size of ring\n    var size = root.rect.element.width * 0.5;\n\n    // ring state\n    var ringFrom = 0;\n    var ringTo = 0;\n\n    // now in busy mode\n    if (props.spin) {\n      ringFrom = 0;\n      ringTo = 0.5;\n    } else {\n      ringFrom = 0;\n      ringTo = props.progress;\n    }\n\n    // get arc path\n    var coordinates = percentageArc(\n      size,\n      size,\n      size - ringStrokeWidth,\n      ringFrom,\n      ringTo\n    );\n\n    // update progress bar\n    attr(root.ref.path, 'd', coordinates);\n\n    // hide while contains 0 value\n    attr(\n      root.ref.path,\n      'stroke-opacity',\n      props.spin || props.progress > 0 ? 1 : 0\n    );\n  };\n\n  var progressIndicator = createView({\n    tag: 'div',\n    name: 'progress-indicator',\n    ignoreRectUpdate: true,\n    ignoreRect: true,\n    create: create,\n    write: write,\n    mixins: {\n      apis: ['progress', 'spin', 'align'],\n      styles: ['opacity'],\n      animations: {\n        opacity: { type: 'tween', duration: 500 },\n        progress: {\n          type: 'spring',\n          stiffness: 0.95,\n          damping: 0.65,\n          mass: 10\n        }\n      }\n    }\n  });\n\n  var create$1 = function create(_ref) {\n    var root = _ref.root,\n      props = _ref.props;\n    root.element.innerHTML =\n      (props.icon || '') + ('<span>' + props.label + '</span>');\n\n    props.isDisabled = false;\n  };\n\n  var write$1 = function write(_ref2) {\n    var root = _ref2.root,\n      props = _ref2.props;\n    var isDisabled = props.isDisabled;\n    var shouldDisable = root.query('GET_DISABLED') || props.opacity === 0;\n\n    if (shouldDisable && !isDisabled) {\n      props.isDisabled = true;\n      attr(root.element, 'disabled', 'disabled');\n    } else if (!shouldDisable && isDisabled) {\n      props.isDisabled = false;\n      root.element.removeAttribute('disabled');\n    }\n  };\n\n  var fileActionButton = createView({\n    tag: 'button',\n    attributes: {\n      type: 'button'\n    },\n\n    ignoreRect: true,\n    ignoreRectUpdate: true,\n    name: 'file-action-button',\n    mixins: {\n      apis: ['label'],\n      styles: ['translateX', 'translateY', 'scaleX', 'scaleY', 'opacity'],\n      animations: {\n        scaleX: 'spring',\n        scaleY: 'spring',\n        translateX: 'spring',\n        translateY: 'spring',\n        opacity: { type: 'tween', duration: 250 }\n      },\n\n      listeners: true\n    },\n\n    create: create$1,\n    write: write$1\n  });\n\n  var toNaturalFileSize = function toNaturalFileSize(bytes) {\n    var decimalSeparator =\n      arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '.';\n    var base =\n      arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1000;\n    // no negative byte sizes\n    bytes = Math.round(Math.abs(bytes));\n\n    var KB = base;\n    var MB = base * base;\n    var GB = base * base * base;\n\n    // just bytes\n    if (bytes < KB) {\n      return bytes + ' bytes';\n    }\n\n    // kilobytes\n    if (bytes < MB) {\n      return Math.floor(bytes / KB) + ' KB';\n    }\n\n    // megabytes\n    if (bytes < GB) {\n      return removeDecimalsWhenZero(bytes / MB, 1, decimalSeparator) + ' MB';\n    }\n\n    // gigabytes\n    return removeDecimalsWhenZero(bytes / GB, 2, decimalSeparator) + ' GB';\n  };\n\n  var removeDecimalsWhenZero = function removeDecimalsWhenZero(\n    value,\n    decimalCount,\n    separator\n  ) {\n    return value\n      .toFixed(decimalCount)\n      .split('.')\n      .filter(function(part) {\n        return part !== '0';\n      })\n      .join(separator);\n  };\n\n  var create$2 = function create(_ref) {\n    var root = _ref.root,\n      props = _ref.props;\n    // filename\n    var fileName = createElement$1('span');\n    fileName.className = 'filepond--file-info-main';\n    // hide for screenreaders\n    // the file is contained in a fieldset with legend that contains the filename\n    // no need to read it twice\n    attr(fileName, 'aria-hidden', 'true');\n    root.appendChild(fileName);\n    root.ref.fileName = fileName;\n\n    // filesize\n    var fileSize = createElement$1('span');\n    fileSize.className = 'filepond--file-info-sub';\n    root.appendChild(fileSize);\n    root.ref.fileSize = fileSize;\n\n    // set initial values\n    text(fileSize, root.query('GET_LABEL_FILE_WAITING_FOR_SIZE'));\n    text(fileName, formatFilename(root.query('GET_ITEM_NAME', props.id)));\n  };\n\n  var updateFile = function updateFile(_ref2) {\n    var root = _ref2.root,\n      props = _ref2.props;\n    text(\n      root.ref.fileSize,\n      toNaturalFileSize(\n        root.query('GET_ITEM_SIZE', props.id),\n        '.',\n        root.query('GET_FILE_SIZE_BASE')\n      )\n    );\n\n    text(\n      root.ref.fileName,\n      formatFilename(root.query('GET_ITEM_NAME', props.id))\n    );\n  };\n\n  var updateFileSizeOnError = function updateFileSizeOnError(_ref3) {\n    var root = _ref3.root,\n      props = _ref3.props;\n    // if size is available don't fallback to unknown size message\n    if (isInt(root.query('GET_ITEM_SIZE', props.id))) {\n      return;\n    }\n\n    text(root.ref.fileSize, root.query('GET_LABEL_FILE_SIZE_NOT_AVAILABLE'));\n  };\n\n  var fileInfo = createView({\n    name: 'file-info',\n    ignoreRect: true,\n    ignoreRectUpdate: true,\n    write: createRoute({\n      DID_LOAD_ITEM: updateFile,\n      DID_UPDATE_ITEM_META: updateFile,\n      DID_THROW_ITEM_LOAD_ERROR: updateFileSizeOnError,\n      DID_THROW_ITEM_INVALID: updateFileSizeOnError\n    }),\n\n    didCreateView: function didCreateView(root) {\n      applyFilters('CREATE_VIEW', Object.assign({}, root, { view: root }));\n    },\n    create: create$2,\n    mixins: {\n      styles: ['translateX', 'translateY'],\n      animations: {\n        translateX: 'spring',\n        translateY: 'spring'\n      }\n    }\n  });\n\n  var toPercentage = function toPercentage(value) {\n    return Math.round(value * 100);\n  };\n\n  var create$3 = function create(_ref) {\n    var root = _ref.root;\n\n    // main status\n    var main = createElement$1('span');\n    main.className = 'filepond--file-status-main';\n    root.appendChild(main);\n    root.ref.main = main;\n\n    // sub status\n    var sub = createElement$1('span');\n    sub.className = 'filepond--file-status-sub';\n    root.appendChild(sub);\n    root.ref.sub = sub;\n\n    didSetItemLoadProgress({ root: root, action: { progress: null } });\n  };\n\n  var didSetItemLoadProgress = function didSetItemLoadProgress(_ref2) {\n    var root = _ref2.root,\n      action = _ref2.action;\n    var title =\n      action.progress === null\n        ? root.query('GET_LABEL_FILE_LOADING')\n        : root.query('GET_LABEL_FILE_LOADING') +\n          ' ' +\n          toPercentage(action.progress) +\n          '%';\n\n    text(root.ref.main, title);\n    text(root.ref.sub, root.query('GET_LABEL_TAP_TO_CANCEL'));\n  };\n\n  var didSetItemProcessProgress = function didSetItemProcessProgress(_ref3) {\n    var root = _ref3.root,\n      action = _ref3.action;\n    var title =\n      action.progress === null\n        ? root.query('GET_LABEL_FILE_PROCESSING')\n        : root.query('GET_LABEL_FILE_PROCESSING') +\n          ' ' +\n          toPercentage(action.progress) +\n          '%';\n\n    text(root.ref.main, title);\n    text(root.ref.sub, root.query('GET_LABEL_TAP_TO_CANCEL'));\n  };\n\n  var didRequestItemProcessing = function didRequestItemProcessing(_ref4) {\n    var root = _ref4.root;\n    text(root.ref.main, root.query('GET_LABEL_FILE_PROCESSING'));\n    text(root.ref.sub, root.query('GET_LABEL_TAP_TO_CANCEL'));\n  };\n\n  var didAbortItemProcessing = function didAbortItemProcessing(_ref5) {\n    var root = _ref5.root;\n    text(root.ref.main, root.query('GET_LABEL_FILE_PROCESSING_ABORTED'));\n    text(root.ref.sub, root.query('GET_LABEL_TAP_TO_RETRY'));\n  };\n\n  var didCompleteItemProcessing = function didCompleteItemProcessing(_ref6) {\n    var root = _ref6.root;\n    text(root.ref.main, root.query('GET_LABEL_FILE_PROCESSING_COMPLETE'));\n    text(root.ref.sub, root.query('GET_LABEL_TAP_TO_UNDO'));\n  };\n\n  var clear = function clear(_ref7) {\n    var root = _ref7.root;\n    text(root.ref.main, '');\n    text(root.ref.sub, '');\n  };\n\n  var error = function error(_ref8) {\n    var root = _ref8.root,\n      action = _ref8.action;\n    text(root.ref.main, action.status.main);\n    text(root.ref.sub, action.status.sub);\n  };\n\n  var fileStatus = createView({\n    name: 'file-status',\n    ignoreRect: true,\n    ignoreRectUpdate: true,\n    write: createRoute({\n      DID_LOAD_ITEM: clear,\n      DID_REVERT_ITEM_PROCESSING: clear,\n      DID_REQUEST_ITEM_PROCESSING: didRequestItemProcessing,\n      DID_ABORT_ITEM_PROCESSING: didAbortItemProcessing,\n      DID_COMPLETE_ITEM_PROCESSING: didCompleteItemProcessing,\n      DID_UPDATE_ITEM_PROCESS_PROGRESS: didSetItemProcessProgress,\n      DID_UPDATE_ITEM_LOAD_PROGRESS: didSetItemLoadProgress,\n      DID_THROW_ITEM_LOAD_ERROR: error,\n      DID_THROW_ITEM_INVALID: error,\n      DID_THROW_ITEM_PROCESSING_ERROR: error,\n      DID_THROW_ITEM_PROCESSING_REVERT_ERROR: error,\n      DID_THROW_ITEM_REMOVE_ERROR: error\n    }),\n\n    didCreateView: function didCreateView(root) {\n      applyFilters('CREATE_VIEW', Object.assign({}, root, { view: root }));\n    },\n    create: create$3,\n    mixins: {\n      styles: ['translateX', 'translateY', 'opacity'],\n      animations: {\n        opacity: { type: 'tween', duration: 250 },\n        translateX: 'spring',\n        translateY: 'spring'\n      }\n    }\n  });\n\n  /**\n   * Button definitions for the file view\n   */\n\n  var Buttons = {\n    AbortItemLoad: {\n      label: 'GET_LABEL_BUTTON_ABORT_ITEM_LOAD',\n      action: 'ABORT_ITEM_LOAD',\n      className: 'filepond--action-abort-item-load',\n      align: 'LOAD_INDICATOR_POSITION' // right\n    },\n    RetryItemLoad: {\n      label: 'GET_LABEL_BUTTON_RETRY_ITEM_LOAD',\n      action: 'RETRY_ITEM_LOAD',\n      icon: 'GET_ICON_RETRY',\n      className: 'filepond--action-retry-item-load',\n      align: 'BUTTON_PROCESS_ITEM_POSITION' // right\n    },\n    RemoveItem: {\n      label: 'GET_LABEL_BUTTON_REMOVE_ITEM',\n      action: 'REQUEST_REMOVE_ITEM',\n      icon: 'GET_ICON_REMOVE',\n      className: 'filepond--action-remove-item',\n      align: 'BUTTON_REMOVE_ITEM_POSITION' // left\n    },\n    ProcessItem: {\n      label: 'GET_LABEL_BUTTON_PROCESS_ITEM',\n      action: 'REQUEST_ITEM_PROCESSING',\n      icon: 'GET_ICON_PROCESS',\n      className: 'filepond--action-process-item',\n      align: 'BUTTON_PROCESS_ITEM_POSITION' // right\n    },\n    AbortItemProcessing: {\n      label: 'GET_LABEL_BUTTON_ABORT_ITEM_PROCESSING',\n      action: 'ABORT_ITEM_PROCESSING',\n      className: 'filepond--action-abort-item-processing',\n      align: 'BUTTON_PROCESS_ITEM_POSITION' // right\n    },\n    RetryItemProcessing: {\n      label: 'GET_LABEL_BUTTON_RETRY_ITEM_PROCESSING',\n      action: 'RETRY_ITEM_PROCESSING',\n      icon: 'GET_ICON_RETRY',\n      className: 'filepond--action-retry-item-processing',\n      align: 'BUTTON_PROCESS_ITEM_POSITION' // right\n    },\n    RevertItemProcessing: {\n      label: 'GET_LABEL_BUTTON_UNDO_ITEM_PROCESSING',\n      action: 'REQUEST_REVERT_ITEM_PROCESSING',\n      icon: 'GET_ICON_UNDO',\n      className: 'filepond--action-revert-item-processing',\n      align: 'BUTTON_PROCESS_ITEM_POSITION' // right\n    }\n  };\n\n  // make a list of buttons, we can then remove buttons from this list if they're disabled\n  var ButtonKeys = [];\n  forin(Buttons, function(key) {\n    ButtonKeys.push(key);\n  });\n\n  var calculateFileInfoOffset = function calculateFileInfoOffset(root) {\n    var buttonRect = root.ref.buttonRemoveItem.rect.element;\n    return buttonRect.hidden ? null : buttonRect.width + buttonRect.left;\n  };\n\n  var calculateButtonWidth = function calculateButtonWidth(root) {\n    var buttonRect = root.ref.buttonAbortItemLoad.rect.element;\n    return buttonRect.width;\n  };\n\n  // Force on full pixels so text stays crips\n  var calculateFileVerticalCenterOffset = function calculateFileVerticalCenterOffset(\n    root\n  ) {\n    return Math.floor(root.ref.buttonRemoveItem.rect.element.height / 4);\n  };\n  var calculateFileHorizontalCenterOffset = function calculateFileHorizontalCenterOffset(\n    root\n  ) {\n    return Math.floor(root.ref.buttonRemoveItem.rect.element.left / 2);\n  };\n\n  var getLoadIndicatorAlignment = function getLoadIndicatorAlignment(root) {\n    return root.query('GET_STYLE_LOAD_INDICATOR_POSITION');\n  };\n  var getProcessIndicatorAlignment = function getProcessIndicatorAlignment(\n    root\n  ) {\n    return root.query('GET_STYLE_PROGRESS_INDICATOR_POSITION');\n  };\n  var getRemoveIndicatorAligment = function getRemoveIndicatorAligment(root) {\n    return root.query('GET_STYLE_BUTTON_REMOVE_ITEM_POSITION');\n  };\n\n  var DefaultStyle = {\n    buttonAbortItemLoad: { opacity: 0 },\n    buttonRetryItemLoad: { opacity: 0 },\n    buttonRemoveItem: { opacity: 0 },\n    buttonProcessItem: { opacity: 0 },\n    buttonAbortItemProcessing: { opacity: 0 },\n    buttonRetryItemProcessing: { opacity: 0 },\n    buttonRevertItemProcessing: { opacity: 0 },\n    loadProgressIndicator: { opacity: 0, align: getLoadIndicatorAlignment },\n    processProgressIndicator: {\n      opacity: 0,\n      align: getProcessIndicatorAlignment\n    },\n    processingCompleteIndicator: { opacity: 0, scaleX: 0.75, scaleY: 0.75 },\n    info: { translateX: 0, translateY: 0, opacity: 0 },\n    status: { translateX: 0, translateY: 0, opacity: 0 }\n  };\n\n  var IdleStyle = {\n    buttonRemoveItem: { opacity: 1 },\n    buttonProcessItem: { opacity: 1 },\n    info: { translateX: calculateFileInfoOffset },\n    status: { translateX: calculateFileInfoOffset }\n  };\n\n  var ProcessingStyle = {\n    buttonAbortItemProcessing: { opacity: 1 },\n    processProgressIndicator: { opacity: 1 },\n    status: { opacity: 1 }\n  };\n\n  var StyleMap = {\n    DID_THROW_ITEM_INVALID: {\n      buttonRemoveItem: { opacity: 1 },\n      info: { translateX: calculateFileInfoOffset },\n      status: { translateX: calculateFileInfoOffset, opacity: 1 }\n    },\n\n    DID_START_ITEM_LOAD: {\n      buttonAbortItemLoad: { opacity: 1 },\n      loadProgressIndicator: { opacity: 1 },\n      status: { opacity: 1 }\n    },\n\n    DID_THROW_ITEM_LOAD_ERROR: {\n      buttonRetryItemLoad: { opacity: 1 },\n      buttonRemoveItem: { opacity: 1 },\n      info: { translateX: calculateFileInfoOffset },\n      status: { opacity: 1 }\n    },\n\n    DID_START_ITEM_REMOVE: {\n      processProgressIndicator: {\n        opacity: 1,\n        align: getRemoveIndicatorAligment\n      },\n      info: { translateX: calculateFileInfoOffset },\n      status: { opacity: 0 }\n    },\n\n    DID_THROW_ITEM_REMOVE_ERROR: {\n      processProgressIndicator: {\n        opacity: 0,\n        align: getRemoveIndicatorAligment\n      },\n      buttonRemoveItem: { opacity: 1 },\n      info: { translateX: calculateFileInfoOffset },\n      status: { opacity: 1, translateX: calculateFileInfoOffset }\n    },\n\n    DID_LOAD_ITEM: IdleStyle,\n    DID_LOAD_LOCAL_ITEM: {\n      buttonRemoveItem: { opacity: 1 },\n      info: { translateX: calculateFileInfoOffset },\n      status: { translateX: calculateFileInfoOffset }\n    },\n\n    DID_START_ITEM_PROCESSING: ProcessingStyle,\n    DID_REQUEST_ITEM_PROCESSING: ProcessingStyle,\n    DID_UPDATE_ITEM_PROCESS_PROGRESS: ProcessingStyle,\n    DID_COMPLETE_ITEM_PROCESSING: {\n      buttonRevertItemProcessing: { opacity: 1 },\n      info: { opacity: 1 },\n      status: { opacity: 1 }\n    },\n\n    DID_THROW_ITEM_PROCESSING_ERROR: {\n      buttonRemoveItem: { opacity: 1 },\n      buttonRetryItemProcessing: { opacity: 1 },\n      status: { opacity: 1 },\n      info: { translateX: calculateFileInfoOffset }\n    },\n\n    DID_THROW_ITEM_PROCESSING_REVERT_ERROR: {\n      buttonRevertItemProcessing: { opacity: 1 },\n      status: { opacity: 1 },\n      info: { opacity: 1 }\n    },\n\n    DID_ABORT_ITEM_PROCESSING: {\n      buttonRemoveItem: { opacity: 1 },\n      buttonProcessItem: { opacity: 1 },\n      info: { translateX: calculateFileInfoOffset },\n      status: { opacity: 1 }\n    },\n\n    DID_REVERT_ITEM_PROCESSING: IdleStyle\n  };\n\n  // complete indicator view\n  var processingCompleteIndicatorView = createView({\n    create: function create(_ref) {\n      var root = _ref.root;\n      root.element.innerHTML = root.query('GET_ICON_DONE');\n    },\n    name: 'processing-complete-indicator',\n    ignoreRect: true,\n    mixins: {\n      styles: ['scaleX', 'scaleY', 'opacity'],\n      animations: {\n        scaleX: 'spring',\n        scaleY: 'spring',\n        opacity: { type: 'tween', duration: 250 }\n      }\n    }\n  });\n\n  /**\n   * Creates the file view\n   */\n  var create$4 = function create(_ref2) {\n    var root = _ref2.root,\n      props = _ref2.props;\n    var id = props.id;\n\n    // allow reverting upload\n    var allowRevert = root.query('GET_ALLOW_REVERT');\n\n    // allow remove file\n    var allowRemove = root.query('GET_ALLOW_REMOVE');\n\n    // allow processing upload\n    var allowProcess = root.query('GET_ALLOW_PROCESS');\n\n    // is instant uploading, need this to determine the icon of the undo button\n    var instantUpload = root.query('GET_INSTANT_UPLOAD');\n\n    // is async set up\n    var isAsync = root.query('IS_ASYNC');\n\n    // should align remove item buttons\n    var alignRemoveItemButton = root.query(\n      'GET_STYLE_BUTTON_REMOVE_ITEM_ALIGN'\n    );\n\n    // enabled buttons array\n    var buttonFilter;\n    if (isAsync) {\n      if (allowProcess && !allowRevert) {\n        // only remove revert button\n        buttonFilter = function buttonFilter(key) {\n          return !/RevertItemProcessing/.test(key);\n        };\n      } else if (!allowProcess && allowRevert) {\n        // only remove process button\n        buttonFilter = function buttonFilter(key) {\n          return !/ProcessItem|RetryItemProcessing|AbortItemProcessing/.test(\n            key\n          );\n        };\n      } else if (!allowProcess && !allowRevert) {\n        // remove all process buttons\n        buttonFilter = function buttonFilter(key) {\n          return !/Process/.test(key);\n        };\n      }\n    } else {\n      // no process controls available\n      buttonFilter = function buttonFilter(key) {\n        return !/Process/.test(key);\n      };\n    }\n\n    var enabledButtons = buttonFilter\n      ? ButtonKeys.filter(buttonFilter)\n      : ButtonKeys.concat();\n\n    // update icon and label for revert button when instant uploading\n    if (instantUpload && allowRevert) {\n      Buttons['RevertItemProcessing'].label = 'GET_LABEL_BUTTON_REMOVE_ITEM';\n      Buttons['RevertItemProcessing'].icon = 'GET_ICON_REMOVE';\n    }\n\n    // remove last button (revert) if not allowed\n    if (isAsync && !allowRevert) {\n      var map = StyleMap['DID_COMPLETE_ITEM_PROCESSING'];\n      map.info.translateX = calculateFileHorizontalCenterOffset;\n      map.info.translateY = calculateFileVerticalCenterOffset;\n      map.status.translateY = calculateFileVerticalCenterOffset;\n      map.processingCompleteIndicator = { opacity: 1, scaleX: 1, scaleY: 1 };\n    }\n\n    // should align center\n    if (isAsync && !allowProcess) {\n      [\n        'DID_START_ITEM_PROCESSING',\n        'DID_REQUEST_ITEM_PROCESSING',\n        'DID_UPDATE_ITEM_PROCESS_PROGRESS',\n        'DID_THROW_ITEM_PROCESSING_ERROR'\n      ].forEach(function(key) {\n        StyleMap[key].status.translateY = calculateFileVerticalCenterOffset;\n      });\n      StyleMap[\n        'DID_THROW_ITEM_PROCESSING_ERROR'\n      ].status.translateX = calculateButtonWidth;\n    }\n\n    // move remove button to right\n    if (alignRemoveItemButton && allowRevert) {\n      Buttons['RevertItemProcessing'].align = 'BUTTON_REMOVE_ITEM_POSITION';\n      var _map = StyleMap['DID_COMPLETE_ITEM_PROCESSING'];\n      _map.info.translateX = calculateFileInfoOffset;\n      _map.status.translateY = calculateFileVerticalCenterOffset;\n      _map.processingCompleteIndicator = { opacity: 1, scaleX: 1, scaleY: 1 };\n    }\n\n    if (!allowRemove) {\n      Buttons['RemoveItem'].disabled = true;\n    }\n\n    // create the button views\n    forin(Buttons, function(key, definition) {\n      // create button\n      var buttonView = root.createChildView(fileActionButton, {\n        label: root.query(definition.label),\n        icon: root.query(definition.icon),\n        opacity: 0\n      });\n\n      // should be appended?\n      if (enabledButtons.includes(key)) {\n        root.appendChildView(buttonView);\n      }\n\n      // toggle\n      if (definition.disabled) {\n        buttonView.element.setAttribute('disabled', 'disabled');\n        buttonView.element.setAttribute('hidden', 'hidden');\n      }\n\n      // add position attribute\n      buttonView.element.dataset.align = root.query(\n        'GET_STYLE_' + definition.align\n      );\n\n      // add class\n      buttonView.element.classList.add(definition.className);\n\n      // handle interactions\n      buttonView.on('click', function(e) {\n        e.stopPropagation();\n        if (definition.disabled) return;\n        root.dispatch(definition.action, { query: id });\n      });\n\n      // set reference\n      root.ref['button' + key] = buttonView;\n    });\n\n    // checkmark\n    root.ref.processingCompleteIndicator = root.appendChildView(\n      root.createChildView(processingCompleteIndicatorView)\n    );\n    root.ref.processingCompleteIndicator.element.dataset.align = root.query(\n      'GET_STYLE_BUTTON_PROCESS_ITEM_POSITION'\n    );\n\n    // create file info view\n    root.ref.info = root.appendChildView(\n      root.createChildView(fileInfo, { id: id })\n    );\n\n    // create file status view\n    root.ref.status = root.appendChildView(\n      root.createChildView(fileStatus, { id: id })\n    );\n\n    // add progress indicators\n    var loadIndicatorView = root.appendChildView(\n      root.createChildView(progressIndicator, {\n        opacity: 0,\n        align: root.query('GET_STYLE_LOAD_INDICATOR_POSITION')\n      })\n    );\n\n    loadIndicatorView.element.classList.add('filepond--load-indicator');\n    root.ref.loadProgressIndicator = loadIndicatorView;\n\n    var progressIndicatorView = root.appendChildView(\n      root.createChildView(progressIndicator, {\n        opacity: 0,\n        align: root.query('GET_STYLE_PROGRESS_INDICATOR_POSITION')\n      })\n    );\n\n    progressIndicatorView.element.classList.add('filepond--process-indicator');\n    root.ref.processProgressIndicator = progressIndicatorView;\n\n    // current active styles\n    root.ref.activeStyles = [];\n  };\n\n  var write$2 = function write(_ref3) {\n    var root = _ref3.root,\n      actions = _ref3.actions,\n      props = _ref3.props;\n\n    // route actions\n    route({ root: root, actions: actions, props: props });\n\n    // select last state change action\n    var action = actions\n      .concat()\n      .filter(function(action) {\n        return /^DID_/.test(action.type);\n      })\n      .reverse()\n      .find(function(action) {\n        return StyleMap[action.type];\n      });\n\n    // a new action happened, let's get the matching styles\n    if (action) {\n      // define new active styles\n      root.ref.activeStyles = [];\n\n      var stylesToApply = StyleMap[action.type];\n      forin(DefaultStyle, function(name, defaultStyles) {\n        // get reference to control\n        var control = root.ref[name];\n\n        // loop over all styles for this control\n        forin(defaultStyles, function(key, defaultValue) {\n          var value =\n            stylesToApply[name] &&\n            typeof stylesToApply[name][key] !== 'undefined'\n              ? stylesToApply[name][key]\n              : defaultValue;\n          root.ref.activeStyles.push({\n            control: control,\n            key: key,\n            value: value\n          });\n        });\n      });\n    }\n\n    // apply active styles to element\n    root.ref.activeStyles.forEach(function(_ref4) {\n      var control = _ref4.control,\n        key = _ref4.key,\n        value = _ref4.value;\n      control[key] = typeof value === 'function' ? value(root) : value;\n    });\n  };\n\n  var route = createRoute({\n    DID_SET_LABEL_BUTTON_ABORT_ITEM_PROCESSING: function DID_SET_LABEL_BUTTON_ABORT_ITEM_PROCESSING(\n      _ref5\n    ) {\n      var root = _ref5.root,\n        action = _ref5.action;\n      root.ref.buttonAbortItemProcessing.label = action.value;\n    },\n    DID_SET_LABEL_BUTTON_ABORT_ITEM_LOAD: function DID_SET_LABEL_BUTTON_ABORT_ITEM_LOAD(\n      _ref6\n    ) {\n      var root = _ref6.root,\n        action = _ref6.action;\n      root.ref.buttonAbortItemLoad.label = action.value;\n    },\n    DID_SET_LABEL_BUTTON_ABORT_ITEM_REMOVAL: function DID_SET_LABEL_BUTTON_ABORT_ITEM_REMOVAL(\n      _ref7\n    ) {\n      var root = _ref7.root,\n        action = _ref7.action;\n      root.ref.buttonAbortItemRemoval.label = action.value;\n    },\n    DID_REQUEST_ITEM_PROCESSING: function DID_REQUEST_ITEM_PROCESSING(_ref8) {\n      var root = _ref8.root;\n      root.ref.processProgressIndicator.spin = true;\n      root.ref.processProgressIndicator.progress = 0;\n    },\n    DID_START_ITEM_LOAD: function DID_START_ITEM_LOAD(_ref9) {\n      var root = _ref9.root;\n      root.ref.loadProgressIndicator.spin = true;\n      root.ref.loadProgressIndicator.progress = 0;\n    },\n    DID_START_ITEM_REMOVE: function DID_START_ITEM_REMOVE(_ref10) {\n      var root = _ref10.root;\n      root.ref.processProgressIndicator.spin = true;\n      root.ref.processProgressIndicator.progress = 0;\n    },\n    DID_UPDATE_ITEM_LOAD_PROGRESS: function DID_UPDATE_ITEM_LOAD_PROGRESS(\n      _ref11\n    ) {\n      var root = _ref11.root,\n        action = _ref11.action;\n      root.ref.loadProgressIndicator.spin = false;\n      root.ref.loadProgressIndicator.progress = action.progress;\n    },\n    DID_UPDATE_ITEM_PROCESS_PROGRESS: function DID_UPDATE_ITEM_PROCESS_PROGRESS(\n      _ref12\n    ) {\n      var root = _ref12.root,\n        action = _ref12.action;\n      root.ref.processProgressIndicator.spin = false;\n      root.ref.processProgressIndicator.progress = action.progress;\n    }\n  });\n\n  var file = createView({\n    create: create$4,\n    write: write$2,\n    didCreateView: function didCreateView(root) {\n      applyFilters('CREATE_VIEW', Object.assign({}, root, { view: root }));\n    },\n    name: 'file'\n  });\n\n  /**\n   * Creates the file view\n   */\n  var create$5 = function create(_ref) {\n    var root = _ref.root,\n      props = _ref.props;\n\n    // filename\n    root.ref.fileName = createElement$1('legend');\n    root.appendChild(root.ref.fileName);\n\n    // file appended\n    root.ref.file = root.appendChildView(\n      root.createChildView(file, { id: props.id })\n    );\n\n    // data has moved to data.js\n    root.ref.data = false;\n  };\n\n  /**\n   * Data storage\n   */\n  var didLoadItem = function didLoadItem(_ref2) {\n    var root = _ref2.root,\n      props = _ref2.props;\n    // updates the legend of the fieldset so screenreaders can better group buttons\n    text(\n      root.ref.fileName,\n      formatFilename(root.query('GET_ITEM_NAME', props.id))\n    );\n  };\n\n  var fileWrapper = createView({\n    create: create$5,\n    ignoreRect: true,\n    write: createRoute({\n      DID_LOAD_ITEM: didLoadItem\n    }),\n\n    didCreateView: function didCreateView(root) {\n      applyFilters('CREATE_VIEW', Object.assign({}, root, { view: root }));\n    },\n    tag: 'fieldset',\n    name: 'file-wrapper'\n  });\n\n  var PANEL_SPRING_PROPS = { type: 'spring', damping: 0.6, mass: 7 };\n\n  var create$6 = function create(_ref) {\n    var root = _ref.root,\n      props = _ref.props;\n    [\n      {\n        name: 'top'\n      },\n\n      {\n        name: 'center',\n        props: {\n          translateY: null,\n          scaleY: null\n        },\n\n        mixins: {\n          animations: {\n            scaleY: PANEL_SPRING_PROPS\n          },\n\n          styles: ['translateY', 'scaleY']\n        }\n      },\n\n      {\n        name: 'bottom',\n        props: {\n          translateY: null\n        },\n\n        mixins: {\n          animations: {\n            translateY: PANEL_SPRING_PROPS\n          },\n\n          styles: ['translateY']\n        }\n      }\n    ].forEach(function(section) {\n      createSection(root, section, props.name);\n    });\n\n    root.element.classList.add('filepond--' + props.name);\n\n    root.ref.scalable = null;\n  };\n\n  var createSection = function createSection(root, section, className) {\n    var viewConstructor = createView({\n      name: 'panel-' + section.name + ' filepond--' + className,\n      mixins: section.mixins,\n      ignoreRectUpdate: true\n    });\n\n    var view = root.createChildView(viewConstructor, section.props);\n\n    root.ref[section.name] = root.appendChildView(view);\n  };\n\n  var write$3 = function write(_ref2) {\n    var root = _ref2.root,\n      props = _ref2.props;\n\n    // update scalable state\n    if (root.ref.scalable === null || props.scalable !== root.ref.scalable) {\n      root.ref.scalable = isBoolean(props.scalable) ? props.scalable : true;\n      root.element.dataset.scalable = root.ref.scalable;\n    }\n\n    // no height, can't set\n    if (!props.height) return;\n\n    // get child rects\n    var topRect = root.ref.top.rect.element;\n    var bottomRect = root.ref.bottom.rect.element;\n\n    // make sure height never is smaller than bottom and top seciton heights combined (will probably never happen, but who knows)\n    var height = Math.max(topRect.height + bottomRect.height, props.height);\n\n    // offset center part\n    root.ref.center.translateY = topRect.height;\n\n    // scale center part\n    // use math ceil to prevent transparent lines because of rounding errors\n    root.ref.center.scaleY =\n      (height - topRect.height - bottomRect.height) / 100;\n\n    // offset bottom part\n    root.ref.bottom.translateY = height - bottomRect.height;\n  };\n\n  var panel = createView({\n    name: 'panel',\n    read: function read(_ref3) {\n      var root = _ref3.root,\n        props = _ref3.props;\n      return (props.heightCurrent = root.ref.bottom.translateY);\n    },\n    write: write$3,\n    create: create$6,\n    ignoreRect: true,\n    mixins: {\n      apis: ['height', 'heightCurrent', 'scalable']\n    }\n  });\n\n  var createDragHelper = function createDragHelper(items) {\n    var itemIds = items.map(function(item) {\n      return item.id;\n    });\n    var prevIndex = undefined;\n    return {\n      setIndex: function setIndex(index) {\n        prevIndex = index;\n      },\n      getIndex: function getIndex() {\n        return prevIndex;\n      },\n      getItemIndex: function getItemIndex(item) {\n        return itemIds.indexOf(item.id);\n      }\n    };\n  };\n\n  var ITEM_TRANSLATE_SPRING = {\n    type: 'spring',\n    stiffness: 0.75,\n    damping: 0.45,\n    mass: 10\n  };\n\n  var ITEM_SCALE_SPRING = 'spring';\n\n  var StateMap = {\n    DID_START_ITEM_LOAD: 'busy',\n    DID_UPDATE_ITEM_LOAD_PROGRESS: 'loading',\n    DID_THROW_ITEM_INVALID: 'load-invalid',\n    DID_THROW_ITEM_LOAD_ERROR: 'load-error',\n    DID_LOAD_ITEM: 'idle',\n    DID_THROW_ITEM_REMOVE_ERROR: 'remove-error',\n    DID_START_ITEM_REMOVE: 'busy',\n    DID_START_ITEM_PROCESSING: 'busy processing',\n    DID_REQUEST_ITEM_PROCESSING: 'busy processing',\n    DID_UPDATE_ITEM_PROCESS_PROGRESS: 'processing',\n    DID_COMPLETE_ITEM_PROCESSING: 'processing-complete',\n    DID_THROW_ITEM_PROCESSING_ERROR: 'processing-error',\n    DID_THROW_ITEM_PROCESSING_REVERT_ERROR: 'processing-revert-error',\n    DID_ABORT_ITEM_PROCESSING: 'cancelled',\n    DID_REVERT_ITEM_PROCESSING: 'idle'\n  };\n\n  /**\n   * Creates the file view\n   */\n  var create$7 = function create(_ref) {\n    var root = _ref.root,\n      props = _ref.props;\n\n    // select\n    root.ref.handleClick = function(e) {\n      return root.dispatch('DID_ACTIVATE_ITEM', { id: props.id });\n    };\n\n    // set id\n    root.element.id = 'filepond--item-' + props.id;\n    root.element.addEventListener('click', root.ref.handleClick);\n\n    // file view\n    root.ref.container = root.appendChildView(\n      root.createChildView(fileWrapper, { id: props.id })\n    );\n\n    // file panel\n    root.ref.panel = root.appendChildView(\n      root.createChildView(panel, { name: 'item-panel' })\n    );\n\n    // default start height\n    root.ref.panel.height = null;\n\n    // by default not marked for removal\n    props.markedForRemoval = false;\n\n    // if not allowed to reorder file items, exit here\n    if (!root.query('GET_ALLOW_REORDER')) return;\n\n    // set to idle so shows grab cursor\n    root.element.dataset.dragState = 'idle';\n\n    var grab = function grab(e) {\n      if (!e.isPrimary) return;\n\n      var removedActivateListener = false;\n\n      var origin = {\n        x: e.pageX,\n        y: e.pageY\n      };\n\n      props.dragOrigin = {\n        x: root.translateX,\n        y: root.translateY\n      };\n\n      props.dragCenter = {\n        x: e.offsetX,\n        y: e.offsetY\n      };\n\n      var dragState = createDragHelper(root.query('GET_ACTIVE_ITEMS'));\n\n      root.dispatch('DID_GRAB_ITEM', { id: props.id, dragState: dragState });\n\n      var drag = function drag(e) {\n        if (!e.isPrimary) return;\n\n        e.stopPropagation();\n        e.preventDefault();\n\n        props.dragOffset = {\n          x: e.pageX - origin.x,\n          y: e.pageY - origin.y\n        };\n\n        // if dragged stop listening to clicks, will re-add when done dragging\n        var dist =\n          props.dragOffset.x * props.dragOffset.x +\n          props.dragOffset.y * props.dragOffset.y;\n        if (dist > 16 && !removedActivateListener) {\n          removedActivateListener = true;\n          root.element.removeEventListener('click', root.ref.handleClick);\n        }\n\n        root.dispatch('DID_DRAG_ITEM', { id: props.id, dragState: dragState });\n      };\n\n      var drop = function drop(e) {\n        if (!e.isPrimary) return;\n\n        document.removeEventListener('pointermove', drag);\n        document.removeEventListener('pointerup', drop);\n\n        props.dragOffset = {\n          x: e.pageX - origin.x,\n          y: e.pageY - origin.y\n        };\n\n        root.dispatch('DID_DROP_ITEM', { id: props.id, dragState: dragState });\n\n        // start listening to clicks again\n        if (removedActivateListener) {\n          setTimeout(function() {\n            return root.element.addEventListener('click', root.ref.handleClick);\n          }, 0);\n        }\n      };\n\n      document.addEventListener('pointermove', drag);\n      document.addEventListener('pointerup', drop);\n    };\n\n    root.element.addEventListener('pointerdown', grab);\n  };\n\n  var route$1 = createRoute({\n    DID_UPDATE_PANEL_HEIGHT: function DID_UPDATE_PANEL_HEIGHT(_ref2) {\n      var root = _ref2.root,\n        action = _ref2.action;\n      root.height = action.height;\n    }\n  });\n\n  var write$4 = createRoute(\n    {\n      DID_GRAB_ITEM: function DID_GRAB_ITEM(_ref3) {\n        var root = _ref3.root,\n          props = _ref3.props;\n        props.dragOrigin = {\n          x: root.translateX,\n          y: root.translateY\n        };\n      },\n      DID_DRAG_ITEM: function DID_DRAG_ITEM(_ref4) {\n        var root = _ref4.root;\n        root.element.dataset.dragState = 'drag';\n      },\n      DID_DROP_ITEM: function DID_DROP_ITEM(_ref5) {\n        var root = _ref5.root,\n          props = _ref5.props;\n        props.dragOffset = null;\n        props.dragOrigin = null;\n        root.element.dataset.dragState = 'drop';\n      }\n    },\n    function(_ref6) {\n      var root = _ref6.root,\n        actions = _ref6.actions,\n        props = _ref6.props,\n        shouldOptimize = _ref6.shouldOptimize;\n\n      if (root.element.dataset.dragState === 'drop') {\n        if (root.scaleX <= 1) {\n          root.element.dataset.dragState = 'idle';\n        }\n      }\n\n      // select last state change action\n      var action = actions\n        .concat()\n        .filter(function(action) {\n          return /^DID_/.test(action.type);\n        })\n        .reverse()\n        .find(function(action) {\n          return StateMap[action.type];\n        });\n\n      // no need to set same state twice\n      if (action && action.type !== props.currentState) {\n        // set current state\n        props.currentState = action.type;\n\n        // set state\n        root.element.dataset.filepondItemState =\n          StateMap[props.currentState] || '';\n      }\n\n      // route actions\n      var aspectRatio =\n        root.query('GET_ITEM_PANEL_ASPECT_RATIO') ||\n        root.query('GET_PANEL_ASPECT_RATIO');\n      if (!aspectRatio) {\n        route$1({ root: root, actions: actions, props: props });\n        if (!root.height && root.ref.container.rect.element.height > 0) {\n          root.height = root.ref.container.rect.element.height;\n        }\n      } else if (!shouldOptimize) {\n        root.height = root.rect.element.width * aspectRatio;\n      }\n\n      // sync panel height with item height\n      if (shouldOptimize) {\n        root.ref.panel.height = null;\n      }\n\n      root.ref.panel.height = root.height;\n    }\n  );\n\n  var item = createView({\n    create: create$7,\n    write: write$4,\n    destroy: function destroy(_ref7) {\n      var root = _ref7.root,\n        props = _ref7.props;\n      root.element.removeEventListener('click', root.ref.handleClick);\n      root.dispatch('RELEASE_ITEM', { query: props.id });\n    },\n    tag: 'li',\n    name: 'item',\n    mixins: {\n      apis: [\n        'id',\n        'interactionMethod',\n        'markedForRemoval',\n        'spawnDate',\n        'dragCenter',\n        'dragOrigin',\n        'dragOffset'\n      ],\n      styles: [\n        'translateX',\n        'translateY',\n        'scaleX',\n        'scaleY',\n        'opacity',\n        'height'\n      ],\n\n      animations: {\n        scaleX: ITEM_SCALE_SPRING,\n        scaleY: ITEM_SCALE_SPRING,\n        translateX: ITEM_TRANSLATE_SPRING,\n        translateY: ITEM_TRANSLATE_SPRING,\n        opacity: { type: 'tween', duration: 150 }\n      }\n    }\n  });\n\n  var getItemIndexByPosition = function getItemIndexByPosition(\n    view,\n    children,\n    positionInView\n  ) {\n    if (!positionInView) return;\n\n    var horizontalSpace = view.rect.element.width;\n    // const children = view.childViews;\n    var l = children.length;\n    var last = null;\n\n    // -1, don't move items to accomodate (either add to top or bottom)\n    if (l === 0 || positionInView.top < children[0].rect.element.top) return -1;\n\n    // let's get the item width\n    var item = children[0];\n    var itemRect = item.rect.element;\n    var itemHorizontalMargin = itemRect.marginLeft + itemRect.marginRight;\n    var itemWidth = itemRect.width + itemHorizontalMargin;\n    var itemsPerRow = Math.round(horizontalSpace / itemWidth);\n\n    // stack\n    if (itemsPerRow === 1) {\n      for (var index = 0; index < l; index++) {\n        var child = children[index];\n        var childMid = child.rect.outer.top + child.rect.element.height * 0.5;\n        if (positionInView.top < childMid) {\n          return index;\n        }\n      }\n      return l;\n    }\n\n    // grid\n    var itemVerticalMargin = itemRect.marginTop + itemRect.marginBottom;\n    var itemHeight = itemRect.height + itemVerticalMargin;\n    for (var _index = 0; _index < l; _index++) {\n      var indexX = _index % itemsPerRow;\n      var indexY = Math.floor(_index / itemsPerRow);\n\n      var offsetX = indexX * itemWidth;\n      var offsetY = indexY * itemHeight;\n\n      var itemTop = offsetY - itemRect.marginTop;\n      var itemRight = offsetX + itemWidth;\n      var itemBottom = offsetY + itemHeight + itemRect.marginBottom;\n\n      if (positionInView.top < itemBottom && positionInView.top > itemTop) {\n        if (positionInView.left < itemRight) {\n          return _index;\n        } else if (_index !== l - 1) {\n          last = _index;\n        } else {\n          last = null;\n        }\n      }\n    }\n\n    if (last !== null) {\n      return last;\n    }\n\n    return l;\n  };\n\n  var dropAreaDimensions = {\n    height: 0,\n    width: 0,\n    get getHeight() {\n      return this.height;\n    },\n    set setHeight(val) {\n      if (this.height === 0 || val === 0) this.height = val;\n    },\n    get getWidth() {\n      return this.width;\n    },\n    set setWidth(val) {\n      if (this.width === 0 || val === 0) this.width = val;\n    },\n    setDimensions: function setDimensions(height, width) {\n      if (this.height === 0 || height === 0) this.height = height;\n      if (this.width === 0 || width === 0) this.width = width;\n    }\n  };\n\n  var create$8 = function create(_ref) {\n    var root = _ref.root;\n    // need to set role to list as otherwise it won't be read as a list by VoiceOver\n    attr(root.element, 'role', 'list');\n\n    root.ref.lastItemSpanwDate = Date.now();\n  };\n\n  /**\n   * Inserts a new item\n   * @param root\n   * @param action\n   */\n  var addItemView = function addItemView(_ref2) {\n    var root = _ref2.root,\n      action = _ref2.action;\n    var id = action.id,\n      index = action.index,\n      interactionMethod = action.interactionMethod;\n\n    root.ref.addIndex = index;\n\n    var now = Date.now();\n    var spawnDate = now;\n    var opacity = 1;\n\n    if (interactionMethod !== InteractionMethod.NONE) {\n      opacity = 0;\n      var cooldown = root.query('GET_ITEM_INSERT_INTERVAL');\n      var dist = now - root.ref.lastItemSpanwDate;\n      spawnDate = dist < cooldown ? now + (cooldown - dist) : now;\n    }\n\n    root.ref.lastItemSpanwDate = spawnDate;\n\n    root.appendChildView(\n      root.createChildView(\n        // view type\n        item,\n\n        // props\n        {\n          spawnDate: spawnDate,\n          id: id,\n          opacity: opacity,\n          interactionMethod: interactionMethod\n        }\n      ),\n\n      index\n    );\n  };\n\n  var moveItem = function moveItem(item, x, y) {\n    var vx =\n      arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    var vy =\n      arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;\n\n    // set to null to remove animation while dragging\n    if (item.dragOffset) {\n      item.translateX = null;\n      item.translateY = null;\n      item.translateX = item.dragOrigin.x + item.dragOffset.x;\n      item.translateY = item.dragOrigin.y + item.dragOffset.y;\n      item.scaleX = 1.025;\n      item.scaleY = 1.025;\n    } else {\n      item.translateX = x;\n      item.translateY = y;\n\n      if (Date.now() > item.spawnDate) {\n        // reveal element\n        if (item.opacity === 0) {\n          introItemView(item, x, y, vx, vy);\n        }\n\n        // make sure is default scale every frame\n        item.scaleX = 1;\n        item.scaleY = 1;\n        item.opacity = 1;\n      }\n    }\n  };\n\n  var introItemView = function introItemView(item, x, y, vx, vy) {\n    if (item.interactionMethod === InteractionMethod.NONE) {\n      item.translateX = null;\n      item.translateX = x;\n      item.translateY = null;\n      item.translateY = y;\n    } else if (item.interactionMethod === InteractionMethod.DROP) {\n      item.translateX = null;\n      item.translateX = x - vx * 20;\n\n      item.translateY = null;\n      item.translateY = y - vy * 10;\n\n      item.scaleX = 0.8;\n      item.scaleY = 0.8;\n    } else if (item.interactionMethod === InteractionMethod.BROWSE) {\n      item.translateY = null;\n      item.translateY = y - 30;\n    } else if (item.interactionMethod === InteractionMethod.API) {\n      item.translateX = null;\n      item.translateX = x - 30;\n      item.translateY = null;\n    }\n  };\n\n  /**\n   * Removes an existing item\n   * @param root\n   * @param action\n   */\n  var removeItemView = function removeItemView(_ref3) {\n    var root = _ref3.root,\n      action = _ref3.action;\n    var id = action.id;\n\n    // get the view matching the given id\n    var view = root.childViews.find(function(child) {\n      return child.id === id;\n    });\n\n    // if no view found, exit\n    if (!view) {\n      return;\n    }\n\n    // animate view out of view\n    view.scaleX = 0.9;\n    view.scaleY = 0.9;\n    view.opacity = 0;\n\n    // mark for removal\n    view.markedForRemoval = true;\n  };\n\n  var getItemHeight = function getItemHeight(child) {\n    return (\n      child.rect.element.height +\n      child.rect.element.marginBottom * 0.5 +\n      child.rect.element.marginTop * 0.5\n    );\n  };\n  var getItemWidth = function getItemWidth(child) {\n    return (\n      child.rect.element.width +\n      child.rect.element.marginLeft * 0.5 +\n      child.rect.element.marginRight * 0.5\n    );\n  };\n\n  var dragItem = function dragItem(_ref4) {\n    var root = _ref4.root,\n      action = _ref4.action;\n    var id = action.id,\n      dragState = action.dragState;\n\n    // reference to item\n    var item = root.query('GET_ITEM', { id: id });\n\n    // get the view matching the given id\n    var view = root.childViews.find(function(child) {\n      return child.id === id;\n    });\n\n    var numItems = root.childViews.length;\n    var oldIndex = dragState.getItemIndex(item);\n\n    // if no view found, exit\n    if (!view) return;\n\n    var dragPosition = {\n      x: view.dragOrigin.x + view.dragOffset.x + view.dragCenter.x,\n      y: view.dragOrigin.y + view.dragOffset.y + view.dragCenter.y\n\n      // get drag area dimensions\n    };\n    var dragHeight = getItemHeight(view);\n    var dragWidth = getItemWidth(view);\n\n    // get rows and columns (There will always be at least one row and one column if a file is present)\n    var cols = Math.floor(root.rect.outer.width / dragWidth);\n    if (cols > numItems) cols = numItems;\n\n    // rows are used to find when we have left the preview area bounding box\n    var rows = Math.floor(numItems / cols + 1);\n\n    dropAreaDimensions.setHeight = dragHeight * rows;\n    dropAreaDimensions.setWidth = dragWidth * cols;\n\n    // get new index of dragged item\n    var location = {\n      y: Math.floor(dragPosition.y / dragHeight),\n      x: Math.floor(dragPosition.x / dragWidth),\n      getGridIndex: function getGridIndex() {\n        if (\n          dragPosition.y > dropAreaDimensions.getHeight ||\n          dragPosition.y < 0 ||\n          dragPosition.x > dropAreaDimensions.getWidth ||\n          dragPosition.x < 0\n        )\n          return oldIndex;\n        return this.y * cols + this.x;\n      },\n      getColIndex: function getColIndex() {\n        var items = root.query('GET_ACTIVE_ITEMS');\n        var visibleChildren = root.childViews.filter(function(child) {\n          return child.rect.element.height;\n        });\n        var children = items.map(function(item) {\n          return visibleChildren.find(function(childView) {\n            return childView.id === item.id;\n          });\n        });\n        var currentIndex = children.findIndex(function(child) {\n          return child === view;\n        });\n        var dragHeight = getItemHeight(view);\n        var l = children.length;\n        var idx = l;\n        var childHeight = 0;\n        var childBottom = 0;\n        var childTop = 0;\n        for (var i = 0; i < l; i++) {\n          childHeight = getItemHeight(children[i]);\n          childTop = childBottom;\n          childBottom = childTop + childHeight;\n          if (dragPosition.y < childBottom) {\n            if (currentIndex > i) {\n              if (dragPosition.y < childTop + dragHeight) {\n                idx = i;\n                break;\n              }\n              continue;\n            }\n            idx = i;\n            break;\n          }\n        }\n        return idx;\n      }\n\n      // get new index\n    };\n    var index = cols > 1 ? location.getGridIndex() : location.getColIndex();\n    root.dispatch('MOVE_ITEM', { query: view, index: index });\n\n    // if the index of the item changed, dispatch reorder action\n    var currentIndex = dragState.getIndex();\n\n    if (currentIndex === undefined || currentIndex !== index) {\n      dragState.setIndex(index);\n\n      if (currentIndex === undefined) return;\n\n      root.dispatch('DID_REORDER_ITEMS', {\n        items: root.query('GET_ACTIVE_ITEMS'),\n        origin: oldIndex,\n        target: index\n      });\n    }\n  };\n\n  /**\n   * Setup action routes\n   */\n  var route$2 = createRoute({\n    DID_ADD_ITEM: addItemView,\n    DID_REMOVE_ITEM: removeItemView,\n    DID_DRAG_ITEM: dragItem\n  });\n\n  /**\n   * Write to view\n   * @param root\n   * @param actions\n   * @param props\n   */\n  var write$5 = function write(_ref5) {\n    var root = _ref5.root,\n      props = _ref5.props,\n      actions = _ref5.actions,\n      shouldOptimize = _ref5.shouldOptimize;\n\n    // route actions\n    route$2({ root: root, props: props, actions: actions });\n    var dragCoordinates = props.dragCoordinates;\n\n    // available space on horizontal axis\n    var horizontalSpace = root.rect.element.width;\n\n    // only draw children that have dimensions\n    var visibleChildren = root.childViews.filter(function(child) {\n      return child.rect.element.height;\n    });\n\n    // sort based on current active items\n    var children = root\n      .query('GET_ACTIVE_ITEMS')\n      .map(function(item) {\n        return visibleChildren.find(function(child) {\n          return child.id === item.id;\n        });\n      })\n      .filter(function(item) {\n        return item;\n      });\n\n    // get index\n    var dragIndex = dragCoordinates\n      ? getItemIndexByPosition(root, children, dragCoordinates)\n      : null;\n\n    // add index is used to reserve the dropped/added item index till the actual item is rendered\n    var addIndex = root.ref.addIndex || null;\n\n    // add index no longer needed till possibly next draw\n    root.ref.addIndex = null;\n\n    var dragIndexOffset = 0;\n    var removeIndexOffset = 0;\n    var addIndexOffset = 0;\n\n    if (children.length === 0) return;\n\n    var childRect = children[0].rect.element;\n    var itemVerticalMargin = childRect.marginTop + childRect.marginBottom;\n    var itemHorizontalMargin = childRect.marginLeft + childRect.marginRight;\n    var itemWidth = childRect.width + itemHorizontalMargin;\n    var itemHeight = childRect.height + itemVerticalMargin;\n    var itemsPerRow = Math.round(horizontalSpace / itemWidth);\n\n    // stack\n    if (itemsPerRow === 1) {\n      var offsetY = 0;\n      var dragOffset = 0;\n\n      children.forEach(function(child, index) {\n        if (dragIndex) {\n          var dist = index - dragIndex;\n          if (dist === -2) {\n            dragOffset = -itemVerticalMargin * 0.25;\n          } else if (dist === -1) {\n            dragOffset = -itemVerticalMargin * 0.75;\n          } else if (dist === 0) {\n            dragOffset = itemVerticalMargin * 0.75;\n          } else if (dist === 1) {\n            dragOffset = itemVerticalMargin * 0.25;\n          } else {\n            dragOffset = 0;\n          }\n        }\n\n        if (shouldOptimize) {\n          child.translateX = null;\n          child.translateY = null;\n        }\n\n        if (!child.markedForRemoval) {\n          moveItem(child, 0, offsetY + dragOffset);\n        }\n\n        var itemHeight = child.rect.element.height + itemVerticalMargin;\n\n        var visualHeight =\n          itemHeight * (child.markedForRemoval ? child.opacity : 1);\n\n        offsetY += visualHeight;\n      });\n    }\n    // grid\n    else {\n      var prevX = 0;\n      var prevY = 0;\n\n      children.forEach(function(child, index) {\n        if (index === dragIndex) {\n          dragIndexOffset = 1;\n        }\n\n        if (index === addIndex) {\n          addIndexOffset += 1;\n        }\n\n        if (child.markedForRemoval && child.opacity < 0.5) {\n          removeIndexOffset -= 1;\n        }\n\n        var visualIndex =\n          index + addIndexOffset + dragIndexOffset + removeIndexOffset;\n\n        var indexX = visualIndex % itemsPerRow;\n        var indexY = Math.floor(visualIndex / itemsPerRow);\n\n        var offsetX = indexX * itemWidth;\n        var offsetY = indexY * itemHeight;\n\n        var vectorX = Math.sign(offsetX - prevX);\n        var vectorY = Math.sign(offsetY - prevY);\n\n        prevX = offsetX;\n        prevY = offsetY;\n\n        if (child.markedForRemoval) return;\n\n        if (shouldOptimize) {\n          child.translateX = null;\n          child.translateY = null;\n        }\n\n        moveItem(child, offsetX, offsetY, vectorX, vectorY);\n      });\n    }\n  };\n\n  /**\n   * Filters actions that are meant specifically for a certain child of the list\n   * @param child\n   * @param actions\n   */\n  var filterSetItemActions = function filterSetItemActions(child, actions) {\n    return actions.filter(function(action) {\n      // if action has an id, filter out actions that don't have this child id\n      if (action.data && action.data.id) {\n        return child.id === action.data.id;\n      }\n\n      // allow all other actions\n      return true;\n    });\n  };\n\n  var list = createView({\n    create: create$8,\n    write: write$5,\n    tag: 'ul',\n    name: 'list',\n    didWriteView: function didWriteView(_ref6) {\n      var root = _ref6.root;\n      root.childViews\n        .filter(function(view) {\n          return view.markedForRemoval && view.opacity === 0 && view.resting;\n        })\n        .forEach(function(view) {\n          view._destroy();\n          root.removeChildView(view);\n        });\n    },\n    filterFrameActionsForChild: filterSetItemActions,\n    mixins: {\n      apis: ['dragCoordinates']\n    }\n  });\n\n  var create$9 = function create(_ref) {\n    var root = _ref.root,\n      props = _ref.props;\n    root.ref.list = root.appendChildView(root.createChildView(list));\n    props.dragCoordinates = null;\n    props.overflowing = false;\n  };\n\n  var storeDragCoordinates = function storeDragCoordinates(_ref2) {\n    var root = _ref2.root,\n      props = _ref2.props,\n      action = _ref2.action;\n    if (!root.query('GET_ITEM_INSERT_LOCATION_FREEDOM')) return;\n    props.dragCoordinates = {\n      left: action.position.scopeLeft - root.ref.list.rect.element.left,\n      top:\n        action.position.scopeTop -\n        (root.rect.outer.top +\n          root.rect.element.marginTop +\n          root.rect.element.scrollTop)\n    };\n  };\n\n  var clearDragCoordinates = function clearDragCoordinates(_ref3) {\n    var props = _ref3.props;\n    props.dragCoordinates = null;\n  };\n\n  var route$3 = createRoute({\n    DID_DRAG: storeDragCoordinates,\n    DID_END_DRAG: clearDragCoordinates\n  });\n\n  var write$6 = function write(_ref4) {\n    var root = _ref4.root,\n      props = _ref4.props,\n      actions = _ref4.actions;\n\n    // route actions\n    route$3({ root: root, props: props, actions: actions });\n\n    // current drag position\n    root.ref.list.dragCoordinates = props.dragCoordinates;\n\n    // if currently overflowing but no longer received overflow\n    if (props.overflowing && !props.overflow) {\n      props.overflowing = false;\n\n      // reset overflow state\n      root.element.dataset.state = '';\n      root.height = null;\n    }\n\n    // if is not overflowing currently but does receive overflow value\n    if (props.overflow) {\n      var newHeight = Math.round(props.overflow);\n      if (newHeight !== root.height) {\n        props.overflowing = true;\n        root.element.dataset.state = 'overflow';\n        root.height = newHeight;\n      }\n    }\n  };\n\n  var listScroller = createView({\n    create: create$9,\n    write: write$6,\n    name: 'list-scroller',\n    mixins: {\n      apis: ['overflow', 'dragCoordinates'],\n      styles: ['height', 'translateY'],\n      animations: {\n        translateY: 'spring'\n      }\n    }\n  });\n\n  var attrToggle = function attrToggle(element, name, state) {\n    var enabledValue =\n      arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';\n    if (state) {\n      attr(element, name, enabledValue);\n    } else {\n      element.removeAttribute(name);\n    }\n  };\n\n  var resetFileInput = function resetFileInput(input) {\n    // no value, no need to reset\n    if (!input || input.value === '') {\n      return;\n    }\n\n    try {\n      // for modern browsers\n      input.value = '';\n    } catch (err) {}\n\n    // for IE10\n    if (input.value) {\n      // quickly append input to temp form and reset form\n      var form = createElement$1('form');\n      var parentNode = input.parentNode;\n      var ref = input.nextSibling;\n      form.appendChild(input);\n      form.reset();\n\n      // re-inject input where it originally was\n      if (ref) {\n        parentNode.insertBefore(input, ref);\n      } else {\n        parentNode.appendChild(input);\n      }\n    }\n  };\n\n  var create$a = function create(_ref) {\n    var root = _ref.root,\n      props = _ref.props;\n\n    // set id so can be referenced from outside labels\n    root.element.id = 'filepond--browser-' + props.id;\n\n    // set name of element (is removed when a value is set)\n    attr(root.element, 'name', root.query('GET_NAME'));\n\n    // we have to link this element to the status element\n    attr(root.element, 'aria-controls', 'filepond--assistant-' + props.id);\n\n    // set label, we use labelled by as otherwise the screenreader does not read the \"browse\" text in the label (as it has tabindex: 0)\n    attr(root.element, 'aria-labelledby', 'filepond--drop-label-' + props.id);\n\n    // set configurable props\n    setAcceptedFileTypes({\n      root: root,\n      action: { value: root.query('GET_ACCEPTED_FILE_TYPES') }\n    });\n    toggleAllowMultiple({\n      root: root,\n      action: { value: root.query('GET_ALLOW_MULTIPLE') }\n    });\n    toggleDirectoryFilter({\n      root: root,\n      action: { value: root.query('GET_ALLOW_DIRECTORIES_ONLY') }\n    });\n    toggleDisabled({ root: root });\n    toggleRequired({\n      root: root,\n      action: { value: root.query('GET_REQUIRED') }\n    });\n    setCaptureMethod({\n      root: root,\n      action: { value: root.query('GET_CAPTURE_METHOD') }\n    });\n\n    // handle changes to the input field\n    root.ref.handleChange = function(e) {\n      if (!root.element.value) {\n        return;\n      }\n\n      // extract files and move value of webkitRelativePath path to _relativePath\n      var files = Array.from(root.element.files).map(function(file) {\n        file._relativePath = file.webkitRelativePath;\n        return file;\n      });\n\n      // we add a little delay so the OS file select window can move out of the way before we add our file\n      setTimeout(function() {\n        // load files\n        props.onload(files);\n\n        // reset input, it's just for exposing a method to drop files, should not retain any state\n        resetFileInput(root.element);\n      }, 250);\n    };\n\n    root.element.addEventListener('change', root.ref.handleChange);\n  };\n\n  var setAcceptedFileTypes = function setAcceptedFileTypes(_ref2) {\n    var root = _ref2.root,\n      action = _ref2.action;\n    if (!root.query('GET_ALLOW_SYNC_ACCEPT_ATTRIBUTE')) return;\n    attrToggle(\n      root.element,\n      'accept',\n      !!action.value,\n      action.value ? action.value.join(',') : ''\n    );\n  };\n\n  var toggleAllowMultiple = function toggleAllowMultiple(_ref3) {\n    var root = _ref3.root,\n      action = _ref3.action;\n    attrToggle(root.element, 'multiple', action.value);\n  };\n\n  var toggleDirectoryFilter = function toggleDirectoryFilter(_ref4) {\n    var root = _ref4.root,\n      action = _ref4.action;\n    attrToggle(root.element, 'webkitdirectory', action.value);\n  };\n\n  var toggleDisabled = function toggleDisabled(_ref5) {\n    var root = _ref5.root;\n    var isDisabled = root.query('GET_DISABLED');\n    var doesAllowBrowse = root.query('GET_ALLOW_BROWSE');\n    var disableField = isDisabled || !doesAllowBrowse;\n    attrToggle(root.element, 'disabled', disableField);\n  };\n\n  var toggleRequired = function toggleRequired(_ref6) {\n    var root = _ref6.root,\n      action = _ref6.action;\n    // want to remove required, always possible\n    if (!action.value) {\n      attrToggle(root.element, 'required', false);\n    }\n    // if want to make required, only possible when zero items\n    else if (root.query('GET_TOTAL_ITEMS') === 0) {\n      attrToggle(root.element, 'required', true);\n    }\n  };\n\n  var setCaptureMethod = function setCaptureMethod(_ref7) {\n    var root = _ref7.root,\n      action = _ref7.action;\n    attrToggle(\n      root.element,\n      'capture',\n      !!action.value,\n      action.value === true ? '' : action.value\n    );\n  };\n\n  var updateRequiredStatus = function updateRequiredStatus(_ref8) {\n    var root = _ref8.root;\n    var element = root.element;\n    // always remove the required attribute when more than zero items\n    if (root.query('GET_TOTAL_ITEMS') > 0) {\n      attrToggle(element, 'required', false);\n      attrToggle(element, 'name', false);\n    } else {\n      // add name attribute\n      attrToggle(element, 'name', true, root.query('GET_NAME'));\n\n      // remove any validation messages\n      var shouldCheckValidity = root.query('GET_CHECK_VALIDITY');\n      if (shouldCheckValidity) {\n        element.setCustomValidity('');\n      }\n\n      // we only add required if the field has been deemed required\n      if (root.query('GET_REQUIRED')) {\n        attrToggle(element, 'required', true);\n      }\n    }\n  };\n\n  var updateFieldValidityStatus = function updateFieldValidityStatus(_ref9) {\n    var root = _ref9.root;\n    var shouldCheckValidity = root.query('GET_CHECK_VALIDITY');\n    if (!shouldCheckValidity) return;\n    root.element.setCustomValidity(root.query('GET_LABEL_INVALID_FIELD'));\n  };\n\n  var browser = createView({\n    tag: 'input',\n    name: 'browser',\n    ignoreRect: true,\n    ignoreRectUpdate: true,\n    attributes: {\n      type: 'file'\n    },\n\n    create: create$a,\n    destroy: function destroy(_ref10) {\n      var root = _ref10.root;\n      root.element.removeEventListener('change', root.ref.handleChange);\n    },\n    write: createRoute({\n      DID_LOAD_ITEM: updateRequiredStatus,\n      DID_REMOVE_ITEM: updateRequiredStatus,\n      DID_THROW_ITEM_INVALID: updateFieldValidityStatus,\n\n      DID_SET_DISABLED: toggleDisabled,\n      DID_SET_ALLOW_BROWSE: toggleDisabled,\n      DID_SET_ALLOW_DIRECTORIES_ONLY: toggleDirectoryFilter,\n      DID_SET_ALLOW_MULTIPLE: toggleAllowMultiple,\n      DID_SET_ACCEPTED_FILE_TYPES: setAcceptedFileTypes,\n      DID_SET_CAPTURE_METHOD: setCaptureMethod,\n      DID_SET_REQUIRED: toggleRequired\n    })\n  });\n\n  var Key = {\n    ENTER: 13,\n    SPACE: 32\n  };\n\n  var create$b = function create(_ref) {\n    var root = _ref.root,\n      props = _ref.props;\n\n    // create the label and link it to the file browser\n    var label = createElement$1('label');\n    attr(label, 'for', 'filepond--browser-' + props.id);\n\n    // use for labeling file input (aria-labelledby on file input)\n    attr(label, 'id', 'filepond--drop-label-' + props.id);\n\n    // hide the label for screenreaders, the input element will read the contents of the label when it's focussed. If we don't set aria-hidden the screenreader will also navigate the contents of the label separately from the input.\n    attr(label, 'aria-hidden', 'true');\n\n    // handle keys\n    root.ref.handleKeyDown = function(e) {\n      var isActivationKey = e.keyCode === Key.ENTER || e.keyCode === Key.SPACE;\n      if (!isActivationKey) return;\n      // stops from triggering the element a second time\n      e.preventDefault();\n\n      // click link (will then in turn activate file input)\n      root.ref.label.click();\n    };\n\n    root.ref.handleClick = function(e) {\n      var isLabelClick = e.target === label || label.contains(e.target);\n\n      // don't want to click twice\n      if (isLabelClick) return;\n\n      // click link (will then in turn activate file input)\n      root.ref.label.click();\n    };\n\n    // attach events\n    label.addEventListener('keydown', root.ref.handleKeyDown);\n    root.element.addEventListener('click', root.ref.handleClick);\n\n    // update\n    updateLabelValue(label, props.caption);\n\n    // add!\n    root.appendChild(label);\n    root.ref.label = label;\n  };\n\n  var updateLabelValue = function updateLabelValue(label, value) {\n    label.innerHTML = value;\n    var clickable = label.querySelector('.filepond--label-action');\n    if (clickable) {\n      attr(clickable, 'tabindex', '0');\n    }\n    return value;\n  };\n\n  var dropLabel = createView({\n    name: 'drop-label',\n    ignoreRect: true,\n    create: create$b,\n    destroy: function destroy(_ref2) {\n      var root = _ref2.root;\n      root.ref.label.addEventListener('keydown', root.ref.handleKeyDown);\n      root.element.removeEventListener('click', root.ref.handleClick);\n    },\n    write: createRoute({\n      DID_SET_LABEL_IDLE: function DID_SET_LABEL_IDLE(_ref3) {\n        var root = _ref3.root,\n          action = _ref3.action;\n        updateLabelValue(root.ref.label, action.value);\n      }\n    }),\n\n    mixins: {\n      styles: ['opacity', 'translateX', 'translateY'],\n      animations: {\n        opacity: { type: 'tween', duration: 150 },\n        translateX: 'spring',\n        translateY: 'spring'\n      }\n    }\n  });\n\n  var blob = createView({\n    name: 'drip-blob',\n    ignoreRect: true,\n    mixins: {\n      styles: ['translateX', 'translateY', 'scaleX', 'scaleY', 'opacity'],\n      animations: {\n        scaleX: 'spring',\n        scaleY: 'spring',\n        translateX: 'spring',\n        translateY: 'spring',\n        opacity: { type: 'tween', duration: 250 }\n      }\n    }\n  });\n\n  var addBlob = function addBlob(_ref) {\n    var root = _ref.root;\n    var centerX = root.rect.element.width * 0.5;\n    var centerY = root.rect.element.height * 0.5;\n\n    root.ref.blob = root.appendChildView(\n      root.createChildView(blob, {\n        opacity: 0,\n        scaleX: 2.5,\n        scaleY: 2.5,\n        translateX: centerX,\n        translateY: centerY\n      })\n    );\n  };\n\n  var moveBlob = function moveBlob(_ref2) {\n    var root = _ref2.root,\n      action = _ref2.action;\n    if (!root.ref.blob) {\n      addBlob({ root: root });\n      return;\n    }\n\n    root.ref.blob.translateX = action.position.scopeLeft;\n    root.ref.blob.translateY = action.position.scopeTop;\n    root.ref.blob.scaleX = 1;\n    root.ref.blob.scaleY = 1;\n    root.ref.blob.opacity = 1;\n  };\n\n  var hideBlob = function hideBlob(_ref3) {\n    var root = _ref3.root;\n    if (!root.ref.blob) {\n      return;\n    }\n    root.ref.blob.opacity = 0;\n  };\n\n  var explodeBlob = function explodeBlob(_ref4) {\n    var root = _ref4.root;\n    if (!root.ref.blob) {\n      return;\n    }\n    root.ref.blob.scaleX = 2.5;\n    root.ref.blob.scaleY = 2.5;\n    root.ref.blob.opacity = 0;\n  };\n\n  var write$7 = function write(_ref5) {\n    var root = _ref5.root,\n      props = _ref5.props,\n      actions = _ref5.actions;\n    route$4({ root: root, props: props, actions: actions });\n    var blob = root.ref.blob;\n\n    if (actions.length === 0 && blob && blob.opacity === 0) {\n      root.removeChildView(blob);\n      root.ref.blob = null;\n    }\n  };\n\n  var route$4 = createRoute({\n    DID_DRAG: moveBlob,\n    DID_DROP: explodeBlob,\n    DID_END_DRAG: hideBlob\n  });\n\n  var drip = createView({\n    ignoreRect: true,\n    ignoreRectUpdate: true,\n    name: 'drip',\n    write: write$7\n  });\n\n  var create$c = function create(_ref) {\n    var root = _ref.root;\n    return (root.ref.fields = {});\n  };\n\n  var getField = function getField(root, id) {\n    return root.ref.fields[id];\n  };\n\n  var syncFieldPositionsWithItems = function syncFieldPositionsWithItems(root) {\n    root.query('GET_ACTIVE_ITEMS').forEach(function(item) {\n      if (!root.ref.fields[item.id]) return;\n      root.element.appendChild(root.ref.fields[item.id]);\n    });\n  };\n\n  var didReorderItems = function didReorderItems(_ref2) {\n    var root = _ref2.root;\n    return syncFieldPositionsWithItems(root);\n  };\n\n  var didAddItem = function didAddItem(_ref3) {\n    var root = _ref3.root,\n      action = _ref3.action;\n    var dataContainer = createElement$1('input');\n    dataContainer.type = 'hidden';\n    dataContainer.name = root.query('GET_NAME');\n    dataContainer.disabled = root.query('GET_DISABLED');\n    root.ref.fields[action.id] = dataContainer;\n    syncFieldPositionsWithItems(root);\n  };\n\n  var didLoadItem$1 = function didLoadItem(_ref4) {\n    var root = _ref4.root,\n      action = _ref4.action;\n    var field = getField(root, action.id);\n    if (!field || action.serverFileReference === null) return;\n    field.value = action.serverFileReference;\n  };\n\n  var didSetDisabled = function didSetDisabled(_ref5) {\n    var root = _ref5.root;\n    root.element.disabled = root.query('GET_DISABLED');\n  };\n\n  var didRemoveItem = function didRemoveItem(_ref6) {\n    var root = _ref6.root,\n      action = _ref6.action;\n    var field = getField(root, action.id);\n    if (!field) return;\n    if (field.parentNode) field.parentNode.removeChild(field);\n    delete root.ref.fields[action.id];\n  };\n\n  var didDefineValue = function didDefineValue(_ref7) {\n    var root = _ref7.root,\n      action = _ref7.action;\n    var field = getField(root, action.id);\n    if (!field) return;\n    if (action.value === null) {\n      field.removeAttribute('value');\n    } else {\n      field.value = action.value;\n    }\n    syncFieldPositionsWithItems(root);\n  };\n\n  var write$8 = createRoute({\n    DID_SET_DISABLED: didSetDisabled,\n    DID_ADD_ITEM: didAddItem,\n    DID_LOAD_ITEM: didLoadItem$1,\n    DID_REMOVE_ITEM: didRemoveItem,\n    DID_DEFINE_VALUE: didDefineValue,\n    DID_REORDER_ITEMS: didReorderItems,\n    DID_SORT_ITEMS: didReorderItems\n  });\n\n  var data = createView({\n    tag: 'fieldset',\n    name: 'data',\n    create: create$c,\n    write: write$8,\n    ignoreRect: true\n  });\n\n  var getRootNode = function getRootNode(element) {\n    return 'getRootNode' in element ? element.getRootNode() : document;\n  };\n\n  var images = ['jpg', 'jpeg', 'png', 'gif', 'bmp', 'webp', 'svg', 'tiff'];\n  var text$1 = ['css', 'csv', 'html', 'txt'];\n  var map = {\n    zip: 'zip|compressed',\n    epub: 'application/epub+zip'\n  };\n\n  var guesstimateMimeType = function guesstimateMimeType() {\n    var extension =\n      arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    extension = extension.toLowerCase();\n    if (images.includes(extension)) {\n      return (\n        'image/' +\n        (extension === 'jpg'\n          ? 'jpeg'\n          : extension === 'svg'\n          ? 'svg+xml'\n          : extension)\n      );\n    }\n    if (text$1.includes(extension)) {\n      return 'text/' + extension;\n    }\n\n    return map[extension] || '';\n  };\n\n  var requestDataTransferItems = function requestDataTransferItems(\n    dataTransfer\n  ) {\n    return new Promise(function(resolve, reject) {\n      // try to get links from transfer, if found we'll exit immediately (unless a file is in the dataTransfer as well, this is because Firefox could represent the file as a URL and a file object at the same time)\n      var links = getLinks(dataTransfer);\n      if (links.length && !hasFiles(dataTransfer)) {\n        return resolve(links);\n      }\n      // try to get files from the transfer\n      getFiles(dataTransfer).then(resolve);\n    });\n  };\n\n  /**\n   * Test if datatransfer has files\n   */\n  var hasFiles = function hasFiles(dataTransfer) {\n    if (dataTransfer.files) return dataTransfer.files.length > 0;\n    return false;\n  };\n\n  /**\n   * Extracts files from a DataTransfer object\n   */\n  var getFiles = function getFiles(dataTransfer) {\n    return new Promise(function(resolve, reject) {\n      // get the transfer items as promises\n      var promisedFiles = (dataTransfer.items\n        ? Array.from(dataTransfer.items)\n        : []\n      )\n        // only keep file system items (files and directories)\n        .filter(function(item) {\n          return isFileSystemItem(item);\n        })\n\n        // map each item to promise\n        .map(function(item) {\n          return getFilesFromItem(item);\n        });\n\n      // if is empty, see if we can extract some info from the files property as a fallback\n      if (!promisedFiles.length) {\n        // TODO: test for directories (should not be allowed)\n        // Use FileReader, problem is that the files property gets lost in the process\n        resolve(dataTransfer.files ? Array.from(dataTransfer.files) : []);\n        return;\n      }\n\n      // done!\n      Promise.all(promisedFiles)\n        .then(function(returnedFileGroups) {\n          // flatten groups\n          var files = [];\n          returnedFileGroups.forEach(function(group) {\n            files.push.apply(files, group);\n          });\n\n          // done (filter out empty files)!\n          resolve(\n            files\n              .filter(function(file) {\n                return file;\n              })\n              .map(function(file) {\n                if (!file._relativePath)\n                  file._relativePath = file.webkitRelativePath;\n                return file;\n              })\n          );\n        })\n        .catch(console.error);\n    });\n  };\n\n  var isFileSystemItem = function isFileSystemItem(item) {\n    if (isEntry(item)) {\n      var entry = getAsEntry(item);\n      if (entry) {\n        return entry.isFile || entry.isDirectory;\n      }\n    }\n    return item.kind === 'file';\n  };\n\n  var getFilesFromItem = function getFilesFromItem(item) {\n    return new Promise(function(resolve, reject) {\n      if (isDirectoryEntry(item)) {\n        getFilesInDirectory(getAsEntry(item))\n          .then(resolve)\n          .catch(reject);\n        return;\n      }\n\n      resolve([item.getAsFile()]);\n    });\n  };\n\n  var getFilesInDirectory = function getFilesInDirectory(entry) {\n    return new Promise(function(resolve, reject) {\n      var files = [];\n\n      // the total entries to read\n      var dirCounter = 0;\n      var fileCounter = 0;\n\n      var resolveIfDone = function resolveIfDone() {\n        if (fileCounter === 0 && dirCounter === 0) {\n          resolve(files);\n        }\n      };\n\n      // the recursive function\n      var readEntries = function readEntries(dirEntry) {\n        dirCounter++;\n\n        var directoryReader = dirEntry.createReader();\n\n        // directories are returned in batches, we need to process all batches before we're done\n        var readBatch = function readBatch() {\n          directoryReader.readEntries(function(entries) {\n            if (entries.length === 0) {\n              dirCounter--;\n              resolveIfDone();\n              return;\n            }\n\n            entries.forEach(function(entry) {\n              // recursively read more directories\n              if (entry.isDirectory) {\n                readEntries(entry);\n              } else {\n                // read as file\n                fileCounter++;\n\n                entry.file(function(file) {\n                  var correctedFile = correctMissingFileType(file);\n                  if (entry.fullPath)\n                    correctedFile._relativePath = entry.fullPath;\n                  files.push(correctedFile);\n                  fileCounter--;\n                  resolveIfDone();\n                });\n              }\n            });\n\n            // try to get next batch of files\n            readBatch();\n          }, reject);\n        };\n\n        // read first batch of files\n        readBatch();\n      };\n\n      // go!\n      readEntries(entry);\n    });\n  };\n\n  var correctMissingFileType = function correctMissingFileType(file) {\n    if (file.type.length) return file;\n    var date = file.lastModifiedDate;\n    var name = file.name;\n    var type = guesstimateMimeType(getExtensionFromFilename(file.name));\n    if (!type.length) return file;\n    file = file.slice(0, file.size, type);\n    file.name = name;\n    file.lastModifiedDate = date;\n    return file;\n  };\n\n  var isDirectoryEntry = function isDirectoryEntry(item) {\n    return isEntry(item) && (getAsEntry(item) || {}).isDirectory;\n  };\n\n  var isEntry = function isEntry(item) {\n    return 'webkitGetAsEntry' in item;\n  };\n\n  var getAsEntry = function getAsEntry(item) {\n    return item.webkitGetAsEntry();\n  };\n\n  /**\n   * Extracts links from a DataTransfer object\n   */\n  var getLinks = function getLinks(dataTransfer) {\n    var links = [];\n    try {\n      // look in meta data property\n      links = getLinksFromTransferMetaData(dataTransfer);\n      if (links.length) {\n        return links;\n      }\n      links = getLinksFromTransferURLData(dataTransfer);\n    } catch (e) {\n      // nope nope nope (probably IE trouble)\n    }\n    return links;\n  };\n\n  var getLinksFromTransferURLData = function getLinksFromTransferURLData(\n    dataTransfer\n  ) {\n    var data = dataTransfer.getData('url');\n    if (typeof data === 'string' && data.length) {\n      return [data];\n    }\n    return [];\n  };\n\n  var getLinksFromTransferMetaData = function getLinksFromTransferMetaData(\n    dataTransfer\n  ) {\n    var data = dataTransfer.getData('text/html');\n    if (typeof data === 'string' && data.length) {\n      var matches = data.match(/src\\s*=\\s*\"(.+?)\"/);\n      if (matches) {\n        return [matches[1]];\n      }\n    }\n    return [];\n  };\n\n  var dragNDropObservers = [];\n\n  var eventPosition = function eventPosition(e) {\n    return {\n      pageLeft: e.pageX,\n      pageTop: e.pageY,\n      scopeLeft: e.offsetX || e.layerX,\n      scopeTop: e.offsetY || e.layerY\n    };\n  };\n\n  var createDragNDropClient = function createDragNDropClient(\n    element,\n    scopeToObserve,\n    filterElement\n  ) {\n    var observer = getDragNDropObserver(scopeToObserve);\n\n    var client = {\n      element: element,\n      filterElement: filterElement,\n      state: null,\n      ondrop: function ondrop() {},\n      onenter: function onenter() {},\n      ondrag: function ondrag() {},\n      onexit: function onexit() {},\n      onload: function onload() {},\n      allowdrop: function allowdrop() {}\n    };\n\n    client.destroy = observer.addListener(client);\n\n    return client;\n  };\n\n  var getDragNDropObserver = function getDragNDropObserver(element) {\n    // see if already exists, if so, return\n    var observer = dragNDropObservers.find(function(item) {\n      return item.element === element;\n    });\n    if (observer) {\n      return observer;\n    }\n\n    // create new observer, does not yet exist for this element\n    var newObserver = createDragNDropObserver(element);\n    dragNDropObservers.push(newObserver);\n    return newObserver;\n  };\n\n  var createDragNDropObserver = function createDragNDropObserver(element) {\n    var clients = [];\n\n    var routes = {\n      dragenter: dragenter,\n      dragover: dragover,\n      dragleave: dragleave,\n      drop: drop\n    };\n\n    var handlers = {};\n\n    forin(routes, function(event, createHandler) {\n      handlers[event] = createHandler(element, clients);\n      element.addEventListener(event, handlers[event], false);\n    });\n\n    var observer = {\n      element: element,\n      addListener: function addListener(client) {\n        // add as client\n        clients.push(client);\n\n        // return removeListener function\n        return function() {\n          // remove client\n          clients.splice(clients.indexOf(client), 1);\n\n          // if no more clients, clean up observer\n          if (clients.length === 0) {\n            dragNDropObservers.splice(dragNDropObservers.indexOf(observer), 1);\n\n            forin(routes, function(event) {\n              element.removeEventListener(event, handlers[event], false);\n            });\n          }\n        };\n      }\n    };\n\n    return observer;\n  };\n\n  var elementFromPoint = function elementFromPoint(root, point) {\n    if (!('elementFromPoint' in root)) {\n      root = document;\n    }\n    return root.elementFromPoint(point.x, point.y);\n  };\n\n  var isEventTarget = function isEventTarget(e, target) {\n    // get root\n    var root = getRootNode(target);\n\n    // get element at position\n    // if root is not actual shadow DOM and does not have elementFromPoint method, use the one on document\n    var elementAtPosition = elementFromPoint(root, {\n      x: e.pageX - window.pageXOffset,\n      y: e.pageY - window.pageYOffset\n    });\n\n    // test if target is the element or if one of its children is\n    return elementAtPosition === target || target.contains(elementAtPosition);\n  };\n\n  var initialTarget = null;\n\n  var setDropEffect = function setDropEffect(dataTransfer, effect) {\n    // is in try catch as IE11 will throw error if not\n    try {\n      dataTransfer.dropEffect = effect;\n    } catch (e) {}\n  };\n\n  var dragenter = function dragenter(root, clients) {\n    return function(e) {\n      e.preventDefault();\n\n      initialTarget = e.target;\n\n      clients.forEach(function(client) {\n        var element = client.element,\n          onenter = client.onenter;\n\n        if (isEventTarget(e, element)) {\n          client.state = 'enter';\n\n          // fire enter event\n          onenter(eventPosition(e));\n        }\n      });\n    };\n  };\n\n  var dragover = function dragover(root, clients) {\n    return function(e) {\n      e.preventDefault();\n\n      var dataTransfer = e.dataTransfer;\n\n      requestDataTransferItems(dataTransfer).then(function(items) {\n        var overDropTarget = false;\n\n        clients.some(function(client) {\n          var filterElement = client.filterElement,\n            element = client.element,\n            onenter = client.onenter,\n            onexit = client.onexit,\n            ondrag = client.ondrag,\n            allowdrop = client.allowdrop;\n\n          // by default we can drop\n          setDropEffect(dataTransfer, 'copy');\n\n          // allow transfer of these items\n          var allowsTransfer = allowdrop(items);\n\n          // only used when can be dropped on page\n          if (!allowsTransfer) {\n            setDropEffect(dataTransfer, 'none');\n            return;\n          }\n\n          // targetting this client\n          if (isEventTarget(e, element)) {\n            overDropTarget = true;\n\n            // had no previous state, means we are entering this client\n            if (client.state === null) {\n              client.state = 'enter';\n              onenter(eventPosition(e));\n              return;\n            }\n\n            // now over element (no matter if it allows the drop or not)\n            client.state = 'over';\n\n            // needs to allow transfer\n            if (filterElement && !allowsTransfer) {\n              setDropEffect(dataTransfer, 'none');\n              return;\n            }\n\n            // dragging\n            ondrag(eventPosition(e));\n          } else {\n            // should be over an element to drop\n            if (filterElement && !overDropTarget) {\n              setDropEffect(dataTransfer, 'none');\n            }\n\n            // might have just left this client?\n            if (client.state) {\n              client.state = null;\n              onexit(eventPosition(e));\n            }\n          }\n        });\n      });\n    };\n  };\n\n  var drop = function drop(root, clients) {\n    return function(e) {\n      e.preventDefault();\n\n      var dataTransfer = e.dataTransfer;\n\n      requestDataTransferItems(dataTransfer).then(function(items) {\n        clients.forEach(function(client) {\n          var filterElement = client.filterElement,\n            element = client.element,\n            ondrop = client.ondrop,\n            onexit = client.onexit,\n            allowdrop = client.allowdrop;\n\n          client.state = null;\n\n          // if we're filtering on element we need to be over the element to drop\n          if (filterElement && !isEventTarget(e, element)) return;\n\n          // no transfer for this client\n          if (!allowdrop(items)) return onexit(eventPosition(e));\n\n          // we can drop these items on this client\n          ondrop(eventPosition(e), items);\n        });\n      });\n    };\n  };\n\n  var dragleave = function dragleave(root, clients) {\n    return function(e) {\n      if (initialTarget !== e.target) {\n        return;\n      }\n\n      clients.forEach(function(client) {\n        var onexit = client.onexit;\n\n        client.state = null;\n\n        onexit(eventPosition(e));\n      });\n    };\n  };\n\n  var createHopper = function createHopper(scope, validateItems, options) {\n    // is now hopper scope\n    scope.classList.add('filepond--hopper');\n\n    // shortcuts\n    var catchesDropsOnPage = options.catchesDropsOnPage,\n      requiresDropOnElement = options.requiresDropOnElement,\n      _options$filterItems = options.filterItems,\n      filterItems =\n        _options$filterItems === void 0\n          ? function(items) {\n              return items;\n            }\n          : _options$filterItems;\n\n    // create a dnd client\n    var client = createDragNDropClient(\n      scope,\n      catchesDropsOnPage ? document.documentElement : scope,\n      requiresDropOnElement\n    );\n\n    // current client state\n    var lastState = '';\n    var currentState = '';\n\n    // determines if a file may be dropped\n    client.allowdrop = function(items) {\n      // TODO: if we can, throw error to indicate the items cannot by dropped\n\n      return validateItems(filterItems(items));\n    };\n\n    client.ondrop = function(position, items) {\n      var filteredItems = filterItems(items);\n\n      if (!validateItems(filteredItems)) {\n        api.ondragend(position);\n        return;\n      }\n\n      currentState = 'drag-drop';\n\n      api.onload(filteredItems, position);\n    };\n\n    client.ondrag = function(position) {\n      api.ondrag(position);\n    };\n\n    client.onenter = function(position) {\n      currentState = 'drag-over';\n\n      api.ondragstart(position);\n    };\n\n    client.onexit = function(position) {\n      currentState = 'drag-exit';\n\n      api.ondragend(position);\n    };\n\n    var api = {\n      updateHopperState: function updateHopperState() {\n        if (lastState !== currentState) {\n          scope.dataset.hopperState = currentState;\n          lastState = currentState;\n        }\n      },\n      onload: function onload() {},\n      ondragstart: function ondragstart() {},\n      ondrag: function ondrag() {},\n      ondragend: function ondragend() {},\n      destroy: function destroy() {\n        // destroy client\n        client.destroy();\n      }\n    };\n\n    return api;\n  };\n\n  var listening = false;\n  var listeners$1 = [];\n\n  var handlePaste = function handlePaste(e) {\n    // if is pasting in input or textarea and the target is outside of a filepond scope, ignore\n    var activeEl = document.activeElement;\n    if (activeEl && /textarea|input/i.test(activeEl.nodeName)) {\n      // test textarea or input is contained in filepond root\n      var inScope = false;\n      var element = activeEl;\n      while (element !== document.body) {\n        if (element.classList.contains('filepond--root')) {\n          inScope = true;\n          break;\n        }\n        element = element.parentNode;\n      }\n\n      if (!inScope) return;\n    }\n\n    requestDataTransferItems(e.clipboardData).then(function(files) {\n      // no files received\n      if (!files.length) {\n        return;\n      }\n\n      // notify listeners of received files\n      listeners$1.forEach(function(listener) {\n        return listener(files);\n      });\n    });\n  };\n\n  var listen = function listen(cb) {\n    // can't add twice\n    if (listeners$1.includes(cb)) {\n      return;\n    }\n\n    // add initial listener\n    listeners$1.push(cb);\n\n    // setup paste listener for entire page\n    if (listening) {\n      return;\n    }\n\n    listening = true;\n    document.addEventListener('paste', handlePaste);\n  };\n\n  var unlisten = function unlisten(listener) {\n    arrayRemove(listeners$1, listeners$1.indexOf(listener));\n\n    // clean up\n    if (listeners$1.length === 0) {\n      document.removeEventListener('paste', handlePaste);\n      listening = false;\n    }\n  };\n\n  var createPaster = function createPaster() {\n    var cb = function cb(files) {\n      api.onload(files);\n    };\n\n    var api = {\n      destroy: function destroy() {\n        unlisten(cb);\n      },\n      onload: function onload() {}\n    };\n\n    listen(cb);\n\n    return api;\n  };\n\n  /**\n   * Creates the file view\n   */\n  var create$d = function create(_ref) {\n    var root = _ref.root,\n      props = _ref.props;\n    root.element.id = 'filepond--assistant-' + props.id;\n    attr(root.element, 'role', 'status');\n    attr(root.element, 'aria-live', 'polite');\n    attr(root.element, 'aria-relevant', 'additions');\n  };\n\n  var addFilesNotificationTimeout = null;\n  var notificationClearTimeout = null;\n\n  var filenames = [];\n\n  var assist = function assist(root, message) {\n    root.element.textContent = message;\n  };\n\n  var clear$1 = function clear(root) {\n    root.element.textContent = '';\n  };\n\n  var listModified = function listModified(root, filename, label) {\n    var total = root.query('GET_TOTAL_ITEMS');\n    assist(\n      root,\n      label +\n        ' ' +\n        filename +\n        ', ' +\n        total +\n        ' ' +\n        (total === 1\n          ? root.query('GET_LABEL_FILE_COUNT_SINGULAR')\n          : root.query('GET_LABEL_FILE_COUNT_PLURAL'))\n    );\n\n    // clear group after set amount of time so the status is not read twice\n    clearTimeout(notificationClearTimeout);\n    notificationClearTimeout = setTimeout(function() {\n      clear$1(root);\n    }, 1500);\n  };\n\n  var isUsingFilePond = function isUsingFilePond(root) {\n    return root.element.parentNode.contains(document.activeElement);\n  };\n\n  var itemAdded = function itemAdded(_ref2) {\n    var root = _ref2.root,\n      action = _ref2.action;\n    if (!isUsingFilePond(root)) {\n      return;\n    }\n\n    root.element.textContent = '';\n    var item = root.query('GET_ITEM', action.id);\n    filenames.push(item.filename);\n\n    clearTimeout(addFilesNotificationTimeout);\n    addFilesNotificationTimeout = setTimeout(function() {\n      listModified(\n        root,\n        filenames.join(', '),\n        root.query('GET_LABEL_FILE_ADDED')\n      );\n\n      filenames.length = 0;\n    }, 750);\n  };\n\n  var itemRemoved = function itemRemoved(_ref3) {\n    var root = _ref3.root,\n      action = _ref3.action;\n    if (!isUsingFilePond(root)) {\n      return;\n    }\n\n    var item = action.item;\n    listModified(root, item.filename, root.query('GET_LABEL_FILE_REMOVED'));\n  };\n\n  var itemProcessed = function itemProcessed(_ref4) {\n    var root = _ref4.root,\n      action = _ref4.action;\n    // will also notify the user when FilePond is not being used, as the user might be occupied with other activities while uploading a file\n\n    var item = root.query('GET_ITEM', action.id);\n    var filename = item.filename;\n    var label = root.query('GET_LABEL_FILE_PROCESSING_COMPLETE');\n\n    assist(root, filename + ' ' + label);\n  };\n\n  var itemProcessedUndo = function itemProcessedUndo(_ref5) {\n    var root = _ref5.root,\n      action = _ref5.action;\n    var item = root.query('GET_ITEM', action.id);\n    var filename = item.filename;\n    var label = root.query('GET_LABEL_FILE_PROCESSING_ABORTED');\n\n    assist(root, filename + ' ' + label);\n  };\n\n  var itemError = function itemError(_ref6) {\n    var root = _ref6.root,\n      action = _ref6.action;\n    var item = root.query('GET_ITEM', action.id);\n    var filename = item.filename;\n\n    // will also notify the user when FilePond is not being used, as the user might be occupied with other activities while uploading a file\n\n    assist(root, action.status.main + ' ' + filename + ' ' + action.status.sub);\n  };\n\n  var assistant = createView({\n    create: create$d,\n    ignoreRect: true,\n    ignoreRectUpdate: true,\n    write: createRoute({\n      DID_LOAD_ITEM: itemAdded,\n      DID_REMOVE_ITEM: itemRemoved,\n      DID_COMPLETE_ITEM_PROCESSING: itemProcessed,\n\n      DID_ABORT_ITEM_PROCESSING: itemProcessedUndo,\n      DID_REVERT_ITEM_PROCESSING: itemProcessedUndo,\n\n      DID_THROW_ITEM_REMOVE_ERROR: itemError,\n      DID_THROW_ITEM_LOAD_ERROR: itemError,\n      DID_THROW_ITEM_INVALID: itemError,\n      DID_THROW_ITEM_PROCESSING_ERROR: itemError\n    }),\n\n    tag: 'span',\n    name: 'assistant'\n  });\n\n  var toCamels = function toCamels(string) {\n    var separator =\n      arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '-';\n    return string.replace(new RegExp(separator + '.', 'g'), function(sub) {\n      return sub.charAt(1).toUpperCase();\n    });\n  };\n\n  var debounce = function debounce(func) {\n    var interval =\n      arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 16;\n    var immidiateOnly =\n      arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    var last = Date.now();\n    var timeout = null;\n\n    return function() {\n      for (\n        var _len = arguments.length, args = new Array(_len), _key = 0;\n        _key < _len;\n        _key++\n      ) {\n        args[_key] = arguments[_key];\n      }\n      clearTimeout(timeout);\n\n      var dist = Date.now() - last;\n\n      var fn = function fn() {\n        last = Date.now();\n        func.apply(void 0, args);\n      };\n\n      if (dist < interval) {\n        // we need to delay by the difference between interval and dist\n        // for example: if distance is 10 ms and interval is 16 ms,\n        // we need to wait an additional 6ms before calling the function)\n        if (!immidiateOnly) {\n          timeout = setTimeout(fn, interval - dist);\n        }\n      } else {\n        // go!\n        fn();\n      }\n    };\n  };\n\n  var MAX_FILES_LIMIT = 1000000;\n\n  var prevent = function prevent(e) {\n    return e.preventDefault();\n  };\n\n  var create$e = function create(_ref) {\n    var root = _ref.root,\n      props = _ref.props;\n\n    // Add id\n    var id = root.query('GET_ID');\n    if (id) {\n      root.element.id = id;\n    }\n\n    // Add className\n    var className = root.query('GET_CLASS_NAME');\n    if (className) {\n      className\n        .split(' ')\n        .filter(function(name) {\n          return name.length;\n        })\n        .forEach(function(name) {\n          root.element.classList.add(name);\n        });\n    }\n\n    // Field label\n    root.ref.label = root.appendChildView(\n      root.createChildView(\n        dropLabel,\n        Object.assign({}, props, {\n          translateY: null,\n          caption: root.query('GET_LABEL_IDLE')\n        })\n      )\n    );\n\n    // List of items\n    root.ref.list = root.appendChildView(\n      root.createChildView(listScroller, { translateY: null })\n    );\n\n    // Background panel\n    root.ref.panel = root.appendChildView(\n      root.createChildView(panel, { name: 'panel-root' })\n    );\n\n    // Assistant notifies assistive tech when content changes\n    root.ref.assistant = root.appendChildView(\n      root.createChildView(assistant, Object.assign({}, props))\n    );\n\n    // Data\n    root.ref.data = root.appendChildView(\n      root.createChildView(data, Object.assign({}, props))\n    );\n\n    // Measure (tests if fixed height was set)\n    // DOCTYPE needs to be set for this to work\n    root.ref.measure = createElement$1('div');\n    root.ref.measure.style.height = '100%';\n    root.element.appendChild(root.ref.measure);\n\n    // information on the root height or fixed height status\n    root.ref.bounds = null;\n\n    // apply initial style properties\n    root\n      .query('GET_STYLES')\n      .filter(function(style) {\n        return !isEmpty(style.value);\n      })\n      .map(function(_ref2) {\n        var name = _ref2.name,\n          value = _ref2.value;\n        root.element.dataset[name] = value;\n      });\n\n    // determine if width changed\n    root.ref.widthPrevious = null;\n    root.ref.widthUpdated = debounce(function() {\n      root.ref.updateHistory = [];\n      root.dispatch('DID_RESIZE_ROOT');\n    }, 250);\n\n    // history of updates\n    root.ref.previousAspectRatio = null;\n    root.ref.updateHistory = [];\n\n    // prevent scrolling and zooming on iOS (only if supports pointer events, for then we can enable reorder)\n    var canHover = window.matchMedia('(pointer: fine) and (hover: hover)')\n      .matches;\n    var hasPointerEvents = 'PointerEvent' in window;\n    if (root.query('GET_ALLOW_REORDER') && hasPointerEvents && !canHover) {\n      root.element.addEventListener('touchmove', prevent, { passive: false });\n      root.element.addEventListener('gesturestart', prevent);\n    }\n\n    // add credits\n    var credits = root.query('GET_CREDITS');\n    var hasCredits = credits.length === 2;\n    if (hasCredits) {\n      var frag = document.createElement('a');\n      frag.className = 'filepond--credits';\n      frag.setAttribute('aria-hidden', 'true');\n      frag.href = credits[0];\n      frag.tabindex = -1;\n      frag.target = '_blank';\n      frag.rel = 'noopener noreferrer';\n      frag.textContent = credits[1];\n      root.element.appendChild(frag);\n      root.ref.credits = frag;\n    }\n  };\n\n  var write$9 = function write(_ref3) {\n    var root = _ref3.root,\n      props = _ref3.props,\n      actions = _ref3.actions;\n\n    // route actions\n    route$5({ root: root, props: props, actions: actions });\n\n    // apply style properties\n    actions\n      .filter(function(action) {\n        return /^DID_SET_STYLE_/.test(action.type);\n      })\n      .filter(function(action) {\n        return !isEmpty(action.data.value);\n      })\n      .map(function(_ref4) {\n        var type = _ref4.type,\n          data = _ref4.data;\n        var name = toCamels(type.substr(8).toLowerCase(), '_');\n        root.element.dataset[name] = data.value;\n        root.invalidateLayout();\n      });\n\n    if (root.rect.element.hidden) return;\n\n    if (root.rect.element.width !== root.ref.widthPrevious) {\n      root.ref.widthPrevious = root.rect.element.width;\n      root.ref.widthUpdated();\n    }\n\n    // get box bounds, we do this only once\n    var bounds = root.ref.bounds;\n    if (!bounds) {\n      bounds = root.ref.bounds = calculateRootBoundingBoxHeight(root);\n\n      // destroy measure element\n      root.element.removeChild(root.ref.measure);\n      root.ref.measure = null;\n    }\n\n    // get quick references to various high level parts of the upload tool\n    var _root$ref = root.ref,\n      hopper = _root$ref.hopper,\n      label = _root$ref.label,\n      list = _root$ref.list,\n      panel = _root$ref.panel;\n\n    // sets correct state to hopper scope\n    if (hopper) {\n      hopper.updateHopperState();\n    }\n\n    // bool to indicate if we're full or not\n    var aspectRatio = root.query('GET_PANEL_ASPECT_RATIO');\n    var isMultiItem = root.query('GET_ALLOW_MULTIPLE');\n    var totalItems = root.query('GET_TOTAL_ITEMS');\n    var maxItems = isMultiItem\n      ? root.query('GET_MAX_FILES') || MAX_FILES_LIMIT\n      : 1;\n    var atMaxCapacity = totalItems === maxItems;\n\n    // action used to add item\n    var addAction = actions.find(function(action) {\n      return action.type === 'DID_ADD_ITEM';\n    });\n\n    // if reached max capacity and we've just reached it\n    if (atMaxCapacity && addAction) {\n      // get interaction type\n      var interactionMethod = addAction.data.interactionMethod;\n\n      // hide label\n      label.opacity = 0;\n\n      if (isMultiItem) {\n        label.translateY = -40;\n      } else {\n        if (interactionMethod === InteractionMethod.API) {\n          label.translateX = 40;\n        } else if (interactionMethod === InteractionMethod.BROWSE) {\n          label.translateY = 40;\n        } else {\n          label.translateY = 30;\n        }\n      }\n    } else if (!atMaxCapacity) {\n      label.opacity = 1;\n      label.translateX = 0;\n      label.translateY = 0;\n    }\n\n    var listItemMargin = calculateListItemMargin(root);\n\n    var listHeight = calculateListHeight(root);\n\n    var labelHeight = label.rect.element.height;\n    var currentLabelHeight = !isMultiItem || atMaxCapacity ? 0 : labelHeight;\n\n    var listMarginTop = atMaxCapacity ? list.rect.element.marginTop : 0;\n    var listMarginBottom =\n      totalItems === 0 ? 0 : list.rect.element.marginBottom;\n\n    var visualHeight =\n      currentLabelHeight + listMarginTop + listHeight.visual + listMarginBottom;\n    var boundsHeight =\n      currentLabelHeight + listMarginTop + listHeight.bounds + listMarginBottom;\n\n    // link list to label bottom position\n    list.translateY =\n      Math.max(0, currentLabelHeight - list.rect.element.marginTop) -\n      listItemMargin.top;\n\n    if (aspectRatio) {\n      // fixed aspect ratio\n\n      // calculate height based on width\n      var width = root.rect.element.width;\n      var height = width * aspectRatio;\n\n      // clear history if aspect ratio has changed\n      if (aspectRatio !== root.ref.previousAspectRatio) {\n        root.ref.previousAspectRatio = aspectRatio;\n        root.ref.updateHistory = [];\n      }\n\n      // remember this width\n      var history = root.ref.updateHistory;\n      history.push(width);\n\n      var MAX_BOUNCES = 2;\n      if (history.length > MAX_BOUNCES * 2) {\n        var l = history.length;\n        var bottom = l - 10;\n        var bounces = 0;\n        for (var i = l; i >= bottom; i--) {\n          if (history[i] === history[i - 2]) {\n            bounces++;\n          }\n\n          if (bounces >= MAX_BOUNCES) {\n            // dont adjust height\n            return;\n          }\n        }\n      }\n\n      // fix height of panel so it adheres to aspect ratio\n      panel.scalable = false;\n      panel.height = height;\n\n      // available height for list\n      var listAvailableHeight =\n        // the height of the panel minus the label height\n        height -\n        currentLabelHeight -\n        // the room we leave open between the end of the list and the panel bottom\n        (listMarginBottom - listItemMargin.bottom) -\n        // if we're full we need to leave some room between the top of the panel and the list\n        (atMaxCapacity ? listMarginTop : 0);\n\n      if (listHeight.visual > listAvailableHeight) {\n        list.overflow = listAvailableHeight;\n      } else {\n        list.overflow = null;\n      }\n\n      // set container bounds (so pushes siblings downwards)\n      root.height = height;\n    } else if (bounds.fixedHeight) {\n      // fixed height\n\n      // fix height of panel\n      panel.scalable = false;\n\n      // available height for list\n      var _listAvailableHeight =\n        // the height of the panel minus the label height\n        bounds.fixedHeight -\n        currentLabelHeight -\n        // the room we leave open between the end of the list and the panel bottom\n        (listMarginBottom - listItemMargin.bottom) -\n        // if we're full we need to leave some room between the top of the panel and the list\n        (atMaxCapacity ? listMarginTop : 0);\n\n      // set list height\n      if (listHeight.visual > _listAvailableHeight) {\n        list.overflow = _listAvailableHeight;\n      } else {\n        list.overflow = null;\n      }\n\n      // no need to set container bounds as these are handles by CSS fixed height\n    } else if (bounds.cappedHeight) {\n      // max-height\n\n      // not a fixed height panel\n      var isCappedHeight = visualHeight >= bounds.cappedHeight;\n      var panelHeight = Math.min(bounds.cappedHeight, visualHeight);\n      panel.scalable = true;\n      panel.height = isCappedHeight\n        ? panelHeight\n        : panelHeight - listItemMargin.top - listItemMargin.bottom;\n\n      // available height for list\n      var _listAvailableHeight2 =\n        // the height of the panel minus the label height\n        panelHeight -\n        currentLabelHeight -\n        // the room we leave open between the end of the list and the panel bottom\n        (listMarginBottom - listItemMargin.bottom) -\n        // if we're full we need to leave some room between the top of the panel and the list\n        (atMaxCapacity ? listMarginTop : 0);\n\n      // set list height (if is overflowing)\n      if (\n        visualHeight > bounds.cappedHeight &&\n        listHeight.visual > _listAvailableHeight2\n      ) {\n        list.overflow = _listAvailableHeight2;\n      } else {\n        list.overflow = null;\n      }\n\n      // set container bounds (so pushes siblings downwards)\n      root.height = Math.min(\n        bounds.cappedHeight,\n        boundsHeight - listItemMargin.top - listItemMargin.bottom\n      );\n    } else {\n      // flexible height\n\n      // not a fixed height panel\n      var itemMargin =\n        totalItems > 0 ? listItemMargin.top + listItemMargin.bottom : 0;\n      panel.scalable = true;\n      panel.height = Math.max(labelHeight, visualHeight - itemMargin);\n\n      // set container bounds (so pushes siblings downwards)\n      root.height = Math.max(labelHeight, boundsHeight - itemMargin);\n    }\n\n    // move credits to bottom\n    if (root.ref.credits && panel.heightCurrent)\n      root.ref.credits.style.transform =\n        'translateY(' + panel.heightCurrent + 'px)';\n  };\n\n  var calculateListItemMargin = function calculateListItemMargin(root) {\n    var item = root.ref.list.childViews[0].childViews[0];\n    return item\n      ? {\n          top: item.rect.element.marginTop,\n          bottom: item.rect.element.marginBottom\n        }\n      : {\n          top: 0,\n          bottom: 0\n        };\n  };\n\n  var calculateListHeight = function calculateListHeight(root) {\n    var visual = 0;\n    var bounds = 0;\n\n    // get file list reference\n    var scrollList = root.ref.list;\n    var itemList = scrollList.childViews[0];\n    var visibleChildren = itemList.childViews.filter(function(child) {\n      return child.rect.element.height;\n    });\n    var children = root\n      .query('GET_ACTIVE_ITEMS')\n      .map(function(item) {\n        return visibleChildren.find(function(child) {\n          return child.id === item.id;\n        });\n      })\n      .filter(function(item) {\n        return item;\n      });\n\n    // no children, done!\n    if (children.length === 0) return { visual: visual, bounds: bounds };\n\n    var horizontalSpace = itemList.rect.element.width;\n    var dragIndex = getItemIndexByPosition(\n      itemList,\n      children,\n      scrollList.dragCoordinates\n    );\n\n    var childRect = children[0].rect.element;\n\n    var itemVerticalMargin = childRect.marginTop + childRect.marginBottom;\n    var itemHorizontalMargin = childRect.marginLeft + childRect.marginRight;\n\n    var itemWidth = childRect.width + itemHorizontalMargin;\n    var itemHeight = childRect.height + itemVerticalMargin;\n\n    var newItem = typeof dragIndex !== 'undefined' && dragIndex >= 0 ? 1 : 0;\n    var removedItem = children.find(function(child) {\n      return child.markedForRemoval && child.opacity < 0.45;\n    })\n      ? -1\n      : 0;\n    var verticalItemCount = children.length + newItem + removedItem;\n    var itemsPerRow = Math.round(horizontalSpace / itemWidth);\n\n    // stack\n    if (itemsPerRow === 1) {\n      children.forEach(function(item) {\n        var height = item.rect.element.height + itemVerticalMargin;\n        bounds += height;\n        visual += height * item.opacity;\n      });\n    }\n    // grid\n    else {\n      bounds = Math.ceil(verticalItemCount / itemsPerRow) * itemHeight;\n      visual = bounds;\n    }\n\n    return { visual: visual, bounds: bounds };\n  };\n\n  var calculateRootBoundingBoxHeight = function calculateRootBoundingBoxHeight(\n    root\n  ) {\n    var height = root.ref.measureHeight || null;\n    var cappedHeight = parseInt(root.style.maxHeight, 10) || null;\n    var fixedHeight = height === 0 ? null : height;\n\n    return {\n      cappedHeight: cappedHeight,\n      fixedHeight: fixedHeight\n    };\n  };\n\n  var exceedsMaxFiles = function exceedsMaxFiles(root, items) {\n    var allowReplace = root.query('GET_ALLOW_REPLACE');\n    var allowMultiple = root.query('GET_ALLOW_MULTIPLE');\n    var totalItems = root.query('GET_TOTAL_ITEMS');\n    var maxItems = root.query('GET_MAX_FILES');\n\n    // total amount of items being dragged\n    var totalBrowseItems = items.length;\n\n    // if does not allow multiple items and dragging more than one item\n    if (!allowMultiple && totalBrowseItems > 1) {\n      return true;\n    }\n\n    // limit max items to one if not allowed to drop multiple items\n    maxItems = allowMultiple ? maxItems : allowReplace ? maxItems : 1;\n\n    // no more room?\n    var hasMaxItems = isInt(maxItems);\n    if (hasMaxItems && totalItems + totalBrowseItems > maxItems) {\n      root.dispatch('DID_THROW_MAX_FILES', {\n        source: items,\n        error: createResponse('warning', 0, 'Max files')\n      });\n\n      return true;\n    }\n\n    return false;\n  };\n\n  var getDragIndex = function getDragIndex(list, children, position) {\n    var itemList = list.childViews[0];\n    return getItemIndexByPosition(itemList, children, {\n      left: position.scopeLeft - itemList.rect.element.left,\n      top:\n        position.scopeTop -\n        (list.rect.outer.top +\n          list.rect.element.marginTop +\n          list.rect.element.scrollTop)\n    });\n  };\n\n  /**\n   * Enable or disable file drop functionality\n   */\n  var toggleDrop = function toggleDrop(root) {\n    var isAllowed = root.query('GET_ALLOW_DROP');\n    var isDisabled = root.query('GET_DISABLED');\n    var enabled = isAllowed && !isDisabled;\n    if (enabled && !root.ref.hopper) {\n      var hopper = createHopper(\n        root.element,\n        function(items) {\n          // allow quick validation of dropped items\n          var beforeDropFile =\n            root.query('GET_BEFORE_DROP_FILE') ||\n            function() {\n              return true;\n            };\n\n          // all items should be validated by all filters as valid\n          var dropValidation = root.query('GET_DROP_VALIDATION');\n          return dropValidation\n            ? items.every(function(item) {\n                return (\n                  applyFilters('ALLOW_HOPPER_ITEM', item, {\n                    query: root.query\n                  }).every(function(result) {\n                    return result === true;\n                  }) && beforeDropFile(item)\n                );\n              })\n            : true;\n        },\n        {\n          filterItems: function filterItems(items) {\n            var ignoredFiles = root.query('GET_IGNORED_FILES');\n            return items.filter(function(item) {\n              if (isFile(item)) {\n                return !ignoredFiles.includes(item.name.toLowerCase());\n              }\n              return true;\n            });\n          },\n          catchesDropsOnPage: root.query('GET_DROP_ON_PAGE'),\n          requiresDropOnElement: root.query('GET_DROP_ON_ELEMENT')\n        }\n      );\n\n      hopper.onload = function(items, position) {\n        // get item children elements and sort based on list sort\n        var list = root.ref.list.childViews[0];\n        var visibleChildren = list.childViews.filter(function(child) {\n          return child.rect.element.height;\n        });\n        var children = root\n          .query('GET_ACTIVE_ITEMS')\n          .map(function(item) {\n            return visibleChildren.find(function(child) {\n              return child.id === item.id;\n            });\n          })\n          .filter(function(item) {\n            return item;\n          });\n\n        applyFilterChain('ADD_ITEMS', items, { dispatch: root.dispatch }).then(\n          function(queue) {\n            // these files don't fit so stop here\n            if (exceedsMaxFiles(root, queue)) return false;\n\n            // go\n            root.dispatch('ADD_ITEMS', {\n              items: queue,\n              index: getDragIndex(root.ref.list, children, position),\n              interactionMethod: InteractionMethod.DROP\n            });\n          }\n        );\n\n        root.dispatch('DID_DROP', { position: position });\n\n        root.dispatch('DID_END_DRAG', { position: position });\n      };\n\n      hopper.ondragstart = function(position) {\n        root.dispatch('DID_START_DRAG', { position: position });\n      };\n\n      hopper.ondrag = debounce(function(position) {\n        root.dispatch('DID_DRAG', { position: position });\n      });\n\n      hopper.ondragend = function(position) {\n        root.dispatch('DID_END_DRAG', { position: position });\n      };\n\n      root.ref.hopper = hopper;\n\n      root.ref.drip = root.appendChildView(root.createChildView(drip));\n    } else if (!enabled && root.ref.hopper) {\n      root.ref.hopper.destroy();\n      root.ref.hopper = null;\n      root.removeChildView(root.ref.drip);\n    }\n  };\n\n  /**\n   * Enable or disable browse functionality\n   */\n  var toggleBrowse = function toggleBrowse(root, props) {\n    var isAllowed = root.query('GET_ALLOW_BROWSE');\n    var isDisabled = root.query('GET_DISABLED');\n    var enabled = isAllowed && !isDisabled;\n    if (enabled && !root.ref.browser) {\n      root.ref.browser = root.appendChildView(\n        root.createChildView(\n          browser,\n          Object.assign({}, props, {\n            onload: function onload(items) {\n              applyFilterChain('ADD_ITEMS', items, {\n                dispatch: root.dispatch\n              }).then(function(queue) {\n                // these files don't fit so stop here\n                if (exceedsMaxFiles(root, queue)) return false;\n\n                // add items!\n                root.dispatch('ADD_ITEMS', {\n                  items: queue,\n                  index: -1,\n                  interactionMethod: InteractionMethod.BROWSE\n                });\n              });\n            }\n          })\n        ),\n\n        0\n      );\n    } else if (!enabled && root.ref.browser) {\n      root.removeChildView(root.ref.browser);\n      root.ref.browser = null;\n    }\n  };\n\n  /**\n   * Enable or disable paste functionality\n   */\n  var togglePaste = function togglePaste(root) {\n    var isAllowed = root.query('GET_ALLOW_PASTE');\n    var isDisabled = root.query('GET_DISABLED');\n    var enabled = isAllowed && !isDisabled;\n    if (enabled && !root.ref.paster) {\n      root.ref.paster = createPaster();\n      root.ref.paster.onload = function(items) {\n        applyFilterChain('ADD_ITEMS', items, { dispatch: root.dispatch }).then(\n          function(queue) {\n            // these files don't fit so stop here\n            if (exceedsMaxFiles(root, queue)) return false;\n\n            // add items!\n            root.dispatch('ADD_ITEMS', {\n              items: queue,\n              index: -1,\n              interactionMethod: InteractionMethod.PASTE\n            });\n          }\n        );\n      };\n    } else if (!enabled && root.ref.paster) {\n      root.ref.paster.destroy();\n      root.ref.paster = null;\n    }\n  };\n\n  /**\n   * Route actions\n   */\n  var route$5 = createRoute({\n    DID_SET_ALLOW_BROWSE: function DID_SET_ALLOW_BROWSE(_ref5) {\n      var root = _ref5.root,\n        props = _ref5.props;\n      toggleBrowse(root, props);\n    },\n    DID_SET_ALLOW_DROP: function DID_SET_ALLOW_DROP(_ref6) {\n      var root = _ref6.root;\n      toggleDrop(root);\n    },\n    DID_SET_ALLOW_PASTE: function DID_SET_ALLOW_PASTE(_ref7) {\n      var root = _ref7.root;\n      togglePaste(root);\n    },\n    DID_SET_DISABLED: function DID_SET_DISABLED(_ref8) {\n      var root = _ref8.root,\n        props = _ref8.props;\n      toggleDrop(root);\n      togglePaste(root);\n      toggleBrowse(root, props);\n      var isDisabled = root.query('GET_DISABLED');\n      if (isDisabled) {\n        root.element.dataset.disabled = 'disabled';\n      } else {\n        // delete root.element.dataset.disabled; <= this does not work on iOS 10\n        root.element.removeAttribute('data-disabled');\n      }\n    }\n  });\n\n  var root = createView({\n    name: 'root',\n    read: function read(_ref9) {\n      var root = _ref9.root;\n      if (root.ref.measure) {\n        root.ref.measureHeight = root.ref.measure.offsetHeight;\n      }\n    },\n    create: create$e,\n    write: write$9,\n    destroy: function destroy(_ref10) {\n      var root = _ref10.root;\n      if (root.ref.paster) {\n        root.ref.paster.destroy();\n      }\n      if (root.ref.hopper) {\n        root.ref.hopper.destroy();\n      }\n      root.element.removeEventListener('touchmove', prevent);\n      root.element.removeEventListener('gesturestart', prevent);\n    },\n    mixins: {\n      styles: ['height']\n    }\n  });\n\n  // creates the app\n  var createApp = function createApp() {\n    var initialOptions =\n      arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    // let element\n    var originalElement = null;\n\n    // get default options\n    var defaultOptions = getOptions();\n\n    // create the data store, this will contain all our app info\n    var store = createStore(\n      // initial state (should be serializable)\n      createInitialState(defaultOptions),\n\n      // queries\n      [queries, createOptionQueries(defaultOptions)],\n\n      // action handlers\n      [actions, createOptionActions(defaultOptions)]\n    );\n\n    // set initial options\n    store.dispatch('SET_OPTIONS', { options: initialOptions });\n\n    // kick thread if visibility changes\n    var visibilityHandler = function visibilityHandler() {\n      if (document.hidden) return;\n      store.dispatch('KICK');\n    };\n    document.addEventListener('visibilitychange', visibilityHandler);\n\n    // re-render on window resize start and finish\n    var resizeDoneTimer = null;\n    var isResizing = false;\n    var isResizingHorizontally = false;\n    var initialWindowWidth = null;\n    var currentWindowWidth = null;\n    var resizeHandler = function resizeHandler() {\n      if (!isResizing) {\n        isResizing = true;\n      }\n      clearTimeout(resizeDoneTimer);\n      resizeDoneTimer = setTimeout(function() {\n        isResizing = false;\n        initialWindowWidth = null;\n        currentWindowWidth = null;\n        if (isResizingHorizontally) {\n          isResizingHorizontally = false;\n          store.dispatch('DID_STOP_RESIZE');\n        }\n      }, 500);\n    };\n    window.addEventListener('resize', resizeHandler);\n\n    // render initial view\n    var view = root(store, { id: getUniqueId() });\n\n    //\n    // PRIVATE API -------------------------------------------------------------------------------------\n    //\n    var isResting = false;\n    var isHidden = false;\n\n    var readWriteApi = {\n      // necessary for update loop\n\n      /**\n       * Reads from dom (never call manually)\n       * @private\n       */\n      _read: function _read() {\n        // test if we're resizing horizontally\n        // TODO: see if we can optimize this by measuring root rect\n        if (isResizing) {\n          currentWindowWidth = window.innerWidth;\n          if (!initialWindowWidth) {\n            initialWindowWidth = currentWindowWidth;\n          }\n\n          if (\n            !isResizingHorizontally &&\n            currentWindowWidth !== initialWindowWidth\n          ) {\n            store.dispatch('DID_START_RESIZE');\n            isResizingHorizontally = true;\n          }\n        }\n\n        if (isHidden && isResting) {\n          // test if is no longer hidden\n          isResting = view.element.offsetParent === null;\n        }\n\n        // if resting, no need to read as numbers will still all be correct\n        if (isResting) return;\n\n        // read view data\n        view._read();\n\n        // if is hidden we need to know so we exit rest mode when revealed\n        isHidden = view.rect.element.hidden;\n      },\n\n      /**\n       * Writes to dom (never call manually)\n       * @private\n       */\n      _write: function _write(ts) {\n        // get all actions from store\n        var actions = store\n          .processActionQueue()\n\n          // filter out set actions (these will automatically trigger DID_SET)\n          .filter(function(action) {\n            return !/^SET_/.test(action.type);\n          });\n\n        // if was idling and no actions stop here\n        if (isResting && !actions.length) return;\n\n        // some actions might trigger events\n        routeActionsToEvents(actions);\n\n        // update the view\n        isResting = view._write(ts, actions, isResizingHorizontally);\n\n        // will clean up all archived items\n        removeReleasedItems(store.query('GET_ITEMS'));\n\n        // now idling\n        if (isResting) {\n          store.processDispatchQueue();\n        }\n      }\n    };\n\n    //\n    // EXPOSE EVENTS -------------------------------------------------------------------------------------\n    //\n    var createEvent = function createEvent(name) {\n      return function(data) {\n        // create default event\n        var event = {\n          type: name\n        };\n\n        // no data to add\n        if (!data) {\n          return event;\n        }\n\n        // copy relevant props\n        if (data.hasOwnProperty('error')) {\n          event.error = data.error ? Object.assign({}, data.error) : null;\n        }\n\n        if (data.status) {\n          event.status = Object.assign({}, data.status);\n        }\n\n        if (data.file) {\n          event.output = data.file;\n        }\n\n        // only source is available, else add item if possible\n        if (data.source) {\n          event.file = data.source;\n        } else if (data.item || data.id) {\n          var item = data.item ? data.item : store.query('GET_ITEM', data.id);\n          event.file = item ? createItemAPI(item) : null;\n        }\n\n        // map all items in a possible items array\n        if (data.items) {\n          event.items = data.items.map(createItemAPI);\n        }\n\n        // if this is a progress event add the progress amount\n        if (/progress/.test(name)) {\n          event.progress = data.progress;\n        }\n\n        // copy relevant props\n        if (data.hasOwnProperty('origin') && data.hasOwnProperty('target')) {\n          event.origin = data.origin;\n          event.target = data.target;\n        }\n\n        return event;\n      };\n    };\n\n    var eventRoutes = {\n      DID_DESTROY: createEvent('destroy'),\n\n      DID_INIT: createEvent('init'),\n\n      DID_THROW_MAX_FILES: createEvent('warning'),\n\n      DID_INIT_ITEM: createEvent('initfile'),\n      DID_START_ITEM_LOAD: createEvent('addfilestart'),\n      DID_UPDATE_ITEM_LOAD_PROGRESS: createEvent('addfileprogress'),\n      DID_LOAD_ITEM: createEvent('addfile'),\n\n      DID_THROW_ITEM_INVALID: [createEvent('error'), createEvent('addfile')],\n\n      DID_THROW_ITEM_LOAD_ERROR: [createEvent('error'), createEvent('addfile')],\n\n      DID_THROW_ITEM_REMOVE_ERROR: [\n        createEvent('error'),\n        createEvent('removefile')\n      ],\n\n      DID_PREPARE_OUTPUT: createEvent('preparefile'),\n\n      DID_START_ITEM_PROCESSING: createEvent('processfilestart'),\n      DID_UPDATE_ITEM_PROCESS_PROGRESS: createEvent('processfileprogress'),\n      DID_ABORT_ITEM_PROCESSING: createEvent('processfileabort'),\n      DID_COMPLETE_ITEM_PROCESSING: createEvent('processfile'),\n      DID_COMPLETE_ITEM_PROCESSING_ALL: createEvent('processfiles'),\n      DID_REVERT_ITEM_PROCESSING: createEvent('processfilerevert'),\n\n      DID_THROW_ITEM_PROCESSING_ERROR: [\n        createEvent('error'),\n        createEvent('processfile')\n      ],\n\n      DID_REMOVE_ITEM: createEvent('removefile'),\n\n      DID_UPDATE_ITEMS: createEvent('updatefiles'),\n\n      DID_ACTIVATE_ITEM: createEvent('activatefile'),\n\n      DID_REORDER_ITEMS: createEvent('reorderfiles')\n    };\n\n    var exposeEvent = function exposeEvent(event) {\n      // create event object to be dispatched\n      var detail = Object.assign({ pond: exports }, event);\n      delete detail.type;\n      view.element.dispatchEvent(\n        new CustomEvent('FilePond:' + event.type, {\n          // event info\n          detail: detail,\n\n          // event behaviour\n          bubbles: true,\n          cancelable: true,\n          composed: true // triggers listeners outside of shadow root\n        })\n      );\n\n      // event object to params used for `on()` event handlers and callbacks `oninit()`\n      var params = [];\n\n      // if is possible error event, make it the first param\n      if (event.hasOwnProperty('error')) {\n        params.push(event.error);\n      }\n\n      // file is always section\n      if (event.hasOwnProperty('file')) {\n        params.push(event.file);\n      }\n\n      // append other props\n      var filtered = ['type', 'error', 'file'];\n      Object.keys(event)\n        .filter(function(key) {\n          return !filtered.includes(key);\n        })\n        .forEach(function(key) {\n          return params.push(event[key]);\n        });\n\n      // on(type, () => { })\n      exports.fire.apply(exports, [event.type].concat(params));\n\n      // oninit = () => {}\n      var handler = store.query('GET_ON' + event.type.toUpperCase());\n      if (handler) {\n        handler.apply(void 0, params);\n      }\n    };\n\n    var routeActionsToEvents = function routeActionsToEvents(actions) {\n      if (!actions.length) return;\n      actions\n        .filter(function(action) {\n          return eventRoutes[action.type];\n        })\n        .forEach(function(action) {\n          var routes = eventRoutes[action.type];\n          (Array.isArray(routes) ? routes : [routes]).forEach(function(route) {\n            // this isn't fantastic, but because of the stacking of settimeouts plugins can handle the did_load before the did_init\n            if (action.type === 'DID_INIT_ITEM') {\n              exposeEvent(route(action.data));\n            } else {\n              setTimeout(function() {\n                exposeEvent(route(action.data));\n              }, 0);\n            }\n          });\n        });\n    };\n\n    //\n    // PUBLIC API -------------------------------------------------------------------------------------\n    //\n    var setOptions = function setOptions(options) {\n      return store.dispatch('SET_OPTIONS', { options: options });\n    };\n\n    var getFile = function getFile(query) {\n      return store.query('GET_ACTIVE_ITEM', query);\n    };\n\n    var prepareFile = function prepareFile(query) {\n      return new Promise(function(resolve, reject) {\n        store.dispatch('REQUEST_ITEM_PREPARE', {\n          query: query,\n          success: function success(item) {\n            resolve(item);\n          },\n          failure: function failure(error) {\n            reject(error);\n          }\n        });\n      });\n    };\n\n    var addFile = function addFile(source) {\n      var options =\n        arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return new Promise(function(resolve, reject) {\n        addFiles([{ source: source, options: options }], {\n          index: options.index\n        })\n          .then(function(items) {\n            return resolve(items && items[0]);\n          })\n          .catch(reject);\n      });\n    };\n\n    var isFilePondFile = function isFilePondFile(obj) {\n      return obj.file && obj.id;\n    };\n\n    var removeFile = function removeFile(query, options) {\n      // if only passed options\n      if (typeof query === 'object' && !isFilePondFile(query) && !options) {\n        options = query;\n        query = undefined;\n      }\n\n      // request item removal\n      store.dispatch(\n        'REMOVE_ITEM',\n        Object.assign({}, options, { query: query })\n      );\n\n      // see if item has been removed\n      return store.query('GET_ACTIVE_ITEM', query) === null;\n    };\n\n    var addFiles = function addFiles() {\n      for (\n        var _len = arguments.length, args = new Array(_len), _key = 0;\n        _key < _len;\n        _key++\n      ) {\n        args[_key] = arguments[_key];\n      }\n      return new Promise(function(resolve, reject) {\n        var sources = [];\n        var options = {};\n\n        // user passed a sources array\n        if (isArray(args[0])) {\n          sources.push.apply(sources, args[0]);\n          Object.assign(options, args[1] || {});\n        } else {\n          // user passed sources as arguments, last one might be options object\n          var lastArgument = args[args.length - 1];\n          if (\n            typeof lastArgument === 'object' &&\n            !(lastArgument instanceof Blob)\n          ) {\n            Object.assign(options, args.pop());\n          }\n\n          // add rest to sources\n          sources.push.apply(sources, args);\n        }\n\n        store.dispatch('ADD_ITEMS', {\n          items: sources,\n          index: options.index,\n          interactionMethod: InteractionMethod.API,\n          success: resolve,\n          failure: reject\n        });\n      });\n    };\n\n    var getFiles = function getFiles() {\n      return store.query('GET_ACTIVE_ITEMS');\n    };\n\n    var processFile = function processFile(query) {\n      return new Promise(function(resolve, reject) {\n        store.dispatch('REQUEST_ITEM_PROCESSING', {\n          query: query,\n          success: function success(item) {\n            resolve(item);\n          },\n          failure: function failure(error) {\n            reject(error);\n          }\n        });\n      });\n    };\n\n    var prepareFiles = function prepareFiles() {\n      for (\n        var _len2 = arguments.length, args = new Array(_len2), _key2 = 0;\n        _key2 < _len2;\n        _key2++\n      ) {\n        args[_key2] = arguments[_key2];\n      }\n      var queries = Array.isArray(args[0]) ? args[0] : args;\n      var items = queries.length ? queries : getFiles();\n      return Promise.all(items.map(prepareFile));\n    };\n\n    var processFiles = function processFiles() {\n      for (\n        var _len3 = arguments.length, args = new Array(_len3), _key3 = 0;\n        _key3 < _len3;\n        _key3++\n      ) {\n        args[_key3] = arguments[_key3];\n      }\n      var queries = Array.isArray(args[0]) ? args[0] : args;\n      if (!queries.length) {\n        var files = getFiles().filter(function(item) {\n          return (\n            !(\n              item.status === ItemStatus.IDLE &&\n              item.origin === FileOrigin.LOCAL\n            ) &&\n            item.status !== ItemStatus.PROCESSING &&\n            item.status !== ItemStatus.PROCESSING_COMPLETE &&\n            item.status !== ItemStatus.PROCESSING_REVERT_ERROR\n          );\n        });\n\n        return Promise.all(files.map(processFile));\n      }\n      return Promise.all(queries.map(processFile));\n    };\n\n    var removeFiles = function removeFiles() {\n      for (\n        var _len4 = arguments.length, args = new Array(_len4), _key4 = 0;\n        _key4 < _len4;\n        _key4++\n      ) {\n        args[_key4] = arguments[_key4];\n      }\n\n      var queries = Array.isArray(args[0]) ? args[0] : args;\n\n      var options;\n      if (typeof queries[queries.length - 1] === 'object') {\n        options = queries.pop();\n      } else if (Array.isArray(args[0])) {\n        options = args[1];\n      }\n\n      var files = getFiles();\n\n      if (!queries.length)\n        return Promise.all(\n          files.map(function(file) {\n            return removeFile(file, options);\n          })\n        );\n\n      // when removing by index the indexes shift after each file removal so we need to convert indexes to ids\n      var mappedQueries = queries\n        .map(function(query) {\n          return isNumber(query)\n            ? files[query]\n              ? files[query].id\n              : null\n            : query;\n        })\n        .filter(function(query) {\n          return query;\n        });\n\n      return mappedQueries.map(function(q) {\n        return removeFile(q, options);\n      });\n    };\n\n    var exports = Object.assign(\n      {},\n\n      on(),\n      {},\n\n      readWriteApi,\n      {},\n\n      createOptionAPI(store, defaultOptions),\n      {\n        /**\n         * Override options defined in options object\n         * @param options\n         */\n        setOptions: setOptions,\n\n        /**\n         * Load the given file\n         * @param source - the source of the file (either a File, base64 data uri or url)\n         * @param options - object, { index: 0 }\n         */\n        addFile: addFile,\n\n        /**\n         * Load the given files\n         * @param sources - the sources of the files to load\n         * @param options - object, { index: 0 }\n         */\n        addFiles: addFiles,\n\n        /**\n         * Returns the file objects matching the given query\n         * @param query { string, number, null }\n         */\n        getFile: getFile,\n\n        /**\n         * Upload file with given name\n         * @param query { string, number, null  }\n         */\n        processFile: processFile,\n\n        /**\n         * Request prepare output for file with given name\n         * @param query { string, number, null  }\n         */\n        prepareFile: prepareFile,\n\n        /**\n         * Removes a file by its name\n         * @param query { string, number, null  }\n         */\n        removeFile: removeFile,\n\n        /**\n         * Moves a file to a new location in the files list\n         */\n        moveFile: function moveFile(query, index) {\n          return store.dispatch('MOVE_ITEM', { query: query, index: index });\n        },\n\n        /**\n         * Returns all files (wrapped in public api)\n         */\n        getFiles: getFiles,\n\n        /**\n         * Starts uploading all files\n         */\n        processFiles: processFiles,\n\n        /**\n         * Clears all files from the files list\n         */\n        removeFiles: removeFiles,\n\n        /**\n         * Starts preparing output of all files\n         */\n        prepareFiles: prepareFiles,\n\n        /**\n         * Sort list of files\n         */\n        sort: function sort(compare) {\n          return store.dispatch('SORT', { compare: compare });\n        },\n\n        /**\n         * Browse the file system for a file\n         */\n        browse: function browse() {\n          // needs to be trigger directly as user action needs to be traceable (is not traceable in requestAnimationFrame)\n          var input = view.element.querySelector('input[type=file]');\n          if (input) {\n            input.click();\n          }\n        },\n\n        /**\n         * Destroys the app\n         */\n        destroy: function destroy() {\n          // request destruction\n          exports.fire('destroy', view.element);\n\n          // stop active processes (file uploads, fetches, stuff like that)\n          // loop over items and depending on states call abort for ongoing processes\n          store.dispatch('ABORT_ALL');\n\n          // destroy view\n          view._destroy();\n\n          // stop listening to resize\n          window.removeEventListener('resize', resizeHandler);\n\n          // stop listening to the visiblitychange event\n          document.removeEventListener('visibilitychange', visibilityHandler);\n\n          // dispatch destroy\n          store.dispatch('DID_DESTROY');\n        },\n\n        /**\n         * Inserts the plugin before the target element\n         */\n        insertBefore: function insertBefore$1(element) {\n          return insertBefore(view.element, element);\n        },\n\n        /**\n         * Inserts the plugin after the target element\n         */\n        insertAfter: function insertAfter$1(element) {\n          return insertAfter(view.element, element);\n        },\n\n        /**\n         * Appends the plugin to the target element\n         */\n        appendTo: function appendTo(element) {\n          return element.appendChild(view.element);\n        },\n\n        /**\n         * Replaces an element with the app\n         */\n        replaceElement: function replaceElement(element) {\n          // insert the app before the element\n          insertBefore(view.element, element);\n\n          // remove the original element\n          element.parentNode.removeChild(element);\n\n          // remember original element\n          originalElement = element;\n        },\n\n        /**\n         * Restores the original element\n         */\n        restoreElement: function restoreElement() {\n          if (!originalElement) {\n            return; // no element to restore\n          }\n\n          // restore original element\n          insertAfter(originalElement, view.element);\n\n          // remove our element\n          view.element.parentNode.removeChild(view.element);\n\n          // remove reference\n          originalElement = null;\n        },\n\n        /**\n         * Returns true if the app root is attached to given element\n         * @param element\n         */\n        isAttachedTo: function isAttachedTo(element) {\n          return view.element === element || originalElement === element;\n        },\n\n        /**\n         * Returns the root element\n         */\n        element: {\n          get: function get() {\n            return view.element;\n          }\n        },\n\n        /**\n         * Returns the current pond status\n         */\n        status: {\n          get: function get() {\n            return store.query('GET_STATUS');\n          }\n        }\n      }\n    );\n\n    // Done!\n    store.dispatch('DID_INIT');\n\n    // create actual api object\n    return createObject(exports);\n  };\n\n  var createAppObject = function createAppObject() {\n    var customOptions =\n      arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    // default options\n    var defaultOptions = {};\n    forin(getOptions(), function(key, value) {\n      defaultOptions[key] = value[0];\n    });\n\n    // set app options\n    var app = createApp(\n      Object.assign(\n        {},\n\n        defaultOptions,\n        {},\n\n        customOptions\n      )\n    );\n\n    // return the plugin instance\n    return app;\n  };\n\n  var lowerCaseFirstLetter = function lowerCaseFirstLetter(string) {\n    return string.charAt(0).toLowerCase() + string.slice(1);\n  };\n\n  var attributeNameToPropertyName = function attributeNameToPropertyName(\n    attributeName\n  ) {\n    return toCamels(attributeName.replace(/^data-/, ''));\n  };\n\n  var mapObject = function mapObject(object, propertyMap) {\n    // remove unwanted\n    forin(propertyMap, function(selector, mapping) {\n      forin(object, function(property, value) {\n        // create regexp shortcut\n        var selectorRegExp = new RegExp(selector);\n\n        // tests if\n        var matches = selectorRegExp.test(property);\n\n        // no match, skip\n        if (!matches) {\n          return;\n        }\n\n        // if there's a mapping, the original property is always removed\n        delete object[property];\n\n        // should only remove, we done!\n        if (mapping === false) {\n          return;\n        }\n\n        // move value to new property\n        if (isString(mapping)) {\n          object[mapping] = value;\n          return;\n        }\n\n        // move to group\n        var group = mapping.group;\n        if (isObject(mapping) && !object[group]) {\n          object[group] = {};\n        }\n\n        object[group][\n          lowerCaseFirstLetter(property.replace(selectorRegExp, ''))\n        ] = value;\n      });\n\n      // do submapping\n      if (mapping.mapping) {\n        mapObject(object[mapping.group], mapping.mapping);\n      }\n    });\n  };\n\n  var getAttributesAsObject = function getAttributesAsObject(node) {\n    var attributeMapping =\n      arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    // turn attributes into object\n    var attributes = [];\n    forin(node.attributes, function(index) {\n      attributes.push(node.attributes[index]);\n    });\n\n    var output = attributes\n      .filter(function(attribute) {\n        return attribute.name;\n      })\n      .reduce(function(obj, attribute) {\n        var value = attr(node, attribute.name);\n\n        obj[attributeNameToPropertyName(attribute.name)] =\n          value === attribute.name ? true : value;\n        return obj;\n      }, {});\n\n    // do mapping of object properties\n    mapObject(output, attributeMapping);\n\n    return output;\n  };\n\n  var createAppAtElement = function createAppAtElement(element) {\n    var options =\n      arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    // how attributes of the input element are mapped to the options for the plugin\n    var attributeMapping = {\n      // translate to other name\n      '^class$': 'className',\n      '^multiple$': 'allowMultiple',\n      '^capture$': 'captureMethod',\n      '^webkitdirectory$': 'allowDirectoriesOnly',\n\n      // group under single property\n      '^server': {\n        group: 'server',\n        mapping: {\n          '^process': {\n            group: 'process'\n          },\n\n          '^revert': {\n            group: 'revert'\n          },\n\n          '^fetch': {\n            group: 'fetch'\n          },\n\n          '^restore': {\n            group: 'restore'\n          },\n\n          '^load': {\n            group: 'load'\n          }\n        }\n      },\n\n      // don't include in object\n      '^type$': false,\n      '^files$': false\n    };\n\n    // add additional option translators\n    applyFilters('SET_ATTRIBUTE_TO_OPTION_MAP', attributeMapping);\n\n    // create final options object by setting options object and then overriding options supplied on element\n    var mergedOptions = Object.assign({}, options);\n\n    var attributeOptions = getAttributesAsObject(\n      element.nodeName === 'FIELDSET'\n        ? element.querySelector('input[type=file]')\n        : element,\n      attributeMapping\n    );\n\n    // merge with options object\n    Object.keys(attributeOptions).forEach(function(key) {\n      if (isObject(attributeOptions[key])) {\n        if (!isObject(mergedOptions[key])) {\n          mergedOptions[key] = {};\n        }\n        Object.assign(mergedOptions[key], attributeOptions[key]);\n      } else {\n        mergedOptions[key] = attributeOptions[key];\n      }\n    });\n\n    // if parent is a fieldset, get files from parent by selecting all input fields that are not file upload fields\n    // these will then be automatically set to the initial files\n    mergedOptions.files = (options.files || []).concat(\n      Array.from(element.querySelectorAll('input:not([type=file])')).map(\n        function(input) {\n          return {\n            source: input.value,\n            options: {\n              type: input.dataset.type\n            }\n          };\n        }\n      )\n    );\n\n    // build plugin\n    var app = createAppObject(mergedOptions);\n\n    // add already selected files\n    if (element.files) {\n      Array.from(element.files).forEach(function(file) {\n        app.addFile(file);\n      });\n    }\n\n    // replace the target element\n    app.replaceElement(element);\n\n    // expose\n    return app;\n  };\n\n  // if an element is passed, we create the instance at that element, if not, we just create an up object\n  var createApp$1 = function createApp() {\n    return isNode(arguments.length <= 0 ? undefined : arguments[0])\n      ? createAppAtElement.apply(void 0, arguments)\n      : createAppObject.apply(void 0, arguments);\n  };\n\n  var PRIVATE_METHODS = ['fire', '_read', '_write'];\n\n  var createAppAPI = function createAppAPI(app) {\n    var api = {};\n\n    copyObjectPropertiesToObject(app, api, PRIVATE_METHODS);\n\n    return api;\n  };\n\n  /**\n   * Replaces placeholders in given string with replacements\n   * @param string - \"Foo {bar}\"\"\n   * @param replacements - { \"bar\": 10 }\n   */\n  var replaceInString = function replaceInString(string, replacements) {\n    return string.replace(/(?:{([a-zA-Z]+)})/g, function(match, group) {\n      return replacements[group];\n    });\n  };\n\n  var createWorker = function createWorker(fn) {\n    var workerBlob = new Blob(['(', fn.toString(), ')()'], {\n      type: 'application/javascript'\n    });\n\n    var workerURL = URL.createObjectURL(workerBlob);\n    var worker = new Worker(workerURL);\n\n    return {\n      transfer: function transfer(message, cb) {},\n      post: function post(message, cb, transferList) {\n        var id = getUniqueId();\n\n        worker.onmessage = function(e) {\n          if (e.data.id === id) {\n            cb(e.data.message);\n          }\n        };\n\n        worker.postMessage(\n          {\n            id: id,\n            message: message\n          },\n\n          transferList\n        );\n      },\n      terminate: function terminate() {\n        worker.terminate();\n        URL.revokeObjectURL(workerURL);\n      }\n    };\n  };\n\n  var loadImage = function loadImage(url) {\n    return new Promise(function(resolve, reject) {\n      var img = new Image();\n      img.onload = function() {\n        resolve(img);\n      };\n      img.onerror = function(e) {\n        reject(e);\n      };\n      img.src = url;\n    });\n  };\n\n  var renameFile = function renameFile(file, name) {\n    var renamedFile = file.slice(0, file.size, file.type);\n    renamedFile.lastModifiedDate = file.lastModifiedDate;\n    renamedFile.name = name;\n    return renamedFile;\n  };\n\n  var copyFile = function copyFile(file) {\n    return renameFile(file, file.name);\n  };\n\n  // already registered plugins (can't register twice)\n  var registeredPlugins = [];\n\n  // pass utils to plugin\n  var createAppPlugin = function createAppPlugin(plugin) {\n    // already registered\n    if (registeredPlugins.includes(plugin)) {\n      return;\n    }\n\n    // remember this plugin\n    registeredPlugins.push(plugin);\n\n    // setup!\n    var pluginOutline = plugin({\n      addFilter: addFilter,\n      utils: {\n        Type: Type,\n        forin: forin,\n        isString: isString,\n        isFile: isFile,\n        toNaturalFileSize: toNaturalFileSize,\n        replaceInString: replaceInString,\n        getExtensionFromFilename: getExtensionFromFilename,\n        getFilenameWithoutExtension: getFilenameWithoutExtension,\n        guesstimateMimeType: guesstimateMimeType,\n        getFileFromBlob: getFileFromBlob,\n        getFilenameFromURL: getFilenameFromURL,\n        createRoute: createRoute,\n        createWorker: createWorker,\n        createView: createView,\n        createItemAPI: createItemAPI,\n        loadImage: loadImage,\n        copyFile: copyFile,\n        renameFile: renameFile,\n        createBlob: createBlob,\n        applyFilterChain: applyFilterChain,\n        text: text,\n        getNumericAspectRatioFromString: getNumericAspectRatioFromString\n      },\n\n      views: {\n        fileActionButton: fileActionButton\n      }\n    });\n\n    // add plugin options to default options\n    extendDefaultOptions(pluginOutline.options);\n  };\n\n  // feature detection used by supported() method\n  var isOperaMini = function isOperaMini() {\n    return (\n      Object.prototype.toString.call(window.operamini) === '[object OperaMini]'\n    );\n  };\n  var hasPromises = function hasPromises() {\n    return 'Promise' in window;\n  };\n  var hasBlobSlice = function hasBlobSlice() {\n    return 'slice' in Blob.prototype;\n  };\n  var hasCreateObjectURL = function hasCreateObjectURL() {\n    return 'URL' in window && 'createObjectURL' in window.URL;\n  };\n  var hasVisibility = function hasVisibility() {\n    return 'visibilityState' in document;\n  };\n  var hasTiming = function hasTiming() {\n    return 'performance' in window;\n  }; // iOS 8.x\n  var hasCSSSupports = function hasCSSSupports() {\n    return 'supports' in (window.CSS || {});\n  }; // use to detect Safari 9+\n  var isIE11 = function isIE11() {\n    return /MSIE|Trident/.test(window.navigator.userAgent);\n  };\n\n  var supported = (function() {\n    // Runs immediately and then remembers result for subsequent calls\n    var isSupported =\n      // Has to be a browser\n      isBrowser() &&\n      // Can't run on Opera Mini due to lack of everything\n      !isOperaMini() &&\n      // Require these APIs to feature detect a modern browser\n      hasVisibility() &&\n      hasPromises() &&\n      hasBlobSlice() &&\n      hasCreateObjectURL() &&\n      hasTiming() &&\n      // doesn't need CSSSupports but is a good way to detect Safari 9+ (we do want to support IE11 though)\n      (hasCSSSupports() || isIE11());\n\n    return function() {\n      return isSupported;\n    };\n  })();\n\n  /**\n   * Plugin internal state (over all instances)\n   */\n  var state = {\n    // active app instances, used to redraw the apps and to find the later\n    apps: []\n  };\n\n  // plugin name\n  var name = 'filepond';\n\n  /**\n   * Public Plugin methods\n   */\n  var fn = function fn() {};\n  exports.Status = {};\n  exports.FileStatus = {};\n  exports.FileOrigin = {};\n  exports.OptionTypes = {};\n  exports.create = fn;\n  exports.destroy = fn;\n  exports.parse = fn;\n  exports.find = fn;\n  exports.registerPlugin = fn;\n  exports.getOptions = fn;\n  exports.setOptions = fn;\n\n  // if not supported, no API\n  if (supported()) {\n    // start painter and fire load event\n    createPainter(\n      function() {\n        state.apps.forEach(function(app) {\n          return app._read();\n        });\n      },\n      function(ts) {\n        state.apps.forEach(function(app) {\n          return app._write(ts);\n        });\n      }\n    );\n\n    // fire loaded event so we know when FilePond is available\n    var dispatch = function dispatch() {\n      // let others know we have area ready\n      document.dispatchEvent(\n        new CustomEvent('FilePond:loaded', {\n          detail: {\n            supported: supported,\n            create: exports.create,\n            destroy: exports.destroy,\n            parse: exports.parse,\n            find: exports.find,\n            registerPlugin: exports.registerPlugin,\n            setOptions: exports.setOptions\n          }\n        })\n      );\n\n      // clean up event\n      document.removeEventListener('DOMContentLoaded', dispatch);\n    };\n\n    if (document.readyState !== 'loading') {\n      // move to back of execution queue, FilePond should have been exported by then\n      setTimeout(function() {\n        return dispatch();\n      }, 0);\n    } else {\n      document.addEventListener('DOMContentLoaded', dispatch);\n    }\n\n    // updates the OptionTypes object based on the current options\n    var updateOptionTypes = function updateOptionTypes() {\n      return forin(getOptions(), function(key, value) {\n        exports.OptionTypes[key] = value[1];\n      });\n    };\n\n    exports.Status = Object.assign({}, Status);\n    exports.FileOrigin = Object.assign({}, FileOrigin);\n    exports.FileStatus = Object.assign({}, ItemStatus);\n\n    exports.OptionTypes = {};\n    updateOptionTypes();\n\n    // create method, creates apps and adds them to the app array\n    exports.create = function create() {\n      var app = createApp$1.apply(void 0, arguments);\n      app.on('destroy', exports.destroy);\n      state.apps.push(app);\n      return createAppAPI(app);\n    };\n\n    // destroys apps and removes them from the app array\n    exports.destroy = function destroy(hook) {\n      // returns true if the app was destroyed successfully\n      var indexToRemove = state.apps.findIndex(function(app) {\n        return app.isAttachedTo(hook);\n      });\n      if (indexToRemove >= 0) {\n        // remove from apps\n        var app = state.apps.splice(indexToRemove, 1)[0];\n\n        // restore original dom element\n        app.restoreElement();\n\n        return true;\n      }\n\n      return false;\n    };\n\n    // parses the given context for plugins (does not include the context element itself)\n    exports.parse = function parse(context) {\n      // get all possible hooks\n      var matchedHooks = Array.from(context.querySelectorAll('.' + name));\n\n      // filter out already active hooks\n      var newHooks = matchedHooks.filter(function(newHook) {\n        return !state.apps.find(function(app) {\n          return app.isAttachedTo(newHook);\n        });\n      });\n\n      // create new instance for each hook\n      return newHooks.map(function(hook) {\n        return exports.create(hook);\n      });\n    };\n\n    // returns an app based on the given element hook\n    exports.find = function find(hook) {\n      var app = state.apps.find(function(app) {\n        return app.isAttachedTo(hook);\n      });\n      if (!app) {\n        return null;\n      }\n      return createAppAPI(app);\n    };\n\n    // adds a plugin extension\n    exports.registerPlugin = function registerPlugin() {\n      for (\n        var _len = arguments.length, plugins = new Array(_len), _key = 0;\n        _key < _len;\n        _key++\n      ) {\n        plugins[_key] = arguments[_key];\n      }\n\n      // register plugins\n      plugins.forEach(createAppPlugin);\n\n      // update OptionTypes, each plugin might have extended the default options\n      updateOptionTypes();\n    };\n\n    exports.getOptions = function getOptions$1() {\n      var opts = {};\n      forin(getOptions(), function(key, value) {\n        opts[key] = value[0];\n      });\n      return opts;\n    };\n\n    exports.setOptions = function setOptions$1(opts) {\n      if (isObject(opts)) {\n        // update existing plugins\n        state.apps.forEach(function(app) {\n          app.setOptions(opts);\n        });\n\n        // override defaults\n        setOptions(opts);\n      }\n\n      // return new options\n      return exports.getOptions();\n    };\n  }\n\n  exports.supported = supported;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmlsZXBvbmQvZGlzdC9maWxlcG9uZC5qcz9jMDYyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxFQUFFLEtBQTREO0FBQzlEO0FBQ0EsTUFBTSxTQUU0RDtBQUNsRSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQzs7QUFFaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix5QkFBeUI7QUFDckQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFDQUFxQyxrQkFBa0I7QUFDdkQsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQzs7QUFFcEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0JBQStCOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsK0NBQStDO0FBQy9DLCtDQUErQztBQUMvQyxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVCw2Q0FBNkM7QUFDN0M7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVCw2Q0FBNkM7QUFDN0M7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0I7QUFDeEIsd0JBQXdCLGVBQWUsc0JBQXNCO0FBQzdELHdCQUF3QixlQUFlLEtBQUssc0JBQXNCLEVBQUU7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBEQUEwRDs7QUFFMUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qzs7QUFFdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDOztBQUV2QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1Qiw0QkFBNEI7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG9EQUFvRDs7QUFFcEQ7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFO0FBQzdFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7O0FBRUE7QUFDQTtBQUNBLHlDQUF5Qzs7QUFFekM7QUFDQTtBQUNBLHFDQUFxQztBQUNyQzs7QUFFQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlDQUF5QztBQUN6Qzs7QUFFQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLHVCQUF1QixrQ0FBa0M7QUFDekQsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixVQUFVO0FBQzNCLHFCQUFxQixPQUFPO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTs7QUFFeEI7QUFDQSx1Q0FBdUMsNEJBQTRCO0FBQ25FO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUEscUJBQXFCLG9CQUFvQjtBQUN6QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxxQkFBcUIsMEJBQTBCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRFQUE0RTtBQUM1RTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsdUJBQXVCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQiw2QkFBNkI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbURBQW1ELGdCQUFnQjtBQUNuRTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsbUJBQW1CO0FBQ3hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDJCQUEyQixzQkFBc0I7QUFDakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBLDJDQUEyQyxRQUFRO0FBQ25EO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDJCQUEyQix5QkFBeUI7QUFDcEQsaUNBQWlDLHFCQUFxQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIscUJBQXFCO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0MsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVzs7QUFFWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBLHlCQUF5QixtQkFBbUI7QUFDNUM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCO0FBQzNCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87O0FBRVA7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBNEMsd0JBQXdCLDJCQUEyQjtBQUMvRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLHVCQUF1QjtBQUMxQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLElBQUksSUFBSTtBQUNwRCxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUEsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDLDBDQUEwQztBQUMxQyxrQ0FBa0M7QUFDbEMsd0NBQXdDO0FBQ3hDLG9DQUFvQztBQUNwQyxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBLGFBQWE7O0FBRWIsMENBQTBDO0FBQzFDO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIscUJBQXFCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDLHlCQUF5QjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0ZBQXNGO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnREFBZ0Q7QUFDaEQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCx3QkFBd0Isd0JBQXdCO0FBQ2hELG1CQUFtQixtQkFBbUI7QUFDdEMsbUJBQW1CLG1CQUFtQjtBQUN0QyxlQUFlLGVBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MscUNBQXFDO0FBQ3pFLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0Esa0RBQWtELFNBQVMsYUFBYTtBQUN4RSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUE0QixzQkFBc0IsaUJBQWlCLEVBQUU7QUFDckU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLGtEQUFrRCxTQUFTLGFBQWE7QUFDeEUsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLCtCQUErQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEIsYUFBYTtBQUN2QywwQkFBMEIsYUFBYTtBQUN2Qyx1QkFBdUIsYUFBYTtBQUNwQyx3QkFBd0IsYUFBYTtBQUNyQyxnQ0FBZ0MsYUFBYTtBQUM3QyxnQ0FBZ0MsYUFBYTtBQUM3QyxpQ0FBaUMsYUFBYTtBQUM5Qyw0QkFBNEIsK0NBQStDO0FBQzNFO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxrQ0FBa0MseUNBQXlDO0FBQzNFLFdBQVcsMkNBQTJDO0FBQ3RELGFBQWE7QUFDYjs7QUFFQTtBQUNBLHVCQUF1QixhQUFhO0FBQ3BDLHdCQUF3QixhQUFhO0FBQ3JDLFdBQVcsc0NBQXNDO0FBQ2pELGFBQWE7QUFDYjs7QUFFQTtBQUNBLGdDQUFnQyxhQUFhO0FBQzdDLCtCQUErQixhQUFhO0FBQzVDLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0EseUJBQXlCLGFBQWE7QUFDdEMsYUFBYSxzQ0FBc0M7QUFDbkQsZUFBZTtBQUNmLEtBQUs7O0FBRUw7QUFDQSw0QkFBNEIsYUFBYTtBQUN6Qyw4QkFBOEIsYUFBYTtBQUMzQyxlQUFlO0FBQ2YsS0FBSzs7QUFFTDtBQUNBLDRCQUE0QixhQUFhO0FBQ3pDLHlCQUF5QixhQUFhO0FBQ3RDLGFBQWEsc0NBQXNDO0FBQ25ELGVBQWU7QUFDZixLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLGFBQWEsc0NBQXNDO0FBQ25ELGVBQWU7QUFDZixLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLHlCQUF5QixhQUFhO0FBQ3RDLGFBQWEsc0NBQXNDO0FBQ25ELGVBQWU7QUFDZixLQUFLOztBQUVMO0FBQ0E7QUFDQSx5QkFBeUIsYUFBYTtBQUN0QyxhQUFhLHNDQUFzQztBQUNuRCxlQUFlO0FBQ2YsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxhQUFhO0FBQ2hELGFBQWEsYUFBYTtBQUMxQixlQUFlO0FBQ2YsS0FBSzs7QUFFTDtBQUNBLHlCQUF5QixhQUFhO0FBQ3RDLGtDQUFrQyxhQUFhO0FBQy9DLGVBQWUsYUFBYTtBQUM1QixhQUFhO0FBQ2IsS0FBSzs7QUFFTDtBQUNBLG1DQUFtQyxhQUFhO0FBQ2hELGVBQWUsYUFBYTtBQUM1QixhQUFhO0FBQ2IsS0FBSzs7QUFFTDtBQUNBLHlCQUF5QixhQUFhO0FBQ3RDLDBCQUEwQixhQUFhO0FBQ3ZDLGFBQWEsc0NBQXNDO0FBQ25ELGVBQWU7QUFDZixLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFlBQVk7QUFDdEQsT0FBTzs7QUFFUDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0NBQXNDLFNBQVM7QUFDL0M7O0FBRUE7QUFDQTtBQUNBLHdDQUF3QyxTQUFTO0FBQ2pEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsNkNBQTZDOztBQUV4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELFNBQVMsYUFBYTtBQUN4RSxLQUFLO0FBQ0w7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQyxlQUFlO0FBQ2pEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxrREFBa0QsU0FBUyxhQUFhO0FBQ3hFLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRzs7QUFFSCw0QkFBNEI7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaURBQWlELGVBQWU7QUFDaEU7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5Q0FBeUMsZUFBZTtBQUN4RDs7QUFFQTtBQUNBO0FBQ0EsbUNBQW1DLHFCQUFxQjtBQUN4RDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsc0NBQXNDLHFDQUFxQzs7QUFFM0U7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDLHFDQUFxQztBQUM3RTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDLHFDQUFxQzs7QUFFN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDZDQUE2QztBQUM5RDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsa0JBQWtCO0FBQ3ZELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5QkFBeUIsV0FBVztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVDQUF1QyxTQUFTOztBQUVoRDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLE9BQU87QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsNEJBQTRCOztBQUU1RDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsNkNBQTZDO0FBQzFEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSw2Q0FBNkM7O0FBRTFEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsS0FBSztBQUNMO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsS0FBSztBQUNMO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsS0FBSztBQUNMLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsS0FBSztBQUNMO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsK0JBQStCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsNkNBQTZDO0FBQzFEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtREFBbUQ7QUFDbkQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQyxvQ0FBb0M7QUFDcEMsa0NBQWtDO0FBQ2xDLGtDQUFrQztBQUNsQyxrQ0FBa0M7QUFDbEM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxrQ0FBa0M7QUFDbEMsNENBQTRDO0FBQzVDLGtDQUFrQztBQUNsQyx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQ0FBMEMsbUJBQW1CO0FBQzdEOztBQUVBO0FBQ0E7QUFDQSxtQ0FBbUMscUJBQXFCO0FBQ3hEOztBQUVBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7O0FBRUE7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsaUJBQWlCO0FBQzVFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLDZDQUE2Qzs7QUFFMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsYUFBYTtBQUNwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQSx1Q0FBdUM7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDNUQsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTyxJQUFJOztBQUVYO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHdDQUF3Qzs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQkFBMkIsSUFBSTtBQUMvQiw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBLCtCQUErQixZQUFZO0FBQzNDO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsMENBQTBDO0FBQzFDLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBLHFDQUFxQztBQUNyQyx5Q0FBeUM7QUFDekMseUNBQXlDOztBQUV6QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGdEQUFnRCxjQUFjO0FBQzlELENBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmlsZXBvbmQvZGlzdC9maWxlcG9uZC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogRmlsZVBvbmQgNC4yNS4xXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQsIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUL1xuICogUGxlYXNlIHZpc2l0IGh0dHBzOi8vcHFpbmEubmwvZmlsZXBvbmQvIGZvciBkZXRhaWxzLlxuICovXG5cbi8qIGVzbGludC1kaXNhYmxlICovXG5cbihmdW5jdGlvbihnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXG4gICAgPyBmYWN0b3J5KGV4cG9ydHMpXG4gICAgOiB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWRcbiAgICA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSlcbiAgICA6ICgoZ2xvYmFsID0gZ2xvYmFsIHx8IHNlbGYpLCBmYWN0b3J5KChnbG9iYWwuRmlsZVBvbmQgPSB7fSkpKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBpc05vZGUgPSBmdW5jdGlvbiBpc05vZGUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudDtcbiAgfTtcblxuICB2YXIgY3JlYXRlU3RvcmUgPSBmdW5jdGlvbiBjcmVhdGVTdG9yZShpbml0aWFsU3RhdGUpIHtcbiAgICB2YXIgcXVlcmllcyA9XG4gICAgICBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFtdO1xuICAgIHZhciBhY3Rpb25zID1cbiAgICAgIGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogW107XG4gICAgLy8gaW50ZXJuYWwgc3RhdGVcbiAgICB2YXIgc3RhdGUgPSBPYmplY3QuYXNzaWduKHt9LCBpbml0aWFsU3RhdGUpO1xuXG4gICAgLy8gY29udGFpbnMgYWxsIGFjdGlvbnMgZm9yIG5leHQgZnJhbWUsIGlzIGNsZWFyIHdoZW4gYWN0aW9ucyBhcmUgcmVxdWVzdGVkXG4gICAgdmFyIGFjdGlvblF1ZXVlID0gW107XG4gICAgdmFyIGRpc3BhdGNoUXVldWUgPSBbXTtcblxuICAgIC8vIHJldHVybnMgYSBkdXBsaWNhdGUgb2YgdGhlIGN1cnJlbnQgc3RhdGVcbiAgICB2YXIgZ2V0U3RhdGUgPSBmdW5jdGlvbiBnZXRTdGF0ZSgpIHtcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSk7XG4gICAgfTtcblxuICAgIC8vIHJldHVybnMgYSBkdXBsaWNhdGUgb2YgdGhlIGFjdGlvbnMgYXJyYXkgYW5kIGNsZWFycyB0aGUgYWN0aW9ucyBhcnJheVxuICAgIHZhciBwcm9jZXNzQWN0aW9uUXVldWUgPSBmdW5jdGlvbiBwcm9jZXNzQWN0aW9uUXVldWUoKSB7XG4gICAgICAvLyBjcmVhdGUgY29weSBvZiBhY3Rpb25zIHF1ZXVlXG4gICAgICB2YXIgcXVldWUgPSBbXS5jb25jYXQoYWN0aW9uUXVldWUpO1xuXG4gICAgICAvLyBjbGVhciBhY3Rpb25zIHF1ZXVlICh3ZSBkb24ndCB3YW50IG5vIGRvdWJsZSBhY3Rpb25zKVxuICAgICAgYWN0aW9uUXVldWUubGVuZ3RoID0gMDtcblxuICAgICAgcmV0dXJuIHF1ZXVlO1xuICAgIH07XG5cbiAgICAvLyBwcm9jZXNzZXMgYWN0aW9ucyB0aGF0IG1pZ2h0IGJsb2NrIHRoZSBtYWluIFVJIHRocmVhZFxuICAgIHZhciBwcm9jZXNzRGlzcGF0Y2hRdWV1ZSA9IGZ1bmN0aW9uIHByb2Nlc3NEaXNwYXRjaFF1ZXVlKCkge1xuICAgICAgLy8gY3JlYXRlIGNvcHkgb2YgYWN0aW9ucyBxdWV1ZVxuICAgICAgdmFyIHF1ZXVlID0gW10uY29uY2F0KGRpc3BhdGNoUXVldWUpO1xuXG4gICAgICAvLyBjbGVhciBhY3Rpb25zIHF1ZXVlICh3ZSBkb24ndCB3YW50IG5vIGRvdWJsZSBhY3Rpb25zKVxuICAgICAgZGlzcGF0Y2hRdWV1ZS5sZW5ndGggPSAwO1xuXG4gICAgICAvLyBub3cgZGlzcGF0Y2ggdGhlc2UgYWN0aW9uc1xuICAgICAgcXVldWUuZm9yRWFjaChmdW5jdGlvbihfcmVmKSB7XG4gICAgICAgIHZhciB0eXBlID0gX3JlZi50eXBlLFxuICAgICAgICAgIGRhdGEgPSBfcmVmLmRhdGE7XG4gICAgICAgIGRpc3BhdGNoKHR5cGUsIGRhdGEpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIGFkZHMgYSBuZXcgYWN0aW9uLCBjYWxscyBpdHMgaGFuZGxlciBhbmRcbiAgICB2YXIgZGlzcGF0Y2ggPSBmdW5jdGlvbiBkaXNwYXRjaCh0eXBlLCBkYXRhLCBpc0Jsb2NraW5nKSB7XG4gICAgICAvLyBpcyBibG9ja2luZyBhY3Rpb24gKHNob3VsZCBuZXZlciBibG9jayBpZiBkb2N1bWVudCBpcyBoaWRkZW4pXG4gICAgICBpZiAoaXNCbG9ja2luZyAmJiAhZG9jdW1lbnQuaGlkZGVuKSB7XG4gICAgICAgIGRpc3BhdGNoUXVldWUucHVzaCh7IHR5cGU6IHR5cGUsIGRhdGE6IGRhdGEgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gaWYgdGhpcyBhY3Rpb24gaGFzIGEgaGFuZGxlciwgaGFuZGxlIHRoZSBhY3Rpb25cbiAgICAgIGlmIChhY3Rpb25IYW5kbGVyc1t0eXBlXSkge1xuICAgICAgICBhY3Rpb25IYW5kbGVyc1t0eXBlXShkYXRhKTtcbiAgICAgIH1cblxuICAgICAgLy8gbm93IGFkZCBhY3Rpb25cbiAgICAgIGFjdGlvblF1ZXVlLnB1c2goe1xuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICBkYXRhOiBkYXRhXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyIHF1ZXJ5ID0gZnVuY3Rpb24gcXVlcnkoc3RyKSB7XG4gICAgICB2YXIgX3F1ZXJ5SGFuZGxlcztcbiAgICAgIGZvciAoXG4gICAgICAgIHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCxcbiAgICAgICAgICBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSxcbiAgICAgICAgICBfa2V5ID0gMTtcbiAgICAgICAgX2tleSA8IF9sZW47XG4gICAgICAgIF9rZXkrK1xuICAgICAgKSB7XG4gICAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHF1ZXJ5SGFuZGxlc1tzdHJdXG4gICAgICAgID8gKF9xdWVyeUhhbmRsZXMgPSBxdWVyeUhhbmRsZXMpW3N0cl0uYXBwbHkoX3F1ZXJ5SGFuZGxlcywgYXJncylcbiAgICAgICAgOiBudWxsO1xuICAgIH07XG5cbiAgICB2YXIgYXBpID0ge1xuICAgICAgZ2V0U3RhdGU6IGdldFN0YXRlLFxuICAgICAgcHJvY2Vzc0FjdGlvblF1ZXVlOiBwcm9jZXNzQWN0aW9uUXVldWUsXG4gICAgICBwcm9jZXNzRGlzcGF0Y2hRdWV1ZTogcHJvY2Vzc0Rpc3BhdGNoUXVldWUsXG4gICAgICBkaXNwYXRjaDogZGlzcGF0Y2gsXG4gICAgICBxdWVyeTogcXVlcnlcbiAgICB9O1xuXG4gICAgdmFyIHF1ZXJ5SGFuZGxlcyA9IHt9O1xuICAgIHF1ZXJpZXMuZm9yRWFjaChmdW5jdGlvbihxdWVyeSkge1xuICAgICAgcXVlcnlIYW5kbGVzID0gT2JqZWN0LmFzc2lnbih7fSwgcXVlcnkoc3RhdGUpLCB7fSwgcXVlcnlIYW5kbGVzKTtcbiAgICB9KTtcblxuICAgIHZhciBhY3Rpb25IYW5kbGVycyA9IHt9O1xuICAgIGFjdGlvbnMuZm9yRWFjaChmdW5jdGlvbihhY3Rpb24pIHtcbiAgICAgIGFjdGlvbkhhbmRsZXJzID0gT2JqZWN0LmFzc2lnbihcbiAgICAgICAge30sXG4gICAgICAgIGFjdGlvbihkaXNwYXRjaCwgcXVlcnksIHN0YXRlKSxcbiAgICAgICAge30sXG4gICAgICAgIGFjdGlvbkhhbmRsZXJzXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGFwaTtcbiAgfTtcblxuICB2YXIgZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShvYmosIHByb3BlcnR5LCBkZWZpbml0aW9uKSB7XG4gICAgaWYgKHR5cGVvZiBkZWZpbml0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBvYmpbcHJvcGVydHldID0gZGVmaW5pdGlvbjtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgcHJvcGVydHksIE9iamVjdC5hc3NpZ24oe30sIGRlZmluaXRpb24pKTtcbiAgfTtcblxuICB2YXIgZm9yaW4gPSBmdW5jdGlvbiBmb3JpbihvYmosIGNiKSB7XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgaWYgKCFvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgY2Ioa2V5LCBvYmpba2V5XSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBjcmVhdGVPYmplY3QgPSBmdW5jdGlvbiBjcmVhdGVPYmplY3QoZGVmaW5pdGlvbikge1xuICAgIHZhciBvYmogPSB7fTtcbiAgICBmb3JpbihkZWZpbml0aW9uLCBmdW5jdGlvbihwcm9wZXJ0eSkge1xuICAgICAgZGVmaW5lUHJvcGVydHkob2JqLCBwcm9wZXJ0eSwgZGVmaW5pdGlvbltwcm9wZXJ0eV0pO1xuICAgIH0pO1xuICAgIHJldHVybiBvYmo7XG4gIH07XG5cbiAgdmFyIGF0dHIgPSBmdW5jdGlvbiBhdHRyKG5vZGUsIG5hbWUpIHtcbiAgICB2YXIgdmFsdWUgPVxuICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBudWxsO1xuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG5vZGUuZ2V0QXR0cmlidXRlKG5hbWUpIHx8IG5vZGUuaGFzQXR0cmlidXRlKG5hbWUpO1xuICAgIH1cbiAgICBub2RlLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG4gIH07XG5cbiAgdmFyIG5zID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcbiAgdmFyIHN2Z0VsZW1lbnRzID0gWydzdmcnLCAncGF0aCddOyAvLyBvbmx5IHN2ZyBlbGVtZW50cyB1c2VkXG5cbiAgdmFyIGlzU1ZHRWxlbWVudCA9IGZ1bmN0aW9uIGlzU1ZHRWxlbWVudCh0YWcpIHtcbiAgICByZXR1cm4gc3ZnRWxlbWVudHMuaW5jbHVkZXModGFnKTtcbiAgfTtcblxuICB2YXIgY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQodGFnLCBjbGFzc05hbWUpIHtcbiAgICB2YXIgYXR0cmlidXRlcyA9XG4gICAgICBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIGlmICh0eXBlb2YgY2xhc3NOYW1lID09PSAnb2JqZWN0Jykge1xuICAgICAgYXR0cmlidXRlcyA9IGNsYXNzTmFtZTtcbiAgICAgIGNsYXNzTmFtZSA9IG51bGw7XG4gICAgfVxuICAgIHZhciBlbGVtZW50ID0gaXNTVkdFbGVtZW50KHRhZylcbiAgICAgID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5zLCB0YWcpXG4gICAgICA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICBpZiAoY2xhc3NOYW1lKSB7XG4gICAgICBpZiAoaXNTVkdFbGVtZW50KHRhZykpIHtcbiAgICAgICAgYXR0cihlbGVtZW50LCAnY2xhc3MnLCBjbGFzc05hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbWVudC5jbGFzc05hbWUgPSBjbGFzc05hbWU7XG4gICAgICB9XG4gICAgfVxuICAgIGZvcmluKGF0dHJpYnV0ZXMsIGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgICBhdHRyKGVsZW1lbnQsIG5hbWUsIHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfTtcblxuICB2YXIgYXBwZW5kQ2hpbGQgPSBmdW5jdGlvbiBhcHBlbmRDaGlsZChwYXJlbnQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oY2hpbGQsIGluZGV4KSB7XG4gICAgICBpZiAodHlwZW9mIGluZGV4ICE9PSAndW5kZWZpbmVkJyAmJiBwYXJlbnQuY2hpbGRyZW5baW5kZXhdKSB7XG4gICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoY2hpbGQsIHBhcmVudC5jaGlsZHJlbltpbmRleF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyZW50LmFwcGVuZENoaWxkKGNoaWxkKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIHZhciBhcHBlbmRDaGlsZFZpZXcgPSBmdW5jdGlvbiBhcHBlbmRDaGlsZFZpZXcocGFyZW50LCBjaGlsZFZpZXdzKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHZpZXcsIGluZGV4KSB7XG4gICAgICBpZiAodHlwZW9mIGluZGV4ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjaGlsZFZpZXdzLnNwbGljZShpbmRleCwgMCwgdmlldyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaGlsZFZpZXdzLnB1c2godmlldyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB2aWV3O1xuICAgIH07XG4gIH07XG5cbiAgdmFyIHJlbW92ZUNoaWxkVmlldyA9IGZ1bmN0aW9uIHJlbW92ZUNoaWxkVmlldyhwYXJlbnQsIGNoaWxkVmlld3MpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odmlldykge1xuICAgICAgLy8gcmVtb3ZlIGZyb20gY2hpbGQgdmlld3NcbiAgICAgIGNoaWxkVmlld3Muc3BsaWNlKGNoaWxkVmlld3MuaW5kZXhPZih2aWV3KSwgMSk7XG5cbiAgICAgIC8vIHJlbW92ZSB0aGUgZWxlbWVudFxuICAgICAgaWYgKHZpZXcuZWxlbWVudC5wYXJlbnROb2RlKSB7XG4gICAgICAgIHBhcmVudC5yZW1vdmVDaGlsZCh2aWV3LmVsZW1lbnQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmlldztcbiAgICB9O1xuICB9O1xuXG4gIHZhciBJU19CUk9XU0VSID0gKGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAoXG4gICAgICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50ICE9PSAndW5kZWZpbmVkJ1xuICAgICk7XG4gIH0pKCk7XG4gIHZhciBpc0Jyb3dzZXIgPSBmdW5jdGlvbiBpc0Jyb3dzZXIoKSB7XG4gICAgcmV0dXJuIElTX0JST1dTRVI7XG4gIH07XG5cbiAgdmFyIHRlc3RFbGVtZW50ID0gaXNCcm93c2VyKCkgPyBjcmVhdGVFbGVtZW50KCdzdmcnKSA6IHt9O1xuICB2YXIgZ2V0Q2hpbGRDb3VudCA9XG4gICAgJ2NoaWxkcmVuJyBpbiB0ZXN0RWxlbWVudFxuICAgICAgPyBmdW5jdGlvbihlbCkge1xuICAgICAgICAgIHJldHVybiBlbC5jaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIDogZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgICByZXR1cm4gZWwuY2hpbGROb2Rlcy5sZW5ndGg7XG4gICAgICAgIH07XG5cbiAgdmFyIGdldFZpZXdSZWN0ID0gZnVuY3Rpb24gZ2V0Vmlld1JlY3QoXG4gICAgZWxlbWVudFJlY3QsXG4gICAgY2hpbGRWaWV3cyxcbiAgICBvZmZzZXQsXG4gICAgc2NhbGVcbiAgKSB7XG4gICAgdmFyIGxlZnQgPSBvZmZzZXRbMF0gfHwgZWxlbWVudFJlY3QubGVmdDtcbiAgICB2YXIgdG9wID0gb2Zmc2V0WzFdIHx8IGVsZW1lbnRSZWN0LnRvcDtcbiAgICB2YXIgcmlnaHQgPSBsZWZ0ICsgZWxlbWVudFJlY3Qud2lkdGg7XG4gICAgdmFyIGJvdHRvbSA9IHRvcCArIGVsZW1lbnRSZWN0LmhlaWdodCAqIChzY2FsZVsxXSB8fCAxKTtcblxuICAgIHZhciByZWN0ID0ge1xuICAgICAgLy8gdGhlIHJlY3RhbmdsZSBvZiB0aGUgZWxlbWVudCBpdHNlbGZcbiAgICAgIGVsZW1lbnQ6IE9iamVjdC5hc3NpZ24oe30sIGVsZW1lbnRSZWN0KSxcblxuICAgICAgLy8gdGhlIHJlY3RhbmdsZSBvZiB0aGUgZWxlbWVudCBleHBhbmRlZCB0byBjb250YWluIGl0cyBjaGlsZHJlbiwgZG9lcyBub3QgaW5jbHVkZSBhbnkgbWFyZ2luc1xuICAgICAgaW5uZXI6IHtcbiAgICAgICAgbGVmdDogZWxlbWVudFJlY3QubGVmdCxcbiAgICAgICAgdG9wOiBlbGVtZW50UmVjdC50b3AsXG4gICAgICAgIHJpZ2h0OiBlbGVtZW50UmVjdC5yaWdodCxcbiAgICAgICAgYm90dG9tOiBlbGVtZW50UmVjdC5ib3R0b21cbiAgICAgIH0sXG5cbiAgICAgIC8vIHRoZSByZWN0YW5nbGUgb2YgdGhlIGVsZW1lbnQgZXhwYW5kZWQgdG8gY29udGFpbiBpdHMgY2hpbGRyZW4gaW5jbHVkaW5nIG93biBtYXJnaW4gYW5kIGNoaWxkIG1hcmdpbnNcbiAgICAgIC8vIG1hcmdpbnMgd2lsbCBiZSBhZGRlZCBhZnRlciB3ZSd2ZSByZWNhbGN1bGF0ZWQgdGhlIHNpemVcbiAgICAgIG91dGVyOiB7XG4gICAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICAgIHRvcDogdG9wLFxuICAgICAgICByaWdodDogcmlnaHQsXG4gICAgICAgIGJvdHRvbTogYm90dG9tXG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIGV4cGFuZCByZWN0IHRvIGZpdCBhbGwgY2hpbGQgcmVjdGFuZ2xlc1xuICAgIGNoaWxkVmlld3NcbiAgICAgIC5maWx0ZXIoZnVuY3Rpb24oY2hpbGRWaWV3KSB7XG4gICAgICAgIHJldHVybiAhY2hpbGRWaWV3LmlzUmVjdElnbm9yZWQoKTtcbiAgICAgIH0pXG4gICAgICAubWFwKGZ1bmN0aW9uKGNoaWxkVmlldykge1xuICAgICAgICByZXR1cm4gY2hpbGRWaWV3LnJlY3Q7XG4gICAgICB9KVxuICAgICAgLmZvckVhY2goZnVuY3Rpb24oY2hpbGRWaWV3UmVjdCkge1xuICAgICAgICBleHBhbmRSZWN0KHJlY3QuaW5uZXIsIE9iamVjdC5hc3NpZ24oe30sIGNoaWxkVmlld1JlY3QuaW5uZXIpKTtcbiAgICAgICAgZXhwYW5kUmVjdChyZWN0Lm91dGVyLCBPYmplY3QuYXNzaWduKHt9LCBjaGlsZFZpZXdSZWN0Lm91dGVyKSk7XG4gICAgICB9KTtcblxuICAgIC8vIGNhbGN1bGF0ZSBpbm5lciB3aWR0aCBhbmQgaGVpZ2h0XG4gICAgY2FsY3VsYXRlUmVjdFNpemUocmVjdC5pbm5lcik7XG5cbiAgICAvLyBhcHBlbmQgYWRkaXRpb25hbCBtYXJnaW4gKHRvcCBhbmQgbGVmdCBtYXJnaW5zIGFyZSBpbmNsdWRlZCBpbiB0b3AgYW5kIGxlZnQgYXV0b21hdGljYWxseSlcbiAgICByZWN0Lm91dGVyLmJvdHRvbSArPSByZWN0LmVsZW1lbnQubWFyZ2luQm90dG9tO1xuICAgIHJlY3Qub3V0ZXIucmlnaHQgKz0gcmVjdC5lbGVtZW50Lm1hcmdpblJpZ2h0O1xuXG4gICAgLy8gY2FsY3VsYXRlIG91dGVyIHdpZHRoIGFuZCBoZWlnaHRcbiAgICBjYWxjdWxhdGVSZWN0U2l6ZShyZWN0Lm91dGVyKTtcblxuICAgIHJldHVybiByZWN0O1xuICB9O1xuXG4gIHZhciBleHBhbmRSZWN0ID0gZnVuY3Rpb24gZXhwYW5kUmVjdChwYXJlbnQsIGNoaWxkKSB7XG4gICAgLy8gYWRqdXN0IGZvciBwYXJlbnQgb2Zmc2V0XG4gICAgY2hpbGQudG9wICs9IHBhcmVudC50b3A7XG4gICAgY2hpbGQucmlnaHQgKz0gcGFyZW50LmxlZnQ7XG4gICAgY2hpbGQuYm90dG9tICs9IHBhcmVudC50b3A7XG4gICAgY2hpbGQubGVmdCArPSBwYXJlbnQubGVmdDtcblxuICAgIGlmIChjaGlsZC5ib3R0b20gPiBwYXJlbnQuYm90dG9tKSB7XG4gICAgICBwYXJlbnQuYm90dG9tID0gY2hpbGQuYm90dG9tO1xuICAgIH1cblxuICAgIGlmIChjaGlsZC5yaWdodCA+IHBhcmVudC5yaWdodCkge1xuICAgICAgcGFyZW50LnJpZ2h0ID0gY2hpbGQucmlnaHQ7XG4gICAgfVxuICB9O1xuXG4gIHZhciBjYWxjdWxhdGVSZWN0U2l6ZSA9IGZ1bmN0aW9uIGNhbGN1bGF0ZVJlY3RTaXplKHJlY3QpIHtcbiAgICByZWN0LndpZHRoID0gcmVjdC5yaWdodCAtIHJlY3QubGVmdDtcbiAgICByZWN0LmhlaWdodCA9IHJlY3QuYm90dG9tIC0gcmVjdC50b3A7XG4gIH07XG5cbiAgdmFyIGlzTnVtYmVyID0gZnVuY3Rpb24gaXNOdW1iZXIodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJztcbiAgfTtcblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyBpZiBwb3NpdGlvbiBpcyBhdCBkZXN0aW5hdGlvblxuICAgKiBAcGFyYW0gcG9zaXRpb25cbiAgICogQHBhcmFtIGRlc3RpbmF0aW9uXG4gICAqIEBwYXJhbSB2ZWxvY2l0eVxuICAgKiBAcGFyYW0gZXJyb3JNYXJnaW5cbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICB2YXIgdGhlcmVZZXQgPSBmdW5jdGlvbiB0aGVyZVlldChwb3NpdGlvbiwgZGVzdGluYXRpb24sIHZlbG9jaXR5KSB7XG4gICAgdmFyIGVycm9yTWFyZ2luID1cbiAgICAgIGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogMC4wMDE7XG4gICAgcmV0dXJuIChcbiAgICAgIE1hdGguYWJzKHBvc2l0aW9uIC0gZGVzdGluYXRpb24pIDwgZXJyb3JNYXJnaW4gJiZcbiAgICAgIE1hdGguYWJzKHZlbG9jaXR5KSA8IGVycm9yTWFyZ2luXG4gICAgKTtcbiAgfTtcblxuICAvKipcbiAgICogU3ByaW5nIGFuaW1hdGlvblxuICAgKi9cbiAgdmFyIHNwcmluZyA9XG4gICAgLy8gZGVmYXVsdCBvcHRpb25zXG4gICAgZnVuY3Rpb24gc3ByaW5nKCkgLy8gbWV0aG9kIGRlZmluaXRpb25cbiAgICB7XG4gICAgICB2YXIgX3JlZiA9XG4gICAgICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gYXJndW1lbnRzWzBdXG4gICAgICAgICAgICA6IHt9LFxuICAgICAgICBfcmVmJHN0aWZmbmVzcyA9IF9yZWYuc3RpZmZuZXNzLFxuICAgICAgICBzdGlmZm5lc3MgPSBfcmVmJHN0aWZmbmVzcyA9PT0gdm9pZCAwID8gMC41IDogX3JlZiRzdGlmZm5lc3MsXG4gICAgICAgIF9yZWYkZGFtcGluZyA9IF9yZWYuZGFtcGluZyxcbiAgICAgICAgZGFtcGluZyA9IF9yZWYkZGFtcGluZyA9PT0gdm9pZCAwID8gMC43NSA6IF9yZWYkZGFtcGluZyxcbiAgICAgICAgX3JlZiRtYXNzID0gX3JlZi5tYXNzLFxuICAgICAgICBtYXNzID0gX3JlZiRtYXNzID09PSB2b2lkIDAgPyAxMCA6IF9yZWYkbWFzcztcbiAgICAgIHZhciB0YXJnZXQgPSBudWxsO1xuICAgICAgdmFyIHBvc2l0aW9uID0gbnVsbDtcbiAgICAgIHZhciB2ZWxvY2l0eSA9IDA7XG4gICAgICB2YXIgcmVzdGluZyA9IGZhbHNlO1xuXG4gICAgICAvLyB1cGRhdGVzIHNwcmluZyBzdGF0ZVxuICAgICAgdmFyIGludGVycG9sYXRlID0gZnVuY3Rpb24gaW50ZXJwb2xhdGUodHMsIHNraXBUb0VuZFN0YXRlKSB7XG4gICAgICAgIC8vIGluIHJlc3QsIGRvbid0IGFuaW1hdGVcbiAgICAgICAgaWYgKHJlc3RpbmcpIHJldHVybjtcblxuICAgICAgICAvLyBuZWVkIGF0IGxlYXN0IGEgdGFyZ2V0IG9yIHBvc2l0aW9uIHRvIGRvIHNwcmluZ3kgdGhpbmdzXG4gICAgICAgIGlmICghKGlzTnVtYmVyKHRhcmdldCkgJiYgaXNOdW1iZXIocG9zaXRpb24pKSkge1xuICAgICAgICAgIHJlc3RpbmcgPSB0cnVlO1xuICAgICAgICAgIHZlbG9jaXR5ID0gMDtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjYWxjdWxhdGUgc3ByaW5nIGZvcmNlXG4gICAgICAgIHZhciBmID0gLShwb3NpdGlvbiAtIHRhcmdldCkgKiBzdGlmZm5lc3M7XG5cbiAgICAgICAgLy8gdXBkYXRlIHZlbG9jaXR5IGJ5IGFkZGluZyBmb3JjZSBiYXNlZCBvbiBtYXNzXG4gICAgICAgIHZlbG9jaXR5ICs9IGYgLyBtYXNzO1xuXG4gICAgICAgIC8vIHVwZGF0ZSBwb3NpdGlvbiBieSBhZGRpbmcgdmVsb2NpdHlcbiAgICAgICAgcG9zaXRpb24gKz0gdmVsb2NpdHk7XG5cbiAgICAgICAgLy8gc2xvdyBkb3duIGJhc2VkIG9uIGFtb3VudCBvZiBkYW1waW5nXG4gICAgICAgIHZlbG9jaXR5ICo9IGRhbXBpbmc7XG5cbiAgICAgICAgLy8gd2UndmUgYXJyaXZlZCBpZiB3ZSdyZSBuZWFyIHRhcmdldCBhbmQgb3VyIHZlbG9jaXR5IGlzIG5lYXIgemVyb1xuICAgICAgICBpZiAodGhlcmVZZXQocG9zaXRpb24sIHRhcmdldCwgdmVsb2NpdHkpIHx8IHNraXBUb0VuZFN0YXRlKSB7XG4gICAgICAgICAgcG9zaXRpb24gPSB0YXJnZXQ7XG4gICAgICAgICAgdmVsb2NpdHkgPSAwO1xuICAgICAgICAgIHJlc3RpbmcgPSB0cnVlO1xuXG4gICAgICAgICAgLy8gd2UgZG9uZVxuICAgICAgICAgIGFwaS5vbnVwZGF0ZShwb3NpdGlvbik7XG4gICAgICAgICAgYXBpLm9uY29tcGxldGUocG9zaXRpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHByb2dyZXNzIHVwZGF0ZVxuICAgICAgICAgIGFwaS5vbnVwZGF0ZShwb3NpdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogU2V0IG5ldyB0YXJnZXQgdmFsdWVcbiAgICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAgICovXG4gICAgICB2YXIgc2V0VGFyZ2V0ID0gZnVuY3Rpb24gc2V0VGFyZ2V0KHZhbHVlKSB7XG4gICAgICAgIC8vIGlmIGN1cnJlbnRseSBoYXMgbm8gcG9zaXRpb24sIHNldCB0YXJnZXQgYW5kIHBvc2l0aW9uIHRvIHRoaXMgdmFsdWVcbiAgICAgICAgaWYgKGlzTnVtYmVyKHZhbHVlKSAmJiAhaXNOdW1iZXIocG9zaXRpb24pKSB7XG4gICAgICAgICAgcG9zaXRpb24gPSB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG5leHQgdGFyZ2V0IHZhbHVlIHdpbGwgbm90IGJlIGFuaW1hdGVkIHRvXG4gICAgICAgIGlmICh0YXJnZXQgPT09IG51bGwpIHtcbiAgICAgICAgICB0YXJnZXQgPSB2YWx1ZTtcbiAgICAgICAgICBwb3NpdGlvbiA9IHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbGV0IHN0YXJ0IG1vdmluZyB0byB0YXJnZXRcbiAgICAgICAgdGFyZ2V0ID0gdmFsdWU7XG5cbiAgICAgICAgLy8gYWxyZWFkeSBhdCB0YXJnZXRcbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSB0YXJnZXQgfHwgdHlwZW9mIHRhcmdldCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAvLyBub3cgcmVzdGluZyBhcyB0YXJnZXQgaXMgY3VycmVudCBwb3NpdGlvbiwgc3RvcCBtb3ZpbmdcbiAgICAgICAgICByZXN0aW5nID0gdHJ1ZTtcbiAgICAgICAgICB2ZWxvY2l0eSA9IDA7XG5cbiAgICAgICAgICAvLyBkb25lIVxuICAgICAgICAgIGFwaS5vbnVwZGF0ZShwb3NpdGlvbik7XG4gICAgICAgICAgYXBpLm9uY29tcGxldGUocG9zaXRpb24pO1xuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdGluZyA9IGZhbHNlO1xuICAgICAgfTtcblxuICAgICAgLy8gbmVlZCAnYXBpJyB0byBjYWxsIG9udXBkYXRlIGNhbGxiYWNrXG4gICAgICB2YXIgYXBpID0gY3JlYXRlT2JqZWN0KHtcbiAgICAgICAgaW50ZXJwb2xhdGU6IGludGVycG9sYXRlLFxuICAgICAgICB0YXJnZXQ6IHtcbiAgICAgICAgICBzZXQ6IHNldFRhcmdldCxcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHJlc3Rpbmc6IHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN0aW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBvbnVwZGF0ZTogZnVuY3Rpb24gb251cGRhdGUodmFsdWUpIHt9LFxuICAgICAgICBvbmNvbXBsZXRlOiBmdW5jdGlvbiBvbmNvbXBsZXRlKHZhbHVlKSB7fVxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBhcGk7XG4gICAgfTtcblxuICB2YXIgZWFzZUxpbmVhciA9IGZ1bmN0aW9uIGVhc2VMaW5lYXIodCkge1xuICAgIHJldHVybiB0O1xuICB9O1xuICB2YXIgZWFzZUluT3V0UXVhZCA9IGZ1bmN0aW9uIGVhc2VJbk91dFF1YWQodCkge1xuICAgIHJldHVybiB0IDwgMC41ID8gMiAqIHQgKiB0IDogLTEgKyAoNCAtIDIgKiB0KSAqIHQ7XG4gIH07XG5cbiAgdmFyIHR3ZWVuID1cbiAgICAvLyBkZWZhdWx0IHZhbHVlc1xuICAgIGZ1bmN0aW9uIHR3ZWVuKCkgLy8gbWV0aG9kIGRlZmluaXRpb25cbiAgICB7XG4gICAgICB2YXIgX3JlZiA9XG4gICAgICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gYXJndW1lbnRzWzBdXG4gICAgICAgICAgICA6IHt9LFxuICAgICAgICBfcmVmJGR1cmF0aW9uID0gX3JlZi5kdXJhdGlvbixcbiAgICAgICAgZHVyYXRpb24gPSBfcmVmJGR1cmF0aW9uID09PSB2b2lkIDAgPyA1MDAgOiBfcmVmJGR1cmF0aW9uLFxuICAgICAgICBfcmVmJGVhc2luZyA9IF9yZWYuZWFzaW5nLFxuICAgICAgICBlYXNpbmcgPSBfcmVmJGVhc2luZyA9PT0gdm9pZCAwID8gZWFzZUluT3V0UXVhZCA6IF9yZWYkZWFzaW5nLFxuICAgICAgICBfcmVmJGRlbGF5ID0gX3JlZi5kZWxheSxcbiAgICAgICAgZGVsYXkgPSBfcmVmJGRlbGF5ID09PSB2b2lkIDAgPyAwIDogX3JlZiRkZWxheTtcbiAgICAgIHZhciBzdGFydCA9IG51bGw7XG4gICAgICB2YXIgdDtcbiAgICAgIHZhciBwO1xuICAgICAgdmFyIHJlc3RpbmcgPSB0cnVlO1xuICAgICAgdmFyIHJldmVyc2UgPSBmYWxzZTtcbiAgICAgIHZhciB0YXJnZXQgPSBudWxsO1xuXG4gICAgICB2YXIgaW50ZXJwb2xhdGUgPSBmdW5jdGlvbiBpbnRlcnBvbGF0ZSh0cywgc2tpcFRvRW5kU3RhdGUpIHtcbiAgICAgICAgaWYgKHJlc3RpbmcgfHwgdGFyZ2V0ID09PSBudWxsKSByZXR1cm47XG5cbiAgICAgICAgaWYgKHN0YXJ0ID09PSBudWxsKSB7XG4gICAgICAgICAgc3RhcnQgPSB0cztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0cyAtIHN0YXJ0IDwgZGVsYXkpIHJldHVybjtcblxuICAgICAgICB0ID0gdHMgLSBzdGFydCAtIGRlbGF5O1xuXG4gICAgICAgIGlmICh0ID49IGR1cmF0aW9uIHx8IHNraXBUb0VuZFN0YXRlKSB7XG4gICAgICAgICAgdCA9IDE7XG4gICAgICAgICAgcCA9IHJldmVyc2UgPyAwIDogMTtcbiAgICAgICAgICBhcGkub251cGRhdGUocCAqIHRhcmdldCk7XG4gICAgICAgICAgYXBpLm9uY29tcGxldGUocCAqIHRhcmdldCk7XG4gICAgICAgICAgcmVzdGluZyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcCA9IHQgLyBkdXJhdGlvbjtcbiAgICAgICAgICBhcGkub251cGRhdGUoKHQgPj0gMCA/IGVhc2luZyhyZXZlcnNlID8gMSAtIHAgOiBwKSA6IDApICogdGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLy8gbmVlZCAnYXBpJyB0byBjYWxsIG9udXBkYXRlIGNhbGxiYWNrXG4gICAgICB2YXIgYXBpID0gY3JlYXRlT2JqZWN0KHtcbiAgICAgICAgaW50ZXJwb2xhdGU6IGludGVycG9sYXRlLFxuICAgICAgICB0YXJnZXQ6IHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiByZXZlcnNlID8gMCA6IHRhcmdldDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgICAgICAvLyBpcyBpbml0aWFsIHZhbHVlXG4gICAgICAgICAgICBpZiAodGFyZ2V0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIHRhcmdldCA9IHZhbHVlO1xuICAgICAgICAgICAgICBhcGkub251cGRhdGUodmFsdWUpO1xuICAgICAgICAgICAgICBhcGkub25jb21wbGV0ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gd2FudCB0byB0d2VlbiB0byBhIHNtYWxsZXIgdmFsdWUgYW5kIGhhdmUgYSBjdXJyZW50IHZhbHVlXG4gICAgICAgICAgICBpZiAodmFsdWUgPCB0YXJnZXQpIHtcbiAgICAgICAgICAgICAgdGFyZ2V0ID0gMTtcbiAgICAgICAgICAgICAgcmV2ZXJzZSA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBub3QgdHdlZW5pbmcgdG8gYSBzbWFsbGVyIHZhbHVlXG4gICAgICAgICAgICAgIHJldmVyc2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgdGFyZ2V0ID0gdmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGxldCdzIGdvIVxuICAgICAgICAgICAgcmVzdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgc3RhcnQgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICByZXN0aW5nOiB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdGluZztcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgb251cGRhdGU6IGZ1bmN0aW9uIG9udXBkYXRlKHZhbHVlKSB7fSxcbiAgICAgICAgb25jb21wbGV0ZTogZnVuY3Rpb24gb25jb21wbGV0ZSh2YWx1ZSkge31cbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gYXBpO1xuICAgIH07XG5cbiAgdmFyIGFuaW1hdG9yID0ge1xuICAgIHNwcmluZzogc3ByaW5nLFxuICAgIHR3ZWVuOiB0d2VlblxuICB9O1xuXG4gIC8qXG4gICAgICAgICAgICAgICAgICAgICAgIHsgdHlwZTogJ3NwcmluZycsIHN0aWZmbmVzczogLjUsIGRhbXBpbmc6IC43NSwgbWFzczogMTAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgeyB0cmFuc2xhdGlvbjogeyB0eXBlOiAnc3ByaW5nJywgLi4uIH0sIC4uLiB9XG4gICAgICAgICAgICAgICAgICAgICAgIHsgdHJhbnNsYXRpb246IHsgeDogeyB0eXBlOiAnc3ByaW5nJywgLi4uIH0gfSB9XG4gICAgICAgICAgICAgICAgICAgICAgKi9cbiAgdmFyIGNyZWF0ZUFuaW1hdG9yID0gZnVuY3Rpb24gY3JlYXRlQW5pbWF0b3IoZGVmaW5pdGlvbiwgY2F0ZWdvcnksIHByb3BlcnR5KSB7XG4gICAgLy8gZGVmYXVsdCBpcyBzaW5nbGUgZGVmaW5pdGlvblxuICAgIC8vIHdlIGNoZWNrIGlmIHRyYW5zZm9ybSBpcyBzZXQsIGlmIHNvLCB3ZSBjaGVjayBpZiBwcm9wZXJ0eSBpcyBzZXRcbiAgICB2YXIgZGVmID1cbiAgICAgIGRlZmluaXRpb25bY2F0ZWdvcnldICYmIHR5cGVvZiBkZWZpbml0aW9uW2NhdGVnb3J5XVtwcm9wZXJ0eV0gPT09ICdvYmplY3QnXG4gICAgICAgID8gZGVmaW5pdGlvbltjYXRlZ29yeV1bcHJvcGVydHldXG4gICAgICAgIDogZGVmaW5pdGlvbltjYXRlZ29yeV0gfHwgZGVmaW5pdGlvbjtcblxuICAgIHZhciB0eXBlID0gdHlwZW9mIGRlZiA9PT0gJ3N0cmluZycgPyBkZWYgOiBkZWYudHlwZTtcbiAgICB2YXIgcHJvcHMgPSB0eXBlb2YgZGVmID09PSAnb2JqZWN0JyA/IE9iamVjdC5hc3NpZ24oe30sIGRlZikgOiB7fTtcblxuICAgIHJldHVybiBhbmltYXRvclt0eXBlXSA/IGFuaW1hdG9yW3R5cGVdKHByb3BzKSA6IG51bGw7XG4gIH07XG5cbiAgdmFyIGFkZEdldFNldCA9IGZ1bmN0aW9uIGFkZEdldFNldChrZXlzLCBvYmosIHByb3BzKSB7XG4gICAgdmFyIG92ZXJ3cml0ZSA9XG4gICAgICBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IGZhbHNlO1xuICAgIG9iaiA9IEFycmF5LmlzQXJyYXkob2JqKSA/IG9iaiA6IFtvYmpdO1xuICAgIG9iai5mb3JFYWNoKGZ1bmN0aW9uKG8pIHtcbiAgICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgdmFyIG5hbWUgPSBrZXk7XG4gICAgICAgIHZhciBnZXR0ZXIgPSBmdW5jdGlvbiBnZXR0ZXIoKSB7XG4gICAgICAgICAgcmV0dXJuIHByb3BzW2tleV07XG4gICAgICAgIH07XG4gICAgICAgIHZhciBzZXR0ZXIgPSBmdW5jdGlvbiBzZXR0ZXIodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gKHByb3BzW2tleV0gPSB2YWx1ZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgbmFtZSA9IGtleS5rZXk7XG4gICAgICAgICAgZ2V0dGVyID0ga2V5LmdldHRlciB8fCBnZXR0ZXI7XG4gICAgICAgICAgc2V0dGVyID0ga2V5LnNldHRlciB8fCBzZXR0ZXI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob1tuYW1lXSAmJiAhb3ZlcndyaXRlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgb1tuYW1lXSA9IHtcbiAgICAgICAgICBnZXQ6IGdldHRlcixcbiAgICAgICAgICBzZXQ6IHNldHRlclxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gYWRkIHRvIHN0YXRlLFxuICAvLyBhZGQgZ2V0dGVycyBhbmQgc2V0dGVycyB0byBpbnRlcm5hbCBhbmQgZXh0ZXJuYWwgYXBpIChpZiBub3Qgc2V0KVxuICAvLyBzZXR1cCBhbmltYXRvcnNcblxuICB2YXIgYW5pbWF0aW9ucyA9IGZ1bmN0aW9uIGFuaW1hdGlvbnMoX3JlZikge1xuICAgIHZhciBtaXhpbkNvbmZpZyA9IF9yZWYubWl4aW5Db25maWcsXG4gICAgICB2aWV3UHJvcHMgPSBfcmVmLnZpZXdQcm9wcyxcbiAgICAgIHZpZXdJbnRlcm5hbEFQSSA9IF9yZWYudmlld0ludGVybmFsQVBJLFxuICAgICAgdmlld0V4dGVybmFsQVBJID0gX3JlZi52aWV3RXh0ZXJuYWxBUEk7XG4gICAgLy8gaW5pdGlhbCBwcm9wZXJ0aWVzXG4gICAgdmFyIGluaXRpYWxQcm9wcyA9IE9iamVjdC5hc3NpZ24oe30sIHZpZXdQcm9wcyk7XG5cbiAgICAvLyBsaXN0IG9mIGFsbCBhY3RpdmUgYW5pbWF0aW9uc1xuICAgIHZhciBhbmltYXRpb25zID0gW107XG5cbiAgICAvLyBzZXR1cCBhbmltYXRvcnNcbiAgICBmb3JpbihtaXhpbkNvbmZpZywgZnVuY3Rpb24ocHJvcGVydHksIGFuaW1hdGlvbikge1xuICAgICAgdmFyIGFuaW1hdG9yID0gY3JlYXRlQW5pbWF0b3IoYW5pbWF0aW9uKTtcbiAgICAgIGlmICghYW5pbWF0b3IpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyB3aGVuIHRoZSBhbmltYXRvciB1cGRhdGVzLCB1cGRhdGUgdGhlIHZpZXcgc3RhdGUgdmFsdWVcbiAgICAgIGFuaW1hdG9yLm9udXBkYXRlID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdmlld1Byb3BzW3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgICAgfTtcblxuICAgICAgLy8gc2V0IGFuaW1hdG9yIHRhcmdldFxuICAgICAgYW5pbWF0b3IudGFyZ2V0ID0gaW5pdGlhbFByb3BzW3Byb3BlcnR5XTtcblxuICAgICAgLy8gd2hlbiB2YWx1ZSBpcyBzZXQsIHNldCB0aGUgYW5pbWF0b3IgdGFyZ2V0IHZhbHVlXG4gICAgICB2YXIgcHJvcCA9IHtcbiAgICAgICAga2V5OiBwcm9wZXJ0eSxcbiAgICAgICAgc2V0dGVyOiBmdW5jdGlvbiBzZXR0ZXIodmFsdWUpIHtcbiAgICAgICAgICAvLyBpZiBhbHJlYWR5IGF0IHRhcmdldCwgd2UgZG9uZSFcbiAgICAgICAgICBpZiAoYW5pbWF0b3IudGFyZ2V0ID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGFuaW1hdG9yLnRhcmdldCA9IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBnZXR0ZXI6IGZ1bmN0aW9uIGdldHRlcigpIHtcbiAgICAgICAgICByZXR1cm4gdmlld1Byb3BzW3Byb3BlcnR5XTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLy8gYWRkIGdldHRlcnMgYW5kIHNldHRlcnNcbiAgICAgIGFkZEdldFNldChbcHJvcF0sIFt2aWV3SW50ZXJuYWxBUEksIHZpZXdFeHRlcm5hbEFQSV0sIHZpZXdQcm9wcywgdHJ1ZSk7XG5cbiAgICAgIC8vIGFkZCBpdCB0byB0aGUgbGlzdCBmb3IgZWFzeSB1cGRhdGluZyBmcm9tIHRoZSBfd3JpdGUgbWV0aG9kXG4gICAgICBhbmltYXRpb25zLnB1c2goYW5pbWF0b3IpO1xuICAgIH0pO1xuXG4gICAgLy8gZXhwb3NlIGludGVybmFsIHdyaXRlIGFwaVxuICAgIHJldHVybiB7XG4gICAgICB3cml0ZTogZnVuY3Rpb24gd3JpdGUodHMpIHtcbiAgICAgICAgdmFyIHNraXBUb0VuZFN0YXRlID0gZG9jdW1lbnQuaGlkZGVuO1xuICAgICAgICB2YXIgcmVzdGluZyA9IHRydWU7XG4gICAgICAgIGFuaW1hdGlvbnMuZm9yRWFjaChmdW5jdGlvbihhbmltYXRpb24pIHtcbiAgICAgICAgICBpZiAoIWFuaW1hdGlvbi5yZXN0aW5nKSByZXN0aW5nID0gZmFsc2U7XG4gICAgICAgICAgYW5pbWF0aW9uLmludGVycG9sYXRlKHRzLCBza2lwVG9FbmRTdGF0ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdGluZztcbiAgICAgIH0sXG4gICAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge31cbiAgICB9O1xuICB9O1xuXG4gIHZhciBhZGRFdmVudCA9IGZ1bmN0aW9uIGFkZEV2ZW50KGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odHlwZSwgZm4pIHtcbiAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBmbik7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgcmVtb3ZlRXZlbnQgPSBmdW5jdGlvbiByZW1vdmVFdmVudChlbGVtZW50KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHR5cGUsIGZuKSB7XG4gICAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgZm4pO1xuICAgIH07XG4gIH07XG5cbiAgLy8gbWl4aW5cbiAgdmFyIGxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyhfcmVmKSB7XG4gICAgdmFyIG1peGluQ29uZmlnID0gX3JlZi5taXhpbkNvbmZpZyxcbiAgICAgIHZpZXdQcm9wcyA9IF9yZWYudmlld1Byb3BzLFxuICAgICAgdmlld0ludGVybmFsQVBJID0gX3JlZi52aWV3SW50ZXJuYWxBUEksXG4gICAgICB2aWV3RXh0ZXJuYWxBUEkgPSBfcmVmLnZpZXdFeHRlcm5hbEFQSSxcbiAgICAgIHZpZXdTdGF0ZSA9IF9yZWYudmlld1N0YXRlLFxuICAgICAgdmlldyA9IF9yZWYudmlldztcbiAgICB2YXIgZXZlbnRzID0gW107XG5cbiAgICB2YXIgYWRkID0gYWRkRXZlbnQodmlldy5lbGVtZW50KTtcbiAgICB2YXIgcmVtb3ZlID0gcmVtb3ZlRXZlbnQodmlldy5lbGVtZW50KTtcblxuICAgIHZpZXdFeHRlcm5hbEFQSS5vbiA9IGZ1bmN0aW9uKHR5cGUsIGZuKSB7XG4gICAgICBldmVudHMucHVzaCh7XG4gICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgIGZuOiBmblxuICAgICAgfSk7XG5cbiAgICAgIGFkZCh0eXBlLCBmbik7XG4gICAgfTtcblxuICAgIHZpZXdFeHRlcm5hbEFQSS5vZmYgPSBmdW5jdGlvbih0eXBlLCBmbikge1xuICAgICAgZXZlbnRzLnNwbGljZShcbiAgICAgICAgZXZlbnRzLmZpbmRJbmRleChmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgIHJldHVybiBldmVudC50eXBlID09PSB0eXBlICYmIGV2ZW50LmZuID09PSBmbjtcbiAgICAgICAgfSksXG4gICAgICAgIDFcbiAgICAgICk7XG5cbiAgICAgIHJlbW92ZSh0eXBlLCBmbik7XG4gICAgfTtcblxuICAgIHJldHVybiB7XG4gICAgICB3cml0ZTogZnVuY3Rpb24gd3JpdGUoKSB7XG4gICAgICAgIC8vIG5vdCBidXN5XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSxcbiAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIGV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgcmVtb3ZlKGV2ZW50LnR5cGUsIGV2ZW50LmZuKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICAvLyBhZGQgdG8gZXh0ZXJuYWwgYXBpIGFuZCBsaW5rIHRvIHByb3BzXG5cbiAgdmFyIGFwaXMgPSBmdW5jdGlvbiBhcGlzKF9yZWYpIHtcbiAgICB2YXIgbWl4aW5Db25maWcgPSBfcmVmLm1peGluQ29uZmlnLFxuICAgICAgdmlld1Byb3BzID0gX3JlZi52aWV3UHJvcHMsXG4gICAgICB2aWV3RXh0ZXJuYWxBUEkgPSBfcmVmLnZpZXdFeHRlcm5hbEFQSTtcbiAgICBhZGRHZXRTZXQobWl4aW5Db25maWcsIHZpZXdFeHRlcm5hbEFQSSwgdmlld1Byb3BzKTtcbiAgfTtcblxuICB2YXIgaXNEZWZpbmVkID0gZnVuY3Rpb24gaXNEZWZpbmVkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9IG51bGw7XG4gIH07XG5cbiAgLy8gYWRkIHRvIHN0YXRlLFxuICAvLyBhZGQgZ2V0dGVycyBhbmQgc2V0dGVycyB0byBpbnRlcm5hbCBhbmQgZXh0ZXJuYWwgYXBpIChpZiBub3Qgc2V0KVxuICAvLyBzZXQgaW5pdGlhbCBzdGF0ZSBiYXNlZCBvbiBwcm9wcyBpbiB2aWV3UHJvcHNcbiAgLy8gYXBwbHkgYXMgdHJhbnNmb3JtcyBlYWNoIGZyYW1lXG5cbiAgdmFyIGRlZmF1bHRzID0ge1xuICAgIG9wYWNpdHk6IDEsXG4gICAgc2NhbGVYOiAxLFxuICAgIHNjYWxlWTogMSxcbiAgICB0cmFuc2xhdGVYOiAwLFxuICAgIHRyYW5zbGF0ZVk6IDAsXG4gICAgcm90YXRlWDogMCxcbiAgICByb3RhdGVZOiAwLFxuICAgIHJvdGF0ZVo6IDAsXG4gICAgb3JpZ2luWDogMCxcbiAgICBvcmlnaW5ZOiAwXG4gIH07XG5cbiAgdmFyIHN0eWxlcyA9IGZ1bmN0aW9uIHN0eWxlcyhfcmVmKSB7XG4gICAgdmFyIG1peGluQ29uZmlnID0gX3JlZi5taXhpbkNvbmZpZyxcbiAgICAgIHZpZXdQcm9wcyA9IF9yZWYudmlld1Byb3BzLFxuICAgICAgdmlld0ludGVybmFsQVBJID0gX3JlZi52aWV3SW50ZXJuYWxBUEksXG4gICAgICB2aWV3RXh0ZXJuYWxBUEkgPSBfcmVmLnZpZXdFeHRlcm5hbEFQSSxcbiAgICAgIHZpZXcgPSBfcmVmLnZpZXc7XG4gICAgLy8gaW5pdGlhbCBwcm9wc1xuICAgIHZhciBpbml0aWFsUHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCB2aWV3UHJvcHMpO1xuXG4gICAgLy8gY3VycmVudCBwcm9wc1xuICAgIHZhciBjdXJyZW50UHJvcHMgPSB7fTtcblxuICAgIC8vIHdlIHdpbGwgYWRkIHRob3NlIHByb3BlcnRpZXMgdG8gdGhlIGV4dGVybmFsIEFQSSBhbmQgbGluayB0aGVtIHRvIHRoZSB2aWV3U3RhdGVcbiAgICBhZGRHZXRTZXQobWl4aW5Db25maWcsIFt2aWV3SW50ZXJuYWxBUEksIHZpZXdFeHRlcm5hbEFQSV0sIHZpZXdQcm9wcyk7XG5cbiAgICAvLyBvdmVycmlkZSByZWN0IG9uIGludGVybmFsIGFuZCBleHRlcm5hbCByZWN0IGdldHRlciBzbyBpdCB0YWtlcyBpbiBhY2NvdW50IHRyYW5zZm9ybXNcbiAgICB2YXIgZ2V0T2Zmc2V0ID0gZnVuY3Rpb24gZ2V0T2Zmc2V0KCkge1xuICAgICAgcmV0dXJuIFt2aWV3UHJvcHNbJ3RyYW5zbGF0ZVgnXSB8fCAwLCB2aWV3UHJvcHNbJ3RyYW5zbGF0ZVknXSB8fCAwXTtcbiAgICB9O1xuXG4gICAgdmFyIGdldFNjYWxlID0gZnVuY3Rpb24gZ2V0U2NhbGUoKSB7XG4gICAgICByZXR1cm4gW3ZpZXdQcm9wc1snc2NhbGVYJ10gfHwgMCwgdmlld1Byb3BzWydzY2FsZVknXSB8fCAwXTtcbiAgICB9O1xuICAgIHZhciBnZXRSZWN0ID0gZnVuY3Rpb24gZ2V0UmVjdCgpIHtcbiAgICAgIHJldHVybiB2aWV3LnJlY3RcbiAgICAgICAgPyBnZXRWaWV3UmVjdCh2aWV3LnJlY3QsIHZpZXcuY2hpbGRWaWV3cywgZ2V0T2Zmc2V0KCksIGdldFNjYWxlKCkpXG4gICAgICAgIDogbnVsbDtcbiAgICB9O1xuICAgIHZpZXdJbnRlcm5hbEFQSS5yZWN0ID0geyBnZXQ6IGdldFJlY3QgfTtcbiAgICB2aWV3RXh0ZXJuYWxBUEkucmVjdCA9IHsgZ2V0OiBnZXRSZWN0IH07XG5cbiAgICAvLyBhcHBseSB2aWV3IHByb3BzXG4gICAgbWl4aW5Db25maWcuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgIHZpZXdQcm9wc1trZXldID1cbiAgICAgICAgdHlwZW9mIGluaXRpYWxQcm9wc1trZXldID09PSAndW5kZWZpbmVkJ1xuICAgICAgICAgID8gZGVmYXVsdHNba2V5XVxuICAgICAgICAgIDogaW5pdGlhbFByb3BzW2tleV07XG4gICAgfSk7XG5cbiAgICAvLyBleHBvc2UgYXBpXG4gICAgcmV0dXJuIHtcbiAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZSgpIHtcbiAgICAgICAgLy8gc2VlIGlmIHByb3BzIGhhdmUgY2hhbmdlZFxuICAgICAgICBpZiAoIXByb3BzSGF2ZUNoYW5nZWQoY3VycmVudFByb3BzLCB2aWV3UHJvcHMpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbW92ZXMgZWxlbWVudCB0byBjb3JyZWN0IHBvc2l0aW9uIG9uIHNjcmVlblxuICAgICAgICBhcHBseVN0eWxlcyh2aWV3LmVsZW1lbnQsIHZpZXdQcm9wcyk7XG5cbiAgICAgICAgLy8gc3RvcmUgbmV3IHRyYW5zZm9ybXNcbiAgICAgICAgT2JqZWN0LmFzc2lnbihjdXJyZW50UHJvcHMsIE9iamVjdC5hc3NpZ24oe30sIHZpZXdQcm9wcykpO1xuXG4gICAgICAgIC8vIG5vIGxvbmdlciBidXN5XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSxcbiAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7fVxuICAgIH07XG4gIH07XG5cbiAgdmFyIHByb3BzSGF2ZUNoYW5nZWQgPSBmdW5jdGlvbiBwcm9wc0hhdmVDaGFuZ2VkKGN1cnJlbnRQcm9wcywgbmV3UHJvcHMpIHtcbiAgICAvLyBkaWZmZXJlbnQgYW1vdW50IG9mIGtleXNcbiAgICBpZiAoT2JqZWN0LmtleXMoY3VycmVudFByb3BzKS5sZW5ndGggIT09IE9iamVjdC5rZXlzKG5ld1Byb3BzKS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIGxldHMgYW5hbHl6ZSB0aGUgaW5kaXZpZHVhbCBwcm9wc1xuICAgIGZvciAodmFyIHByb3AgaW4gbmV3UHJvcHMpIHtcbiAgICAgIGlmIChuZXdQcm9wc1twcm9wXSAhPT0gY3VycmVudFByb3BzW3Byb3BdKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICB2YXIgYXBwbHlTdHlsZXMgPSBmdW5jdGlvbiBhcHBseVN0eWxlcyhlbGVtZW50LCBfcmVmMikge1xuICAgIHZhciBvcGFjaXR5ID0gX3JlZjIub3BhY2l0eSxcbiAgICAgIHBlcnNwZWN0aXZlID0gX3JlZjIucGVyc3BlY3RpdmUsXG4gICAgICB0cmFuc2xhdGVYID0gX3JlZjIudHJhbnNsYXRlWCxcbiAgICAgIHRyYW5zbGF0ZVkgPSBfcmVmMi50cmFuc2xhdGVZLFxuICAgICAgc2NhbGVYID0gX3JlZjIuc2NhbGVYLFxuICAgICAgc2NhbGVZID0gX3JlZjIuc2NhbGVZLFxuICAgICAgcm90YXRlWCA9IF9yZWYyLnJvdGF0ZVgsXG4gICAgICByb3RhdGVZID0gX3JlZjIucm90YXRlWSxcbiAgICAgIHJvdGF0ZVogPSBfcmVmMi5yb3RhdGVaLFxuICAgICAgb3JpZ2luWCA9IF9yZWYyLm9yaWdpblgsXG4gICAgICBvcmlnaW5ZID0gX3JlZjIub3JpZ2luWSxcbiAgICAgIHdpZHRoID0gX3JlZjIud2lkdGgsXG4gICAgICBoZWlnaHQgPSBfcmVmMi5oZWlnaHQ7XG5cbiAgICB2YXIgdHJhbnNmb3JtcyA9ICcnO1xuICAgIHZhciBzdHlsZXMgPSAnJztcblxuICAgIC8vIGhhbmRsZSB0cmFuc2Zvcm0gb3JpZ2luXG4gICAgaWYgKGlzRGVmaW5lZChvcmlnaW5YKSB8fCBpc0RlZmluZWQob3JpZ2luWSkpIHtcbiAgICAgIHN0eWxlcyArPVxuICAgICAgICAndHJhbnNmb3JtLW9yaWdpbjogJyArIChvcmlnaW5YIHx8IDApICsgJ3B4ICcgKyAob3JpZ2luWSB8fCAwKSArICdweDsnO1xuICAgIH1cblxuICAgIC8vIHRyYW5zZm9ybSBvcmRlciBpcyByZWxldmFudFxuICAgIC8vIDAuIHBlcnNwZWN0aXZlXG4gICAgaWYgKGlzRGVmaW5lZChwZXJzcGVjdGl2ZSkpIHtcbiAgICAgIHRyYW5zZm9ybXMgKz0gJ3BlcnNwZWN0aXZlKCcgKyBwZXJzcGVjdGl2ZSArICdweCkgJztcbiAgICB9XG5cbiAgICAvLyAxLiB0cmFuc2xhdGVcbiAgICBpZiAoaXNEZWZpbmVkKHRyYW5zbGF0ZVgpIHx8IGlzRGVmaW5lZCh0cmFuc2xhdGVZKSkge1xuICAgICAgdHJhbnNmb3JtcyArPVxuICAgICAgICAndHJhbnNsYXRlM2QoJyArXG4gICAgICAgICh0cmFuc2xhdGVYIHx8IDApICtcbiAgICAgICAgJ3B4LCAnICtcbiAgICAgICAgKHRyYW5zbGF0ZVkgfHwgMCkgK1xuICAgICAgICAncHgsIDApICc7XG4gICAgfVxuXG4gICAgLy8gMi4gc2NhbGVcbiAgICBpZiAoaXNEZWZpbmVkKHNjYWxlWCkgfHwgaXNEZWZpbmVkKHNjYWxlWSkpIHtcbiAgICAgIHRyYW5zZm9ybXMgKz1cbiAgICAgICAgJ3NjYWxlM2QoJyArXG4gICAgICAgIChpc0RlZmluZWQoc2NhbGVYKSA/IHNjYWxlWCA6IDEpICtcbiAgICAgICAgJywgJyArXG4gICAgICAgIChpc0RlZmluZWQoc2NhbGVZKSA/IHNjYWxlWSA6IDEpICtcbiAgICAgICAgJywgMSkgJztcbiAgICB9XG5cbiAgICAvLyAzLiByb3RhdGVcbiAgICBpZiAoaXNEZWZpbmVkKHJvdGF0ZVopKSB7XG4gICAgICB0cmFuc2Zvcm1zICs9ICdyb3RhdGVaKCcgKyByb3RhdGVaICsgJ3JhZCkgJztcbiAgICB9XG5cbiAgICBpZiAoaXNEZWZpbmVkKHJvdGF0ZVgpKSB7XG4gICAgICB0cmFuc2Zvcm1zICs9ICdyb3RhdGVYKCcgKyByb3RhdGVYICsgJ3JhZCkgJztcbiAgICB9XG5cbiAgICBpZiAoaXNEZWZpbmVkKHJvdGF0ZVkpKSB7XG4gICAgICB0cmFuc2Zvcm1zICs9ICdyb3RhdGVZKCcgKyByb3RhdGVZICsgJ3JhZCkgJztcbiAgICB9XG5cbiAgICAvLyBhZGQgdHJhbnNmb3Jtc1xuICAgIGlmICh0cmFuc2Zvcm1zLmxlbmd0aCkge1xuICAgICAgc3R5bGVzICs9ICd0cmFuc2Zvcm06JyArIHRyYW5zZm9ybXMgKyAnOyc7XG4gICAgfVxuXG4gICAgLy8gYWRkIG9wYWNpdHlcbiAgICBpZiAoaXNEZWZpbmVkKG9wYWNpdHkpKSB7XG4gICAgICBzdHlsZXMgKz0gJ29wYWNpdHk6JyArIG9wYWNpdHkgKyAnOyc7XG5cbiAgICAgIC8vIGlmIHdlIHJlYWNoIHplcm8sIHdlIG1ha2UgdGhlIGVsZW1lbnQgaW5hY2Nlc3NpYmxlXG4gICAgICBpZiAob3BhY2l0eSA9PT0gMCkge1xuICAgICAgICBzdHlsZXMgKz0gJ3Zpc2liaWxpdHk6aGlkZGVuOyc7XG4gICAgICB9XG5cbiAgICAgIC8vIGlmIHdlJ3JlIGJlbG93IDEwMCUgb3BhY2l0eSB0aGlzIGVsZW1lbnQgY2FuJ3QgYmUgY2xpY2tlZFxuICAgICAgaWYgKG9wYWNpdHkgPCAxKSB7XG4gICAgICAgIHN0eWxlcyArPSAncG9pbnRlci1ldmVudHM6bm9uZTsnO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGFkZCBoZWlnaHRcbiAgICBpZiAoaXNEZWZpbmVkKGhlaWdodCkpIHtcbiAgICAgIHN0eWxlcyArPSAnaGVpZ2h0OicgKyBoZWlnaHQgKyAncHg7JztcbiAgICB9XG5cbiAgICAvLyBhZGQgd2lkdGhcbiAgICBpZiAoaXNEZWZpbmVkKHdpZHRoKSkge1xuICAgICAgc3R5bGVzICs9ICd3aWR0aDonICsgd2lkdGggKyAncHg7JztcbiAgICB9XG5cbiAgICAvLyBhcHBseSBzdHlsZXNcbiAgICB2YXIgZWxlbWVudEN1cnJlbnRTdHlsZSA9IGVsZW1lbnQuZWxlbWVudEN1cnJlbnRTdHlsZSB8fCAnJztcblxuICAgIC8vIGlmIG5ldyBzdHlsZXMgZG9lcyBub3QgbWF0Y2ggY3VycmVudCBzdHlsZXMsIGxldHMgdXBkYXRlIVxuICAgIGlmIChcbiAgICAgIHN0eWxlcy5sZW5ndGggIT09IGVsZW1lbnRDdXJyZW50U3R5bGUubGVuZ3RoIHx8XG4gICAgICBzdHlsZXMgIT09IGVsZW1lbnRDdXJyZW50U3R5bGVcbiAgICApIHtcbiAgICAgIGVsZW1lbnQuc3R5bGUuY3NzVGV4dCA9IHN0eWxlcztcbiAgICAgIC8vIHN0b3JlIGN1cnJlbnQgc3R5bGVzIHNvIHdlIGNhbiBjb21wYXJlIHRoZW0gdG8gbmV3IHN0eWxlcyBsYXRlciBvblxuICAgICAgLy8gX25vdF8gZ2V0dGluZyB0aGUgc3R5bGUgdmFsdWUgaXMgZmFzdGVyXG4gICAgICBlbGVtZW50LmVsZW1lbnRDdXJyZW50U3R5bGUgPSBzdHlsZXM7XG4gICAgfVxuICB9O1xuXG4gIHZhciBNaXhpbnMgPSB7XG4gICAgc3R5bGVzOiBzdHlsZXMsXG4gICAgbGlzdGVuZXJzOiBsaXN0ZW5lcnMsXG4gICAgYW5pbWF0aW9uczogYW5pbWF0aW9ucyxcbiAgICBhcGlzOiBhcGlzXG4gIH07XG5cbiAgdmFyIHVwZGF0ZVJlY3QgPSBmdW5jdGlvbiB1cGRhdGVSZWN0KCkge1xuICAgIHZhciByZWN0ID1cbiAgICAgIGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgdmFyIGVsZW1lbnQgPVxuICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIgc3R5bGUgPVxuICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcblxuICAgIGlmICghZWxlbWVudC5sYXlvdXRDYWxjdWxhdGVkKSB7XG4gICAgICByZWN0LnBhZGRpbmdUb3AgPSBwYXJzZUludChzdHlsZS5wYWRkaW5nVG9wLCAxMCkgfHwgMDtcbiAgICAgIHJlY3QubWFyZ2luVG9wID0gcGFyc2VJbnQoc3R5bGUubWFyZ2luVG9wLCAxMCkgfHwgMDtcbiAgICAgIHJlY3QubWFyZ2luUmlnaHQgPSBwYXJzZUludChzdHlsZS5tYXJnaW5SaWdodCwgMTApIHx8IDA7XG4gICAgICByZWN0Lm1hcmdpbkJvdHRvbSA9IHBhcnNlSW50KHN0eWxlLm1hcmdpbkJvdHRvbSwgMTApIHx8IDA7XG4gICAgICByZWN0Lm1hcmdpbkxlZnQgPSBwYXJzZUludChzdHlsZS5tYXJnaW5MZWZ0LCAxMCkgfHwgMDtcbiAgICAgIGVsZW1lbnQubGF5b3V0Q2FsY3VsYXRlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgcmVjdC5sZWZ0ID0gZWxlbWVudC5vZmZzZXRMZWZ0IHx8IDA7XG4gICAgcmVjdC50b3AgPSBlbGVtZW50Lm9mZnNldFRvcCB8fCAwO1xuICAgIHJlY3Qud2lkdGggPSBlbGVtZW50Lm9mZnNldFdpZHRoIHx8IDA7XG4gICAgcmVjdC5oZWlnaHQgPSBlbGVtZW50Lm9mZnNldEhlaWdodCB8fCAwO1xuXG4gICAgcmVjdC5yaWdodCA9IHJlY3QubGVmdCArIHJlY3Qud2lkdGg7XG4gICAgcmVjdC5ib3R0b20gPSByZWN0LnRvcCArIHJlY3QuaGVpZ2h0O1xuXG4gICAgcmVjdC5zY3JvbGxUb3AgPSBlbGVtZW50LnNjcm9sbFRvcDtcblxuICAgIHJlY3QuaGlkZGVuID0gZWxlbWVudC5vZmZzZXRQYXJlbnQgPT09IG51bGw7XG5cbiAgICByZXR1cm4gcmVjdDtcbiAgfTtcblxuICB2YXIgY3JlYXRlVmlldyA9XG4gICAgLy8gZGVmYXVsdCB2aWV3IGRlZmluaXRpb25cbiAgICBmdW5jdGlvbiBjcmVhdGVWaWV3KCkge1xuICAgICAgdmFyIF9yZWYgPVxuICAgICAgICAgIGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IGFyZ3VtZW50c1swXVxuICAgICAgICAgICAgOiB7fSxcbiAgICAgICAgX3JlZiR0YWcgPSBfcmVmLnRhZyxcbiAgICAgICAgdGFnID0gX3JlZiR0YWcgPT09IHZvaWQgMCA/ICdkaXYnIDogX3JlZiR0YWcsXG4gICAgICAgIF9yZWYkbmFtZSA9IF9yZWYubmFtZSxcbiAgICAgICAgbmFtZSA9IF9yZWYkbmFtZSA9PT0gdm9pZCAwID8gbnVsbCA6IF9yZWYkbmFtZSxcbiAgICAgICAgX3JlZiRhdHRyaWJ1dGVzID0gX3JlZi5hdHRyaWJ1dGVzLFxuICAgICAgICBhdHRyaWJ1dGVzID0gX3JlZiRhdHRyaWJ1dGVzID09PSB2b2lkIDAgPyB7fSA6IF9yZWYkYXR0cmlidXRlcyxcbiAgICAgICAgX3JlZiRyZWFkID0gX3JlZi5yZWFkLFxuICAgICAgICByZWFkID0gX3JlZiRyZWFkID09PSB2b2lkIDAgPyBmdW5jdGlvbigpIHt9IDogX3JlZiRyZWFkLFxuICAgICAgICBfcmVmJHdyaXRlID0gX3JlZi53cml0ZSxcbiAgICAgICAgd3JpdGUgPSBfcmVmJHdyaXRlID09PSB2b2lkIDAgPyBmdW5jdGlvbigpIHt9IDogX3JlZiR3cml0ZSxcbiAgICAgICAgX3JlZiRjcmVhdGUgPSBfcmVmLmNyZWF0ZSxcbiAgICAgICAgY3JlYXRlID0gX3JlZiRjcmVhdGUgPT09IHZvaWQgMCA/IGZ1bmN0aW9uKCkge30gOiBfcmVmJGNyZWF0ZSxcbiAgICAgICAgX3JlZiRkZXN0cm95ID0gX3JlZi5kZXN0cm95LFxuICAgICAgICBkZXN0cm95ID0gX3JlZiRkZXN0cm95ID09PSB2b2lkIDAgPyBmdW5jdGlvbigpIHt9IDogX3JlZiRkZXN0cm95LFxuICAgICAgICBfcmVmJGZpbHRlckZyYW1lQWN0aW8gPSBfcmVmLmZpbHRlckZyYW1lQWN0aW9uc0ZvckNoaWxkLFxuICAgICAgICBmaWx0ZXJGcmFtZUFjdGlvbnNGb3JDaGlsZCA9XG4gICAgICAgICAgX3JlZiRmaWx0ZXJGcmFtZUFjdGlvID09PSB2b2lkIDBcbiAgICAgICAgICAgID8gZnVuY3Rpb24oY2hpbGQsIGFjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWN0aW9ucztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiBfcmVmJGZpbHRlckZyYW1lQWN0aW8sXG4gICAgICAgIF9yZWYkZGlkQ3JlYXRlVmlldyA9IF9yZWYuZGlkQ3JlYXRlVmlldyxcbiAgICAgICAgZGlkQ3JlYXRlVmlldyA9XG4gICAgICAgICAgX3JlZiRkaWRDcmVhdGVWaWV3ID09PSB2b2lkIDAgPyBmdW5jdGlvbigpIHt9IDogX3JlZiRkaWRDcmVhdGVWaWV3LFxuICAgICAgICBfcmVmJGRpZFdyaXRlVmlldyA9IF9yZWYuZGlkV3JpdGVWaWV3LFxuICAgICAgICBkaWRXcml0ZVZpZXcgPVxuICAgICAgICAgIF9yZWYkZGlkV3JpdGVWaWV3ID09PSB2b2lkIDAgPyBmdW5jdGlvbigpIHt9IDogX3JlZiRkaWRXcml0ZVZpZXcsXG4gICAgICAgIF9yZWYkaWdub3JlUmVjdCA9IF9yZWYuaWdub3JlUmVjdCxcbiAgICAgICAgaWdub3JlUmVjdCA9IF9yZWYkaWdub3JlUmVjdCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmJGlnbm9yZVJlY3QsXG4gICAgICAgIF9yZWYkaWdub3JlUmVjdFVwZGF0ZSA9IF9yZWYuaWdub3JlUmVjdFVwZGF0ZSxcbiAgICAgICAgaWdub3JlUmVjdFVwZGF0ZSA9XG4gICAgICAgICAgX3JlZiRpZ25vcmVSZWN0VXBkYXRlID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYkaWdub3JlUmVjdFVwZGF0ZSxcbiAgICAgICAgX3JlZiRtaXhpbnMgPSBfcmVmLm1peGlucyxcbiAgICAgICAgbWl4aW5zID0gX3JlZiRtaXhpbnMgPT09IHZvaWQgMCA/IFtdIDogX3JlZiRtaXhpbnM7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oXG4gICAgICAgIC8vIGVhY2ggdmlldyByZXF1aXJlcyByZWZlcmVuY2UgdG8gc3RvcmVcbiAgICAgICAgc3RvcmVcbiAgICAgICkge1xuICAgICAgICB2YXIgcHJvcHMgPVxuICAgICAgICAgIGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IGFyZ3VtZW50c1sxXVxuICAgICAgICAgICAgOiB7fTtcbiAgICAgICAgLy8gcm9vdCBlbGVtZW50IHNob3VsZCBub3QgYmUgY2hhbmdlZFxuICAgICAgICB2YXIgZWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQodGFnLCAnZmlsZXBvbmQtLScgKyBuYW1lLCBhdHRyaWJ1dGVzKTtcblxuICAgICAgICAvLyBzdHlsZSByZWZlcmVuY2Ugc2hvdWxkIGFsc28gbm90IGJlIGNoYW5nZWRcbiAgICAgICAgdmFyIHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCwgbnVsbCk7XG5cbiAgICAgICAgLy8gZWxlbWVudCByZWN0YW5nbGVcbiAgICAgICAgdmFyIHJlY3QgPSB1cGRhdGVSZWN0KCk7XG4gICAgICAgIHZhciBmcmFtZVJlY3QgPSBudWxsO1xuXG4gICAgICAgIC8vIHJlc3Qgc3RhdGVcbiAgICAgICAgdmFyIGlzUmVzdGluZyA9IGZhbHNlO1xuXG4gICAgICAgIC8vIHByZXR0eSBzZWxmIGV4cGxhbmF0b3J5XG4gICAgICAgIHZhciBjaGlsZFZpZXdzID0gW107XG5cbiAgICAgICAgLy8gbG9hZGVkIG1peGluc1xuICAgICAgICB2YXIgYWN0aXZlTWl4aW5zID0gW107XG5cbiAgICAgICAgLy8gcmVmZXJlbmNlcyB0byBjcmVhdGVkIGNoaWxkcmVuXG4gICAgICAgIHZhciByZWYgPSB7fTtcblxuICAgICAgICAvLyBzdGF0ZSB1c2VkIGZvciBlYWNoIGluc3RhbmNlXG4gICAgICAgIHZhciBzdGF0ZSA9IHt9O1xuXG4gICAgICAgIC8vIGxpc3Qgb2Ygd3JpdGVycyB0aGF0IHdpbGwgYmUgY2FsbGVkIHRvIHVwZGF0ZSB0aGlzIHZpZXdcbiAgICAgICAgdmFyIHdyaXRlcnMgPSBbXG4gICAgICAgICAgd3JpdGUgLy8gZGVmYXVsdCB3cml0ZXJcbiAgICAgICAgXTtcblxuICAgICAgICB2YXIgcmVhZGVycyA9IFtcbiAgICAgICAgICByZWFkIC8vIGRlZmF1bHQgcmVhZGVyXG4gICAgICAgIF07XG5cbiAgICAgICAgdmFyIGRlc3Ryb3llcnMgPSBbXG4gICAgICAgICAgZGVzdHJveSAvLyBkZWZhdWx0IGRlc3Ryb3lcbiAgICAgICAgXTtcblxuICAgICAgICAvLyBjb3JlIHZpZXcgbWV0aG9kc1xuICAgICAgICB2YXIgZ2V0RWxlbWVudCA9IGZ1bmN0aW9uIGdldEVsZW1lbnQoKSB7XG4gICAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBnZXRDaGlsZFZpZXdzID0gZnVuY3Rpb24gZ2V0Q2hpbGRWaWV3cygpIHtcbiAgICAgICAgICByZXR1cm4gY2hpbGRWaWV3cy5jb25jYXQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGdldFJlZmVyZW5jZSA9IGZ1bmN0aW9uIGdldFJlZmVyZW5jZSgpIHtcbiAgICAgICAgICByZXR1cm4gcmVmO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgY3JlYXRlQ2hpbGRWaWV3ID0gZnVuY3Rpb24gY3JlYXRlQ2hpbGRWaWV3KHN0b3JlKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHZpZXcsIHByb3BzKSB7XG4gICAgICAgICAgICByZXR1cm4gdmlldyhzdG9yZSwgcHJvcHMpO1xuICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIHZhciBnZXRSZWN0ID0gZnVuY3Rpb24gZ2V0UmVjdCgpIHtcbiAgICAgICAgICBpZiAoZnJhbWVSZWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gZnJhbWVSZWN0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBmcmFtZVJlY3QgPSBnZXRWaWV3UmVjdChyZWN0LCBjaGlsZFZpZXdzLCBbMCwgMF0sIFsxLCAxXSk7XG4gICAgICAgICAgcmV0dXJuIGZyYW1lUmVjdDtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGdldFN0eWxlID0gZnVuY3Rpb24gZ2V0U3R5bGUoKSB7XG4gICAgICAgICAgcmV0dXJuIHN0eWxlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWFkIGRhdGEgZnJvbSBET01cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHZhciBfcmVhZCA9IGZ1bmN0aW9uIF9yZWFkKCkge1xuICAgICAgICAgIGZyYW1lUmVjdCA9IG51bGw7XG5cbiAgICAgICAgICAvLyByZWFkIGNoaWxkIHZpZXdzXG4gICAgICAgICAgY2hpbGRWaWV3cy5mb3JFYWNoKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgICAgICByZXR1cm4gY2hpbGQuX3JlYWQoKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBzaG91bGRVcGRhdGUgPSAhKGlnbm9yZVJlY3RVcGRhdGUgJiYgcmVjdC53aWR0aCAmJiByZWN0LmhlaWdodCk7XG4gICAgICAgICAgaWYgKHNob3VsZFVwZGF0ZSkge1xuICAgICAgICAgICAgdXBkYXRlUmVjdChyZWN0LCBlbGVtZW50LCBzdHlsZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gcmVhZGVyc1xuICAgICAgICAgIHZhciBhcGkgPSB7IHJvb3Q6IGludGVybmFsQVBJLCBwcm9wczogcHJvcHMsIHJlY3Q6IHJlY3QgfTtcbiAgICAgICAgICByZWFkZXJzLmZvckVhY2goZnVuY3Rpb24ocmVhZGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVhZGVyKGFwaSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdyaXRlIGRhdGEgdG8gRE9NXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgX3dyaXRlID0gZnVuY3Rpb24gX3dyaXRlKHRzLCBmcmFtZUFjdGlvbnMsIHNob3VsZE9wdGltaXplKSB7XG4gICAgICAgICAgLy8gaWYgbm8gYWN0aW9ucywgd2UgYXNzdW1lIHRoYXQgdGhlIHZpZXcgaXMgcmVzdGluZ1xuICAgICAgICAgIHZhciByZXN0aW5nID0gZnJhbWVBY3Rpb25zLmxlbmd0aCA9PT0gMDtcblxuICAgICAgICAgIC8vIHdyaXRlcnNcbiAgICAgICAgICB3cml0ZXJzLmZvckVhY2goZnVuY3Rpb24od3JpdGVyKSB7XG4gICAgICAgICAgICB2YXIgd3JpdGVyUmVzdGluZyA9IHdyaXRlcih7XG4gICAgICAgICAgICAgIHByb3BzOiBwcm9wcyxcbiAgICAgICAgICAgICAgcm9vdDogaW50ZXJuYWxBUEksXG4gICAgICAgICAgICAgIGFjdGlvbnM6IGZyYW1lQWN0aW9ucyxcbiAgICAgICAgICAgICAgdGltZXN0YW1wOiB0cyxcbiAgICAgICAgICAgICAgc2hvdWxkT3B0aW1pemU6IHNob3VsZE9wdGltaXplXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKHdyaXRlclJlc3RpbmcgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIHJlc3RpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIC8vIHJ1biBtaXhpbnNcbiAgICAgICAgICBhY3RpdmVNaXhpbnMuZm9yRWFjaChmdW5jdGlvbihtaXhpbikge1xuICAgICAgICAgICAgLy8gaWYgb25lIG9mIHRoZSBtaXhpbnMgaXMgc3RpbGwgYnVzeSBhZnRlciB3cml0ZSBvcGVyYXRpb24sIHdlIGFyZSBub3QgcmVzdGluZ1xuICAgICAgICAgICAgdmFyIG1peGluUmVzdGluZyA9IG1peGluLndyaXRlKHRzKTtcbiAgICAgICAgICAgIGlmIChtaXhpblJlc3RpbmcgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIHJlc3RpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIC8vIHVwZGF0ZXMgY2hpbGQgdmlld3MgdGhhdCBhcmUgY3VycmVudGx5IGF0dGFjaGVkIHRvIHRoZSBET01cbiAgICAgICAgICBjaGlsZFZpZXdzXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgICAgICAgIHJldHVybiAhIWNoaWxkLmVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICAgICAgICAvLyBpZiBhIGNoaWxkIHZpZXcgaXMgbm90IHJlc3RpbmcsIHdlIGFyZSBub3QgcmVzdGluZ1xuICAgICAgICAgICAgICB2YXIgY2hpbGRSZXN0aW5nID0gY2hpbGQuX3dyaXRlKFxuICAgICAgICAgICAgICAgIHRzLFxuICAgICAgICAgICAgICAgIGZpbHRlckZyYW1lQWN0aW9uc0ZvckNoaWxkKGNoaWxkLCBmcmFtZUFjdGlvbnMpLFxuICAgICAgICAgICAgICAgIHNob3VsZE9wdGltaXplXG4gICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgaWYgKCFjaGlsZFJlc3RpbmcpIHtcbiAgICAgICAgICAgICAgICByZXN0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gYXBwZW5kIG5ldyBlbGVtZW50cyB0byBET00gYW5kIHVwZGF0ZSB0aG9zZVxuICAgICAgICAgIGNoaWxkVmlld3NcbiAgICAgICAgICAgIC8vLmZpbHRlcihjaGlsZCA9PiAhY2hpbGQuZWxlbWVudC5wYXJlbnROb2RlKVxuICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24oY2hpbGQsIGluZGV4KSB7XG4gICAgICAgICAgICAgIC8vIHNraXBcbiAgICAgICAgICAgICAgaWYgKGNoaWxkLmVsZW1lbnQucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIGFwcGVuZCB0byBET01cbiAgICAgICAgICAgICAgaW50ZXJuYWxBUEkuYXBwZW5kQ2hpbGQoY2hpbGQuZWxlbWVudCwgaW5kZXgpO1xuXG4gICAgICAgICAgICAgIC8vIGNhbGwgcmVhZCAobmVlZCB0byBrbm93IHRoZSBzaXplIG9mIHRoZXNlIGVsZW1lbnRzKVxuICAgICAgICAgICAgICBjaGlsZC5fcmVhZCgpO1xuXG4gICAgICAgICAgICAgIC8vIHJlLWNhbGwgd3JpdGVcbiAgICAgICAgICAgICAgY2hpbGQuX3dyaXRlKFxuICAgICAgICAgICAgICAgIHRzLFxuICAgICAgICAgICAgICAgIGZpbHRlckZyYW1lQWN0aW9uc0ZvckNoaWxkKGNoaWxkLCBmcmFtZUFjdGlvbnMpLFxuICAgICAgICAgICAgICAgIHNob3VsZE9wdGltaXplXG4gICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgLy8gd2UganVzdCBhZGRlZCBzb210aGluZyB0byB0aGUgZG9tLCBubyByZXN0XG4gICAgICAgICAgICAgIHJlc3RpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gdXBkYXRlIHJlc3Rpbmcgc3RhdGVcbiAgICAgICAgICBpc1Jlc3RpbmcgPSByZXN0aW5nO1xuXG4gICAgICAgICAgZGlkV3JpdGVWaWV3KHtcbiAgICAgICAgICAgIHByb3BzOiBwcm9wcyxcbiAgICAgICAgICAgIHJvb3Q6IGludGVybmFsQVBJLFxuICAgICAgICAgICAgYWN0aW9uczogZnJhbWVBY3Rpb25zLFxuICAgICAgICAgICAgdGltZXN0YW1wOiB0c1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gbGV0IHBhcmVudCBrbm93IGlmIHdlIGFyZSByZXN0aW5nXG4gICAgICAgICAgcmV0dXJuIHJlc3Rpbmc7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIF9kZXN0cm95ID0gZnVuY3Rpb24gX2Rlc3Ryb3koKSB7XG4gICAgICAgICAgYWN0aXZlTWl4aW5zLmZvckVhY2goZnVuY3Rpb24obWl4aW4pIHtcbiAgICAgICAgICAgIHJldHVybiBtaXhpbi5kZXN0cm95KCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZGVzdHJveWVycy5mb3JFYWNoKGZ1bmN0aW9uKGRlc3Ryb3llcikge1xuICAgICAgICAgICAgZGVzdHJveWVyKHsgcm9vdDogaW50ZXJuYWxBUEksIHByb3BzOiBwcm9wcyB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjaGlsZFZpZXdzLmZvckVhY2goZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGlsZC5fZGVzdHJveSgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHNoYXJlZEFQSVxuICAgICAgICB2YXIgc2hhcmVkQVBJRGVmaW5pdGlvbiA9IHtcbiAgICAgICAgICBlbGVtZW50OiB7XG4gICAgICAgICAgICBnZXQ6IGdldEVsZW1lbnRcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIGdldDogZ2V0U3R5bGVcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgY2hpbGRWaWV3czoge1xuICAgICAgICAgICAgZ2V0OiBnZXRDaGlsZFZpZXdzXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHByaXZhdGUgQVBJIGRlZmluaXRpb25cbiAgICAgICAgdmFyIGludGVybmFsQVBJRGVmaW5pdGlvbiA9IE9iamVjdC5hc3NpZ24oe30sIHNoYXJlZEFQSURlZmluaXRpb24sIHtcbiAgICAgICAgICByZWN0OiB7XG4gICAgICAgICAgICBnZXQ6IGdldFJlY3RcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgLy8gYWNjZXNzIHRvIGN1c3RvbSBjaGlsZHJlbiByZWZlcmVuY2VzXG4gICAgICAgICAgcmVmOiB7XG4gICAgICAgICAgICBnZXQ6IGdldFJlZmVyZW5jZVxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICAvLyBkb20gbW9kaWZpZXJzXG4gICAgICAgICAgaXM6IGZ1bmN0aW9uIGlzKG5lZWRsZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5hbWUgPT09IG5lZWRsZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGFwcGVuZENoaWxkOiBhcHBlbmRDaGlsZChlbGVtZW50KSxcbiAgICAgICAgICBjcmVhdGVDaGlsZFZpZXc6IGNyZWF0ZUNoaWxkVmlldyhzdG9yZSksXG4gICAgICAgICAgbGlua1ZpZXc6IGZ1bmN0aW9uIGxpbmtWaWV3KHZpZXcpIHtcbiAgICAgICAgICAgIGNoaWxkVmlld3MucHVzaCh2aWV3KTtcbiAgICAgICAgICAgIHJldHVybiB2aWV3O1xuICAgICAgICAgIH0sXG4gICAgICAgICAgdW5saW5rVmlldzogZnVuY3Rpb24gdW5saW5rVmlldyh2aWV3KSB7XG4gICAgICAgICAgICBjaGlsZFZpZXdzLnNwbGljZShjaGlsZFZpZXdzLmluZGV4T2YodmlldyksIDEpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgYXBwZW5kQ2hpbGRWaWV3OiBhcHBlbmRDaGlsZFZpZXcoZWxlbWVudCwgY2hpbGRWaWV3cyksXG4gICAgICAgICAgcmVtb3ZlQ2hpbGRWaWV3OiByZW1vdmVDaGlsZFZpZXcoZWxlbWVudCwgY2hpbGRWaWV3cyksXG4gICAgICAgICAgcmVnaXN0ZXJXcml0ZXI6IGZ1bmN0aW9uIHJlZ2lzdGVyV3JpdGVyKHdyaXRlcikge1xuICAgICAgICAgICAgcmV0dXJuIHdyaXRlcnMucHVzaCh3cml0ZXIpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVnaXN0ZXJSZWFkZXI6IGZ1bmN0aW9uIHJlZ2lzdGVyUmVhZGVyKHJlYWRlcikge1xuICAgICAgICAgICAgcmV0dXJuIHJlYWRlcnMucHVzaChyZWFkZXIpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVnaXN0ZXJEZXN0cm95ZXI6IGZ1bmN0aW9uIHJlZ2lzdGVyRGVzdHJveWVyKGRlc3Ryb3llcikge1xuICAgICAgICAgICAgcmV0dXJuIGRlc3Ryb3llcnMucHVzaChkZXN0cm95ZXIpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgaW52YWxpZGF0ZUxheW91dDogZnVuY3Rpb24gaW52YWxpZGF0ZUxheW91dCgpIHtcbiAgICAgICAgICAgIHJldHVybiAoZWxlbWVudC5sYXlvdXRDYWxjdWxhdGVkID0gZmFsc2UpO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICAvLyBhY2Nlc3MgdG8gZGF0YSBzdG9yZVxuICAgICAgICAgIGRpc3BhdGNoOiBzdG9yZS5kaXNwYXRjaCxcbiAgICAgICAgICBxdWVyeTogc3RvcmUucXVlcnlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gcHVibGljIHZpZXcgQVBJIG1ldGhvZHNcbiAgICAgICAgdmFyIGV4dGVybmFsQVBJRGVmaW5pdGlvbiA9IHtcbiAgICAgICAgICBlbGVtZW50OiB7XG4gICAgICAgICAgICBnZXQ6IGdldEVsZW1lbnRcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgY2hpbGRWaWV3czoge1xuICAgICAgICAgICAgZ2V0OiBnZXRDaGlsZFZpZXdzXG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHJlY3Q6IHtcbiAgICAgICAgICAgIGdldDogZ2V0UmVjdFxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICByZXN0aW5nOiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGlzUmVzdGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgaXNSZWN0SWdub3JlZDogZnVuY3Rpb24gaXNSZWN0SWdub3JlZCgpIHtcbiAgICAgICAgICAgIHJldHVybiBpZ25vcmVSZWN0O1xuICAgICAgICAgIH0sXG4gICAgICAgICAgX3JlYWQ6IF9yZWFkLFxuICAgICAgICAgIF93cml0ZTogX3dyaXRlLFxuICAgICAgICAgIF9kZXN0cm95OiBfZGVzdHJveVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIG1peGluIEFQSSBtZXRob2RzXG4gICAgICAgIHZhciBtaXhpbkFQSURlZmluaXRpb24gPSBPYmplY3QuYXNzaWduKHt9LCBzaGFyZWRBUElEZWZpbml0aW9uLCB7XG4gICAgICAgICAgcmVjdDoge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgIHJldHVybiByZWN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gYWRkIG1peGluIGZ1bmN0aW9uYWxpdHlcbiAgICAgICAgT2JqZWN0LmtleXMobWl4aW5zKVxuICAgICAgICAgIC5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgIC8vIG1vdmUgc3R5bGVzIHRvIHRoZSBiYWNrIG9mIHRoZSBtaXhpbiBsaXN0IChzbyBhZGp1c3RtZW50cyBvZiBvdGhlciBtaXhpbnMgYXJlIGFwcGxpZWQgdG8gdGhlIHByb3BzIGNvcnJlY3RseSlcbiAgICAgICAgICAgIGlmIChhID09PSAnc3R5bGVzJykge1xuICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYiA9PT0gJ3N0eWxlcycpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgfSlcbiAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIHZhciBtaXhpbkFQSSA9IE1peGluc1trZXldKHtcbiAgICAgICAgICAgICAgbWl4aW5Db25maWc6IG1peGluc1trZXldLFxuICAgICAgICAgICAgICB2aWV3UHJvcHM6IHByb3BzLFxuICAgICAgICAgICAgICB2aWV3U3RhdGU6IHN0YXRlLFxuICAgICAgICAgICAgICB2aWV3SW50ZXJuYWxBUEk6IGludGVybmFsQVBJRGVmaW5pdGlvbixcbiAgICAgICAgICAgICAgdmlld0V4dGVybmFsQVBJOiBleHRlcm5hbEFQSURlZmluaXRpb24sXG4gICAgICAgICAgICAgIHZpZXc6IGNyZWF0ZU9iamVjdChtaXhpbkFQSURlZmluaXRpb24pXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKG1peGluQVBJKSB7XG4gICAgICAgICAgICAgIGFjdGl2ZU1peGlucy5wdXNoKG1peGluQVBJKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAvLyBjb25zdHJ1Y3QgcHJpdmF0ZSBhcGlcbiAgICAgICAgdmFyIGludGVybmFsQVBJID0gY3JlYXRlT2JqZWN0KGludGVybmFsQVBJRGVmaW5pdGlvbik7XG5cbiAgICAgICAgLy8gY3JlYXRlIHRoZSB2aWV3XG4gICAgICAgIGNyZWF0ZSh7XG4gICAgICAgICAgcm9vdDogaW50ZXJuYWxBUEksXG4gICAgICAgICAgcHJvcHM6IHByb3BzXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGFwcGVuZCBjcmVhdGVkIGNoaWxkIHZpZXdzIHRvIHJvb3Qgbm9kZVxuICAgICAgICB2YXIgY2hpbGRDb3VudCA9IGdldENoaWxkQ291bnQoZWxlbWVudCk7IC8vIG5lZWQgdG8ga25vdyB0aGUgY3VycmVudCBjaGlsZCBjb3VudCBzbyBhcHBlbmRpbmcgaGFwcGVucyBpbiBjb3JyZWN0IG9yZGVyXG4gICAgICAgIGNoaWxkVmlld3MuZm9yRWFjaChmdW5jdGlvbihjaGlsZCwgaW5kZXgpIHtcbiAgICAgICAgICBpbnRlcm5hbEFQSS5hcHBlbmRDaGlsZChjaGlsZC5lbGVtZW50LCBjaGlsZENvdW50ICsgaW5kZXgpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBjYWxsIGRpZCBjcmVhdGVcbiAgICAgICAgZGlkQ3JlYXRlVmlldyhpbnRlcm5hbEFQSSk7XG5cbiAgICAgICAgLy8gZXhwb3NlIHB1YmxpYyBhcGlcbiAgICAgICAgcmV0dXJuIGNyZWF0ZU9iamVjdChleHRlcm5hbEFQSURlZmluaXRpb24pO1xuICAgICAgfTtcbiAgICB9O1xuXG4gIHZhciBjcmVhdGVQYWludGVyID0gZnVuY3Rpb24gY3JlYXRlUGFpbnRlcihyZWFkLCB3cml0ZSkge1xuICAgIHZhciBmcHMgPVxuICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiA2MDtcblxuICAgIHZhciBuYW1lID0gJ19fZnJhbWVQYWludGVyJztcblxuICAgIC8vIHNldCBnbG9iYWwgcGFpbnRlclxuICAgIGlmICh3aW5kb3dbbmFtZV0pIHtcbiAgICAgIHdpbmRvd1tuYW1lXS5yZWFkZXJzLnB1c2gocmVhZCk7XG4gICAgICB3aW5kb3dbbmFtZV0ud3JpdGVycy5wdXNoKHdyaXRlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3aW5kb3dbbmFtZV0gPSB7XG4gICAgICByZWFkZXJzOiBbcmVhZF0sXG4gICAgICB3cml0ZXJzOiBbd3JpdGVdXG4gICAgfTtcblxuICAgIHZhciBwYWludGVyID0gd2luZG93W25hbWVdO1xuXG4gICAgdmFyIGludGVydmFsID0gMTAwMCAvIGZwcztcbiAgICB2YXIgbGFzdCA9IG51bGw7XG4gICAgdmFyIGlkID0gbnVsbDtcbiAgICB2YXIgcmVxdWVzdFRpY2sgPSBudWxsO1xuICAgIHZhciBjYW5jZWxUaWNrID0gbnVsbDtcblxuICAgIHZhciBzZXRUaW1lclR5cGUgPSBmdW5jdGlvbiBzZXRUaW1lclR5cGUoKSB7XG4gICAgICBpZiAoZG9jdW1lbnQuaGlkZGVuKSB7XG4gICAgICAgIHJlcXVlc3RUaWNrID0gZnVuY3Rpb24gcmVxdWVzdFRpY2soKSB7XG4gICAgICAgICAgcmV0dXJuIHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRpY2socGVyZm9ybWFuY2Uubm93KCkpO1xuICAgICAgICAgIH0sIGludGVydmFsKTtcbiAgICAgICAgfTtcbiAgICAgICAgY2FuY2VsVGljayA9IGZ1bmN0aW9uIGNhbmNlbFRpY2soKSB7XG4gICAgICAgICAgcmV0dXJuIHdpbmRvdy5jbGVhclRpbWVvdXQoaWQpO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVxdWVzdFRpY2sgPSBmdW5jdGlvbiByZXF1ZXN0VGljaygpIHtcbiAgICAgICAgICByZXR1cm4gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSh0aWNrKTtcbiAgICAgICAgfTtcbiAgICAgICAgY2FuY2VsVGljayA9IGZ1bmN0aW9uIGNhbmNlbFRpY2soKSB7XG4gICAgICAgICAgcmV0dXJuIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZShpZCk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcblxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Zpc2liaWxpdHljaGFuZ2UnLCBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChjYW5jZWxUaWNrKSBjYW5jZWxUaWNrKCk7XG4gICAgICBzZXRUaW1lclR5cGUoKTtcbiAgICAgIHRpY2socGVyZm9ybWFuY2Uubm93KCkpO1xuICAgIH0pO1xuXG4gICAgdmFyIHRpY2sgPSBmdW5jdGlvbiB0aWNrKHRzKSB7XG4gICAgICAvLyBxdWV1ZSBuZXh0IHRpY2tcbiAgICAgIGlkID0gcmVxdWVzdFRpY2sodGljayk7XG5cbiAgICAgIC8vIGxpbWl0IGZwc1xuICAgICAgaWYgKCFsYXN0KSB7XG4gICAgICAgIGxhc3QgPSB0cztcbiAgICAgIH1cblxuICAgICAgdmFyIGRlbHRhID0gdHMgLSBsYXN0O1xuXG4gICAgICBpZiAoZGVsdGEgPD0gaW50ZXJ2YWwpIHtcbiAgICAgICAgLy8gc2tpcCBmcmFtZVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIGFsaWduIG5leHQgZnJhbWVcbiAgICAgIGxhc3QgPSB0cyAtIChkZWx0YSAlIGludGVydmFsKTtcblxuICAgICAgLy8gdXBkYXRlIHZpZXdcbiAgICAgIHBhaW50ZXIucmVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKHJlYWQpIHtcbiAgICAgICAgcmV0dXJuIHJlYWQoKTtcbiAgICAgIH0pO1xuICAgICAgcGFpbnRlci53cml0ZXJzLmZvckVhY2goZnVuY3Rpb24od3JpdGUpIHtcbiAgICAgICAgcmV0dXJuIHdyaXRlKHRzKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBzZXRUaW1lclR5cGUoKTtcbiAgICB0aWNrKHBlcmZvcm1hbmNlLm5vdygpKTtcblxuICAgIHJldHVybiB7XG4gICAgICBwYXVzZTogZnVuY3Rpb24gcGF1c2UoKSB7XG4gICAgICAgIGNhbmNlbFRpY2soaWQpO1xuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgdmFyIGNyZWF0ZVJvdXRlID0gZnVuY3Rpb24gY3JlYXRlUm91dGUocm91dGVzLCBmbikge1xuICAgIHJldHVybiBmdW5jdGlvbihfcmVmKSB7XG4gICAgICB2YXIgcm9vdCA9IF9yZWYucm9vdCxcbiAgICAgICAgcHJvcHMgPSBfcmVmLnByb3BzLFxuICAgICAgICBfcmVmJGFjdGlvbnMgPSBfcmVmLmFjdGlvbnMsXG4gICAgICAgIGFjdGlvbnMgPSBfcmVmJGFjdGlvbnMgPT09IHZvaWQgMCA/IFtdIDogX3JlZiRhY3Rpb25zLFxuICAgICAgICB0aW1lc3RhbXAgPSBfcmVmLnRpbWVzdGFtcCxcbiAgICAgICAgc2hvdWxkT3B0aW1pemUgPSBfcmVmLnNob3VsZE9wdGltaXplO1xuICAgICAgYWN0aW9uc1xuICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKGFjdGlvbikge1xuICAgICAgICAgIHJldHVybiByb3V0ZXNbYWN0aW9uLnR5cGVdO1xuICAgICAgICB9KVxuICAgICAgICAuZm9yRWFjaChmdW5jdGlvbihhY3Rpb24pIHtcbiAgICAgICAgICByZXR1cm4gcm91dGVzW2FjdGlvbi50eXBlXSh7XG4gICAgICAgICAgICByb290OiByb290LFxuICAgICAgICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgICAgICAgYWN0aW9uOiBhY3Rpb24uZGF0YSxcbiAgICAgICAgICAgIHRpbWVzdGFtcDogdGltZXN0YW1wLFxuICAgICAgICAgICAgc2hvdWxkT3B0aW1pemU6IHNob3VsZE9wdGltaXplXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICBpZiAoZm4pIHtcbiAgICAgICAgZm4oe1xuICAgICAgICAgIHJvb3Q6IHJvb3QsXG4gICAgICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgICAgIGFjdGlvbnM6IGFjdGlvbnMsXG4gICAgICAgICAgdGltZXN0YW1wOiB0aW1lc3RhbXAsXG4gICAgICAgICAgc2hvdWxkT3B0aW1pemU6IHNob3VsZE9wdGltaXplXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgdmFyIGluc2VydEJlZm9yZSA9IGZ1bmN0aW9uIGluc2VydEJlZm9yZShuZXdOb2RlLCByZWZlcmVuY2VOb2RlKSB7XG4gICAgcmV0dXJuIHJlZmVyZW5jZU5vZGUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobmV3Tm9kZSwgcmVmZXJlbmNlTm9kZSk7XG4gIH07XG5cbiAgdmFyIGluc2VydEFmdGVyID0gZnVuY3Rpb24gaW5zZXJ0QWZ0ZXIobmV3Tm9kZSwgcmVmZXJlbmNlTm9kZSkge1xuICAgIHJldHVybiByZWZlcmVuY2VOb2RlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKFxuICAgICAgbmV3Tm9kZSxcbiAgICAgIHJlZmVyZW5jZU5vZGUubmV4dFNpYmxpbmdcbiAgICApO1xuICB9O1xuXG4gIHZhciBpc0FycmF5ID0gZnVuY3Rpb24gaXNBcnJheSh2YWx1ZSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKTtcbiAgfTtcblxuICB2YXIgaXNFbXB0eSA9IGZ1bmN0aW9uIGlzRW1wdHkodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT0gbnVsbDtcbiAgfTtcblxuICB2YXIgdHJpbSA9IGZ1bmN0aW9uIHRyaW0oc3RyKSB7XG4gICAgcmV0dXJuIHN0ci50cmltKCk7XG4gIH07XG5cbiAgdmFyIHRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcodmFsdWUpIHtcbiAgICByZXR1cm4gJycgKyB2YWx1ZTtcbiAgfTtcblxuICB2YXIgdG9BcnJheSA9IGZ1bmN0aW9uIHRvQXJyYXkodmFsdWUpIHtcbiAgICB2YXIgc3BsaXR0ZXIgPVxuICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAnLCc7XG4gICAgaWYgKGlzRW1wdHkodmFsdWUpKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gdG9TdHJpbmcodmFsdWUpXG4gICAgICAuc3BsaXQoc3BsaXR0ZXIpXG4gICAgICAubWFwKHRyaW0pXG4gICAgICAuZmlsdGVyKGZ1bmN0aW9uKHN0cikge1xuICAgICAgICByZXR1cm4gc3RyLmxlbmd0aDtcbiAgICAgIH0pO1xuICB9O1xuXG4gIHZhciBpc0Jvb2xlYW4gPSBmdW5jdGlvbiBpc0Jvb2xlYW4odmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbic7XG4gIH07XG5cbiAgdmFyIHRvQm9vbGVhbiA9IGZ1bmN0aW9uIHRvQm9vbGVhbih2YWx1ZSkge1xuICAgIHJldHVybiBpc0Jvb2xlYW4odmFsdWUpID8gdmFsdWUgOiB2YWx1ZSA9PT0gJ3RydWUnO1xuICB9O1xuXG4gIHZhciBpc1N0cmluZyA9IGZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZyc7XG4gIH07XG5cbiAgdmFyIHRvTnVtYmVyID0gZnVuY3Rpb24gdG9OdW1iZXIodmFsdWUpIHtcbiAgICByZXR1cm4gaXNOdW1iZXIodmFsdWUpXG4gICAgICA/IHZhbHVlXG4gICAgICA6IGlzU3RyaW5nKHZhbHVlKVxuICAgICAgPyB0b1N0cmluZyh2YWx1ZSkucmVwbGFjZSgvW2Etel0rL2dpLCAnJylcbiAgICAgIDogMDtcbiAgfTtcblxuICB2YXIgdG9JbnQgPSBmdW5jdGlvbiB0b0ludCh2YWx1ZSkge1xuICAgIHJldHVybiBwYXJzZUludCh0b051bWJlcih2YWx1ZSksIDEwKTtcbiAgfTtcblxuICB2YXIgdG9GbG9hdCA9IGZ1bmN0aW9uIHRvRmxvYXQodmFsdWUpIHtcbiAgICByZXR1cm4gcGFyc2VGbG9hdCh0b051bWJlcih2YWx1ZSkpO1xuICB9O1xuXG4gIHZhciBpc0ludCA9IGZ1bmN0aW9uIGlzSW50KHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzTnVtYmVyKHZhbHVlKSAmJiBpc0Zpbml0ZSh2YWx1ZSkgJiYgTWF0aC5mbG9vcih2YWx1ZSkgPT09IHZhbHVlO1xuICB9O1xuXG4gIHZhciB0b0J5dGVzID0gZnVuY3Rpb24gdG9CeXRlcyh2YWx1ZSkge1xuICAgIHZhciBiYXNlID1cbiAgICAgIGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMTAwMDtcbiAgICAvLyBpcyBpbiBieXRlc1xuICAgIGlmIChpc0ludCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvLyBpcyBuYXR1cmFsIGZpbGUgc2l6ZVxuICAgIHZhciBuYXR1cmFsRmlsZVNpemUgPSB0b1N0cmluZyh2YWx1ZSkudHJpbSgpO1xuXG4gICAgLy8gaWYgaXMgdmFsdWUgaW4gbWVnYWJ5dGVzXG4gICAgaWYgKC9NQiQvaS50ZXN0KG5hdHVyYWxGaWxlU2l6ZSkpIHtcbiAgICAgIG5hdHVyYWxGaWxlU2l6ZSA9IG5hdHVyYWxGaWxlU2l6ZS5yZXBsYWNlKC9NQiRpLywgJycpLnRyaW0oKTtcbiAgICAgIHJldHVybiB0b0ludChuYXR1cmFsRmlsZVNpemUpICogYmFzZSAqIGJhc2U7XG4gICAgfVxuXG4gICAgLy8gaWYgaXMgdmFsdWUgaW4ga2lsb2J5dGVzXG4gICAgaWYgKC9LQi9pLnRlc3QobmF0dXJhbEZpbGVTaXplKSkge1xuICAgICAgbmF0dXJhbEZpbGVTaXplID0gbmF0dXJhbEZpbGVTaXplLnJlcGxhY2UoL0tCJGkvLCAnJykudHJpbSgpO1xuICAgICAgcmV0dXJuIHRvSW50KG5hdHVyYWxGaWxlU2l6ZSkgKiBiYXNlO1xuICAgIH1cblxuICAgIHJldHVybiB0b0ludChuYXR1cmFsRmlsZVNpemUpO1xuICB9O1xuXG4gIHZhciBpc0Z1bmN0aW9uID0gZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbic7XG4gIH07XG5cbiAgdmFyIHRvRnVuY3Rpb25SZWZlcmVuY2UgPSBmdW5jdGlvbiB0b0Z1bmN0aW9uUmVmZXJlbmNlKHN0cmluZykge1xuICAgIHZhciByZWYgPSBzZWxmO1xuICAgIHZhciBsZXZlbHMgPSBzdHJpbmcuc3BsaXQoJy4nKTtcbiAgICB2YXIgbGV2ZWwgPSBudWxsO1xuICAgIHdoaWxlICgobGV2ZWwgPSBsZXZlbHMuc2hpZnQoKSkpIHtcbiAgICAgIHJlZiA9IHJlZltsZXZlbF07XG4gICAgICBpZiAoIXJlZikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlZjtcbiAgfTtcblxuICB2YXIgbWV0aG9kcyA9IHtcbiAgICBwcm9jZXNzOiAnUE9TVCcsXG4gICAgcGF0Y2g6ICdQQVRDSCcsXG4gICAgcmV2ZXJ0OiAnREVMRVRFJyxcbiAgICBmZXRjaDogJ0dFVCcsXG4gICAgcmVzdG9yZTogJ0dFVCcsXG4gICAgbG9hZDogJ0dFVCdcbiAgfTtcblxuICB2YXIgY3JlYXRlU2VydmVyQVBJID0gZnVuY3Rpb24gY3JlYXRlU2VydmVyQVBJKG91dGxpbmUpIHtcbiAgICB2YXIgYXBpID0ge307XG5cbiAgICBhcGkudXJsID0gaXNTdHJpbmcob3V0bGluZSkgPyBvdXRsaW5lIDogb3V0bGluZS51cmwgfHwgJyc7XG4gICAgYXBpLnRpbWVvdXQgPSBvdXRsaW5lLnRpbWVvdXQgPyBwYXJzZUludChvdXRsaW5lLnRpbWVvdXQsIDEwKSA6IDA7XG4gICAgYXBpLmhlYWRlcnMgPSBvdXRsaW5lLmhlYWRlcnMgPyBvdXRsaW5lLmhlYWRlcnMgOiB7fTtcblxuICAgIGZvcmluKG1ldGhvZHMsIGZ1bmN0aW9uKGtleSkge1xuICAgICAgYXBpW2tleV0gPSBjcmVhdGVBY3Rpb24oXG4gICAgICAgIGtleSxcbiAgICAgICAgb3V0bGluZVtrZXldLFxuICAgICAgICBtZXRob2RzW2tleV0sXG4gICAgICAgIGFwaS50aW1lb3V0LFxuICAgICAgICBhcGkuaGVhZGVyc1xuICAgICAgKTtcbiAgICB9KTtcblxuICAgIC8vIHNwZWNpYWwgdHJlYXRtZW50IGZvciByZW1vdmVcbiAgICBhcGkucmVtb3ZlID0gb3V0bGluZS5yZW1vdmUgfHwgbnVsbDtcblxuICAgIC8vIHJlbW92ZSBnZW5lcmljIGhlYWRlcnMgZnJvbSBhcGkgb2JqZWN0XG4gICAgZGVsZXRlIGFwaS5oZWFkZXJzO1xuXG4gICAgcmV0dXJuIGFwaTtcbiAgfTtcblxuICB2YXIgY3JlYXRlQWN0aW9uID0gZnVuY3Rpb24gY3JlYXRlQWN0aW9uKFxuICAgIG5hbWUsXG4gICAgb3V0bGluZSxcbiAgICBtZXRob2QsXG4gICAgdGltZW91dCxcbiAgICBoZWFkZXJzXG4gICkge1xuICAgIC8vIGlzIGV4cGxpY2l0ZWx5IHNldCB0byBudWxsIHNvIGRpc2FibGVcbiAgICBpZiAob3V0bGluZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gaWYgaXMgY3VzdG9tIGZ1bmN0aW9uLCBkb25lISBEZXYgaGFuZGxlcyBldmVyeXRoaW5nLlxuICAgIGlmICh0eXBlb2Ygb3V0bGluZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIG91dGxpbmU7XG4gICAgfVxuXG4gICAgLy8gYnVpbGQgYWN0aW9uIG9iamVjdFxuICAgIHZhciBhY3Rpb24gPSB7XG4gICAgICB1cmw6IG1ldGhvZCA9PT0gJ0dFVCcgfHwgbWV0aG9kID09PSAnUEFUQ0gnID8gJz8nICsgbmFtZSArICc9JyA6ICcnLFxuICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICBoZWFkZXJzOiBoZWFkZXJzLFxuICAgICAgd2l0aENyZWRlbnRpYWxzOiBmYWxzZSxcbiAgICAgIHRpbWVvdXQ6IHRpbWVvdXQsXG4gICAgICBvbmxvYWQ6IG51bGwsXG4gICAgICBvbmRhdGE6IG51bGwsXG4gICAgICBvbmVycm9yOiBudWxsXG4gICAgfTtcblxuICAgIC8vIGlzIGEgc2luZ2xlIHVybFxuICAgIGlmIChpc1N0cmluZyhvdXRsaW5lKSkge1xuICAgICAgYWN0aW9uLnVybCA9IG91dGxpbmU7XG4gICAgICByZXR1cm4gYWN0aW9uO1xuICAgIH1cblxuICAgIC8vIG92ZXJ3cml0ZVxuICAgIE9iamVjdC5hc3NpZ24oYWN0aW9uLCBvdXRsaW5lKTtcblxuICAgIC8vIHNlZSBpZiBzaG91bGQgcmVmb3JtYXQgaGVhZGVycztcbiAgICBpZiAoaXNTdHJpbmcoYWN0aW9uLmhlYWRlcnMpKSB7XG4gICAgICB2YXIgcGFydHMgPSBhY3Rpb24uaGVhZGVycy5zcGxpdCgvOiguKykvKTtcbiAgICAgIGFjdGlvbi5oZWFkZXJzID0ge1xuICAgICAgICBoZWFkZXI6IHBhcnRzWzBdLFxuICAgICAgICB2YWx1ZTogcGFydHNbMV1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gaWYgaXMgYm9vbCB3aXRoQ3JlZGVudGlhbHNcbiAgICBhY3Rpb24ud2l0aENyZWRlbnRpYWxzID0gdG9Cb29sZWFuKGFjdGlvbi53aXRoQ3JlZGVudGlhbHMpO1xuXG4gICAgcmV0dXJuIGFjdGlvbjtcbiAgfTtcblxuICB2YXIgdG9TZXJ2ZXJBUEkgPSBmdW5jdGlvbiB0b1NlcnZlckFQSSh2YWx1ZSkge1xuICAgIHJldHVybiBjcmVhdGVTZXJ2ZXJBUEkodmFsdWUpO1xuICB9O1xuXG4gIHZhciBpc051bGwgPSBmdW5jdGlvbiBpc051bGwodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IG51bGw7XG4gIH07XG5cbiAgdmFyIGlzT2JqZWN0ID0gZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbDtcbiAgfTtcblxuICB2YXIgaXNBUEkgPSBmdW5jdGlvbiBpc0FQSSh2YWx1ZSkge1xuICAgIHJldHVybiAoXG4gICAgICBpc09iamVjdCh2YWx1ZSkgJiZcbiAgICAgIGlzU3RyaW5nKHZhbHVlLnVybCkgJiZcbiAgICAgIGlzT2JqZWN0KHZhbHVlLnByb2Nlc3MpICYmXG4gICAgICBpc09iamVjdCh2YWx1ZS5yZXZlcnQpICYmXG4gICAgICBpc09iamVjdCh2YWx1ZS5yZXN0b3JlKSAmJlxuICAgICAgaXNPYmplY3QodmFsdWUuZmV0Y2gpXG4gICAgKTtcbiAgfTtcblxuICB2YXIgZ2V0VHlwZSA9IGZ1bmN0aW9uIGdldFR5cGUodmFsdWUpIHtcbiAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiAnYXJyYXknO1xuICAgIH1cblxuICAgIGlmIChpc051bGwodmFsdWUpKSB7XG4gICAgICByZXR1cm4gJ251bGwnO1xuICAgIH1cblxuICAgIGlmIChpc0ludCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiAnaW50JztcbiAgICB9XG5cbiAgICBpZiAoL15bMC05XSsgPyg/OkdCfE1CfEtCKSQvZ2kudGVzdCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiAnYnl0ZXMnO1xuICAgIH1cblxuICAgIGlmIChpc0FQSSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiAnYXBpJztcbiAgICB9XG5cbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlO1xuICB9O1xuXG4gIHZhciByZXBsYWNlU2luZ2xlUXVvdGVzID0gZnVuY3Rpb24gcmVwbGFjZVNpbmdsZVF1b3RlcyhzdHIpIHtcbiAgICByZXR1cm4gc3RyXG4gICAgICAucmVwbGFjZSgve1xccyonL2csICd7XCInKVxuICAgICAgLnJlcGxhY2UoLydcXHMqfS9nLCAnXCJ9JylcbiAgICAgIC5yZXBsYWNlKC8nXFxzKjovZywgJ1wiOicpXG4gICAgICAucmVwbGFjZSgvOlxccyonL2csICc6XCInKVxuICAgICAgLnJlcGxhY2UoLyxcXHMqJy9nLCAnLFwiJylcbiAgICAgIC5yZXBsYWNlKC8nXFxzKiwvZywgJ1wiLCcpO1xuICB9O1xuXG4gIHZhciBjb252ZXJzaW9uVGFibGUgPSB7XG4gICAgYXJyYXk6IHRvQXJyYXksXG4gICAgYm9vbGVhbjogdG9Cb29sZWFuLFxuICAgIGludDogZnVuY3Rpb24gaW50KHZhbHVlKSB7XG4gICAgICByZXR1cm4gZ2V0VHlwZSh2YWx1ZSkgPT09ICdieXRlcycgPyB0b0J5dGVzKHZhbHVlKSA6IHRvSW50KHZhbHVlKTtcbiAgICB9LFxuICAgIG51bWJlcjogdG9GbG9hdCxcbiAgICBmbG9hdDogdG9GbG9hdCxcbiAgICBieXRlczogdG9CeXRlcyxcbiAgICBzdHJpbmc6IGZ1bmN0aW9uIHN0cmluZyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzRnVuY3Rpb24odmFsdWUpID8gdmFsdWUgOiB0b1N0cmluZyh2YWx1ZSk7XG4gICAgfSxcbiAgICBmdW5jdGlvbjogZnVuY3Rpb24gX2Z1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdG9GdW5jdGlvblJlZmVyZW5jZSh2YWx1ZSk7XG4gICAgfSxcbiAgICBzZXJ2ZXJhcGk6IHRvU2VydmVyQVBJLFxuICAgIG9iamVjdDogZnVuY3Rpb24gb2JqZWN0KHZhbHVlKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShyZXBsYWNlU2luZ2xlUXVvdGVzKHZhbHVlKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgY29udmVydFRvID0gZnVuY3Rpb24gY29udmVydFRvKHZhbHVlLCB0eXBlKSB7XG4gICAgcmV0dXJuIGNvbnZlcnNpb25UYWJsZVt0eXBlXSh2YWx1ZSk7XG4gIH07XG5cbiAgdmFyIGdldFZhbHVlQnlUeXBlID0gZnVuY3Rpb24gZ2V0VmFsdWVCeVR5cGUoXG4gICAgbmV3VmFsdWUsXG4gICAgZGVmYXVsdFZhbHVlLFxuICAgIHZhbHVlVHlwZVxuICApIHtcbiAgICAvLyBjYW4gYWx3YXlzIGFzc2lnbiBkZWZhdWx0IHZhbHVlXG4gICAgaWYgKG5ld1ZhbHVlID09PSBkZWZhdWx0VmFsdWUpIHtcbiAgICAgIHJldHVybiBuZXdWYWx1ZTtcbiAgICB9XG5cbiAgICAvLyBnZXQgdGhlIHR5cGUgb2YgdGhlIG5ldyB2YWx1ZVxuICAgIHZhciBuZXdWYWx1ZVR5cGUgPSBnZXRUeXBlKG5ld1ZhbHVlKTtcblxuICAgIC8vIGlzIHZhbGlkIHR5cGU/XG4gICAgaWYgKG5ld1ZhbHVlVHlwZSAhPT0gdmFsdWVUeXBlKSB7XG4gICAgICAvLyBpcyBzdHJpbmcgaW5wdXQsIGxldCdzIGF0dGVtcHQgdG8gY29udmVydFxuICAgICAgdmFyIGNvbnZlcnRlZFZhbHVlID0gY29udmVydFRvKG5ld1ZhbHVlLCB2YWx1ZVR5cGUpO1xuXG4gICAgICAvLyB3aGF0IGlzIHRoZSB0eXBlIG5vd1xuICAgICAgbmV3VmFsdWVUeXBlID0gZ2V0VHlwZShjb252ZXJ0ZWRWYWx1ZSk7XG5cbiAgICAgIC8vIG5vIHZhbGlkIGNvbnZlcnNpb25zIGZvdW5kXG4gICAgICBpZiAoY29udmVydGVkVmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgJ1RyeWluZyB0byBhc3NpZ24gdmFsdWUgd2l0aCBpbmNvcnJlY3QgdHlwZSB0byBcIicgK1xuICAgICAgICAgIG9wdGlvbiArXG4gICAgICAgICAgJ1wiLCBhbGxvd2VkIHR5cGU6IFwiJyArXG4gICAgICAgICAgdmFsdWVUeXBlICtcbiAgICAgICAgICAnXCInO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3VmFsdWUgPSBjb252ZXJ0ZWRWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhc3NpZ24gbmV3IHZhbHVlXG4gICAgcmV0dXJuIG5ld1ZhbHVlO1xuICB9O1xuXG4gIHZhciBjcmVhdGVPcHRpb24gPSBmdW5jdGlvbiBjcmVhdGVPcHRpb24oZGVmYXVsdFZhbHVlLCB2YWx1ZVR5cGUpIHtcbiAgICB2YXIgY3VycmVudFZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICAgIHJldHVybiB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBjdXJyZW50VmFsdWU7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQobmV3VmFsdWUpIHtcbiAgICAgICAgY3VycmVudFZhbHVlID0gZ2V0VmFsdWVCeVR5cGUobmV3VmFsdWUsIGRlZmF1bHRWYWx1ZSwgdmFsdWVUeXBlKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIHZhciBjcmVhdGVPcHRpb25zID0gZnVuY3Rpb24gY3JlYXRlT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgdmFyIG9iaiA9IHt9O1xuICAgIGZvcmluKG9wdGlvbnMsIGZ1bmN0aW9uKHByb3ApIHtcbiAgICAgIHZhciBvcHRpb25EZWZpbml0aW9uID0gb3B0aW9uc1twcm9wXTtcbiAgICAgIG9ialtwcm9wXSA9IGNyZWF0ZU9wdGlvbihvcHRpb25EZWZpbml0aW9uWzBdLCBvcHRpb25EZWZpbml0aW9uWzFdKTtcbiAgICB9KTtcbiAgICByZXR1cm4gY3JlYXRlT2JqZWN0KG9iaik7XG4gIH07XG5cbiAgdmFyIGNyZWF0ZUluaXRpYWxTdGF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZUluaXRpYWxTdGF0ZShvcHRpb25zKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC8vIG1vZGVsXG4gICAgICBpdGVtczogW10sXG5cbiAgICAgIC8vIHRpbWVvdXQgdXNlZCBmb3IgY2FsbGluZyB1cGRhdGUgaXRlbXNcbiAgICAgIGxpc3RVcGRhdGVUaW1lb3V0OiBudWxsLFxuXG4gICAgICAvLyB0aW1lb3V0IHVzZWQgZm9yIHN0YWNraW5nIG1ldGFkYXRhIHVwZGF0ZXNcbiAgICAgIGl0ZW1VcGRhdGVUaW1lb3V0OiBudWxsLFxuXG4gICAgICAvLyBxdWV1ZSBvZiBpdGVtcyB3YWl0aW5nIHRvIGJlIHByb2Nlc3NlZFxuICAgICAgcHJvY2Vzc2luZ1F1ZXVlOiBbXSxcblxuICAgICAgLy8gb3B0aW9uc1xuICAgICAgb3B0aW9uczogY3JlYXRlT3B0aW9ucyhvcHRpb25zKVxuICAgIH07XG4gIH07XG5cbiAgdmFyIGZyb21DYW1lbHMgPSBmdW5jdGlvbiBmcm9tQ2FtZWxzKHN0cmluZykge1xuICAgIHZhciBzZXBhcmF0b3IgPVxuICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAnLSc7XG4gICAgcmV0dXJuIHN0cmluZ1xuICAgICAgLnNwbGl0KC8oPz1bQS1aXSkvKVxuICAgICAgLm1hcChmdW5jdGlvbihwYXJ0KSB7XG4gICAgICAgIHJldHVybiBwYXJ0LnRvTG93ZXJDYXNlKCk7XG4gICAgICB9KVxuICAgICAgLmpvaW4oc2VwYXJhdG9yKTtcbiAgfTtcblxuICB2YXIgY3JlYXRlT3B0aW9uQVBJID0gZnVuY3Rpb24gY3JlYXRlT3B0aW9uQVBJKHN0b3JlLCBvcHRpb25zKSB7XG4gICAgdmFyIG9iaiA9IHt9O1xuICAgIGZvcmluKG9wdGlvbnMsIGZ1bmN0aW9uKGtleSkge1xuICAgICAgb2JqW2tleV0gPSB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHJldHVybiBzdG9yZS5nZXRTdGF0ZSgpLm9wdGlvbnNba2V5XTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgICBzdG9yZS5kaXNwYXRjaCgnU0VUXycgKyBmcm9tQ2FtZWxzKGtleSwgJ18nKS50b1VwcGVyQ2FzZSgpLCB7XG4gICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gb2JqO1xuICB9O1xuXG4gIHZhciBjcmVhdGVPcHRpb25BY3Rpb25zID0gZnVuY3Rpb24gY3JlYXRlT3B0aW9uQWN0aW9ucyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGRpc3BhdGNoLCBxdWVyeSwgc3RhdGUpIHtcbiAgICAgIHZhciBvYmogPSB7fTtcbiAgICAgIGZvcmluKG9wdGlvbnMsIGZ1bmN0aW9uKGtleSkge1xuICAgICAgICB2YXIgbmFtZSA9IGZyb21DYW1lbHMoa2V5LCAnXycpLnRvVXBwZXJDYXNlKCk7XG5cbiAgICAgICAgb2JqWydTRVRfJyArIG5hbWVdID0gZnVuY3Rpb24oYWN0aW9uKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHN0YXRlLm9wdGlvbnNba2V5XSA9IGFjdGlvbi52YWx1ZTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7fSAvLyBub3BlLCBmYWlsZWRcblxuICAgICAgICAgIC8vIHdlIHN1Y2Nlc3NmdWxseSBzZXQgdGhlIHZhbHVlIG9mIHRoaXMgb3B0aW9uXG4gICAgICAgICAgZGlzcGF0Y2goJ0RJRF9TRVRfJyArIG5hbWUsIHsgdmFsdWU6IHN0YXRlLm9wdGlvbnNba2V5XSB9KTtcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBjcmVhdGVPcHRpb25RdWVyaWVzID0gZnVuY3Rpb24gY3JlYXRlT3B0aW9uUXVlcmllcyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgICB2YXIgb2JqID0ge307XG4gICAgICBmb3JpbihvcHRpb25zLCBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgb2JqWydHRVRfJyArIGZyb21DYW1lbHMoa2V5LCAnXycpLnRvVXBwZXJDYXNlKCldID0gZnVuY3Rpb24oYWN0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIHN0YXRlLm9wdGlvbnNba2V5XTtcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBJbnRlcmFjdGlvbk1ldGhvZCA9IHtcbiAgICBBUEk6IDEsXG4gICAgRFJPUDogMixcbiAgICBCUk9XU0U6IDMsXG4gICAgUEFTVEU6IDQsXG4gICAgTk9ORTogNVxuICB9O1xuXG4gIHZhciBnZXRVbmlxdWVJZCA9IGZ1bmN0aW9uIGdldFVuaXF1ZUlkKCkge1xuICAgIHJldHVybiBNYXRoLnJhbmRvbSgpXG4gICAgICAudG9TdHJpbmcoMzYpXG4gICAgICAuc3Vic3RyKDIsIDkpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgIF90eXBlb2YgPSBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBfdHlwZW9mID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogJiZcbiAgICAgICAgICB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICAgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiZcbiAgICAgICAgICBvYmogIT09IFN5bWJvbC5wcm90b3R5cGVcbiAgICAgICAgICA/ICdzeW1ib2wnXG4gICAgICAgICAgOiB0eXBlb2Ygb2JqO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3R5cGVvZihvYmopO1xuICB9XG5cbiAgdmFyIFJFQUNUX0VMRU1FTlRfVFlQRTtcblxuICBmdW5jdGlvbiBfanN4KHR5cGUsIHByb3BzLCBrZXksIGNoaWxkcmVuKSB7XG4gICAgaWYgKCFSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgIFJFQUNUX0VMRU1FTlRfVFlQRSA9XG4gICAgICAgICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICAgU3ltYm9sWydmb3InXSAmJlxuICAgICAgICAgIFN5bWJvbFsnZm9yJ10oJ3JlYWN0LmVsZW1lbnQnKSkgfHxcbiAgICAgICAgMHhlYWM3O1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0UHJvcHMgPSB0eXBlICYmIHR5cGUuZGVmYXVsdFByb3BzO1xuICAgIHZhciBjaGlsZHJlbkxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggLSAzO1xuXG4gICAgaWYgKCFwcm9wcyAmJiBjaGlsZHJlbkxlbmd0aCAhPT0gMCkge1xuICAgICAgcHJvcHMgPSB7XG4gICAgICAgIGNoaWxkcmVuOiB2b2lkIDBcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKHByb3BzICYmIGRlZmF1bHRQcm9wcykge1xuICAgICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gZGVmYXVsdFByb3BzKSB7XG4gICAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IHZvaWQgMCkge1xuICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFwcm9wcykge1xuICAgICAgcHJvcHMgPSBkZWZhdWx0UHJvcHMgfHwge307XG4gICAgfVxuXG4gICAgaWYgKGNoaWxkcmVuTGVuZ3RoID09PSAxKSB7XG4gICAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgIH0gZWxzZSBpZiAoY2hpbGRyZW5MZW5ndGggPiAxKSB7XG4gICAgICB2YXIgY2hpbGRBcnJheSA9IG5ldyBBcnJheShjaGlsZHJlbkxlbmd0aCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW5MZW5ndGg7IGkrKykge1xuICAgICAgICBjaGlsZEFycmF5W2ldID0gYXJndW1lbnRzW2kgKyAzXTtcbiAgICAgIH1cblxuICAgICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZEFycmF5O1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAkJHR5cGVvZjogUkVBQ1RfRUxFTUVOVF9UWVBFLFxuICAgICAgdHlwZTogdHlwZSxcbiAgICAgIGtleToga2V5ID09PSB1bmRlZmluZWQgPyBudWxsIDogJycgKyBrZXksXG4gICAgICByZWY6IG51bGwsXG4gICAgICBwcm9wczogcHJvcHMsXG4gICAgICBfb3duZXI6IG51bGxcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gX2FzeW5jSXRlcmF0b3IoaXRlcmFibGUpIHtcbiAgICB2YXIgbWV0aG9kO1xuXG4gICAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBpZiAoU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHtcbiAgICAgICAgbWV0aG9kID0gaXRlcmFibGVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdO1xuICAgICAgICBpZiAobWV0aG9kICE9IG51bGwpIHJldHVybiBtZXRob2QuY2FsbChpdGVyYWJsZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChTeW1ib2wuaXRlcmF0b3IpIHtcbiAgICAgICAgbWV0aG9kID0gaXRlcmFibGVbU3ltYm9sLml0ZXJhdG9yXTtcbiAgICAgICAgaWYgKG1ldGhvZCAhPSBudWxsKSByZXR1cm4gbWV0aG9kLmNhbGwoaXRlcmFibGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdCBpcyBub3QgYXN5bmMgaXRlcmFibGUnKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9Bd2FpdFZhbHVlKHZhbHVlKSB7XG4gICAgdGhpcy53cmFwcGVkID0gdmFsdWU7XG4gIH1cblxuICBmdW5jdGlvbiBfQXN5bmNHZW5lcmF0b3IoZ2VuKSB7XG4gICAgdmFyIGZyb250LCBiYWNrO1xuXG4gICAgZnVuY3Rpb24gc2VuZChrZXksIGFyZykge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB2YXIgcmVxdWVzdCA9IHtcbiAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICBhcmc6IGFyZyxcbiAgICAgICAgICByZXNvbHZlOiByZXNvbHZlLFxuICAgICAgICAgIHJlamVjdDogcmVqZWN0LFxuICAgICAgICAgIG5leHQ6IG51bGxcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoYmFjaykge1xuICAgICAgICAgIGJhY2sgPSBiYWNrLm5leHQgPSByZXF1ZXN0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZyb250ID0gYmFjayA9IHJlcXVlc3Q7XG4gICAgICAgICAgcmVzdW1lKGtleSwgYXJnKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVzdW1lKGtleSwgYXJnKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gZ2VuW2tleV0oYXJnKTtcbiAgICAgICAgdmFyIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICB2YXIgd3JhcHBlZEF3YWl0ID0gdmFsdWUgaW5zdGFuY2VvZiBfQXdhaXRWYWx1ZTtcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKHdyYXBwZWRBd2FpdCA/IHZhbHVlLndyYXBwZWQgOiB2YWx1ZSkudGhlbihcbiAgICAgICAgICBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgICAgIGlmICh3cmFwcGVkQXdhaXQpIHtcbiAgICAgICAgICAgICAgcmVzdW1lKCduZXh0JywgYXJnKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZXR0bGUocmVzdWx0LmRvbmUgPyAncmV0dXJuJyA6ICdub3JtYWwnLCBhcmcpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICByZXN1bWUoJ3Rocm93JywgZXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgc2V0dGxlKCd0aHJvdycsIGVycik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0dGxlKHR5cGUsIHZhbHVlKSB7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAncmV0dXJuJzpcbiAgICAgICAgICBmcm9udC5yZXNvbHZlKHtcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIGRvbmU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICd0aHJvdyc6XG4gICAgICAgICAgZnJvbnQucmVqZWN0KHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGZyb250LnJlc29sdmUoe1xuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgZnJvbnQgPSBmcm9udC5uZXh0O1xuXG4gICAgICBpZiAoZnJvbnQpIHtcbiAgICAgICAgcmVzdW1lKGZyb250LmtleSwgZnJvbnQuYXJnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJhY2sgPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX2ludm9rZSA9IHNlbmQ7XG5cbiAgICBpZiAodHlwZW9mIGdlbi5yZXR1cm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMucmV0dXJuID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5hc3luY0l0ZXJhdG9yKSB7XG4gICAgX0FzeW5jR2VuZXJhdG9yLnByb3RvdHlwZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gIH1cblxuICBfQXN5bmNHZW5lcmF0b3IucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gdGhpcy5faW52b2tlKCduZXh0JywgYXJnKTtcbiAgfTtcblxuICBfQXN5bmNHZW5lcmF0b3IucHJvdG90eXBlLnRocm93ID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ludm9rZSgndGhyb3cnLCBhcmcpO1xuICB9O1xuXG4gIF9Bc3luY0dlbmVyYXRvci5wcm90b3R5cGUucmV0dXJuID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ludm9rZSgncmV0dXJuJywgYXJnKTtcbiAgfTtcblxuICBmdW5jdGlvbiBfd3JhcEFzeW5jR2VuZXJhdG9yKGZuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG5ldyBfQXN5bmNHZW5lcmF0b3IoZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9hd2FpdEFzeW5jR2VuZXJhdG9yKHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBfQXdhaXRWYWx1ZSh2YWx1ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBfYXN5bmNHZW5lcmF0b3JEZWxlZ2F0ZShpbm5lciwgYXdhaXRXcmFwKSB7XG4gICAgdmFyIGl0ZXIgPSB7fSxcbiAgICAgIHdhaXRpbmcgPSBmYWxzZTtcblxuICAgIGZ1bmN0aW9uIHB1bXAoa2V5LCB2YWx1ZSkge1xuICAgICAgd2FpdGluZyA9IHRydWU7XG4gICAgICB2YWx1ZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICAgICAgcmVzb2x2ZShpbm5lcltrZXldKHZhbHVlKSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICB2YWx1ZTogYXdhaXRXcmFwKHZhbHVlKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3IpIHtcbiAgICAgIGl0ZXJbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaXRlci5uZXh0ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIGlmICh3YWl0aW5nKSB7XG4gICAgICAgIHdhaXRpbmcgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHVtcCgnbmV4dCcsIHZhbHVlKTtcbiAgICB9O1xuXG4gICAgaWYgKHR5cGVvZiBpbm5lci50aHJvdyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaXRlci50aHJvdyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGlmICh3YWl0aW5nKSB7XG4gICAgICAgICAgd2FpdGluZyA9IGZhbHNlO1xuICAgICAgICAgIHRocm93IHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHB1bXAoJ3Rocm93JywgdmFsdWUpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGlubmVyLnJldHVybiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaXRlci5yZXR1cm4gPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gcHVtcCgncmV0dXJuJywgdmFsdWUpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gaXRlcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywga2V5LCBhcmcpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpO1xuICAgICAgdmFyIHZhbHVlID0gaW5mby52YWx1ZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoaW5mby5kb25lKSB7XG4gICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKF9uZXh0LCBfdGhyb3cpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKGZuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB2YXIgZ2VuID0gZm4uYXBwbHkoc2VsZiwgYXJncyk7XG5cbiAgICAgICAgZnVuY3Rpb24gX25leHQodmFsdWUpIHtcbiAgICAgICAgICBhc3luY0dlbmVyYXRvclN0ZXAoXG4gICAgICAgICAgICBnZW4sXG4gICAgICAgICAgICByZXNvbHZlLFxuICAgICAgICAgICAgcmVqZWN0LFxuICAgICAgICAgICAgX25leHQsXG4gICAgICAgICAgICBfdGhyb3csXG4gICAgICAgICAgICAnbmV4dCcsXG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBfdGhyb3coZXJyKSB7XG4gICAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCAndGhyb3cnLCBlcnIpO1xuICAgICAgICB9XG5cbiAgICAgICAgX25leHQodW5kZWZpbmVkKTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gICAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgaWYgKCd2YWx1ZScgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gIH1cblxuICBmdW5jdGlvbiBfZGVmaW5lRW51bWVyYWJsZVByb3BlcnRpZXMob2JqLCBkZXNjcykge1xuICAgIGZvciAodmFyIGtleSBpbiBkZXNjcykge1xuICAgICAgdmFyIGRlc2MgPSBkZXNjc1trZXldO1xuICAgICAgZGVzYy5jb25maWd1cmFibGUgPSBkZXNjLmVudW1lcmFibGUgPSB0cnVlO1xuICAgICAgaWYgKCd2YWx1ZScgaW4gZGVzYykgZGVzYy53cml0YWJsZSA9IHRydWU7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIGRlc2MpO1xuICAgIH1cblxuICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgICB2YXIgb2JqZWN0U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZGVzY3MpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdFN5bWJvbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHN5bSA9IG9iamVjdFN5bWJvbHNbaV07XG4gICAgICAgIHZhciBkZXNjID0gZGVzY3Nbc3ltXTtcbiAgICAgICAgZGVzYy5jb25maWd1cmFibGUgPSBkZXNjLmVudW1lcmFibGUgPSB0cnVlO1xuICAgICAgICBpZiAoJ3ZhbHVlJyBpbiBkZXNjKSBkZXNjLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgc3ltLCBkZXNjKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgZnVuY3Rpb24gX2RlZmF1bHRzKG9iaiwgZGVmYXVsdHMpIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGRlZmF1bHRzKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICB2YXIgdmFsdWUgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGRlZmF1bHRzLCBrZXkpO1xuXG4gICAgICBpZiAodmFsdWUgJiYgdmFsdWUuY29uZmlndXJhYmxlICYmIG9ialtrZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgICBpZiAoa2V5IGluIG9iaikge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ialtrZXldID0gdmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICAgIF9leHRlbmRzID1cbiAgICAgIE9iamVjdC5hc3NpZ24gfHxcbiAgICAgIGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICB9O1xuXG4gICAgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBmdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTtcbiAgICAgIHZhciBvd25LZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcblxuICAgICAgaWYgKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG93bktleXMgPSBvd25LZXlzLmNvbmNhdChcbiAgICAgICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSkuZmlsdGVyKGZ1bmN0aW9uKHN5bSkge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBzeW0pLmVudW1lcmFibGU7XG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgb3duS2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cblxuICBmdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG5cbiAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgICAgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7XG4gICAgICBpZiAoZW51bWVyYWJsZU9ubHkpXG4gICAgICAgIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbihzeW0pIHtcbiAgICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTtcbiAgICAgICAgfSk7XG4gICAgICBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGtleXM7XG4gIH1cblxuICBmdW5jdGlvbiBfb2JqZWN0U3ByZWFkMih0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307XG5cbiAgICAgIGlmIChpICUgMikge1xuICAgICAgICBvd25LZXlzKHNvdXJjZSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFxuICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvd25LZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoXG4gICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KVxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cblxuICBmdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICdmdW5jdGlvbicgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24nKTtcbiAgICB9XG5cbiAgICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xuICB9XG5cbiAgZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTtcbiAgICBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzcztcbiAgICBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzO1xuICB9XG5cbiAgZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2ZcbiAgICAgID8gT2JqZWN0LmdldFByb3RvdHlwZU9mXG4gICAgICA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgICAgICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgICAgICAgfTtcbiAgICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xuICB9XG5cbiAgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBfc2V0UHJvdG90eXBlT2YgPVxuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgICAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgICAgIHJldHVybiBvO1xuICAgICAgfTtcblxuICAgIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG4gIH1cblxuICBmdW5jdGlvbiBpc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSAndW5kZWZpbmVkJyB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0eXBlb2YgUHJveHkgPT09ICdmdW5jdGlvbicpIHJldHVybiB0cnVlO1xuXG4gICAgdHJ5IHtcbiAgICAgIERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoRGF0ZSwgW10sIGZ1bmN0aW9uKCkge30pKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHtcbiAgICBpZiAoaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkpIHtcbiAgICAgIF9jb25zdHJ1Y3QgPSBSZWZsZWN0LmNvbnN0cnVjdDtcbiAgICB9IGVsc2Uge1xuICAgICAgX2NvbnN0cnVjdCA9IGZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykge1xuICAgICAgICB2YXIgYSA9IFtudWxsXTtcbiAgICAgICAgYS5wdXNoLmFwcGx5KGEsIGFyZ3MpO1xuICAgICAgICB2YXIgQ29uc3RydWN0b3IgPSBGdW5jdGlvbi5iaW5kLmFwcGx5KFBhcmVudCwgYSk7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IG5ldyBDb25zdHJ1Y3RvcigpO1xuICAgICAgICBpZiAoQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihpbnN0YW5jZSwgQ2xhc3MucHJvdG90eXBlKTtcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gX2NvbnN0cnVjdC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgZnVuY3Rpb24gX2lzTmF0aXZlRnVuY3Rpb24oZm4pIHtcbiAgICByZXR1cm4gRnVuY3Rpb24udG9TdHJpbmcuY2FsbChmbikuaW5kZXhPZignW25hdGl2ZSBjb2RlXScpICE9PSAtMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHtcbiAgICB2YXIgX2NhY2hlID0gdHlwZW9mIE1hcCA9PT0gJ2Z1bmN0aW9uJyA/IG5ldyBNYXAoKSA6IHVuZGVmaW5lZDtcblxuICAgIF93cmFwTmF0aXZlU3VwZXIgPSBmdW5jdGlvbiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKSB7XG4gICAgICBpZiAoQ2xhc3MgPT09IG51bGwgfHwgIV9pc05hdGl2ZUZ1bmN0aW9uKENsYXNzKSkgcmV0dXJuIENsYXNzO1xuXG4gICAgICBpZiAodHlwZW9mIENsYXNzICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uJ1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIF9jYWNoZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaWYgKF9jYWNoZS5oYXMoQ2xhc3MpKSByZXR1cm4gX2NhY2hlLmdldChDbGFzcyk7XG5cbiAgICAgICAgX2NhY2hlLnNldChDbGFzcywgV3JhcHBlcik7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIFdyYXBwZXIoKSB7XG4gICAgICAgIHJldHVybiBfY29uc3RydWN0KENsYXNzLCBhcmd1bWVudHMsIF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3Rvcik7XG4gICAgICB9XG5cbiAgICAgIFdyYXBwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDbGFzcy5wcm90b3R5cGUsIHtcbiAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICB2YWx1ZTogV3JhcHBlcixcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gX3NldFByb3RvdHlwZU9mKFdyYXBwZXIsIENsYXNzKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpO1xuICB9XG5cbiAgZnVuY3Rpb24gX2luc3RhbmNlb2YobGVmdCwgcmlnaHQpIHtcbiAgICBpZiAoXG4gICAgICByaWdodCAhPSBudWxsICYmXG4gICAgICB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgcmlnaHRbU3ltYm9sLmhhc0luc3RhbmNlXVxuICAgICkge1xuICAgICAgcmV0dXJuICEhcmlnaHRbU3ltYm9sLmhhc0luc3RhbmNlXShsZWZ0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGxlZnQgaW5zdGFuY2VvZiByaWdodDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICAgIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGVcbiAgICAgID8gb2JqXG4gICAgICA6IHtcbiAgICAgICAgICBkZWZhdWx0OiBvYmpcbiAgICAgICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikge1xuICAgIGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHtcbiAgICAgIHJldHVybiBvYmo7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBuZXdPYmogPSB7fTtcblxuICAgICAgaWYgKG9iaiAhPSBudWxsKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICAgICAgdmFyIGRlc2MgPVxuICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvclxuICAgICAgICAgICAgICAgID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSlcbiAgICAgICAgICAgICAgICA6IHt9O1xuXG4gICAgICAgICAgICBpZiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpIHtcbiAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5ld09ialtrZXldID0gb2JqW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG5ld09iai5kZWZhdWx0ID0gb2JqO1xuICAgICAgcmV0dXJuIG5ld09iajtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBfbmV3QXJyb3dDaGVjayhpbm5lclRoaXMsIGJvdW5kVGhpcykge1xuICAgIGlmIChpbm5lclRoaXMgIT09IGJvdW5kVGhpcykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGluc3RhbnRpYXRlIGFuIGFycm93IGZ1bmN0aW9uJyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX29iamVjdERlc3RydWN0dXJpbmdFbXB0eShvYmopIHtcbiAgICBpZiAob2JqID09IG51bGwpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBkZXN0cnVjdHVyZSB1bmRlZmluZWQnKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgICB2YXIgdGFyZ2V0ID0ge307XG4gICAgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICAgIHZhciBrZXksIGk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAga2V5ID0gc291cmNlS2V5c1tpXTtcbiAgICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cblxuICBmdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkge1xuICAgIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuXG4gICAgdmFyIHRhcmdldCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpO1xuXG4gICAgdmFyIGtleSwgaTtcblxuICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgICB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTtcbiAgICAgICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG5cbiAgZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gICAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFxuICAgICAgICBcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBzZWxmO1xuICB9XG5cbiAgZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICAgIGlmIChjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIGNhbGwgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgICByZXR1cm4gY2FsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9zdXBlclByb3BCYXNlKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgICB3aGlsZSAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkge1xuICAgICAgb2JqZWN0ID0gX2dldFByb3RvdHlwZU9mKG9iamVjdCk7XG4gICAgICBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9XG5cbiAgZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gJ3VuZGVmaW5lZCcgJiYgUmVmbGVjdC5nZXQpIHtcbiAgICAgIF9nZXQgPSBSZWZsZWN0LmdldDtcbiAgICB9IGVsc2Uge1xuICAgICAgX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHtcbiAgICAgICAgdmFyIGJhc2UgPSBfc3VwZXJQcm9wQmFzZSh0YXJnZXQsIHByb3BlcnR5KTtcblxuICAgICAgICBpZiAoIWJhc2UpIHJldHVybjtcbiAgICAgICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2UsIHByb3BlcnR5KTtcblxuICAgICAgICBpZiAoZGVzYy5nZXQpIHtcbiAgICAgICAgICByZXR1cm4gZGVzYy5nZXQuY2FsbChyZWNlaXZlcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGVzYy52YWx1ZTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIgfHwgdGFyZ2V0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldCh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSwgcmVjZWl2ZXIpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgIT09ICd1bmRlZmluZWQnICYmIFJlZmxlY3Quc2V0KSB7XG4gICAgICBzZXQgPSBSZWZsZWN0LnNldDtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0ID0gZnVuY3Rpb24gc2V0KHRhcmdldCwgcHJvcGVydHksIHZhbHVlLCByZWNlaXZlcikge1xuICAgICAgICB2YXIgYmFzZSA9IF9zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpO1xuXG4gICAgICAgIHZhciBkZXNjO1xuXG4gICAgICAgIGlmIChiYXNlKSB7XG4gICAgICAgICAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpO1xuXG4gICAgICAgICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICAgICAgICBkZXNjLnNldC5jYWxsKHJlY2VpdmVyLCB2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFkZXNjLndyaXRhYmxlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocmVjZWl2ZXIsIHByb3BlcnR5KTtcblxuICAgICAgICBpZiAoZGVzYykge1xuICAgICAgICAgIGlmICghZGVzYy53cml0YWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRlc2MudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVjZWl2ZXIsIHByb3BlcnR5LCBkZXNjKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfZGVmaW5lUHJvcGVydHkocmVjZWl2ZXIsIHByb3BlcnR5LCB2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHNldCh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSwgcmVjZWl2ZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gX3NldCh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSwgcmVjZWl2ZXIsIGlzU3RyaWN0KSB7XG4gICAgdmFyIHMgPSBzZXQodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUsIHJlY2VpdmVyIHx8IHRhcmdldCk7XG5cbiAgICBpZiAoIXMgJiYgaXNTdHJpY3QpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZmFpbGVkIHRvIHNldCBwcm9wZXJ0eScpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF90YWdnZWRUZW1wbGF0ZUxpdGVyYWwoc3RyaW5ncywgcmF3KSB7XG4gICAgaWYgKCFyYXcpIHtcbiAgICAgIHJhdyA9IHN0cmluZ3Muc2xpY2UoMCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhzdHJpbmdzLCB7XG4gICAgICAgIHJhdzoge1xuICAgICAgICAgIHZhbHVlOiBPYmplY3QuZnJlZXplKHJhdylcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gX3RhZ2dlZFRlbXBsYXRlTGl0ZXJhbExvb3NlKHN0cmluZ3MsIHJhdykge1xuICAgIGlmICghcmF3KSB7XG4gICAgICByYXcgPSBzdHJpbmdzLnNsaWNlKDApO1xuICAgIH1cblxuICAgIHN0cmluZ3MucmF3ID0gcmF3O1xuICAgIHJldHVybiBzdHJpbmdzO1xuICB9XG5cbiAgZnVuY3Rpb24gX3RlbXBvcmFsUmVmKHZhbCwgbmFtZSkge1xuICAgIGlmICh2YWwgPT09IF90ZW1wb3JhbFVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKG5hbWUgKyAnIGlzIG5vdCBkZWZpbmVkIC0gdGVtcG9yYWwgZGVhZCB6b25lJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX3JlYWRPbmx5RXJyb3IobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignXCInICsgbmFtZSArICdcIiBpcyByZWFkLW9ubHknKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9jbGFzc05hbWVURFpFcnJvcihuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0NsYXNzIFwiJyArIG5hbWUgKyAnXCIgY2Fubm90IGJlIHJlZmVyZW5jZWQgaW4gY29tcHV0ZWQgcHJvcGVydHkga2V5cy4nXG4gICAgKTtcbiAgfVxuXG4gIHZhciBfdGVtcG9yYWxVbmRlZmluZWQgPSB7fTtcblxuICBmdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHtcbiAgICByZXR1cm4gKFxuICAgICAgX2FycmF5V2l0aEhvbGVzKGFycikgfHxcbiAgICAgIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8XG4gICAgICBfbm9uSXRlcmFibGVSZXN0KClcbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXlMb29zZShhcnIsIGkpIHtcbiAgICByZXR1cm4gKFxuICAgICAgX2FycmF5V2l0aEhvbGVzKGFycikgfHxcbiAgICAgIF9pdGVyYWJsZVRvQXJyYXlMaW1pdExvb3NlKGFyciwgaSkgfHxcbiAgICAgIF9ub25JdGVyYWJsZVJlc3QoKVxuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiBfdG9BcnJheShhcnIpIHtcbiAgICByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHtcbiAgICByZXR1cm4gKFxuICAgICAgX2FycmF5V2l0aG91dEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF9ub25JdGVyYWJsZVNwcmVhZCgpXG4gICAgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTsgaSA8IGFyci5sZW5ndGg7IGkrKylcbiAgICAgICAgYXJyMltpXSA9IGFycltpXTtcblxuICAgICAgcmV0dXJuIGFycjI7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7XG4gIH1cblxuICBmdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHtcbiAgICBpZiAoXG4gICAgICBTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGl0ZXIpIHx8XG4gICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaXRlcikgPT09ICdbb2JqZWN0IEFyZ3VtZW50c10nXG4gICAgKVxuICAgICAgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7XG4gIH1cblxuICBmdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7XG4gICAgdmFyIF9hcnIgPSBbXTtcbiAgICB2YXIgX24gPSB0cnVlO1xuICAgIHZhciBfZCA9IGZhbHNlO1xuICAgIHZhciBfZSA9IHVuZGVmaW5lZDtcblxuICAgIHRyeSB7XG4gICAgICBmb3IgKFxuICAgICAgICB2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfcztcbiAgICAgICAgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7XG4gICAgICAgIF9uID0gdHJ1ZVxuICAgICAgKSB7XG4gICAgICAgIF9hcnIucHVzaChfcy52YWx1ZSk7XG5cbiAgICAgICAgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2QgPSB0cnVlO1xuICAgICAgX2UgPSBlcnI7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghX24gJiYgX2lbJ3JldHVybiddICE9IG51bGwpIF9pWydyZXR1cm4nXSgpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKF9kKSB0aHJvdyBfZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gX2FycjtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdExvb3NlKGFyciwgaSkge1xuICAgIHZhciBfYXJyID0gW107XG5cbiAgICBmb3IgKFxuICAgICAgdmFyIF9pdGVyYXRvciA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwO1xuICAgICAgIShfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmU7XG5cbiAgICApIHtcbiAgICAgIF9hcnIucHVzaChfc3RlcC52YWx1ZSk7XG5cbiAgICAgIGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gX2FycjtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZScpO1xuICB9XG5cbiAgZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlJyk7XG4gIH1cblxuICBmdW5jdGlvbiBfc2tpcEZpcnN0R2VuZXJhdG9yTmV4dChmbikge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpdCA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICBpdC5uZXh0KCk7XG4gICAgICByZXR1cm4gaXQ7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF90b1ByaW1pdGl2ZShpbnB1dCwgaGludCkge1xuICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdvYmplY3QnIHx8IGlucHV0ID09PSBudWxsKSByZXR1cm4gaW5wdXQ7XG4gICAgdmFyIHByaW0gPSBpbnB1dFtTeW1ib2wudG9QcmltaXRpdmVdO1xuXG4gICAgaWYgKHByaW0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIHJlcyA9IHByaW0uY2FsbChpbnB1dCwgaGludCB8fCAnZGVmYXVsdCcpO1xuICAgICAgaWYgKHR5cGVvZiByZXMgIT09ICdvYmplY3QnKSByZXR1cm4gcmVzO1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gKGhpbnQgPT09ICdzdHJpbmcnID8gU3RyaW5nIDogTnVtYmVyKShpbnB1dCk7XG4gIH1cblxuICBmdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleShhcmcpIHtcbiAgICB2YXIga2V5ID0gX3RvUHJpbWl0aXZlKGFyZywgJ3N0cmluZycpO1xuXG4gICAgcmV0dXJuIHR5cGVvZiBrZXkgPT09ICdzeW1ib2wnID8ga2V5IDogU3RyaW5nKGtleSk7XG4gIH1cblxuICBmdW5jdGlvbiBfaW5pdGlhbGl6ZXJXYXJuaW5nSGVscGVyKGRlc2NyaXB0b3IsIGNvbnRleHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnRGVjb3JhdGluZyBjbGFzcyBwcm9wZXJ0eSBmYWlsZWQuIFBsZWFzZSBlbnN1cmUgdGhhdCAnICtcbiAgICAgICAgJ3Byb3Bvc2FsLWNsYXNzLXByb3BlcnRpZXMgaXMgZW5hYmxlZCBhbmQgc2V0IHRvIHVzZSBsb29zZSBtb2RlLiAnICtcbiAgICAgICAgJ1RvIHVzZSBwcm9wb3NhbC1jbGFzcy1wcm9wZXJ0aWVzIGluIHNwZWMgbW9kZSB3aXRoIGRlY29yYXRvcnMsIHdhaXQgZm9yICcgK1xuICAgICAgICAndGhlIG5leHQgbWFqb3IgdmVyc2lvbiBvZiBkZWNvcmF0b3JzIGluIHN0YWdlIDIuJ1xuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5LCBkZXNjcmlwdG9yLCBjb250ZXh0KSB7XG4gICAgaWYgKCFkZXNjcmlwdG9yKSByZXR1cm47XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHksIHtcbiAgICAgIGVudW1lcmFibGU6IGRlc2NyaXB0b3IuZW51bWVyYWJsZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogZGVzY3JpcHRvci5jb25maWd1cmFibGUsXG4gICAgICB3cml0YWJsZTogZGVzY3JpcHRvci53cml0YWJsZSxcbiAgICAgIHZhbHVlOiBkZXNjcmlwdG9yLmluaXRpYWxpemVyXG4gICAgICAgID8gZGVzY3JpcHRvci5pbml0aWFsaXplci5jYWxsKGNvbnRleHQpXG4gICAgICAgIDogdm9pZCAwXG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKFxuICAgIHRhcmdldCxcbiAgICBwcm9wZXJ0eSxcbiAgICBkZWNvcmF0b3JzLFxuICAgIGRlc2NyaXB0b3IsXG4gICAgY29udGV4dFxuICApIHtcbiAgICB2YXIgZGVzYyA9IHt9O1xuICAgIE9iamVjdC5rZXlzKGRlc2NyaXB0b3IpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICBkZXNjW2tleV0gPSBkZXNjcmlwdG9yW2tleV07XG4gICAgfSk7XG4gICAgZGVzYy5lbnVtZXJhYmxlID0gISFkZXNjLmVudW1lcmFibGU7XG4gICAgZGVzYy5jb25maWd1cmFibGUgPSAhIWRlc2MuY29uZmlndXJhYmxlO1xuXG4gICAgaWYgKCd2YWx1ZScgaW4gZGVzYyB8fCBkZXNjLmluaXRpYWxpemVyKSB7XG4gICAgICBkZXNjLndyaXRhYmxlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBkZXNjID0gZGVjb3JhdG9yc1xuICAgICAgLnNsaWNlKClcbiAgICAgIC5yZXZlcnNlKClcbiAgICAgIC5yZWR1Y2UoZnVuY3Rpb24oZGVzYywgZGVjb3JhdG9yKSB7XG4gICAgICAgIHJldHVybiBkZWNvcmF0b3IodGFyZ2V0LCBwcm9wZXJ0eSwgZGVzYykgfHwgZGVzYztcbiAgICAgIH0sIGRlc2MpO1xuXG4gICAgaWYgKGNvbnRleHQgJiYgZGVzYy5pbml0aWFsaXplciAhPT0gdm9pZCAwKSB7XG4gICAgICBkZXNjLnZhbHVlID0gZGVzYy5pbml0aWFsaXplciA/IGRlc2MuaW5pdGlhbGl6ZXIuY2FsbChjb250ZXh0KSA6IHZvaWQgMDtcbiAgICAgIGRlc2MuaW5pdGlhbGl6ZXIgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKGRlc2MuaW5pdGlhbGl6ZXIgPT09IHZvaWQgMCkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHksIGRlc2MpO1xuICAgICAgZGVzYyA9IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlc2M7XG4gIH1cblxuICB2YXIgaWQgPSAwO1xuXG4gIGZ1bmN0aW9uIF9jbGFzc1ByaXZhdGVGaWVsZExvb3NlS2V5KG5hbWUpIHtcbiAgICByZXR1cm4gJ19fcHJpdmF0ZV8nICsgaWQrKyArICdfJyArIG5hbWU7XG4gIH1cblxuICBmdW5jdGlvbiBfY2xhc3NQcml2YXRlRmllbGRMb29zZUJhc2UocmVjZWl2ZXIsIHByaXZhdGVLZXkpIHtcbiAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChyZWNlaXZlciwgcHJpdmF0ZUtleSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2F0dGVtcHRlZCB0byB1c2UgcHJpdmF0ZSBmaWVsZCBvbiBub24taW5zdGFuY2UnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVjZWl2ZXI7XG4gIH1cblxuICBmdW5jdGlvbiBfY2xhc3NQcml2YXRlRmllbGRHZXQocmVjZWl2ZXIsIHByaXZhdGVNYXApIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByaXZhdGVNYXAuZ2V0KHJlY2VpdmVyKTtcblxuICAgIGlmICghZGVzY3JpcHRvcikge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXR0ZW1wdGVkIHRvIGdldCBwcml2YXRlIGZpZWxkIG9uIG5vbi1pbnN0YW5jZScpO1xuICAgIH1cblxuICAgIGlmIChkZXNjcmlwdG9yLmdldCkge1xuICAgICAgcmV0dXJuIGRlc2NyaXB0b3IuZ2V0LmNhbGwocmVjZWl2ZXIpO1xuICAgIH1cblxuICAgIHJldHVybiBkZXNjcmlwdG9yLnZhbHVlO1xuICB9XG5cbiAgZnVuY3Rpb24gX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHJlY2VpdmVyLCBwcml2YXRlTWFwLCB2YWx1ZSkge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJpdmF0ZU1hcC5nZXQocmVjZWl2ZXIpO1xuXG4gICAgaWYgKCFkZXNjcmlwdG9yKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhdHRlbXB0ZWQgdG8gc2V0IHByaXZhdGUgZmllbGQgb24gbm9uLWluc3RhbmNlJyk7XG4gICAgfVxuXG4gICAgaWYgKGRlc2NyaXB0b3Iuc2V0KSB7XG4gICAgICBkZXNjcmlwdG9yLnNldC5jYWxsKHJlY2VpdmVyLCB2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghZGVzY3JpcHRvci53cml0YWJsZSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhdHRlbXB0ZWQgdG8gc2V0IHJlYWQgb25seSBwcml2YXRlIGZpZWxkJyk7XG4gICAgICB9XG5cbiAgICAgIGRlc2NyaXB0b3IudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBmdW5jdGlvbiBfY2xhc3NQcml2YXRlRmllbGREZXN0cnVjdHVyZVNldChyZWNlaXZlciwgcHJpdmF0ZU1hcCkge1xuICAgIGlmICghcHJpdmF0ZU1hcC5oYXMocmVjZWl2ZXIpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhdHRlbXB0ZWQgdG8gc2V0IHByaXZhdGUgZmllbGQgb24gbm9uLWluc3RhbmNlJyk7XG4gICAgfVxuXG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcml2YXRlTWFwLmdldChyZWNlaXZlcik7XG5cbiAgICBpZiAoZGVzY3JpcHRvci5zZXQpIHtcbiAgICAgIGlmICghKCdfX2Rlc3RyT2JqJyBpbiBkZXNjcmlwdG9yKSkge1xuICAgICAgICBkZXNjcmlwdG9yLl9fZGVzdHJPYmogPSB7XG4gICAgICAgICAgc2V0IHZhbHVlKHYpIHtcbiAgICAgICAgICAgIGRlc2NyaXB0b3Iuc2V0LmNhbGwocmVjZWl2ZXIsIHYpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRlc2NyaXB0b3IuX19kZXN0ck9iajtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFkZXNjcmlwdG9yLndyaXRhYmxlKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2F0dGVtcHRlZCB0byBzZXQgcmVhZCBvbmx5IHByaXZhdGUgZmllbGQnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRlc2NyaXB0b3I7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX2NsYXNzU3RhdGljUHJpdmF0ZUZpZWxkU3BlY0dldChcbiAgICByZWNlaXZlcixcbiAgICBjbGFzc0NvbnN0cnVjdG9yLFxuICAgIGRlc2NyaXB0b3JcbiAgKSB7XG4gICAgaWYgKHJlY2VpdmVyICE9PSBjbGFzc0NvbnN0cnVjdG9yKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQcml2YXRlIHN0YXRpYyBhY2Nlc3Mgb2Ygd3JvbmcgcHJvdmVuYW5jZScpO1xuICAgIH1cblxuICAgIHJldHVybiBkZXNjcmlwdG9yLnZhbHVlO1xuICB9XG5cbiAgZnVuY3Rpb24gX2NsYXNzU3RhdGljUHJpdmF0ZUZpZWxkU3BlY1NldChcbiAgICByZWNlaXZlcixcbiAgICBjbGFzc0NvbnN0cnVjdG9yLFxuICAgIGRlc2NyaXB0b3IsXG4gICAgdmFsdWVcbiAgKSB7XG4gICAgaWYgKHJlY2VpdmVyICE9PSBjbGFzc0NvbnN0cnVjdG9yKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQcml2YXRlIHN0YXRpYyBhY2Nlc3Mgb2Ygd3JvbmcgcHJvdmVuYW5jZScpO1xuICAgIH1cblxuICAgIGlmICghZGVzY3JpcHRvci53cml0YWJsZSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXR0ZW1wdGVkIHRvIHNldCByZWFkIG9ubHkgcHJpdmF0ZSBmaWVsZCcpO1xuICAgIH1cblxuICAgIGRlc2NyaXB0b3IudmFsdWUgPSB2YWx1ZTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBmdW5jdGlvbiBfY2xhc3NTdGF0aWNQcml2YXRlTWV0aG9kR2V0KHJlY2VpdmVyLCBjbGFzc0NvbnN0cnVjdG9yLCBtZXRob2QpIHtcbiAgICBpZiAocmVjZWl2ZXIgIT09IGNsYXNzQ29uc3RydWN0b3IpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1ByaXZhdGUgc3RhdGljIGFjY2VzcyBvZiB3cm9uZyBwcm92ZW5hbmNlJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1ldGhvZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9jbGFzc1N0YXRpY1ByaXZhdGVNZXRob2RTZXQoKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXR0ZW1wdGVkIHRvIHNldCByZWFkIG9ubHkgc3RhdGljIHByaXZhdGUgZmllbGQnKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9kZWNvcmF0ZShkZWNvcmF0b3JzLCBmYWN0b3J5LCBzdXBlckNsYXNzLCBtaXhpbnMpIHtcbiAgICB2YXIgYXBpID0gX2dldERlY29yYXRvcnNBcGkoKTtcblxuICAgIGlmIChtaXhpbnMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWl4aW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFwaSA9IG1peGluc1tpXShhcGkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByID0gZmFjdG9yeShmdW5jdGlvbiBpbml0aWFsaXplKE8pIHtcbiAgICAgIGFwaS5pbml0aWFsaXplSW5zdGFuY2VFbGVtZW50cyhPLCBkZWNvcmF0ZWQuZWxlbWVudHMpO1xuICAgIH0sIHN1cGVyQ2xhc3MpO1xuICAgIHZhciBkZWNvcmF0ZWQgPSBhcGkuZGVjb3JhdGVDbGFzcyhcbiAgICAgIF9jb2FsZXNjZUNsYXNzRWxlbWVudHMoci5kLm1hcChfY3JlYXRlRWxlbWVudERlc2NyaXB0b3IpKSxcbiAgICAgIGRlY29yYXRvcnNcbiAgICApO1xuICAgIGFwaS5pbml0aWFsaXplQ2xhc3NFbGVtZW50cyhyLkYsIGRlY29yYXRlZC5lbGVtZW50cyk7XG4gICAgcmV0dXJuIGFwaS5ydW5DbGFzc0ZpbmlzaGVycyhyLkYsIGRlY29yYXRlZC5maW5pc2hlcnMpO1xuICB9XG5cbiAgZnVuY3Rpb24gX2dldERlY29yYXRvcnNBcGkoKSB7XG4gICAgX2dldERlY29yYXRvcnNBcGkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBhcGk7XG4gICAgfTtcblxuICAgIHZhciBhcGkgPSB7XG4gICAgICBlbGVtZW50c0RlZmluaXRpb25PcmRlcjogW1snbWV0aG9kJ10sIFsnZmllbGQnXV0sXG4gICAgICBpbml0aWFsaXplSW5zdGFuY2VFbGVtZW50czogZnVuY3Rpb24oTywgZWxlbWVudHMpIHtcbiAgICAgICAgWydtZXRob2QnLCAnZmllbGQnXS5mb3JFYWNoKGZ1bmN0aW9uKGtpbmQpIHtcbiAgICAgICAgICBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIGlmIChlbGVtZW50LmtpbmQgPT09IGtpbmQgJiYgZWxlbWVudC5wbGFjZW1lbnQgPT09ICdvd24nKSB7XG4gICAgICAgICAgICAgIHRoaXMuZGVmaW5lQ2xhc3NFbGVtZW50KE8sIGVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICAgIH0sXG4gICAgICBpbml0aWFsaXplQ2xhc3NFbGVtZW50czogZnVuY3Rpb24oRiwgZWxlbWVudHMpIHtcbiAgICAgICAgdmFyIHByb3RvID0gRi5wcm90b3R5cGU7XG4gICAgICAgIFsnbWV0aG9kJywgJ2ZpZWxkJ10uZm9yRWFjaChmdW5jdGlvbihraW5kKSB7XG4gICAgICAgICAgZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgICB2YXIgcGxhY2VtZW50ID0gZWxlbWVudC5wbGFjZW1lbnQ7XG5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgZWxlbWVudC5raW5kID09PSBraW5kICYmXG4gICAgICAgICAgICAgIChwbGFjZW1lbnQgPT09ICdzdGF0aWMnIHx8IHBsYWNlbWVudCA9PT0gJ3Byb3RvdHlwZScpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgdmFyIHJlY2VpdmVyID0gcGxhY2VtZW50ID09PSAnc3RhdGljJyA/IEYgOiBwcm90bztcbiAgICAgICAgICAgICAgdGhpcy5kZWZpbmVDbGFzc0VsZW1lbnQocmVjZWl2ZXIsIGVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICAgIH0sXG4gICAgICBkZWZpbmVDbGFzc0VsZW1lbnQ6IGZ1bmN0aW9uKHJlY2VpdmVyLCBlbGVtZW50KSB7XG4gICAgICAgIHZhciBkZXNjcmlwdG9yID0gZWxlbWVudC5kZXNjcmlwdG9yO1xuXG4gICAgICAgIGlmIChlbGVtZW50LmtpbmQgPT09ICdmaWVsZCcpIHtcbiAgICAgICAgICB2YXIgaW5pdGlhbGl6ZXIgPSBlbGVtZW50LmluaXRpYWxpemVyO1xuICAgICAgICAgIGRlc2NyaXB0b3IgPSB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBkZXNjcmlwdG9yLmVudW1lcmFibGUsXG4gICAgICAgICAgICB3cml0YWJsZTogZGVzY3JpcHRvci53cml0YWJsZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogZGVzY3JpcHRvci5jb25maWd1cmFibGUsXG4gICAgICAgICAgICB2YWx1ZTogaW5pdGlhbGl6ZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGluaXRpYWxpemVyLmNhbGwocmVjZWl2ZXIpXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZWNlaXZlciwgZWxlbWVudC5rZXksIGRlc2NyaXB0b3IpO1xuICAgICAgfSxcbiAgICAgIGRlY29yYXRlQ2xhc3M6IGZ1bmN0aW9uKGVsZW1lbnRzLCBkZWNvcmF0b3JzKSB7XG4gICAgICAgIHZhciBuZXdFbGVtZW50cyA9IFtdO1xuICAgICAgICB2YXIgZmluaXNoZXJzID0gW107XG4gICAgICAgIHZhciBwbGFjZW1lbnRzID0ge1xuICAgICAgICAgIHN0YXRpYzogW10sXG4gICAgICAgICAgcHJvdG90eXBlOiBbXSxcbiAgICAgICAgICBvd246IFtdXG4gICAgICAgIH07XG4gICAgICAgIGVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgIHRoaXMuYWRkRWxlbWVudFBsYWNlbWVudChlbGVtZW50LCBwbGFjZW1lbnRzKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIGVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgIGlmICghX2hhc0RlY29yYXRvcnMoZWxlbWVudCkpIHJldHVybiBuZXdFbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xuICAgICAgICAgIHZhciBlbGVtZW50RmluaXNoZXJzRXh0cmFzID0gdGhpcy5kZWNvcmF0ZUVsZW1lbnQoXG4gICAgICAgICAgICBlbGVtZW50LFxuICAgICAgICAgICAgcGxhY2VtZW50c1xuICAgICAgICAgICk7XG4gICAgICAgICAgbmV3RWxlbWVudHMucHVzaChlbGVtZW50RmluaXNoZXJzRXh0cmFzLmVsZW1lbnQpO1xuICAgICAgICAgIG5ld0VsZW1lbnRzLnB1c2guYXBwbHkobmV3RWxlbWVudHMsIGVsZW1lbnRGaW5pc2hlcnNFeHRyYXMuZXh0cmFzKTtcbiAgICAgICAgICBmaW5pc2hlcnMucHVzaC5hcHBseShmaW5pc2hlcnMsIGVsZW1lbnRGaW5pc2hlcnNFeHRyYXMuZmluaXNoZXJzKTtcbiAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgaWYgKCFkZWNvcmF0b3JzKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVsZW1lbnRzOiBuZXdFbGVtZW50cyxcbiAgICAgICAgICAgIGZpbmlzaGVyczogZmluaXNoZXJzXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmRlY29yYXRlQ29uc3RydWN0b3IobmV3RWxlbWVudHMsIGRlY29yYXRvcnMpO1xuICAgICAgICBmaW5pc2hlcnMucHVzaC5hcHBseShmaW5pc2hlcnMsIHJlc3VsdC5maW5pc2hlcnMpO1xuICAgICAgICByZXN1bHQuZmluaXNoZXJzID0gZmluaXNoZXJzO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSxcbiAgICAgIGFkZEVsZW1lbnRQbGFjZW1lbnQ6IGZ1bmN0aW9uKGVsZW1lbnQsIHBsYWNlbWVudHMsIHNpbGVudCkge1xuICAgICAgICB2YXIga2V5cyA9IHBsYWNlbWVudHNbZWxlbWVudC5wbGFjZW1lbnRdO1xuXG4gICAgICAgIGlmICghc2lsZW50ICYmIGtleXMuaW5kZXhPZihlbGVtZW50LmtleSkgIT09IC0xKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRHVwbGljYXRlZCBlbGVtZW50ICgnICsgZWxlbWVudC5rZXkgKyAnKScpO1xuICAgICAgICB9XG5cbiAgICAgICAga2V5cy5wdXNoKGVsZW1lbnQua2V5KTtcbiAgICAgIH0sXG4gICAgICBkZWNvcmF0ZUVsZW1lbnQ6IGZ1bmN0aW9uKGVsZW1lbnQsIHBsYWNlbWVudHMpIHtcbiAgICAgICAgdmFyIGV4dHJhcyA9IFtdO1xuICAgICAgICB2YXIgZmluaXNoZXJzID0gW107XG5cbiAgICAgICAgZm9yIChcbiAgICAgICAgICB2YXIgZGVjb3JhdG9ycyA9IGVsZW1lbnQuZGVjb3JhdG9ycywgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTtcbiAgICAgICAgICBpID49IDA7XG4gICAgICAgICAgaS0tXG4gICAgICAgICkge1xuICAgICAgICAgIHZhciBrZXlzID0gcGxhY2VtZW50c1tlbGVtZW50LnBsYWNlbWVudF07XG4gICAgICAgICAga2V5cy5zcGxpY2Uoa2V5cy5pbmRleE9mKGVsZW1lbnQua2V5KSwgMSk7XG4gICAgICAgICAgdmFyIGVsZW1lbnRPYmplY3QgPSB0aGlzLmZyb21FbGVtZW50RGVzY3JpcHRvcihlbGVtZW50KTtcbiAgICAgICAgICB2YXIgZWxlbWVudEZpbmlzaGVyRXh0cmFzID0gdGhpcy50b0VsZW1lbnRGaW5pc2hlckV4dHJhcyhcbiAgICAgICAgICAgICgwLCBkZWNvcmF0b3JzW2ldKShlbGVtZW50T2JqZWN0KSB8fCBlbGVtZW50T2JqZWN0XG4gICAgICAgICAgKTtcbiAgICAgICAgICBlbGVtZW50ID0gZWxlbWVudEZpbmlzaGVyRXh0cmFzLmVsZW1lbnQ7XG4gICAgICAgICAgdGhpcy5hZGRFbGVtZW50UGxhY2VtZW50KGVsZW1lbnQsIHBsYWNlbWVudHMpO1xuXG4gICAgICAgICAgaWYgKGVsZW1lbnRGaW5pc2hlckV4dHJhcy5maW5pc2hlcikge1xuICAgICAgICAgICAgZmluaXNoZXJzLnB1c2goZWxlbWVudEZpbmlzaGVyRXh0cmFzLmZpbmlzaGVyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgbmV3RXh0cmFzID0gZWxlbWVudEZpbmlzaGVyRXh0cmFzLmV4dHJhcztcblxuICAgICAgICAgIGlmIChuZXdFeHRyYXMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbmV3RXh0cmFzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgIHRoaXMuYWRkRWxlbWVudFBsYWNlbWVudChuZXdFeHRyYXNbal0sIHBsYWNlbWVudHMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBleHRyYXMucHVzaC5hcHBseShleHRyYXMsIG5ld0V4dHJhcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgICAgICAgIGZpbmlzaGVyczogZmluaXNoZXJzLFxuICAgICAgICAgIGV4dHJhczogZXh0cmFzXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgZGVjb3JhdGVDb25zdHJ1Y3RvcjogZnVuY3Rpb24oZWxlbWVudHMsIGRlY29yYXRvcnMpIHtcbiAgICAgICAgdmFyIGZpbmlzaGVycyA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgdmFyIG9iaiA9IHRoaXMuZnJvbUNsYXNzRGVzY3JpcHRvcihlbGVtZW50cyk7XG4gICAgICAgICAgdmFyIGVsZW1lbnRzQW5kRmluaXNoZXIgPSB0aGlzLnRvQ2xhc3NEZXNjcmlwdG9yKFxuICAgICAgICAgICAgKDAsIGRlY29yYXRvcnNbaV0pKG9iaikgfHwgb2JqXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGlmIChlbGVtZW50c0FuZEZpbmlzaGVyLmZpbmlzaGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZpbmlzaGVycy5wdXNoKGVsZW1lbnRzQW5kRmluaXNoZXIuZmluaXNoZXIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChlbGVtZW50c0FuZEZpbmlzaGVyLmVsZW1lbnRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGVsZW1lbnRzID0gZWxlbWVudHNBbmRGaW5pc2hlci5lbGVtZW50cztcblxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBlbGVtZW50cy5sZW5ndGggLSAxOyBqKyspIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgayA9IGogKyAxOyBrIDwgZWxlbWVudHMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICBlbGVtZW50c1tqXS5rZXkgPT09IGVsZW1lbnRzW2tdLmtleSAmJlxuICAgICAgICAgICAgICAgICAgZWxlbWVudHNbal0ucGxhY2VtZW50ID09PSBlbGVtZW50c1trXS5wbGFjZW1lbnRcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICdEdXBsaWNhdGVkIGVsZW1lbnQgKCcgKyBlbGVtZW50c1tqXS5rZXkgKyAnKSdcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBlbGVtZW50czogZWxlbWVudHMsXG4gICAgICAgICAgZmluaXNoZXJzOiBmaW5pc2hlcnNcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBmcm9tRWxlbWVudERlc2NyaXB0b3I6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIG9iaiA9IHtcbiAgICAgICAgICBraW5kOiBlbGVtZW50LmtpbmQsXG4gICAgICAgICAga2V5OiBlbGVtZW50LmtleSxcbiAgICAgICAgICBwbGFjZW1lbnQ6IGVsZW1lbnQucGxhY2VtZW50LFxuICAgICAgICAgIGRlc2NyaXB0b3I6IGVsZW1lbnQuZGVzY3JpcHRvclxuICAgICAgICB9O1xuICAgICAgICB2YXIgZGVzYyA9IHtcbiAgICAgICAgICB2YWx1ZTogJ0Rlc2NyaXB0b3InLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBTeW1ib2wudG9TdHJpbmdUYWcsIGRlc2MpO1xuICAgICAgICBpZiAoZWxlbWVudC5raW5kID09PSAnZmllbGQnKSBvYmouaW5pdGlhbGl6ZXIgPSBlbGVtZW50LmluaXRpYWxpemVyO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgfSxcbiAgICAgIHRvRWxlbWVudERlc2NyaXB0b3JzOiBmdW5jdGlvbihlbGVtZW50T2JqZWN0cykge1xuICAgICAgICBpZiAoZWxlbWVudE9iamVjdHMgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuICAgICAgICByZXR1cm4gX3RvQXJyYXkoZWxlbWVudE9iamVjdHMpLm1hcChmdW5jdGlvbihlbGVtZW50T2JqZWN0KSB7XG4gICAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLnRvRWxlbWVudERlc2NyaXB0b3IoZWxlbWVudE9iamVjdCk7XG4gICAgICAgICAgdGhpcy5kaXNhbGxvd1Byb3BlcnR5KFxuICAgICAgICAgICAgZWxlbWVudE9iamVjdCxcbiAgICAgICAgICAgICdmaW5pc2hlcicsXG4gICAgICAgICAgICAnQW4gZWxlbWVudCBkZXNjcmlwdG9yJ1xuICAgICAgICAgICk7XG4gICAgICAgICAgdGhpcy5kaXNhbGxvd1Byb3BlcnR5KFxuICAgICAgICAgICAgZWxlbWVudE9iamVjdCxcbiAgICAgICAgICAgICdleHRyYXMnLFxuICAgICAgICAgICAgJ0FuIGVsZW1lbnQgZGVzY3JpcHRvcidcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgICB9LCB0aGlzKTtcbiAgICAgIH0sXG4gICAgICB0b0VsZW1lbnREZXNjcmlwdG9yOiBmdW5jdGlvbihlbGVtZW50T2JqZWN0KSB7XG4gICAgICAgIHZhciBraW5kID0gU3RyaW5nKGVsZW1lbnRPYmplY3Qua2luZCk7XG5cbiAgICAgICAgaWYgKGtpbmQgIT09ICdtZXRob2QnICYmIGtpbmQgIT09ICdmaWVsZCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgJ0FuIGVsZW1lbnQgZGVzY3JpcHRvclxcJ3MgLmtpbmQgcHJvcGVydHkgbXVzdCBiZSBlaXRoZXIgXCJtZXRob2RcIiBvcicgK1xuICAgICAgICAgICAgICAnIFwiZmllbGRcIiwgYnV0IGEgZGVjb3JhdG9yIGNyZWF0ZWQgYW4gZWxlbWVudCBkZXNjcmlwdG9yIHdpdGgnICtcbiAgICAgICAgICAgICAgJyAua2luZCBcIicgK1xuICAgICAgICAgICAgICBraW5kICtcbiAgICAgICAgICAgICAgJ1wiJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIga2V5ID0gX3RvUHJvcGVydHlLZXkoZWxlbWVudE9iamVjdC5rZXkpO1xuXG4gICAgICAgIHZhciBwbGFjZW1lbnQgPSBTdHJpbmcoZWxlbWVudE9iamVjdC5wbGFjZW1lbnQpO1xuXG4gICAgICAgIGlmIChcbiAgICAgICAgICBwbGFjZW1lbnQgIT09ICdzdGF0aWMnICYmXG4gICAgICAgICAgcGxhY2VtZW50ICE9PSAncHJvdG90eXBlJyAmJlxuICAgICAgICAgIHBsYWNlbWVudCAhPT0gJ293bidcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICdBbiBlbGVtZW50IGRlc2NyaXB0b3JcXCdzIC5wbGFjZW1lbnQgcHJvcGVydHkgbXVzdCBiZSBvbmUgb2YgXCJzdGF0aWNcIiwnICtcbiAgICAgICAgICAgICAgJyBcInByb3RvdHlwZVwiIG9yIFwib3duXCIsIGJ1dCBhIGRlY29yYXRvciBjcmVhdGVkIGFuIGVsZW1lbnQgZGVzY3JpcHRvcicgK1xuICAgICAgICAgICAgICAnIHdpdGggLnBsYWNlbWVudCBcIicgK1xuICAgICAgICAgICAgICBwbGFjZW1lbnQgK1xuICAgICAgICAgICAgICAnXCInXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkZXNjcmlwdG9yID0gZWxlbWVudE9iamVjdC5kZXNjcmlwdG9yO1xuICAgICAgICB0aGlzLmRpc2FsbG93UHJvcGVydHkoXG4gICAgICAgICAgZWxlbWVudE9iamVjdCxcbiAgICAgICAgICAnZWxlbWVudHMnLFxuICAgICAgICAgICdBbiBlbGVtZW50IGRlc2NyaXB0b3InXG4gICAgICAgICk7XG4gICAgICAgIHZhciBlbGVtZW50ID0ge1xuICAgICAgICAgIGtpbmQ6IGtpbmQsXG4gICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgcGxhY2VtZW50OiBwbGFjZW1lbnQsXG4gICAgICAgICAgZGVzY3JpcHRvcjogT2JqZWN0LmFzc2lnbih7fSwgZGVzY3JpcHRvcilcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoa2luZCAhPT0gJ2ZpZWxkJykge1xuICAgICAgICAgIHRoaXMuZGlzYWxsb3dQcm9wZXJ0eShcbiAgICAgICAgICAgIGVsZW1lbnRPYmplY3QsXG4gICAgICAgICAgICAnaW5pdGlhbGl6ZXInLFxuICAgICAgICAgICAgJ0EgbWV0aG9kIGRlc2NyaXB0b3InXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmRpc2FsbG93UHJvcGVydHkoXG4gICAgICAgICAgICBkZXNjcmlwdG9yLFxuICAgICAgICAgICAgJ2dldCcsXG4gICAgICAgICAgICAnVGhlIHByb3BlcnR5IGRlc2NyaXB0b3Igb2YgYSBmaWVsZCBkZXNjcmlwdG9yJ1xuICAgICAgICAgICk7XG4gICAgICAgICAgdGhpcy5kaXNhbGxvd1Byb3BlcnR5KFxuICAgICAgICAgICAgZGVzY3JpcHRvcixcbiAgICAgICAgICAgICdzZXQnLFxuICAgICAgICAgICAgJ1RoZSBwcm9wZXJ0eSBkZXNjcmlwdG9yIG9mIGEgZmllbGQgZGVzY3JpcHRvcidcbiAgICAgICAgICApO1xuICAgICAgICAgIHRoaXMuZGlzYWxsb3dQcm9wZXJ0eShcbiAgICAgICAgICAgIGRlc2NyaXB0b3IsXG4gICAgICAgICAgICAndmFsdWUnLFxuICAgICAgICAgICAgJ1RoZSBwcm9wZXJ0eSBkZXNjcmlwdG9yIG9mIGEgZmllbGQgZGVzY3JpcHRvcidcbiAgICAgICAgICApO1xuICAgICAgICAgIGVsZW1lbnQuaW5pdGlhbGl6ZXIgPSBlbGVtZW50T2JqZWN0LmluaXRpYWxpemVyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICB9LFxuICAgICAgdG9FbGVtZW50RmluaXNoZXJFeHRyYXM6IGZ1bmN0aW9uKGVsZW1lbnRPYmplY3QpIHtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLnRvRWxlbWVudERlc2NyaXB0b3IoZWxlbWVudE9iamVjdCk7XG5cbiAgICAgICAgdmFyIGZpbmlzaGVyID0gX29wdGlvbmFsQ2FsbGFibGVQcm9wZXJ0eShlbGVtZW50T2JqZWN0LCAnZmluaXNoZXInKTtcblxuICAgICAgICB2YXIgZXh0cmFzID0gdGhpcy50b0VsZW1lbnREZXNjcmlwdG9ycyhlbGVtZW50T2JqZWN0LmV4dHJhcyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZWxlbWVudDogZWxlbWVudCxcbiAgICAgICAgICBmaW5pc2hlcjogZmluaXNoZXIsXG4gICAgICAgICAgZXh0cmFzOiBleHRyYXNcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBmcm9tQ2xhc3NEZXNjcmlwdG9yOiBmdW5jdGlvbihlbGVtZW50cykge1xuICAgICAgICB2YXIgb2JqID0ge1xuICAgICAgICAgIGtpbmQ6ICdjbGFzcycsXG4gICAgICAgICAgZWxlbWVudHM6IGVsZW1lbnRzLm1hcCh0aGlzLmZyb21FbGVtZW50RGVzY3JpcHRvciwgdGhpcylcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGRlc2MgPSB7XG4gICAgICAgICAgdmFsdWU6ICdEZXNjcmlwdG9yJyxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgU3ltYm9sLnRvU3RyaW5nVGFnLCBkZXNjKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgIH0sXG4gICAgICB0b0NsYXNzRGVzY3JpcHRvcjogZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgIHZhciBraW5kID0gU3RyaW5nKG9iai5raW5kKTtcblxuICAgICAgICBpZiAoa2luZCAhPT0gJ2NsYXNzJykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAnQSBjbGFzcyBkZXNjcmlwdG9yXFwncyAua2luZCBwcm9wZXJ0eSBtdXN0IGJlIFwiY2xhc3NcIiwgYnV0IGEgZGVjb3JhdG9yJyArXG4gICAgICAgICAgICAgICcgY3JlYXRlZCBhIGNsYXNzIGRlc2NyaXB0b3Igd2l0aCAua2luZCBcIicgK1xuICAgICAgICAgICAgICBraW5kICtcbiAgICAgICAgICAgICAgJ1wiJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRpc2FsbG93UHJvcGVydHkob2JqLCAna2V5JywgJ0EgY2xhc3MgZGVzY3JpcHRvcicpO1xuICAgICAgICB0aGlzLmRpc2FsbG93UHJvcGVydHkob2JqLCAncGxhY2VtZW50JywgJ0EgY2xhc3MgZGVzY3JpcHRvcicpO1xuICAgICAgICB0aGlzLmRpc2FsbG93UHJvcGVydHkob2JqLCAnZGVzY3JpcHRvcicsICdBIGNsYXNzIGRlc2NyaXB0b3InKTtcbiAgICAgICAgdGhpcy5kaXNhbGxvd1Byb3BlcnR5KG9iaiwgJ2luaXRpYWxpemVyJywgJ0EgY2xhc3MgZGVzY3JpcHRvcicpO1xuICAgICAgICB0aGlzLmRpc2FsbG93UHJvcGVydHkob2JqLCAnZXh0cmFzJywgJ0EgY2xhc3MgZGVzY3JpcHRvcicpO1xuXG4gICAgICAgIHZhciBmaW5pc2hlciA9IF9vcHRpb25hbENhbGxhYmxlUHJvcGVydHkob2JqLCAnZmluaXNoZXInKTtcblxuICAgICAgICB2YXIgZWxlbWVudHMgPSB0aGlzLnRvRWxlbWVudERlc2NyaXB0b3JzKG9iai5lbGVtZW50cyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZWxlbWVudHM6IGVsZW1lbnRzLFxuICAgICAgICAgIGZpbmlzaGVyOiBmaW5pc2hlclxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHJ1bkNsYXNzRmluaXNoZXJzOiBmdW5jdGlvbihjb25zdHJ1Y3RvciwgZmluaXNoZXJzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmluaXNoZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIG5ld0NvbnN0cnVjdG9yID0gKDAsIGZpbmlzaGVyc1tpXSkoY29uc3RydWN0b3IpO1xuXG4gICAgICAgICAgaWYgKG5ld0NvbnN0cnVjdG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbmV3Q29uc3RydWN0b3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmluaXNoZXJzIG11c3QgcmV0dXJuIGEgY29uc3RydWN0b3IuJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0cnVjdG9yID0gbmV3Q29uc3RydWN0b3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbnN0cnVjdG9yO1xuICAgICAgfSxcbiAgICAgIGRpc2FsbG93UHJvcGVydHk6IGZ1bmN0aW9uKG9iaiwgbmFtZSwgb2JqZWN0VHlwZSkge1xuICAgICAgICBpZiAob2JqW25hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgb2JqZWN0VHlwZSArIFwiIGNhbid0IGhhdmUgYSAuXCIgKyBuYW1lICsgJyBwcm9wZXJ0eS4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIGFwaTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9jcmVhdGVFbGVtZW50RGVzY3JpcHRvcihkZWYpIHtcbiAgICB2YXIga2V5ID0gX3RvUHJvcGVydHlLZXkoZGVmLmtleSk7XG5cbiAgICB2YXIgZGVzY3JpcHRvcjtcblxuICAgIGlmIChkZWYua2luZCA9PT0gJ21ldGhvZCcpIHtcbiAgICAgIGRlc2NyaXB0b3IgPSB7XG4gICAgICAgIHZhbHVlOiBkZWYudmFsdWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoZGVmLmtpbmQgPT09ICdnZXQnKSB7XG4gICAgICBkZXNjcmlwdG9yID0ge1xuICAgICAgICBnZXQ6IGRlZi52YWx1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGRlZi5raW5kID09PSAnc2V0Jykge1xuICAgICAgZGVzY3JpcHRvciA9IHtcbiAgICAgICAgc2V0OiBkZWYudmFsdWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChkZWYua2luZCA9PT0gJ2ZpZWxkJykge1xuICAgICAgZGVzY3JpcHRvciA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgZWxlbWVudCA9IHtcbiAgICAgIGtpbmQ6IGRlZi5raW5kID09PSAnZmllbGQnID8gJ2ZpZWxkJyA6ICdtZXRob2QnLFxuICAgICAga2V5OiBrZXksXG4gICAgICBwbGFjZW1lbnQ6IGRlZi5zdGF0aWNcbiAgICAgICAgPyAnc3RhdGljJ1xuICAgICAgICA6IGRlZi5raW5kID09PSAnZmllbGQnXG4gICAgICAgID8gJ293bidcbiAgICAgICAgOiAncHJvdG90eXBlJyxcbiAgICAgIGRlc2NyaXB0b3I6IGRlc2NyaXB0b3JcbiAgICB9O1xuICAgIGlmIChkZWYuZGVjb3JhdG9ycykgZWxlbWVudC5kZWNvcmF0b3JzID0gZGVmLmRlY29yYXRvcnM7XG4gICAgaWYgKGRlZi5raW5kID09PSAnZmllbGQnKSBlbGVtZW50LmluaXRpYWxpemVyID0gZGVmLnZhbHVlO1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG5cbiAgZnVuY3Rpb24gX2NvYWxlc2NlR2V0dGVyU2V0dGVyKGVsZW1lbnQsIG90aGVyKSB7XG4gICAgaWYgKGVsZW1lbnQuZGVzY3JpcHRvci5nZXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgb3RoZXIuZGVzY3JpcHRvci5nZXQgPSBlbGVtZW50LmRlc2NyaXB0b3IuZ2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICBvdGhlci5kZXNjcmlwdG9yLnNldCA9IGVsZW1lbnQuZGVzY3JpcHRvci5zZXQ7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX2NvYWxlc2NlQ2xhc3NFbGVtZW50cyhlbGVtZW50cykge1xuICAgIHZhciBuZXdFbGVtZW50cyA9IFtdO1xuXG4gICAgdmFyIGlzU2FtZUVsZW1lbnQgPSBmdW5jdGlvbihvdGhlcikge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgb3RoZXIua2luZCA9PT0gJ21ldGhvZCcgJiZcbiAgICAgICAgb3RoZXIua2V5ID09PSBlbGVtZW50LmtleSAmJlxuICAgICAgICBvdGhlci5wbGFjZW1lbnQgPT09IGVsZW1lbnQucGxhY2VtZW50XG4gICAgICApO1xuICAgIH07XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWxlbWVudCA9IGVsZW1lbnRzW2ldO1xuICAgICAgdmFyIG90aGVyO1xuXG4gICAgICBpZiAoXG4gICAgICAgIGVsZW1lbnQua2luZCA9PT0gJ21ldGhvZCcgJiZcbiAgICAgICAgKG90aGVyID0gbmV3RWxlbWVudHMuZmluZChpc1NhbWVFbGVtZW50KSlcbiAgICAgICkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgX2lzRGF0YURlc2NyaXB0b3IoZWxlbWVudC5kZXNjcmlwdG9yKSB8fFxuICAgICAgICAgIF9pc0RhdGFEZXNjcmlwdG9yKG90aGVyLmRlc2NyaXB0b3IpXG4gICAgICAgICkge1xuICAgICAgICAgIGlmIChfaGFzRGVjb3JhdG9ycyhlbGVtZW50KSB8fCBfaGFzRGVjb3JhdG9ycyhvdGhlcikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcbiAgICAgICAgICAgICAgJ0R1cGxpY2F0ZWQgbWV0aG9kcyAoJyArIGVsZW1lbnQua2V5ICsgXCIpIGNhbid0IGJlIGRlY29yYXRlZC5cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBvdGhlci5kZXNjcmlwdG9yID0gZWxlbWVudC5kZXNjcmlwdG9yO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChfaGFzRGVjb3JhdG9ycyhlbGVtZW50KSkge1xuICAgICAgICAgICAgaWYgKF9oYXNEZWNvcmF0b3JzKG90aGVyKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJEZWNvcmF0b3JzIGNhbid0IGJlIHBsYWNlZCBvbiBkaWZmZXJlbnQgYWNjZXNzb3JzIHdpdGggZm9yIFwiICtcbiAgICAgICAgICAgICAgICAgICd0aGUgc2FtZSBwcm9wZXJ0eSAoJyArXG4gICAgICAgICAgICAgICAgICBlbGVtZW50LmtleSArXG4gICAgICAgICAgICAgICAgICAnKS4nXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG90aGVyLmRlY29yYXRvcnMgPSBlbGVtZW50LmRlY29yYXRvcnM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX2NvYWxlc2NlR2V0dGVyU2V0dGVyKGVsZW1lbnQsIG90aGVyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3RWxlbWVudHMucHVzaChlbGVtZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmV3RWxlbWVudHM7XG4gIH1cblxuICBmdW5jdGlvbiBfaGFzRGVjb3JhdG9ycyhlbGVtZW50KSB7XG4gICAgcmV0dXJuIGVsZW1lbnQuZGVjb3JhdG9ycyAmJiBlbGVtZW50LmRlY29yYXRvcnMubGVuZ3RoO1xuICB9XG5cbiAgZnVuY3Rpb24gX2lzRGF0YURlc2NyaXB0b3IoZGVzYykge1xuICAgIHJldHVybiAoXG4gICAgICBkZXNjICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICEoZGVzYy52YWx1ZSA9PT0gdW5kZWZpbmVkICYmIGRlc2Mud3JpdGFibGUgPT09IHVuZGVmaW5lZClcbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gX29wdGlvbmFsQ2FsbGFibGVQcm9wZXJ0eShvYmosIG5hbWUpIHtcbiAgICB2YXIgdmFsdWUgPSBvYmpbbmFtZV07XG5cbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCAnXCIgKyBuYW1lICsgXCInIHRvIGJlIGEgZnVuY3Rpb25cIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgZnVuY3Rpb24gX2NsYXNzUHJpdmF0ZU1ldGhvZEdldChyZWNlaXZlciwgcHJpdmF0ZVNldCwgZm4pIHtcbiAgICBpZiAoIXByaXZhdGVTZXQuaGFzKHJlY2VpdmVyKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXR0ZW1wdGVkIHRvIGdldCBwcml2YXRlIGZpZWxkIG9uIG5vbi1pbnN0YW5jZScpO1xuICAgIH1cblxuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9jbGFzc1ByaXZhdGVNZXRob2RTZXQoKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXR0ZW1wdGVkIHRvIHJlYXNzaWduIHByaXZhdGUgbWV0aG9kJyk7XG4gIH1cblxuICBmdW5jdGlvbiBfd3JhcFJlZ0V4cChyZSwgZ3JvdXBzKSB7XG4gICAgX3dyYXBSZWdFeHAgPSBmdW5jdGlvbihyZSwgZ3JvdXBzKSB7XG4gICAgICByZXR1cm4gbmV3IEJhYmVsUmVnRXhwKHJlLCBncm91cHMpO1xuICAgIH07XG5cbiAgICB2YXIgX1JlZ0V4cCA9IF93cmFwTmF0aXZlU3VwZXIoUmVnRXhwKTtcblxuICAgIHZhciBfc3VwZXIgPSBSZWdFeHAucHJvdG90eXBlO1xuXG4gICAgdmFyIF9ncm91cHMgPSBuZXcgV2Vha01hcCgpO1xuXG4gICAgZnVuY3Rpb24gQmFiZWxSZWdFeHAocmUsIGdyb3Vwcykge1xuICAgICAgdmFyIF90aGlzID0gX1JlZ0V4cC5jYWxsKHRoaXMsIHJlKTtcblxuICAgICAgX2dyb3Vwcy5zZXQoX3RoaXMsIGdyb3Vwcyk7XG5cbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICBfaW5oZXJpdHMoQmFiZWxSZWdFeHAsIF9SZWdFeHApO1xuXG4gICAgQmFiZWxSZWdFeHAucHJvdG90eXBlLmV4ZWMgPSBmdW5jdGlvbihzdHIpIHtcbiAgICAgIHZhciByZXN1bHQgPSBfc3VwZXIuZXhlYy5jYWxsKHRoaXMsIHN0cik7XG5cbiAgICAgIGlmIChyZXN1bHQpIHJlc3VsdC5ncm91cHMgPSBidWlsZEdyb3VwcyhyZXN1bHQsIHRoaXMpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgQmFiZWxSZWdFeHAucHJvdG90eXBlW1N5bWJvbC5yZXBsYWNlXSA9IGZ1bmN0aW9uKHN0ciwgc3Vic3RpdHV0aW9uKSB7XG4gICAgICBpZiAodHlwZW9mIHN1YnN0aXR1dGlvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFyIGdyb3VwcyA9IF9ncm91cHMuZ2V0KHRoaXMpO1xuXG4gICAgICAgIHJldHVybiBfc3VwZXJbU3ltYm9sLnJlcGxhY2VdLmNhbGwoXG4gICAgICAgICAgdGhpcyxcbiAgICAgICAgICBzdHIsXG4gICAgICAgICAgc3Vic3RpdHV0aW9uLnJlcGxhY2UoL1xcJDwoW14+XSspPi9nLCBmdW5jdGlvbihfLCBuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyQnICsgZ3JvdXBzW25hbWVdO1xuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzdWJzdGl0dXRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICByZXR1cm4gX3N1cGVyW1N5bWJvbC5yZXBsYWNlXS5jYWxsKHRoaXMsIHN0ciwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICBhcmdzLnB1c2guYXBwbHkoYXJncywgYXJndW1lbnRzKTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgYXJnc1thcmdzLmxlbmd0aCAtIDFdICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgYXJncy5wdXNoKGJ1aWxkR3JvdXBzKGFyZ3MsIF90aGlzKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHN1YnN0aXR1dGlvbi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gX3N1cGVyW1N5bWJvbC5yZXBsYWNlXS5jYWxsKHRoaXMsIHN0ciwgc3Vic3RpdHV0aW9uKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gYnVpbGRHcm91cHMocmVzdWx0LCByZSkge1xuICAgICAgdmFyIGcgPSBfZ3JvdXBzLmdldChyZSk7XG5cbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyhnKS5yZWR1Y2UoZnVuY3Rpb24oZ3JvdXBzLCBuYW1lKSB7XG4gICAgICAgIGdyb3Vwc1tuYW1lXSA9IHJlc3VsdFtnW25hbWVdXTtcbiAgICAgICAgcmV0dXJuIGdyb3VwcztcbiAgICAgIH0sIE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICAgIH1cblxuICAgIHJldHVybiBfd3JhcFJlZ0V4cC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgdmFyIGFycmF5UmVtb3ZlID0gZnVuY3Rpb24gYXJyYXlSZW1vdmUoYXJyLCBpbmRleCkge1xuICAgIHJldHVybiBhcnIuc3BsaWNlKGluZGV4LCAxKTtcbiAgfTtcblxuICB2YXIgcnVuID0gZnVuY3Rpb24gcnVuKGNiLCBzeW5jKSB7XG4gICAgaWYgKHN5bmMpIHtcbiAgICAgIGNiKCk7XG4gICAgfSBlbHNlIGlmIChkb2N1bWVudC5oaWRkZW4pIHtcbiAgICAgIFByb21pc2UucmVzb2x2ZSgxKS50aGVuKGNiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0VGltZW91dChjYiwgMCk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBvbiA9IGZ1bmN0aW9uIG9uKCkge1xuICAgIHZhciBsaXN0ZW5lcnMgPSBbXTtcbiAgICB2YXIgb2ZmID0gZnVuY3Rpb24gb2ZmKGV2ZW50LCBjYikge1xuICAgICAgYXJyYXlSZW1vdmUoXG4gICAgICAgIGxpc3RlbmVycyxcbiAgICAgICAgbGlzdGVuZXJzLmZpbmRJbmRleChmdW5jdGlvbihsaXN0ZW5lcikge1xuICAgICAgICAgIHJldHVybiBsaXN0ZW5lci5ldmVudCA9PT0gZXZlbnQgJiYgKGxpc3RlbmVyLmNiID09PSBjYiB8fCAhY2IpO1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9O1xuICAgIHZhciBfZmlyZSA9IGZ1bmN0aW9uIGZpcmUoZXZlbnQsIGFyZ3MsIHN5bmMpIHtcbiAgICAgIGxpc3RlbmVyc1xuICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKGxpc3RlbmVyKSB7XG4gICAgICAgICAgcmV0dXJuIGxpc3RlbmVyLmV2ZW50ID09PSBldmVudDtcbiAgICAgICAgfSlcbiAgICAgICAgLm1hcChmdW5jdGlvbihsaXN0ZW5lcikge1xuICAgICAgICAgIHJldHVybiBsaXN0ZW5lci5jYjtcbiAgICAgICAgfSlcbiAgICAgICAgLmZvckVhY2goZnVuY3Rpb24oY2IpIHtcbiAgICAgICAgICByZXR1cm4gcnVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGNiLmFwcGx5KHZvaWQgMCwgX3RvQ29uc3VtYWJsZUFycmF5KGFyZ3MpKTtcbiAgICAgICAgICB9LCBzeW5jKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgZmlyZVN5bmM6IGZ1bmN0aW9uIGZpcmVTeW5jKGV2ZW50KSB7XG4gICAgICAgIGZvciAoXG4gICAgICAgICAgdmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICAgICAgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksXG4gICAgICAgICAgICBfa2V5ID0gMTtcbiAgICAgICAgICBfa2V5IDwgX2xlbjtcbiAgICAgICAgICBfa2V5KytcbiAgICAgICAgKSB7XG4gICAgICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgIH1cbiAgICAgICAgX2ZpcmUoZXZlbnQsIGFyZ3MsIHRydWUpO1xuICAgICAgfSxcbiAgICAgIGZpcmU6IGZ1bmN0aW9uIGZpcmUoZXZlbnQpIHtcbiAgICAgICAgZm9yIChcbiAgICAgICAgICB2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICAgICAgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSxcbiAgICAgICAgICAgIF9rZXkyID0gMTtcbiAgICAgICAgICBfa2V5MiA8IF9sZW4yO1xuICAgICAgICAgIF9rZXkyKytcbiAgICAgICAgKSB7XG4gICAgICAgICAgYXJnc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgICAgfVxuICAgICAgICBfZmlyZShldmVudCwgYXJncywgZmFsc2UpO1xuICAgICAgfSxcbiAgICAgIG9uOiBmdW5jdGlvbiBvbihldmVudCwgY2IpIHtcbiAgICAgICAgbGlzdGVuZXJzLnB1c2goeyBldmVudDogZXZlbnQsIGNiOiBjYiB9KTtcbiAgICAgIH0sXG4gICAgICBvbk9uY2U6IGZ1bmN0aW9uIG9uT25jZShldmVudCwgX2NiKSB7XG4gICAgICAgIGxpc3RlbmVycy5wdXNoKHtcbiAgICAgICAgICBldmVudDogZXZlbnQsXG4gICAgICAgICAgY2I6IGZ1bmN0aW9uIGNiKCkge1xuICAgICAgICAgICAgb2ZmKGV2ZW50LCBfY2IpO1xuICAgICAgICAgICAgX2NiLmFwcGx5KHZvaWQgMCwgYXJndW1lbnRzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIG9mZjogb2ZmXG4gICAgfTtcbiAgfTtcblxuICB2YXIgY29weU9iamVjdFByb3BlcnRpZXNUb09iamVjdCA9IGZ1bmN0aW9uIGNvcHlPYmplY3RQcm9wZXJ0aWVzVG9PYmplY3QoXG4gICAgc3JjLFxuICAgIHRhcmdldCxcbiAgICBleGNsdWRlZFxuICApIHtcbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhzcmMpXG4gICAgICAuZmlsdGVyKGZ1bmN0aW9uKHByb3BlcnR5KSB7XG4gICAgICAgIHJldHVybiAhZXhjbHVkZWQuaW5jbHVkZXMocHJvcGVydHkpO1xuICAgICAgfSlcbiAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KFxuICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICBrZXksXG4gICAgICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzcmMsIGtleSlcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICB9O1xuXG4gIHZhciBQUklWQVRFID0gW1xuICAgICdmaXJlJyxcbiAgICAncHJvY2VzcycsXG4gICAgJ3JldmVydCcsXG4gICAgJ2xvYWQnLFxuICAgICdvbicsXG4gICAgJ29mZicsXG4gICAgJ29uT25jZScsXG4gICAgJ3JldHJ5TG9hZCcsXG4gICAgJ2V4dGVuZCcsXG4gICAgJ2FyY2hpdmUnLFxuICAgICdhcmNoaXZlZCcsXG4gICAgJ3JlbGVhc2UnLFxuICAgICdyZWxlYXNlZCcsXG4gICAgJ3JlcXVlc3RQcm9jZXNzaW5nJyxcbiAgICAnZnJlZXplJ1xuICBdO1xuXG4gIHZhciBjcmVhdGVJdGVtQVBJID0gZnVuY3Rpb24gY3JlYXRlSXRlbUFQSShpdGVtKSB7XG4gICAgdmFyIGFwaSA9IHt9O1xuICAgIGNvcHlPYmplY3RQcm9wZXJ0aWVzVG9PYmplY3QoaXRlbSwgYXBpLCBQUklWQVRFKTtcbiAgICByZXR1cm4gYXBpO1xuICB9O1xuXG4gIHZhciByZW1vdmVSZWxlYXNlZEl0ZW1zID0gZnVuY3Rpb24gcmVtb3ZlUmVsZWFzZWRJdGVtcyhpdGVtcykge1xuICAgIGl0ZW1zLmZvckVhY2goZnVuY3Rpb24oaXRlbSwgaW5kZXgpIHtcbiAgICAgIGlmIChpdGVtLnJlbGVhc2VkKSB7XG4gICAgICAgIGFycmF5UmVtb3ZlKGl0ZW1zLCBpbmRleCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIEl0ZW1TdGF0dXMgPSB7XG4gICAgSU5JVDogMSxcbiAgICBJRExFOiAyLFxuICAgIFBST0NFU1NJTkdfUVVFVUVEOiA5LFxuICAgIFBST0NFU1NJTkc6IDMsXG4gICAgUFJPQ0VTU0lOR19DT01QTEVURTogNSxcbiAgICBQUk9DRVNTSU5HX0VSUk9SOiA2LFxuICAgIFBST0NFU1NJTkdfUkVWRVJUX0VSUk9SOiAxMCxcbiAgICBMT0FESU5HOiA3LFxuICAgIExPQURfRVJST1I6IDhcbiAgfTtcblxuICB2YXIgRmlsZU9yaWdpbiA9IHtcbiAgICBJTlBVVDogMSxcbiAgICBMSU1CTzogMixcbiAgICBMT0NBTDogM1xuICB9O1xuXG4gIHZhciBnZXROb25OdW1lcmljID0gZnVuY3Rpb24gZ2V0Tm9uTnVtZXJpYyhzdHIpIHtcbiAgICByZXR1cm4gL1teMC05XSsvLmV4ZWMoc3RyKTtcbiAgfTtcblxuICB2YXIgZ2V0RGVjaW1hbFNlcGFyYXRvciA9IGZ1bmN0aW9uIGdldERlY2ltYWxTZXBhcmF0b3IoKSB7XG4gICAgcmV0dXJuIGdldE5vbk51bWVyaWMoKDEuMSkudG9Mb2NhbGVTdHJpbmcoKSlbMF07XG4gIH07XG5cbiAgdmFyIGdldFRob3VzYW5kc1NlcGFyYXRvciA9IGZ1bmN0aW9uIGdldFRob3VzYW5kc1NlcGFyYXRvcigpIHtcbiAgICAvLyBBZGRlZCBmb3IgYnJvd3NlcnMgdGhhdCBkbyBub3QgcmV0dXJuIHRoZSB0aG91c2FuZHMgc2VwYXJhdG9yIChoYXBwZW5kIG9uIG5hdGl2ZSBicm93c2VyIEFuZHJvaWQgNC40LjQpXG4gICAgLy8gV2UgY2hlY2sgYWdhaW5zdCB0aGUgbm9ybWFsIHRvU3RyaW5nIG91dHB1dCBhbmQgaWYgdGhleSdyZSB0aGUgc2FtZSByZXR1cm4gYSBjb21tYSB3aGVuIGRlY2ltYWwgc2VwYXJhdG9yIGlzIGEgZG90XG4gICAgdmFyIGRlY2ltYWxTZXBhcmF0b3IgPSBnZXREZWNpbWFsU2VwYXJhdG9yKCk7XG4gICAgdmFyIHRob3VzYW5kc1N0cmluZ1dpdGhTZXBhcmF0b3IgPSAoMTAwMC4wKS50b0xvY2FsZVN0cmluZygpO1xuICAgIHZhciB0aG91c2FuZHNTdHJpbmdXaXRob3V0U2VwYXJhdG9yID0gKDEwMDAuMCkudG9TdHJpbmcoKTtcbiAgICBpZiAodGhvdXNhbmRzU3RyaW5nV2l0aFNlcGFyYXRvciAhPT0gdGhvdXNhbmRzU3RyaW5nV2l0aG91dFNlcGFyYXRvcikge1xuICAgICAgcmV0dXJuIGdldE5vbk51bWVyaWModGhvdXNhbmRzU3RyaW5nV2l0aFNlcGFyYXRvcilbMF07XG4gICAgfVxuICAgIHJldHVybiBkZWNpbWFsU2VwYXJhdG9yID09PSAnLicgPyAnLCcgOiAnLic7XG4gIH07XG5cbiAgdmFyIFR5cGUgPSB7XG4gICAgQk9PTEVBTjogJ2Jvb2xlYW4nLFxuICAgIElOVDogJ2ludCcsXG4gICAgTlVNQkVSOiAnbnVtYmVyJyxcbiAgICBTVFJJTkc6ICdzdHJpbmcnLFxuICAgIEFSUkFZOiAnYXJyYXknLFxuICAgIE9CSkVDVDogJ29iamVjdCcsXG4gICAgRlVOQ1RJT046ICdmdW5jdGlvbicsXG4gICAgQUNUSU9OOiAnYWN0aW9uJyxcbiAgICBTRVJWRVJfQVBJOiAnc2VydmVyYXBpJyxcbiAgICBSRUdFWDogJ3JlZ2V4J1xuICB9O1xuXG4gIC8vIGFsbCByZWdpc3RlcmVkIGZpbHRlcnNcbiAgdmFyIGZpbHRlcnMgPSBbXTtcblxuICAvLyBsb29wcyBvdmVyIG1hdGNoaW5nIGZpbHRlcnMgYW5kIHBhc3NlcyBvcHRpb25zIHRvIGVhY2ggZmlsdGVyLCByZXR1cm5pbmcgdGhlIG1hcHBlZCByZXN1bHRzXG4gIHZhciBhcHBseUZpbHRlckNoYWluID0gZnVuY3Rpb24gYXBwbHlGaWx0ZXJDaGFpbihrZXksIHZhbHVlLCB1dGlscykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIC8vIGZpbmQgbWF0Y2hpbmcgZmlsdGVycyBmb3IgdGhpcyBrZXlcbiAgICAgIHZhciBtYXRjaGluZ0ZpbHRlcnMgPSBmaWx0ZXJzXG4gICAgICAgIC5maWx0ZXIoZnVuY3Rpb24oZikge1xuICAgICAgICAgIHJldHVybiBmLmtleSA9PT0ga2V5O1xuICAgICAgICB9KVxuICAgICAgICAubWFwKGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgICByZXR1cm4gZi5jYjtcbiAgICAgICAgfSk7XG5cbiAgICAgIC8vIHJlc29sdmUgbm93XG4gICAgICBpZiAobWF0Y2hpbmdGaWx0ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBmaXJzdCBmaWx0ZXIgdG8ga2ljayB0aGluZ3Mgb2ZcbiAgICAgIHZhciBpbml0aWFsRmlsdGVyID0gbWF0Y2hpbmdGaWx0ZXJzLnNoaWZ0KCk7XG5cbiAgICAgIC8vIGNoYWluIGZpbHRlcnNcbiAgICAgIG1hdGNoaW5nRmlsdGVyc1xuICAgICAgICAucmVkdWNlKFxuICAgICAgICAgIC8vIGxvb3Agb3ZlciBwcm9taXNlcyBwYXNzaW5nIHZhbHVlIHRvIG5leHQgcHJvbWlzZVxuICAgICAgICAgIGZ1bmN0aW9uKGN1cnJlbnQsIG5leHQpIHtcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50LnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5leHQodmFsdWUsIHV0aWxzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICAvLyBjYWxsIGluaXRpYWwgZmlsdGVyLCB3aWxsIHJldHVybiBhIHByb21pc2VcbiAgICAgICAgICBpbml0aWFsRmlsdGVyKHZhbHVlLCB1dGlscylcblxuICAgICAgICAgIC8vIGFsbCBleGVjdXRlZFxuICAgICAgICApXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc29sdmUodmFsdWUpO1xuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIGFwcGx5RmlsdGVycyA9IGZ1bmN0aW9uIGFwcGx5RmlsdGVycyhrZXksIHZhbHVlLCB1dGlscykge1xuICAgIHJldHVybiBmaWx0ZXJzXG4gICAgICAuZmlsdGVyKGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgcmV0dXJuIGYua2V5ID09PSBrZXk7XG4gICAgICB9KVxuICAgICAgLm1hcChmdW5jdGlvbihmKSB7XG4gICAgICAgIHJldHVybiBmLmNiKHZhbHVlLCB1dGlscyk7XG4gICAgICB9KTtcbiAgfTtcblxuICAvLyBhZGRzIGEgbmV3IGZpbHRlciB0byB0aGUgbGlzdFxuICB2YXIgYWRkRmlsdGVyID0gZnVuY3Rpb24gYWRkRmlsdGVyKGtleSwgY2IpIHtcbiAgICByZXR1cm4gZmlsdGVycy5wdXNoKHsga2V5OiBrZXksIGNiOiBjYiB9KTtcbiAgfTtcblxuICB2YXIgZXh0ZW5kRGVmYXVsdE9wdGlvbnMgPSBmdW5jdGlvbiBleHRlbmREZWZhdWx0T3B0aW9ucyhhZGRpdGlvbmFsT3B0aW9ucykge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKGRlZmF1bHRPcHRpb25zLCBhZGRpdGlvbmFsT3B0aW9ucyk7XG4gIH07XG5cbiAgdmFyIGdldE9wdGlvbnMgPSBmdW5jdGlvbiBnZXRPcHRpb25zKCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0T3B0aW9ucyk7XG4gIH07XG5cbiAgdmFyIHNldE9wdGlvbnMgPSBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdHMpIHtcbiAgICBmb3JpbihvcHRzLCBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAvLyBrZXkgZG9lcyBub3QgZXhpc3QsIHNvIHRoaXMgb3B0aW9uIGNhbm5vdCBiZSBzZXRcbiAgICAgIGlmICghZGVmYXVsdE9wdGlvbnNba2V5XSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBkZWZhdWx0T3B0aW9uc1trZXldWzBdID0gZ2V0VmFsdWVCeVR5cGUoXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBkZWZhdWx0T3B0aW9uc1trZXldWzBdLFxuICAgICAgICBkZWZhdWx0T3B0aW9uc1trZXldWzFdXG4gICAgICApO1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIGRlZmF1bHQgb3B0aW9ucyBvbiBhcHBcbiAgdmFyIGRlZmF1bHRPcHRpb25zID0ge1xuICAgIC8vIHRoZSBpZCB0byBhZGQgdG8gdGhlIHJvb3QgZWxlbWVudFxuICAgIGlkOiBbbnVsbCwgVHlwZS5TVFJJTkddLFxuXG4gICAgLy8gaW5wdXQgZmllbGQgbmFtZSB0byB1c2VcbiAgICBuYW1lOiBbJ2ZpbGVwb25kJywgVHlwZS5TVFJJTkddLFxuXG4gICAgLy8gZGlzYWJsZSB0aGUgZmllbGRcbiAgICBkaXNhYmxlZDogW2ZhbHNlLCBUeXBlLkJPT0xFQU5dLFxuXG4gICAgLy8gY2xhc3NuYW1lIHRvIHB1dCBvbiB3cmFwcGVyXG4gICAgY2xhc3NOYW1lOiBbbnVsbCwgVHlwZS5TVFJJTkddLFxuXG4gICAgLy8gaXMgdGhlIGZpZWxkIHJlcXVpcmVkXG4gICAgcmVxdWlyZWQ6IFtmYWxzZSwgVHlwZS5CT09MRUFOXSxcblxuICAgIC8vIEFsbG93IG1lZGlhIGNhcHR1cmUgd2hlbiB2YWx1ZSBpcyBzZXRcbiAgICBjYXB0dXJlTWV0aG9kOiBbbnVsbCwgVHlwZS5TVFJJTkddLFxuICAgIC8vIC0gXCJjYW1lcmFcIiwgXCJtaWNyb3Bob25lXCIgb3IgXCJjYW1jb3JkZXJcIixcbiAgICAvLyAtIERvZXMgbm90IHdvcmsgd2l0aCBtdWx0aXBsZSBvbiBhcHBsZSBkZXZpY2VzXG4gICAgLy8gLSBJZiBzZXQsIGFjY2VwdGVkRmlsZVR5cGVzIG11c3QgYmUgbWFkZSB0byBtYXRjaCB3aXRoIG1lZGlhIHdpbGRjYXJkIFwiaW1hZ2UvKlwiLCBcImF1ZGlvLypcIiBvciBcInZpZGVvLypcIlxuXG4gICAgLy8gc3luYyBgYWNjZXB0ZWRGaWxlVHlwZXNgIHByb3BlcnR5IHdpdGggYGFjY2VwdGAgYXR0cmlidXRlXG4gICAgYWxsb3dTeW5jQWNjZXB0QXR0cmlidXRlOiBbdHJ1ZSwgVHlwZS5CT09MRUFOXSxcblxuICAgIC8vIEZlYXR1cmUgdG9nZ2xlc1xuICAgIGFsbG93RHJvcDogW3RydWUsIFR5cGUuQk9PTEVBTl0sIC8vIEFsbG93IGRyb3BwaW5nIG9mIGZpbGVzXG4gICAgYWxsb3dCcm93c2U6IFt0cnVlLCBUeXBlLkJPT0xFQU5dLCAvLyBBbGxvdyBicm93c2luZyB0aGUgZmlsZSBzeXN0ZW1cbiAgICBhbGxvd1Bhc3RlOiBbdHJ1ZSwgVHlwZS5CT09MRUFOXSwgLy8gQWxsb3cgcGFzdGluZyBmaWxlc1xuICAgIGFsbG93TXVsdGlwbGU6IFtmYWxzZSwgVHlwZS5CT09MRUFOXSwgLy8gQWxsb3cgbXVsdGlwbGUgZmlsZXMgKGRpc2FibGVkIGJ5IGRlZmF1bHQsIGFzIG11bHRpcGxlIGF0dHJpYnV0ZSBpcyBhbHNvIHJlcXVpcmVkIG9uIGlucHV0IHRvIGFsbG93IG11bHRpcGxlKVxuICAgIGFsbG93UmVwbGFjZTogW3RydWUsIFR5cGUuQk9PTEVBTl0sIC8vIEFsbG93IGRyb3BwaW5nIGEgZmlsZSBvbiBvdGhlciBmaWxlIHRvIHJlcGxhY2UgaXQgKG9ubHkgd29ya3Mgd2hlbiBtdWx0aXBsZSBpcyBzZXQgdG8gZmFsc2UpXG4gICAgYWxsb3dSZXZlcnQ6IFt0cnVlLCBUeXBlLkJPT0xFQU5dLCAvLyBBbGxvd3MgdXNlciB0byByZXZlcnQgZmlsZSB1cGxvYWRcbiAgICBhbGxvd1JlbW92ZTogW3RydWUsIFR5cGUuQk9PTEVBTl0sIC8vIEFsbG93IHVzZXIgdG8gcmVtb3ZlIGEgZmlsZVxuICAgIGFsbG93UHJvY2VzczogW3RydWUsIFR5cGUuQk9PTEVBTl0sIC8vIEFsbG93cyB1c2VyIHRvIHByb2Nlc3MgYSBmaWxlLCB3aGVuIHNldCB0byBmYWxzZSwgdGhpcyByZW1vdmVzIHRoZSBmaWxlIHVwbG9hZCBidXR0b25cbiAgICBhbGxvd1Jlb3JkZXI6IFtmYWxzZSwgVHlwZS5CT09MRUFOXSwgLy8gQWxsb3cgcmVvcmRlcmluZyBvZiBmaWxlc1xuICAgIGFsbG93RGlyZWN0b3JpZXNPbmx5OiBbZmFsc2UsIFR5cGUuQk9PTEVBTl0sIC8vIEFsbG93IG9ubHkgc2VsZWN0aW5nIGRpcmVjdG9yaWVzIHdpdGggYnJvd3NlIChubyBzdXBwb3J0IGZvciBmaWx0ZXJpbmcgZG5kIGF0IHRoaXMgcG9pbnQpXG5cbiAgICAvLyBSZXZlcnQgbW9kZVxuICAgIGZvcmNlUmV2ZXJ0OiBbZmFsc2UsIFR5cGUuQk9PTEVBTl0sIC8vIFNldCB0byAnZm9yY2UnIHRvIHJlcXVpcmUgdGhlIGZpbGUgdG8gYmUgcmV2ZXJ0ZWQgYmVmb3JlIHJlbW92YWxcblxuICAgIC8vIElucHV0IHJlcXVpcmVtZW50c1xuICAgIG1heEZpbGVzOiBbbnVsbCwgVHlwZS5JTlRdLCAvLyBNYXggbnVtYmVyIG9mIGZpbGVzXG4gICAgY2hlY2tWYWxpZGl0eTogW2ZhbHNlLCBUeXBlLkJPT0xFQU5dLCAvLyBFbmFibGVzIGN1c3RvbSB2YWxpZGl0eSBtZXNzYWdlc1xuXG4gICAgLy8gV2hlcmUgdG8gcHV0IGZpbGVcbiAgICBpdGVtSW5zZXJ0TG9jYXRpb25GcmVlZG9tOiBbdHJ1ZSwgVHlwZS5CT09MRUFOXSwgLy8gU2V0IHRvIGZhbHNlIHRvIGFsd2F5cyBhZGQgaXRlbXMgdG8gYmVnaW4gb3IgZW5kIG9mIGxpc3RcbiAgICBpdGVtSW5zZXJ0TG9jYXRpb246IFsnYmVmb3JlJywgVHlwZS5TVFJJTkddLCAvLyBEZWZhdWx0IGluZGV4IGluIGxpc3QgdG8gYWRkIGl0ZW1zIHRoYXQgaGF2ZSBiZWVuIGRyb3BwZWQgYXQgdGhlIHRvcCBvZiB0aGUgbGlzdFxuICAgIGl0ZW1JbnNlcnRJbnRlcnZhbDogWzc1LCBUeXBlLklOVF0sXG5cbiAgICAvLyBEcmFnICduIERyb3AgcmVsYXRlZFxuICAgIGRyb3BPblBhZ2U6IFtmYWxzZSwgVHlwZS5CT09MRUFOXSwgLy8gQWxsb3cgZHJvcHBpbmcgb2YgZmlsZXMgYW55d2hlcmUgb24gcGFnZSAocHJldmVudHMgYnJvd3NlciBmcm9tIG9wZW5pbmcgZmlsZSBpZiBkcm9wcGVkIG91dHNpZGUgb2YgVXApXG4gICAgZHJvcE9uRWxlbWVudDogW3RydWUsIFR5cGUuQk9PTEVBTl0sIC8vIERyb3AgbmVlZHMgdG8gaGFwcGVuIG9uIGVsZW1lbnQgKHNldCB0byBmYWxzZSB0byBhbHNvIGxvYWQgZHJvcHMgb3V0c2lkZSBvZiBVcClcbiAgICBkcm9wVmFsaWRhdGlvbjogW2ZhbHNlLCBUeXBlLkJPT0xFQU5dLCAvLyBFbmFibGUgb3IgZGlzYWJsZSB2YWxpZGF0aW5nIGZpbGVzIG9uIGRyb3BcbiAgICBpZ25vcmVkRmlsZXM6IFtbJy5kc19zdG9yZScsICd0aHVtYnMuZGInLCAnZGVza3RvcC5pbmknXSwgVHlwZS5BUlJBWV0sXG5cbiAgICAvLyBVcGxvYWQgcmVsYXRlZFxuICAgIGluc3RhbnRVcGxvYWQ6IFt0cnVlLCBUeXBlLkJPT0xFQU5dLCAvLyBTaG91bGQgdXBsb2FkIGZpbGVzIGltbWVkaWF0ZWx5IG9uIGRyb3BcbiAgICBtYXhQYXJhbGxlbFVwbG9hZHM6IFsyLCBUeXBlLklOVF0sIC8vIE1heGltdW0gZmlsZXMgdG8gdXBsb2FkIGluIHBhcmFsbGVsXG5cbiAgICAvLyBDaHVua3NcbiAgICBjaHVua1VwbG9hZHM6IFtmYWxzZSwgVHlwZS5CT09MRUFOXSwgLy8gRW5hYmxlIGNodW5rZWQgdXBsb2Fkc1xuICAgIGNodW5rRm9yY2U6IFtmYWxzZSwgVHlwZS5CT09MRUFOXSwgLy8gRm9yY2UgdXNlIG9mIGNodW5rIHVwbG9hZHMgZXZlbiBmb3IgZmlsZXMgc21hbGxlciB0aGFuIGNodW5rIHNpemVcbiAgICBjaHVua1NpemU6IFs1MDAwMDAwLCBUeXBlLklOVF0sIC8vIFNpemUgb2YgY2h1bmtzICg1TUIgZGVmYXVsdClcbiAgICBjaHVua1JldHJ5RGVsYXlzOiBbWzUwMCwgMTAwMCwgMzAwMF0sIFR5cGUuQXJyYXldLCAvLyBBbW91bnQgb2YgdGltZXMgdG8gcmV0cnkgdXBsb2FkIG9mIGEgY2h1bmsgd2hlbiBpdCBmYWlsc1xuXG4gICAgLy8gVGhlIHNlcnZlciBhcGkgZW5kIHBvaW50cyB0byB1c2UgZm9yIHVwbG9hZGluZyAoc2VlIGRvY3MpXG4gICAgc2VydmVyOiBbbnVsbCwgVHlwZS5TRVJWRVJfQVBJXSxcblxuICAgIC8vIEZpbGUgc2l6ZSBjYWxjdWxhdGlvbnMsIGNhbiBzZXQgdG8gMTAyNCwgdGhpcyBpcyBvbmx5IHVzZWQgZm9yIGRpc3BsYXksIHByb3BlcnRpZXMgdXNlIGZpbGUgc2l6ZSBiYXNlIDEwMDBcbiAgICBmaWxlU2l6ZUJhc2U6IFsxMDAwLCBUeXBlLklOVF0sXG5cbiAgICAvLyBMYWJlbHMgYW5kIHN0YXR1cyBtZXNzYWdlc1xuICAgIGxhYmVsRGVjaW1hbFNlcGFyYXRvcjogW2dldERlY2ltYWxTZXBhcmF0b3IoKSwgVHlwZS5TVFJJTkddLCAvLyBEZWZhdWx0IGlzIGxvY2FsZSBzZXBhcmF0b3JcbiAgICBsYWJlbFRob3VzYW5kc1NlcGFyYXRvcjogW2dldFRob3VzYW5kc1NlcGFyYXRvcigpLCBUeXBlLlNUUklOR10sIC8vIERlZmF1bHQgaXMgbG9jYWxlIHNlcGFyYXRvclxuXG4gICAgbGFiZWxJZGxlOiBbXG4gICAgICAnRHJhZyAmIERyb3AgeW91ciBmaWxlcyBvciA8c3BhbiBjbGFzcz1cImZpbGVwb25kLS1sYWJlbC1hY3Rpb25cIj5Ccm93c2U8L3NwYW4+JyxcbiAgICAgIFR5cGUuU1RSSU5HXG4gICAgXSxcbiAgICBsYWJlbEludmFsaWRGaWVsZDogWydGaWVsZCBjb250YWlucyBpbnZhbGlkIGZpbGVzJywgVHlwZS5TVFJJTkddLFxuICAgIGxhYmVsRmlsZVdhaXRpbmdGb3JTaXplOiBbJ1dhaXRpbmcgZm9yIHNpemUnLCBUeXBlLlNUUklOR10sXG4gICAgbGFiZWxGaWxlU2l6ZU5vdEF2YWlsYWJsZTogWydTaXplIG5vdCBhdmFpbGFibGUnLCBUeXBlLlNUUklOR10sXG4gICAgbGFiZWxGaWxlQ291bnRTaW5ndWxhcjogWydmaWxlIGluIGxpc3QnLCBUeXBlLlNUUklOR10sXG4gICAgbGFiZWxGaWxlQ291bnRQbHVyYWw6IFsnZmlsZXMgaW4gbGlzdCcsIFR5cGUuU1RSSU5HXSxcbiAgICBsYWJlbEZpbGVMb2FkaW5nOiBbJ0xvYWRpbmcnLCBUeXBlLlNUUklOR10sXG4gICAgbGFiZWxGaWxlQWRkZWQ6IFsnQWRkZWQnLCBUeXBlLlNUUklOR10sIC8vIGFzc2lzdGl2ZSBvbmx5XG4gICAgbGFiZWxGaWxlTG9hZEVycm9yOiBbJ0Vycm9yIGR1cmluZyBsb2FkJywgVHlwZS5TVFJJTkddLFxuICAgIGxhYmVsRmlsZVJlbW92ZWQ6IFsnUmVtb3ZlZCcsIFR5cGUuU1RSSU5HXSwgLy8gYXNzaXN0aXZlIG9ubHlcbiAgICBsYWJlbEZpbGVSZW1vdmVFcnJvcjogWydFcnJvciBkdXJpbmcgcmVtb3ZlJywgVHlwZS5TVFJJTkddLFxuICAgIGxhYmVsRmlsZVByb2Nlc3Npbmc6IFsnVXBsb2FkaW5nJywgVHlwZS5TVFJJTkddLFxuICAgIGxhYmVsRmlsZVByb2Nlc3NpbmdDb21wbGV0ZTogWydVcGxvYWQgY29tcGxldGUnLCBUeXBlLlNUUklOR10sXG4gICAgbGFiZWxGaWxlUHJvY2Vzc2luZ0Fib3J0ZWQ6IFsnVXBsb2FkIGNhbmNlbGxlZCcsIFR5cGUuU1RSSU5HXSxcbiAgICBsYWJlbEZpbGVQcm9jZXNzaW5nRXJyb3I6IFsnRXJyb3IgZHVyaW5nIHVwbG9hZCcsIFR5cGUuU1RSSU5HXSxcbiAgICBsYWJlbEZpbGVQcm9jZXNzaW5nUmV2ZXJ0RXJyb3I6IFsnRXJyb3IgZHVyaW5nIHJldmVydCcsIFR5cGUuU1RSSU5HXSxcblxuICAgIGxhYmVsVGFwVG9DYW5jZWw6IFsndGFwIHRvIGNhbmNlbCcsIFR5cGUuU1RSSU5HXSxcbiAgICBsYWJlbFRhcFRvUmV0cnk6IFsndGFwIHRvIHJldHJ5JywgVHlwZS5TVFJJTkddLFxuICAgIGxhYmVsVGFwVG9VbmRvOiBbJ3RhcCB0byB1bmRvJywgVHlwZS5TVFJJTkddLFxuXG4gICAgbGFiZWxCdXR0b25SZW1vdmVJdGVtOiBbJ1JlbW92ZScsIFR5cGUuU1RSSU5HXSxcbiAgICBsYWJlbEJ1dHRvbkFib3J0SXRlbUxvYWQ6IFsnQWJvcnQnLCBUeXBlLlNUUklOR10sXG4gICAgbGFiZWxCdXR0b25SZXRyeUl0ZW1Mb2FkOiBbJ1JldHJ5JywgVHlwZS5TVFJJTkddLFxuICAgIGxhYmVsQnV0dG9uQWJvcnRJdGVtUHJvY2Vzc2luZzogWydDYW5jZWwnLCBUeXBlLlNUUklOR10sXG4gICAgbGFiZWxCdXR0b25VbmRvSXRlbVByb2Nlc3Npbmc6IFsnVW5kbycsIFR5cGUuU1RSSU5HXSxcbiAgICBsYWJlbEJ1dHRvblJldHJ5SXRlbVByb2Nlc3Npbmc6IFsnUmV0cnknLCBUeXBlLlNUUklOR10sXG4gICAgbGFiZWxCdXR0b25Qcm9jZXNzSXRlbTogWydVcGxvYWQnLCBUeXBlLlNUUklOR10sXG5cbiAgICAvLyBtYWtlIHN1cmUgd2lkdGggYW5kIGhlaWdodCBwbHVzIHZpZXdwb3ggYXJlIGV2ZW4gbnVtYmVycyBzbyBpY29ucyBhcmUgbmljZWx5IGNlbnRlcmVkXG4gICAgaWNvblJlbW92ZTogW1xuICAgICAgJzxzdmcgd2lkdGg9XCIyNlwiIGhlaWdodD1cIjI2XCIgdmlld0JveD1cIjAgMCAyNiAyNlwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj48cGF0aCBkPVwiTTExLjU4NiAxM2wtMi4yOTMgMi4yOTNhMSAxIDAgMCAwIDEuNDE0IDEuNDE0TDEzIDE0LjQxNGwyLjI5MyAyLjI5M2ExIDEgMCAwIDAgMS40MTQtMS40MTRMMTQuNDE0IDEzbDIuMjkzLTIuMjkzYTEgMSAwIDAgMC0xLjQxNC0xLjQxNEwxMyAxMS41ODZsLTIuMjkzLTIuMjkzYTEgMSAwIDAgMC0xLjQxNCAxLjQxNEwxMS41ODYgMTN6XCIgZmlsbD1cImN1cnJlbnRDb2xvclwiIGZpbGwtcnVsZT1cIm5vbnplcm9cIi8+PC9zdmc+JyxcbiAgICAgIFR5cGUuU1RSSU5HXG4gICAgXSxcblxuICAgIGljb25Qcm9jZXNzOiBbXG4gICAgICAnPHN2ZyB3aWR0aD1cIjI2XCIgaGVpZ2h0PVwiMjZcIiB2aWV3Qm94PVwiMCAwIDI2IDI2XCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPjxwYXRoIGQ9XCJNMTQgMTAuNDE0djMuNTg1YTEgMSAwIDAgMS0yIDB2LTMuNTg1bC0xLjI5MyAxLjI5M2ExIDEgMCAwIDEtMS40MTQtMS40MTVsMy0zYTEgMSAwIDAgMSAxLjQxNCAwbDMgM2ExIDEgMCAwIDEtMS40MTQgMS40MTVMMTQgMTAuNDE0ek05IDE4YTEgMSAwIDAgMSAwLTJoOGExIDEgMCAwIDEgMCAySDl6XCIgZmlsbD1cImN1cnJlbnRDb2xvclwiIGZpbGwtcnVsZT1cImV2ZW5vZGRcIi8+PC9zdmc+JyxcbiAgICAgIFR5cGUuU1RSSU5HXG4gICAgXSxcblxuICAgIGljb25SZXRyeTogW1xuICAgICAgJzxzdmcgd2lkdGg9XCIyNlwiIGhlaWdodD1cIjI2XCIgdmlld0JveD1cIjAgMCAyNiAyNlwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj48cGF0aCBkPVwiTTEwLjgxIDkuMTg1bC0uMDM4LjAyQTQuOTk3IDQuOTk3IDAgMCAwIDggMTMuNjgzYTUgNSAwIDAgMCA1IDUgNSA1IDAgMCAwIDUtNSAxIDEgMCAwIDEgMiAwQTcgNyAwIDEgMSA5LjcyMiA3LjQ5NmwtLjg0Mi0uMjFhLjk5OS45OTkgMCAxIDEgLjQ4NC0xLjk0bDMuMjMuODA2Yy41MzUuMTMzLjg2LjY3NS43MyAxLjIxbC0uODA0IDMuMjMzYS45OTcuOTk3IDAgMCAxLTEuMjEuNzMuOTk3Ljk5NyAwIDAgMS0uNzMtMS4yMWwuMjMtLjkyOHYtLjAwMnpcIiBmaWxsPVwiY3VycmVudENvbG9yXCIgZmlsbC1ydWxlPVwibm9uemVyb1wiLz48L3N2Zz4nLFxuICAgICAgVHlwZS5TVFJJTkdcbiAgICBdLFxuXG4gICAgaWNvblVuZG86IFtcbiAgICAgICc8c3ZnIHdpZHRoPVwiMjZcIiBoZWlnaHQ9XCIyNlwiIHZpZXdCb3g9XCIwIDAgMjYgMjZcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI+PHBhdGggZD1cIk05LjE4NSAxMC44MWwuMDItLjAzOEE0Ljk5NyA0Ljk5NyAwIDAgMSAxMy42ODMgOGE1IDUgMCAwIDEgNSA1IDUgNSAwIDAgMS01IDUgMSAxIDAgMCAwIDAgMkE3IDcgMCAxIDAgNy40OTYgOS43MjJsLS4yMS0uODQyYS45OTkuOTk5IDAgMSAwLTEuOTQuNDg0bC44MDYgMy4yM2MuMTMzLjUzNS42NzUuODYgMS4yMS43M2wzLjIzMy0uODAzYS45OTcuOTk3IDAgMCAwIC43My0xLjIxLjk5Ny45OTcgMCAwIDAtMS4yMS0uNzNsLS45MjguMjMtLjAwMi0uMDAxelwiIGZpbGw9XCJjdXJyZW50Q29sb3JcIiBmaWxsLXJ1bGU9XCJub256ZXJvXCIvPjwvc3ZnPicsXG4gICAgICBUeXBlLlNUUklOR1xuICAgIF0sXG5cbiAgICBpY29uRG9uZTogW1xuICAgICAgJzxzdmcgd2lkdGg9XCIyNlwiIGhlaWdodD1cIjI2XCIgdmlld0JveD1cIjAgMCAyNiAyNlwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj48cGF0aCBkPVwiTTE4LjI5MyA5LjI5M2ExIDEgMCAwIDEgMS40MTQgMS40MTRsLTcuMDAyIDdhMSAxIDAgMCAxLTEuNDE0IDBsLTMuOTk4LTRhMSAxIDAgMSAxIDEuNDE0LTEuNDE0TDEyIDE1LjU4Nmw2LjI5NC02LjI5M3pcIiBmaWxsPVwiY3VycmVudENvbG9yXCIgZmlsbC1ydWxlPVwibm9uemVyb1wiLz48L3N2Zz4nLFxuICAgICAgVHlwZS5TVFJJTkdcbiAgICBdLFxuXG4gICAgLy8gZXZlbnQgaGFuZGxlcnNcbiAgICBvbmluaXQ6IFtudWxsLCBUeXBlLkZVTkNUSU9OXSxcbiAgICBvbndhcm5pbmc6IFtudWxsLCBUeXBlLkZVTkNUSU9OXSxcbiAgICBvbmVycm9yOiBbbnVsbCwgVHlwZS5GVU5DVElPTl0sXG4gICAgb25hY3RpdmF0ZWZpbGU6IFtudWxsLCBUeXBlLkZVTkNUSU9OXSxcbiAgICBvbmluaXRmaWxlOiBbbnVsbCwgVHlwZS5GVU5DVElPTl0sXG4gICAgb25hZGRmaWxlc3RhcnQ6IFtudWxsLCBUeXBlLkZVTkNUSU9OXSxcbiAgICBvbmFkZGZpbGVwcm9ncmVzczogW251bGwsIFR5cGUuRlVOQ1RJT05dLFxuICAgIG9uYWRkZmlsZTogW251bGwsIFR5cGUuRlVOQ1RJT05dLFxuICAgIG9ucHJvY2Vzc2ZpbGVzdGFydDogW251bGwsIFR5cGUuRlVOQ1RJT05dLFxuICAgIG9ucHJvY2Vzc2ZpbGVwcm9ncmVzczogW251bGwsIFR5cGUuRlVOQ1RJT05dLFxuICAgIG9ucHJvY2Vzc2ZpbGVhYm9ydDogW251bGwsIFR5cGUuRlVOQ1RJT05dLFxuICAgIG9ucHJvY2Vzc2ZpbGVyZXZlcnQ6IFtudWxsLCBUeXBlLkZVTkNUSU9OXSxcbiAgICBvbnByb2Nlc3NmaWxlOiBbbnVsbCwgVHlwZS5GVU5DVElPTl0sXG4gICAgb25wcm9jZXNzZmlsZXM6IFtudWxsLCBUeXBlLkZVTkNUSU9OXSxcbiAgICBvbnJlbW92ZWZpbGU6IFtudWxsLCBUeXBlLkZVTkNUSU9OXSxcbiAgICBvbnByZXBhcmVmaWxlOiBbbnVsbCwgVHlwZS5GVU5DVElPTl0sXG4gICAgb251cGRhdGVmaWxlczogW251bGwsIFR5cGUuRlVOQ1RJT05dLFxuICAgIG9ucmVvcmRlcmZpbGVzOiBbbnVsbCwgVHlwZS5GVU5DVElPTl0sXG5cbiAgICAvLyBob29rc1xuICAgIGJlZm9yZURyb3BGaWxlOiBbbnVsbCwgVHlwZS5GVU5DVElPTl0sXG4gICAgYmVmb3JlQWRkRmlsZTogW251bGwsIFR5cGUuRlVOQ1RJT05dLFxuICAgIGJlZm9yZVJlbW92ZUZpbGU6IFtudWxsLCBUeXBlLkZVTkNUSU9OXSxcbiAgICBiZWZvcmVQcmVwYXJlRmlsZTogW251bGwsIFR5cGUuRlVOQ1RJT05dLFxuXG4gICAgLy8gc3R5bGVzXG4gICAgc3R5bGVQYW5lbExheW91dDogW251bGwsIFR5cGUuU1RSSU5HXSwgLy8gbnVsbCAnaW50ZWdyYXRlZCcsICdjb21wYWN0JywgJ2NpcmNsZSdcbiAgICBzdHlsZVBhbmVsQXNwZWN0UmF0aW86IFtudWxsLCBUeXBlLlNUUklOR10sIC8vIG51bGwgb3IgJzM6Micgb3IgMVxuICAgIHN0eWxlSXRlbVBhbmVsQXNwZWN0UmF0aW86IFtudWxsLCBUeXBlLlNUUklOR10sXG4gICAgc3R5bGVCdXR0b25SZW1vdmVJdGVtUG9zaXRpb246IFsnbGVmdCcsIFR5cGUuU1RSSU5HXSxcbiAgICBzdHlsZUJ1dHRvblByb2Nlc3NJdGVtUG9zaXRpb246IFsncmlnaHQnLCBUeXBlLlNUUklOR10sXG4gICAgc3R5bGVMb2FkSW5kaWNhdG9yUG9zaXRpb246IFsncmlnaHQnLCBUeXBlLlNUUklOR10sXG4gICAgc3R5bGVQcm9ncmVzc0luZGljYXRvclBvc2l0aW9uOiBbJ3JpZ2h0JywgVHlwZS5TVFJJTkddLFxuICAgIHN0eWxlQnV0dG9uUmVtb3ZlSXRlbUFsaWduOiBbZmFsc2UsIFR5cGUuQk9PTEVBTl0sXG5cbiAgICAvLyBjdXN0b20gaW5pdGlhbCBmaWxlcyBhcnJheVxuICAgIGZpbGVzOiBbW10sIFR5cGUuQVJSQVldLFxuXG4gICAgLy8gc2hvdyBzdXBwb3J0IGJ5IGRpc3BsYXlpbmcgY3JlZGl0c1xuICAgIGNyZWRpdHM6IFtbJ2h0dHBzOi8vcHFpbmEubmwvJywgJ1Bvd2VyZWQgYnkgUFFJTkEnXSwgVHlwZS5BUlJBWV1cbiAgfTtcblxuICB2YXIgZ2V0SXRlbUJ5UXVlcnkgPSBmdW5jdGlvbiBnZXRJdGVtQnlRdWVyeShpdGVtcywgcXVlcnkpIHtcbiAgICAvLyBqdXN0IHJldHVybiBmaXJzdCBpbmRleFxuICAgIGlmIChpc0VtcHR5KHF1ZXJ5KSkge1xuICAgICAgcmV0dXJuIGl0ZW1zWzBdIHx8IG51bGw7XG4gICAgfVxuXG4gICAgLy8gcXVlcnkgaXMgaW5kZXhcbiAgICBpZiAoaXNJbnQocXVlcnkpKSB7XG4gICAgICByZXR1cm4gaXRlbXNbcXVlcnldIHx8IG51bGw7XG4gICAgfVxuXG4gICAgLy8gaWYgcXVlcnkgaXMgaXRlbSwgZ2V0IHRoZSBpZFxuICAgIGlmICh0eXBlb2YgcXVlcnkgPT09ICdvYmplY3QnKSB7XG4gICAgICBxdWVyeSA9IHF1ZXJ5LmlkO1xuICAgIH1cblxuICAgIC8vIGFzc3VtZSBxdWVyeSBpcyBhIHN0cmluZyBhbmQgcmV0dXJuIGl0ZW0gYnkgaWRcbiAgICByZXR1cm4gKFxuICAgICAgaXRlbXMuZmluZChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgIHJldHVybiBpdGVtLmlkID09PSBxdWVyeTtcbiAgICAgIH0pIHx8IG51bGxcbiAgICApO1xuICB9O1xuXG4gIHZhciBnZXROdW1lcmljQXNwZWN0UmF0aW9Gcm9tU3RyaW5nID0gZnVuY3Rpb24gZ2V0TnVtZXJpY0FzcGVjdFJhdGlvRnJvbVN0cmluZyhcbiAgICBhc3BlY3RSYXRpb1xuICApIHtcbiAgICBpZiAoaXNFbXB0eShhc3BlY3RSYXRpbykpIHtcbiAgICAgIHJldHVybiBhc3BlY3RSYXRpbztcbiAgICB9XG4gICAgaWYgKC86Ly50ZXN0KGFzcGVjdFJhdGlvKSkge1xuICAgICAgdmFyIHBhcnRzID0gYXNwZWN0UmF0aW8uc3BsaXQoJzonKTtcbiAgICAgIHJldHVybiBwYXJ0c1sxXSAvIHBhcnRzWzBdO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VGbG9hdChhc3BlY3RSYXRpbyk7XG4gIH07XG5cbiAgdmFyIGdldEFjdGl2ZUl0ZW1zID0gZnVuY3Rpb24gZ2V0QWN0aXZlSXRlbXMoaXRlbXMpIHtcbiAgICByZXR1cm4gaXRlbXMuZmlsdGVyKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgIHJldHVybiAhaXRlbS5hcmNoaXZlZDtcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgU3RhdHVzID0ge1xuICAgIEVNUFRZOiAwLFxuICAgIElETEU6IDEsIC8vIHdhaXRpbmdcbiAgICBFUlJPUjogMiwgLy8gYSBmaWxlIGlzIGluIGVycm9yIHN0YXRlXG4gICAgQlVTWTogMywgLy8gYnVzeSBwcm9jZXNzaW5nIG9yIGxvYWRpbmdcbiAgICBSRUFEWTogNCAvLyBhbGwgZmlsZXMgdXBsb2FkZWRcbiAgfTtcblxuICB2YXIgSVRFTV9FUlJPUiA9IFtcbiAgICBJdGVtU3RhdHVzLkxPQURfRVJST1IsXG4gICAgSXRlbVN0YXR1cy5QUk9DRVNTSU5HX0VSUk9SLFxuICAgIEl0ZW1TdGF0dXMuUFJPQ0VTU0lOR19SRVZFUlRfRVJST1JcbiAgXTtcbiAgdmFyIElURU1fQlVTWSA9IFtcbiAgICBJdGVtU3RhdHVzLkxPQURJTkcsXG4gICAgSXRlbVN0YXR1cy5QUk9DRVNTSU5HLFxuICAgIEl0ZW1TdGF0dXMuUFJPQ0VTU0lOR19RVUVVRUQsXG4gICAgSXRlbVN0YXR1cy5JTklUXG4gIF07XG4gIHZhciBJVEVNX1JFQURZID0gW0l0ZW1TdGF0dXMuUFJPQ0VTU0lOR19DT01QTEVURV07XG5cbiAgdmFyIGlzSXRlbUluRXJyb3JTdGF0ZSA9IGZ1bmN0aW9uIGlzSXRlbUluRXJyb3JTdGF0ZShpdGVtKSB7XG4gICAgcmV0dXJuIElURU1fRVJST1IuaW5jbHVkZXMoaXRlbS5zdGF0dXMpO1xuICB9O1xuICB2YXIgaXNJdGVtSW5CdXN5U3RhdGUgPSBmdW5jdGlvbiBpc0l0ZW1JbkJ1c3lTdGF0ZShpdGVtKSB7XG4gICAgcmV0dXJuIElURU1fQlVTWS5pbmNsdWRlcyhpdGVtLnN0YXR1cyk7XG4gIH07XG4gIHZhciBpc0l0ZW1JblJlYWR5U3RhdGUgPSBmdW5jdGlvbiBpc0l0ZW1JblJlYWR5U3RhdGUoaXRlbSkge1xuICAgIHJldHVybiBJVEVNX1JFQURZLmluY2x1ZGVzKGl0ZW0uc3RhdHVzKTtcbiAgfTtcblxuICB2YXIgcXVlcmllcyA9IGZ1bmN0aW9uIHF1ZXJpZXMoc3RhdGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgR0VUX1NUQVRVUzogZnVuY3Rpb24gR0VUX1NUQVRVUygpIHtcbiAgICAgICAgdmFyIGl0ZW1zID0gZ2V0QWN0aXZlSXRlbXMoc3RhdGUuaXRlbXMpO1xuICAgICAgICB2YXIgRU1QVFkgPSBTdGF0dXMuRU1QVFksXG4gICAgICAgICAgRVJST1IgPSBTdGF0dXMuRVJST1IsXG4gICAgICAgICAgQlVTWSA9IFN0YXR1cy5CVVNZLFxuICAgICAgICAgIElETEUgPSBTdGF0dXMuSURMRSxcbiAgICAgICAgICBSRUFEWSA9IFN0YXR1cy5SRUFEWTtcblxuICAgICAgICBpZiAoaXRlbXMubGVuZ3RoID09PSAwKSByZXR1cm4gRU1QVFk7XG5cbiAgICAgICAgaWYgKGl0ZW1zLnNvbWUoaXNJdGVtSW5FcnJvclN0YXRlKSkgcmV0dXJuIEVSUk9SO1xuXG4gICAgICAgIGlmIChpdGVtcy5zb21lKGlzSXRlbUluQnVzeVN0YXRlKSkgcmV0dXJuIEJVU1k7XG5cbiAgICAgICAgaWYgKGl0ZW1zLnNvbWUoaXNJdGVtSW5SZWFkeVN0YXRlKSkgcmV0dXJuIFJFQURZO1xuXG4gICAgICAgIHJldHVybiBJRExFO1xuICAgICAgfSxcblxuICAgICAgR0VUX0lURU06IGZ1bmN0aW9uIEdFVF9JVEVNKHF1ZXJ5KSB7XG4gICAgICAgIHJldHVybiBnZXRJdGVtQnlRdWVyeShzdGF0ZS5pdGVtcywgcXVlcnkpO1xuICAgICAgfSxcblxuICAgICAgR0VUX0FDVElWRV9JVEVNOiBmdW5jdGlvbiBHRVRfQUNUSVZFX0lURU0ocXVlcnkpIHtcbiAgICAgICAgcmV0dXJuIGdldEl0ZW1CeVF1ZXJ5KGdldEFjdGl2ZUl0ZW1zKHN0YXRlLml0ZW1zKSwgcXVlcnkpO1xuICAgICAgfSxcblxuICAgICAgR0VUX0FDVElWRV9JVEVNUzogZnVuY3Rpb24gR0VUX0FDVElWRV9JVEVNUygpIHtcbiAgICAgICAgcmV0dXJuIGdldEFjdGl2ZUl0ZW1zKHN0YXRlLml0ZW1zKTtcbiAgICAgIH0sXG5cbiAgICAgIEdFVF9JVEVNUzogZnVuY3Rpb24gR0VUX0lURU1TKCkge1xuICAgICAgICByZXR1cm4gc3RhdGUuaXRlbXM7XG4gICAgICB9LFxuXG4gICAgICBHRVRfSVRFTV9OQU1FOiBmdW5jdGlvbiBHRVRfSVRFTV9OQU1FKHF1ZXJ5KSB7XG4gICAgICAgIHZhciBpdGVtID0gZ2V0SXRlbUJ5UXVlcnkoc3RhdGUuaXRlbXMsIHF1ZXJ5KTtcbiAgICAgICAgcmV0dXJuIGl0ZW0gPyBpdGVtLmZpbGVuYW1lIDogbnVsbDtcbiAgICAgIH0sXG5cbiAgICAgIEdFVF9JVEVNX1NJWkU6IGZ1bmN0aW9uIEdFVF9JVEVNX1NJWkUocXVlcnkpIHtcbiAgICAgICAgdmFyIGl0ZW0gPSBnZXRJdGVtQnlRdWVyeShzdGF0ZS5pdGVtcywgcXVlcnkpO1xuICAgICAgICByZXR1cm4gaXRlbSA/IGl0ZW0uZmlsZVNpemUgOiBudWxsO1xuICAgICAgfSxcblxuICAgICAgR0VUX1NUWUxFUzogZnVuY3Rpb24gR0VUX1NUWUxFUygpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHN0YXRlLm9wdGlvbnMpXG4gICAgICAgICAgLmZpbHRlcihmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiAvXnN0eWxlLy50ZXN0KGtleSk7XG4gICAgICAgICAgfSlcbiAgICAgICAgICAubWFwKGZ1bmN0aW9uKG9wdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgbmFtZTogb3B0aW9uLFxuICAgICAgICAgICAgICB2YWx1ZTogc3RhdGUub3B0aW9uc1tvcHRpb25dXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pO1xuICAgICAgfSxcblxuICAgICAgR0VUX1BBTkVMX0FTUEVDVF9SQVRJTzogZnVuY3Rpb24gR0VUX1BBTkVMX0FTUEVDVF9SQVRJTygpIHtcbiAgICAgICAgdmFyIGlzU2hhcGVDaXJjbGUgPSAvY2lyY2xlLy50ZXN0KHN0YXRlLm9wdGlvbnMuc3R5bGVQYW5lbExheW91dCk7XG4gICAgICAgIHZhciBhc3BlY3RSYXRpbyA9IGlzU2hhcGVDaXJjbGVcbiAgICAgICAgICA/IDFcbiAgICAgICAgICA6IGdldE51bWVyaWNBc3BlY3RSYXRpb0Zyb21TdHJpbmcoXG4gICAgICAgICAgICAgIHN0YXRlLm9wdGlvbnMuc3R5bGVQYW5lbEFzcGVjdFJhdGlvXG4gICAgICAgICAgICApO1xuICAgICAgICByZXR1cm4gYXNwZWN0UmF0aW87XG4gICAgICB9LFxuXG4gICAgICBHRVRfSVRFTV9QQU5FTF9BU1BFQ1RfUkFUSU86IGZ1bmN0aW9uIEdFVF9JVEVNX1BBTkVMX0FTUEVDVF9SQVRJTygpIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlLm9wdGlvbnMuc3R5bGVJdGVtUGFuZWxBc3BlY3RSYXRpbztcbiAgICAgIH0sXG5cbiAgICAgIEdFVF9JVEVNU19CWV9TVEFUVVM6IGZ1bmN0aW9uIEdFVF9JVEVNU19CWV9TVEFUVVMoc3RhdHVzKSB7XG4gICAgICAgIHJldHVybiBnZXRBY3RpdmVJdGVtcyhzdGF0ZS5pdGVtcykuZmlsdGVyKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICByZXR1cm4gaXRlbS5zdGF0dXMgPT09IHN0YXR1cztcbiAgICAgICAgfSk7XG4gICAgICB9LFxuXG4gICAgICBHRVRfVE9UQUxfSVRFTVM6IGZ1bmN0aW9uIEdFVF9UT1RBTF9JVEVNUygpIHtcbiAgICAgICAgcmV0dXJuIGdldEFjdGl2ZUl0ZW1zKHN0YXRlLml0ZW1zKS5sZW5ndGg7XG4gICAgICB9LFxuXG4gICAgICBJU19BU1lOQzogZnVuY3Rpb24gSVNfQVNZTkMoKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgaXNPYmplY3Qoc3RhdGUub3B0aW9ucy5zZXJ2ZXIpICYmXG4gICAgICAgICAgKGlzT2JqZWN0KHN0YXRlLm9wdGlvbnMuc2VydmVyLnByb2Nlc3MpIHx8XG4gICAgICAgICAgICBpc0Z1bmN0aW9uKHN0YXRlLm9wdGlvbnMuc2VydmVyLnByb2Nlc3MpKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgdmFyIGhhc1Jvb21Gb3JJdGVtID0gZnVuY3Rpb24gaGFzUm9vbUZvckl0ZW0oc3RhdGUpIHtcbiAgICB2YXIgY291bnQgPSBnZXRBY3RpdmVJdGVtcyhzdGF0ZS5pdGVtcykubGVuZ3RoO1xuXG4gICAgLy8gaWYgY2Fubm90IGhhdmUgbXVsdGlwbGUgaXRlbXMsIHRvIGFkZCBvbmUgaXRlbSBpdCBzaG91bGQgY3VycmVudGx5IG5vdCBjb250YWluIGl0ZW1zXG4gICAgaWYgKCFzdGF0ZS5vcHRpb25zLmFsbG93TXVsdGlwbGUpIHtcbiAgICAgIHJldHVybiBjb3VudCA9PT0gMDtcbiAgICB9XG5cbiAgICAvLyBpZiBhbGxvd3MgbXVsdGlwbGUgaXRlbXMsIHdlIGNoZWNrIGlmIGEgbWF4IGl0ZW0gY291bnQgaGFzIGJlZW4gc2V0LCBpZiBub3QsIHRoZXJlJ3Mgbm8gbGltaXRcbiAgICB2YXIgbWF4RmlsZUNvdW50ID0gc3RhdGUub3B0aW9ucy5tYXhGaWxlcztcbiAgICBpZiAobWF4RmlsZUNvdW50ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyB3ZSBjaGVjayBpZiB0aGUgY3VycmVudCBjb3VudCBpcyBzbWFsbGVyIHRoYW4gdGhlIG1heCBjb3VudCwgaWYgc28sIGFub3RoZXIgZmlsZSBjYW4gc3RpbGwgYmUgYWRkZWRcbiAgICBpZiAoY291bnQgPCBtYXhGaWxlQ291bnQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIG5vIG1vcmUgcm9vbSBmb3IgYW5vdGhlciBmaWxlXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIHZhciBsaW1pdCA9IGZ1bmN0aW9uIGxpbWl0KHZhbHVlLCBtaW4sIG1heCkge1xuICAgIHJldHVybiBNYXRoLm1heChNYXRoLm1pbihtYXgsIHZhbHVlKSwgbWluKTtcbiAgfTtcblxuICB2YXIgYXJyYXlJbnNlcnQgPSBmdW5jdGlvbiBhcnJheUluc2VydChhcnIsIGluZGV4LCBpdGVtKSB7XG4gICAgcmV0dXJuIGFyci5zcGxpY2UoaW5kZXgsIDAsIGl0ZW0pO1xuICB9O1xuXG4gIHZhciBpbnNlcnRJdGVtID0gZnVuY3Rpb24gaW5zZXJ0SXRlbShpdGVtcywgaXRlbSwgaW5kZXgpIHtcbiAgICBpZiAoaXNFbXB0eShpdGVtKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gaWYgaW5kZXggaXMgdW5kZWZpbmVkLCBhcHBlbmRcbiAgICBpZiAodHlwZW9mIGluZGV4ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgaXRlbXMucHVzaChpdGVtKTtcbiAgICAgIHJldHVybiBpdGVtO1xuICAgIH1cblxuICAgIC8vIGxpbWl0IHRoZSBpbmRleCB0byB0aGUgc2l6ZSBvZiB0aGUgaXRlbXMgYXJyYXlcbiAgICBpbmRleCA9IGxpbWl0KGluZGV4LCAwLCBpdGVtcy5sZW5ndGgpO1xuXG4gICAgLy8gYWRkIGl0ZW0gdG8gYXJyYXlcbiAgICBhcnJheUluc2VydChpdGVtcywgaW5kZXgsIGl0ZW0pO1xuXG4gICAgLy8gZXhwb3NlXG4gICAgcmV0dXJuIGl0ZW07XG4gIH07XG5cbiAgdmFyIGlzQmFzZTY0RGF0YVVSSSA9IGZ1bmN0aW9uIGlzQmFzZTY0RGF0YVVSSShzdHIpIHtcbiAgICByZXR1cm4gL15cXHMqZGF0YTooW2Etel0rXFwvW2EtejAtOS0rLl0rKDtbYS16LV0rPVthLXowLTktXSspPyk/KDtiYXNlNjQpPywoW2EtejAtOSEkJicsKCkqKzs9XFwtLl9+OkBcXC8/JVxcc10qKVxccyokL2kudGVzdChcbiAgICAgIHN0clxuICAgICk7XG4gIH07XG5cbiAgdmFyIGdldEZpbGVuYW1lRnJvbVVSTCA9IGZ1bmN0aW9uIGdldEZpbGVuYW1lRnJvbVVSTCh1cmwpIHtcbiAgICByZXR1cm4gdXJsXG4gICAgICAuc3BsaXQoJy8nKVxuICAgICAgLnBvcCgpXG4gICAgICAuc3BsaXQoJz8nKVxuICAgICAgLnNoaWZ0KCk7XG4gIH07XG5cbiAgdmFyIGdldEV4dGVuc2lvbkZyb21GaWxlbmFtZSA9IGZ1bmN0aW9uIGdldEV4dGVuc2lvbkZyb21GaWxlbmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIG5hbWUuc3BsaXQoJy4nKS5wb3AoKTtcbiAgfTtcblxuICB2YXIgZ3Vlc3N0aW1hdGVFeHRlbnNpb24gPSBmdW5jdGlvbiBndWVzc3RpbWF0ZUV4dGVuc2lvbih0eXBlKSB7XG4gICAgLy8gaWYgbm8gZXh0ZW5zaW9uIHN1cHBsaWVkLCBleGl0IGhlcmVcbiAgICBpZiAodHlwZW9mIHR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgLy8gZ2V0IHN1YnR5cGVcbiAgICB2YXIgc3VidHlwZSA9IHR5cGUuc3BsaXQoJy8nKS5wb3AoKTtcblxuICAgIC8vIGlzIHN2ZyBzdWJ0eXBlXG4gICAgaWYgKC9zdmcvLnRlc3Qoc3VidHlwZSkpIHtcbiAgICAgIHJldHVybiAnc3ZnJztcbiAgICB9XG5cbiAgICBpZiAoL3ppcHxjb21wcmVzc2VkLy50ZXN0KHN1YnR5cGUpKSB7XG4gICAgICByZXR1cm4gJ3ppcCc7XG4gICAgfVxuXG4gICAgaWYgKC9wbGFpbi8udGVzdChzdWJ0eXBlKSkge1xuICAgICAgcmV0dXJuICd0eHQnO1xuICAgIH1cblxuICAgIGlmICgvbXN3b3JkLy50ZXN0KHN1YnR5cGUpKSB7XG4gICAgICByZXR1cm4gJ2RvYyc7XG4gICAgfVxuXG4gICAgLy8gaWYgaXMgdmFsaWQgc3VidHlwZVxuICAgIGlmICgvW2Etel0rLy50ZXN0KHN1YnR5cGUpKSB7XG4gICAgICAvLyBhbHdheXMgdXNlIGpwZyBleHRlbnNpb25cbiAgICAgIGlmIChzdWJ0eXBlID09PSAnanBlZycpIHtcbiAgICAgICAgcmV0dXJuICdqcGcnO1xuICAgICAgfVxuXG4gICAgICAvLyByZXR1cm4gc3VidHlwZVxuICAgICAgcmV0dXJuIHN1YnR5cGU7XG4gICAgfVxuXG4gICAgcmV0dXJuICcnO1xuICB9O1xuXG4gIHZhciBsZWZ0UGFkID0gZnVuY3Rpb24gbGVmdFBhZCh2YWx1ZSkge1xuICAgIHZhciBwYWRkaW5nID1cbiAgICAgIGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJyc7XG4gICAgcmV0dXJuIChwYWRkaW5nICsgdmFsdWUpLnNsaWNlKC1wYWRkaW5nLmxlbmd0aCk7XG4gIH07XG5cbiAgdmFyIGdldERhdGVTdHJpbmcgPSBmdW5jdGlvbiBnZXREYXRlU3RyaW5nKCkge1xuICAgIHZhciBkYXRlID1cbiAgICAgIGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkXG4gICAgICAgID8gYXJndW1lbnRzWzBdXG4gICAgICAgIDogbmV3IERhdGUoKTtcbiAgICByZXR1cm4gKFxuICAgICAgZGF0ZS5nZXRGdWxsWWVhcigpICtcbiAgICAgICctJyArXG4gICAgICBsZWZ0UGFkKGRhdGUuZ2V0TW9udGgoKSArIDEsICcwMCcpICtcbiAgICAgICctJyArXG4gICAgICBsZWZ0UGFkKGRhdGUuZ2V0RGF0ZSgpLCAnMDAnKSArXG4gICAgICAnXycgK1xuICAgICAgbGVmdFBhZChkYXRlLmdldEhvdXJzKCksICcwMCcpICtcbiAgICAgICctJyArXG4gICAgICBsZWZ0UGFkKGRhdGUuZ2V0TWludXRlcygpLCAnMDAnKSArXG4gICAgICAnLScgK1xuICAgICAgbGVmdFBhZChkYXRlLmdldFNlY29uZHMoKSwgJzAwJylcbiAgICApO1xuICB9O1xuXG4gIHZhciBnZXRGaWxlRnJvbUJsb2IgPSBmdW5jdGlvbiBnZXRGaWxlRnJvbUJsb2IoYmxvYiwgZmlsZW5hbWUpIHtcbiAgICB2YXIgdHlwZSA9XG4gICAgICBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IG51bGw7XG4gICAgdmFyIGV4dGVuc2lvbiA9XG4gICAgICBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IG51bGw7XG4gICAgdmFyIGZpbGUgPVxuICAgICAgdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnXG4gICAgICAgID8gYmxvYi5zbGljZSgwLCBibG9iLnNpemUsIHR5cGUpXG4gICAgICAgIDogYmxvYi5zbGljZSgwLCBibG9iLnNpemUsIGJsb2IudHlwZSk7XG4gICAgZmlsZS5sYXN0TW9kaWZpZWREYXRlID0gbmV3IERhdGUoKTtcblxuICAgIC8vIGNvcHkgcmVsYXRpdmUgcGF0aFxuICAgIGlmIChibG9iLl9yZWxhdGl2ZVBhdGgpIGZpbGUuX3JlbGF0aXZlUGF0aCA9IGJsb2IuX3JlbGF0aXZlUGF0aDtcblxuICAgIC8vIGlmIGJsb2IgaGFzIG5hbWUgcHJvcGVydHksIHVzZSBhcyBmaWxlbmFtZSBpZiBubyBmaWxlbmFtZSBzdXBwbGllZFxuICAgIGlmICghaXNTdHJpbmcoZmlsZW5hbWUpKSB7XG4gICAgICBmaWxlbmFtZSA9IGdldERhdGVTdHJpbmcoKTtcbiAgICB9XG5cbiAgICAvLyBpZiBmaWxlbmFtZSBzdXBwbGllZCBidXQgbm8gZXh0ZW5zaW9uIGFuZCBmaWxlbmFtZSBoYXMgZXh0ZW5zaW9uXG4gICAgaWYgKGZpbGVuYW1lICYmIGV4dGVuc2lvbiA9PT0gbnVsbCAmJiBnZXRFeHRlbnNpb25Gcm9tRmlsZW5hbWUoZmlsZW5hbWUpKSB7XG4gICAgICBmaWxlLm5hbWUgPSBmaWxlbmFtZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXh0ZW5zaW9uID0gZXh0ZW5zaW9uIHx8IGd1ZXNzdGltYXRlRXh0ZW5zaW9uKGZpbGUudHlwZSk7XG4gICAgICBmaWxlLm5hbWUgPSBmaWxlbmFtZSArIChleHRlbnNpb24gPyAnLicgKyBleHRlbnNpb24gOiAnJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpbGU7XG4gIH07XG5cbiAgdmFyIGdldEJsb2JCdWlsZGVyID0gZnVuY3Rpb24gZ2V0QmxvYkJ1aWxkZXIoKSB7XG4gICAgcmV0dXJuICh3aW5kb3cuQmxvYkJ1aWxkZXIgPVxuICAgICAgd2luZG93LkJsb2JCdWlsZGVyIHx8XG4gICAgICB3aW5kb3cuV2ViS2l0QmxvYkJ1aWxkZXIgfHxcbiAgICAgIHdpbmRvdy5Nb3pCbG9iQnVpbGRlciB8fFxuICAgICAgd2luZG93Lk1TQmxvYkJ1aWxkZXIpO1xuICB9O1xuXG4gIHZhciBjcmVhdGVCbG9iID0gZnVuY3Rpb24gY3JlYXRlQmxvYihhcnJheUJ1ZmZlciwgbWltZVR5cGUpIHtcbiAgICB2YXIgQkIgPSBnZXRCbG9iQnVpbGRlcigpO1xuXG4gICAgaWYgKEJCKSB7XG4gICAgICB2YXIgYmIgPSBuZXcgQkIoKTtcbiAgICAgIGJiLmFwcGVuZChhcnJheUJ1ZmZlcik7XG4gICAgICByZXR1cm4gYmIuZ2V0QmxvYihtaW1lVHlwZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBCbG9iKFthcnJheUJ1ZmZlcl0sIHtcbiAgICAgIHR5cGU6IG1pbWVUeXBlXG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIGdldEJsb2JGcm9tQnl0ZVN0cmluZ1dpdGhNaW1lVHlwZSA9IGZ1bmN0aW9uIGdldEJsb2JGcm9tQnl0ZVN0cmluZ1dpdGhNaW1lVHlwZShcbiAgICBieXRlU3RyaW5nLFxuICAgIG1pbWVUeXBlXG4gICkge1xuICAgIHZhciBhYiA9IG5ldyBBcnJheUJ1ZmZlcihieXRlU3RyaW5nLmxlbmd0aCk7XG4gICAgdmFyIGlhID0gbmV3IFVpbnQ4QXJyYXkoYWIpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlU3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpYVtpXSA9IGJ5dGVTdHJpbmcuY2hhckNvZGVBdChpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlQmxvYihhYiwgbWltZVR5cGUpO1xuICB9O1xuXG4gIHZhciBnZXRNaW1lVHlwZUZyb21CYXNlNjREYXRhVVJJID0gZnVuY3Rpb24gZ2V0TWltZVR5cGVGcm9tQmFzZTY0RGF0YVVSSShcbiAgICBkYXRhVVJJXG4gICkge1xuICAgIHJldHVybiAoL15kYXRhOiguKyk7Ly5leGVjKGRhdGFVUkkpIHx8IFtdKVsxXSB8fCBudWxsO1xuICB9O1xuXG4gIHZhciBnZXRCYXNlNjREYXRhRnJvbUJhc2U2NERhdGFVUkkgPSBmdW5jdGlvbiBnZXRCYXNlNjREYXRhRnJvbUJhc2U2NERhdGFVUkkoXG4gICAgZGF0YVVSSVxuICApIHtcbiAgICAvLyBnZXQgZGF0YSBwYXJ0IG9mIHN0cmluZyAocmVtb3ZlIGRhdGE6aW1hZ2UvanBlZy4uLiwpXG4gICAgdmFyIGRhdGEgPSBkYXRhVVJJLnNwbGl0KCcsJylbMV07XG5cbiAgICAvLyByZW1vdmUgYW55IHdoaXRlc3BhY2UgYXMgdGhhdCBjYXVzZXMgSW52YWxpZENoYXJhY3RlckVycm9yIGluIElFXG4gICAgcmV0dXJuIGRhdGEucmVwbGFjZSgvXFxzL2csICcnKTtcbiAgfTtcblxuICB2YXIgZ2V0Qnl0ZVN0cmluZ0Zyb21CYXNlNjREYXRhVVJJID0gZnVuY3Rpb24gZ2V0Qnl0ZVN0cmluZ0Zyb21CYXNlNjREYXRhVVJJKFxuICAgIGRhdGFVUklcbiAgKSB7XG4gICAgcmV0dXJuIGF0b2IoZ2V0QmFzZTY0RGF0YUZyb21CYXNlNjREYXRhVVJJKGRhdGFVUkkpKTtcbiAgfTtcblxuICB2YXIgZ2V0QmxvYkZyb21CYXNlNjREYXRhVVJJID0gZnVuY3Rpb24gZ2V0QmxvYkZyb21CYXNlNjREYXRhVVJJKGRhdGFVUkkpIHtcbiAgICB2YXIgbWltZVR5cGUgPSBnZXRNaW1lVHlwZUZyb21CYXNlNjREYXRhVVJJKGRhdGFVUkkpO1xuICAgIHZhciBieXRlU3RyaW5nID0gZ2V0Qnl0ZVN0cmluZ0Zyb21CYXNlNjREYXRhVVJJKGRhdGFVUkkpO1xuXG4gICAgcmV0dXJuIGdldEJsb2JGcm9tQnl0ZVN0cmluZ1dpdGhNaW1lVHlwZShieXRlU3RyaW5nLCBtaW1lVHlwZSk7XG4gIH07XG5cbiAgdmFyIGdldEZpbGVGcm9tQmFzZTY0RGF0YVVSSSA9IGZ1bmN0aW9uIGdldEZpbGVGcm9tQmFzZTY0RGF0YVVSSShcbiAgICBkYXRhVVJJLFxuICAgIGZpbGVuYW1lLFxuICAgIGV4dGVuc2lvblxuICApIHtcbiAgICByZXR1cm4gZ2V0RmlsZUZyb21CbG9iKFxuICAgICAgZ2V0QmxvYkZyb21CYXNlNjREYXRhVVJJKGRhdGFVUkkpLFxuICAgICAgZmlsZW5hbWUsXG4gICAgICBudWxsLFxuICAgICAgZXh0ZW5zaW9uXG4gICAgKTtcbiAgfTtcblxuICB2YXIgZ2V0RmlsZU5hbWVGcm9tSGVhZGVyID0gZnVuY3Rpb24gZ2V0RmlsZU5hbWVGcm9tSGVhZGVyKGhlYWRlcikge1xuICAgIC8vIHRlc3QgaWYgaXMgY29udGVudCBkaXNwb3NpdGlvbiBoZWFkZXIsIGlmIG5vdCBleGl0XG4gICAgaWYgKCEvXmNvbnRlbnQtZGlzcG9zaXRpb246L2kudGVzdChoZWFkZXIpKSByZXR1cm4gbnVsbDtcblxuICAgIC8vIGdldCBmaWxlbmFtZSBwYXJ0c1xuICAgIHZhciBtYXRjaGVzID0gaGVhZGVyXG4gICAgICAuc3BsaXQoL2ZpbGVuYW1lPXxmaWxlbmFtZVxcKj0uKycnLylcbiAgICAgIC5zcGxpY2UoMSlcbiAgICAgIC5tYXAoZnVuY3Rpb24obmFtZSkge1xuICAgICAgICByZXR1cm4gbmFtZS50cmltKCkucmVwbGFjZSgvXltcIiddfFs7XCInXXswLDJ9JC9nLCAnJyk7XG4gICAgICB9KVxuICAgICAgLmZpbHRlcihmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHJldHVybiBuYW1lLmxlbmd0aDtcbiAgICAgIH0pO1xuXG4gICAgcmV0dXJuIG1hdGNoZXMubGVuZ3RoID8gZGVjb2RlVVJJKG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXSkgOiBudWxsO1xuICB9O1xuXG4gIHZhciBnZXRGaWxlU2l6ZUZyb21IZWFkZXIgPSBmdW5jdGlvbiBnZXRGaWxlU2l6ZUZyb21IZWFkZXIoaGVhZGVyKSB7XG4gICAgaWYgKC9jb250ZW50LWxlbmd0aDovaS50ZXN0KGhlYWRlcikpIHtcbiAgICAgIHZhciBzaXplID0gaGVhZGVyLm1hdGNoKC9bMC05XSsvKVswXTtcbiAgICAgIHJldHVybiBzaXplID8gcGFyc2VJbnQoc2l6ZSwgMTApIDogbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgdmFyIGdldFRyYW5mc2VySWRGcm9tSGVhZGVyID0gZnVuY3Rpb24gZ2V0VHJhbmZzZXJJZEZyb21IZWFkZXIoaGVhZGVyKSB7XG4gICAgaWYgKC94LWNvbnRlbnQtdHJhbnNmZXItaWQ6L2kudGVzdChoZWFkZXIpKSB7XG4gICAgICB2YXIgaWQgPSAoaGVhZGVyLnNwbGl0KCc6JylbMV0gfHwgJycpLnRyaW0oKTtcbiAgICAgIHJldHVybiBpZCB8fCBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICB2YXIgZ2V0RmlsZUluZm9Gcm9tSGVhZGVycyA9IGZ1bmN0aW9uIGdldEZpbGVJbmZvRnJvbUhlYWRlcnMoaGVhZGVycykge1xuICAgIHZhciBpbmZvID0ge1xuICAgICAgc291cmNlOiBudWxsLFxuICAgICAgbmFtZTogbnVsbCxcbiAgICAgIHNpemU6IG51bGxcbiAgICB9O1xuXG4gICAgdmFyIHJvd3MgPSBoZWFkZXJzLnNwbGl0KCdcXG4nKTtcbiAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XG4gICAgdmFyIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7XG4gICAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuICAgIHRyeSB7XG4gICAgICBmb3IgKFxuICAgICAgICB2YXIgX2l0ZXJhdG9yID0gcm93c1tTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwO1xuICAgICAgICAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSAoX3N0ZXAgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKTtcbiAgICAgICAgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWVcbiAgICAgICkge1xuICAgICAgICB2YXIgaGVhZGVyID0gX3N0ZXAudmFsdWU7XG5cbiAgICAgICAgdmFyIG5hbWUgPSBnZXRGaWxlTmFtZUZyb21IZWFkZXIoaGVhZGVyKTtcbiAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICBpbmZvLm5hbWUgPSBuYW1lO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNpemUgPSBnZXRGaWxlU2l6ZUZyb21IZWFkZXIoaGVhZGVyKTtcbiAgICAgICAgaWYgKHNpemUpIHtcbiAgICAgICAgICBpbmZvLnNpemUgPSBzaXplO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNvdXJjZSA9IGdldFRyYW5mc2VySWRGcm9tSGVhZGVyKGhlYWRlcik7XG4gICAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgICBpbmZvLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgICAgX2l0ZXJhdG9yRXJyb3IgPSBlcnI7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuICE9IG51bGwpIHtcbiAgICAgICAgICBfaXRlcmF0b3IucmV0dXJuKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGluZm87XG4gIH07XG5cbiAgdmFyIGNyZWF0ZUZpbGVMb2FkZXIgPSBmdW5jdGlvbiBjcmVhdGVGaWxlTG9hZGVyKGZldGNoRm4pIHtcbiAgICB2YXIgc3RhdGUgPSB7XG4gICAgICBzb3VyY2U6IG51bGwsXG4gICAgICBjb21wbGV0ZTogZmFsc2UsXG4gICAgICBwcm9ncmVzczogMCxcbiAgICAgIHNpemU6IG51bGwsXG4gICAgICB0aW1lc3RhbXA6IG51bGwsXG4gICAgICBkdXJhdGlvbjogMCxcbiAgICAgIHJlcXVlc3Q6IG51bGxcbiAgICB9O1xuXG4gICAgdmFyIGdldFByb2dyZXNzID0gZnVuY3Rpb24gZ2V0UHJvZ3Jlc3MoKSB7XG4gICAgICByZXR1cm4gc3RhdGUucHJvZ3Jlc3M7XG4gICAgfTtcbiAgICB2YXIgYWJvcnQgPSBmdW5jdGlvbiBhYm9ydCgpIHtcbiAgICAgIGlmIChzdGF0ZS5yZXF1ZXN0ICYmIHN0YXRlLnJlcXVlc3QuYWJvcnQpIHtcbiAgICAgICAgc3RhdGUucmVxdWVzdC5hYm9ydCgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBsb2FkIHNvdXJjZVxuICAgIHZhciBsb2FkID0gZnVuY3Rpb24gbG9hZCgpIHtcbiAgICAgIC8vIGdldCBxdWljayByZWZlcmVuY2VcbiAgICAgIHZhciBzb3VyY2UgPSBzdGF0ZS5zb3VyY2U7XG5cbiAgICAgIGFwaS5maXJlKCdpbml0Jywgc291cmNlKTtcblxuICAgICAgLy8gTG9hZCBGaWxlc1xuICAgICAgaWYgKHNvdXJjZSBpbnN0YW5jZW9mIEZpbGUpIHtcbiAgICAgICAgYXBpLmZpcmUoJ2xvYWQnLCBzb3VyY2UpO1xuICAgICAgfSBlbHNlIGlmIChzb3VyY2UgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgICAgIC8vIExvYWQgYmxvYnMsIHNldCBkZWZhdWx0IG5hbWUgdG8gY3VycmVudCBkYXRlXG4gICAgICAgIGFwaS5maXJlKCdsb2FkJywgZ2V0RmlsZUZyb21CbG9iKHNvdXJjZSwgc291cmNlLm5hbWUpKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNCYXNlNjREYXRhVVJJKHNvdXJjZSkpIHtcbiAgICAgICAgLy8gTG9hZCBiYXNlIDY0LCBzZXQgZGVmYXVsdCBuYW1lIHRvIGN1cnJlbnQgZGF0ZVxuICAgICAgICBhcGkuZmlyZSgnbG9hZCcsIGdldEZpbGVGcm9tQmFzZTY0RGF0YVVSSShzb3VyY2UpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIERlYWwgYXMgaWYgaXMgZXh0ZXJuYWwgVVJMLCBsZXQncyBsb2FkIGl0IVxuICAgICAgICBsb2FkVVJMKHNvdXJjZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIGxvYWRzIGEgdXJsXG4gICAgdmFyIGxvYWRVUkwgPSBmdW5jdGlvbiBsb2FkVVJMKHVybCkge1xuICAgICAgLy8gaXMgcmVtb3RlIHVybCBhbmQgbm8gZmV0Y2ggbWV0aG9kIHN1cHBsaWVkXG4gICAgICBpZiAoIWZldGNoRm4pIHtcbiAgICAgICAgYXBpLmZpcmUoJ2Vycm9yJywge1xuICAgICAgICAgIHR5cGU6ICdlcnJvcicsXG4gICAgICAgICAgYm9keTogXCJDYW4ndCBsb2FkIFVSTFwiLFxuICAgICAgICAgIGNvZGU6IDQwMFxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIHNldCByZXF1ZXN0IHN0YXJ0XG4gICAgICBzdGF0ZS50aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuXG4gICAgICAvLyBsb2FkIGZpbGVcbiAgICAgIHN0YXRlLnJlcXVlc3QgPSBmZXRjaEZuKFxuICAgICAgICB1cmwsXG4gICAgICAgIGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgLy8gdXBkYXRlIGR1cmF0aW9uXG4gICAgICAgICAgc3RhdGUuZHVyYXRpb24gPSBEYXRlLm5vdygpIC0gc3RhdGUudGltZXN0YW1wO1xuXG4gICAgICAgICAgLy8gZG9uZSFcbiAgICAgICAgICBzdGF0ZS5jb21wbGV0ZSA9IHRydWU7XG5cbiAgICAgICAgICAvLyB0dXJuIGJsb2IgcmVzcG9uc2UgaW50byBhIGZpbGVcbiAgICAgICAgICBpZiAocmVzcG9uc2UgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgICAgICAgICByZXNwb25zZSA9IGdldEZpbGVGcm9tQmxvYihcbiAgICAgICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgICAgIHJlc3BvbnNlLm5hbWUgfHwgZ2V0RmlsZW5hbWVGcm9tVVJMKHVybClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYXBpLmZpcmUoXG4gICAgICAgICAgICAnbG9hZCcsXG4gICAgICAgICAgICAvLyBpZiBoYXMgcmVjZWl2ZWQgYmxvYiwgd2UgZ28gd2l0aCBibG9iLCBpZiBubyByZXNwb25zZSwgd2UgcmV0dXJuIG51bGxcbiAgICAgICAgICAgIHJlc3BvbnNlIGluc3RhbmNlb2YgQmxvYlxuICAgICAgICAgICAgICA/IHJlc3BvbnNlXG4gICAgICAgICAgICAgIDogcmVzcG9uc2VcbiAgICAgICAgICAgICAgPyByZXNwb25zZS5ib2R5XG4gICAgICAgICAgICAgIDogbnVsbFxuICAgICAgICAgICk7XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgYXBpLmZpcmUoXG4gICAgICAgICAgICAnZXJyb3InLFxuICAgICAgICAgICAgdHlwZW9mIGVycm9yID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6ICdlcnJvcicsXG4gICAgICAgICAgICAgICAgICBjb2RlOiAwLFxuICAgICAgICAgICAgICAgICAgYm9keTogZXJyb3JcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIDogZXJyb3JcbiAgICAgICAgICApO1xuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbihjb21wdXRhYmxlLCBjdXJyZW50LCB0b3RhbCkge1xuICAgICAgICAgIC8vIGNvbGxlY3RlZCBzb21lIG1ldGEgZGF0YSBhbHJlYWR5XG4gICAgICAgICAgaWYgKHRvdGFsKSB7XG4gICAgICAgICAgICBzdGF0ZS5zaXplID0gdG90YWw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gdXBkYXRlIGR1cmF0aW9uXG4gICAgICAgICAgc3RhdGUuZHVyYXRpb24gPSBEYXRlLm5vdygpIC0gc3RhdGUudGltZXN0YW1wO1xuXG4gICAgICAgICAgLy8gaWYgd2UgY2FuJ3QgY29tcHV0ZSBwcm9ncmVzcywgd2UncmUgbm90IGdvaW5nIHRvIGZpcmUgcHJvZ3Jlc3MgZXZlbnRzXG4gICAgICAgICAgaWYgKCFjb21wdXRhYmxlKSB7XG4gICAgICAgICAgICBzdGF0ZS5wcm9ncmVzcyA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gdXBkYXRlIHByb2dyZXNzIHBlcmNlbnRhZ2VcbiAgICAgICAgICBzdGF0ZS5wcm9ncmVzcyA9IGN1cnJlbnQgLyB0b3RhbDtcblxuICAgICAgICAgIC8vIGV4cG9zZVxuICAgICAgICAgIGFwaS5maXJlKCdwcm9ncmVzcycsIHN0YXRlLnByb2dyZXNzKTtcbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgYXBpLmZpcmUoJ2Fib3J0Jyk7XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgdmFyIGZpbGVpbmZvID0gZ2V0RmlsZUluZm9Gcm9tSGVhZGVycyhcbiAgICAgICAgICAgIHR5cGVvZiByZXNwb25zZSA9PT0gJ3N0cmluZycgPyByZXNwb25zZSA6IHJlc3BvbnNlLmhlYWRlcnNcbiAgICAgICAgICApO1xuICAgICAgICAgIGFwaS5maXJlKCdtZXRhJywge1xuICAgICAgICAgICAgc2l6ZTogc3RhdGUuc2l6ZSB8fCBmaWxlaW5mby5zaXplLFxuICAgICAgICAgICAgZmlsZW5hbWU6IGZpbGVpbmZvLm5hbWUsXG4gICAgICAgICAgICBzb3VyY2U6IGZpbGVpbmZvLnNvdXJjZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICApO1xuICAgIH07XG5cbiAgICB2YXIgYXBpID0gT2JqZWN0LmFzc2lnbih7fSwgb24oKSwge1xuICAgICAgc2V0U291cmNlOiBmdW5jdGlvbiBzZXRTb3VyY2Uoc291cmNlKSB7XG4gICAgICAgIHJldHVybiAoc3RhdGUuc291cmNlID0gc291cmNlKTtcbiAgICAgIH0sXG4gICAgICBnZXRQcm9ncmVzczogZ2V0UHJvZ3Jlc3MsIC8vIGZpbGUgbG9hZCBwcm9ncmVzc1xuICAgICAgYWJvcnQ6IGFib3J0LCAvLyBhYm9ydCBmaWxlIGxvYWRcbiAgICAgIGxvYWQ6IGxvYWQgLy8gc3RhcnQgbG9hZFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGFwaTtcbiAgfTtcblxuICB2YXIgaXNHZXQgPSBmdW5jdGlvbiBpc0dldChtZXRob2QpIHtcbiAgICByZXR1cm4gL0dFVHxIRUFELy50ZXN0KG1ldGhvZCk7XG4gIH07XG5cbiAgdmFyIHNlbmRSZXF1ZXN0ID0gZnVuY3Rpb24gc2VuZFJlcXVlc3QoZGF0YSwgdXJsLCBvcHRpb25zKSB7XG4gICAgdmFyIGFwaSA9IHtcbiAgICAgIG9uaGVhZGVyczogZnVuY3Rpb24gb25oZWFkZXJzKCkge30sXG4gICAgICBvbnByb2dyZXNzOiBmdW5jdGlvbiBvbnByb2dyZXNzKCkge30sXG4gICAgICBvbmxvYWQ6IGZ1bmN0aW9uIG9ubG9hZCgpIHt9LFxuICAgICAgb250aW1lb3V0OiBmdW5jdGlvbiBvbnRpbWVvdXQoKSB7fSxcbiAgICAgIG9uZXJyb3I6IGZ1bmN0aW9uIG9uZXJyb3IoKSB7fSxcbiAgICAgIG9uYWJvcnQ6IGZ1bmN0aW9uIG9uYWJvcnQoKSB7fSxcbiAgICAgIGFib3J0OiBmdW5jdGlvbiBhYm9ydCgpIHtcbiAgICAgICAgYWJvcnRlZCA9IHRydWU7XG4gICAgICAgIHhoci5hYm9ydCgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyB0aW1lb3V0IGlkZW50aWZpZXIsIG9ubHkgdXNlZCB3aGVuIHRpbWVvdXQgaXMgZGVmaW5lZFxuICAgIHZhciBhYm9ydGVkID0gZmFsc2U7XG4gICAgdmFyIGhlYWRlcnNSZWNlaXZlZCA9IGZhbHNlO1xuXG4gICAgLy8gc2V0IGRlZmF1bHQgb3B0aW9uc1xuICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKFxuICAgICAge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczoge30sXG4gICAgICAgIHdpdGhDcmVkZW50aWFsczogZmFsc2VcbiAgICAgIH0sXG4gICAgICBvcHRpb25zXG4gICAgKTtcblxuICAgIC8vIGVuY29kZSB1cmxcbiAgICB1cmwgPSBlbmNvZGVVUkkodXJsKTtcblxuICAgIC8vIGlmIG1ldGhvZCBpcyBHRVQsIGFkZCBhbnkgcmVjZWl2ZWQgZGF0YSB0byB1cmxcblxuICAgIGlmIChpc0dldChvcHRpb25zLm1ldGhvZCkgJiYgZGF0YSkge1xuICAgICAgdXJsID1cbiAgICAgICAgJycgK1xuICAgICAgICB1cmwgK1xuICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoXG4gICAgICAgICAgdHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnID8gZGF0YSA6IEpTT04uc3RyaW5naWZ5KGRhdGEpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gY3JlYXRlIHJlcXVlc3RcbiAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgICAvLyBwcm9ncmVzcyBvZiBsb2FkXG4gICAgdmFyIHByb2Nlc3MgPSBpc0dldChvcHRpb25zLm1ldGhvZCkgPyB4aHIgOiB4aHIudXBsb2FkO1xuICAgIHByb2Nlc3Mub25wcm9ncmVzcyA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgIC8vIG5vIHByb2dyZXNzIGV2ZW50IHdoZW4gYWJvcnRlZCAoIG9ucHJvZ3Jlc3MgaXMgY2FsbGVkIG9uY2UgYWZ0ZXIgYWJvcnQoKSApXG4gICAgICBpZiAoYWJvcnRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGFwaS5vbnByb2dyZXNzKGUubGVuZ3RoQ29tcHV0YWJsZSwgZS5sb2FkZWQsIGUudG90YWwpO1xuICAgIH07XG5cbiAgICAvLyB0cmllcyB0byBnZXQgaGVhZGVyIGluZm8gdG8gdGhlIGFwcCBhcyBmYXN0IGFzIHBvc3NpYmxlXG4gICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gbm90IGludGVyZXN0aW5nIGluIHRoZXNlIHN0YXRlcyAoJ3Vuc2VudCcgYW5kICdvcGVuZW5kJyBhcyB0aGV5IGRvbid0IGdpdmUgdXMgYW55IGFkZGl0aW9uYWwgaW5mbylcbiAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA8IDIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBubyBzZXJ2ZXIgcmVzcG9uc2VcbiAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PT0gNCAmJiB4aHIuc3RhdHVzID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGhlYWRlcnNSZWNlaXZlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGhlYWRlcnNSZWNlaXZlZCA9IHRydWU7XG5cbiAgICAgIC8vIHdlJ3ZlIHByb2JhYmx5IHJlY2VpdmVkIHNvbWUgdXNlZnVsIGRhdGEgaW4gcmVzcG9uc2UgaGVhZGVyc1xuICAgICAgYXBpLm9uaGVhZGVycyh4aHIpO1xuICAgIH07XG5cbiAgICAvLyBsb2FkIHN1Y2Nlc3NmdWxcbiAgICB4aHIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAvLyBpcyBjbGFzc2lmaWVkIGFzIHZhbGlkIHJlc3BvbnNlXG4gICAgICBpZiAoeGhyLnN0YXR1cyA+PSAyMDAgJiYgeGhyLnN0YXR1cyA8IDMwMCkge1xuICAgICAgICBhcGkub25sb2FkKHhocik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhcGkub25lcnJvcih4aHIpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBlcnJvciBkdXJpbmcgbG9hZFxuICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gYXBpLm9uZXJyb3IoeGhyKTtcbiAgICB9O1xuXG4gICAgLy8gcmVxdWVzdCBhYm9ydGVkXG4gICAgeGhyLm9uYWJvcnQgPSBmdW5jdGlvbigpIHtcbiAgICAgIGFib3J0ZWQgPSB0cnVlO1xuICAgICAgYXBpLm9uYWJvcnQoKTtcbiAgICB9O1xuXG4gICAgLy8gcmVxdWVzdCB0aW1lb3V0XG4gICAgeGhyLm9udGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGFwaS5vbnRpbWVvdXQoeGhyKTtcbiAgICB9O1xuXG4gICAgLy8gb3BlbiB1cCBvcGVuIHVwIVxuICAgIHhoci5vcGVuKG9wdGlvbnMubWV0aG9kLCB1cmwsIHRydWUpO1xuXG4gICAgLy8gc2V0IHRpbWVvdXQgaWYgZGVmaW5lZCAoZG8gaXQgYWZ0ZXIgb3BlbiBzbyBJRTExIHBsYXlzIGJhbGwpXG4gICAgaWYgKGlzSW50KG9wdGlvbnMudGltZW91dCkpIHtcbiAgICAgIHhoci50aW1lb3V0ID0gb3B0aW9ucy50aW1lb3V0O1xuICAgIH1cblxuICAgIC8vIGFkZCBoZWFkZXJzXG4gICAgT2JqZWN0LmtleXMob3B0aW9ucy5oZWFkZXJzKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgdmFyIHZhbHVlID0gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KG9wdGlvbnMuaGVhZGVyc1trZXldKSk7XG4gICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihrZXksIHZhbHVlKTtcbiAgICB9KTtcblxuICAgIC8vIHNldCB0eXBlIG9mIHJlc3BvbnNlXG4gICAgaWYgKG9wdGlvbnMucmVzcG9uc2VUeXBlKSB7XG4gICAgICB4aHIucmVzcG9uc2VUeXBlID0gb3B0aW9ucy5yZXNwb25zZVR5cGU7XG4gICAgfVxuXG4gICAgLy8gc2V0IGNyZWRlbnRpYWxzXG4gICAgaWYgKG9wdGlvbnMud2l0aENyZWRlbnRpYWxzKSB7XG4gICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBsZXQncyBzZW5kIG91ciBkYXRhXG4gICAgeGhyLnNlbmQoZGF0YSk7XG5cbiAgICByZXR1cm4gYXBpO1xuICB9O1xuXG4gIHZhciBjcmVhdGVSZXNwb25zZSA9IGZ1bmN0aW9uIGNyZWF0ZVJlc3BvbnNlKHR5cGUsIGNvZGUsIGJvZHksIGhlYWRlcnMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogdHlwZSxcbiAgICAgIGNvZGU6IGNvZGUsXG4gICAgICBib2R5OiBib2R5LFxuICAgICAgaGVhZGVyczogaGVhZGVyc1xuICAgIH07XG4gIH07XG5cbiAgdmFyIGNyZWF0ZVRpbWVvdXRSZXNwb25zZSA9IGZ1bmN0aW9uIGNyZWF0ZVRpbWVvdXRSZXNwb25zZShjYikge1xuICAgIHJldHVybiBmdW5jdGlvbih4aHIpIHtcbiAgICAgIGNiKGNyZWF0ZVJlc3BvbnNlKCdlcnJvcicsIDAsICdUaW1lb3V0JywgeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpKSk7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgaGFzUVMgPSBmdW5jdGlvbiBoYXNRUyhzdHIpIHtcbiAgICByZXR1cm4gL1xcPy8udGVzdChzdHIpO1xuICB9O1xuICB2YXIgYnVpbGRVUkwgPSBmdW5jdGlvbiBidWlsZFVSTCgpIHtcbiAgICB2YXIgdXJsID0gJyc7XG4gICAgZm9yIChcbiAgICAgIHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcGFydHMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwO1xuICAgICAgX2tleSA8IF9sZW47XG4gICAgICBfa2V5KytcbiAgICApIHtcbiAgICAgIHBhcnRzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cbiAgICBwYXJ0cy5mb3JFYWNoKGZ1bmN0aW9uKHBhcnQpIHtcbiAgICAgIHVybCArPSBoYXNRUyh1cmwpICYmIGhhc1FTKHBhcnQpID8gcGFydC5yZXBsYWNlKC9cXD8vLCAnJicpIDogcGFydDtcbiAgICB9KTtcbiAgICByZXR1cm4gdXJsO1xuICB9O1xuXG4gIHZhciBjcmVhdGVGZXRjaEZ1bmN0aW9uID0gZnVuY3Rpb24gY3JlYXRlRmV0Y2hGdW5jdGlvbigpIHtcbiAgICB2YXIgYXBpVXJsID1cbiAgICAgIGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogJyc7XG4gICAgdmFyIGFjdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICAgIC8vIGN1c3RvbSBoYW5kbGVyIChzaG91bGQgYWxzbyBoYW5kbGUgZmlsZSwgbG9hZCwgZXJyb3IsIHByb2dyZXNzIGFuZCBhYm9ydClcbiAgICBpZiAodHlwZW9mIGFjdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGFjdGlvbjtcbiAgICB9XG5cbiAgICAvLyBubyBhY3Rpb24gc3VwcGxpZWRcbiAgICBpZiAoIWFjdGlvbiB8fCAhaXNTdHJpbmcoYWN0aW9uLnVybCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIHNldCBvbmxvYWQgaGFubGRlclxuICAgIHZhciBvbmxvYWQgPVxuICAgICAgYWN0aW9uLm9ubG9hZCB8fFxuICAgICAgZnVuY3Rpb24ocmVzKSB7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9O1xuICAgIHZhciBvbmVycm9yID1cbiAgICAgIGFjdGlvbi5vbmVycm9yIHx8XG4gICAgICBmdW5jdGlvbihyZXMpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuXG4gICAgLy8gaW50ZXJuYWwgaGFuZGxlclxuICAgIHJldHVybiBmdW5jdGlvbih1cmwsIGxvYWQsIGVycm9yLCBwcm9ncmVzcywgYWJvcnQsIGhlYWRlcnMpIHtcbiAgICAgIC8vIGRvIGxvY2FsIG9yIHJlbW90ZSByZXF1ZXN0IGJhc2VkIG9uIGlmIHRoZSB1cmwgaXMgZXh0ZXJuYWxcbiAgICAgIHZhciByZXF1ZXN0ID0gc2VuZFJlcXVlc3QoXG4gICAgICAgIHVybCxcbiAgICAgICAgYnVpbGRVUkwoYXBpVXJsLCBhY3Rpb24udXJsKSxcbiAgICAgICAgT2JqZWN0LmFzc2lnbih7fSwgYWN0aW9uLCB7XG4gICAgICAgICAgcmVzcG9uc2VUeXBlOiAnYmxvYidcbiAgICAgICAgfSlcbiAgICAgICk7XG5cbiAgICAgIHJlcXVlc3Qub25sb2FkID0gZnVuY3Rpb24oeGhyKSB7XG4gICAgICAgIC8vIGdldCBoZWFkZXJzXG4gICAgICAgIHZhciBoZWFkZXJzID0geGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpO1xuXG4gICAgICAgIC8vIGdldCBmaWxlbmFtZVxuICAgICAgICB2YXIgZmlsZW5hbWUgPVxuICAgICAgICAgIGdldEZpbGVJbmZvRnJvbUhlYWRlcnMoaGVhZGVycykubmFtZSB8fCBnZXRGaWxlbmFtZUZyb21VUkwodXJsKTtcblxuICAgICAgICAvLyBjcmVhdGUgcmVzcG9uc2VcbiAgICAgICAgbG9hZChcbiAgICAgICAgICBjcmVhdGVSZXNwb25zZShcbiAgICAgICAgICAgICdsb2FkJyxcbiAgICAgICAgICAgIHhoci5zdGF0dXMsXG4gICAgICAgICAgICBhY3Rpb24ubWV0aG9kID09PSAnSEVBRCdcbiAgICAgICAgICAgICAgPyBudWxsXG4gICAgICAgICAgICAgIDogZ2V0RmlsZUZyb21CbG9iKG9ubG9hZCh4aHIucmVzcG9uc2UpLCBmaWxlbmFtZSksXG4gICAgICAgICAgICBoZWFkZXJzXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfTtcblxuICAgICAgcmVxdWVzdC5vbmVycm9yID0gZnVuY3Rpb24oeGhyKSB7XG4gICAgICAgIGVycm9yKFxuICAgICAgICAgIGNyZWF0ZVJlc3BvbnNlKFxuICAgICAgICAgICAgJ2Vycm9yJyxcbiAgICAgICAgICAgIHhoci5zdGF0dXMsXG4gICAgICAgICAgICBvbmVycm9yKHhoci5yZXNwb25zZSkgfHwgeGhyLnN0YXR1c1RleHQsXG4gICAgICAgICAgICB4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKClcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9O1xuXG4gICAgICByZXF1ZXN0Lm9uaGVhZGVycyA9IGZ1bmN0aW9uKHhocikge1xuICAgICAgICBoZWFkZXJzKFxuICAgICAgICAgIGNyZWF0ZVJlc3BvbnNlKFxuICAgICAgICAgICAgJ2hlYWRlcnMnLFxuICAgICAgICAgICAgeGhyLnN0YXR1cyxcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICB4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKClcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9O1xuXG4gICAgICByZXF1ZXN0Lm9udGltZW91dCA9IGNyZWF0ZVRpbWVvdXRSZXNwb25zZShlcnJvcik7XG4gICAgICByZXF1ZXN0Lm9ucHJvZ3Jlc3MgPSBwcm9ncmVzcztcbiAgICAgIHJlcXVlc3Qub25hYm9ydCA9IGFib3J0O1xuXG4gICAgICAvLyBzaG91bGQgcmV0dXJuIHJlcXVlc3RcbiAgICAgIHJldHVybiByZXF1ZXN0O1xuICAgIH07XG4gIH07XG5cbiAgdmFyIENodW5rU3RhdHVzID0ge1xuICAgIFFVRVVFRDogMCxcbiAgICBDT01QTEVURTogMSxcbiAgICBQUk9DRVNTSU5HOiAyLFxuICAgIEVSUk9SOiAzLFxuICAgIFdBSVRJTkc6IDRcbiAgfTtcblxuICAvKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHNpZ25hdHVyZTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChmaWxlLCBtZXRhZGF0YSwgbG9hZCwgZXJyb3IsIHByb2dyZXNzLCBhYm9ydCwgdHJhbnNmZXIsIG9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWJvcnQ6KCkgPT4ge31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblxuICAvLyBhcGlVcmwsIGFjdGlvbiwgbmFtZSwgZmlsZSwgbWV0YWRhdGEsIGxvYWQsIGVycm9yLCBwcm9ncmVzcywgYWJvcnQsIHRyYW5zZmVyLCBvcHRpb25zXG4gIHZhciBwcm9jZXNzRmlsZUNodW5rZWQgPSBmdW5jdGlvbiBwcm9jZXNzRmlsZUNodW5rZWQoXG4gICAgYXBpVXJsLFxuICAgIGFjdGlvbixcbiAgICBuYW1lLFxuICAgIGZpbGUsXG4gICAgbWV0YWRhdGEsXG4gICAgbG9hZCxcbiAgICBlcnJvcixcbiAgICBwcm9ncmVzcyxcbiAgICBhYm9ydCxcbiAgICB0cmFuc2ZlcixcbiAgICBvcHRpb25zXG4gICkge1xuICAgIC8vIGFsbCBjaHVua3NcbiAgICB2YXIgY2h1bmtzID0gW107XG4gICAgdmFyIGNodW5rVHJhbnNmZXJJZCA9IG9wdGlvbnMuY2h1bmtUcmFuc2ZlcklkLFxuICAgICAgY2h1bmtTZXJ2ZXIgPSBvcHRpb25zLmNodW5rU2VydmVyLFxuICAgICAgY2h1bmtTaXplID0gb3B0aW9ucy5jaHVua1NpemUsXG4gICAgICBjaHVua1JldHJ5RGVsYXlzID0gb3B0aW9ucy5jaHVua1JldHJ5RGVsYXlzO1xuXG4gICAgLy8gZGVmYXVsdCBzdGF0ZVxuICAgIHZhciBzdGF0ZSA9IHtcbiAgICAgIHNlcnZlcklkOiBjaHVua1RyYW5zZmVySWQsXG4gICAgICBhYm9ydGVkOiBmYWxzZVxuICAgIH07XG5cbiAgICAvLyBzZXQgb25sb2FkIGhhbmRsZXJzXG4gICAgdmFyIG9uZGF0YSA9XG4gICAgICBhY3Rpb24ub25kYXRhIHx8XG4gICAgICBmdW5jdGlvbihmZCkge1xuICAgICAgICByZXR1cm4gZmQ7XG4gICAgICB9O1xuICAgIHZhciBvbmxvYWQgPVxuICAgICAgYWN0aW9uLm9ubG9hZCB8fFxuICAgICAgZnVuY3Rpb24oeGhyLCBtZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIG1ldGhvZCA9PT0gJ0hFQUQnXG4gICAgICAgICAgPyB4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoJ1VwbG9hZC1PZmZzZXQnKVxuICAgICAgICAgIDogeGhyLnJlc3BvbnNlO1xuICAgICAgfTtcbiAgICB2YXIgb25lcnJvciA9XG4gICAgICBhY3Rpb24ub25lcnJvciB8fFxuICAgICAgZnVuY3Rpb24ocmVzKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcblxuICAgIC8vIGNyZWF0ZSBzZXJ2ZXIgaG9va1xuICAgIHZhciByZXF1ZXN0VHJhbnNmZXJJZCA9IGZ1bmN0aW9uIHJlcXVlc3RUcmFuc2ZlcklkKGNiKSB7XG4gICAgICB2YXIgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcblxuICAgICAgLy8gYWRkIG1ldGFkYXRhIHVuZGVyIHNhbWUgbmFtZVxuICAgICAgaWYgKGlzT2JqZWN0KG1ldGFkYXRhKSkgZm9ybURhdGEuYXBwZW5kKG5hbWUsIEpTT04uc3RyaW5naWZ5KG1ldGFkYXRhKSk7XG5cbiAgICAgIHZhciBoZWFkZXJzID1cbiAgICAgICAgdHlwZW9mIGFjdGlvbi5oZWFkZXJzID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgPyBhY3Rpb24uaGVhZGVycyhmaWxlLCBtZXRhZGF0YSlcbiAgICAgICAgICA6IE9iamVjdC5hc3NpZ24oe30sIGFjdGlvbi5oZWFkZXJzLCB7XG4gICAgICAgICAgICAgICdVcGxvYWQtTGVuZ3RoJzogZmlsZS5zaXplXG4gICAgICAgICAgICB9KTtcblxuICAgICAgdmFyIHJlcXVlc3RQYXJhbXMgPSBPYmplY3QuYXNzaWduKHt9LCBhY3Rpb24sIHtcbiAgICAgICAgaGVhZGVyczogaGVhZGVyc1xuICAgICAgfSk7XG5cbiAgICAgIC8vIHNlbmQgcmVxdWVzdCBvYmplY3RcbiAgICAgIHZhciByZXF1ZXN0ID0gc2VuZFJlcXVlc3QoXG4gICAgICAgIG9uZGF0YShmb3JtRGF0YSksXG4gICAgICAgIGJ1aWxkVVJMKGFwaVVybCwgYWN0aW9uLnVybCksXG4gICAgICAgIHJlcXVlc3RQYXJhbXNcbiAgICAgICk7XG5cbiAgICAgIHJlcXVlc3Qub25sb2FkID0gZnVuY3Rpb24oeGhyKSB7XG4gICAgICAgIHJldHVybiBjYihvbmxvYWQoeGhyLCByZXF1ZXN0UGFyYW1zLm1ldGhvZCkpO1xuICAgICAgfTtcblxuICAgICAgcmVxdWVzdC5vbmVycm9yID0gZnVuY3Rpb24oeGhyKSB7XG4gICAgICAgIHJldHVybiBlcnJvcihcbiAgICAgICAgICBjcmVhdGVSZXNwb25zZShcbiAgICAgICAgICAgICdlcnJvcicsXG4gICAgICAgICAgICB4aHIuc3RhdHVzLFxuICAgICAgICAgICAgb25lcnJvcih4aHIucmVzcG9uc2UpIHx8IHhoci5zdGF0dXNUZXh0LFxuICAgICAgICAgICAgeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfTtcblxuICAgICAgcmVxdWVzdC5vbnRpbWVvdXQgPSBjcmVhdGVUaW1lb3V0UmVzcG9uc2UoZXJyb3IpO1xuICAgIH07XG5cbiAgICB2YXIgcmVxdWVzdFRyYW5zZmVyT2Zmc2V0ID0gZnVuY3Rpb24gcmVxdWVzdFRyYW5zZmVyT2Zmc2V0KGNiKSB7XG4gICAgICB2YXIgcmVxdWVzdFVybCA9IGJ1aWxkVVJMKGFwaVVybCwgY2h1bmtTZXJ2ZXIudXJsLCBzdGF0ZS5zZXJ2ZXJJZCk7XG5cbiAgICAgIHZhciBoZWFkZXJzID1cbiAgICAgICAgdHlwZW9mIGFjdGlvbi5oZWFkZXJzID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgPyBhY3Rpb24uaGVhZGVycyhzdGF0ZS5zZXJ2ZXJJZClcbiAgICAgICAgICA6IE9iamVjdC5hc3NpZ24oe30sIGFjdGlvbi5oZWFkZXJzKTtcblxuICAgICAgdmFyIHJlcXVlc3RQYXJhbXMgPSB7XG4gICAgICAgIGhlYWRlcnM6IGhlYWRlcnMsXG4gICAgICAgIG1ldGhvZDogJ0hFQUQnXG4gICAgICB9O1xuXG4gICAgICB2YXIgcmVxdWVzdCA9IHNlbmRSZXF1ZXN0KG51bGwsIHJlcXVlc3RVcmwsIHJlcXVlc3RQYXJhbXMpO1xuXG4gICAgICByZXF1ZXN0Lm9ubG9hZCA9IGZ1bmN0aW9uKHhocikge1xuICAgICAgICByZXR1cm4gY2Iob25sb2FkKHhociwgcmVxdWVzdFBhcmFtcy5tZXRob2QpKTtcbiAgICAgIH07XG5cbiAgICAgIHJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uKHhocikge1xuICAgICAgICByZXR1cm4gZXJyb3IoXG4gICAgICAgICAgY3JlYXRlUmVzcG9uc2UoXG4gICAgICAgICAgICAnZXJyb3InLFxuICAgICAgICAgICAgeGhyLnN0YXR1cyxcbiAgICAgICAgICAgIG9uZXJyb3IoeGhyLnJlc3BvbnNlKSB8fCB4aHIuc3RhdHVzVGV4dCxcbiAgICAgICAgICAgIHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKVxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH07XG5cbiAgICAgIHJlcXVlc3Qub250aW1lb3V0ID0gY3JlYXRlVGltZW91dFJlc3BvbnNlKGVycm9yKTtcbiAgICB9O1xuXG4gICAgLy8gY3JlYXRlIGNodW5rc1xuICAgIHZhciBsYXN0Q2h1bmtJbmRleCA9IE1hdGguZmxvb3IoZmlsZS5zaXplIC8gY2h1bmtTaXplKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBsYXN0Q2h1bmtJbmRleDsgaSsrKSB7XG4gICAgICB2YXIgb2Zmc2V0ID0gaSAqIGNodW5rU2l6ZTtcbiAgICAgIHZhciBkYXRhID0gZmlsZS5zbGljZShcbiAgICAgICAgb2Zmc2V0LFxuICAgICAgICBvZmZzZXQgKyBjaHVua1NpemUsXG4gICAgICAgICdhcHBsaWNhdGlvbi9vZmZzZXQrb2N0ZXQtc3RyZWFtJ1xuICAgICAgKTtcbiAgICAgIGNodW5rc1tpXSA9IHtcbiAgICAgICAgaW5kZXg6IGksXG4gICAgICAgIHNpemU6IGRhdGEuc2l6ZSxcbiAgICAgICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgIGZpbGU6IGZpbGUsXG4gICAgICAgIHByb2dyZXNzOiAwLFxuICAgICAgICByZXRyaWVzOiBfdG9Db25zdW1hYmxlQXJyYXkoY2h1bmtSZXRyeURlbGF5cyksXG4gICAgICAgIHN0YXR1czogQ2h1bmtTdGF0dXMuUVVFVUVELFxuICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgcmVxdWVzdDogbnVsbCxcbiAgICAgICAgdGltZW91dDogbnVsbFxuICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgY29tcGxldGVQcm9jZXNzaW5nQ2h1bmtzID0gZnVuY3Rpb24gY29tcGxldGVQcm9jZXNzaW5nQ2h1bmtzKCkge1xuICAgICAgcmV0dXJuIGxvYWQoc3RhdGUuc2VydmVySWQpO1xuICAgIH07XG5cbiAgICB2YXIgY2FuUHJvY2Vzc0NodW5rID0gZnVuY3Rpb24gY2FuUHJvY2Vzc0NodW5rKGNodW5rKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBjaHVuay5zdGF0dXMgPT09IENodW5rU3RhdHVzLlFVRVVFRCB8fFxuICAgICAgICBjaHVuay5zdGF0dXMgPT09IENodW5rU3RhdHVzLkVSUk9SXG4gICAgICApO1xuICAgIH07XG5cbiAgICB2YXIgcHJvY2Vzc0NodW5rID0gZnVuY3Rpb24gcHJvY2Vzc0NodW5rKGNodW5rKSB7XG4gICAgICAvLyBwcm9jZXNzaW5nIGlzIHBhdXNlZCwgd2FpdCBoZXJlXG4gICAgICBpZiAoc3RhdGUuYWJvcnRlZCkgcmV0dXJuO1xuXG4gICAgICAvLyBnZXQgbmV4dCBjaHVuayB0byBwcm9jZXNzXG4gICAgICBjaHVuayA9IGNodW5rIHx8IGNodW5rcy5maW5kKGNhblByb2Nlc3NDaHVuayk7XG5cbiAgICAgIC8vIG5vIG1vcmUgY2h1bmtzIHRvIHByb2Nlc3NcbiAgICAgIGlmICghY2h1bmspIHtcbiAgICAgICAgLy8gYWxsIGRvbmU/XG4gICAgICAgIGlmIChcbiAgICAgICAgICBjaHVua3MuZXZlcnkoZnVuY3Rpb24oY2h1bmspIHtcbiAgICAgICAgICAgIHJldHVybiBjaHVuay5zdGF0dXMgPT09IENodW5rU3RhdHVzLkNPTVBMRVRFO1xuICAgICAgICAgIH0pXG4gICAgICAgICkge1xuICAgICAgICAgIGNvbXBsZXRlUHJvY2Vzc2luZ0NodW5rcygpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbm8gY2h1bmsgdG8gaGFuZGxlXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gbm93IHByb2Nlc3NpbmcgdGhpcyBjaHVua1xuICAgICAgY2h1bmsuc3RhdHVzID0gQ2h1bmtTdGF0dXMuUFJPQ0VTU0lORztcbiAgICAgIGNodW5rLnByb2dyZXNzID0gbnVsbDtcblxuICAgICAgLy8gYWxsb3cgcGFyc2luZyBvZiBmb3JtZGF0YVxuICAgICAgdmFyIG9uZGF0YSA9XG4gICAgICAgIGNodW5rU2VydmVyLm9uZGF0YSB8fFxuICAgICAgICBmdW5jdGlvbihmZCkge1xuICAgICAgICAgIHJldHVybiBmZDtcbiAgICAgICAgfTtcbiAgICAgIHZhciBvbmVycm9yID1cbiAgICAgICAgY2h1bmtTZXJ2ZXIub25lcnJvciB8fFxuICAgICAgICBmdW5jdGlvbihyZXMpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcblxuICAgICAgLy8gc2VuZCByZXF1ZXN0IG9iamVjdFxuICAgICAgdmFyIHJlcXVlc3RVcmwgPSBidWlsZFVSTChhcGlVcmwsIGNodW5rU2VydmVyLnVybCwgc3RhdGUuc2VydmVySWQpO1xuXG4gICAgICB2YXIgaGVhZGVycyA9XG4gICAgICAgIHR5cGVvZiBjaHVua1NlcnZlci5oZWFkZXJzID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgPyBjaHVua1NlcnZlci5oZWFkZXJzKGNodW5rKVxuICAgICAgICAgIDogT2JqZWN0LmFzc2lnbih7fSwgY2h1bmtTZXJ2ZXIuaGVhZGVycywge1xuICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL29mZnNldCtvY3RldC1zdHJlYW0nLFxuICAgICAgICAgICAgICAnVXBsb2FkLU9mZnNldCc6IGNodW5rLm9mZnNldCxcbiAgICAgICAgICAgICAgJ1VwbG9hZC1MZW5ndGgnOiBmaWxlLnNpemUsXG4gICAgICAgICAgICAgICdVcGxvYWQtTmFtZSc6IGZpbGUubmFtZVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgIHZhciByZXF1ZXN0ID0gKGNodW5rLnJlcXVlc3QgPSBzZW5kUmVxdWVzdChcbiAgICAgICAgb25kYXRhKGNodW5rLmRhdGEpLFxuICAgICAgICByZXF1ZXN0VXJsLFxuICAgICAgICBPYmplY3QuYXNzaWduKHt9LCBjaHVua1NlcnZlciwge1xuICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnNcbiAgICAgICAgfSlcbiAgICAgICkpO1xuXG4gICAgICByZXF1ZXN0Lm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBkb25lIVxuICAgICAgICBjaHVuay5zdGF0dXMgPSBDaHVua1N0YXR1cy5DT01QTEVURTtcblxuICAgICAgICAvLyByZW1vdmUgcmVxdWVzdCByZWZlcmVuY2VcbiAgICAgICAgY2h1bmsucmVxdWVzdCA9IG51bGw7XG5cbiAgICAgICAgLy8gc3RhcnQgcHJvY2Vzc2luZyBtb3JlIGNodW5rc1xuICAgICAgICBwcm9jZXNzQ2h1bmtzKCk7XG4gICAgICB9O1xuXG4gICAgICByZXF1ZXN0Lm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbihsZW5ndGhDb21wdXRhYmxlLCBsb2FkZWQsIHRvdGFsKSB7XG4gICAgICAgIGNodW5rLnByb2dyZXNzID0gbGVuZ3RoQ29tcHV0YWJsZSA/IGxvYWRlZCA6IG51bGw7XG4gICAgICAgIHVwZGF0ZVRvdGFsUHJvZ3Jlc3MoKTtcbiAgICAgIH07XG5cbiAgICAgIHJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uKHhocikge1xuICAgICAgICBjaHVuay5zdGF0dXMgPSBDaHVua1N0YXR1cy5FUlJPUjtcbiAgICAgICAgY2h1bmsucmVxdWVzdCA9IG51bGw7XG4gICAgICAgIGNodW5rLmVycm9yID0gb25lcnJvcih4aHIucmVzcG9uc2UpIHx8IHhoci5zdGF0dXNUZXh0O1xuICAgICAgICBpZiAoIXJldHJ5UHJvY2Vzc0NodW5rKGNodW5rKSkge1xuICAgICAgICAgIGVycm9yKFxuICAgICAgICAgICAgY3JlYXRlUmVzcG9uc2UoXG4gICAgICAgICAgICAgICdlcnJvcicsXG4gICAgICAgICAgICAgIHhoci5zdGF0dXMsXG4gICAgICAgICAgICAgIG9uZXJyb3IoeGhyLnJlc3BvbnNlKSB8fCB4aHIuc3RhdHVzVGV4dCxcbiAgICAgICAgICAgICAgeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgcmVxdWVzdC5vbnRpbWVvdXQgPSBmdW5jdGlvbih4aHIpIHtcbiAgICAgICAgY2h1bmsuc3RhdHVzID0gQ2h1bmtTdGF0dXMuRVJST1I7XG4gICAgICAgIGNodW5rLnJlcXVlc3QgPSBudWxsO1xuICAgICAgICBpZiAoIXJldHJ5UHJvY2Vzc0NodW5rKGNodW5rKSkge1xuICAgICAgICAgIGNyZWF0ZVRpbWVvdXRSZXNwb25zZShlcnJvcikoeGhyKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgcmVxdWVzdC5vbmFib3J0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGNodW5rLnN0YXR1cyA9IENodW5rU3RhdHVzLlFVRVVFRDtcbiAgICAgICAgY2h1bmsucmVxdWVzdCA9IG51bGw7XG4gICAgICAgIGFib3J0KCk7XG4gICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgcmV0cnlQcm9jZXNzQ2h1bmsgPSBmdW5jdGlvbiByZXRyeVByb2Nlc3NDaHVuayhjaHVuaykge1xuICAgICAgLy8gbm8gbW9yZSByZXRyaWVzIGxlZnRcbiAgICAgIGlmIChjaHVuay5yZXRyaWVzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAvLyBuZXcgcmV0cnlcbiAgICAgIGNodW5rLnN0YXR1cyA9IENodW5rU3RhdHVzLldBSVRJTkc7XG4gICAgICBjbGVhclRpbWVvdXQoY2h1bmsudGltZW91dCk7XG4gICAgICBjaHVuay50aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgcHJvY2Vzc0NodW5rKGNodW5rKTtcbiAgICAgIH0sIGNodW5rLnJldHJpZXMuc2hpZnQoKSk7XG5cbiAgICAgIC8vIHdlJ3JlIGdvaW5nIHRvIHJldHJ5XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgdmFyIHVwZGF0ZVRvdGFsUHJvZ3Jlc3MgPSBmdW5jdGlvbiB1cGRhdGVUb3RhbFByb2dyZXNzKCkge1xuICAgICAgLy8gY2FsY3VsYXRlIHRvdGFsIHByb2dyZXNzIGZyYWN0aW9uXG4gICAgICB2YXIgdG90YWxCeXRlc1RyYW5zZmVyZWQgPSBjaHVua3MucmVkdWNlKGZ1bmN0aW9uKHAsIGNodW5rKSB7XG4gICAgICAgIGlmIChwID09PSBudWxsIHx8IGNodW5rLnByb2dyZXNzID09PSBudWxsKSByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIHAgKyBjaHVuay5wcm9ncmVzcztcbiAgICAgIH0sIDApO1xuXG4gICAgICAvLyBjYW4ndCBjb21wdXRlIHByb2dyZXNzXG4gICAgICBpZiAodG90YWxCeXRlc1RyYW5zZmVyZWQgPT09IG51bGwpIHJldHVybiBwcm9ncmVzcyhmYWxzZSwgMCwgMCk7XG5cbiAgICAgIC8vIGNhbGN1bGF0ZSBwcm9ncmVzcyB2YWx1ZXNcbiAgICAgIHZhciB0b3RhbFNpemUgPSBjaHVua3MucmVkdWNlKGZ1bmN0aW9uKHRvdGFsLCBjaHVuaykge1xuICAgICAgICByZXR1cm4gdG90YWwgKyBjaHVuay5zaXplO1xuICAgICAgfSwgMCk7XG5cbiAgICAgIC8vIGNhbiB1cGRhdGUgcHJvZ3Jlc3MgaW5kaWNhdG9yXG4gICAgICBwcm9ncmVzcyh0cnVlLCB0b3RhbEJ5dGVzVHJhbnNmZXJlZCwgdG90YWxTaXplKTtcbiAgICB9O1xuXG4gICAgLy8gcHJvY2VzcyBuZXcgY2h1bmtzXG4gICAgdmFyIHByb2Nlc3NDaHVua3MgPSBmdW5jdGlvbiBwcm9jZXNzQ2h1bmtzKCkge1xuICAgICAgdmFyIHRvdGFsUHJvY2Vzc2luZyA9IGNodW5rcy5maWx0ZXIoZnVuY3Rpb24oY2h1bmspIHtcbiAgICAgICAgcmV0dXJuIGNodW5rLnN0YXR1cyA9PT0gQ2h1bmtTdGF0dXMuUFJPQ0VTU0lORztcbiAgICAgIH0pLmxlbmd0aDtcbiAgICAgIGlmICh0b3RhbFByb2Nlc3NpbmcgPj0gMSkgcmV0dXJuO1xuICAgICAgcHJvY2Vzc0NodW5rKCk7XG4gICAgfTtcblxuICAgIHZhciBhYm9ydENodW5rcyA9IGZ1bmN0aW9uIGFib3J0Q2h1bmtzKCkge1xuICAgICAgY2h1bmtzLmZvckVhY2goZnVuY3Rpb24oY2h1bmspIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KGNodW5rLnRpbWVvdXQpO1xuICAgICAgICBpZiAoY2h1bmsucmVxdWVzdCkge1xuICAgICAgICAgIGNodW5rLnJlcXVlc3QuYWJvcnQoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIGxldCdzIGdvIVxuICAgIGlmICghc3RhdGUuc2VydmVySWQpIHtcbiAgICAgIHJlcXVlc3RUcmFuc2ZlcklkKGZ1bmN0aW9uKHNlcnZlcklkKSB7XG4gICAgICAgIC8vIHN0b3AgaGVyZSBpZiBhYm9ydGVkLCBtaWdodCBoYXZlIGhhcHBlbmVkIGluIGJldHdlZW4gcmVxdWVzdCBhbmQgY2FsbGJhY2tcbiAgICAgICAgaWYgKHN0YXRlLmFib3J0ZWQpIHJldHVybjtcblxuICAgICAgICAvLyBwYXNzIGJhY2sgdG8gaXRlbSBzbyB3ZSBjYW4gdXNlIGl0IGlmIHNvbWV0aGluZyBnb2VzIHdyb25nXG4gICAgICAgIHRyYW5zZmVyKHNlcnZlcklkKTtcblxuICAgICAgICAvLyBzdG9yZSBpbnRlcm5hbGx5XG4gICAgICAgIHN0YXRlLnNlcnZlcklkID0gc2VydmVySWQ7XG4gICAgICAgIHByb2Nlc3NDaHVua3MoKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXF1ZXN0VHJhbnNmZXJPZmZzZXQoZnVuY3Rpb24ob2Zmc2V0KSB7XG4gICAgICAgIC8vIHN0b3AgaGVyZSBpZiBhYm9ydGVkLCBtaWdodCBoYXZlIGhhcHBlbmVkIGluIGJldHdlZW4gcmVxdWVzdCBhbmQgY2FsbGJhY2tcbiAgICAgICAgaWYgKHN0YXRlLmFib3J0ZWQpIHJldHVybjtcblxuICAgICAgICAvLyBtYXJrIGNodW5rcyB3aXRoIGxvd2VyIG9mZnNldCBhcyBjb21wbGV0ZVxuICAgICAgICBjaHVua3NcbiAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKGNodW5rKSB7XG4gICAgICAgICAgICByZXR1cm4gY2h1bmsub2Zmc2V0IDwgb2Zmc2V0O1xuICAgICAgICAgIH0pXG4gICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24oY2h1bmspIHtcbiAgICAgICAgICAgIGNodW5rLnN0YXR1cyA9IENodW5rU3RhdHVzLkNPTVBMRVRFO1xuICAgICAgICAgICAgY2h1bmsucHJvZ3Jlc3MgPSBjaHVuay5zaXplO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGNvbnRpbnVlIHByb2Nlc3NpbmdcbiAgICAgICAgcHJvY2Vzc0NodW5rcygpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGFib3J0OiBmdW5jdGlvbiBhYm9ydCgpIHtcbiAgICAgICAgc3RhdGUuYWJvcnRlZCA9IHRydWU7XG4gICAgICAgIGFib3J0Q2h1bmtzKCk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICAvKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gc2lnbmF0dXJlOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZmlsZSwgbWV0YWRhdGEsIGxvYWQsIGVycm9yLCBwcm9ncmVzcywgYWJvcnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFib3J0OigpID0+IHt9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gIHZhciBjcmVhdGVGaWxlUHJvY2Vzc29yRnVuY3Rpb24gPSBmdW5jdGlvbiBjcmVhdGVGaWxlUHJvY2Vzc29yRnVuY3Rpb24oXG4gICAgYXBpVXJsLFxuICAgIGFjdGlvbixcbiAgICBuYW1lLFxuICAgIG9wdGlvbnNcbiAgKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGZpbGUsIG1ldGFkYXRhLCBsb2FkLCBlcnJvciwgcHJvZ3Jlc3MsIGFib3J0LCB0cmFuc2Zlcikge1xuICAgICAgLy8gbm8gZmlsZSByZWNlaXZlZFxuICAgICAgaWYgKCFmaWxlKSByZXR1cm47XG5cbiAgICAgIC8vIGlmIHdhcyBwYXNzZWQgYSBmaWxlLCBhbmQgd2UgY2FuIGNodW5rIGl0LCBleGl0IGhlcmVcbiAgICAgIHZhciBjYW5DaHVua1VwbG9hZCA9IG9wdGlvbnMuY2h1bmtVcGxvYWRzO1xuICAgICAgdmFyIHNob3VsZENodW5rVXBsb2FkID0gY2FuQ2h1bmtVcGxvYWQgJiYgZmlsZS5zaXplID4gb3B0aW9ucy5jaHVua1NpemU7XG4gICAgICB2YXIgd2lsbENodW5rVXBsb2FkID1cbiAgICAgICAgY2FuQ2h1bmtVcGxvYWQgJiYgKHNob3VsZENodW5rVXBsb2FkIHx8IG9wdGlvbnMuY2h1bmtGb3JjZSk7XG4gICAgICBpZiAoZmlsZSBpbnN0YW5jZW9mIEJsb2IgJiYgd2lsbENodW5rVXBsb2FkKVxuICAgICAgICByZXR1cm4gcHJvY2Vzc0ZpbGVDaHVua2VkKFxuICAgICAgICAgIGFwaVVybCxcbiAgICAgICAgICBhY3Rpb24sXG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBmaWxlLFxuICAgICAgICAgIG1ldGFkYXRhLFxuICAgICAgICAgIGxvYWQsXG4gICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgcHJvZ3Jlc3MsXG4gICAgICAgICAgYWJvcnQsXG4gICAgICAgICAgdHJhbnNmZXIsXG4gICAgICAgICAgb3B0aW9uc1xuICAgICAgICApO1xuXG4gICAgICAvLyBzZXQgaGFuZGxlcnNcbiAgICAgIHZhciBvbmRhdGEgPVxuICAgICAgICBhY3Rpb24ub25kYXRhIHx8XG4gICAgICAgIGZ1bmN0aW9uKGZkKSB7XG4gICAgICAgICAgcmV0dXJuIGZkO1xuICAgICAgICB9O1xuICAgICAgdmFyIG9ubG9hZCA9XG4gICAgICAgIGFjdGlvbi5vbmxvYWQgfHxcbiAgICAgICAgZnVuY3Rpb24ocmVzKSB7XG4gICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfTtcbiAgICAgIHZhciBvbmVycm9yID1cbiAgICAgICAgYWN0aW9uLm9uZXJyb3IgfHxcbiAgICAgICAgZnVuY3Rpb24ocmVzKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG5cbiAgICAgIC8vIGNyZWF0ZSBmb3JtZGF0YSBvYmplY3RcbiAgICAgIHZhciBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuXG4gICAgICAvLyBhZGQgbWV0YWRhdGEgdW5kZXIgc2FtZSBuYW1lXG4gICAgICBpZiAoaXNPYmplY3QobWV0YWRhdGEpKSB7XG4gICAgICAgIGZvcm1EYXRhLmFwcGVuZChuYW1lLCBKU09OLnN0cmluZ2lmeShtZXRhZGF0YSkpO1xuICAgICAgfVxuXG4gICAgICAvLyBUdXJuIGludG8gYW4gYXJyYXkgb2Ygb2JqZWN0cyBzbyBubyBtYXR0ZXIgd2hhdCB0aGUgaW5wdXQsIHdlIGNhbiBoYW5kbGUgaXQgdGhlIHNhbWUgd2F5XG4gICAgICAoZmlsZSBpbnN0YW5jZW9mIEJsb2IgPyBbeyBuYW1lOiBudWxsLCBmaWxlOiBmaWxlIH1dIDogZmlsZSkuZm9yRWFjaChcbiAgICAgICAgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBpdGVtLmZpbGUsXG4gICAgICAgICAgICBpdGVtLm5hbWUgPT09IG51bGxcbiAgICAgICAgICAgICAgPyBpdGVtLmZpbGUubmFtZVxuICAgICAgICAgICAgICA6ICcnICsgaXRlbS5uYW1lICsgaXRlbS5maWxlLm5hbWVcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICApO1xuXG4gICAgICAvLyBzZW5kIHJlcXVlc3Qgb2JqZWN0XG4gICAgICB2YXIgcmVxdWVzdCA9IHNlbmRSZXF1ZXN0KFxuICAgICAgICBvbmRhdGEoZm9ybURhdGEpLFxuICAgICAgICBidWlsZFVSTChhcGlVcmwsIGFjdGlvbi51cmwpLFxuICAgICAgICBhY3Rpb25cbiAgICAgICk7XG4gICAgICByZXF1ZXN0Lm9ubG9hZCA9IGZ1bmN0aW9uKHhocikge1xuICAgICAgICBsb2FkKFxuICAgICAgICAgIGNyZWF0ZVJlc3BvbnNlKFxuICAgICAgICAgICAgJ2xvYWQnLFxuICAgICAgICAgICAgeGhyLnN0YXR1cyxcbiAgICAgICAgICAgIG9ubG9hZCh4aHIucmVzcG9uc2UpLFxuICAgICAgICAgICAgeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfTtcblxuICAgICAgcmVxdWVzdC5vbmVycm9yID0gZnVuY3Rpb24oeGhyKSB7XG4gICAgICAgIGVycm9yKFxuICAgICAgICAgIGNyZWF0ZVJlc3BvbnNlKFxuICAgICAgICAgICAgJ2Vycm9yJyxcbiAgICAgICAgICAgIHhoci5zdGF0dXMsXG4gICAgICAgICAgICBvbmVycm9yKHhoci5yZXNwb25zZSkgfHwgeGhyLnN0YXR1c1RleHQsXG4gICAgICAgICAgICB4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKClcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9O1xuXG4gICAgICByZXF1ZXN0Lm9udGltZW91dCA9IGNyZWF0ZVRpbWVvdXRSZXNwb25zZShlcnJvcik7XG4gICAgICByZXF1ZXN0Lm9ucHJvZ3Jlc3MgPSBwcm9ncmVzcztcbiAgICAgIHJlcXVlc3Qub25hYm9ydCA9IGFib3J0O1xuXG4gICAgICAvLyBzaG91bGQgcmV0dXJuIHJlcXVlc3RcbiAgICAgIHJldHVybiByZXF1ZXN0O1xuICAgIH07XG4gIH07XG5cbiAgdmFyIGNyZWF0ZVByb2Nlc3NvckZ1bmN0aW9uID0gZnVuY3Rpb24gY3JlYXRlUHJvY2Vzc29yRnVuY3Rpb24oKSB7XG4gICAgdmFyIGFwaVVybCA9XG4gICAgICBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6ICcnO1xuICAgIHZhciBhY3Rpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgbmFtZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgPyBhcmd1bWVudHNbM10gOiB1bmRlZmluZWQ7XG5cbiAgICAvLyBjdXN0b20gaGFuZGxlciAoc2hvdWxkIGFsc28gaGFuZGxlIGZpbGUsIGxvYWQsIGVycm9yLCBwcm9ncmVzcyBhbmQgYWJvcnQpXG4gICAgaWYgKHR5cGVvZiBhY3Rpb24gPT09ICdmdW5jdGlvbicpXG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZvciAoXG4gICAgICAgICAgdmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBwYXJhbXMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwO1xuICAgICAgICAgIF9rZXkgPCBfbGVuO1xuICAgICAgICAgIF9rZXkrK1xuICAgICAgICApIHtcbiAgICAgICAgICBwYXJhbXNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFjdGlvbi5hcHBseSh2b2lkIDAsIFtuYW1lXS5jb25jYXQocGFyYW1zLCBbb3B0aW9uc10pKTtcbiAgICAgIH07XG5cbiAgICAvLyBubyBhY3Rpb24gc3VwcGxpZWRcbiAgICBpZiAoIWFjdGlvbiB8fCAhaXNTdHJpbmcoYWN0aW9uLnVybCkpIHJldHVybiBudWxsO1xuXG4gICAgLy8gaW50ZXJuYWwgaGFuZGxlclxuICAgIHJldHVybiBjcmVhdGVGaWxlUHJvY2Vzc29yRnVuY3Rpb24oYXBpVXJsLCBhY3Rpb24sIG5hbWUsIG9wdGlvbnMpO1xuICB9O1xuXG4gIC8qXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBzaWduYXR1cmU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAodW5pcXVlRmlsZUlkLCBsb2FkLCBlcnJvcikgPT4geyB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICB2YXIgY3JlYXRlUmV2ZXJ0RnVuY3Rpb24gPSBmdW5jdGlvbiBjcmVhdGVSZXZlcnRGdW5jdGlvbigpIHtcbiAgICB2YXIgYXBpVXJsID1cbiAgICAgIGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogJyc7XG4gICAgdmFyIGFjdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICAgIC8vIGlzIGN1c3RvbSBpbXBsZW1lbnRhdGlvblxuICAgIGlmICh0eXBlb2YgYWN0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gYWN0aW9uO1xuICAgIH1cblxuICAgIC8vIG5vIGFjdGlvbiBzdXBwbGllZCwgcmV0dXJuIHN0dWIgZnVuY3Rpb24sIGludGVyZmFjZSB3aWxsIHdvcmssIGJ1dCBmaWxlIHdvbid0IGJlIHJlbW92ZWRcbiAgICBpZiAoIWFjdGlvbiB8fCAhaXNTdHJpbmcoYWN0aW9uLnVybCkpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbih1bmlxdWVGaWxlSWQsIGxvYWQpIHtcbiAgICAgICAgcmV0dXJuIGxvYWQoKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gc2V0IG9ubG9hZCBoYW5sZGVyXG4gICAgdmFyIG9ubG9hZCA9XG4gICAgICBhY3Rpb24ub25sb2FkIHx8XG4gICAgICBmdW5jdGlvbihyZXMpIHtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH07XG4gICAgdmFyIG9uZXJyb3IgPVxuICAgICAgYWN0aW9uLm9uZXJyb3IgfHxcbiAgICAgIGZ1bmN0aW9uKHJlcykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG5cbiAgICAvLyBpbnRlcm5hbCBpbXBsZW1lbnRhdGlvblxuICAgIHJldHVybiBmdW5jdGlvbih1bmlxdWVGaWxlSWQsIGxvYWQsIGVycm9yKSB7XG4gICAgICB2YXIgcmVxdWVzdCA9IHNlbmRSZXF1ZXN0KFxuICAgICAgICB1bmlxdWVGaWxlSWQsXG4gICAgICAgIGFwaVVybCArIGFjdGlvbi51cmwsXG4gICAgICAgIGFjdGlvbiAvLyBjb250YWlucyBtZXRob2QsIGhlYWRlcnMgYW5kIHdpdGhDcmVkZW50aWFscyBwcm9wZXJ0aWVzXG4gICAgICApO1xuICAgICAgcmVxdWVzdC5vbmxvYWQgPSBmdW5jdGlvbih4aHIpIHtcbiAgICAgICAgbG9hZChcbiAgICAgICAgICBjcmVhdGVSZXNwb25zZShcbiAgICAgICAgICAgICdsb2FkJyxcbiAgICAgICAgICAgIHhoci5zdGF0dXMsXG4gICAgICAgICAgICBvbmxvYWQoeGhyLnJlc3BvbnNlKSxcbiAgICAgICAgICAgIHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKVxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH07XG5cbiAgICAgIHJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uKHhocikge1xuICAgICAgICBlcnJvcihcbiAgICAgICAgICBjcmVhdGVSZXNwb25zZShcbiAgICAgICAgICAgICdlcnJvcicsXG4gICAgICAgICAgICB4aHIuc3RhdHVzLFxuICAgICAgICAgICAgb25lcnJvcih4aHIucmVzcG9uc2UpIHx8IHhoci5zdGF0dXNUZXh0LFxuICAgICAgICAgICAgeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfTtcblxuICAgICAgcmVxdWVzdC5vbnRpbWVvdXQgPSBjcmVhdGVUaW1lb3V0UmVzcG9uc2UoZXJyb3IpO1xuXG4gICAgICByZXR1cm4gcmVxdWVzdDtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBnZXRSYW5kb21OdW1iZXIgPSBmdW5jdGlvbiBnZXRSYW5kb21OdW1iZXIoKSB7XG4gICAgdmFyIG1pbiA9XG4gICAgICBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG4gICAgdmFyIG1heCA9XG4gICAgICBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDE7XG4gICAgcmV0dXJuIG1pbiArIE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluKTtcbiAgfTtcblxuICB2YXIgY3JlYXRlUGVyY2VpdmVkUGVyZm9ybWFuY2VVcGRhdGVyID0gZnVuY3Rpb24gY3JlYXRlUGVyY2VpdmVkUGVyZm9ybWFuY2VVcGRhdGVyKFxuICAgIGNiXG4gICkge1xuICAgIHZhciBkdXJhdGlvbiA9XG4gICAgICBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDEwMDA7XG4gICAgdmFyIG9mZnNldCA9XG4gICAgICBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDA7XG4gICAgdmFyIHRpY2tNaW4gPVxuICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiAyNTtcbiAgICB2YXIgdGlja01heCA9XG4gICAgICBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IDI1MDtcbiAgICB2YXIgdGltZW91dCA9IG51bGw7XG4gICAgdmFyIHN0YXJ0ID0gRGF0ZS5ub3coKTtcblxuICAgIHZhciB0aWNrID0gZnVuY3Rpb24gdGljaygpIHtcbiAgICAgIHZhciBydW50aW1lID0gRGF0ZS5ub3coKSAtIHN0YXJ0O1xuICAgICAgdmFyIGRlbGF5ID0gZ2V0UmFuZG9tTnVtYmVyKHRpY2tNaW4sIHRpY2tNYXgpO1xuXG4gICAgICBpZiAocnVudGltZSArIGRlbGF5ID4gZHVyYXRpb24pIHtcbiAgICAgICAgZGVsYXkgPSBydW50aW1lICsgZGVsYXkgLSBkdXJhdGlvbjtcbiAgICAgIH1cblxuICAgICAgdmFyIHByb2dyZXNzID0gcnVudGltZSAvIGR1cmF0aW9uO1xuICAgICAgaWYgKHByb2dyZXNzID49IDEgfHwgZG9jdW1lbnQuaGlkZGVuKSB7XG4gICAgICAgIGNiKDEpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNiKHByb2dyZXNzKTtcblxuICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQodGljaywgZGVsYXkpO1xuICAgIH07XG5cbiAgICB0aWNrKCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgY2xlYXI6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICB2YXIgY3JlYXRlRmlsZVByb2Nlc3NvciA9IGZ1bmN0aW9uIGNyZWF0ZUZpbGVQcm9jZXNzb3IocHJvY2Vzc0ZuKSB7XG4gICAgdmFyIHN0YXRlID0ge1xuICAgICAgY29tcGxldGU6IGZhbHNlLFxuICAgICAgcGVyY2VpdmVkUHJvZ3Jlc3M6IDAsXG4gICAgICBwZXJjZWl2ZWRQZXJmb3JtYW5jZVVwZGF0ZXI6IG51bGwsXG4gICAgICBwcm9ncmVzczogbnVsbCxcbiAgICAgIHRpbWVzdGFtcDogbnVsbCxcbiAgICAgIHBlcmNlaXZlZER1cmF0aW9uOiAwLFxuICAgICAgZHVyYXRpb246IDAsXG4gICAgICByZXF1ZXN0OiBudWxsLFxuICAgICAgcmVzcG9uc2U6IG51bGxcbiAgICB9O1xuXG4gICAgdmFyIHByb2Nlc3MgPSBmdW5jdGlvbiBwcm9jZXNzKGZpbGUsIG1ldGFkYXRhKSB7XG4gICAgICB2YXIgcHJvZ3Jlc3NGbiA9IGZ1bmN0aW9uIHByb2dyZXNzRm4oKSB7XG4gICAgICAgIC8vIHdlJ3ZlIG5vdCB5ZXQgc3RhcnRlZCB0aGUgcmVhbCBkb3dubG9hZCwgc3RvcCBoZXJlXG4gICAgICAgIC8vIHRoZSByZXF1ZXN0IG1pZ2h0IG5vdCBnbyB0aHJvdWdoLCBmb3IgaW5zdGFuY2UsIHRoZXJlIG1pZ2h0IGJlIHNvbWUgc2VydmVyIHRyb3VibGVcbiAgICAgICAgLy8gaWYgc3RhdGUucHJvZ3Jlc3MgaXMgbnVsbCwgdGhlIHNlcnZlciBkb2VzIG5vdCBhbGxvdyBjb21wdXRpbmcgcHJvZ3Jlc3MgYW5kIHdlIHNob3cgdGhlIHNwaW5uZXIgaW5zdGVhZFxuICAgICAgICBpZiAoc3RhdGUuZHVyYXRpb24gPT09IDAgfHwgc3RhdGUucHJvZ3Jlc3MgPT09IG51bGwpIHJldHVybjtcblxuICAgICAgICAvLyBhcyB3ZSdyZSBub3cgcHJvY2Vzc2luZywgZmlyZSB0aGUgcHJvZ3Jlc3MgZXZlbnRcbiAgICAgICAgYXBpLmZpcmUoJ3Byb2dyZXNzJywgYXBpLmdldFByb2dyZXNzKCkpO1xuICAgICAgfTtcblxuICAgICAgdmFyIGNvbXBsZXRlRm4gPSBmdW5jdGlvbiBjb21wbGV0ZUZuKCkge1xuICAgICAgICBzdGF0ZS5jb21wbGV0ZSA9IHRydWU7XG4gICAgICAgIGFwaS5maXJlKCdsb2FkLXBlcmNlaXZlZCcsIHN0YXRlLnJlc3BvbnNlLmJvZHkpO1xuICAgICAgfTtcblxuICAgICAgLy8gbGV0J3Mgc3RhcnQgcHJvY2Vzc2luZ1xuICAgICAgYXBpLmZpcmUoJ3N0YXJ0Jyk7XG5cbiAgICAgIC8vIHNldCByZXF1ZXN0IHN0YXJ0XG4gICAgICBzdGF0ZS50aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuXG4gICAgICAvLyBjcmVhdGUgcGVyY2VpdmVkIHBlcmZvcm1hbmNlIHByb2dyZXNzIGluZGljYXRvclxuICAgICAgc3RhdGUucGVyY2VpdmVkUGVyZm9ybWFuY2VVcGRhdGVyID0gY3JlYXRlUGVyY2VpdmVkUGVyZm9ybWFuY2VVcGRhdGVyKFxuICAgICAgICBmdW5jdGlvbihwcm9ncmVzcykge1xuICAgICAgICAgIHN0YXRlLnBlcmNlaXZlZFByb2dyZXNzID0gcHJvZ3Jlc3M7XG4gICAgICAgICAgc3RhdGUucGVyY2VpdmVkRHVyYXRpb24gPSBEYXRlLm5vdygpIC0gc3RhdGUudGltZXN0YW1wO1xuXG4gICAgICAgICAgcHJvZ3Jlc3NGbigpO1xuXG4gICAgICAgICAgLy8gaWYgZmFrZSBwcm9ncmVzcyBpcyBkb25lLCBhbmQgYSByZXNwb25zZSBoYXMgYmVlbiByZWNlaXZlZCxcbiAgICAgICAgICAvLyBhbmQgd2UndmUgbm90IHlldCBjYWxsZWQgdGhlIGNvbXBsZXRlIG1ldGhvZFxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHN0YXRlLnJlc3BvbnNlICYmXG4gICAgICAgICAgICBzdGF0ZS5wZXJjZWl2ZWRQcm9ncmVzcyA9PT0gMSAmJlxuICAgICAgICAgICAgIXN0YXRlLmNvbXBsZXRlXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICAvLyB3ZSBkb25lIVxuICAgICAgICAgICAgY29tcGxldGVGbigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLy8gcmFuZG9tIGRlbGF5IGFzIGluIGEgbGlzdCBvZiBmaWxlcyB5b3Ugc3RhcnQgbm90aWNpbmdcbiAgICAgICAgLy8gZmlsZXMgdXBsb2FkaW5nIGF0IHRoZSBleGFjdCBzYW1lIHNwZWVkXG4gICAgICAgIGdldFJhbmRvbU51bWJlcig3NTAsIDE1MDApXG4gICAgICApO1xuXG4gICAgICAvLyByZW1lbWJlciByZXF1ZXN0IHNvIHdlIGNhbiBhYm9ydCBpdCBsYXRlclxuICAgICAgc3RhdGUucmVxdWVzdCA9IHByb2Nlc3NGbihcbiAgICAgICAgLy8gdGhlIGZpbGUgdG8gcHJvY2Vzc1xuICAgICAgICBmaWxlLFxuXG4gICAgICAgIC8vIHRoZSBtZXRhZGF0YSB0byBzZW5kIGFsb25nXG4gICAgICAgIG1ldGFkYXRhLFxuXG4gICAgICAgIC8vIGNhbGxiYWNrcyAobG9hZCwgZXJyb3IsIHByb2dyZXNzLCBhYm9ydCwgdHJhbnNmZXIpXG4gICAgICAgIC8vIGxvYWQgZXhwZWN0cyB0aGUgYm9keSB0byBiZSBhIHNlcnZlciBpZCBpZlxuICAgICAgICAvLyB5b3Ugd2FudCB0byBtYWtlIHVzZSBvZiByZXZlcnRcbiAgICAgICAgZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAvLyB3ZSBwdXQgdGhlIHJlc3BvbnNlIGluIHN0YXRlIHNvIHdlIGNhbiBhY2Nlc3NcbiAgICAgICAgICAvLyBpdCBvdXRzaWRlIG9mIHRoaXMgbWV0aG9kXG4gICAgICAgICAgc3RhdGUucmVzcG9uc2UgPSBpc09iamVjdChyZXNwb25zZSlcbiAgICAgICAgICAgID8gcmVzcG9uc2VcbiAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdsb2FkJyxcbiAgICAgICAgICAgICAgICBjb2RlOiAyMDAsXG4gICAgICAgICAgICAgICAgYm9keTogJycgKyByZXNwb25zZSxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7fVxuICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgLy8gdXBkYXRlIGR1cmF0aW9uXG4gICAgICAgICAgc3RhdGUuZHVyYXRpb24gPSBEYXRlLm5vdygpIC0gc3RhdGUudGltZXN0YW1wO1xuXG4gICAgICAgICAgLy8gZm9yY2UgcHJvZ3Jlc3MgdG8gMSBhcyB3ZSdyZSBub3cgZG9uZVxuICAgICAgICAgIHN0YXRlLnByb2dyZXNzID0gMTtcblxuICAgICAgICAgIC8vIGFjdHVhbCBsb2FkIGlzIGRvbmUgbGV0J3Mgc2hhcmUgcmVzdWx0c1xuICAgICAgICAgIGFwaS5maXJlKCdsb2FkJywgc3RhdGUucmVzcG9uc2UuYm9keSk7XG5cbiAgICAgICAgICAvLyB3ZSBhcmUgcmVhbGx5IGRvbmVcbiAgICAgICAgICAvLyBpZiBwZXJjZWl2ZWQgcHJvZ3Jlc3MgaXMgMSAoIHdhaXQgZm9yIHBlcmNlaXZlZCBwcm9ncmVzcyB0byBjb21wbGV0ZSApXG4gICAgICAgICAgLy8gb3IgaWYgc2VydmVyIGRvZXMgbm90IHN1cHBvcnQgcHJvZ3Jlc3MgKCBudWxsIClcbiAgICAgICAgICBpZiAoc3RhdGUucGVyY2VpdmVkUHJvZ3Jlc3MgPT09IDEpIHtcbiAgICAgICAgICAgIGNvbXBsZXRlRm4oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gZXJyb3IgaXMgZXhwZWN0ZWQgdG8gYmUgYW4gb2JqZWN0IHdpdGggdHlwZSwgY29kZSwgYm9keVxuICAgICAgICBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgIC8vIGNhbmNlbCB1cGRhdGVyXG4gICAgICAgICAgc3RhdGUucGVyY2VpdmVkUGVyZm9ybWFuY2VVcGRhdGVyLmNsZWFyKCk7XG5cbiAgICAgICAgICAvLyB1cGRhdGUgb3RoZXJzIGFib3V0IHRoaXMgZXJyb3JcbiAgICAgICAgICBhcGkuZmlyZShcbiAgICAgICAgICAgICdlcnJvcicsXG4gICAgICAgICAgICBpc09iamVjdChlcnJvcilcbiAgICAgICAgICAgICAgPyBlcnJvclxuICAgICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6ICdlcnJvcicsXG4gICAgICAgICAgICAgICAgICBjb2RlOiAwLFxuICAgICAgICAgICAgICAgICAgYm9keTogJycgKyBlcnJvclxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIGFjdHVhbCBwcm9jZXNzaW5nIHByb2dyZXNzXG4gICAgICAgIGZ1bmN0aW9uKGNvbXB1dGFibGUsIGN1cnJlbnQsIHRvdGFsKSB7XG4gICAgICAgICAgLy8gdXBkYXRlIGFjdHVhbCBkdXJhdGlvblxuICAgICAgICAgIHN0YXRlLmR1cmF0aW9uID0gRGF0ZS5ub3coKSAtIHN0YXRlLnRpbWVzdGFtcDtcblxuICAgICAgICAgIC8vIHVwZGF0ZSBhY3R1YWwgcHJvZ3Jlc3NcbiAgICAgICAgICBzdGF0ZS5wcm9ncmVzcyA9IGNvbXB1dGFibGUgPyBjdXJyZW50IC8gdG90YWwgOiBudWxsO1xuXG4gICAgICAgICAgcHJvZ3Jlc3NGbigpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIGFib3J0IGRvZXMgbm90IGV4cGVjdCBhIHZhbHVlXG4gICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIC8vIHN0b3AgdXBkYXRlclxuICAgICAgICAgIHN0YXRlLnBlcmNlaXZlZFBlcmZvcm1hbmNlVXBkYXRlci5jbGVhcigpO1xuXG4gICAgICAgICAgLy8gZmlyZSB0aGUgYWJvcnQgZXZlbnQgc28gd2UgY2FuIHN3aXRjaCB2aXN1YWxzXG4gICAgICAgICAgYXBpLmZpcmUoJ2Fib3J0Jywgc3RhdGUucmVzcG9uc2UgPyBzdGF0ZS5yZXNwb25zZS5ib2R5IDogbnVsbCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gcmVnaXN0ZXIgdGhlIGlkIGZvciB0aGlzIHRyYW5zZmVyXG4gICAgICAgIGZ1bmN0aW9uKHRyYW5zZmVySWQpIHtcbiAgICAgICAgICBhcGkuZmlyZSgndHJhbnNmZXInLCB0cmFuc2ZlcklkKTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9O1xuXG4gICAgdmFyIGFib3J0ID0gZnVuY3Rpb24gYWJvcnQoKSB7XG4gICAgICAvLyBubyByZXF1ZXN0IHJ1bm5pbmcsIGNhbid0IGFib3J0XG4gICAgICBpZiAoIXN0YXRlLnJlcXVlc3QpIHJldHVybjtcblxuICAgICAgLy8gc3RvcCB1cGRhdGVyXG4gICAgICBzdGF0ZS5wZXJjZWl2ZWRQZXJmb3JtYW5jZVVwZGF0ZXIuY2xlYXIoKTtcblxuICAgICAgLy8gYWJvcnQgYWN0dWFsIHJlcXVlc3RcbiAgICAgIGlmIChzdGF0ZS5yZXF1ZXN0LmFib3J0KSBzdGF0ZS5yZXF1ZXN0LmFib3J0KCk7XG5cbiAgICAgIC8vIGlmIGhhcyByZXNwb25zZSBvYmplY3QsIHdlJ3ZlIGNvbXBsZXRlZCB0aGUgcmVxdWVzdFxuICAgICAgc3RhdGUuY29tcGxldGUgPSB0cnVlO1xuICAgIH07XG5cbiAgICB2YXIgcmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgIGFib3J0KCk7XG4gICAgICBzdGF0ZS5jb21wbGV0ZSA9IGZhbHNlO1xuICAgICAgc3RhdGUucGVyY2VpdmVkUHJvZ3Jlc3MgPSAwO1xuICAgICAgc3RhdGUucHJvZ3Jlc3MgPSAwO1xuICAgICAgc3RhdGUudGltZXN0YW1wID0gbnVsbDtcbiAgICAgIHN0YXRlLnBlcmNlaXZlZER1cmF0aW9uID0gMDtcbiAgICAgIHN0YXRlLmR1cmF0aW9uID0gMDtcbiAgICAgIHN0YXRlLnJlcXVlc3QgPSBudWxsO1xuICAgICAgc3RhdGUucmVzcG9uc2UgPSBudWxsO1xuICAgIH07XG5cbiAgICB2YXIgZ2V0UHJvZ3Jlc3MgPSBmdW5jdGlvbiBnZXRQcm9ncmVzcygpIHtcbiAgICAgIHJldHVybiBzdGF0ZS5wcm9ncmVzc1xuICAgICAgICA/IE1hdGgubWluKHN0YXRlLnByb2dyZXNzLCBzdGF0ZS5wZXJjZWl2ZWRQcm9ncmVzcylcbiAgICAgICAgOiBudWxsO1xuICAgIH07XG4gICAgdmFyIGdldER1cmF0aW9uID0gZnVuY3Rpb24gZ2V0RHVyYXRpb24oKSB7XG4gICAgICByZXR1cm4gTWF0aC5taW4oc3RhdGUuZHVyYXRpb24sIHN0YXRlLnBlcmNlaXZlZER1cmF0aW9uKTtcbiAgICB9O1xuXG4gICAgdmFyIGFwaSA9IE9iamVjdC5hc3NpZ24oe30sIG9uKCksIHtcbiAgICAgIHByb2Nlc3M6IHByb2Nlc3MsIC8vIHN0YXJ0IHByb2Nlc3NpbmcgZmlsZVxuICAgICAgYWJvcnQ6IGFib3J0LCAvLyBhYm9ydCBhY3RpdmUgcHJvY2VzcyByZXF1ZXN0XG4gICAgICBnZXRQcm9ncmVzczogZ2V0UHJvZ3Jlc3MsXG4gICAgICBnZXREdXJhdGlvbjogZ2V0RHVyYXRpb24sXG4gICAgICByZXNldDogcmVzZXRcbiAgICB9KTtcblxuICAgIHJldHVybiBhcGk7XG4gIH07XG5cbiAgdmFyIGdldEZpbGVuYW1lV2l0aG91dEV4dGVuc2lvbiA9IGZ1bmN0aW9uIGdldEZpbGVuYW1lV2l0aG91dEV4dGVuc2lvbihuYW1lKSB7XG4gICAgcmV0dXJuIG5hbWUuc3Vic3RyKDAsIG5hbWUubGFzdEluZGV4T2YoJy4nKSkgfHwgbmFtZTtcbiAgfTtcblxuICB2YXIgY3JlYXRlRmlsZVN0dWIgPSBmdW5jdGlvbiBjcmVhdGVGaWxlU3R1Yihzb3VyY2UpIHtcbiAgICB2YXIgZGF0YSA9IFtzb3VyY2UubmFtZSwgc291cmNlLnNpemUsIHNvdXJjZS50eXBlXTtcblxuICAgIC8vIGlzIGJsb2Igb3IgYmFzZTY0LCB0aGVuIHdlIG5lZWQgdG8gc2V0IHRoZSBuYW1lXG4gICAgaWYgKHNvdXJjZSBpbnN0YW5jZW9mIEJsb2IgfHwgaXNCYXNlNjREYXRhVVJJKHNvdXJjZSkpIHtcbiAgICAgIGRhdGFbMF0gPSBzb3VyY2UubmFtZSB8fCBnZXREYXRlU3RyaW5nKCk7XG4gICAgfSBlbHNlIGlmIChpc0Jhc2U2NERhdGFVUkkoc291cmNlKSkge1xuICAgICAgLy8gaWYgaXMgYmFzZTY0IGRhdGEgdXJpIHdlIG5lZWQgdG8gZGV0ZXJtaW5lIHRoZSBhdmVyYWdlIHNpemUgYW5kIHR5cGVcbiAgICAgIGRhdGFbMV0gPSBzb3VyY2UubGVuZ3RoO1xuICAgICAgZGF0YVsyXSA9IGdldE1pbWVUeXBlRnJvbUJhc2U2NERhdGFVUkkoc291cmNlKTtcbiAgICB9IGVsc2UgaWYgKGlzU3RyaW5nKHNvdXJjZSkpIHtcbiAgICAgIC8vIHVybFxuICAgICAgZGF0YVswXSA9IGdldEZpbGVuYW1lRnJvbVVSTChzb3VyY2UpO1xuICAgICAgZGF0YVsxXSA9IDA7XG4gICAgICBkYXRhWzJdID0gJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbSc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IGRhdGFbMF0sXG4gICAgICBzaXplOiBkYXRhWzFdLFxuICAgICAgdHlwZTogZGF0YVsyXVxuICAgIH07XG4gIH07XG5cbiAgdmFyIGlzRmlsZSA9IGZ1bmN0aW9uIGlzRmlsZSh2YWx1ZSkge1xuICAgIHJldHVybiAhISh2YWx1ZSBpbnN0YW5jZW9mIEZpbGUgfHwgKHZhbHVlIGluc3RhbmNlb2YgQmxvYiAmJiB2YWx1ZS5uYW1lKSk7XG4gIH07XG5cbiAgdmFyIGRlZXBDbG9uZU9iamVjdCA9IGZ1bmN0aW9uIGRlZXBDbG9uZU9iamVjdChzcmMpIHtcbiAgICBpZiAoIWlzT2JqZWN0KHNyYykpIHJldHVybiBzcmM7XG4gICAgdmFyIHRhcmdldCA9IGlzQXJyYXkoc3JjKSA/IFtdIDoge307XG4gICAgZm9yICh2YXIga2V5IGluIHNyYykge1xuICAgICAgaWYgKCFzcmMuaGFzT3duUHJvcGVydHkoa2V5KSkgY29udGludWU7XG4gICAgICB2YXIgdiA9IHNyY1trZXldO1xuICAgICAgdGFyZ2V0W2tleV0gPSB2ICYmIGlzT2JqZWN0KHYpID8gZGVlcENsb25lT2JqZWN0KHYpIDogdjtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfTtcblxuICB2YXIgY3JlYXRlSXRlbSA9IGZ1bmN0aW9uIGNyZWF0ZUl0ZW0oKSB7XG4gICAgdmFyIG9yaWdpbiA9XG4gICAgICBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IG51bGw7XG4gICAgdmFyIHNlcnZlckZpbGVSZWZlcmVuY2UgPVxuICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBudWxsO1xuICAgIHZhciBmaWxlID1cbiAgICAgIGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogbnVsbDtcbiAgICAvLyB1bmlxdWUgaWQgZm9yIHRoaXMgaXRlbSwgaXMgdXNlZCB0byBpZGVudGlmeSB0aGUgaXRlbSBhY3Jvc3Mgdmlld3NcbiAgICB2YXIgaWQgPSBnZXRVbmlxdWVJZCgpO1xuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgaXRlbSBzdGF0ZVxuICAgICAqL1xuICAgIHZhciBzdGF0ZSA9IHtcbiAgICAgIC8vIGlzIGFyY2hpdmVkXG4gICAgICBhcmNoaXZlZDogZmFsc2UsXG5cbiAgICAgIC8vIGlmIGlzIGZyb3plbiwgbm8gbG9uZ2VyIGZpcmVzIGV2ZW50c1xuICAgICAgZnJvemVuOiBmYWxzZSxcblxuICAgICAgLy8gcmVtb3ZlZCBmcm9tIHZpZXdcbiAgICAgIHJlbGVhc2VkOiBmYWxzZSxcblxuICAgICAgLy8gb3JpZ2luYWwgc291cmNlXG4gICAgICBzb3VyY2U6IG51bGwsXG5cbiAgICAgIC8vIGZpbGUgbW9kZWwgcmVmZXJlbmNlXG4gICAgICBmaWxlOiBmaWxlLFxuXG4gICAgICAvLyBpZCBvZiBmaWxlIG9uIHNlcnZlclxuICAgICAgc2VydmVyRmlsZVJlZmVyZW5jZTogc2VydmVyRmlsZVJlZmVyZW5jZSxcblxuICAgICAgLy8gaWQgb2YgZmlsZSB0cmFuc2ZlciBvbiBzZXJ2ZXJcbiAgICAgIHRyYW5zZmVySWQ6IG51bGwsXG5cbiAgICAgIC8vIGlzIGFib3J0ZWRcbiAgICAgIHByb2Nlc3NpbmdBYm9ydGVkOiBmYWxzZSxcblxuICAgICAgLy8gY3VycmVudCBpdGVtIHN0YXR1c1xuICAgICAgc3RhdHVzOiBzZXJ2ZXJGaWxlUmVmZXJlbmNlXG4gICAgICAgID8gSXRlbVN0YXR1cy5QUk9DRVNTSU5HX0NPTVBMRVRFXG4gICAgICAgIDogSXRlbVN0YXR1cy5JTklULFxuXG4gICAgICAvLyBhY3RpdmUgcHJvY2Vzc2VzXG4gICAgICBhY3RpdmVMb2FkZXI6IG51bGwsXG4gICAgICBhY3RpdmVQcm9jZXNzb3I6IG51bGxcbiAgICB9O1xuXG4gICAgLy8gY2FsbGJhY2sgdXNlZCB3aGVuIGFib3J0IHByb2Nlc3NpbmcgaXMgY2FsbGVkIHRvIGxpbmsgYmFjayB0byB0aGUgcmVzb2x2ZSBtZXRob2RcbiAgICB2YXIgYWJvcnRQcm9jZXNzaW5nUmVxdWVzdENvbXBsZXRlID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEV4dGVybmFsbHkgYWRkZWQgaXRlbSBtZXRhZGF0YVxuICAgICAqL1xuICAgIHZhciBtZXRhZGF0YSA9IHt9O1xuXG4gICAgLy8gaXRlbSBkYXRhXG4gICAgdmFyIHNldFN0YXR1cyA9IGZ1bmN0aW9uIHNldFN0YXR1cyhzdGF0dXMpIHtcbiAgICAgIHJldHVybiAoc3RhdGUuc3RhdHVzID0gc3RhdHVzKTtcbiAgICB9O1xuXG4gICAgLy8gZmlyZSBldmVudCB1bmxlc3MgdGhlIGl0ZW0gaGFzIGJlZW4gYXJjaGl2ZWRcbiAgICB2YXIgZmlyZSA9IGZ1bmN0aW9uIGZpcmUoZXZlbnQpIHtcbiAgICAgIGlmIChzdGF0ZS5yZWxlYXNlZCB8fCBzdGF0ZS5mcm96ZW4pIHJldHVybjtcbiAgICAgIGZvciAoXG4gICAgICAgIHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCxcbiAgICAgICAgICBwYXJhbXMgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLFxuICAgICAgICAgIF9rZXkgPSAxO1xuICAgICAgICBfa2V5IDwgX2xlbjtcbiAgICAgICAgX2tleSsrXG4gICAgICApIHtcbiAgICAgICAgcGFyYW1zW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cbiAgICAgIGFwaS5maXJlLmFwcGx5KGFwaSwgW2V2ZW50XS5jb25jYXQocGFyYW1zKSk7XG4gICAgfTtcblxuICAgIC8vIGZpbGUgZGF0YVxuICAgIHZhciBnZXRGaWxlRXh0ZW5zaW9uID0gZnVuY3Rpb24gZ2V0RmlsZUV4dGVuc2lvbigpIHtcbiAgICAgIHJldHVybiBnZXRFeHRlbnNpb25Gcm9tRmlsZW5hbWUoc3RhdGUuZmlsZS5uYW1lKTtcbiAgICB9O1xuICAgIHZhciBnZXRGaWxlVHlwZSA9IGZ1bmN0aW9uIGdldEZpbGVUeXBlKCkge1xuICAgICAgcmV0dXJuIHN0YXRlLmZpbGUudHlwZTtcbiAgICB9O1xuICAgIHZhciBnZXRGaWxlU2l6ZSA9IGZ1bmN0aW9uIGdldEZpbGVTaXplKCkge1xuICAgICAgcmV0dXJuIHN0YXRlLmZpbGUuc2l6ZTtcbiAgICB9O1xuICAgIHZhciBnZXRGaWxlID0gZnVuY3Rpb24gZ2V0RmlsZSgpIHtcbiAgICAgIHJldHVybiBzdGF0ZS5maWxlO1xuICAgIH07XG5cbiAgICAvL1xuICAgIC8vIGxvZ2ljIHRvIGxvYWQgYSBmaWxlXG4gICAgLy9cbiAgICB2YXIgbG9hZCA9IGZ1bmN0aW9uIGxvYWQoc291cmNlLCBsb2FkZXIsIG9ubG9hZCkge1xuICAgICAgLy8gcmVtZW1iZXIgdGhlIG9yaWdpbmFsIGl0ZW0gc291cmNlXG4gICAgICBzdGF0ZS5zb3VyY2UgPSBzb3VyY2U7XG5cbiAgICAgIC8vIHNvdXJjZSBpcyBrbm93blxuICAgICAgYXBpLmZpcmVTeW5jKCdpbml0Jyk7XG5cbiAgICAgIC8vIGZpbGUgc3R1YiBpcyBhbHJlYWR5IHRoZXJlXG4gICAgICBpZiAoc3RhdGUuZmlsZSkge1xuICAgICAgICBhcGkuZmlyZVN5bmMoJ2xvYWQtc2tpcCcpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIHNldCBhIHN0dWIgZmlsZSBvYmplY3Qgd2hpbGUgbG9hZGluZyB0aGUgYWN0dWFsIGRhdGFcbiAgICAgIHN0YXRlLmZpbGUgPSBjcmVhdGVGaWxlU3R1Yihzb3VyY2UpO1xuXG4gICAgICAvLyBzdGFydHMgbG9hZGluZ1xuICAgICAgbG9hZGVyLm9uKCdpbml0JywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGZpcmUoJ2xvYWQtaW5pdCcpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIHdlJ2V2ZSByZWNlaXZlZCBhIHNpemUgaW5kaWNhdGlvbiwgbGV0J3MgdXBkYXRlIHRoZSBzdHViXG4gICAgICBsb2FkZXIub24oJ21ldGEnLCBmdW5jdGlvbihtZXRhKSB7XG4gICAgICAgIC8vIHNldCBzaXplIG9mIGZpbGUgc3R1YlxuICAgICAgICBzdGF0ZS5maWxlLnNpemUgPSBtZXRhLnNpemU7XG5cbiAgICAgICAgLy8gc2V0IG5hbWUgb2YgZmlsZSBzdHViXG4gICAgICAgIHN0YXRlLmZpbGUuZmlsZW5hbWUgPSBtZXRhLmZpbGVuYW1lO1xuXG4gICAgICAgIC8vIGlmIGhhcyByZWNlaXZlZCBzb3VyY2UsIHdlIGRvbmVcbiAgICAgICAgaWYgKG1ldGEuc291cmNlKSB7XG4gICAgICAgICAgb3JpZ2luID0gRmlsZU9yaWdpbi5MSU1CTztcbiAgICAgICAgICBzdGF0ZS5zZXJ2ZXJGaWxlUmVmZXJlbmNlID0gbWV0YS5zb3VyY2U7XG4gICAgICAgICAgc3RhdGUuc3RhdHVzID0gSXRlbVN0YXR1cy5QUk9DRVNTSU5HX0NPTVBMRVRFO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2l6ZSBoYXMgYmVlbiB1cGRhdGVkXG4gICAgICAgIGZpcmUoJ2xvYWQtbWV0YScpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIHRoZSBmaWxlIGlzIG5vdyBsb2FkaW5nIHdlIG5lZWQgdG8gdXBkYXRlIHRoZSBwcm9ncmVzcyBpbmRpY2F0b3JzXG4gICAgICBsb2FkZXIub24oJ3Byb2dyZXNzJywgZnVuY3Rpb24ocHJvZ3Jlc3MpIHtcbiAgICAgICAgc2V0U3RhdHVzKEl0ZW1TdGF0dXMuTE9BRElORyk7XG5cbiAgICAgICAgZmlyZSgnbG9hZC1wcm9ncmVzcycsIHByb2dyZXNzKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBhbiBlcnJvciB3YXMgdGhyb3duIHdoaWxlIGxvYWRpbmcgdGhlIGZpbGUsIHdlIG5lZWQgdG8gc3dpdGNoIHRvIGVycm9yIHN0YXRlXG4gICAgICBsb2FkZXIub24oJ2Vycm9yJywgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgc2V0U3RhdHVzKEl0ZW1TdGF0dXMuTE9BRF9FUlJPUik7XG5cbiAgICAgICAgZmlyZSgnbG9hZC1yZXF1ZXN0LWVycm9yJywgZXJyb3IpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIHVzZXIgb3IgYW5vdGhlciBwcm9jZXNzIGFib3J0ZWQgdGhlIGZpbGUgbG9hZCAoY2Fubm90IHJldHJ5KVxuICAgICAgbG9hZGVyLm9uKCdhYm9ydCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICBzZXRTdGF0dXMoSXRlbVN0YXR1cy5JTklUKTtcbiAgICAgICAgZmlyZSgnbG9hZC1hYm9ydCcpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIGRvbmUgbG9hZGluZ1xuICAgICAgbG9hZGVyLm9uKCdsb2FkJywgZnVuY3Rpb24oZmlsZSkge1xuICAgICAgICAvLyBhcyB3ZSd2ZSBub3cgbG9hZGVkIHRoZSBmaWxlIHRoZSBsb2FkZXIgaXMgbm8gbG9uZ2VyIHJlcXVpcmVkXG4gICAgICAgIHN0YXRlLmFjdGl2ZUxvYWRlciA9IG51bGw7XG5cbiAgICAgICAgLy8gY2FsbGVkIHdoZW4gZmlsZSBoYXMgbG9hZGVkIHN1Y2Nlc2Z1bGx5XG4gICAgICAgIHZhciBzdWNjZXNzID0gZnVuY3Rpb24gc3VjY2VzcyhyZXN1bHQpIHtcbiAgICAgICAgICAvLyBzZXQgKHBvc3NpYmx5KSB0cmFuc2Zvcm1lZCBmaWxlXG4gICAgICAgICAgc3RhdGUuZmlsZSA9IGlzRmlsZShyZXN1bHQpID8gcmVzdWx0IDogc3RhdGUuZmlsZTtcblxuICAgICAgICAgIC8vIGZpbGUgcmVjZWl2ZWRcbiAgICAgICAgICBpZiAob3JpZ2luID09PSBGaWxlT3JpZ2luLkxJTUJPICYmIHN0YXRlLnNlcnZlckZpbGVSZWZlcmVuY2UpIHtcbiAgICAgICAgICAgIHNldFN0YXR1cyhJdGVtU3RhdHVzLlBST0NFU1NJTkdfQ09NUExFVEUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXRTdGF0dXMoSXRlbVN0YXR1cy5JRExFKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmaXJlKCdsb2FkJyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGVycm9yID0gZnVuY3Rpb24gZXJyb3IocmVzdWx0KSB7XG4gICAgICAgICAgLy8gc2V0IG9yaWdpbmFsIGZpbGVcbiAgICAgICAgICBzdGF0ZS5maWxlID0gZmlsZTtcbiAgICAgICAgICBmaXJlKCdsb2FkLW1ldGEnKTtcblxuICAgICAgICAgIHNldFN0YXR1cyhJdGVtU3RhdHVzLkxPQURfRVJST1IpO1xuICAgICAgICAgIGZpcmUoJ2xvYWQtZmlsZS1lcnJvcicsIHJlc3VsdCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gaWYgd2UgYWxyZWFkeSBoYXZlIGEgc2VydmVyIGZpbGUgcmVmZXJlbmNlLCB3ZSBkb24ndCBuZWVkIHRvIGNhbGwgdGhlIG9ubG9hZCBtZXRob2RcbiAgICAgICAgaWYgKHN0YXRlLnNlcnZlckZpbGVSZWZlcmVuY2UpIHtcbiAgICAgICAgICBzdWNjZXNzKGZpbGUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG5vIHNlcnZlciBpZCwgbGV0J3MgZ2l2ZSB0aGlzIGZpbGUgdGhlIGZ1bGwgdHJlYXRtZW50XG4gICAgICAgIG9ubG9hZChmaWxlLCBzdWNjZXNzLCBlcnJvcik7XG4gICAgICB9KTtcblxuICAgICAgLy8gc2V0IGxvYWRlciBzb3VyY2UgZGF0YVxuICAgICAgbG9hZGVyLnNldFNvdXJjZShzb3VyY2UpO1xuXG4gICAgICAvLyBzZXQgYXMgYWN0aXZlIGxvYWRlclxuICAgICAgc3RhdGUuYWN0aXZlTG9hZGVyID0gbG9hZGVyO1xuXG4gICAgICAvLyBsb2FkIHRoZSBzb3VyY2UgZGF0YVxuICAgICAgbG9hZGVyLmxvYWQoKTtcbiAgICB9O1xuXG4gICAgdmFyIHJldHJ5TG9hZCA9IGZ1bmN0aW9uIHJldHJ5TG9hZCgpIHtcbiAgICAgIGlmICghc3RhdGUuYWN0aXZlTG9hZGVyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHN0YXRlLmFjdGl2ZUxvYWRlci5sb2FkKCk7XG4gICAgfTtcblxuICAgIHZhciBhYm9ydExvYWQgPSBmdW5jdGlvbiBhYm9ydExvYWQoKSB7XG4gICAgICBpZiAoc3RhdGUuYWN0aXZlTG9hZGVyKSB7XG4gICAgICAgIHN0YXRlLmFjdGl2ZUxvYWRlci5hYm9ydCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzZXRTdGF0dXMoSXRlbVN0YXR1cy5JTklUKTtcbiAgICAgIGZpcmUoJ2xvYWQtYWJvcnQnKTtcbiAgICB9O1xuXG4gICAgLy9cbiAgICAvLyBsb2dpYyB0byBwcm9jZXNzIGEgZmlsZVxuICAgIC8vXG4gICAgdmFyIHByb2Nlc3MgPSBmdW5jdGlvbiBwcm9jZXNzKHByb2Nlc3Nvciwgb25wcm9jZXNzKSB7XG4gICAgICAvLyBwcm9jZXNzaW5nIHdhcyBhYm9ydGVkXG4gICAgICBpZiAoc3RhdGUucHJvY2Vzc2luZ0Fib3J0ZWQpIHtcbiAgICAgICAgc3RhdGUucHJvY2Vzc2luZ0Fib3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBub3cgcHJvY2Vzc2luZ1xuICAgICAgc2V0U3RhdHVzKEl0ZW1TdGF0dXMuUFJPQ0VTU0lORyk7XG5cbiAgICAgIC8vIHJlc2V0IGFib3J0IGNhbGxiYWNrXG4gICAgICBhYm9ydFByb2Nlc3NpbmdSZXF1ZXN0Q29tcGxldGUgPSBudWxsO1xuXG4gICAgICAvLyBpZiBubyBmaWxlIGxvYWRlZCB3ZSdsbCB3YWl0IGZvciB0aGUgbG9hZCBldmVudFxuICAgICAgaWYgKCEoc3RhdGUuZmlsZSBpbnN0YW5jZW9mIEJsb2IpKSB7XG4gICAgICAgIGFwaS5vbignbG9hZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHByb2Nlc3MocHJvY2Vzc29yLCBvbnByb2Nlc3MpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBzZXR1cCBwcm9jZXNzb3JcbiAgICAgIHByb2Nlc3Nvci5vbignbG9hZCcsIGZ1bmN0aW9uKHNlcnZlckZpbGVSZWZlcmVuY2UpIHtcbiAgICAgICAgLy8gbmVlZCB0aGlzIGlkIHRvIGJlIGFibGUgdG8gcmV2ZXJ0IHRoZSB1cGxvYWRcbiAgICAgICAgc3RhdGUudHJhbnNmZXJJZCA9IG51bGw7XG4gICAgICAgIHN0YXRlLnNlcnZlckZpbGVSZWZlcmVuY2UgPSBzZXJ2ZXJGaWxlUmVmZXJlbmNlO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIHJlZ2lzdGVyIHRyYW5zZmVyIGlkXG4gICAgICBwcm9jZXNzb3Iub24oJ3RyYW5zZmVyJywgZnVuY3Rpb24odHJhbnNmZXJJZCkge1xuICAgICAgICAvLyBuZWVkIHRoaXMgaWQgdG8gYmUgYWJsZSB0byByZXZlcnQgdGhlIHVwbG9hZFxuICAgICAgICBzdGF0ZS50cmFuc2ZlcklkID0gdHJhbnNmZXJJZDtcbiAgICAgIH0pO1xuXG4gICAgICBwcm9jZXNzb3Iub24oJ2xvYWQtcGVyY2VpdmVkJywgZnVuY3Rpb24oc2VydmVyRmlsZVJlZmVyZW5jZSkge1xuICAgICAgICAvLyBubyBsb25nZXIgcmVxdWlyZWRcbiAgICAgICAgc3RhdGUuYWN0aXZlUHJvY2Vzc29yID0gbnVsbDtcblxuICAgICAgICAvLyBuZWVkIHRoaXMgaWQgdG8gYmUgYWJsZSB0byByZXZlciB0aGUgdXBsb2FkXG4gICAgICAgIHN0YXRlLnRyYW5zZmVySWQgPSBudWxsO1xuICAgICAgICBzdGF0ZS5zZXJ2ZXJGaWxlUmVmZXJlbmNlID0gc2VydmVyRmlsZVJlZmVyZW5jZTtcblxuICAgICAgICBzZXRTdGF0dXMoSXRlbVN0YXR1cy5QUk9DRVNTSU5HX0NPTVBMRVRFKTtcbiAgICAgICAgZmlyZSgncHJvY2Vzcy1jb21wbGV0ZScsIHNlcnZlckZpbGVSZWZlcmVuY2UpO1xuICAgICAgfSk7XG5cbiAgICAgIHByb2Nlc3Nvci5vbignc3RhcnQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgZmlyZSgncHJvY2Vzcy1zdGFydCcpO1xuICAgICAgfSk7XG5cbiAgICAgIHByb2Nlc3Nvci5vbignZXJyb3InLCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICBzdGF0ZS5hY3RpdmVQcm9jZXNzb3IgPSBudWxsO1xuICAgICAgICBzZXRTdGF0dXMoSXRlbVN0YXR1cy5QUk9DRVNTSU5HX0VSUk9SKTtcbiAgICAgICAgZmlyZSgncHJvY2Vzcy1lcnJvcicsIGVycm9yKTtcbiAgICAgIH0pO1xuXG4gICAgICBwcm9jZXNzb3Iub24oJ2Fib3J0JywgZnVuY3Rpb24oc2VydmVyRmlsZVJlZmVyZW5jZSkge1xuICAgICAgICBzdGF0ZS5hY3RpdmVQcm9jZXNzb3IgPSBudWxsO1xuXG4gICAgICAgIC8vIGlmIGZpbGUgd2FzIHVwbG9hZGVkIGJ1dCBwcm9jZXNzaW5nIHdhcyBjYW5jZWxsZWQgZHVyaW5nIHBlcmNlaXZlZCBwcm9jZXNzb3IgdGltZSBzdG9yZSBmaWxlIHJlZmVyZW5jZVxuICAgICAgICBzdGF0ZS50cmFuc2ZlcklkID0gbnVsbDtcbiAgICAgICAgc3RhdGUuc2VydmVyRmlsZVJlZmVyZW5jZSA9IHNlcnZlckZpbGVSZWZlcmVuY2U7XG5cbiAgICAgICAgc2V0U3RhdHVzKEl0ZW1TdGF0dXMuSURMRSk7XG4gICAgICAgIGZpcmUoJ3Byb2Nlc3MtYWJvcnQnKTtcblxuICAgICAgICAvLyBoYXMgdGltZW91dCBzbyBkb2Vzbid0IGludGVyZmVyZSB3aXRoIHJlbW92ZSBhY3Rpb25cbiAgICAgICAgaWYgKGFib3J0UHJvY2Vzc2luZ1JlcXVlc3RDb21wbGV0ZSkge1xuICAgICAgICAgIGFib3J0UHJvY2Vzc2luZ1JlcXVlc3RDb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcHJvY2Vzc29yLm9uKCdwcm9ncmVzcycsIGZ1bmN0aW9uKHByb2dyZXNzKSB7XG4gICAgICAgIGZpcmUoJ3Byb2Nlc3MtcHJvZ3Jlc3MnLCBwcm9ncmVzcyk7XG4gICAgICB9KTtcblxuICAgICAgLy8gd2hlbiBzdWNjZXNzZnVsbHkgdHJhbnNmb3JtZWRcbiAgICAgIHZhciBzdWNjZXNzID0gZnVuY3Rpb24gc3VjY2VzcyhmaWxlKSB7XG4gICAgICAgIC8vIGlmIHdhcyBhcmNoaXZlZCBpbiB0aGUgbWVhbiB0aW1lLCBkb24ndCBwcm9jZXNzXG4gICAgICAgIGlmIChzdGF0ZS5hcmNoaXZlZCkgcmV0dXJuO1xuXG4gICAgICAgIC8vIHByb2Nlc3MgZmlsZSFcbiAgICAgICAgcHJvY2Vzc29yLnByb2Nlc3MoZmlsZSwgT2JqZWN0LmFzc2lnbih7fSwgbWV0YWRhdGEpKTtcbiAgICAgIH07XG5cbiAgICAgIC8vIHNvbWV0aGluZyB3ZW50IHdyb25nIGR1cmluZyB0cmFuc2Zvcm0gcGhhc2VcbiAgICAgIHZhciBlcnJvciA9IGNvbnNvbGUuZXJyb3I7XG5cbiAgICAgIC8vIHN0YXJ0IHByb2Nlc3NpbmcgdGhlIGZpbGVcbiAgICAgIG9ucHJvY2VzcyhzdGF0ZS5maWxlLCBzdWNjZXNzLCBlcnJvcik7XG5cbiAgICAgIC8vIHNldCBhcyBhY3RpdmUgcHJvY2Vzc29yXG4gICAgICBzdGF0ZS5hY3RpdmVQcm9jZXNzb3IgPSBwcm9jZXNzb3I7XG4gICAgfTtcblxuICAgIHZhciByZXF1ZXN0UHJvY2Vzc2luZyA9IGZ1bmN0aW9uIHJlcXVlc3RQcm9jZXNzaW5nKCkge1xuICAgICAgc3RhdGUucHJvY2Vzc2luZ0Fib3J0ZWQgPSBmYWxzZTtcbiAgICAgIHNldFN0YXR1cyhJdGVtU3RhdHVzLlBST0NFU1NJTkdfUVVFVUVEKTtcbiAgICB9O1xuXG4gICAgdmFyIGFib3J0UHJvY2Vzc2luZyA9IGZ1bmN0aW9uIGFib3J0UHJvY2Vzc2luZygpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlKSB7XG4gICAgICAgIGlmICghc3RhdGUuYWN0aXZlUHJvY2Vzc29yKSB7XG4gICAgICAgICAgc3RhdGUucHJvY2Vzc2luZ0Fib3J0ZWQgPSB0cnVlO1xuXG4gICAgICAgICAgc2V0U3RhdHVzKEl0ZW1TdGF0dXMuSURMRSk7XG4gICAgICAgICAgZmlyZSgncHJvY2Vzcy1hYm9ydCcpO1xuXG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGFib3J0UHJvY2Vzc2luZ1JlcXVlc3RDb21wbGV0ZSA9IGZ1bmN0aW9uIGFib3J0UHJvY2Vzc2luZ1JlcXVlc3RDb21wbGV0ZSgpIHtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgc3RhdGUuYWN0aXZlUHJvY2Vzc29yLmFib3J0KCk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy9cbiAgICAvLyBsb2dpYyB0byByZXZlcnQgYSBwcm9jZXNzZWQgZmlsZVxuICAgIC8vXG4gICAgdmFyIHJldmVydCA9IGZ1bmN0aW9uIHJldmVydChyZXZlcnRGaWxlVXBsb2FkLCBmb3JjZVJldmVydCkge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAvLyBjYW5ub3QgcmV2ZXJ0IHdpdGhvdXQgYSBzZXJ2ZXIgaWQgZm9yIHRoaXMgcHJvY2Vzc1xuICAgICAgICBpZiAoc3RhdGUuc2VydmVyRmlsZVJlZmVyZW5jZSA9PT0gbnVsbCkge1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXZlcnQgdGhlIHVwbG9hZCAoZmlyZSBhbmQgZm9yZ2V0KVxuICAgICAgICByZXZlcnRGaWxlVXBsb2FkKFxuICAgICAgICAgIHN0YXRlLnNlcnZlckZpbGVSZWZlcmVuY2UsXG4gICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyByZXNldCBmaWxlIHNlcnZlciBpZCBhcyBub3cgaXQncyBubyBhdmFpbGFibGUgb24gdGhlIHNlcnZlclxuICAgICAgICAgICAgc3RhdGUuc2VydmVyRmlsZVJlZmVyZW5jZSA9IG51bGw7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgICAgLy8gZG9uJ3Qgc2V0IGVycm9yIHN0YXRlIHdoZW4gcmV2ZXJ0aW5nIGlzIG9wdGlvbmFsLCBpdCB3aWxsIGFsd2F5cyByZXNvbHZlXG4gICAgICAgICAgICBpZiAoIWZvcmNlUmV2ZXJ0KSB7XG4gICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBvaCBubyBlcnJvcnNcbiAgICAgICAgICAgIHNldFN0YXR1cyhJdGVtU3RhdHVzLlBST0NFU1NJTkdfUkVWRVJUX0VSUk9SKTtcbiAgICAgICAgICAgIGZpcmUoJ3Byb2Nlc3MtcmV2ZXJ0LWVycm9yJyk7XG4gICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgKTtcblxuICAgICAgICAvLyBmaXJlIGV2ZW50XG4gICAgICAgIHNldFN0YXR1cyhJdGVtU3RhdHVzLklETEUpO1xuICAgICAgICBmaXJlKCdwcm9jZXNzLXJldmVydCcpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIGV4cG9zZWQgbWV0aG9kc1xuICAgIHZhciBfc2V0TWV0YWRhdGEgPSBmdW5jdGlvbiBzZXRNZXRhZGF0YShrZXksIHZhbHVlLCBzaWxlbnQpIHtcbiAgICAgIHZhciBrZXlzID0ga2V5LnNwbGl0KCcuJyk7XG4gICAgICB2YXIgcm9vdCA9IGtleXNbMF07XG4gICAgICB2YXIgbGFzdCA9IGtleXMucG9wKCk7XG4gICAgICB2YXIgZGF0YSA9IG1ldGFkYXRhO1xuICAgICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICByZXR1cm4gKGRhdGEgPSBkYXRhW2tleV0pO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIGNvbXBhcmUgb2xkIHZhbHVlIGFnYWluc3QgbmV3IHZhbHVlLCBpZiB0aGV5J3JlIHRoZSBzYW1lLCB3ZSdyZSBub3QgdXBkYXRpbmdcbiAgICAgIGlmIChKU09OLnN0cmluZ2lmeShkYXRhW2xhc3RdKSA9PT0gSlNPTi5zdHJpbmdpZnkodmFsdWUpKSByZXR1cm47XG5cbiAgICAgIC8vIHVwZGF0ZSB2YWx1ZVxuICAgICAgZGF0YVtsYXN0XSA9IHZhbHVlO1xuXG4gICAgICAvLyBkb24ndCBmaXJlIHVwZGF0ZVxuICAgICAgaWYgKHNpbGVudCkgcmV0dXJuO1xuXG4gICAgICAvLyBmaXJlIHVwZGF0ZVxuICAgICAgZmlyZSgnbWV0YWRhdGEtdXBkYXRlJywge1xuICAgICAgICBrZXk6IHJvb3QsXG4gICAgICAgIHZhbHVlOiBtZXRhZGF0YVtyb290XVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHZhciBnZXRNZXRhZGF0YSA9IGZ1bmN0aW9uIGdldE1ldGFkYXRhKGtleSkge1xuICAgICAgcmV0dXJuIGRlZXBDbG9uZU9iamVjdChrZXkgPyBtZXRhZGF0YVtrZXldIDogbWV0YWRhdGEpO1xuICAgIH07XG5cbiAgICB2YXIgYXBpID0gT2JqZWN0LmFzc2lnbihcbiAgICAgIHtcbiAgICAgICAgaWQ6IHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9yaWdpbjoge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIG9yaWdpbjtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNlcnZlcklkOiB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhdGUuc2VydmVyRmlsZVJlZmVyZW5jZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHRyYW5zZmVySWQ6IHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZS50cmFuc2ZlcklkO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc3RhdHVzOiB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhdGUuc3RhdHVzO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZmlsZW5hbWU6IHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZS5maWxlLm5hbWU7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBmaWxlbmFtZVdpdGhvdXRFeHRlbnNpb246IHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRGaWxlbmFtZVdpdGhvdXRFeHRlbnNpb24oc3RhdGUuZmlsZS5uYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGZpbGVFeHRlbnNpb246IHsgZ2V0OiBnZXRGaWxlRXh0ZW5zaW9uIH0sXG4gICAgICAgIGZpbGVUeXBlOiB7IGdldDogZ2V0RmlsZVR5cGUgfSxcbiAgICAgICAgZmlsZVNpemU6IHsgZ2V0OiBnZXRGaWxlU2l6ZSB9LFxuICAgICAgICBmaWxlOiB7IGdldDogZ2V0RmlsZSB9LFxuICAgICAgICByZWxhdGl2ZVBhdGg6IHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZS5maWxlLl9yZWxhdGl2ZVBhdGg7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHNvdXJjZToge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXRlLnNvdXJjZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0TWV0YWRhdGE6IGdldE1ldGFkYXRhLFxuICAgICAgICBzZXRNZXRhZGF0YTogZnVuY3Rpb24gc2V0TWV0YWRhdGEoa2V5LCB2YWx1ZSwgc2lsZW50KSB7XG4gICAgICAgICAgaWYgKGlzT2JqZWN0KGtleSkpIHtcbiAgICAgICAgICAgIHZhciBkYXRhID0ga2V5O1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoZGF0YSkuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgX3NldE1ldGFkYXRhKGtleSwgZGF0YVtrZXldLCB2YWx1ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBrZXk7XG4gICAgICAgICAgfVxuICAgICAgICAgIF9zZXRNZXRhZGF0YShrZXksIHZhbHVlLCBzaWxlbnQpO1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICBleHRlbmQ6IGZ1bmN0aW9uIGV4dGVuZChuYW1lLCBoYW5kbGVyKSB7XG4gICAgICAgICAgcmV0dXJuIChpdGVtQVBJW25hbWVdID0gaGFuZGxlcik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYWJvcnRMb2FkOiBhYm9ydExvYWQsXG4gICAgICAgIHJldHJ5TG9hZDogcmV0cnlMb2FkLFxuICAgICAgICByZXF1ZXN0UHJvY2Vzc2luZzogcmVxdWVzdFByb2Nlc3NpbmcsXG4gICAgICAgIGFib3J0UHJvY2Vzc2luZzogYWJvcnRQcm9jZXNzaW5nLFxuXG4gICAgICAgIGxvYWQ6IGxvYWQsXG4gICAgICAgIHByb2Nlc3M6IHByb2Nlc3MsXG4gICAgICAgIHJldmVydDogcmV2ZXJ0XG4gICAgICB9LFxuXG4gICAgICBvbigpLFxuICAgICAge1xuICAgICAgICBmcmVlemU6IGZ1bmN0aW9uIGZyZWV6ZSgpIHtcbiAgICAgICAgICByZXR1cm4gKHN0YXRlLmZyb3plbiA9IHRydWUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlbGVhc2U6IGZ1bmN0aW9uIHJlbGVhc2UoKSB7XG4gICAgICAgICAgcmV0dXJuIChzdGF0ZS5yZWxlYXNlZCA9IHRydWUpO1xuICAgICAgICB9LFxuICAgICAgICByZWxlYXNlZDoge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXRlLnJlbGVhc2VkO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBhcmNoaXZlOiBmdW5jdGlvbiBhcmNoaXZlKCkge1xuICAgICAgICAgIHJldHVybiAoc3RhdGUuYXJjaGl2ZWQgPSB0cnVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgYXJjaGl2ZWQ6IHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZS5hcmNoaXZlZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApO1xuXG4gICAgLy8gY3JlYXRlIGl0IGhlcmUgaW5zdGVhZCBvZiByZXR1cm5pbmcgaXQgaW5zdGFudGx5IHNvIHdlIGNhbiBleHRlbmQgaXQgbGF0ZXJcbiAgICB2YXIgaXRlbUFQSSA9IGNyZWF0ZU9iamVjdChhcGkpO1xuXG4gICAgcmV0dXJuIGl0ZW1BUEk7XG4gIH07XG5cbiAgdmFyIGdldEl0ZW1JbmRleEJ5UXVlcnkgPSBmdW5jdGlvbiBnZXRJdGVtSW5kZXhCeVF1ZXJ5KGl0ZW1zLCBxdWVyeSkge1xuICAgIC8vIGp1c3QgcmV0dXJuIGZpcnN0IGluZGV4XG4gICAgaWYgKGlzRW1wdHkocXVlcnkpKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICAvLyBpbnZhbGlkIHF1ZXJpZXNcbiAgICBpZiAoIWlzU3RyaW5nKHF1ZXJ5KSkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIC8vIHJldHVybiBpdGVtIGJ5IGlkIChvciAtMSBpZiBub3QgZm91bmQpXG4gICAgcmV0dXJuIGl0ZW1zLmZpbmRJbmRleChmdW5jdGlvbihpdGVtKSB7XG4gICAgICByZXR1cm4gaXRlbS5pZCA9PT0gcXVlcnk7XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIGdldEl0ZW1CeUlkID0gZnVuY3Rpb24gZ2V0SXRlbUJ5SWQoaXRlbXMsIGl0ZW1JZCkge1xuICAgIHZhciBpbmRleCA9IGdldEl0ZW1JbmRleEJ5UXVlcnkoaXRlbXMsIGl0ZW1JZCk7XG4gICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gaXRlbXNbaW5kZXhdIHx8IG51bGw7XG4gIH07XG5cbiAgdmFyIGZldGNoQmxvYiA9IGZ1bmN0aW9uIGZldGNoQmxvYihcbiAgICB1cmwsXG4gICAgbG9hZCxcbiAgICBlcnJvcixcbiAgICBwcm9ncmVzcyxcbiAgICBhYm9ydCxcbiAgICBoZWFkZXJzXG4gICkge1xuICAgIHZhciByZXF1ZXN0ID0gc2VuZFJlcXVlc3QobnVsbCwgdXJsLCB7XG4gICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgcmVzcG9uc2VUeXBlOiAnYmxvYidcbiAgICB9KTtcblxuICAgIHJlcXVlc3Qub25sb2FkID0gZnVuY3Rpb24oeGhyKSB7XG4gICAgICAvLyBnZXQgaGVhZGVyc1xuICAgICAgdmFyIGhlYWRlcnMgPSB4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCk7XG5cbiAgICAgIC8vIGdldCBmaWxlbmFtZVxuICAgICAgdmFyIGZpbGVuYW1lID1cbiAgICAgICAgZ2V0RmlsZUluZm9Gcm9tSGVhZGVycyhoZWFkZXJzKS5uYW1lIHx8IGdldEZpbGVuYW1lRnJvbVVSTCh1cmwpO1xuXG4gICAgICAvLyBjcmVhdGUgcmVzcG9uc2VcbiAgICAgIGxvYWQoXG4gICAgICAgIGNyZWF0ZVJlc3BvbnNlKFxuICAgICAgICAgICdsb2FkJyxcbiAgICAgICAgICB4aHIuc3RhdHVzLFxuICAgICAgICAgIGdldEZpbGVGcm9tQmxvYih4aHIucmVzcG9uc2UsIGZpbGVuYW1lKSxcbiAgICAgICAgICBoZWFkZXJzXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfTtcblxuICAgIHJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uKHhocikge1xuICAgICAgZXJyb3IoXG4gICAgICAgIGNyZWF0ZVJlc3BvbnNlKFxuICAgICAgICAgICdlcnJvcicsXG4gICAgICAgICAgeGhyLnN0YXR1cyxcbiAgICAgICAgICB4aHIuc3RhdHVzVGV4dCxcbiAgICAgICAgICB4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKClcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9O1xuXG4gICAgcmVxdWVzdC5vbmhlYWRlcnMgPSBmdW5jdGlvbih4aHIpIHtcbiAgICAgIGhlYWRlcnMoXG4gICAgICAgIGNyZWF0ZVJlc3BvbnNlKCdoZWFkZXJzJywgeGhyLnN0YXR1cywgbnVsbCwgeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpKVxuICAgICAgKTtcbiAgICB9O1xuXG4gICAgcmVxdWVzdC5vbnRpbWVvdXQgPSBjcmVhdGVUaW1lb3V0UmVzcG9uc2UoZXJyb3IpO1xuICAgIHJlcXVlc3Qub25wcm9ncmVzcyA9IHByb2dyZXNzO1xuICAgIHJlcXVlc3Qub25hYm9ydCA9IGFib3J0O1xuXG4gICAgLy8gc2hvdWxkIHJldHVybiByZXF1ZXN0XG4gICAgcmV0dXJuIHJlcXVlc3Q7XG4gIH07XG5cbiAgdmFyIGdldERvbWFpbkZyb21VUkwgPSBmdW5jdGlvbiBnZXREb21haW5Gcm9tVVJMKHVybCkge1xuICAgIGlmICh1cmwuaW5kZXhPZignLy8nKSA9PT0gMCkge1xuICAgICAgdXJsID0gbG9jYXRpb24ucHJvdG9jb2wgKyB1cmw7XG4gICAgfVxuICAgIHJldHVybiB1cmxcbiAgICAgIC50b0xvd2VyQ2FzZSgpXG4gICAgICAucmVwbGFjZSgnYmxvYjonLCAnJylcbiAgICAgIC5yZXBsYWNlKC8oW2Etel0pPzpcXC9cXC8vLCAnJDEnKVxuICAgICAgLnNwbGl0KCcvJylbMF07XG4gIH07XG5cbiAgdmFyIGlzRXh0ZXJuYWxVUkwgPSBmdW5jdGlvbiBpc0V4dGVybmFsVVJMKHVybCkge1xuICAgIHJldHVybiAoXG4gICAgICAodXJsLmluZGV4T2YoJzonKSA+IC0xIHx8IHVybC5pbmRleE9mKCcvLycpID4gLTEpICYmXG4gICAgICBnZXREb21haW5Gcm9tVVJMKGxvY2F0aW9uLmhyZWYpICE9PSBnZXREb21haW5Gcm9tVVJMKHVybClcbiAgICApO1xuICB9O1xuXG4gIHZhciBkeW5hbWljTGFiZWwgPSBmdW5jdGlvbiBkeW5hbWljTGFiZWwobGFiZWwpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gaXNGdW5jdGlvbihsYWJlbCkgPyBsYWJlbC5hcHBseSh2b2lkIDAsIGFyZ3VtZW50cykgOiBsYWJlbDtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBpc01vY2tJdGVtID0gZnVuY3Rpb24gaXNNb2NrSXRlbShpdGVtKSB7XG4gICAgcmV0dXJuICFpc0ZpbGUoaXRlbS5maWxlKTtcbiAgfTtcblxuICB2YXIgbGlzdFVwZGF0ZWQgPSBmdW5jdGlvbiBsaXN0VXBkYXRlZChkaXNwYXRjaCwgc3RhdGUpIHtcbiAgICBjbGVhclRpbWVvdXQoc3RhdGUubGlzdFVwZGF0ZVRpbWVvdXQpO1xuICAgIHN0YXRlLmxpc3RVcGRhdGVUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIGRpc3BhdGNoKCdESURfVVBEQVRFX0lURU1TJywgeyBpdGVtczogZ2V0QWN0aXZlSXRlbXMoc3RhdGUuaXRlbXMpIH0pO1xuICAgIH0sIDApO1xuICB9O1xuXG4gIHZhciBvcHRpb25hbFByb21pc2UgPSBmdW5jdGlvbiBvcHRpb25hbFByb21pc2UoZm4pIHtcbiAgICBmb3IgKFxuICAgICAgdmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICBwYXJhbXMgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLFxuICAgICAgICBfa2V5ID0gMTtcbiAgICAgIF9rZXkgPCBfbGVuO1xuICAgICAgX2tleSsrXG4gICAgKSB7XG4gICAgICBwYXJhbXNbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSkge1xuICAgICAgaWYgKCFmbikge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZSh0cnVlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlc3VsdCA9IGZuLmFwcGx5KHZvaWQgMCwgcGFyYW1zKTtcblxuICAgICAgaWYgKHJlc3VsdCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlKHRydWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlKHJlc3VsdCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgcmVzdWx0LnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmVzdWx0LnRoZW4ocmVzb2x2ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIHNvcnRJdGVtcyA9IGZ1bmN0aW9uIHNvcnRJdGVtcyhzdGF0ZSwgY29tcGFyZSkge1xuICAgIHN0YXRlLml0ZW1zLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgcmV0dXJuIGNvbXBhcmUoY3JlYXRlSXRlbUFQSShhKSwgY3JlYXRlSXRlbUFQSShiKSk7XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gcmV0dXJucyBpdGVtIGJhc2VkIG9uIHN0YXRlXG4gIHZhciBnZXRJdGVtQnlRdWVyeUZyb21TdGF0ZSA9IGZ1bmN0aW9uIGdldEl0ZW1CeVF1ZXJ5RnJvbVN0YXRlKFxuICAgIHN0YXRlLFxuICAgIGl0ZW1IYW5kbGVyXG4gICkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBfcmVmID1cbiAgICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICAgIHZhciBxdWVyeSA9IF9yZWYucXVlcnksXG4gICAgICAgIF9yZWYkc3VjY2VzcyA9IF9yZWYuc3VjY2VzcyxcbiAgICAgICAgc3VjY2VzcyA9IF9yZWYkc3VjY2VzcyA9PT0gdm9pZCAwID8gZnVuY3Rpb24oKSB7fSA6IF9yZWYkc3VjY2VzcyxcbiAgICAgICAgX3JlZiRmYWlsdXJlID0gX3JlZi5mYWlsdXJlLFxuICAgICAgICBmYWlsdXJlID0gX3JlZiRmYWlsdXJlID09PSB2b2lkIDAgPyBmdW5jdGlvbigpIHt9IDogX3JlZiRmYWlsdXJlLFxuICAgICAgICBvcHRpb25zID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFtcbiAgICAgICAgICAncXVlcnknLFxuICAgICAgICAgICdzdWNjZXNzJyxcbiAgICAgICAgICAnZmFpbHVyZSdcbiAgICAgICAgXSk7XG4gICAgICB2YXIgaXRlbSA9IGdldEl0ZW1CeVF1ZXJ5KHN0YXRlLml0ZW1zLCBxdWVyeSk7XG4gICAgICBpZiAoIWl0ZW0pIHtcbiAgICAgICAgZmFpbHVyZSh7XG4gICAgICAgICAgZXJyb3I6IGNyZWF0ZVJlc3BvbnNlKCdlcnJvcicsIDAsICdJdGVtIG5vdCBmb3VuZCcpLFxuXG4gICAgICAgICAgZmlsZTogbnVsbFxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpdGVtSGFuZGxlcihpdGVtLCBzdWNjZXNzLCBmYWlsdXJlLCBvcHRpb25zIHx8IHt9KTtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBhY3Rpb25zID0gZnVuY3Rpb24gYWN0aW9ucyhkaXNwYXRjaCwgcXVlcnksIHN0YXRlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC8qKlxuICAgICAgICogQWJvcnRzIGFsbCBvbmdvaW5nIHByb2Nlc3Nlc1xuICAgICAgICovXG4gICAgICBBQk9SVF9BTEw6IGZ1bmN0aW9uIEFCT1JUX0FMTCgpIHtcbiAgICAgICAgZ2V0QWN0aXZlSXRlbXMoc3RhdGUuaXRlbXMpLmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgIGl0ZW0uZnJlZXplKCk7XG4gICAgICAgICAgaXRlbS5hYm9ydExvYWQoKTtcbiAgICAgICAgICBpdGVtLmFib3J0UHJvY2Vzc2luZygpO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogU2V0cyBpbml0aWFsIGZpbGVzXG4gICAgICAgKi9cbiAgICAgIERJRF9TRVRfRklMRVM6IGZ1bmN0aW9uIERJRF9TRVRfRklMRVMoX3JlZjIpIHtcbiAgICAgICAgdmFyIF9yZWYyJHZhbHVlID0gX3JlZjIudmFsdWUsXG4gICAgICAgICAgdmFsdWUgPSBfcmVmMiR2YWx1ZSA9PT0gdm9pZCAwID8gW10gOiBfcmVmMiR2YWx1ZTtcblxuICAgICAgICAvLyBtYXAgdmFsdWVzIHRvIGZpbGUgb2JqZWN0c1xuICAgICAgICB2YXIgZmlsZXMgPSB2YWx1ZS5tYXAoZnVuY3Rpb24oZmlsZSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzb3VyY2U6IGZpbGUuc291cmNlID8gZmlsZS5zb3VyY2UgOiBmaWxlLFxuICAgICAgICAgICAgb3B0aW9uczogZmlsZS5vcHRpb25zXG4gICAgICAgICAgfTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gbG9vcCBvdmVyIGZpbGVzLCBpZiBmaWxlIGlzIGluIGxpc3QsIGxlYXZlIGl0IGJlLCBpZiBub3QsIHJlbW92ZVxuICAgICAgICAvLyB0ZXN0IGlmIGl0ZW1zIHNob3VsZCBiZSBtb3ZlZFxuICAgICAgICB2YXIgYWN0aXZlSXRlbXMgPSBnZXRBY3RpdmVJdGVtcyhzdGF0ZS5pdGVtcyk7XG5cbiAgICAgICAgYWN0aXZlSXRlbXMuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgLy8gaWYgaXRlbSBub3QgaXMgaW4gbmV3IHZhbHVlLCByZW1vdmVcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAhZmlsZXMuZmluZChmdW5jdGlvbihmaWxlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmaWxlLnNvdXJjZSA9PT0gaXRlbS5zb3VyY2UgfHwgZmlsZS5zb3VyY2UgPT09IGl0ZW0uZmlsZTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBkaXNwYXRjaCgnUkVNT1ZFX0lURU0nLCB7IHF1ZXJ5OiBpdGVtLCByZW1vdmU6IGZhbHNlIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gYWRkIG5ldyBmaWxlc1xuICAgICAgICBhY3RpdmVJdGVtcyA9IGdldEFjdGl2ZUl0ZW1zKHN0YXRlLml0ZW1zKTtcbiAgICAgICAgZmlsZXMuZm9yRWFjaChmdW5jdGlvbihmaWxlLCBpbmRleCkge1xuICAgICAgICAgIC8vIGlmIGZpbGUgaXMgYWxyZWFkeSBpbiBsaXN0XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgYWN0aXZlSXRlbXMuZmluZChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgIHJldHVybiBpdGVtLnNvdXJjZSA9PT0gZmlsZS5zb3VyY2UgfHwgaXRlbS5maWxlID09PSBmaWxlLnNvdXJjZTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKVxuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgLy8gbm90IGluIGxpc3QsIGFkZFxuICAgICAgICAgIGRpc3BhdGNoKFxuICAgICAgICAgICAgJ0FERF9JVEVNJyxcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oe30sIGZpbGUsIHtcbiAgICAgICAgICAgICAgaW50ZXJhY3Rpb25NZXRob2Q6IEludGVyYWN0aW9uTWV0aG9kLk5PTkUsXG4gICAgICAgICAgICAgIGluZGV4OiBpbmRleFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG5cbiAgICAgIERJRF9VUERBVEVfSVRFTV9NRVRBREFUQTogZnVuY3Rpb24gRElEX1VQREFURV9JVEVNX01FVEFEQVRBKF9yZWYzKSB7XG4gICAgICAgIHZhciBpZCA9IF9yZWYzLmlkLFxuICAgICAgICAgIGFjdGlvbiA9IF9yZWYzLmFjdGlvbjtcblxuICAgICAgICAvLyBpZiBpcyBjYWxsZWQgbXVsdGlwbGUgdGltZXMgaW4gY2xvc2Ugc3VjY2Vzc2lvbiB3ZSBjb21iaW5lZCBhbGwgY2FsbHMgdG9nZXRoZXIgdG8gc2F2ZSByZXNvdXJjZXNcbiAgICAgICAgY2xlYXJUaW1lb3V0KHN0YXRlLml0ZW1VcGRhdGVUaW1lb3V0KTtcbiAgICAgICAgc3RhdGUuaXRlbVVwZGF0ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBpdGVtID0gZ2V0SXRlbUJ5SWQoc3RhdGUuaXRlbXMsIGlkKTtcblxuICAgICAgICAgIC8vIG9ubHkgcmV2ZXJ0IGFuZCBhdHRlbXB0IHRvIHVwbG9hZCB3aGVuIHdlJ3JlIHVwbG9hZGluZyB0byBhIHNlcnZlclxuICAgICAgICAgIGlmICghcXVlcnkoJ0lTX0FTWU5DJykpIHtcbiAgICAgICAgICAgIC8vIHNob3VsZCB3ZSB1cGRhdGUgdGhlIG91dHB1dCBkYXRhXG4gICAgICAgICAgICBhcHBseUZpbHRlckNoYWluKCdTSE9VTERfUFJFUEFSRV9PVVRQVVQnLCBmYWxzZSwge1xuICAgICAgICAgICAgICBpdGVtOiBpdGVtLFxuICAgICAgICAgICAgICBxdWVyeTogcXVlcnksXG4gICAgICAgICAgICAgIGFjdGlvbjogYWN0aW9uXG4gICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKHNob3VsZFByZXBhcmVPdXRwdXQpIHtcbiAgICAgICAgICAgICAgLy8gcGx1Z2lucyBkZXRlcm1pbmVkIHRoZSBvdXRwdXQgZGF0YSBzaG91bGQgYmUgcHJlcGFyZWQgKG9yIG5vdCksIGNhbiBiZSBhZGp1c3RlZCB3aXRoIGJlZm9yZVByZXBhcmVPdXRwdXQgaG9va1xuICAgICAgICAgICAgICB2YXIgYmVmb3JlUHJlcGFyZUZpbGUgPSBxdWVyeSgnR0VUX0JFRk9SRV9QUkVQQVJFX0ZJTEUnKTtcbiAgICAgICAgICAgICAgaWYgKGJlZm9yZVByZXBhcmVGaWxlKVxuICAgICAgICAgICAgICAgIHNob3VsZFByZXBhcmVPdXRwdXQgPSBiZWZvcmVQcmVwYXJlRmlsZShcbiAgICAgICAgICAgICAgICAgIGl0ZW0sXG4gICAgICAgICAgICAgICAgICBzaG91bGRQcmVwYXJlT3V0cHV0XG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICBpZiAoIXNob3VsZFByZXBhcmVPdXRwdXQpIHJldHVybjtcblxuICAgICAgICAgICAgICBkaXNwYXRjaChcbiAgICAgICAgICAgICAgICAnUkVRVUVTVF9QUkVQQVJFX09VVFBVVCcsXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgcXVlcnk6IGlkLFxuICAgICAgICAgICAgICAgICAgaXRlbTogaXRlbSxcbiAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIHN1Y2Nlc3MoZmlsZSkge1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaCgnRElEX1BSRVBBUkVfT1VUUFVUJywgeyBpZDogaWQsIGZpbGU6IGZpbGUgfSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGZvciBhc3luYyBzY2VuYXJpb3NcbiAgICAgICAgICB2YXIgdXBsb2FkID0gZnVuY3Rpb24gdXBsb2FkKCkge1xuICAgICAgICAgICAgLy8gd2UgcHVzaCB0aGlzIGZvcndhcmQgYSBiaXQgc28gdGhlIGludGVyZmFjZSBpcyB1cGRhdGVkIGNvcnJlY3RseVxuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgZGlzcGF0Y2goJ1JFUVVFU1RfSVRFTV9QUk9DRVNTSU5HJywgeyBxdWVyeTogaWQgfSk7XG4gICAgICAgICAgICB9LCAzMik7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHZhciByZXZlcnQgPSBmdW5jdGlvbiByZXZlcnQoZG9VcGxvYWQpIHtcbiAgICAgICAgICAgIGl0ZW1cbiAgICAgICAgICAgICAgLnJldmVydChcbiAgICAgICAgICAgICAgICBjcmVhdGVSZXZlcnRGdW5jdGlvbihcbiAgICAgICAgICAgICAgICAgIHN0YXRlLm9wdGlvbnMuc2VydmVyLnVybCxcbiAgICAgICAgICAgICAgICAgIHN0YXRlLm9wdGlvbnMuc2VydmVyLnJldmVydFxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgcXVlcnkoJ0dFVF9GT1JDRV9SRVZFUlQnKVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIC50aGVuKGRvVXBsb2FkID8gdXBsb2FkIDogZnVuY3Rpb24oKSB7fSlcbiAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uKCkge30pO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICB2YXIgYWJvcnQgPSBmdW5jdGlvbiBhYm9ydChkb1VwbG9hZCkge1xuICAgICAgICAgICAgaXRlbS5hYm9ydFByb2Nlc3NpbmcoKS50aGVuKGRvVXBsb2FkID8gdXBsb2FkIDogZnVuY3Rpb24oKSB7fSk7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIC8vIGlmIHdlIHNob3VsZCByZS11cGxvYWQgdGhlIGZpbGUgaW1tZWRpYXRlbHlcbiAgICAgICAgICBpZiAoaXRlbS5zdGF0dXMgPT09IEl0ZW1TdGF0dXMuUFJPQ0VTU0lOR19DT01QTEVURSkge1xuICAgICAgICAgICAgcmV0dXJuIHJldmVydChzdGF0ZS5vcHRpb25zLmluc3RhbnRVcGxvYWQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGlmIGN1cnJlbnRseSB1cGxvYWRpbmcsIGNhbmNlbCB1cGxvYWRcbiAgICAgICAgICBpZiAoaXRlbS5zdGF0dXMgPT09IEl0ZW1TdGF0dXMuUFJPQ0VTU0lORykge1xuICAgICAgICAgICAgcmV0dXJuIGFib3J0KHN0YXRlLm9wdGlvbnMuaW5zdGFudFVwbG9hZCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHN0YXRlLm9wdGlvbnMuaW5zdGFudFVwbG9hZCkge1xuICAgICAgICAgICAgdXBsb2FkKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCAwKTtcbiAgICAgIH0sXG5cbiAgICAgIE1PVkVfSVRFTTogZnVuY3Rpb24gTU9WRV9JVEVNKF9yZWY0KSB7XG4gICAgICAgIHZhciBxdWVyeSA9IF9yZWY0LnF1ZXJ5LFxuICAgICAgICAgIGluZGV4ID0gX3JlZjQuaW5kZXg7XG4gICAgICAgIHZhciBpdGVtID0gZ2V0SXRlbUJ5UXVlcnkoc3RhdGUuaXRlbXMsIHF1ZXJ5KTtcbiAgICAgICAgaWYgKCFpdGVtKSByZXR1cm47XG4gICAgICAgIHZhciBjdXJyZW50SW5kZXggPSBzdGF0ZS5pdGVtcy5pbmRleE9mKGl0ZW0pO1xuICAgICAgICBpbmRleCA9IGxpbWl0KGluZGV4LCAwLCBzdGF0ZS5pdGVtcy5sZW5ndGggLSAxKTtcbiAgICAgICAgaWYgKGN1cnJlbnRJbmRleCA9PT0gaW5kZXgpIHJldHVybjtcbiAgICAgICAgc3RhdGUuaXRlbXMuc3BsaWNlKGluZGV4LCAwLCBzdGF0ZS5pdGVtcy5zcGxpY2UoY3VycmVudEluZGV4LCAxKVswXSk7XG4gICAgICB9LFxuXG4gICAgICBTT1JUOiBmdW5jdGlvbiBTT1JUKF9yZWY1KSB7XG4gICAgICAgIHZhciBjb21wYXJlID0gX3JlZjUuY29tcGFyZTtcbiAgICAgICAgc29ydEl0ZW1zKHN0YXRlLCBjb21wYXJlKTtcbiAgICAgICAgZGlzcGF0Y2goJ0RJRF9TT1JUX0lURU1TJywge1xuICAgICAgICAgIGl0ZW1zOiBxdWVyeSgnR0VUX0FDVElWRV9JVEVNUycpXG4gICAgICAgIH0pO1xuICAgICAgfSxcblxuICAgICAgQUREX0lURU1TOiBmdW5jdGlvbiBBRERfSVRFTVMoX3JlZjYpIHtcbiAgICAgICAgdmFyIGl0ZW1zID0gX3JlZjYuaXRlbXMsXG4gICAgICAgICAgaW5kZXggPSBfcmVmNi5pbmRleCxcbiAgICAgICAgICBpbnRlcmFjdGlvbk1ldGhvZCA9IF9yZWY2LmludGVyYWN0aW9uTWV0aG9kLFxuICAgICAgICAgIF9yZWY2JHN1Y2Nlc3MgPSBfcmVmNi5zdWNjZXNzLFxuICAgICAgICAgIHN1Y2Nlc3MgPSBfcmVmNiRzdWNjZXNzID09PSB2b2lkIDAgPyBmdW5jdGlvbigpIHt9IDogX3JlZjYkc3VjY2VzcyxcbiAgICAgICAgICBfcmVmNiRmYWlsdXJlID0gX3JlZjYuZmFpbHVyZSxcbiAgICAgICAgICBmYWlsdXJlID0gX3JlZjYkZmFpbHVyZSA9PT0gdm9pZCAwID8gZnVuY3Rpb24oKSB7fSA6IF9yZWY2JGZhaWx1cmU7XG5cbiAgICAgICAgdmFyIGN1cnJlbnRJbmRleCA9IGluZGV4O1xuXG4gICAgICAgIGlmIChpbmRleCA9PT0gLTEgfHwgdHlwZW9mIGluZGV4ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHZhciBpbnNlcnRMb2NhdGlvbiA9IHF1ZXJ5KCdHRVRfSVRFTV9JTlNFUlRfTE9DQVRJT04nKTtcbiAgICAgICAgICB2YXIgdG90YWxJdGVtcyA9IHF1ZXJ5KCdHRVRfVE9UQUxfSVRFTVMnKTtcbiAgICAgICAgICBjdXJyZW50SW5kZXggPSBpbnNlcnRMb2NhdGlvbiA9PT0gJ2JlZm9yZScgPyAwIDogdG90YWxJdGVtcztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpZ25vcmVkRmlsZXMgPSBxdWVyeSgnR0VUX0lHTk9SRURfRklMRVMnKTtcbiAgICAgICAgdmFyIGlzVmFsaWRGaWxlID0gZnVuY3Rpb24gaXNWYWxpZEZpbGUoc291cmNlKSB7XG4gICAgICAgICAgcmV0dXJuIGlzRmlsZShzb3VyY2UpXG4gICAgICAgICAgICA/ICFpZ25vcmVkRmlsZXMuaW5jbHVkZXMoc291cmNlLm5hbWUudG9Mb3dlckNhc2UoKSlcbiAgICAgICAgICAgIDogIWlzRW1wdHkoc291cmNlKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHZhbGlkSXRlbXMgPSBpdGVtcy5maWx0ZXIoaXNWYWxpZEZpbGUpO1xuXG4gICAgICAgIHZhciBwcm9taXNlcyA9IHZhbGlkSXRlbXMubWFwKGZ1bmN0aW9uKHNvdXJjZSkge1xuICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIGRpc3BhdGNoKCdBRERfSVRFTScsIHtcbiAgICAgICAgICAgICAgaW50ZXJhY3Rpb25NZXRob2Q6IGludGVyYWN0aW9uTWV0aG9kLFxuICAgICAgICAgICAgICBzb3VyY2U6IHNvdXJjZS5zb3VyY2UgfHwgc291cmNlLFxuICAgICAgICAgICAgICBzdWNjZXNzOiByZXNvbHZlLFxuICAgICAgICAgICAgICBmYWlsdXJlOiByZWplY3QsXG4gICAgICAgICAgICAgIGluZGV4OiBjdXJyZW50SW5kZXgrKyxcbiAgICAgICAgICAgICAgb3B0aW9uczogc291cmNlLm9wdGlvbnMgfHwge31cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBQcm9taXNlLmFsbChwcm9taXNlcylcbiAgICAgICAgICAudGhlbihzdWNjZXNzKVxuICAgICAgICAgIC5jYXRjaChmYWlsdXJlKTtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHNvdXJjZVxuICAgICAgICogQHBhcmFtIGluZGV4XG4gICAgICAgKiBAcGFyYW0gaW50ZXJhY3Rpb25NZXRob2RcbiAgICAgICAqL1xuICAgICAgQUREX0lURU06IGZ1bmN0aW9uIEFERF9JVEVNKF9yZWY3KSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBfcmVmNy5zb3VyY2UsXG4gICAgICAgICAgX3JlZjckaW5kZXggPSBfcmVmNy5pbmRleCxcbiAgICAgICAgICBpbmRleCA9IF9yZWY3JGluZGV4ID09PSB2b2lkIDAgPyAtMSA6IF9yZWY3JGluZGV4LFxuICAgICAgICAgIGludGVyYWN0aW9uTWV0aG9kID0gX3JlZjcuaW50ZXJhY3Rpb25NZXRob2QsXG4gICAgICAgICAgX3JlZjckc3VjY2VzcyA9IF9yZWY3LnN1Y2Nlc3MsXG4gICAgICAgICAgc3VjY2VzcyA9IF9yZWY3JHN1Y2Nlc3MgPT09IHZvaWQgMCA/IGZ1bmN0aW9uKCkge30gOiBfcmVmNyRzdWNjZXNzLFxuICAgICAgICAgIF9yZWY3JGZhaWx1cmUgPSBfcmVmNy5mYWlsdXJlLFxuICAgICAgICAgIGZhaWx1cmUgPSBfcmVmNyRmYWlsdXJlID09PSB2b2lkIDAgPyBmdW5jdGlvbigpIHt9IDogX3JlZjckZmFpbHVyZSxcbiAgICAgICAgICBfcmVmNyRvcHRpb25zID0gX3JlZjcub3B0aW9ucyxcbiAgICAgICAgICBvcHRpb25zID0gX3JlZjckb3B0aW9ucyA9PT0gdm9pZCAwID8ge30gOiBfcmVmNyRvcHRpb25zO1xuXG4gICAgICAgIC8vIGlmIG5vIHNvdXJjZSBzdXBwbGllZFxuICAgICAgICBpZiAoaXNFbXB0eShzb3VyY2UpKSB7XG4gICAgICAgICAgZmFpbHVyZSh7XG4gICAgICAgICAgICBlcnJvcjogY3JlYXRlUmVzcG9uc2UoJ2Vycm9yJywgMCwgJ05vIHNvdXJjZScpLFxuXG4gICAgICAgICAgICBmaWxlOiBudWxsXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmaWx0ZXIgb3V0IGludmFsaWQgZmlsZSBpdGVtcywgdXNlZCB0byBmaWx0ZXIgZHJvcHBlZCBkaXJlY3RvcnkgY29udGVudHNcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGlzRmlsZShzb3VyY2UpICYmXG4gICAgICAgICAgc3RhdGUub3B0aW9ucy5pZ25vcmVkRmlsZXMuaW5jbHVkZXMoc291cmNlLm5hbWUudG9Mb3dlckNhc2UoKSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgLy8gZmFpbCBzaWxlbnRseVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRlc3QgaWYgdGhlcmUncyBzdGlsbCByb29tIGluIHRoZSBsaXN0IG9mIGZpbGVzXG4gICAgICAgIGlmICghaGFzUm9vbUZvckl0ZW0oc3RhdGUpKSB7XG4gICAgICAgICAgLy8gaWYgbXVsdGlwbGUgYWxsb3dlZCwgd2UgY2FuJ3QgcmVwbGFjZVxuICAgICAgICAgIC8vIG9yIGlmIG9ubHkgYSBzaW5nbGUgaXRlbSBpcyBhbGxvd2VkIGJ1dCB3ZSdyZSBub3QgYWxsb3dlZCB0byByZXBsYWNlIGl0IHdlIGV4aXRcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBzdGF0ZS5vcHRpb25zLmFsbG93TXVsdGlwbGUgfHxcbiAgICAgICAgICAgICghc3RhdGUub3B0aW9ucy5hbGxvd011bHRpcGxlICYmICFzdGF0ZS5vcHRpb25zLmFsbG93UmVwbGFjZSlcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHZhciBlcnJvciA9IGNyZWF0ZVJlc3BvbnNlKCd3YXJuaW5nJywgMCwgJ01heCBmaWxlcycpO1xuXG4gICAgICAgICAgICBkaXNwYXRjaCgnRElEX1RIUk9XX01BWF9GSUxFUycsIHtcbiAgICAgICAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgICAgICAgIGVycm9yOiBlcnJvclxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGZhaWx1cmUoeyBlcnJvcjogZXJyb3IsIGZpbGU6IG51bGwgfSk7XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBsZXQncyByZXBsYWNlIHRoZSBpdGVtXG4gICAgICAgICAgLy8gaWQgb2YgZmlyc3QgaXRlbSB3ZSdyZSBhYm91dCB0byByZW1vdmVcbiAgICAgICAgICB2YXIgX2l0ZW0gPSBnZXRBY3RpdmVJdGVtcyhzdGF0ZS5pdGVtcylbMF07XG5cbiAgICAgICAgICAvLyBpZiBoYXMgYmVlbiBwcm9jZXNzZWQgcmVtb3ZlIGl0IGZyb20gdGhlIHNlcnZlciBhcyB3ZWxsXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgX2l0ZW0uc3RhdHVzID09PSBJdGVtU3RhdHVzLlBST0NFU1NJTkdfQ09NUExFVEUgfHxcbiAgICAgICAgICAgIF9pdGVtLnN0YXR1cyA9PT0gSXRlbVN0YXR1cy5QUk9DRVNTSU5HX1JFVkVSVF9FUlJPUlxuICAgICAgICAgICkge1xuICAgICAgICAgICAgdmFyIGZvcmNlUmV2ZXJ0ID0gcXVlcnkoJ0dFVF9GT1JDRV9SRVZFUlQnKTtcbiAgICAgICAgICAgIF9pdGVtXG4gICAgICAgICAgICAgIC5yZXZlcnQoXG4gICAgICAgICAgICAgICAgY3JlYXRlUmV2ZXJ0RnVuY3Rpb24oXG4gICAgICAgICAgICAgICAgICBzdGF0ZS5vcHRpb25zLnNlcnZlci51cmwsXG4gICAgICAgICAgICAgICAgICBzdGF0ZS5vcHRpb25zLnNlcnZlci5yZXZlcnRcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGZvcmNlUmV2ZXJ0XG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFmb3JjZVJldmVydCkgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgLy8gdHJ5IHRvIGFkZCBub3dcbiAgICAgICAgICAgICAgICBkaXNwYXRjaCgnQUREX0lURU0nLCB7XG4gICAgICAgICAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgICAgICAgICAgIGludGVyYWN0aW9uTWV0aG9kOiBpbnRlcmFjdGlvbk1ldGhvZCxcbiAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHN1Y2Nlc3MsXG4gICAgICAgICAgICAgICAgICBmYWlsdXJlOiBmYWlsdXJlLFxuICAgICAgICAgICAgICAgICAgb3B0aW9uczogb3B0aW9uc1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24oKSB7fSk7IC8vIG5vIG5lZWQgdG8gaGFuZGxlIHRoaXMgY2F0Y2ggc3RhdGUgZm9yIG5vd1xuXG4gICAgICAgICAgICBpZiAoZm9yY2VSZXZlcnQpIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyByZW1vdmUgZmlyc3QgaXRlbSBhcyBpdCB3aWxsIGJlIHJlcGxhY2VkIGJ5IHRoaXMgaXRlbVxuICAgICAgICAgIGRpc3BhdGNoKCdSRU1PVkVfSVRFTScsIHsgcXVlcnk6IF9pdGVtLmlkIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gd2hlcmUgZGlkIHRoZSBmaWxlIG9yaWdpbmF0ZVxuICAgICAgICB2YXIgb3JpZ2luID1cbiAgICAgICAgICBvcHRpb25zLnR5cGUgPT09ICdsb2NhbCdcbiAgICAgICAgICAgID8gRmlsZU9yaWdpbi5MT0NBTFxuICAgICAgICAgICAgOiBvcHRpb25zLnR5cGUgPT09ICdsaW1ibydcbiAgICAgICAgICAgID8gRmlsZU9yaWdpbi5MSU1CT1xuICAgICAgICAgICAgOiBGaWxlT3JpZ2luLklOUFVUO1xuXG4gICAgICAgIC8vIGNyZWF0ZSBhIG5ldyBibGFuayBpdGVtXG4gICAgICAgIHZhciBpdGVtID0gY3JlYXRlSXRlbShcbiAgICAgICAgICAvLyB3aGVyZSBkaWQgdGhpcyBmaWxlIGNvbWUgZnJvbVxuICAgICAgICAgIG9yaWdpbixcblxuICAgICAgICAgIC8vIGFuIGlucHV0IGZpbGUgbmV2ZXIgaGFzIGEgc2VydmVyIGZpbGUgcmVmZXJlbmNlXG4gICAgICAgICAgb3JpZ2luID09PSBGaWxlT3JpZ2luLklOUFVUID8gbnVsbCA6IHNvdXJjZSxcblxuICAgICAgICAgIC8vIGZpbGUgbW9jayBkYXRhLCBpZiBkZWZpbmVkXG4gICAgICAgICAgb3B0aW9ucy5maWxlXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gc2V0IGluaXRpYWwgbWV0YSBkYXRhXG4gICAgICAgIE9iamVjdC5rZXlzKG9wdGlvbnMubWV0YWRhdGEgfHwge30pLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgaXRlbS5zZXRNZXRhZGF0YShrZXksIG9wdGlvbnMubWV0YWRhdGFba2V5XSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGNyZWF0ZWQgdGhlIGl0ZW0sIGxldCBwbHVnaW5zIGFkZCBtZXRob2RzXG4gICAgICAgIGFwcGx5RmlsdGVycygnRElEX0NSRUFURV9JVEVNJywgaXRlbSwge1xuICAgICAgICAgIHF1ZXJ5OiBxdWVyeSxcbiAgICAgICAgICBkaXNwYXRjaDogZGlzcGF0Y2hcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gd2hlcmUgdG8gaW5zZXJ0IG5ldyBpdGVtc1xuICAgICAgICB2YXIgaXRlbUluc2VydExvY2F0aW9uID0gcXVlcnkoJ0dFVF9JVEVNX0lOU0VSVF9MT0NBVElPTicpO1xuXG4gICAgICAgIC8vIGFkanVzdCBpbmRleCBpZiBpcyBub3QgYWxsb3dlZCB0byBwaWNrIGxvY2F0aW9uXG4gICAgICAgIGlmICghc3RhdGUub3B0aW9ucy5pdGVtSW5zZXJ0TG9jYXRpb25GcmVlZG9tKSB7XG4gICAgICAgICAgaW5kZXggPSBpdGVtSW5zZXJ0TG9jYXRpb24gPT09ICdiZWZvcmUnID8gLTEgOiBzdGF0ZS5pdGVtcy5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgaXRlbSB0byBsaXN0XG4gICAgICAgIGluc2VydEl0ZW0oc3RhdGUuaXRlbXMsIGl0ZW0sIGluZGV4KTtcblxuICAgICAgICAvLyBzb3J0IGl0ZW1zIGluIGxpc3RcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24oaXRlbUluc2VydExvY2F0aW9uKSAmJiBzb3VyY2UpIHtcbiAgICAgICAgICBzb3J0SXRlbXMoc3RhdGUsIGl0ZW1JbnNlcnRMb2NhdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBnZXQgYSBxdWljayByZWZlcmVuY2UgdG8gdGhlIGl0ZW0gaWRcbiAgICAgICAgdmFyIGlkID0gaXRlbS5pZDtcblxuICAgICAgICAvLyBvYnNlcnZlIGl0ZW0gZXZlbnRzXG4gICAgICAgIGl0ZW0ub24oJ2luaXQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICBkaXNwYXRjaCgnRElEX0lOSVRfSVRFTScsIHsgaWQ6IGlkIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdGVtLm9uKCdsb2FkLWluaXQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICBkaXNwYXRjaCgnRElEX1NUQVJUX0lURU1fTE9BRCcsIHsgaWQ6IGlkIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdGVtLm9uKCdsb2FkLW1ldGEnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICBkaXNwYXRjaCgnRElEX1VQREFURV9JVEVNX01FVEEnLCB7IGlkOiBpZCB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXRlbS5vbignbG9hZC1wcm9ncmVzcycsIGZ1bmN0aW9uKHByb2dyZXNzKSB7XG4gICAgICAgICAgZGlzcGF0Y2goJ0RJRF9VUERBVEVfSVRFTV9MT0FEX1BST0dSRVNTJywge1xuICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgcHJvZ3Jlc3M6IHByb2dyZXNzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0ZW0ub24oJ2xvYWQtcmVxdWVzdC1lcnJvcicsIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgdmFyIG1haW5TdGF0dXMgPSBkeW5hbWljTGFiZWwoc3RhdGUub3B0aW9ucy5sYWJlbEZpbGVMb2FkRXJyb3IpKFxuICAgICAgICAgICAgZXJyb3JcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgLy8gaXMgY2xpZW50IGVycm9yLCBubyB3YXkgdG8gcmVjb3ZlclxuICAgICAgICAgIGlmIChlcnJvci5jb2RlID49IDQwMCAmJiBlcnJvci5jb2RlIDwgNTAwKSB7XG4gICAgICAgICAgICBkaXNwYXRjaCgnRElEX1RIUk9XX0lURU1fSU5WQUxJRCcsIHtcbiAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgICAgICAgIHN0YXR1czoge1xuICAgICAgICAgICAgICAgIG1haW46IG1haW5TdGF0dXMsXG4gICAgICAgICAgICAgICAgc3ViOiBlcnJvci5jb2RlICsgJyAoJyArIGVycm9yLmJvZHkgKyAnKSdcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIHJlamVjdCB0aGUgZmlsZSBzbyBjYW4gYmUgZGVhbHQgd2l0aCB0aHJvdWdoIEFQSVxuICAgICAgICAgICAgZmFpbHVyZSh7IGVycm9yOiBlcnJvciwgZmlsZTogY3JlYXRlSXRlbUFQSShpdGVtKSB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBpcyBwb3NzaWJsZSBzZXJ2ZXIgZXJyb3IsIHNvIG1pZ2h0IGJlIHBvc3NpYmxlIHRvIHJldHJ5XG4gICAgICAgICAgZGlzcGF0Y2goJ0RJRF9USFJPV19JVEVNX0xPQURfRVJST1InLCB7XG4gICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgICAgICBzdGF0dXM6IHtcbiAgICAgICAgICAgICAgbWFpbjogbWFpblN0YXR1cyxcbiAgICAgICAgICAgICAgc3ViOiBzdGF0ZS5vcHRpb25zLmxhYmVsVGFwVG9SZXRyeVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdGVtLm9uKCdsb2FkLWZpbGUtZXJyb3InLCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgIGRpc3BhdGNoKCdESURfVEhST1dfSVRFTV9JTlZBTElEJywge1xuICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgZXJyb3I6IGVycm9yLnN0YXR1cyxcbiAgICAgICAgICAgIHN0YXR1czogZXJyb3Iuc3RhdHVzXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBmYWlsdXJlKHsgZXJyb3I6IGVycm9yLnN0YXR1cywgZmlsZTogY3JlYXRlSXRlbUFQSShpdGVtKSB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXRlbS5vbignbG9hZC1hYm9ydCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGRpc3BhdGNoKCdSRU1PVkVfSVRFTScsIHsgcXVlcnk6IGlkIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdGVtLm9uKCdsb2FkLXNraXAnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICBkaXNwYXRjaCgnQ09NUExFVEVfTE9BRF9JVEVNJywge1xuICAgICAgICAgICAgcXVlcnk6IGlkLFxuICAgICAgICAgICAgaXRlbTogaXRlbSxcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgICAgICAgIHN1Y2Nlc3M6IHN1Y2Nlc3NcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXRlbS5vbignbG9hZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBoYW5kbGVBZGQgPSBmdW5jdGlvbiBoYW5kbGVBZGQoc2hvdWxkQWRkKSB7XG4gICAgICAgICAgICAvLyBubyBzaG91bGQgbm90IGFkZCB0aGlzIGZpbGVcbiAgICAgICAgICAgIGlmICghc2hvdWxkQWRkKSB7XG4gICAgICAgICAgICAgIGRpc3BhdGNoKCdSRU1PVkVfSVRFTScsIHtcbiAgICAgICAgICAgICAgICBxdWVyeTogaWRcbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBub3cgaW50ZXJlc3RlZCBpbiBtZXRhZGF0YSB1cGRhdGVzXG4gICAgICAgICAgICBpdGVtLm9uKCdtZXRhZGF0YS11cGRhdGUnLCBmdW5jdGlvbihjaGFuZ2UpIHtcbiAgICAgICAgICAgICAgZGlzcGF0Y2goJ0RJRF9VUERBVEVfSVRFTV9NRVRBREFUQScsIHsgaWQ6IGlkLCBjaGFuZ2U6IGNoYW5nZSB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBsZXQgcGx1Z2lucyBkZWNpZGUgaWYgdGhlIG91dHB1dCBkYXRhIHNob3VsZCBiZSBwcmVwYXJlZCBhdCB0aGlzIHBvaW50XG4gICAgICAgICAgICAvLyBtZWFucyB3ZSdsbCBkbyB0aGlzIGFuZCB3YWl0IGZvciBpZGxlIHN0YXRlXG4gICAgICAgICAgICBhcHBseUZpbHRlckNoYWluKCdTSE9VTERfUFJFUEFSRV9PVVRQVVQnLCBmYWxzZSwge1xuICAgICAgICAgICAgICBpdGVtOiBpdGVtLFxuICAgICAgICAgICAgICBxdWVyeTogcXVlcnlcbiAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24oc2hvdWxkUHJlcGFyZU91dHB1dCkge1xuICAgICAgICAgICAgICAvLyBwbHVnaW5zIGRldGVybWluZWQgdGhlIG91dHB1dCBkYXRhIHNob3VsZCBiZSBwcmVwYXJlZCAob3Igbm90KSwgY2FuIGJlIGFkanVzdGVkIHdpdGggYmVmb3JlUHJlcGFyZU91dHB1dCBob29rXG4gICAgICAgICAgICAgIHZhciBiZWZvcmVQcmVwYXJlRmlsZSA9IHF1ZXJ5KCdHRVRfQkVGT1JFX1BSRVBBUkVfRklMRScpO1xuICAgICAgICAgICAgICBpZiAoYmVmb3JlUHJlcGFyZUZpbGUpXG4gICAgICAgICAgICAgICAgc2hvdWxkUHJlcGFyZU91dHB1dCA9IGJlZm9yZVByZXBhcmVGaWxlKFxuICAgICAgICAgICAgICAgICAgaXRlbSxcbiAgICAgICAgICAgICAgICAgIHNob3VsZFByZXBhcmVPdXRwdXRcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgIHZhciBsb2FkQ29tcGxldGUgPSBmdW5jdGlvbiBsb2FkQ29tcGxldGUoKSB7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2goJ0NPTVBMRVRFX0xPQURfSVRFTScsIHtcbiAgICAgICAgICAgICAgICAgIHF1ZXJ5OiBpZCxcbiAgICAgICAgICAgICAgICAgIGl0ZW06IGl0ZW0sXG4gICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiBzdWNjZXNzXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBsaXN0VXBkYXRlZChkaXNwYXRjaCwgc3RhdGUpO1xuICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgIC8vIGV4aXRcbiAgICAgICAgICAgICAgaWYgKHNob3VsZFByZXBhcmVPdXRwdXQpIHtcbiAgICAgICAgICAgICAgICAvLyB3YWl0IGZvciBpZGxlIHN0YXRlIGFuZCB0aGVuIHJ1biBQUkVQQVJFX09VVFBVVFxuICAgICAgICAgICAgICAgIGRpc3BhdGNoKFxuICAgICAgICAgICAgICAgICAgJ1JFUVVFU1RfUFJFUEFSRV9PVVRQVVQnLFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBxdWVyeTogaWQsXG4gICAgICAgICAgICAgICAgICAgIGl0ZW06IGl0ZW0sXG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIHN1Y2Nlc3MoZmlsZSkge1xuICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdESURfUFJFUEFSRV9PVVRQVVQnLCB7IGlkOiBpZCwgZmlsZTogZmlsZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICBsb2FkQ29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIHRydWVcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgbG9hZENvbXBsZXRlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgLy8gaXRlbSBsb2FkZWQsIGFsbG93IHBsdWdpbnMgdG9cbiAgICAgICAgICAvLyAtIHJlYWQgZGF0YSAocXVpY2tseSlcbiAgICAgICAgICAvLyAtIGFkZCBtZXRhZGF0YVxuICAgICAgICAgIGFwcGx5RmlsdGVyQ2hhaW4oJ0RJRF9MT0FEX0lURU0nLCBpdGVtLCB7XG4gICAgICAgICAgICBxdWVyeTogcXVlcnksXG4gICAgICAgICAgICBkaXNwYXRjaDogZGlzcGF0Y2hcbiAgICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIG9wdGlvbmFsUHJvbWlzZShcbiAgICAgICAgICAgICAgICBxdWVyeSgnR0VUX0JFRk9SRV9BRERfRklMRScpLFxuICAgICAgICAgICAgICAgIGNyZWF0ZUl0ZW1BUEkoaXRlbSlcbiAgICAgICAgICAgICAgKS50aGVuKGhhbmRsZUFkZCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBoYW5kbGVBZGQoZmFsc2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0ZW0ub24oJ3Byb2Nlc3Mtc3RhcnQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICBkaXNwYXRjaCgnRElEX1NUQVJUX0lURU1fUFJPQ0VTU0lORycsIHsgaWQ6IGlkIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdGVtLm9uKCdwcm9jZXNzLXByb2dyZXNzJywgZnVuY3Rpb24ocHJvZ3Jlc3MpIHtcbiAgICAgICAgICBkaXNwYXRjaCgnRElEX1VQREFURV9JVEVNX1BST0NFU1NfUFJPR1JFU1MnLCB7XG4gICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICBwcm9ncmVzczogcHJvZ3Jlc3NcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXRlbS5vbigncHJvY2Vzcy1lcnJvcicsIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgZGlzcGF0Y2goJ0RJRF9USFJPV19JVEVNX1BST0NFU1NJTkdfRVJST1InLCB7XG4gICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgICAgICBzdGF0dXM6IHtcbiAgICAgICAgICAgICAgbWFpbjogZHluYW1pY0xhYmVsKHN0YXRlLm9wdGlvbnMubGFiZWxGaWxlUHJvY2Vzc2luZ0Vycm9yKShlcnJvciksXG4gICAgICAgICAgICAgIHN1Yjogc3RhdGUub3B0aW9ucy5sYWJlbFRhcFRvUmV0cnlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXRlbS5vbigncHJvY2Vzcy1yZXZlcnQtZXJyb3InLCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgIGRpc3BhdGNoKCdESURfVEhST1dfSVRFTV9QUk9DRVNTSU5HX1JFVkVSVF9FUlJPUicsIHtcbiAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICAgIHN0YXR1czoge1xuICAgICAgICAgICAgICBtYWluOiBkeW5hbWljTGFiZWwoc3RhdGUub3B0aW9ucy5sYWJlbEZpbGVQcm9jZXNzaW5nUmV2ZXJ0RXJyb3IpKFxuICAgICAgICAgICAgICAgIGVycm9yXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIHN1Yjogc3RhdGUub3B0aW9ucy5sYWJlbFRhcFRvUmV0cnlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXRlbS5vbigncHJvY2Vzcy1jb21wbGV0ZScsIGZ1bmN0aW9uKHNlcnZlckZpbGVSZWZlcmVuY2UpIHtcbiAgICAgICAgICBkaXNwYXRjaCgnRElEX0NPTVBMRVRFX0lURU1fUFJPQ0VTU0lORycsIHtcbiAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgICAgc2VydmVyRmlsZVJlZmVyZW5jZTogc2VydmVyRmlsZVJlZmVyZW5jZVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgZGlzcGF0Y2goJ0RJRF9ERUZJTkVfVkFMVUUnLCB7IGlkOiBpZCwgdmFsdWU6IHNlcnZlckZpbGVSZWZlcmVuY2UgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0ZW0ub24oJ3Byb2Nlc3MtYWJvcnQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICBkaXNwYXRjaCgnRElEX0FCT1JUX0lURU1fUFJPQ0VTU0lORycsIHsgaWQ6IGlkIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdGVtLm9uKCdwcm9jZXNzLXJldmVydCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGRpc3BhdGNoKCdESURfUkVWRVJUX0lURU1fUFJPQ0VTU0lORycsIHsgaWQ6IGlkIH0pO1xuICAgICAgICAgIGRpc3BhdGNoKCdESURfREVGSU5FX1ZBTFVFJywgeyBpZDogaWQsIHZhbHVlOiBudWxsIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBsZXQgdmlldyBrbm93IHRoZSBpdGVtIGhhcyBiZWVuIGluc2VydGVkXG4gICAgICAgIGRpc3BhdGNoKCdESURfQUREX0lURU0nLCB7XG4gICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgICBpbnRlcmFjdGlvbk1ldGhvZDogaW50ZXJhY3Rpb25NZXRob2RcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbGlzdFVwZGF0ZWQoZGlzcGF0Y2gsIHN0YXRlKTtcblxuICAgICAgICAvLyBzdGFydCBsb2FkaW5nIHRoZSBzb3VyY2VcbiAgICAgICAgdmFyIF9yZWY4ID0gc3RhdGUub3B0aW9ucy5zZXJ2ZXIgfHwge30sXG4gICAgICAgICAgdXJsID0gX3JlZjgudXJsLFxuICAgICAgICAgIGxvYWQgPSBfcmVmOC5sb2FkLFxuICAgICAgICAgIHJlc3RvcmUgPSBfcmVmOC5yZXN0b3JlLFxuICAgICAgICAgIGZldGNoID0gX3JlZjguZmV0Y2g7XG5cbiAgICAgICAgaXRlbS5sb2FkKFxuICAgICAgICAgIHNvdXJjZSxcblxuICAgICAgICAgIC8vIHRoaXMgY3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgbG9hZHMgdGhlIGZpbGUgYmFzZWQgb24gdGhlIHR5cGUgb2YgZmlsZSAoc3RyaW5nLCBiYXNlNjQsIGJsb2IsIGZpbGUpIGFuZCBsb2NhdGlvbiBvZiBmaWxlIChsb2NhbCwgcmVtb3RlLCBsaW1ibylcbiAgICAgICAgICBjcmVhdGVGaWxlTG9hZGVyKFxuICAgICAgICAgICAgb3JpZ2luID09PSBGaWxlT3JpZ2luLklOUFVUXG4gICAgICAgICAgICAgID8gLy8gaW5wdXQsIGlmIGlzIHJlbW90ZSwgc2VlIGlmIHNob3VsZCB1c2UgY3VzdG9tIGZldGNoLCBlbHNlIHVzZSBkZWZhdWx0IGZldGNoQmxvYlxuICAgICAgICAgICAgICAgIGlzU3RyaW5nKHNvdXJjZSkgJiYgaXNFeHRlcm5hbFVSTChzb3VyY2UpXG4gICAgICAgICAgICAgICAgPyBmZXRjaFxuICAgICAgICAgICAgICAgICAgPyBjcmVhdGVGZXRjaEZ1bmN0aW9uKHVybCwgZmV0Y2gpXG4gICAgICAgICAgICAgICAgICA6IGZldGNoQmxvYiAvLyByZW1vdGUgdXJsXG4gICAgICAgICAgICAgICAgOiBmZXRjaEJsb2IgLy8gdHJ5IHRvIGZldGNoIHVybFxuICAgICAgICAgICAgICA6IC8vIGxpbWJvIG9yIGxvY2FsXG4gICAgICAgICAgICAgIG9yaWdpbiA9PT0gRmlsZU9yaWdpbi5MSU1CT1xuICAgICAgICAgICAgICA/IGNyZWF0ZUZldGNoRnVuY3Rpb24odXJsLCByZXN0b3JlKSAvLyBsaW1ib1xuICAgICAgICAgICAgICA6IGNyZWF0ZUZldGNoRnVuY3Rpb24odXJsLCBsb2FkKSAvLyBsb2NhbFxuICAgICAgICAgICksXG5cbiAgICAgICAgICAvLyBjYWxsZWQgd2hlbiB0aGUgZmlsZSBpcyBsb2FkZWQgc28gaXQgY2FuIGJlIHBpcGVkIHRocm91Z2ggdGhlIGZpbHRlcnNcbiAgICAgICAgICBmdW5jdGlvbihmaWxlLCBzdWNjZXNzLCBlcnJvcikge1xuICAgICAgICAgICAgLy8gbGV0J3MgcHJvY2VzcyB0aGUgZmlsZVxuICAgICAgICAgICAgYXBwbHlGaWx0ZXJDaGFpbignTE9BRF9GSUxFJywgZmlsZSwgeyBxdWVyeTogcXVlcnkgfSlcbiAgICAgICAgICAgICAgLnRoZW4oc3VjY2VzcylcbiAgICAgICAgICAgICAgLmNhdGNoKGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICB9LFxuXG4gICAgICBSRVFVRVNUX1BSRVBBUkVfT1VUUFVUOiBmdW5jdGlvbiBSRVFVRVNUX1BSRVBBUkVfT1VUUFVUKF9yZWY5KSB7XG4gICAgICAgIHZhciBpdGVtID0gX3JlZjkuaXRlbSxcbiAgICAgICAgICBzdWNjZXNzID0gX3JlZjkuc3VjY2VzcyxcbiAgICAgICAgICBfcmVmOSRmYWlsdXJlID0gX3JlZjkuZmFpbHVyZSxcbiAgICAgICAgICBmYWlsdXJlID0gX3JlZjkkZmFpbHVyZSA9PT0gdm9pZCAwID8gZnVuY3Rpb24oKSB7fSA6IF9yZWY5JGZhaWx1cmU7XG5cbiAgICAgICAgLy8gZXJyb3IgcmVzcG9uc2UgaWYgaXRlbSBhcmNoaXZlZFxuICAgICAgICB2YXIgZXJyID0ge1xuICAgICAgICAgIGVycm9yOiBjcmVhdGVSZXNwb25zZSgnZXJyb3InLCAwLCAnSXRlbSBub3QgZm91bmQnKSxcblxuICAgICAgICAgIGZpbGU6IG51bGxcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBkb24ndCBoYW5kbGUgYXJjaGl2ZWQgaXRlbXMsIGFuIGl0ZW0gY291bGQgaGF2ZSBiZWVuIGFyY2hpdmVkIChsb2FkIGFib3J0ZWQpIHdoaWxlIHdhaXRpbmcgdG8gYmUgcHJlcGFyZWRcbiAgICAgICAgaWYgKGl0ZW0uYXJjaGl2ZWQpIHJldHVybiBmYWlsdXJlKGVycik7XG5cbiAgICAgICAgLy8gYWxsb3cgcGx1Z2lucyB0byBhbHRlciB0aGUgZmlsZSBkYXRhXG4gICAgICAgIGFwcGx5RmlsdGVyQ2hhaW4oJ1BSRVBBUkVfT1VUUFVUJywgaXRlbS5maWxlLCB7XG4gICAgICAgICAgcXVlcnk6IHF1ZXJ5LFxuICAgICAgICAgIGl0ZW06IGl0ZW1cbiAgICAgICAgfSkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICBhcHBseUZpbHRlckNoYWluKCdDT01QTEVURV9QUkVQQVJFX09VVFBVVCcsIHJlc3VsdCwge1xuICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5LFxuICAgICAgICAgICAgaXRlbTogaXRlbVxuICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgICAvLyBkb24ndCBoYW5kbGUgYXJjaGl2ZWQgaXRlbXMsIGFuIGl0ZW0gY291bGQgaGF2ZSBiZWVuIGFyY2hpdmVkIChsb2FkIGFib3J0ZWQpIHdoaWxlIGJlaW5nIHByZXBhcmVkXG4gICAgICAgICAgICBpZiAoaXRlbS5hcmNoaXZlZCkgcmV0dXJuIGZhaWx1cmUoZXJyKTtcblxuICAgICAgICAgICAgLy8gd2UgZG9uZSFcbiAgICAgICAgICAgIHN1Y2Nlc3MocmVzdWx0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuXG4gICAgICBDT01QTEVURV9MT0FEX0lURU06IGZ1bmN0aW9uIENPTVBMRVRFX0xPQURfSVRFTShfcmVmMTApIHtcbiAgICAgICAgdmFyIGl0ZW0gPSBfcmVmMTAuaXRlbSxcbiAgICAgICAgICBkYXRhID0gX3JlZjEwLmRhdGE7XG4gICAgICAgIHZhciBzdWNjZXNzID0gZGF0YS5zdWNjZXNzLFxuICAgICAgICAgIHNvdXJjZSA9IGRhdGEuc291cmNlO1xuXG4gICAgICAgIC8vIHNvcnQgaXRlbXMgaW4gbGlzdFxuICAgICAgICB2YXIgaXRlbUluc2VydExvY2F0aW9uID0gcXVlcnkoJ0dFVF9JVEVNX0lOU0VSVF9MT0NBVElPTicpO1xuICAgICAgICBpZiAoaXNGdW5jdGlvbihpdGVtSW5zZXJ0TG9jYXRpb24pICYmIHNvdXJjZSkge1xuICAgICAgICAgIHNvcnRJdGVtcyhzdGF0ZSwgaXRlbUluc2VydExvY2F0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGxldCBpbnRlcmZhY2Uga25vdyB0aGUgaXRlbSBoYXMgbG9hZGVkXG4gICAgICAgIGRpc3BhdGNoKCdESURfTE9BRF9JVEVNJywge1xuICAgICAgICAgIGlkOiBpdGVtLmlkLFxuICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgIHNlcnZlckZpbGVSZWZlcmVuY2U6IGl0ZW0ub3JpZ2luID09PSBGaWxlT3JpZ2luLklOUFVUID8gbnVsbCA6IHNvdXJjZVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBpdGVtIGhhcyBiZWVuIHN1Y2Nlc3NmdWxseSBsb2FkZWQgYW5kIGFkZGVkIHRvIHRoZVxuICAgICAgICAvLyBsaXN0IG9mIGl0ZW1zIHNvIGNhbiBub3cgYmUgc2FmZWx5IHJldHVybmVkIGZvciB1c2VcbiAgICAgICAgc3VjY2VzcyhjcmVhdGVJdGVtQVBJKGl0ZW0pKTtcblxuICAgICAgICAvLyBpZiB0aGlzIGlzIGEgbG9jYWwgc2VydmVyIGZpbGUgd2UgbmVlZCB0byBzaG93IGEgZGlmZmVyZW50IHN0YXRlXG4gICAgICAgIGlmIChpdGVtLm9yaWdpbiA9PT0gRmlsZU9yaWdpbi5MT0NBTCkge1xuICAgICAgICAgIGRpc3BhdGNoKCdESURfTE9BRF9MT0NBTF9JVEVNJywgeyBpZDogaXRlbS5pZCB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBpcyBhIHRlbXAgc2VydmVyIGZpbGUgd2UgcHJldmVudCBhc3luYyB1cGxvYWQgY2FsbCBoZXJlIChhcyB0aGUgZmlsZSBpcyBhbHJlYWR5IG9uIHRoZSBzZXJ2ZXIpXG4gICAgICAgIGlmIChpdGVtLm9yaWdpbiA9PT0gRmlsZU9yaWdpbi5MSU1CTykge1xuICAgICAgICAgIGRpc3BhdGNoKCdESURfQ09NUExFVEVfSVRFTV9QUk9DRVNTSU5HJywge1xuICAgICAgICAgICAgaWQ6IGl0ZW0uaWQsXG4gICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICAgIHNlcnZlckZpbGVSZWZlcmVuY2U6IHNvdXJjZVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgZGlzcGF0Y2goJ0RJRF9ERUZJTkVfVkFMVUUnLCB7XG4gICAgICAgICAgICBpZDogaXRlbS5pZCxcbiAgICAgICAgICAgIHZhbHVlOiBzb3VyY2VcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlkIHdlIGFyZSBhbGxvd2VkIHRvIHVwbG9hZCB0aGUgZmlsZSBpbW1lZGlhdGVseSwgbGV0cyBkbyBpdFxuICAgICAgICBpZiAocXVlcnkoJ0lTX0FTWU5DJykgJiYgc3RhdGUub3B0aW9ucy5pbnN0YW50VXBsb2FkKSB7XG4gICAgICAgICAgZGlzcGF0Y2goJ1JFUVVFU1RfSVRFTV9QUk9DRVNTSU5HJywgeyBxdWVyeTogaXRlbS5pZCB9KTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgUkVUUllfSVRFTV9MT0FEOiBnZXRJdGVtQnlRdWVyeUZyb21TdGF0ZShzdGF0ZSwgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAvLyB0cnkgbG9hZGluZyB0aGUgc291cmNlIG9uZSBtb3JlIHRpbWVcbiAgICAgICAgaXRlbS5yZXRyeUxvYWQoKTtcbiAgICAgIH0pLFxuXG4gICAgICBSRVFVRVNUX0lURU1fUFJFUEFSRTogZ2V0SXRlbUJ5UXVlcnlGcm9tU3RhdGUoc3RhdGUsIGZ1bmN0aW9uKFxuICAgICAgICBpdGVtLFxuICAgICAgICBfc3VjY2VzcyxcbiAgICAgICAgZmFpbHVyZVxuICAgICAgKSB7XG4gICAgICAgIGRpc3BhdGNoKFxuICAgICAgICAgICdSRVFVRVNUX1BSRVBBUkVfT1VUUFVUJyxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBxdWVyeTogaXRlbS5pZCxcbiAgICAgICAgICAgIGl0ZW06IGl0ZW0sXG4gICAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiBzdWNjZXNzKGZpbGUpIHtcbiAgICAgICAgICAgICAgZGlzcGF0Y2goJ0RJRF9QUkVQQVJFX09VVFBVVCcsIHsgaWQ6IGl0ZW0uaWQsIGZpbGU6IGZpbGUgfSk7XG4gICAgICAgICAgICAgIF9zdWNjZXNzKHtcbiAgICAgICAgICAgICAgICBmaWxlOiBpdGVtLFxuICAgICAgICAgICAgICAgIG91dHB1dDogZmlsZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmYWlsdXJlOiBmYWlsdXJlXG4gICAgICAgICAgfSxcbiAgICAgICAgICB0cnVlXG4gICAgICAgICk7XG4gICAgICB9KSxcblxuICAgICAgUkVRVUVTVF9JVEVNX1BST0NFU1NJTkc6IGdldEl0ZW1CeVF1ZXJ5RnJvbVN0YXRlKHN0YXRlLCBmdW5jdGlvbihcbiAgICAgICAgaXRlbSxcbiAgICAgICAgc3VjY2VzcyxcbiAgICAgICAgZmFpbHVyZVxuICAgICAgKSB7XG4gICAgICAgIC8vIGNhbm5vdCBiZSBxdWV1ZWQgKG9yIGlzIGFscmVhZHkgcXVldWVkKVxuICAgICAgICB2YXIgaXRlbUNhbkJlUXVldWVkRm9yUHJvY2Vzc2luZyA9XG4gICAgICAgICAgLy8gd2FpdGluZyBmb3Igc29tZXRoaW5nXG4gICAgICAgICAgaXRlbS5zdGF0dXMgPT09IEl0ZW1TdGF0dXMuSURMRSB8fFxuICAgICAgICAgIC8vIHByb2Nlc3Npbmcgd2VudCB3cm9uZyBlYXJsaWVyXG4gICAgICAgICAgaXRlbS5zdGF0dXMgPT09IEl0ZW1TdGF0dXMuUFJPQ0VTU0lOR19FUlJPUjtcblxuICAgICAgICAvLyBub3QgcmVhZHkgdG8gYmUgcHJvY2Vzc2VkXG4gICAgICAgIGlmICghaXRlbUNhbkJlUXVldWVkRm9yUHJvY2Vzc2luZykge1xuICAgICAgICAgIHZhciBwcm9jZXNzTm93ID0gZnVuY3Rpb24gcHJvY2Vzc05vdygpIHtcbiAgICAgICAgICAgIHJldHVybiBkaXNwYXRjaCgnUkVRVUVTVF9JVEVNX1BST0NFU1NJTkcnLCB7XG4gICAgICAgICAgICAgIHF1ZXJ5OiBpdGVtLFxuICAgICAgICAgICAgICBzdWNjZXNzOiBzdWNjZXNzLFxuICAgICAgICAgICAgICBmYWlsdXJlOiBmYWlsdXJlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgdmFyIHByb2Nlc3MgPSBmdW5jdGlvbiBwcm9jZXNzKCkge1xuICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50LmhpZGRlbiA/IHByb2Nlc3NOb3coKSA6IHNldFRpbWVvdXQocHJvY2Vzc05vdywgMzIpO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICAvLyBpZiBhbHJlYWR5IGRvbmUgcHJvY2Vzc2luZyBvciB0cmllZCB0byByZXZlcnQgYnV0IGRpZG4ndCB3b3JrLCB0cnkgYWdhaW5cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBpdGVtLnN0YXR1cyA9PT0gSXRlbVN0YXR1cy5QUk9DRVNTSU5HX0NPTVBMRVRFIHx8XG4gICAgICAgICAgICBpdGVtLnN0YXR1cyA9PT0gSXRlbVN0YXR1cy5QUk9DRVNTSU5HX1JFVkVSVF9FUlJPUlxuICAgICAgICAgICkge1xuICAgICAgICAgICAgaXRlbVxuICAgICAgICAgICAgICAucmV2ZXJ0KFxuICAgICAgICAgICAgICAgIGNyZWF0ZVJldmVydEZ1bmN0aW9uKFxuICAgICAgICAgICAgICAgICAgc3RhdGUub3B0aW9ucy5zZXJ2ZXIudXJsLFxuICAgICAgICAgICAgICAgICAgc3RhdGUub3B0aW9ucy5zZXJ2ZXIucmV2ZXJ0XG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBxdWVyeSgnR0VUX0ZPUkNFX1JFVkVSVCcpXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgLnRoZW4ocHJvY2VzcylcbiAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uKCkge30pOyAvLyBkb24ndCBjb250aW51ZSB3aXRoIHByb2Nlc3NpbmcgaWYgc29tZXRoaW5nIHdlbnQgd3JvbmdcbiAgICAgICAgICB9IGVsc2UgaWYgKGl0ZW0uc3RhdHVzID09PSBJdGVtU3RhdHVzLlBST0NFU1NJTkcpIHtcbiAgICAgICAgICAgIGl0ZW0uYWJvcnRQcm9jZXNzaW5nKCkudGhlbihwcm9jZXNzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhbHJlYWR5IHF1ZXVlZCBmb3IgcHJvY2Vzc2luZ1xuICAgICAgICBpZiAoaXRlbS5zdGF0dXMgPT09IEl0ZW1TdGF0dXMuUFJPQ0VTU0lOR19RVUVVRUQpIHJldHVybjtcblxuICAgICAgICBpdGVtLnJlcXVlc3RQcm9jZXNzaW5nKCk7XG5cbiAgICAgICAgZGlzcGF0Y2goJ0RJRF9SRVFVRVNUX0lURU1fUFJPQ0VTU0lORycsIHsgaWQ6IGl0ZW0uaWQgfSk7XG5cbiAgICAgICAgZGlzcGF0Y2goXG4gICAgICAgICAgJ1BST0NFU1NfSVRFTScsXG4gICAgICAgICAgeyBxdWVyeTogaXRlbSwgc3VjY2Vzczogc3VjY2VzcywgZmFpbHVyZTogZmFpbHVyZSB9LFxuICAgICAgICAgIHRydWVcbiAgICAgICAgKTtcbiAgICAgIH0pLFxuXG4gICAgICBQUk9DRVNTX0lURU06IGdldEl0ZW1CeVF1ZXJ5RnJvbVN0YXRlKHN0YXRlLCBmdW5jdGlvbihcbiAgICAgICAgaXRlbSxcbiAgICAgICAgc3VjY2VzcyxcbiAgICAgICAgZmFpbHVyZVxuICAgICAgKSB7XG4gICAgICAgIHZhciBtYXhQYXJhbGxlbFVwbG9hZHMgPSBxdWVyeSgnR0VUX01BWF9QQVJBTExFTF9VUExPQURTJyk7XG4gICAgICAgIHZhciB0b3RhbEN1cnJlbnRVcGxvYWRzID0gcXVlcnkoXG4gICAgICAgICAgJ0dFVF9JVEVNU19CWV9TVEFUVVMnLFxuICAgICAgICAgIEl0ZW1TdGF0dXMuUFJPQ0VTU0lOR1xuICAgICAgICApLmxlbmd0aDtcblxuICAgICAgICAvLyBxdWV1ZSBhbmQgd2FpdCB0aWxsIHF1ZXVlIGlzIGZyZWVkIHVwXG4gICAgICAgIGlmICh0b3RhbEN1cnJlbnRVcGxvYWRzID09PSBtYXhQYXJhbGxlbFVwbG9hZHMpIHtcbiAgICAgICAgICAvLyBxdWV1ZSBmb3IgbGF0ZXIgcHJvY2Vzc2luZ1xuICAgICAgICAgIHN0YXRlLnByb2Nlc3NpbmdRdWV1ZS5wdXNoKHtcbiAgICAgICAgICAgIGlkOiBpdGVtLmlkLFxuICAgICAgICAgICAgc3VjY2Vzczogc3VjY2VzcyxcbiAgICAgICAgICAgIGZhaWx1cmU6IGZhaWx1cmVcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIC8vIHN0b3AgaXQhXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgd2FzIG5vdCBxdWV1ZWQgb3IgaXMgYWxyZWFkeSBwcm9jZXNzaW5nIGV4aXQgaGVyZVxuICAgICAgICBpZiAoaXRlbS5zdGF0dXMgPT09IEl0ZW1TdGF0dXMuUFJPQ0VTU0lORykgcmV0dXJuO1xuXG4gICAgICAgIHZhciBwcm9jZXNzTmV4dCA9IGZ1bmN0aW9uIHByb2Nlc3NOZXh0KCkge1xuICAgICAgICAgIC8vIHByb2Nlc3MgcXVldWV1ZCBpdGVtc1xuICAgICAgICAgIHZhciBxdWV1ZUVudHJ5ID0gc3RhdGUucHJvY2Vzc2luZ1F1ZXVlLnNoaWZ0KCk7XG5cbiAgICAgICAgICAvLyBubyBpdGVtcyBsZWZ0XG4gICAgICAgICAgaWYgKCFxdWV1ZUVudHJ5KSByZXR1cm47XG5cbiAgICAgICAgICAvLyBnZXQgaXRlbSByZWZlcmVuY2VcbiAgICAgICAgICB2YXIgaWQgPSBxdWV1ZUVudHJ5LmlkLFxuICAgICAgICAgICAgc3VjY2VzcyA9IHF1ZXVlRW50cnkuc3VjY2VzcyxcbiAgICAgICAgICAgIGZhaWx1cmUgPSBxdWV1ZUVudHJ5LmZhaWx1cmU7XG4gICAgICAgICAgdmFyIGl0ZW1SZWZlcmVuY2UgPSBnZXRJdGVtQnlRdWVyeShzdGF0ZS5pdGVtcywgaWQpO1xuXG4gICAgICAgICAgLy8gaWYgaXRlbSB3YXMgYXJjaGl2ZWQgd2hpbGUgaW4gcXVldWUsIGp1bXAgdG8gbmV4dFxuICAgICAgICAgIGlmICghaXRlbVJlZmVyZW5jZSB8fCBpdGVtUmVmZXJlbmNlLmFyY2hpdmVkKSB7XG4gICAgICAgICAgICBwcm9jZXNzTmV4dCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHByb2Nlc3MgcXVldWVkIGl0ZW1cbiAgICAgICAgICBkaXNwYXRjaChcbiAgICAgICAgICAgICdQUk9DRVNTX0lURU0nLFxuICAgICAgICAgICAgeyBxdWVyeTogaWQsIHN1Y2Nlc3M6IHN1Y2Nlc3MsIGZhaWx1cmU6IGZhaWx1cmUgfSxcbiAgICAgICAgICAgIHRydWVcbiAgICAgICAgICApO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHdlIGRvbmUgZnVuY3Rpb25cbiAgICAgICAgaXRlbS5vbk9uY2UoJ3Byb2Nlc3MtY29tcGxldGUnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICBzdWNjZXNzKGNyZWF0ZUl0ZW1BUEkoaXRlbSkpO1xuICAgICAgICAgIHByb2Nlc3NOZXh0KCk7XG5cbiAgICAgICAgICAvLyBBbGwgaXRlbXMgcHJvY2Vzc2VkPyBObyBlcnJvcnM/XG4gICAgICAgICAgdmFyIGFsbEl0ZW1zUHJvY2Vzc2VkID1cbiAgICAgICAgICAgIHF1ZXJ5KCdHRVRfSVRFTVNfQllfU1RBVFVTJywgSXRlbVN0YXR1cy5QUk9DRVNTSU5HX0NPTVBMRVRFKVxuICAgICAgICAgICAgICAubGVuZ3RoID09PSBzdGF0ZS5pdGVtcy5sZW5ndGg7XG4gICAgICAgICAgaWYgKGFsbEl0ZW1zUHJvY2Vzc2VkKSB7XG4gICAgICAgICAgICBkaXNwYXRjaCgnRElEX0NPTVBMRVRFX0lURU1fUFJPQ0VTU0lOR19BTEwnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHdlIGVycm9yIGZ1bmN0aW9uXG4gICAgICAgIGl0ZW0ub25PbmNlKCdwcm9jZXNzLWVycm9yJywgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICBmYWlsdXJlKHsgZXJyb3I6IGVycm9yLCBmaWxlOiBjcmVhdGVJdGVtQVBJKGl0ZW0pIH0pO1xuICAgICAgICAgIHByb2Nlc3NOZXh0KCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHN0YXJ0IGZpbGUgcHJvY2Vzc2luZ1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHN0YXRlLm9wdGlvbnM7XG4gICAgICAgIGl0ZW0ucHJvY2VzcyhcbiAgICAgICAgICBjcmVhdGVGaWxlUHJvY2Vzc29yKFxuICAgICAgICAgICAgY3JlYXRlUHJvY2Vzc29yRnVuY3Rpb24oXG4gICAgICAgICAgICAgIG9wdGlvbnMuc2VydmVyLnVybCxcbiAgICAgICAgICAgICAgb3B0aW9ucy5zZXJ2ZXIucHJvY2VzcyxcbiAgICAgICAgICAgICAgb3B0aW9ucy5uYW1lLFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY2h1bmtUcmFuc2ZlcklkOiBpdGVtLnRyYW5zZmVySWQsXG4gICAgICAgICAgICAgICAgY2h1bmtTZXJ2ZXI6IG9wdGlvbnMuc2VydmVyLnBhdGNoLFxuICAgICAgICAgICAgICAgIGNodW5rVXBsb2Fkczogb3B0aW9ucy5jaHVua1VwbG9hZHMsXG4gICAgICAgICAgICAgICAgY2h1bmtGb3JjZTogb3B0aW9ucy5jaHVua0ZvcmNlLFxuICAgICAgICAgICAgICAgIGNodW5rU2l6ZTogb3B0aW9ucy5jaHVua1NpemUsXG4gICAgICAgICAgICAgICAgY2h1bmtSZXRyeURlbGF5czogb3B0aW9ucy5jaHVua1JldHJ5RGVsYXlzXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIClcbiAgICAgICAgICApLFxuXG4gICAgICAgICAgLy8gY2FsbGVkIHdoZW4gdGhlIGZpbGUgaXMgYWJvdXQgdG8gYmUgcHJvY2Vzc2VkIHNvIGl0IGNhbiBiZSBwaXBlZCB0aHJvdWdoIHRoZSB0cmFuc2Zvcm0gZmlsdGVyc1xuICAgICAgICAgIGZ1bmN0aW9uKGZpbGUsIHN1Y2Nlc3MsIGVycm9yKSB7XG4gICAgICAgICAgICAvLyBhbGxvdyBwbHVnaW5zIHRvIGFsdGVyIHRoZSBmaWxlIGRhdGFcbiAgICAgICAgICAgIGFwcGx5RmlsdGVyQ2hhaW4oJ1BSRVBBUkVfT1VUUFVUJywgZmlsZSwge1xuICAgICAgICAgICAgICBxdWVyeTogcXVlcnksXG4gICAgICAgICAgICAgIGl0ZW06IGl0ZW1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKGZpbGUpIHtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaCgnRElEX1BSRVBBUkVfT1VUUFVUJywgeyBpZDogaXRlbS5pZCwgZmlsZTogZmlsZSB9KTtcblxuICAgICAgICAgICAgICAgIHN1Y2Nlc3MoZmlsZSk7XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIC5jYXRjaChlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgfSksXG5cbiAgICAgIFJFVFJZX0lURU1fUFJPQ0VTU0lORzogZ2V0SXRlbUJ5UXVlcnlGcm9tU3RhdGUoc3RhdGUsIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgZGlzcGF0Y2goJ1JFUVVFU1RfSVRFTV9QUk9DRVNTSU5HJywgeyBxdWVyeTogaXRlbSB9KTtcbiAgICAgIH0pLFxuXG4gICAgICBSRVFVRVNUX1JFTU9WRV9JVEVNOiBnZXRJdGVtQnlRdWVyeUZyb21TdGF0ZShzdGF0ZSwgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICBvcHRpb25hbFByb21pc2UoXG4gICAgICAgICAgcXVlcnkoJ0dFVF9CRUZPUkVfUkVNT1ZFX0ZJTEUnKSxcbiAgICAgICAgICBjcmVhdGVJdGVtQVBJKGl0ZW0pXG4gICAgICAgICkudGhlbihmdW5jdGlvbihzaG91bGRSZW1vdmUpIHtcbiAgICAgICAgICBpZiAoIXNob3VsZFJlbW92ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkaXNwYXRjaCgnUkVNT1ZFX0lURU0nLCB7IHF1ZXJ5OiBpdGVtIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pLFxuXG4gICAgICBSRUxFQVNFX0lURU06IGdldEl0ZW1CeVF1ZXJ5RnJvbVN0YXRlKHN0YXRlLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgIGl0ZW0ucmVsZWFzZSgpO1xuICAgICAgfSksXG5cbiAgICAgIFJFTU9WRV9JVEVNOiBnZXRJdGVtQnlRdWVyeUZyb21TdGF0ZShzdGF0ZSwgZnVuY3Rpb24oXG4gICAgICAgIGl0ZW0sXG4gICAgICAgIHN1Y2Nlc3MsXG4gICAgICAgIGZhaWx1cmUsXG4gICAgICAgIG9wdGlvbnNcbiAgICAgICkge1xuICAgICAgICB2YXIgcmVtb3ZlRnJvbVZpZXcgPSBmdW5jdGlvbiByZW1vdmVGcm9tVmlldygpIHtcbiAgICAgICAgICAvLyBnZXQgaWQgcmVmZXJlbmNlXG4gICAgICAgICAgdmFyIGlkID0gaXRlbS5pZDtcblxuICAgICAgICAgIC8vIGFyY2hpdmUgdGhlIGl0ZW0sIHRoaXMgZG9lcyBub3QgcmVtb3ZlIGl0IGZyb20gdGhlIGxpc3RcbiAgICAgICAgICBnZXRJdGVtQnlJZChzdGF0ZS5pdGVtcywgaWQpLmFyY2hpdmUoKTtcblxuICAgICAgICAgIC8vIHRlbGwgdGhlIHZpZXcgdGhlIGl0ZW0gaGFzIGJlZW4gcmVtb3ZlZFxuICAgICAgICAgIGRpc3BhdGNoKCdESURfUkVNT1ZFX0lURU0nLCB7IGVycm9yOiBudWxsLCBpZDogaWQsIGl0ZW06IGl0ZW0gfSk7XG5cbiAgICAgICAgICAvLyBub3cgdGhlIGxpc3QgaGFzIGJlZW4gbW9kaWZpZWRcbiAgICAgICAgICBsaXN0VXBkYXRlZChkaXNwYXRjaCwgc3RhdGUpO1xuXG4gICAgICAgICAgLy8gY29ycmVjdGx5IHJlbW92ZWRcbiAgICAgICAgICBzdWNjZXNzKGNyZWF0ZUl0ZW1BUEkoaXRlbSkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGlmIHRoaXMgaXMgYSBsb2NhbCBmaWxlIGFuZCB0aGUgc2VydmVyLnJlbW92ZSBmdW5jdGlvbiBoYXMgYmVlbiBjb25maWd1cmVkLCBzZW5kIHNvdXJjZSB0aGVyZSBzbyBkZXYgY2FuIHJlbW92ZSBmaWxlIGZyb20gc2VydmVyXG4gICAgICAgIHZhciBzZXJ2ZXIgPSBzdGF0ZS5vcHRpb25zLnNlcnZlcjtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGl0ZW0ub3JpZ2luID09PSBGaWxlT3JpZ2luLkxPQ0FMICYmXG4gICAgICAgICAgc2VydmVyICYmXG4gICAgICAgICAgaXNGdW5jdGlvbihzZXJ2ZXIucmVtb3ZlKSAmJlxuICAgICAgICAgIG9wdGlvbnMucmVtb3ZlICE9PSBmYWxzZVxuICAgICAgICApIHtcbiAgICAgICAgICBkaXNwYXRjaCgnRElEX1NUQVJUX0lURU1fUkVNT1ZFJywgeyBpZDogaXRlbS5pZCB9KTtcblxuICAgICAgICAgIHNlcnZlci5yZW1vdmUoXG4gICAgICAgICAgICBpdGVtLnNvdXJjZSxcbiAgICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICByZXR1cm4gcmVtb3ZlRnJvbVZpZXcoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmdW5jdGlvbihzdGF0dXMpIHtcbiAgICAgICAgICAgICAgZGlzcGF0Y2goJ0RJRF9USFJPV19JVEVNX1JFTU9WRV9FUlJPUicsIHtcbiAgICAgICAgICAgICAgICBpZDogaXRlbS5pZCxcbiAgICAgICAgICAgICAgICBlcnJvcjogY3JlYXRlUmVzcG9uc2UoJ2Vycm9yJywgMCwgc3RhdHVzLCBudWxsKSxcbiAgICAgICAgICAgICAgICBzdGF0dXM6IHtcbiAgICAgICAgICAgICAgICAgIG1haW46IGR5bmFtaWNMYWJlbChzdGF0ZS5vcHRpb25zLmxhYmVsRmlsZVJlbW92ZUVycm9yKShcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzXG4gICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgc3ViOiBzdGF0ZS5vcHRpb25zLmxhYmVsVGFwVG9SZXRyeVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBpZiBpcyByZXF1ZXN0aW5nIHJldmVydCBhbmQgY2FuIHJldmVydCBuZWVkIHRvIGNhbGwgcmV2ZXJ0IGhhbmRsZXIgKG5vdCBjYWxsaW5nIHJlcXVlc3RfIGJlY2F1c2UgdGhhdCB3b3VsZCBhbHNvIHRyaWdnZXIgYmVmb3JlUmVtb3ZlSG9vaylcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBvcHRpb25zLnJldmVydCAmJlxuICAgICAgICAgICAgaXRlbS5vcmlnaW4gIT09IEZpbGVPcmlnaW4uTE9DQUwgJiZcbiAgICAgICAgICAgIGl0ZW0uc2VydmVySWQgIT09IG51bGxcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGl0ZW0ucmV2ZXJ0KFxuICAgICAgICAgICAgICBjcmVhdGVSZXZlcnRGdW5jdGlvbihcbiAgICAgICAgICAgICAgICBzdGF0ZS5vcHRpb25zLnNlcnZlci51cmwsXG4gICAgICAgICAgICAgICAgc3RhdGUub3B0aW9ucy5zZXJ2ZXIucmV2ZXJ0XG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIHF1ZXJ5KCdHRVRfRk9SQ0VfUkVWRVJUJylcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gY2FuIG5vdyBzYWZlbHkgcmVtb3ZlIGZyb20gdmlld1xuICAgICAgICAgIHJlbW92ZUZyb21WaWV3KCk7XG4gICAgICAgIH1cbiAgICAgIH0pLFxuXG4gICAgICBBQk9SVF9JVEVNX0xPQUQ6IGdldEl0ZW1CeVF1ZXJ5RnJvbVN0YXRlKHN0YXRlLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgIGl0ZW0uYWJvcnRMb2FkKCk7XG4gICAgICB9KSxcblxuICAgICAgQUJPUlRfSVRFTV9QUk9DRVNTSU5HOiBnZXRJdGVtQnlRdWVyeUZyb21TdGF0ZShzdGF0ZSwgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAvLyB0ZXN0IGlmIGlzIGFscmVhZHkgcHJvY2Vzc2VkXG4gICAgICAgIGlmIChpdGVtLnNlcnZlcklkKSB7XG4gICAgICAgICAgZGlzcGF0Y2goJ1JFVkVSVF9JVEVNX1BST0NFU1NJTkcnLCB7IGlkOiBpdGVtLmlkIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFib3J0XG4gICAgICAgIGl0ZW0uYWJvcnRQcm9jZXNzaW5nKCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgc2hvdWxkUmVtb3ZlID0gc3RhdGUub3B0aW9ucy5pbnN0YW50VXBsb2FkO1xuICAgICAgICAgIGlmIChzaG91bGRSZW1vdmUpIHtcbiAgICAgICAgICAgIGRpc3BhdGNoKCdSRU1PVkVfSVRFTScsIHsgcXVlcnk6IGl0ZW0uaWQgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pLFxuXG4gICAgICBSRVFVRVNUX1JFVkVSVF9JVEVNX1BST0NFU1NJTkc6IGdldEl0ZW1CeVF1ZXJ5RnJvbVN0YXRlKHN0YXRlLCBmdW5jdGlvbihcbiAgICAgICAgaXRlbVxuICAgICAgKSB7XG4gICAgICAgIC8vIG5vdCBpbnN0YW50IHVwbG9hZGluZywgcmV2ZXJ0IGltbWVkaWF0ZWx5XG4gICAgICAgIGlmICghc3RhdGUub3B0aW9ucy5pbnN0YW50VXBsb2FkKSB7XG4gICAgICAgICAgZGlzcGF0Y2goJ1JFVkVSVF9JVEVNX1BST0NFU1NJTkcnLCB7IHF1ZXJ5OiBpdGVtIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHdlJ3JlIGluc3RhbnQgdXBsb2FkaW5nIHRoZSBmaWxlIHdpbGwgYWxzbyBiZSByZW1vdmVkIGlmIHdlIHJldmVydCxcbiAgICAgICAgLy8gc28gaWYgYSBiZWZvcmUgcmVtb3ZlIGZpbGUgaG9vayBpcyBkZWZpbmVkIHdlIG5lZWQgdG8gcnVuIGl0IG5vd1xuICAgICAgICB2YXIgaGFuZGxlUmV2ZXJ0ID0gZnVuY3Rpb24gaGFuZGxlUmV2ZXJ0KHNob3VsZFJldmVydCkge1xuICAgICAgICAgIGlmICghc2hvdWxkUmV2ZXJ0KSByZXR1cm47XG4gICAgICAgICAgZGlzcGF0Y2goJ1JFVkVSVF9JVEVNX1BST0NFU1NJTkcnLCB7IHF1ZXJ5OiBpdGVtIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBmbiA9IHF1ZXJ5KCdHRVRfQkVGT1JFX1JFTU9WRV9GSUxFJyk7XG4gICAgICAgIGlmICghZm4pIHtcbiAgICAgICAgICByZXR1cm4gaGFuZGxlUmV2ZXJ0KHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlcXVlc3RSZW1vdmVSZXN1bHQgPSBmbihjcmVhdGVJdGVtQVBJKGl0ZW0pKTtcbiAgICAgICAgaWYgKHJlcXVlc3RSZW1vdmVSZXN1bHQgPT0gbnVsbCkge1xuICAgICAgICAgIC8vIHVuZGVmaW5lZCBvciBudWxsXG4gICAgICAgICAgcmV0dXJuIGhhbmRsZVJldmVydCh0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcmVxdWVzdFJlbW92ZVJlc3VsdCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgcmV0dXJuIGhhbmRsZVJldmVydChyZXF1ZXN0UmVtb3ZlUmVzdWx0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcmVxdWVzdFJlbW92ZVJlc3VsdC50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcmVxdWVzdFJlbW92ZVJlc3VsdC50aGVuKGhhbmRsZVJldmVydCk7XG4gICAgICAgIH1cbiAgICAgIH0pLFxuXG4gICAgICBSRVZFUlRfSVRFTV9QUk9DRVNTSU5HOiBnZXRJdGVtQnlRdWVyeUZyb21TdGF0ZShzdGF0ZSwgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICBpdGVtXG4gICAgICAgICAgLnJldmVydChcbiAgICAgICAgICAgIGNyZWF0ZVJldmVydEZ1bmN0aW9uKFxuICAgICAgICAgICAgICBzdGF0ZS5vcHRpb25zLnNlcnZlci51cmwsXG4gICAgICAgICAgICAgIHN0YXRlLm9wdGlvbnMuc2VydmVyLnJldmVydFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIHF1ZXJ5KCdHRVRfRk9SQ0VfUkVWRVJUJylcbiAgICAgICAgICApXG4gICAgICAgICAgLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgc2hvdWxkUmVtb3ZlID0gc3RhdGUub3B0aW9ucy5pbnN0YW50VXBsb2FkIHx8IGlzTW9ja0l0ZW0oaXRlbSk7XG4gICAgICAgICAgICBpZiAoc2hvdWxkUmVtb3ZlKSB7XG4gICAgICAgICAgICAgIGRpc3BhdGNoKCdSRU1PVkVfSVRFTScsIHsgcXVlcnk6IGl0ZW0uaWQgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24oKSB7fSk7XG4gICAgICB9KSxcblxuICAgICAgU0VUX09QVElPTlM6IGZ1bmN0aW9uIFNFVF9PUFRJT05TKF9yZWYxMSkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IF9yZWYxMS5vcHRpb25zO1xuICAgICAgICBmb3JpbihvcHRpb25zLCBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgICAgZGlzcGF0Y2goJ1NFVF8nICsgZnJvbUNhbWVscyhrZXksICdfJykudG9VcHBlckNhc2UoKSwge1xuICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgdmFyIGZvcm1hdEZpbGVuYW1lID0gZnVuY3Rpb24gZm9ybWF0RmlsZW5hbWUobmFtZSkge1xuICAgIHJldHVybiBuYW1lO1xuICB9O1xuXG4gIHZhciBjcmVhdGVFbGVtZW50JDEgPSBmdW5jdGlvbiBjcmVhdGVFbGVtZW50KHRhZ05hbWUpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcbiAgfTtcblxuICB2YXIgdGV4dCA9IGZ1bmN0aW9uIHRleHQobm9kZSwgdmFsdWUpIHtcbiAgICB2YXIgdGV4dE5vZGUgPSBub2RlLmNoaWxkTm9kZXNbMF07XG4gICAgaWYgKCF0ZXh0Tm9kZSkge1xuICAgICAgdGV4dE5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh2YWx1ZSk7XG4gICAgICBub2RlLmFwcGVuZENoaWxkKHRleHROb2RlKTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlICE9PSB0ZXh0Tm9kZS5ub2RlVmFsdWUpIHtcbiAgICAgIHRleHROb2RlLm5vZGVWYWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgfTtcblxuICB2YXIgcG9sYXJUb0NhcnRlc2lhbiA9IGZ1bmN0aW9uIHBvbGFyVG9DYXJ0ZXNpYW4oXG4gICAgY2VudGVyWCxcbiAgICBjZW50ZXJZLFxuICAgIHJhZGl1cyxcbiAgICBhbmdsZUluRGVncmVlc1xuICApIHtcbiAgICB2YXIgYW5nbGVJblJhZGlhbnMgPSAoKChhbmdsZUluRGVncmVlcyAlIDM2MCkgLSA5MCkgKiBNYXRoLlBJKSAvIDE4MC4wO1xuICAgIHJldHVybiB7XG4gICAgICB4OiBjZW50ZXJYICsgcmFkaXVzICogTWF0aC5jb3MoYW5nbGVJblJhZGlhbnMpLFxuICAgICAgeTogY2VudGVyWSArIHJhZGl1cyAqIE1hdGguc2luKGFuZ2xlSW5SYWRpYW5zKVxuICAgIH07XG4gIH07XG5cbiAgdmFyIGRlc2NyaWJlQXJjID0gZnVuY3Rpb24gZGVzY3JpYmVBcmMoXG4gICAgeCxcbiAgICB5LFxuICAgIHJhZGl1cyxcbiAgICBzdGFydEFuZ2xlLFxuICAgIGVuZEFuZ2xlLFxuICAgIGFyY1N3ZWVwXG4gICkge1xuICAgIHZhciBzdGFydCA9IHBvbGFyVG9DYXJ0ZXNpYW4oeCwgeSwgcmFkaXVzLCBlbmRBbmdsZSk7XG4gICAgdmFyIGVuZCA9IHBvbGFyVG9DYXJ0ZXNpYW4oeCwgeSwgcmFkaXVzLCBzdGFydEFuZ2xlKTtcbiAgICByZXR1cm4gW1xuICAgICAgJ00nLFxuICAgICAgc3RhcnQueCxcbiAgICAgIHN0YXJ0LnksXG4gICAgICAnQScsXG4gICAgICByYWRpdXMsXG4gICAgICByYWRpdXMsXG4gICAgICAwLFxuICAgICAgYXJjU3dlZXAsXG4gICAgICAwLFxuICAgICAgZW5kLngsXG4gICAgICBlbmQueVxuICAgIF0uam9pbignICcpO1xuICB9O1xuXG4gIHZhciBwZXJjZW50YWdlQXJjID0gZnVuY3Rpb24gcGVyY2VudGFnZUFyYyh4LCB5LCByYWRpdXMsIGZyb20sIHRvKSB7XG4gICAgdmFyIGFyY1N3ZWVwID0gMTtcbiAgICBpZiAodG8gPiBmcm9tICYmIHRvIC0gZnJvbSA8PSAwLjUpIHtcbiAgICAgIGFyY1N3ZWVwID0gMDtcbiAgICB9XG4gICAgaWYgKGZyb20gPiB0byAmJiBmcm9tIC0gdG8gPj0gMC41KSB7XG4gICAgICBhcmNTd2VlcCA9IDA7XG4gICAgfVxuICAgIHJldHVybiBkZXNjcmliZUFyYyhcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgcmFkaXVzLFxuICAgICAgTWF0aC5taW4oMC45OTk5LCBmcm9tKSAqIDM2MCxcbiAgICAgIE1hdGgubWluKDAuOTk5OSwgdG8pICogMzYwLFxuICAgICAgYXJjU3dlZXBcbiAgICApO1xuICB9O1xuXG4gIHZhciBjcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoX3JlZikge1xuICAgIHZhciByb290ID0gX3JlZi5yb290LFxuICAgICAgcHJvcHMgPSBfcmVmLnByb3BzO1xuICAgIC8vIHN0YXJ0IGF0IDBcbiAgICBwcm9wcy5zcGluID0gZmFsc2U7XG4gICAgcHJvcHMucHJvZ3Jlc3MgPSAwO1xuICAgIHByb3BzLm9wYWNpdHkgPSAwO1xuXG4gICAgLy8gc3ZnXG4gICAgdmFyIHN2ZyA9IGNyZWF0ZUVsZW1lbnQoJ3N2ZycpO1xuICAgIHJvb3QucmVmLnBhdGggPSBjcmVhdGVFbGVtZW50KCdwYXRoJywge1xuICAgICAgJ3N0cm9rZS13aWR0aCc6IDIsXG4gICAgICAnc3Ryb2tlLWxpbmVjYXAnOiAncm91bmQnXG4gICAgfSk7XG5cbiAgICBzdmcuYXBwZW5kQ2hpbGQocm9vdC5yZWYucGF0aCk7XG5cbiAgICByb290LnJlZi5zdmcgPSBzdmc7XG5cbiAgICByb290LmFwcGVuZENoaWxkKHN2Zyk7XG4gIH07XG5cbiAgdmFyIHdyaXRlID0gZnVuY3Rpb24gd3JpdGUoX3JlZjIpIHtcbiAgICB2YXIgcm9vdCA9IF9yZWYyLnJvb3QsXG4gICAgICBwcm9wcyA9IF9yZWYyLnByb3BzO1xuXG4gICAgaWYgKHByb3BzLm9wYWNpdHkgPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocHJvcHMuYWxpZ24pIHtcbiAgICAgIHJvb3QuZWxlbWVudC5kYXRhc2V0LmFsaWduID0gcHJvcHMuYWxpZ247XG4gICAgfVxuXG4gICAgLy8gZ2V0IHdpZHRoIG9mIHN0cm9rZVxuICAgIHZhciByaW5nU3Ryb2tlV2lkdGggPSBwYXJzZUludChhdHRyKHJvb3QucmVmLnBhdGgsICdzdHJva2Utd2lkdGgnKSwgMTApO1xuXG4gICAgLy8gY2FsY3VsYXRlIHNpemUgb2YgcmluZ1xuICAgIHZhciBzaXplID0gcm9vdC5yZWN0LmVsZW1lbnQud2lkdGggKiAwLjU7XG5cbiAgICAvLyByaW5nIHN0YXRlXG4gICAgdmFyIHJpbmdGcm9tID0gMDtcbiAgICB2YXIgcmluZ1RvID0gMDtcblxuICAgIC8vIG5vdyBpbiBidXN5IG1vZGVcbiAgICBpZiAocHJvcHMuc3Bpbikge1xuICAgICAgcmluZ0Zyb20gPSAwO1xuICAgICAgcmluZ1RvID0gMC41O1xuICAgIH0gZWxzZSB7XG4gICAgICByaW5nRnJvbSA9IDA7XG4gICAgICByaW5nVG8gPSBwcm9wcy5wcm9ncmVzcztcbiAgICB9XG5cbiAgICAvLyBnZXQgYXJjIHBhdGhcbiAgICB2YXIgY29vcmRpbmF0ZXMgPSBwZXJjZW50YWdlQXJjKFxuICAgICAgc2l6ZSxcbiAgICAgIHNpemUsXG4gICAgICBzaXplIC0gcmluZ1N0cm9rZVdpZHRoLFxuICAgICAgcmluZ0Zyb20sXG4gICAgICByaW5nVG9cbiAgICApO1xuXG4gICAgLy8gdXBkYXRlIHByb2dyZXNzIGJhclxuICAgIGF0dHIocm9vdC5yZWYucGF0aCwgJ2QnLCBjb29yZGluYXRlcyk7XG5cbiAgICAvLyBoaWRlIHdoaWxlIGNvbnRhaW5zIDAgdmFsdWVcbiAgICBhdHRyKFxuICAgICAgcm9vdC5yZWYucGF0aCxcbiAgICAgICdzdHJva2Utb3BhY2l0eScsXG4gICAgICBwcm9wcy5zcGluIHx8IHByb3BzLnByb2dyZXNzID4gMCA/IDEgOiAwXG4gICAgKTtcbiAgfTtcblxuICB2YXIgcHJvZ3Jlc3NJbmRpY2F0b3IgPSBjcmVhdGVWaWV3KHtcbiAgICB0YWc6ICdkaXYnLFxuICAgIG5hbWU6ICdwcm9ncmVzcy1pbmRpY2F0b3InLFxuICAgIGlnbm9yZVJlY3RVcGRhdGU6IHRydWUsXG4gICAgaWdub3JlUmVjdDogdHJ1ZSxcbiAgICBjcmVhdGU6IGNyZWF0ZSxcbiAgICB3cml0ZTogd3JpdGUsXG4gICAgbWl4aW5zOiB7XG4gICAgICBhcGlzOiBbJ3Byb2dyZXNzJywgJ3NwaW4nLCAnYWxpZ24nXSxcbiAgICAgIHN0eWxlczogWydvcGFjaXR5J10sXG4gICAgICBhbmltYXRpb25zOiB7XG4gICAgICAgIG9wYWNpdHk6IHsgdHlwZTogJ3R3ZWVuJywgZHVyYXRpb246IDUwMCB9LFxuICAgICAgICBwcm9ncmVzczoge1xuICAgICAgICAgIHR5cGU6ICdzcHJpbmcnLFxuICAgICAgICAgIHN0aWZmbmVzczogMC45NSxcbiAgICAgICAgICBkYW1waW5nOiAwLjY1LFxuICAgICAgICAgIG1hc3M6IDEwXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHZhciBjcmVhdGUkMSA9IGZ1bmN0aW9uIGNyZWF0ZShfcmVmKSB7XG4gICAgdmFyIHJvb3QgPSBfcmVmLnJvb3QsXG4gICAgICBwcm9wcyA9IF9yZWYucHJvcHM7XG4gICAgcm9vdC5lbGVtZW50LmlubmVySFRNTCA9XG4gICAgICAocHJvcHMuaWNvbiB8fCAnJykgKyAoJzxzcGFuPicgKyBwcm9wcy5sYWJlbCArICc8L3NwYW4+Jyk7XG5cbiAgICBwcm9wcy5pc0Rpc2FibGVkID0gZmFsc2U7XG4gIH07XG5cbiAgdmFyIHdyaXRlJDEgPSBmdW5jdGlvbiB3cml0ZShfcmVmMikge1xuICAgIHZhciByb290ID0gX3JlZjIucm9vdCxcbiAgICAgIHByb3BzID0gX3JlZjIucHJvcHM7XG4gICAgdmFyIGlzRGlzYWJsZWQgPSBwcm9wcy5pc0Rpc2FibGVkO1xuICAgIHZhciBzaG91bGREaXNhYmxlID0gcm9vdC5xdWVyeSgnR0VUX0RJU0FCTEVEJykgfHwgcHJvcHMub3BhY2l0eSA9PT0gMDtcblxuICAgIGlmIChzaG91bGREaXNhYmxlICYmICFpc0Rpc2FibGVkKSB7XG4gICAgICBwcm9wcy5pc0Rpc2FibGVkID0gdHJ1ZTtcbiAgICAgIGF0dHIocm9vdC5lbGVtZW50LCAnZGlzYWJsZWQnLCAnZGlzYWJsZWQnKTtcbiAgICB9IGVsc2UgaWYgKCFzaG91bGREaXNhYmxlICYmIGlzRGlzYWJsZWQpIHtcbiAgICAgIHByb3BzLmlzRGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgIHJvb3QuZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2Rpc2FibGVkJyk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBmaWxlQWN0aW9uQnV0dG9uID0gY3JlYXRlVmlldyh7XG4gICAgdGFnOiAnYnV0dG9uJyxcbiAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICB0eXBlOiAnYnV0dG9uJ1xuICAgIH0sXG5cbiAgICBpZ25vcmVSZWN0OiB0cnVlLFxuICAgIGlnbm9yZVJlY3RVcGRhdGU6IHRydWUsXG4gICAgbmFtZTogJ2ZpbGUtYWN0aW9uLWJ1dHRvbicsXG4gICAgbWl4aW5zOiB7XG4gICAgICBhcGlzOiBbJ2xhYmVsJ10sXG4gICAgICBzdHlsZXM6IFsndHJhbnNsYXRlWCcsICd0cmFuc2xhdGVZJywgJ3NjYWxlWCcsICdzY2FsZVknLCAnb3BhY2l0eSddLFxuICAgICAgYW5pbWF0aW9uczoge1xuICAgICAgICBzY2FsZVg6ICdzcHJpbmcnLFxuICAgICAgICBzY2FsZVk6ICdzcHJpbmcnLFxuICAgICAgICB0cmFuc2xhdGVYOiAnc3ByaW5nJyxcbiAgICAgICAgdHJhbnNsYXRlWTogJ3NwcmluZycsXG4gICAgICAgIG9wYWNpdHk6IHsgdHlwZTogJ3R3ZWVuJywgZHVyYXRpb246IDI1MCB9XG4gICAgICB9LFxuXG4gICAgICBsaXN0ZW5lcnM6IHRydWVcbiAgICB9LFxuXG4gICAgY3JlYXRlOiBjcmVhdGUkMSxcbiAgICB3cml0ZTogd3JpdGUkMVxuICB9KTtcblxuICB2YXIgdG9OYXR1cmFsRmlsZVNpemUgPSBmdW5jdGlvbiB0b05hdHVyYWxGaWxlU2l6ZShieXRlcykge1xuICAgIHZhciBkZWNpbWFsU2VwYXJhdG9yID1cbiAgICAgIGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJy4nO1xuICAgIHZhciBiYXNlID1cbiAgICAgIGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMTAwMDtcbiAgICAvLyBubyBuZWdhdGl2ZSBieXRlIHNpemVzXG4gICAgYnl0ZXMgPSBNYXRoLnJvdW5kKE1hdGguYWJzKGJ5dGVzKSk7XG5cbiAgICB2YXIgS0IgPSBiYXNlO1xuICAgIHZhciBNQiA9IGJhc2UgKiBiYXNlO1xuICAgIHZhciBHQiA9IGJhc2UgKiBiYXNlICogYmFzZTtcblxuICAgIC8vIGp1c3QgYnl0ZXNcbiAgICBpZiAoYnl0ZXMgPCBLQikge1xuICAgICAgcmV0dXJuIGJ5dGVzICsgJyBieXRlcyc7XG4gICAgfVxuXG4gICAgLy8ga2lsb2J5dGVzXG4gICAgaWYgKGJ5dGVzIDwgTUIpIHtcbiAgICAgIHJldHVybiBNYXRoLmZsb29yKGJ5dGVzIC8gS0IpICsgJyBLQic7XG4gICAgfVxuXG4gICAgLy8gbWVnYWJ5dGVzXG4gICAgaWYgKGJ5dGVzIDwgR0IpIHtcbiAgICAgIHJldHVybiByZW1vdmVEZWNpbWFsc1doZW5aZXJvKGJ5dGVzIC8gTUIsIDEsIGRlY2ltYWxTZXBhcmF0b3IpICsgJyBNQic7XG4gICAgfVxuXG4gICAgLy8gZ2lnYWJ5dGVzXG4gICAgcmV0dXJuIHJlbW92ZURlY2ltYWxzV2hlblplcm8oYnl0ZXMgLyBHQiwgMiwgZGVjaW1hbFNlcGFyYXRvcikgKyAnIEdCJztcbiAgfTtcblxuICB2YXIgcmVtb3ZlRGVjaW1hbHNXaGVuWmVybyA9IGZ1bmN0aW9uIHJlbW92ZURlY2ltYWxzV2hlblplcm8oXG4gICAgdmFsdWUsXG4gICAgZGVjaW1hbENvdW50LFxuICAgIHNlcGFyYXRvclxuICApIHtcbiAgICByZXR1cm4gdmFsdWVcbiAgICAgIC50b0ZpeGVkKGRlY2ltYWxDb3VudClcbiAgICAgIC5zcGxpdCgnLicpXG4gICAgICAuZmlsdGVyKGZ1bmN0aW9uKHBhcnQpIHtcbiAgICAgICAgcmV0dXJuIHBhcnQgIT09ICcwJztcbiAgICAgIH0pXG4gICAgICAuam9pbihzZXBhcmF0b3IpO1xuICB9O1xuXG4gIHZhciBjcmVhdGUkMiA9IGZ1bmN0aW9uIGNyZWF0ZShfcmVmKSB7XG4gICAgdmFyIHJvb3QgPSBfcmVmLnJvb3QsXG4gICAgICBwcm9wcyA9IF9yZWYucHJvcHM7XG4gICAgLy8gZmlsZW5hbWVcbiAgICB2YXIgZmlsZU5hbWUgPSBjcmVhdGVFbGVtZW50JDEoJ3NwYW4nKTtcbiAgICBmaWxlTmFtZS5jbGFzc05hbWUgPSAnZmlsZXBvbmQtLWZpbGUtaW5mby1tYWluJztcbiAgICAvLyBoaWRlIGZvciBzY3JlZW5yZWFkZXJzXG4gICAgLy8gdGhlIGZpbGUgaXMgY29udGFpbmVkIGluIGEgZmllbGRzZXQgd2l0aCBsZWdlbmQgdGhhdCBjb250YWlucyB0aGUgZmlsZW5hbWVcbiAgICAvLyBubyBuZWVkIHRvIHJlYWQgaXQgdHdpY2VcbiAgICBhdHRyKGZpbGVOYW1lLCAnYXJpYS1oaWRkZW4nLCAndHJ1ZScpO1xuICAgIHJvb3QuYXBwZW5kQ2hpbGQoZmlsZU5hbWUpO1xuICAgIHJvb3QucmVmLmZpbGVOYW1lID0gZmlsZU5hbWU7XG5cbiAgICAvLyBmaWxlc2l6ZVxuICAgIHZhciBmaWxlU2l6ZSA9IGNyZWF0ZUVsZW1lbnQkMSgnc3BhbicpO1xuICAgIGZpbGVTaXplLmNsYXNzTmFtZSA9ICdmaWxlcG9uZC0tZmlsZS1pbmZvLXN1Yic7XG4gICAgcm9vdC5hcHBlbmRDaGlsZChmaWxlU2l6ZSk7XG4gICAgcm9vdC5yZWYuZmlsZVNpemUgPSBmaWxlU2l6ZTtcblxuICAgIC8vIHNldCBpbml0aWFsIHZhbHVlc1xuICAgIHRleHQoZmlsZVNpemUsIHJvb3QucXVlcnkoJ0dFVF9MQUJFTF9GSUxFX1dBSVRJTkdfRk9SX1NJWkUnKSk7XG4gICAgdGV4dChmaWxlTmFtZSwgZm9ybWF0RmlsZW5hbWUocm9vdC5xdWVyeSgnR0VUX0lURU1fTkFNRScsIHByb3BzLmlkKSkpO1xuICB9O1xuXG4gIHZhciB1cGRhdGVGaWxlID0gZnVuY3Rpb24gdXBkYXRlRmlsZShfcmVmMikge1xuICAgIHZhciByb290ID0gX3JlZjIucm9vdCxcbiAgICAgIHByb3BzID0gX3JlZjIucHJvcHM7XG4gICAgdGV4dChcbiAgICAgIHJvb3QucmVmLmZpbGVTaXplLFxuICAgICAgdG9OYXR1cmFsRmlsZVNpemUoXG4gICAgICAgIHJvb3QucXVlcnkoJ0dFVF9JVEVNX1NJWkUnLCBwcm9wcy5pZCksXG4gICAgICAgICcuJyxcbiAgICAgICAgcm9vdC5xdWVyeSgnR0VUX0ZJTEVfU0laRV9CQVNFJylcbiAgICAgIClcbiAgICApO1xuXG4gICAgdGV4dChcbiAgICAgIHJvb3QucmVmLmZpbGVOYW1lLFxuICAgICAgZm9ybWF0RmlsZW5hbWUocm9vdC5xdWVyeSgnR0VUX0lURU1fTkFNRScsIHByb3BzLmlkKSlcbiAgICApO1xuICB9O1xuXG4gIHZhciB1cGRhdGVGaWxlU2l6ZU9uRXJyb3IgPSBmdW5jdGlvbiB1cGRhdGVGaWxlU2l6ZU9uRXJyb3IoX3JlZjMpIHtcbiAgICB2YXIgcm9vdCA9IF9yZWYzLnJvb3QsXG4gICAgICBwcm9wcyA9IF9yZWYzLnByb3BzO1xuICAgIC8vIGlmIHNpemUgaXMgYXZhaWxhYmxlIGRvbid0IGZhbGxiYWNrIHRvIHVua25vd24gc2l6ZSBtZXNzYWdlXG4gICAgaWYgKGlzSW50KHJvb3QucXVlcnkoJ0dFVF9JVEVNX1NJWkUnLCBwcm9wcy5pZCkpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGV4dChyb290LnJlZi5maWxlU2l6ZSwgcm9vdC5xdWVyeSgnR0VUX0xBQkVMX0ZJTEVfU0laRV9OT1RfQVZBSUxBQkxFJykpO1xuICB9O1xuXG4gIHZhciBmaWxlSW5mbyA9IGNyZWF0ZVZpZXcoe1xuICAgIG5hbWU6ICdmaWxlLWluZm8nLFxuICAgIGlnbm9yZVJlY3Q6IHRydWUsXG4gICAgaWdub3JlUmVjdFVwZGF0ZTogdHJ1ZSxcbiAgICB3cml0ZTogY3JlYXRlUm91dGUoe1xuICAgICAgRElEX0xPQURfSVRFTTogdXBkYXRlRmlsZSxcbiAgICAgIERJRF9VUERBVEVfSVRFTV9NRVRBOiB1cGRhdGVGaWxlLFxuICAgICAgRElEX1RIUk9XX0lURU1fTE9BRF9FUlJPUjogdXBkYXRlRmlsZVNpemVPbkVycm9yLFxuICAgICAgRElEX1RIUk9XX0lURU1fSU5WQUxJRDogdXBkYXRlRmlsZVNpemVPbkVycm9yXG4gICAgfSksXG5cbiAgICBkaWRDcmVhdGVWaWV3OiBmdW5jdGlvbiBkaWRDcmVhdGVWaWV3KHJvb3QpIHtcbiAgICAgIGFwcGx5RmlsdGVycygnQ1JFQVRFX1ZJRVcnLCBPYmplY3QuYXNzaWduKHt9LCByb290LCB7IHZpZXc6IHJvb3QgfSkpO1xuICAgIH0sXG4gICAgY3JlYXRlOiBjcmVhdGUkMixcbiAgICBtaXhpbnM6IHtcbiAgICAgIHN0eWxlczogWyd0cmFuc2xhdGVYJywgJ3RyYW5zbGF0ZVknXSxcbiAgICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgICAgdHJhbnNsYXRlWDogJ3NwcmluZycsXG4gICAgICAgIHRyYW5zbGF0ZVk6ICdzcHJpbmcnXG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICB2YXIgdG9QZXJjZW50YWdlID0gZnVuY3Rpb24gdG9QZXJjZW50YWdlKHZhbHVlKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQodmFsdWUgKiAxMDApO1xuICB9O1xuXG4gIHZhciBjcmVhdGUkMyA9IGZ1bmN0aW9uIGNyZWF0ZShfcmVmKSB7XG4gICAgdmFyIHJvb3QgPSBfcmVmLnJvb3Q7XG5cbiAgICAvLyBtYWluIHN0YXR1c1xuICAgIHZhciBtYWluID0gY3JlYXRlRWxlbWVudCQxKCdzcGFuJyk7XG4gICAgbWFpbi5jbGFzc05hbWUgPSAnZmlsZXBvbmQtLWZpbGUtc3RhdHVzLW1haW4nO1xuICAgIHJvb3QuYXBwZW5kQ2hpbGQobWFpbik7XG4gICAgcm9vdC5yZWYubWFpbiA9IG1haW47XG5cbiAgICAvLyBzdWIgc3RhdHVzXG4gICAgdmFyIHN1YiA9IGNyZWF0ZUVsZW1lbnQkMSgnc3BhbicpO1xuICAgIHN1Yi5jbGFzc05hbWUgPSAnZmlsZXBvbmQtLWZpbGUtc3RhdHVzLXN1Yic7XG4gICAgcm9vdC5hcHBlbmRDaGlsZChzdWIpO1xuICAgIHJvb3QucmVmLnN1YiA9IHN1YjtcblxuICAgIGRpZFNldEl0ZW1Mb2FkUHJvZ3Jlc3MoeyByb290OiByb290LCBhY3Rpb246IHsgcHJvZ3Jlc3M6IG51bGwgfSB9KTtcbiAgfTtcblxuICB2YXIgZGlkU2V0SXRlbUxvYWRQcm9ncmVzcyA9IGZ1bmN0aW9uIGRpZFNldEl0ZW1Mb2FkUHJvZ3Jlc3MoX3JlZjIpIHtcbiAgICB2YXIgcm9vdCA9IF9yZWYyLnJvb3QsXG4gICAgICBhY3Rpb24gPSBfcmVmMi5hY3Rpb247XG4gICAgdmFyIHRpdGxlID1cbiAgICAgIGFjdGlvbi5wcm9ncmVzcyA9PT0gbnVsbFxuICAgICAgICA/IHJvb3QucXVlcnkoJ0dFVF9MQUJFTF9GSUxFX0xPQURJTkcnKVxuICAgICAgICA6IHJvb3QucXVlcnkoJ0dFVF9MQUJFTF9GSUxFX0xPQURJTkcnKSArXG4gICAgICAgICAgJyAnICtcbiAgICAgICAgICB0b1BlcmNlbnRhZ2UoYWN0aW9uLnByb2dyZXNzKSArXG4gICAgICAgICAgJyUnO1xuXG4gICAgdGV4dChyb290LnJlZi5tYWluLCB0aXRsZSk7XG4gICAgdGV4dChyb290LnJlZi5zdWIsIHJvb3QucXVlcnkoJ0dFVF9MQUJFTF9UQVBfVE9fQ0FOQ0VMJykpO1xuICB9O1xuXG4gIHZhciBkaWRTZXRJdGVtUHJvY2Vzc1Byb2dyZXNzID0gZnVuY3Rpb24gZGlkU2V0SXRlbVByb2Nlc3NQcm9ncmVzcyhfcmVmMykge1xuICAgIHZhciByb290ID0gX3JlZjMucm9vdCxcbiAgICAgIGFjdGlvbiA9IF9yZWYzLmFjdGlvbjtcbiAgICB2YXIgdGl0bGUgPVxuICAgICAgYWN0aW9uLnByb2dyZXNzID09PSBudWxsXG4gICAgICAgID8gcm9vdC5xdWVyeSgnR0VUX0xBQkVMX0ZJTEVfUFJPQ0VTU0lORycpXG4gICAgICAgIDogcm9vdC5xdWVyeSgnR0VUX0xBQkVMX0ZJTEVfUFJPQ0VTU0lORycpICtcbiAgICAgICAgICAnICcgK1xuICAgICAgICAgIHRvUGVyY2VudGFnZShhY3Rpb24ucHJvZ3Jlc3MpICtcbiAgICAgICAgICAnJSc7XG5cbiAgICB0ZXh0KHJvb3QucmVmLm1haW4sIHRpdGxlKTtcbiAgICB0ZXh0KHJvb3QucmVmLnN1Yiwgcm9vdC5xdWVyeSgnR0VUX0xBQkVMX1RBUF9UT19DQU5DRUwnKSk7XG4gIH07XG5cbiAgdmFyIGRpZFJlcXVlc3RJdGVtUHJvY2Vzc2luZyA9IGZ1bmN0aW9uIGRpZFJlcXVlc3RJdGVtUHJvY2Vzc2luZyhfcmVmNCkge1xuICAgIHZhciByb290ID0gX3JlZjQucm9vdDtcbiAgICB0ZXh0KHJvb3QucmVmLm1haW4sIHJvb3QucXVlcnkoJ0dFVF9MQUJFTF9GSUxFX1BST0NFU1NJTkcnKSk7XG4gICAgdGV4dChyb290LnJlZi5zdWIsIHJvb3QucXVlcnkoJ0dFVF9MQUJFTF9UQVBfVE9fQ0FOQ0VMJykpO1xuICB9O1xuXG4gIHZhciBkaWRBYm9ydEl0ZW1Qcm9jZXNzaW5nID0gZnVuY3Rpb24gZGlkQWJvcnRJdGVtUHJvY2Vzc2luZyhfcmVmNSkge1xuICAgIHZhciByb290ID0gX3JlZjUucm9vdDtcbiAgICB0ZXh0KHJvb3QucmVmLm1haW4sIHJvb3QucXVlcnkoJ0dFVF9MQUJFTF9GSUxFX1BST0NFU1NJTkdfQUJPUlRFRCcpKTtcbiAgICB0ZXh0KHJvb3QucmVmLnN1Yiwgcm9vdC5xdWVyeSgnR0VUX0xBQkVMX1RBUF9UT19SRVRSWScpKTtcbiAgfTtcblxuICB2YXIgZGlkQ29tcGxldGVJdGVtUHJvY2Vzc2luZyA9IGZ1bmN0aW9uIGRpZENvbXBsZXRlSXRlbVByb2Nlc3NpbmcoX3JlZjYpIHtcbiAgICB2YXIgcm9vdCA9IF9yZWY2LnJvb3Q7XG4gICAgdGV4dChyb290LnJlZi5tYWluLCByb290LnF1ZXJ5KCdHRVRfTEFCRUxfRklMRV9QUk9DRVNTSU5HX0NPTVBMRVRFJykpO1xuICAgIHRleHQocm9vdC5yZWYuc3ViLCByb290LnF1ZXJ5KCdHRVRfTEFCRUxfVEFQX1RPX1VORE8nKSk7XG4gIH07XG5cbiAgdmFyIGNsZWFyID0gZnVuY3Rpb24gY2xlYXIoX3JlZjcpIHtcbiAgICB2YXIgcm9vdCA9IF9yZWY3LnJvb3Q7XG4gICAgdGV4dChyb290LnJlZi5tYWluLCAnJyk7XG4gICAgdGV4dChyb290LnJlZi5zdWIsICcnKTtcbiAgfTtcblxuICB2YXIgZXJyb3IgPSBmdW5jdGlvbiBlcnJvcihfcmVmOCkge1xuICAgIHZhciByb290ID0gX3JlZjgucm9vdCxcbiAgICAgIGFjdGlvbiA9IF9yZWY4LmFjdGlvbjtcbiAgICB0ZXh0KHJvb3QucmVmLm1haW4sIGFjdGlvbi5zdGF0dXMubWFpbik7XG4gICAgdGV4dChyb290LnJlZi5zdWIsIGFjdGlvbi5zdGF0dXMuc3ViKTtcbiAgfTtcblxuICB2YXIgZmlsZVN0YXR1cyA9IGNyZWF0ZVZpZXcoe1xuICAgIG5hbWU6ICdmaWxlLXN0YXR1cycsXG4gICAgaWdub3JlUmVjdDogdHJ1ZSxcbiAgICBpZ25vcmVSZWN0VXBkYXRlOiB0cnVlLFxuICAgIHdyaXRlOiBjcmVhdGVSb3V0ZSh7XG4gICAgICBESURfTE9BRF9JVEVNOiBjbGVhcixcbiAgICAgIERJRF9SRVZFUlRfSVRFTV9QUk9DRVNTSU5HOiBjbGVhcixcbiAgICAgIERJRF9SRVFVRVNUX0lURU1fUFJPQ0VTU0lORzogZGlkUmVxdWVzdEl0ZW1Qcm9jZXNzaW5nLFxuICAgICAgRElEX0FCT1JUX0lURU1fUFJPQ0VTU0lORzogZGlkQWJvcnRJdGVtUHJvY2Vzc2luZyxcbiAgICAgIERJRF9DT01QTEVURV9JVEVNX1BST0NFU1NJTkc6IGRpZENvbXBsZXRlSXRlbVByb2Nlc3NpbmcsXG4gICAgICBESURfVVBEQVRFX0lURU1fUFJPQ0VTU19QUk9HUkVTUzogZGlkU2V0SXRlbVByb2Nlc3NQcm9ncmVzcyxcbiAgICAgIERJRF9VUERBVEVfSVRFTV9MT0FEX1BST0dSRVNTOiBkaWRTZXRJdGVtTG9hZFByb2dyZXNzLFxuICAgICAgRElEX1RIUk9XX0lURU1fTE9BRF9FUlJPUjogZXJyb3IsXG4gICAgICBESURfVEhST1dfSVRFTV9JTlZBTElEOiBlcnJvcixcbiAgICAgIERJRF9USFJPV19JVEVNX1BST0NFU1NJTkdfRVJST1I6IGVycm9yLFxuICAgICAgRElEX1RIUk9XX0lURU1fUFJPQ0VTU0lOR19SRVZFUlRfRVJST1I6IGVycm9yLFxuICAgICAgRElEX1RIUk9XX0lURU1fUkVNT1ZFX0VSUk9SOiBlcnJvclxuICAgIH0pLFxuXG4gICAgZGlkQ3JlYXRlVmlldzogZnVuY3Rpb24gZGlkQ3JlYXRlVmlldyhyb290KSB7XG4gICAgICBhcHBseUZpbHRlcnMoJ0NSRUFURV9WSUVXJywgT2JqZWN0LmFzc2lnbih7fSwgcm9vdCwgeyB2aWV3OiByb290IH0pKTtcbiAgICB9LFxuICAgIGNyZWF0ZTogY3JlYXRlJDMsXG4gICAgbWl4aW5zOiB7XG4gICAgICBzdHlsZXM6IFsndHJhbnNsYXRlWCcsICd0cmFuc2xhdGVZJywgJ29wYWNpdHknXSxcbiAgICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgICAgb3BhY2l0eTogeyB0eXBlOiAndHdlZW4nLCBkdXJhdGlvbjogMjUwIH0sXG4gICAgICAgIHRyYW5zbGF0ZVg6ICdzcHJpbmcnLFxuICAgICAgICB0cmFuc2xhdGVZOiAnc3ByaW5nJ1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIEJ1dHRvbiBkZWZpbml0aW9ucyBmb3IgdGhlIGZpbGUgdmlld1xuICAgKi9cblxuICB2YXIgQnV0dG9ucyA9IHtcbiAgICBBYm9ydEl0ZW1Mb2FkOiB7XG4gICAgICBsYWJlbDogJ0dFVF9MQUJFTF9CVVRUT05fQUJPUlRfSVRFTV9MT0FEJyxcbiAgICAgIGFjdGlvbjogJ0FCT1JUX0lURU1fTE9BRCcsXG4gICAgICBjbGFzc05hbWU6ICdmaWxlcG9uZC0tYWN0aW9uLWFib3J0LWl0ZW0tbG9hZCcsXG4gICAgICBhbGlnbjogJ0xPQURfSU5ESUNBVE9SX1BPU0lUSU9OJyAvLyByaWdodFxuICAgIH0sXG4gICAgUmV0cnlJdGVtTG9hZDoge1xuICAgICAgbGFiZWw6ICdHRVRfTEFCRUxfQlVUVE9OX1JFVFJZX0lURU1fTE9BRCcsXG4gICAgICBhY3Rpb246ICdSRVRSWV9JVEVNX0xPQUQnLFxuICAgICAgaWNvbjogJ0dFVF9JQ09OX1JFVFJZJyxcbiAgICAgIGNsYXNzTmFtZTogJ2ZpbGVwb25kLS1hY3Rpb24tcmV0cnktaXRlbS1sb2FkJyxcbiAgICAgIGFsaWduOiAnQlVUVE9OX1BST0NFU1NfSVRFTV9QT1NJVElPTicgLy8gcmlnaHRcbiAgICB9LFxuICAgIFJlbW92ZUl0ZW06IHtcbiAgICAgIGxhYmVsOiAnR0VUX0xBQkVMX0JVVFRPTl9SRU1PVkVfSVRFTScsXG4gICAgICBhY3Rpb246ICdSRVFVRVNUX1JFTU9WRV9JVEVNJyxcbiAgICAgIGljb246ICdHRVRfSUNPTl9SRU1PVkUnLFxuICAgICAgY2xhc3NOYW1lOiAnZmlsZXBvbmQtLWFjdGlvbi1yZW1vdmUtaXRlbScsXG4gICAgICBhbGlnbjogJ0JVVFRPTl9SRU1PVkVfSVRFTV9QT1NJVElPTicgLy8gbGVmdFxuICAgIH0sXG4gICAgUHJvY2Vzc0l0ZW06IHtcbiAgICAgIGxhYmVsOiAnR0VUX0xBQkVMX0JVVFRPTl9QUk9DRVNTX0lURU0nLFxuICAgICAgYWN0aW9uOiAnUkVRVUVTVF9JVEVNX1BST0NFU1NJTkcnLFxuICAgICAgaWNvbjogJ0dFVF9JQ09OX1BST0NFU1MnLFxuICAgICAgY2xhc3NOYW1lOiAnZmlsZXBvbmQtLWFjdGlvbi1wcm9jZXNzLWl0ZW0nLFxuICAgICAgYWxpZ246ICdCVVRUT05fUFJPQ0VTU19JVEVNX1BPU0lUSU9OJyAvLyByaWdodFxuICAgIH0sXG4gICAgQWJvcnRJdGVtUHJvY2Vzc2luZzoge1xuICAgICAgbGFiZWw6ICdHRVRfTEFCRUxfQlVUVE9OX0FCT1JUX0lURU1fUFJPQ0VTU0lORycsXG4gICAgICBhY3Rpb246ICdBQk9SVF9JVEVNX1BST0NFU1NJTkcnLFxuICAgICAgY2xhc3NOYW1lOiAnZmlsZXBvbmQtLWFjdGlvbi1hYm9ydC1pdGVtLXByb2Nlc3NpbmcnLFxuICAgICAgYWxpZ246ICdCVVRUT05fUFJPQ0VTU19JVEVNX1BPU0lUSU9OJyAvLyByaWdodFxuICAgIH0sXG4gICAgUmV0cnlJdGVtUHJvY2Vzc2luZzoge1xuICAgICAgbGFiZWw6ICdHRVRfTEFCRUxfQlVUVE9OX1JFVFJZX0lURU1fUFJPQ0VTU0lORycsXG4gICAgICBhY3Rpb246ICdSRVRSWV9JVEVNX1BST0NFU1NJTkcnLFxuICAgICAgaWNvbjogJ0dFVF9JQ09OX1JFVFJZJyxcbiAgICAgIGNsYXNzTmFtZTogJ2ZpbGVwb25kLS1hY3Rpb24tcmV0cnktaXRlbS1wcm9jZXNzaW5nJyxcbiAgICAgIGFsaWduOiAnQlVUVE9OX1BST0NFU1NfSVRFTV9QT1NJVElPTicgLy8gcmlnaHRcbiAgICB9LFxuICAgIFJldmVydEl0ZW1Qcm9jZXNzaW5nOiB7XG4gICAgICBsYWJlbDogJ0dFVF9MQUJFTF9CVVRUT05fVU5ET19JVEVNX1BST0NFU1NJTkcnLFxuICAgICAgYWN0aW9uOiAnUkVRVUVTVF9SRVZFUlRfSVRFTV9QUk9DRVNTSU5HJyxcbiAgICAgIGljb246ICdHRVRfSUNPTl9VTkRPJyxcbiAgICAgIGNsYXNzTmFtZTogJ2ZpbGVwb25kLS1hY3Rpb24tcmV2ZXJ0LWl0ZW0tcHJvY2Vzc2luZycsXG4gICAgICBhbGlnbjogJ0JVVFRPTl9QUk9DRVNTX0lURU1fUE9TSVRJT04nIC8vIHJpZ2h0XG4gICAgfVxuICB9O1xuXG4gIC8vIG1ha2UgYSBsaXN0IG9mIGJ1dHRvbnMsIHdlIGNhbiB0aGVuIHJlbW92ZSBidXR0b25zIGZyb20gdGhpcyBsaXN0IGlmIHRoZXkncmUgZGlzYWJsZWRcbiAgdmFyIEJ1dHRvbktleXMgPSBbXTtcbiAgZm9yaW4oQnV0dG9ucywgZnVuY3Rpb24oa2V5KSB7XG4gICAgQnV0dG9uS2V5cy5wdXNoKGtleSk7XG4gIH0pO1xuXG4gIHZhciBjYWxjdWxhdGVGaWxlSW5mb09mZnNldCA9IGZ1bmN0aW9uIGNhbGN1bGF0ZUZpbGVJbmZvT2Zmc2V0KHJvb3QpIHtcbiAgICB2YXIgYnV0dG9uUmVjdCA9IHJvb3QucmVmLmJ1dHRvblJlbW92ZUl0ZW0ucmVjdC5lbGVtZW50O1xuICAgIHJldHVybiBidXR0b25SZWN0LmhpZGRlbiA/IG51bGwgOiBidXR0b25SZWN0LndpZHRoICsgYnV0dG9uUmVjdC5sZWZ0O1xuICB9O1xuXG4gIHZhciBjYWxjdWxhdGVCdXR0b25XaWR0aCA9IGZ1bmN0aW9uIGNhbGN1bGF0ZUJ1dHRvbldpZHRoKHJvb3QpIHtcbiAgICB2YXIgYnV0dG9uUmVjdCA9IHJvb3QucmVmLmJ1dHRvbkFib3J0SXRlbUxvYWQucmVjdC5lbGVtZW50O1xuICAgIHJldHVybiBidXR0b25SZWN0LndpZHRoO1xuICB9O1xuXG4gIC8vIEZvcmNlIG9uIGZ1bGwgcGl4ZWxzIHNvIHRleHQgc3RheXMgY3JpcHNcbiAgdmFyIGNhbGN1bGF0ZUZpbGVWZXJ0aWNhbENlbnRlck9mZnNldCA9IGZ1bmN0aW9uIGNhbGN1bGF0ZUZpbGVWZXJ0aWNhbENlbnRlck9mZnNldChcbiAgICByb290XG4gICkge1xuICAgIHJldHVybiBNYXRoLmZsb29yKHJvb3QucmVmLmJ1dHRvblJlbW92ZUl0ZW0ucmVjdC5lbGVtZW50LmhlaWdodCAvIDQpO1xuICB9O1xuICB2YXIgY2FsY3VsYXRlRmlsZUhvcml6b250YWxDZW50ZXJPZmZzZXQgPSBmdW5jdGlvbiBjYWxjdWxhdGVGaWxlSG9yaXpvbnRhbENlbnRlck9mZnNldChcbiAgICByb290XG4gICkge1xuICAgIHJldHVybiBNYXRoLmZsb29yKHJvb3QucmVmLmJ1dHRvblJlbW92ZUl0ZW0ucmVjdC5lbGVtZW50LmxlZnQgLyAyKTtcbiAgfTtcblxuICB2YXIgZ2V0TG9hZEluZGljYXRvckFsaWdubWVudCA9IGZ1bmN0aW9uIGdldExvYWRJbmRpY2F0b3JBbGlnbm1lbnQocm9vdCkge1xuICAgIHJldHVybiByb290LnF1ZXJ5KCdHRVRfU1RZTEVfTE9BRF9JTkRJQ0FUT1JfUE9TSVRJT04nKTtcbiAgfTtcbiAgdmFyIGdldFByb2Nlc3NJbmRpY2F0b3JBbGlnbm1lbnQgPSBmdW5jdGlvbiBnZXRQcm9jZXNzSW5kaWNhdG9yQWxpZ25tZW50KFxuICAgIHJvb3RcbiAgKSB7XG4gICAgcmV0dXJuIHJvb3QucXVlcnkoJ0dFVF9TVFlMRV9QUk9HUkVTU19JTkRJQ0FUT1JfUE9TSVRJT04nKTtcbiAgfTtcbiAgdmFyIGdldFJlbW92ZUluZGljYXRvckFsaWdtZW50ID0gZnVuY3Rpb24gZ2V0UmVtb3ZlSW5kaWNhdG9yQWxpZ21lbnQocm9vdCkge1xuICAgIHJldHVybiByb290LnF1ZXJ5KCdHRVRfU1RZTEVfQlVUVE9OX1JFTU9WRV9JVEVNX1BPU0lUSU9OJyk7XG4gIH07XG5cbiAgdmFyIERlZmF1bHRTdHlsZSA9IHtcbiAgICBidXR0b25BYm9ydEl0ZW1Mb2FkOiB7IG9wYWNpdHk6IDAgfSxcbiAgICBidXR0b25SZXRyeUl0ZW1Mb2FkOiB7IG9wYWNpdHk6IDAgfSxcbiAgICBidXR0b25SZW1vdmVJdGVtOiB7IG9wYWNpdHk6IDAgfSxcbiAgICBidXR0b25Qcm9jZXNzSXRlbTogeyBvcGFjaXR5OiAwIH0sXG4gICAgYnV0dG9uQWJvcnRJdGVtUHJvY2Vzc2luZzogeyBvcGFjaXR5OiAwIH0sXG4gICAgYnV0dG9uUmV0cnlJdGVtUHJvY2Vzc2luZzogeyBvcGFjaXR5OiAwIH0sXG4gICAgYnV0dG9uUmV2ZXJ0SXRlbVByb2Nlc3Npbmc6IHsgb3BhY2l0eTogMCB9LFxuICAgIGxvYWRQcm9ncmVzc0luZGljYXRvcjogeyBvcGFjaXR5OiAwLCBhbGlnbjogZ2V0TG9hZEluZGljYXRvckFsaWdubWVudCB9LFxuICAgIHByb2Nlc3NQcm9ncmVzc0luZGljYXRvcjoge1xuICAgICAgb3BhY2l0eTogMCxcbiAgICAgIGFsaWduOiBnZXRQcm9jZXNzSW5kaWNhdG9yQWxpZ25tZW50XG4gICAgfSxcbiAgICBwcm9jZXNzaW5nQ29tcGxldGVJbmRpY2F0b3I6IHsgb3BhY2l0eTogMCwgc2NhbGVYOiAwLjc1LCBzY2FsZVk6IDAuNzUgfSxcbiAgICBpbmZvOiB7IHRyYW5zbGF0ZVg6IDAsIHRyYW5zbGF0ZVk6IDAsIG9wYWNpdHk6IDAgfSxcbiAgICBzdGF0dXM6IHsgdHJhbnNsYXRlWDogMCwgdHJhbnNsYXRlWTogMCwgb3BhY2l0eTogMCB9XG4gIH07XG5cbiAgdmFyIElkbGVTdHlsZSA9IHtcbiAgICBidXR0b25SZW1vdmVJdGVtOiB7IG9wYWNpdHk6IDEgfSxcbiAgICBidXR0b25Qcm9jZXNzSXRlbTogeyBvcGFjaXR5OiAxIH0sXG4gICAgaW5mbzogeyB0cmFuc2xhdGVYOiBjYWxjdWxhdGVGaWxlSW5mb09mZnNldCB9LFxuICAgIHN0YXR1czogeyB0cmFuc2xhdGVYOiBjYWxjdWxhdGVGaWxlSW5mb09mZnNldCB9XG4gIH07XG5cbiAgdmFyIFByb2Nlc3NpbmdTdHlsZSA9IHtcbiAgICBidXR0b25BYm9ydEl0ZW1Qcm9jZXNzaW5nOiB7IG9wYWNpdHk6IDEgfSxcbiAgICBwcm9jZXNzUHJvZ3Jlc3NJbmRpY2F0b3I6IHsgb3BhY2l0eTogMSB9LFxuICAgIHN0YXR1czogeyBvcGFjaXR5OiAxIH1cbiAgfTtcblxuICB2YXIgU3R5bGVNYXAgPSB7XG4gICAgRElEX1RIUk9XX0lURU1fSU5WQUxJRDoge1xuICAgICAgYnV0dG9uUmVtb3ZlSXRlbTogeyBvcGFjaXR5OiAxIH0sXG4gICAgICBpbmZvOiB7IHRyYW5zbGF0ZVg6IGNhbGN1bGF0ZUZpbGVJbmZvT2Zmc2V0IH0sXG4gICAgICBzdGF0dXM6IHsgdHJhbnNsYXRlWDogY2FsY3VsYXRlRmlsZUluZm9PZmZzZXQsIG9wYWNpdHk6IDEgfVxuICAgIH0sXG5cbiAgICBESURfU1RBUlRfSVRFTV9MT0FEOiB7XG4gICAgICBidXR0b25BYm9ydEl0ZW1Mb2FkOiB7IG9wYWNpdHk6IDEgfSxcbiAgICAgIGxvYWRQcm9ncmVzc0luZGljYXRvcjogeyBvcGFjaXR5OiAxIH0sXG4gICAgICBzdGF0dXM6IHsgb3BhY2l0eTogMSB9XG4gICAgfSxcblxuICAgIERJRF9USFJPV19JVEVNX0xPQURfRVJST1I6IHtcbiAgICAgIGJ1dHRvblJldHJ5SXRlbUxvYWQ6IHsgb3BhY2l0eTogMSB9LFxuICAgICAgYnV0dG9uUmVtb3ZlSXRlbTogeyBvcGFjaXR5OiAxIH0sXG4gICAgICBpbmZvOiB7IHRyYW5zbGF0ZVg6IGNhbGN1bGF0ZUZpbGVJbmZvT2Zmc2V0IH0sXG4gICAgICBzdGF0dXM6IHsgb3BhY2l0eTogMSB9XG4gICAgfSxcblxuICAgIERJRF9TVEFSVF9JVEVNX1JFTU9WRToge1xuICAgICAgcHJvY2Vzc1Byb2dyZXNzSW5kaWNhdG9yOiB7XG4gICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgIGFsaWduOiBnZXRSZW1vdmVJbmRpY2F0b3JBbGlnbWVudFxuICAgICAgfSxcbiAgICAgIGluZm86IHsgdHJhbnNsYXRlWDogY2FsY3VsYXRlRmlsZUluZm9PZmZzZXQgfSxcbiAgICAgIHN0YXR1czogeyBvcGFjaXR5OiAwIH1cbiAgICB9LFxuXG4gICAgRElEX1RIUk9XX0lURU1fUkVNT1ZFX0VSUk9SOiB7XG4gICAgICBwcm9jZXNzUHJvZ3Jlc3NJbmRpY2F0b3I6IHtcbiAgICAgICAgb3BhY2l0eTogMCxcbiAgICAgICAgYWxpZ246IGdldFJlbW92ZUluZGljYXRvckFsaWdtZW50XG4gICAgICB9LFxuICAgICAgYnV0dG9uUmVtb3ZlSXRlbTogeyBvcGFjaXR5OiAxIH0sXG4gICAgICBpbmZvOiB7IHRyYW5zbGF0ZVg6IGNhbGN1bGF0ZUZpbGVJbmZvT2Zmc2V0IH0sXG4gICAgICBzdGF0dXM6IHsgb3BhY2l0eTogMSwgdHJhbnNsYXRlWDogY2FsY3VsYXRlRmlsZUluZm9PZmZzZXQgfVxuICAgIH0sXG5cbiAgICBESURfTE9BRF9JVEVNOiBJZGxlU3R5bGUsXG4gICAgRElEX0xPQURfTE9DQUxfSVRFTToge1xuICAgICAgYnV0dG9uUmVtb3ZlSXRlbTogeyBvcGFjaXR5OiAxIH0sXG4gICAgICBpbmZvOiB7IHRyYW5zbGF0ZVg6IGNhbGN1bGF0ZUZpbGVJbmZvT2Zmc2V0IH0sXG4gICAgICBzdGF0dXM6IHsgdHJhbnNsYXRlWDogY2FsY3VsYXRlRmlsZUluZm9PZmZzZXQgfVxuICAgIH0sXG5cbiAgICBESURfU1RBUlRfSVRFTV9QUk9DRVNTSU5HOiBQcm9jZXNzaW5nU3R5bGUsXG4gICAgRElEX1JFUVVFU1RfSVRFTV9QUk9DRVNTSU5HOiBQcm9jZXNzaW5nU3R5bGUsXG4gICAgRElEX1VQREFURV9JVEVNX1BST0NFU1NfUFJPR1JFU1M6IFByb2Nlc3NpbmdTdHlsZSxcbiAgICBESURfQ09NUExFVEVfSVRFTV9QUk9DRVNTSU5HOiB7XG4gICAgICBidXR0b25SZXZlcnRJdGVtUHJvY2Vzc2luZzogeyBvcGFjaXR5OiAxIH0sXG4gICAgICBpbmZvOiB7IG9wYWNpdHk6IDEgfSxcbiAgICAgIHN0YXR1czogeyBvcGFjaXR5OiAxIH1cbiAgICB9LFxuXG4gICAgRElEX1RIUk9XX0lURU1fUFJPQ0VTU0lOR19FUlJPUjoge1xuICAgICAgYnV0dG9uUmVtb3ZlSXRlbTogeyBvcGFjaXR5OiAxIH0sXG4gICAgICBidXR0b25SZXRyeUl0ZW1Qcm9jZXNzaW5nOiB7IG9wYWNpdHk6IDEgfSxcbiAgICAgIHN0YXR1czogeyBvcGFjaXR5OiAxIH0sXG4gICAgICBpbmZvOiB7IHRyYW5zbGF0ZVg6IGNhbGN1bGF0ZUZpbGVJbmZvT2Zmc2V0IH1cbiAgICB9LFxuXG4gICAgRElEX1RIUk9XX0lURU1fUFJPQ0VTU0lOR19SRVZFUlRfRVJST1I6IHtcbiAgICAgIGJ1dHRvblJldmVydEl0ZW1Qcm9jZXNzaW5nOiB7IG9wYWNpdHk6IDEgfSxcbiAgICAgIHN0YXR1czogeyBvcGFjaXR5OiAxIH0sXG4gICAgICBpbmZvOiB7IG9wYWNpdHk6IDEgfVxuICAgIH0sXG5cbiAgICBESURfQUJPUlRfSVRFTV9QUk9DRVNTSU5HOiB7XG4gICAgICBidXR0b25SZW1vdmVJdGVtOiB7IG9wYWNpdHk6IDEgfSxcbiAgICAgIGJ1dHRvblByb2Nlc3NJdGVtOiB7IG9wYWNpdHk6IDEgfSxcbiAgICAgIGluZm86IHsgdHJhbnNsYXRlWDogY2FsY3VsYXRlRmlsZUluZm9PZmZzZXQgfSxcbiAgICAgIHN0YXR1czogeyBvcGFjaXR5OiAxIH1cbiAgICB9LFxuXG4gICAgRElEX1JFVkVSVF9JVEVNX1BST0NFU1NJTkc6IElkbGVTdHlsZVxuICB9O1xuXG4gIC8vIGNvbXBsZXRlIGluZGljYXRvciB2aWV3XG4gIHZhciBwcm9jZXNzaW5nQ29tcGxldGVJbmRpY2F0b3JWaWV3ID0gY3JlYXRlVmlldyh7XG4gICAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUoX3JlZikge1xuICAgICAgdmFyIHJvb3QgPSBfcmVmLnJvb3Q7XG4gICAgICByb290LmVsZW1lbnQuaW5uZXJIVE1MID0gcm9vdC5xdWVyeSgnR0VUX0lDT05fRE9ORScpO1xuICAgIH0sXG4gICAgbmFtZTogJ3Byb2Nlc3NpbmctY29tcGxldGUtaW5kaWNhdG9yJyxcbiAgICBpZ25vcmVSZWN0OiB0cnVlLFxuICAgIG1peGluczoge1xuICAgICAgc3R5bGVzOiBbJ3NjYWxlWCcsICdzY2FsZVknLCAnb3BhY2l0eSddLFxuICAgICAgYW5pbWF0aW9uczoge1xuICAgICAgICBzY2FsZVg6ICdzcHJpbmcnLFxuICAgICAgICBzY2FsZVk6ICdzcHJpbmcnLFxuICAgICAgICBvcGFjaXR5OiB7IHR5cGU6ICd0d2VlbicsIGR1cmF0aW9uOiAyNTAgfVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgdGhlIGZpbGUgdmlld1xuICAgKi9cbiAgdmFyIGNyZWF0ZSQ0ID0gZnVuY3Rpb24gY3JlYXRlKF9yZWYyKSB7XG4gICAgdmFyIHJvb3QgPSBfcmVmMi5yb290LFxuICAgICAgcHJvcHMgPSBfcmVmMi5wcm9wcztcbiAgICB2YXIgaWQgPSBwcm9wcy5pZDtcblxuICAgIC8vIGFsbG93IHJldmVydGluZyB1cGxvYWRcbiAgICB2YXIgYWxsb3dSZXZlcnQgPSByb290LnF1ZXJ5KCdHRVRfQUxMT1dfUkVWRVJUJyk7XG5cbiAgICAvLyBhbGxvdyByZW1vdmUgZmlsZVxuICAgIHZhciBhbGxvd1JlbW92ZSA9IHJvb3QucXVlcnkoJ0dFVF9BTExPV19SRU1PVkUnKTtcblxuICAgIC8vIGFsbG93IHByb2Nlc3NpbmcgdXBsb2FkXG4gICAgdmFyIGFsbG93UHJvY2VzcyA9IHJvb3QucXVlcnkoJ0dFVF9BTExPV19QUk9DRVNTJyk7XG5cbiAgICAvLyBpcyBpbnN0YW50IHVwbG9hZGluZywgbmVlZCB0aGlzIHRvIGRldGVybWluZSB0aGUgaWNvbiBvZiB0aGUgdW5kbyBidXR0b25cbiAgICB2YXIgaW5zdGFudFVwbG9hZCA9IHJvb3QucXVlcnkoJ0dFVF9JTlNUQU5UX1VQTE9BRCcpO1xuXG4gICAgLy8gaXMgYXN5bmMgc2V0IHVwXG4gICAgdmFyIGlzQXN5bmMgPSByb290LnF1ZXJ5KCdJU19BU1lOQycpO1xuXG4gICAgLy8gc2hvdWxkIGFsaWduIHJlbW92ZSBpdGVtIGJ1dHRvbnNcbiAgICB2YXIgYWxpZ25SZW1vdmVJdGVtQnV0dG9uID0gcm9vdC5xdWVyeShcbiAgICAgICdHRVRfU1RZTEVfQlVUVE9OX1JFTU9WRV9JVEVNX0FMSUdOJ1xuICAgICk7XG5cbiAgICAvLyBlbmFibGVkIGJ1dHRvbnMgYXJyYXlcbiAgICB2YXIgYnV0dG9uRmlsdGVyO1xuICAgIGlmIChpc0FzeW5jKSB7XG4gICAgICBpZiAoYWxsb3dQcm9jZXNzICYmICFhbGxvd1JldmVydCkge1xuICAgICAgICAvLyBvbmx5IHJlbW92ZSByZXZlcnQgYnV0dG9uXG4gICAgICAgIGJ1dHRvbkZpbHRlciA9IGZ1bmN0aW9uIGJ1dHRvbkZpbHRlcihrZXkpIHtcbiAgICAgICAgICByZXR1cm4gIS9SZXZlcnRJdGVtUHJvY2Vzc2luZy8udGVzdChrZXkpO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmICghYWxsb3dQcm9jZXNzICYmIGFsbG93UmV2ZXJ0KSB7XG4gICAgICAgIC8vIG9ubHkgcmVtb3ZlIHByb2Nlc3MgYnV0dG9uXG4gICAgICAgIGJ1dHRvbkZpbHRlciA9IGZ1bmN0aW9uIGJ1dHRvbkZpbHRlcihrZXkpIHtcbiAgICAgICAgICByZXR1cm4gIS9Qcm9jZXNzSXRlbXxSZXRyeUl0ZW1Qcm9jZXNzaW5nfEFib3J0SXRlbVByb2Nlc3NpbmcvLnRlc3QoXG4gICAgICAgICAgICBrZXlcbiAgICAgICAgICApO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmICghYWxsb3dQcm9jZXNzICYmICFhbGxvd1JldmVydCkge1xuICAgICAgICAvLyByZW1vdmUgYWxsIHByb2Nlc3MgYnV0dG9uc1xuICAgICAgICBidXR0b25GaWx0ZXIgPSBmdW5jdGlvbiBidXR0b25GaWx0ZXIoa2V5KSB7XG4gICAgICAgICAgcmV0dXJuICEvUHJvY2Vzcy8udGVzdChrZXkpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBubyBwcm9jZXNzIGNvbnRyb2xzIGF2YWlsYWJsZVxuICAgICAgYnV0dG9uRmlsdGVyID0gZnVuY3Rpb24gYnV0dG9uRmlsdGVyKGtleSkge1xuICAgICAgICByZXR1cm4gIS9Qcm9jZXNzLy50ZXN0KGtleSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciBlbmFibGVkQnV0dG9ucyA9IGJ1dHRvbkZpbHRlclxuICAgICAgPyBCdXR0b25LZXlzLmZpbHRlcihidXR0b25GaWx0ZXIpXG4gICAgICA6IEJ1dHRvbktleXMuY29uY2F0KCk7XG5cbiAgICAvLyB1cGRhdGUgaWNvbiBhbmQgbGFiZWwgZm9yIHJldmVydCBidXR0b24gd2hlbiBpbnN0YW50IHVwbG9hZGluZ1xuICAgIGlmIChpbnN0YW50VXBsb2FkICYmIGFsbG93UmV2ZXJ0KSB7XG4gICAgICBCdXR0b25zWydSZXZlcnRJdGVtUHJvY2Vzc2luZyddLmxhYmVsID0gJ0dFVF9MQUJFTF9CVVRUT05fUkVNT1ZFX0lURU0nO1xuICAgICAgQnV0dG9uc1snUmV2ZXJ0SXRlbVByb2Nlc3NpbmcnXS5pY29uID0gJ0dFVF9JQ09OX1JFTU9WRSc7XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIGxhc3QgYnV0dG9uIChyZXZlcnQpIGlmIG5vdCBhbGxvd2VkXG4gICAgaWYgKGlzQXN5bmMgJiYgIWFsbG93UmV2ZXJ0KSB7XG4gICAgICB2YXIgbWFwID0gU3R5bGVNYXBbJ0RJRF9DT01QTEVURV9JVEVNX1BST0NFU1NJTkcnXTtcbiAgICAgIG1hcC5pbmZvLnRyYW5zbGF0ZVggPSBjYWxjdWxhdGVGaWxlSG9yaXpvbnRhbENlbnRlck9mZnNldDtcbiAgICAgIG1hcC5pbmZvLnRyYW5zbGF0ZVkgPSBjYWxjdWxhdGVGaWxlVmVydGljYWxDZW50ZXJPZmZzZXQ7XG4gICAgICBtYXAuc3RhdHVzLnRyYW5zbGF0ZVkgPSBjYWxjdWxhdGVGaWxlVmVydGljYWxDZW50ZXJPZmZzZXQ7XG4gICAgICBtYXAucHJvY2Vzc2luZ0NvbXBsZXRlSW5kaWNhdG9yID0geyBvcGFjaXR5OiAxLCBzY2FsZVg6IDEsIHNjYWxlWTogMSB9O1xuICAgIH1cblxuICAgIC8vIHNob3VsZCBhbGlnbiBjZW50ZXJcbiAgICBpZiAoaXNBc3luYyAmJiAhYWxsb3dQcm9jZXNzKSB7XG4gICAgICBbXG4gICAgICAgICdESURfU1RBUlRfSVRFTV9QUk9DRVNTSU5HJyxcbiAgICAgICAgJ0RJRF9SRVFVRVNUX0lURU1fUFJPQ0VTU0lORycsXG4gICAgICAgICdESURfVVBEQVRFX0lURU1fUFJPQ0VTU19QUk9HUkVTUycsXG4gICAgICAgICdESURfVEhST1dfSVRFTV9QUk9DRVNTSU5HX0VSUk9SJ1xuICAgICAgXS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICBTdHlsZU1hcFtrZXldLnN0YXR1cy50cmFuc2xhdGVZID0gY2FsY3VsYXRlRmlsZVZlcnRpY2FsQ2VudGVyT2Zmc2V0O1xuICAgICAgfSk7XG4gICAgICBTdHlsZU1hcFtcbiAgICAgICAgJ0RJRF9USFJPV19JVEVNX1BST0NFU1NJTkdfRVJST1InXG4gICAgICBdLnN0YXR1cy50cmFuc2xhdGVYID0gY2FsY3VsYXRlQnV0dG9uV2lkdGg7XG4gICAgfVxuXG4gICAgLy8gbW92ZSByZW1vdmUgYnV0dG9uIHRvIHJpZ2h0XG4gICAgaWYgKGFsaWduUmVtb3ZlSXRlbUJ1dHRvbiAmJiBhbGxvd1JldmVydCkge1xuICAgICAgQnV0dG9uc1snUmV2ZXJ0SXRlbVByb2Nlc3NpbmcnXS5hbGlnbiA9ICdCVVRUT05fUkVNT1ZFX0lURU1fUE9TSVRJT04nO1xuICAgICAgdmFyIF9tYXAgPSBTdHlsZU1hcFsnRElEX0NPTVBMRVRFX0lURU1fUFJPQ0VTU0lORyddO1xuICAgICAgX21hcC5pbmZvLnRyYW5zbGF0ZVggPSBjYWxjdWxhdGVGaWxlSW5mb09mZnNldDtcbiAgICAgIF9tYXAuc3RhdHVzLnRyYW5zbGF0ZVkgPSBjYWxjdWxhdGVGaWxlVmVydGljYWxDZW50ZXJPZmZzZXQ7XG4gICAgICBfbWFwLnByb2Nlc3NpbmdDb21wbGV0ZUluZGljYXRvciA9IHsgb3BhY2l0eTogMSwgc2NhbGVYOiAxLCBzY2FsZVk6IDEgfTtcbiAgICB9XG5cbiAgICBpZiAoIWFsbG93UmVtb3ZlKSB7XG4gICAgICBCdXR0b25zWydSZW1vdmVJdGVtJ10uZGlzYWJsZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIGNyZWF0ZSB0aGUgYnV0dG9uIHZpZXdzXG4gICAgZm9yaW4oQnV0dG9ucywgZnVuY3Rpb24oa2V5LCBkZWZpbml0aW9uKSB7XG4gICAgICAvLyBjcmVhdGUgYnV0dG9uXG4gICAgICB2YXIgYnV0dG9uVmlldyA9IHJvb3QuY3JlYXRlQ2hpbGRWaWV3KGZpbGVBY3Rpb25CdXR0b24sIHtcbiAgICAgICAgbGFiZWw6IHJvb3QucXVlcnkoZGVmaW5pdGlvbi5sYWJlbCksXG4gICAgICAgIGljb246IHJvb3QucXVlcnkoZGVmaW5pdGlvbi5pY29uKSxcbiAgICAgICAgb3BhY2l0eTogMFxuICAgICAgfSk7XG5cbiAgICAgIC8vIHNob3VsZCBiZSBhcHBlbmRlZD9cbiAgICAgIGlmIChlbmFibGVkQnV0dG9ucy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgIHJvb3QuYXBwZW5kQ2hpbGRWaWV3KGJ1dHRvblZpZXcpO1xuICAgICAgfVxuXG4gICAgICAvLyB0b2dnbGVcbiAgICAgIGlmIChkZWZpbml0aW9uLmRpc2FibGVkKSB7XG4gICAgICAgIGJ1dHRvblZpZXcuZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2Rpc2FibGVkJywgJ2Rpc2FibGVkJyk7XG4gICAgICAgIGJ1dHRvblZpZXcuZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2hpZGRlbicsICdoaWRkZW4nKTtcbiAgICAgIH1cblxuICAgICAgLy8gYWRkIHBvc2l0aW9uIGF0dHJpYnV0ZVxuICAgICAgYnV0dG9uVmlldy5lbGVtZW50LmRhdGFzZXQuYWxpZ24gPSByb290LnF1ZXJ5KFxuICAgICAgICAnR0VUX1NUWUxFXycgKyBkZWZpbml0aW9uLmFsaWduXG4gICAgICApO1xuXG4gICAgICAvLyBhZGQgY2xhc3NcbiAgICAgIGJ1dHRvblZpZXcuZWxlbWVudC5jbGFzc0xpc3QuYWRkKGRlZmluaXRpb24uY2xhc3NOYW1lKTtcblxuICAgICAgLy8gaGFuZGxlIGludGVyYWN0aW9uc1xuICAgICAgYnV0dG9uVmlldy5vbignY2xpY2snLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGlmIChkZWZpbml0aW9uLmRpc2FibGVkKSByZXR1cm47XG4gICAgICAgIHJvb3QuZGlzcGF0Y2goZGVmaW5pdGlvbi5hY3Rpb24sIHsgcXVlcnk6IGlkIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIHNldCByZWZlcmVuY2VcbiAgICAgIHJvb3QucmVmWydidXR0b24nICsga2V5XSA9IGJ1dHRvblZpZXc7XG4gICAgfSk7XG5cbiAgICAvLyBjaGVja21hcmtcbiAgICByb290LnJlZi5wcm9jZXNzaW5nQ29tcGxldGVJbmRpY2F0b3IgPSByb290LmFwcGVuZENoaWxkVmlldyhcbiAgICAgIHJvb3QuY3JlYXRlQ2hpbGRWaWV3KHByb2Nlc3NpbmdDb21wbGV0ZUluZGljYXRvclZpZXcpXG4gICAgKTtcbiAgICByb290LnJlZi5wcm9jZXNzaW5nQ29tcGxldGVJbmRpY2F0b3IuZWxlbWVudC5kYXRhc2V0LmFsaWduID0gcm9vdC5xdWVyeShcbiAgICAgICdHRVRfU1RZTEVfQlVUVE9OX1BST0NFU1NfSVRFTV9QT1NJVElPTidcbiAgICApO1xuXG4gICAgLy8gY3JlYXRlIGZpbGUgaW5mbyB2aWV3XG4gICAgcm9vdC5yZWYuaW5mbyA9IHJvb3QuYXBwZW5kQ2hpbGRWaWV3KFxuICAgICAgcm9vdC5jcmVhdGVDaGlsZFZpZXcoZmlsZUluZm8sIHsgaWQ6IGlkIH0pXG4gICAgKTtcblxuICAgIC8vIGNyZWF0ZSBmaWxlIHN0YXR1cyB2aWV3XG4gICAgcm9vdC5yZWYuc3RhdHVzID0gcm9vdC5hcHBlbmRDaGlsZFZpZXcoXG4gICAgICByb290LmNyZWF0ZUNoaWxkVmlldyhmaWxlU3RhdHVzLCB7IGlkOiBpZCB9KVxuICAgICk7XG5cbiAgICAvLyBhZGQgcHJvZ3Jlc3MgaW5kaWNhdG9yc1xuICAgIHZhciBsb2FkSW5kaWNhdG9yVmlldyA9IHJvb3QuYXBwZW5kQ2hpbGRWaWV3KFxuICAgICAgcm9vdC5jcmVhdGVDaGlsZFZpZXcocHJvZ3Jlc3NJbmRpY2F0b3IsIHtcbiAgICAgICAgb3BhY2l0eTogMCxcbiAgICAgICAgYWxpZ246IHJvb3QucXVlcnkoJ0dFVF9TVFlMRV9MT0FEX0lORElDQVRPUl9QT1NJVElPTicpXG4gICAgICB9KVxuICAgICk7XG5cbiAgICBsb2FkSW5kaWNhdG9yVmlldy5lbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2ZpbGVwb25kLS1sb2FkLWluZGljYXRvcicpO1xuICAgIHJvb3QucmVmLmxvYWRQcm9ncmVzc0luZGljYXRvciA9IGxvYWRJbmRpY2F0b3JWaWV3O1xuXG4gICAgdmFyIHByb2dyZXNzSW5kaWNhdG9yVmlldyA9IHJvb3QuYXBwZW5kQ2hpbGRWaWV3KFxuICAgICAgcm9vdC5jcmVhdGVDaGlsZFZpZXcocHJvZ3Jlc3NJbmRpY2F0b3IsIHtcbiAgICAgICAgb3BhY2l0eTogMCxcbiAgICAgICAgYWxpZ246IHJvb3QucXVlcnkoJ0dFVF9TVFlMRV9QUk9HUkVTU19JTkRJQ0FUT1JfUE9TSVRJT04nKVxuICAgICAgfSlcbiAgICApO1xuXG4gICAgcHJvZ3Jlc3NJbmRpY2F0b3JWaWV3LmVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnZmlsZXBvbmQtLXByb2Nlc3MtaW5kaWNhdG9yJyk7XG4gICAgcm9vdC5yZWYucHJvY2Vzc1Byb2dyZXNzSW5kaWNhdG9yID0gcHJvZ3Jlc3NJbmRpY2F0b3JWaWV3O1xuXG4gICAgLy8gY3VycmVudCBhY3RpdmUgc3R5bGVzXG4gICAgcm9vdC5yZWYuYWN0aXZlU3R5bGVzID0gW107XG4gIH07XG5cbiAgdmFyIHdyaXRlJDIgPSBmdW5jdGlvbiB3cml0ZShfcmVmMykge1xuICAgIHZhciByb290ID0gX3JlZjMucm9vdCxcbiAgICAgIGFjdGlvbnMgPSBfcmVmMy5hY3Rpb25zLFxuICAgICAgcHJvcHMgPSBfcmVmMy5wcm9wcztcblxuICAgIC8vIHJvdXRlIGFjdGlvbnNcbiAgICByb3V0ZSh7IHJvb3Q6IHJvb3QsIGFjdGlvbnM6IGFjdGlvbnMsIHByb3BzOiBwcm9wcyB9KTtcblxuICAgIC8vIHNlbGVjdCBsYXN0IHN0YXRlIGNoYW5nZSBhY3Rpb25cbiAgICB2YXIgYWN0aW9uID0gYWN0aW9uc1xuICAgICAgLmNvbmNhdCgpXG4gICAgICAuZmlsdGVyKGZ1bmN0aW9uKGFjdGlvbikge1xuICAgICAgICByZXR1cm4gL15ESURfLy50ZXN0KGFjdGlvbi50eXBlKTtcbiAgICAgIH0pXG4gICAgICAucmV2ZXJzZSgpXG4gICAgICAuZmluZChmdW5jdGlvbihhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIFN0eWxlTWFwW2FjdGlvbi50eXBlXTtcbiAgICAgIH0pO1xuXG4gICAgLy8gYSBuZXcgYWN0aW9uIGhhcHBlbmVkLCBsZXQncyBnZXQgdGhlIG1hdGNoaW5nIHN0eWxlc1xuICAgIGlmIChhY3Rpb24pIHtcbiAgICAgIC8vIGRlZmluZSBuZXcgYWN0aXZlIHN0eWxlc1xuICAgICAgcm9vdC5yZWYuYWN0aXZlU3R5bGVzID0gW107XG5cbiAgICAgIHZhciBzdHlsZXNUb0FwcGx5ID0gU3R5bGVNYXBbYWN0aW9uLnR5cGVdO1xuICAgICAgZm9yaW4oRGVmYXVsdFN0eWxlLCBmdW5jdGlvbihuYW1lLCBkZWZhdWx0U3R5bGVzKSB7XG4gICAgICAgIC8vIGdldCByZWZlcmVuY2UgdG8gY29udHJvbFxuICAgICAgICB2YXIgY29udHJvbCA9IHJvb3QucmVmW25hbWVdO1xuXG4gICAgICAgIC8vIGxvb3Agb3ZlciBhbGwgc3R5bGVzIGZvciB0aGlzIGNvbnRyb2xcbiAgICAgICAgZm9yaW4oZGVmYXVsdFN0eWxlcywgZnVuY3Rpb24oa2V5LCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPVxuICAgICAgICAgICAgc3R5bGVzVG9BcHBseVtuYW1lXSAmJlxuICAgICAgICAgICAgdHlwZW9mIHN0eWxlc1RvQXBwbHlbbmFtZV1ba2V5XSAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgICAgPyBzdHlsZXNUb0FwcGx5W25hbWVdW2tleV1cbiAgICAgICAgICAgICAgOiBkZWZhdWx0VmFsdWU7XG4gICAgICAgICAgcm9vdC5yZWYuYWN0aXZlU3R5bGVzLnB1c2goe1xuICAgICAgICAgICAgY29udHJvbDogY29udHJvbCxcbiAgICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gYXBwbHkgYWN0aXZlIHN0eWxlcyB0byBlbGVtZW50XG4gICAgcm9vdC5yZWYuYWN0aXZlU3R5bGVzLmZvckVhY2goZnVuY3Rpb24oX3JlZjQpIHtcbiAgICAgIHZhciBjb250cm9sID0gX3JlZjQuY29udHJvbCxcbiAgICAgICAga2V5ID0gX3JlZjQua2V5LFxuICAgICAgICB2YWx1ZSA9IF9yZWY0LnZhbHVlO1xuICAgICAgY29udHJvbFtrZXldID0gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nID8gdmFsdWUocm9vdCkgOiB2YWx1ZTtcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgcm91dGUgPSBjcmVhdGVSb3V0ZSh7XG4gICAgRElEX1NFVF9MQUJFTF9CVVRUT05fQUJPUlRfSVRFTV9QUk9DRVNTSU5HOiBmdW5jdGlvbiBESURfU0VUX0xBQkVMX0JVVFRPTl9BQk9SVF9JVEVNX1BST0NFU1NJTkcoXG4gICAgICBfcmVmNVxuICAgICkge1xuICAgICAgdmFyIHJvb3QgPSBfcmVmNS5yb290LFxuICAgICAgICBhY3Rpb24gPSBfcmVmNS5hY3Rpb247XG4gICAgICByb290LnJlZi5idXR0b25BYm9ydEl0ZW1Qcm9jZXNzaW5nLmxhYmVsID0gYWN0aW9uLnZhbHVlO1xuICAgIH0sXG4gICAgRElEX1NFVF9MQUJFTF9CVVRUT05fQUJPUlRfSVRFTV9MT0FEOiBmdW5jdGlvbiBESURfU0VUX0xBQkVMX0JVVFRPTl9BQk9SVF9JVEVNX0xPQUQoXG4gICAgICBfcmVmNlxuICAgICkge1xuICAgICAgdmFyIHJvb3QgPSBfcmVmNi5yb290LFxuICAgICAgICBhY3Rpb24gPSBfcmVmNi5hY3Rpb247XG4gICAgICByb290LnJlZi5idXR0b25BYm9ydEl0ZW1Mb2FkLmxhYmVsID0gYWN0aW9uLnZhbHVlO1xuICAgIH0sXG4gICAgRElEX1NFVF9MQUJFTF9CVVRUT05fQUJPUlRfSVRFTV9SRU1PVkFMOiBmdW5jdGlvbiBESURfU0VUX0xBQkVMX0JVVFRPTl9BQk9SVF9JVEVNX1JFTU9WQUwoXG4gICAgICBfcmVmN1xuICAgICkge1xuICAgICAgdmFyIHJvb3QgPSBfcmVmNy5yb290LFxuICAgICAgICBhY3Rpb24gPSBfcmVmNy5hY3Rpb247XG4gICAgICByb290LnJlZi5idXR0b25BYm9ydEl0ZW1SZW1vdmFsLmxhYmVsID0gYWN0aW9uLnZhbHVlO1xuICAgIH0sXG4gICAgRElEX1JFUVVFU1RfSVRFTV9QUk9DRVNTSU5HOiBmdW5jdGlvbiBESURfUkVRVUVTVF9JVEVNX1BST0NFU1NJTkcoX3JlZjgpIHtcbiAgICAgIHZhciByb290ID0gX3JlZjgucm9vdDtcbiAgICAgIHJvb3QucmVmLnByb2Nlc3NQcm9ncmVzc0luZGljYXRvci5zcGluID0gdHJ1ZTtcbiAgICAgIHJvb3QucmVmLnByb2Nlc3NQcm9ncmVzc0luZGljYXRvci5wcm9ncmVzcyA9IDA7XG4gICAgfSxcbiAgICBESURfU1RBUlRfSVRFTV9MT0FEOiBmdW5jdGlvbiBESURfU1RBUlRfSVRFTV9MT0FEKF9yZWY5KSB7XG4gICAgICB2YXIgcm9vdCA9IF9yZWY5LnJvb3Q7XG4gICAgICByb290LnJlZi5sb2FkUHJvZ3Jlc3NJbmRpY2F0b3Iuc3BpbiA9IHRydWU7XG4gICAgICByb290LnJlZi5sb2FkUHJvZ3Jlc3NJbmRpY2F0b3IucHJvZ3Jlc3MgPSAwO1xuICAgIH0sXG4gICAgRElEX1NUQVJUX0lURU1fUkVNT1ZFOiBmdW5jdGlvbiBESURfU1RBUlRfSVRFTV9SRU1PVkUoX3JlZjEwKSB7XG4gICAgICB2YXIgcm9vdCA9IF9yZWYxMC5yb290O1xuICAgICAgcm9vdC5yZWYucHJvY2Vzc1Byb2dyZXNzSW5kaWNhdG9yLnNwaW4gPSB0cnVlO1xuICAgICAgcm9vdC5yZWYucHJvY2Vzc1Byb2dyZXNzSW5kaWNhdG9yLnByb2dyZXNzID0gMDtcbiAgICB9LFxuICAgIERJRF9VUERBVEVfSVRFTV9MT0FEX1BST0dSRVNTOiBmdW5jdGlvbiBESURfVVBEQVRFX0lURU1fTE9BRF9QUk9HUkVTUyhcbiAgICAgIF9yZWYxMVxuICAgICkge1xuICAgICAgdmFyIHJvb3QgPSBfcmVmMTEucm9vdCxcbiAgICAgICAgYWN0aW9uID0gX3JlZjExLmFjdGlvbjtcbiAgICAgIHJvb3QucmVmLmxvYWRQcm9ncmVzc0luZGljYXRvci5zcGluID0gZmFsc2U7XG4gICAgICByb290LnJlZi5sb2FkUHJvZ3Jlc3NJbmRpY2F0b3IucHJvZ3Jlc3MgPSBhY3Rpb24ucHJvZ3Jlc3M7XG4gICAgfSxcbiAgICBESURfVVBEQVRFX0lURU1fUFJPQ0VTU19QUk9HUkVTUzogZnVuY3Rpb24gRElEX1VQREFURV9JVEVNX1BST0NFU1NfUFJPR1JFU1MoXG4gICAgICBfcmVmMTJcbiAgICApIHtcbiAgICAgIHZhciByb290ID0gX3JlZjEyLnJvb3QsXG4gICAgICAgIGFjdGlvbiA9IF9yZWYxMi5hY3Rpb247XG4gICAgICByb290LnJlZi5wcm9jZXNzUHJvZ3Jlc3NJbmRpY2F0b3Iuc3BpbiA9IGZhbHNlO1xuICAgICAgcm9vdC5yZWYucHJvY2Vzc1Byb2dyZXNzSW5kaWNhdG9yLnByb2dyZXNzID0gYWN0aW9uLnByb2dyZXNzO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIGZpbGUgPSBjcmVhdGVWaWV3KHtcbiAgICBjcmVhdGU6IGNyZWF0ZSQ0LFxuICAgIHdyaXRlOiB3cml0ZSQyLFxuICAgIGRpZENyZWF0ZVZpZXc6IGZ1bmN0aW9uIGRpZENyZWF0ZVZpZXcocm9vdCkge1xuICAgICAgYXBwbHlGaWx0ZXJzKCdDUkVBVEVfVklFVycsIE9iamVjdC5hc3NpZ24oe30sIHJvb3QsIHsgdmlldzogcm9vdCB9KSk7XG4gICAgfSxcbiAgICBuYW1lOiAnZmlsZSdcbiAgfSk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgdGhlIGZpbGUgdmlld1xuICAgKi9cbiAgdmFyIGNyZWF0ZSQ1ID0gZnVuY3Rpb24gY3JlYXRlKF9yZWYpIHtcbiAgICB2YXIgcm9vdCA9IF9yZWYucm9vdCxcbiAgICAgIHByb3BzID0gX3JlZi5wcm9wcztcblxuICAgIC8vIGZpbGVuYW1lXG4gICAgcm9vdC5yZWYuZmlsZU5hbWUgPSBjcmVhdGVFbGVtZW50JDEoJ2xlZ2VuZCcpO1xuICAgIHJvb3QuYXBwZW5kQ2hpbGQocm9vdC5yZWYuZmlsZU5hbWUpO1xuXG4gICAgLy8gZmlsZSBhcHBlbmRlZFxuICAgIHJvb3QucmVmLmZpbGUgPSByb290LmFwcGVuZENoaWxkVmlldyhcbiAgICAgIHJvb3QuY3JlYXRlQ2hpbGRWaWV3KGZpbGUsIHsgaWQ6IHByb3BzLmlkIH0pXG4gICAgKTtcblxuICAgIC8vIGRhdGEgaGFzIG1vdmVkIHRvIGRhdGEuanNcbiAgICByb290LnJlZi5kYXRhID0gZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIERhdGEgc3RvcmFnZVxuICAgKi9cbiAgdmFyIGRpZExvYWRJdGVtID0gZnVuY3Rpb24gZGlkTG9hZEl0ZW0oX3JlZjIpIHtcbiAgICB2YXIgcm9vdCA9IF9yZWYyLnJvb3QsXG4gICAgICBwcm9wcyA9IF9yZWYyLnByb3BzO1xuICAgIC8vIHVwZGF0ZXMgdGhlIGxlZ2VuZCBvZiB0aGUgZmllbGRzZXQgc28gc2NyZWVucmVhZGVycyBjYW4gYmV0dGVyIGdyb3VwIGJ1dHRvbnNcbiAgICB0ZXh0KFxuICAgICAgcm9vdC5yZWYuZmlsZU5hbWUsXG4gICAgICBmb3JtYXRGaWxlbmFtZShyb290LnF1ZXJ5KCdHRVRfSVRFTV9OQU1FJywgcHJvcHMuaWQpKVxuICAgICk7XG4gIH07XG5cbiAgdmFyIGZpbGVXcmFwcGVyID0gY3JlYXRlVmlldyh7XG4gICAgY3JlYXRlOiBjcmVhdGUkNSxcbiAgICBpZ25vcmVSZWN0OiB0cnVlLFxuICAgIHdyaXRlOiBjcmVhdGVSb3V0ZSh7XG4gICAgICBESURfTE9BRF9JVEVNOiBkaWRMb2FkSXRlbVxuICAgIH0pLFxuXG4gICAgZGlkQ3JlYXRlVmlldzogZnVuY3Rpb24gZGlkQ3JlYXRlVmlldyhyb290KSB7XG4gICAgICBhcHBseUZpbHRlcnMoJ0NSRUFURV9WSUVXJywgT2JqZWN0LmFzc2lnbih7fSwgcm9vdCwgeyB2aWV3OiByb290IH0pKTtcbiAgICB9LFxuICAgIHRhZzogJ2ZpZWxkc2V0JyxcbiAgICBuYW1lOiAnZmlsZS13cmFwcGVyJ1xuICB9KTtcblxuICB2YXIgUEFORUxfU1BSSU5HX1BST1BTID0geyB0eXBlOiAnc3ByaW5nJywgZGFtcGluZzogMC42LCBtYXNzOiA3IH07XG5cbiAgdmFyIGNyZWF0ZSQ2ID0gZnVuY3Rpb24gY3JlYXRlKF9yZWYpIHtcbiAgICB2YXIgcm9vdCA9IF9yZWYucm9vdCxcbiAgICAgIHByb3BzID0gX3JlZi5wcm9wcztcbiAgICBbXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICd0b3AnXG4gICAgICB9LFxuXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdjZW50ZXInLFxuICAgICAgICBwcm9wczoge1xuICAgICAgICAgIHRyYW5zbGF0ZVk6IG51bGwsXG4gICAgICAgICAgc2NhbGVZOiBudWxsXG4gICAgICAgIH0sXG5cbiAgICAgICAgbWl4aW5zOiB7XG4gICAgICAgICAgYW5pbWF0aW9uczoge1xuICAgICAgICAgICAgc2NhbGVZOiBQQU5FTF9TUFJJTkdfUFJPUFNcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgc3R5bGVzOiBbJ3RyYW5zbGF0ZVknLCAnc2NhbGVZJ11cbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAge1xuICAgICAgICBuYW1lOiAnYm90dG9tJyxcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICB0cmFuc2xhdGVZOiBudWxsXG4gICAgICAgIH0sXG5cbiAgICAgICAgbWl4aW5zOiB7XG4gICAgICAgICAgYW5pbWF0aW9uczoge1xuICAgICAgICAgICAgdHJhbnNsYXRlWTogUEFORUxfU1BSSU5HX1BST1BTXG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHN0eWxlczogWyd0cmFuc2xhdGVZJ11cbiAgICAgICAgfVxuICAgICAgfVxuICAgIF0uZm9yRWFjaChmdW5jdGlvbihzZWN0aW9uKSB7XG4gICAgICBjcmVhdGVTZWN0aW9uKHJvb3QsIHNlY3Rpb24sIHByb3BzLm5hbWUpO1xuICAgIH0pO1xuXG4gICAgcm9vdC5lbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2ZpbGVwb25kLS0nICsgcHJvcHMubmFtZSk7XG5cbiAgICByb290LnJlZi5zY2FsYWJsZSA9IG51bGw7XG4gIH07XG5cbiAgdmFyIGNyZWF0ZVNlY3Rpb24gPSBmdW5jdGlvbiBjcmVhdGVTZWN0aW9uKHJvb3QsIHNlY3Rpb24sIGNsYXNzTmFtZSkge1xuICAgIHZhciB2aWV3Q29uc3RydWN0b3IgPSBjcmVhdGVWaWV3KHtcbiAgICAgIG5hbWU6ICdwYW5lbC0nICsgc2VjdGlvbi5uYW1lICsgJyBmaWxlcG9uZC0tJyArIGNsYXNzTmFtZSxcbiAgICAgIG1peGluczogc2VjdGlvbi5taXhpbnMsXG4gICAgICBpZ25vcmVSZWN0VXBkYXRlOiB0cnVlXG4gICAgfSk7XG5cbiAgICB2YXIgdmlldyA9IHJvb3QuY3JlYXRlQ2hpbGRWaWV3KHZpZXdDb25zdHJ1Y3Rvciwgc2VjdGlvbi5wcm9wcyk7XG5cbiAgICByb290LnJlZltzZWN0aW9uLm5hbWVdID0gcm9vdC5hcHBlbmRDaGlsZFZpZXcodmlldyk7XG4gIH07XG5cbiAgdmFyIHdyaXRlJDMgPSBmdW5jdGlvbiB3cml0ZShfcmVmMikge1xuICAgIHZhciByb290ID0gX3JlZjIucm9vdCxcbiAgICAgIHByb3BzID0gX3JlZjIucHJvcHM7XG5cbiAgICAvLyB1cGRhdGUgc2NhbGFibGUgc3RhdGVcbiAgICBpZiAocm9vdC5yZWYuc2NhbGFibGUgPT09IG51bGwgfHwgcHJvcHMuc2NhbGFibGUgIT09IHJvb3QucmVmLnNjYWxhYmxlKSB7XG4gICAgICByb290LnJlZi5zY2FsYWJsZSA9IGlzQm9vbGVhbihwcm9wcy5zY2FsYWJsZSkgPyBwcm9wcy5zY2FsYWJsZSA6IHRydWU7XG4gICAgICByb290LmVsZW1lbnQuZGF0YXNldC5zY2FsYWJsZSA9IHJvb3QucmVmLnNjYWxhYmxlO1xuICAgIH1cblxuICAgIC8vIG5vIGhlaWdodCwgY2FuJ3Qgc2V0XG4gICAgaWYgKCFwcm9wcy5oZWlnaHQpIHJldHVybjtcblxuICAgIC8vIGdldCBjaGlsZCByZWN0c1xuICAgIHZhciB0b3BSZWN0ID0gcm9vdC5yZWYudG9wLnJlY3QuZWxlbWVudDtcbiAgICB2YXIgYm90dG9tUmVjdCA9IHJvb3QucmVmLmJvdHRvbS5yZWN0LmVsZW1lbnQ7XG5cbiAgICAvLyBtYWtlIHN1cmUgaGVpZ2h0IG5ldmVyIGlzIHNtYWxsZXIgdGhhbiBib3R0b20gYW5kIHRvcCBzZWNpdG9uIGhlaWdodHMgY29tYmluZWQgKHdpbGwgcHJvYmFibHkgbmV2ZXIgaGFwcGVuLCBidXQgd2hvIGtub3dzKVxuICAgIHZhciBoZWlnaHQgPSBNYXRoLm1heCh0b3BSZWN0LmhlaWdodCArIGJvdHRvbVJlY3QuaGVpZ2h0LCBwcm9wcy5oZWlnaHQpO1xuXG4gICAgLy8gb2Zmc2V0IGNlbnRlciBwYXJ0XG4gICAgcm9vdC5yZWYuY2VudGVyLnRyYW5zbGF0ZVkgPSB0b3BSZWN0LmhlaWdodDtcblxuICAgIC8vIHNjYWxlIGNlbnRlciBwYXJ0XG4gICAgLy8gdXNlIG1hdGggY2VpbCB0byBwcmV2ZW50IHRyYW5zcGFyZW50IGxpbmVzIGJlY2F1c2Ugb2Ygcm91bmRpbmcgZXJyb3JzXG4gICAgcm9vdC5yZWYuY2VudGVyLnNjYWxlWSA9XG4gICAgICAoaGVpZ2h0IC0gdG9wUmVjdC5oZWlnaHQgLSBib3R0b21SZWN0LmhlaWdodCkgLyAxMDA7XG5cbiAgICAvLyBvZmZzZXQgYm90dG9tIHBhcnRcbiAgICByb290LnJlZi5ib3R0b20udHJhbnNsYXRlWSA9IGhlaWdodCAtIGJvdHRvbVJlY3QuaGVpZ2h0O1xuICB9O1xuXG4gIHZhciBwYW5lbCA9IGNyZWF0ZVZpZXcoe1xuICAgIG5hbWU6ICdwYW5lbCcsXG4gICAgcmVhZDogZnVuY3Rpb24gcmVhZChfcmVmMykge1xuICAgICAgdmFyIHJvb3QgPSBfcmVmMy5yb290LFxuICAgICAgICBwcm9wcyA9IF9yZWYzLnByb3BzO1xuICAgICAgcmV0dXJuIChwcm9wcy5oZWlnaHRDdXJyZW50ID0gcm9vdC5yZWYuYm90dG9tLnRyYW5zbGF0ZVkpO1xuICAgIH0sXG4gICAgd3JpdGU6IHdyaXRlJDMsXG4gICAgY3JlYXRlOiBjcmVhdGUkNixcbiAgICBpZ25vcmVSZWN0OiB0cnVlLFxuICAgIG1peGluczoge1xuICAgICAgYXBpczogWydoZWlnaHQnLCAnaGVpZ2h0Q3VycmVudCcsICdzY2FsYWJsZSddXG4gICAgfVxuICB9KTtcblxuICB2YXIgY3JlYXRlRHJhZ0hlbHBlciA9IGZ1bmN0aW9uIGNyZWF0ZURyYWdIZWxwZXIoaXRlbXMpIHtcbiAgICB2YXIgaXRlbUlkcyA9IGl0ZW1zLm1hcChmdW5jdGlvbihpdGVtKSB7XG4gICAgICByZXR1cm4gaXRlbS5pZDtcbiAgICB9KTtcbiAgICB2YXIgcHJldkluZGV4ID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiB7XG4gICAgICBzZXRJbmRleDogZnVuY3Rpb24gc2V0SW5kZXgoaW5kZXgpIHtcbiAgICAgICAgcHJldkluZGV4ID0gaW5kZXg7XG4gICAgICB9LFxuICAgICAgZ2V0SW5kZXg6IGZ1bmN0aW9uIGdldEluZGV4KCkge1xuICAgICAgICByZXR1cm4gcHJldkluZGV4O1xuICAgICAgfSxcbiAgICAgIGdldEl0ZW1JbmRleDogZnVuY3Rpb24gZ2V0SXRlbUluZGV4KGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW1JZHMuaW5kZXhPZihpdGVtLmlkKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIHZhciBJVEVNX1RSQU5TTEFURV9TUFJJTkcgPSB7XG4gICAgdHlwZTogJ3NwcmluZycsXG4gICAgc3RpZmZuZXNzOiAwLjc1LFxuICAgIGRhbXBpbmc6IDAuNDUsXG4gICAgbWFzczogMTBcbiAgfTtcblxuICB2YXIgSVRFTV9TQ0FMRV9TUFJJTkcgPSAnc3ByaW5nJztcblxuICB2YXIgU3RhdGVNYXAgPSB7XG4gICAgRElEX1NUQVJUX0lURU1fTE9BRDogJ2J1c3knLFxuICAgIERJRF9VUERBVEVfSVRFTV9MT0FEX1BST0dSRVNTOiAnbG9hZGluZycsXG4gICAgRElEX1RIUk9XX0lURU1fSU5WQUxJRDogJ2xvYWQtaW52YWxpZCcsXG4gICAgRElEX1RIUk9XX0lURU1fTE9BRF9FUlJPUjogJ2xvYWQtZXJyb3InLFxuICAgIERJRF9MT0FEX0lURU06ICdpZGxlJyxcbiAgICBESURfVEhST1dfSVRFTV9SRU1PVkVfRVJST1I6ICdyZW1vdmUtZXJyb3InLFxuICAgIERJRF9TVEFSVF9JVEVNX1JFTU9WRTogJ2J1c3knLFxuICAgIERJRF9TVEFSVF9JVEVNX1BST0NFU1NJTkc6ICdidXN5IHByb2Nlc3NpbmcnLFxuICAgIERJRF9SRVFVRVNUX0lURU1fUFJPQ0VTU0lORzogJ2J1c3kgcHJvY2Vzc2luZycsXG4gICAgRElEX1VQREFURV9JVEVNX1BST0NFU1NfUFJPR1JFU1M6ICdwcm9jZXNzaW5nJyxcbiAgICBESURfQ09NUExFVEVfSVRFTV9QUk9DRVNTSU5HOiAncHJvY2Vzc2luZy1jb21wbGV0ZScsXG4gICAgRElEX1RIUk9XX0lURU1fUFJPQ0VTU0lOR19FUlJPUjogJ3Byb2Nlc3NpbmctZXJyb3InLFxuICAgIERJRF9USFJPV19JVEVNX1BST0NFU1NJTkdfUkVWRVJUX0VSUk9SOiAncHJvY2Vzc2luZy1yZXZlcnQtZXJyb3InLFxuICAgIERJRF9BQk9SVF9JVEVNX1BST0NFU1NJTkc6ICdjYW5jZWxsZWQnLFxuICAgIERJRF9SRVZFUlRfSVRFTV9QUk9DRVNTSU5HOiAnaWRsZSdcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlcyB0aGUgZmlsZSB2aWV3XG4gICAqL1xuICB2YXIgY3JlYXRlJDcgPSBmdW5jdGlvbiBjcmVhdGUoX3JlZikge1xuICAgIHZhciByb290ID0gX3JlZi5yb290LFxuICAgICAgcHJvcHMgPSBfcmVmLnByb3BzO1xuXG4gICAgLy8gc2VsZWN0XG4gICAgcm9vdC5yZWYuaGFuZGxlQ2xpY2sgPSBmdW5jdGlvbihlKSB7XG4gICAgICByZXR1cm4gcm9vdC5kaXNwYXRjaCgnRElEX0FDVElWQVRFX0lURU0nLCB7IGlkOiBwcm9wcy5pZCB9KTtcbiAgICB9O1xuXG4gICAgLy8gc2V0IGlkXG4gICAgcm9vdC5lbGVtZW50LmlkID0gJ2ZpbGVwb25kLS1pdGVtLScgKyBwcm9wcy5pZDtcbiAgICByb290LmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCByb290LnJlZi5oYW5kbGVDbGljayk7XG5cbiAgICAvLyBmaWxlIHZpZXdcbiAgICByb290LnJlZi5jb250YWluZXIgPSByb290LmFwcGVuZENoaWxkVmlldyhcbiAgICAgIHJvb3QuY3JlYXRlQ2hpbGRWaWV3KGZpbGVXcmFwcGVyLCB7IGlkOiBwcm9wcy5pZCB9KVxuICAgICk7XG5cbiAgICAvLyBmaWxlIHBhbmVsXG4gICAgcm9vdC5yZWYucGFuZWwgPSByb290LmFwcGVuZENoaWxkVmlldyhcbiAgICAgIHJvb3QuY3JlYXRlQ2hpbGRWaWV3KHBhbmVsLCB7IG5hbWU6ICdpdGVtLXBhbmVsJyB9KVxuICAgICk7XG5cbiAgICAvLyBkZWZhdWx0IHN0YXJ0IGhlaWdodFxuICAgIHJvb3QucmVmLnBhbmVsLmhlaWdodCA9IG51bGw7XG5cbiAgICAvLyBieSBkZWZhdWx0IG5vdCBtYXJrZWQgZm9yIHJlbW92YWxcbiAgICBwcm9wcy5tYXJrZWRGb3JSZW1vdmFsID0gZmFsc2U7XG5cbiAgICAvLyBpZiBub3QgYWxsb3dlZCB0byByZW9yZGVyIGZpbGUgaXRlbXMsIGV4aXQgaGVyZVxuICAgIGlmICghcm9vdC5xdWVyeSgnR0VUX0FMTE9XX1JFT1JERVInKSkgcmV0dXJuO1xuXG4gICAgLy8gc2V0IHRvIGlkbGUgc28gc2hvd3MgZ3JhYiBjdXJzb3JcbiAgICByb290LmVsZW1lbnQuZGF0YXNldC5kcmFnU3RhdGUgPSAnaWRsZSc7XG5cbiAgICB2YXIgZ3JhYiA9IGZ1bmN0aW9uIGdyYWIoZSkge1xuICAgICAgaWYgKCFlLmlzUHJpbWFyeSkgcmV0dXJuO1xuXG4gICAgICB2YXIgcmVtb3ZlZEFjdGl2YXRlTGlzdGVuZXIgPSBmYWxzZTtcblxuICAgICAgdmFyIG9yaWdpbiA9IHtcbiAgICAgICAgeDogZS5wYWdlWCxcbiAgICAgICAgeTogZS5wYWdlWVxuICAgICAgfTtcblxuICAgICAgcHJvcHMuZHJhZ09yaWdpbiA9IHtcbiAgICAgICAgeDogcm9vdC50cmFuc2xhdGVYLFxuICAgICAgICB5OiByb290LnRyYW5zbGF0ZVlcbiAgICAgIH07XG5cbiAgICAgIHByb3BzLmRyYWdDZW50ZXIgPSB7XG4gICAgICAgIHg6IGUub2Zmc2V0WCxcbiAgICAgICAgeTogZS5vZmZzZXRZXG4gICAgICB9O1xuXG4gICAgICB2YXIgZHJhZ1N0YXRlID0gY3JlYXRlRHJhZ0hlbHBlcihyb290LnF1ZXJ5KCdHRVRfQUNUSVZFX0lURU1TJykpO1xuXG4gICAgICByb290LmRpc3BhdGNoKCdESURfR1JBQl9JVEVNJywgeyBpZDogcHJvcHMuaWQsIGRyYWdTdGF0ZTogZHJhZ1N0YXRlIH0pO1xuXG4gICAgICB2YXIgZHJhZyA9IGZ1bmN0aW9uIGRyYWcoZSkge1xuICAgICAgICBpZiAoIWUuaXNQcmltYXJ5KSByZXR1cm47XG5cbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIHByb3BzLmRyYWdPZmZzZXQgPSB7XG4gICAgICAgICAgeDogZS5wYWdlWCAtIG9yaWdpbi54LFxuICAgICAgICAgIHk6IGUucGFnZVkgLSBvcmlnaW4ueVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGlmIGRyYWdnZWQgc3RvcCBsaXN0ZW5pbmcgdG8gY2xpY2tzLCB3aWxsIHJlLWFkZCB3aGVuIGRvbmUgZHJhZ2dpbmdcbiAgICAgICAgdmFyIGRpc3QgPVxuICAgICAgICAgIHByb3BzLmRyYWdPZmZzZXQueCAqIHByb3BzLmRyYWdPZmZzZXQueCArXG4gICAgICAgICAgcHJvcHMuZHJhZ09mZnNldC55ICogcHJvcHMuZHJhZ09mZnNldC55O1xuICAgICAgICBpZiAoZGlzdCA+IDE2ICYmICFyZW1vdmVkQWN0aXZhdGVMaXN0ZW5lcikge1xuICAgICAgICAgIHJlbW92ZWRBY3RpdmF0ZUxpc3RlbmVyID0gdHJ1ZTtcbiAgICAgICAgICByb290LmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCByb290LnJlZi5oYW5kbGVDbGljayk7XG4gICAgICAgIH1cblxuICAgICAgICByb290LmRpc3BhdGNoKCdESURfRFJBR19JVEVNJywgeyBpZDogcHJvcHMuaWQsIGRyYWdTdGF0ZTogZHJhZ1N0YXRlIH0pO1xuICAgICAgfTtcblxuICAgICAgdmFyIGRyb3AgPSBmdW5jdGlvbiBkcm9wKGUpIHtcbiAgICAgICAgaWYgKCFlLmlzUHJpbWFyeSkgcmV0dXJuO1xuXG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJtb3ZlJywgZHJhZyk7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJ1cCcsIGRyb3ApO1xuXG4gICAgICAgIHByb3BzLmRyYWdPZmZzZXQgPSB7XG4gICAgICAgICAgeDogZS5wYWdlWCAtIG9yaWdpbi54LFxuICAgICAgICAgIHk6IGUucGFnZVkgLSBvcmlnaW4ueVxuICAgICAgICB9O1xuXG4gICAgICAgIHJvb3QuZGlzcGF0Y2goJ0RJRF9EUk9QX0lURU0nLCB7IGlkOiBwcm9wcy5pZCwgZHJhZ1N0YXRlOiBkcmFnU3RhdGUgfSk7XG5cbiAgICAgICAgLy8gc3RhcnQgbGlzdGVuaW5nIHRvIGNsaWNrcyBhZ2FpblxuICAgICAgICBpZiAocmVtb3ZlZEFjdGl2YXRlTGlzdGVuZXIpIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHJvb3QuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHJvb3QucmVmLmhhbmRsZUNsaWNrKTtcbiAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcm1vdmUnLCBkcmFnKTtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJ1cCcsIGRyb3ApO1xuICAgIH07XG5cbiAgICByb290LmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcmRvd24nLCBncmFiKTtcbiAgfTtcblxuICB2YXIgcm91dGUkMSA9IGNyZWF0ZVJvdXRlKHtcbiAgICBESURfVVBEQVRFX1BBTkVMX0hFSUdIVDogZnVuY3Rpb24gRElEX1VQREFURV9QQU5FTF9IRUlHSFQoX3JlZjIpIHtcbiAgICAgIHZhciByb290ID0gX3JlZjIucm9vdCxcbiAgICAgICAgYWN0aW9uID0gX3JlZjIuYWN0aW9uO1xuICAgICAgcm9vdC5oZWlnaHQgPSBhY3Rpb24uaGVpZ2h0O1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIHdyaXRlJDQgPSBjcmVhdGVSb3V0ZShcbiAgICB7XG4gICAgICBESURfR1JBQl9JVEVNOiBmdW5jdGlvbiBESURfR1JBQl9JVEVNKF9yZWYzKSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZjMucm9vdCxcbiAgICAgICAgICBwcm9wcyA9IF9yZWYzLnByb3BzO1xuICAgICAgICBwcm9wcy5kcmFnT3JpZ2luID0ge1xuICAgICAgICAgIHg6IHJvb3QudHJhbnNsYXRlWCxcbiAgICAgICAgICB5OiByb290LnRyYW5zbGF0ZVlcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBESURfRFJBR19JVEVNOiBmdW5jdGlvbiBESURfRFJBR19JVEVNKF9yZWY0KSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZjQucm9vdDtcbiAgICAgICAgcm9vdC5lbGVtZW50LmRhdGFzZXQuZHJhZ1N0YXRlID0gJ2RyYWcnO1xuICAgICAgfSxcbiAgICAgIERJRF9EUk9QX0lURU06IGZ1bmN0aW9uIERJRF9EUk9QX0lURU0oX3JlZjUpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmNS5yb290LFxuICAgICAgICAgIHByb3BzID0gX3JlZjUucHJvcHM7XG4gICAgICAgIHByb3BzLmRyYWdPZmZzZXQgPSBudWxsO1xuICAgICAgICBwcm9wcy5kcmFnT3JpZ2luID0gbnVsbDtcbiAgICAgICAgcm9vdC5lbGVtZW50LmRhdGFzZXQuZHJhZ1N0YXRlID0gJ2Ryb3AnO1xuICAgICAgfVxuICAgIH0sXG4gICAgZnVuY3Rpb24oX3JlZjYpIHtcbiAgICAgIHZhciByb290ID0gX3JlZjYucm9vdCxcbiAgICAgICAgYWN0aW9ucyA9IF9yZWY2LmFjdGlvbnMsXG4gICAgICAgIHByb3BzID0gX3JlZjYucHJvcHMsXG4gICAgICAgIHNob3VsZE9wdGltaXplID0gX3JlZjYuc2hvdWxkT3B0aW1pemU7XG5cbiAgICAgIGlmIChyb290LmVsZW1lbnQuZGF0YXNldC5kcmFnU3RhdGUgPT09ICdkcm9wJykge1xuICAgICAgICBpZiAocm9vdC5zY2FsZVggPD0gMSkge1xuICAgICAgICAgIHJvb3QuZWxlbWVudC5kYXRhc2V0LmRyYWdTdGF0ZSA9ICdpZGxlJztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBzZWxlY3QgbGFzdCBzdGF0ZSBjaGFuZ2UgYWN0aW9uXG4gICAgICB2YXIgYWN0aW9uID0gYWN0aW9uc1xuICAgICAgICAuY29uY2F0KClcbiAgICAgICAgLmZpbHRlcihmdW5jdGlvbihhY3Rpb24pIHtcbiAgICAgICAgICByZXR1cm4gL15ESURfLy50ZXN0KGFjdGlvbi50eXBlKTtcbiAgICAgICAgfSlcbiAgICAgICAgLnJldmVyc2UoKVxuICAgICAgICAuZmluZChmdW5jdGlvbihhY3Rpb24pIHtcbiAgICAgICAgICByZXR1cm4gU3RhdGVNYXBbYWN0aW9uLnR5cGVdO1xuICAgICAgICB9KTtcblxuICAgICAgLy8gbm8gbmVlZCB0byBzZXQgc2FtZSBzdGF0ZSB0d2ljZVxuICAgICAgaWYgKGFjdGlvbiAmJiBhY3Rpb24udHlwZSAhPT0gcHJvcHMuY3VycmVudFN0YXRlKSB7XG4gICAgICAgIC8vIHNldCBjdXJyZW50IHN0YXRlXG4gICAgICAgIHByb3BzLmN1cnJlbnRTdGF0ZSA9IGFjdGlvbi50eXBlO1xuXG4gICAgICAgIC8vIHNldCBzdGF0ZVxuICAgICAgICByb290LmVsZW1lbnQuZGF0YXNldC5maWxlcG9uZEl0ZW1TdGF0ZSA9XG4gICAgICAgICAgU3RhdGVNYXBbcHJvcHMuY3VycmVudFN0YXRlXSB8fCAnJztcbiAgICAgIH1cblxuICAgICAgLy8gcm91dGUgYWN0aW9uc1xuICAgICAgdmFyIGFzcGVjdFJhdGlvID1cbiAgICAgICAgcm9vdC5xdWVyeSgnR0VUX0lURU1fUEFORUxfQVNQRUNUX1JBVElPJykgfHxcbiAgICAgICAgcm9vdC5xdWVyeSgnR0VUX1BBTkVMX0FTUEVDVF9SQVRJTycpO1xuICAgICAgaWYgKCFhc3BlY3RSYXRpbykge1xuICAgICAgICByb3V0ZSQxKHsgcm9vdDogcm9vdCwgYWN0aW9uczogYWN0aW9ucywgcHJvcHM6IHByb3BzIH0pO1xuICAgICAgICBpZiAoIXJvb3QuaGVpZ2h0ICYmIHJvb3QucmVmLmNvbnRhaW5lci5yZWN0LmVsZW1lbnQuaGVpZ2h0ID4gMCkge1xuICAgICAgICAgIHJvb3QuaGVpZ2h0ID0gcm9vdC5yZWYuY29udGFpbmVyLnJlY3QuZWxlbWVudC5oZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIXNob3VsZE9wdGltaXplKSB7XG4gICAgICAgIHJvb3QuaGVpZ2h0ID0gcm9vdC5yZWN0LmVsZW1lbnQud2lkdGggKiBhc3BlY3RSYXRpbztcbiAgICAgIH1cblxuICAgICAgLy8gc3luYyBwYW5lbCBoZWlnaHQgd2l0aCBpdGVtIGhlaWdodFxuICAgICAgaWYgKHNob3VsZE9wdGltaXplKSB7XG4gICAgICAgIHJvb3QucmVmLnBhbmVsLmhlaWdodCA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJvb3QucmVmLnBhbmVsLmhlaWdodCA9IHJvb3QuaGVpZ2h0O1xuICAgIH1cbiAgKTtcblxuICB2YXIgaXRlbSA9IGNyZWF0ZVZpZXcoe1xuICAgIGNyZWF0ZTogY3JlYXRlJDcsXG4gICAgd3JpdGU6IHdyaXRlJDQsXG4gICAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveShfcmVmNykge1xuICAgICAgdmFyIHJvb3QgPSBfcmVmNy5yb290LFxuICAgICAgICBwcm9wcyA9IF9yZWY3LnByb3BzO1xuICAgICAgcm9vdC5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgcm9vdC5yZWYuaGFuZGxlQ2xpY2spO1xuICAgICAgcm9vdC5kaXNwYXRjaCgnUkVMRUFTRV9JVEVNJywgeyBxdWVyeTogcHJvcHMuaWQgfSk7XG4gICAgfSxcbiAgICB0YWc6ICdsaScsXG4gICAgbmFtZTogJ2l0ZW0nLFxuICAgIG1peGluczoge1xuICAgICAgYXBpczogW1xuICAgICAgICAnaWQnLFxuICAgICAgICAnaW50ZXJhY3Rpb25NZXRob2QnLFxuICAgICAgICAnbWFya2VkRm9yUmVtb3ZhbCcsXG4gICAgICAgICdzcGF3bkRhdGUnLFxuICAgICAgICAnZHJhZ0NlbnRlcicsXG4gICAgICAgICdkcmFnT3JpZ2luJyxcbiAgICAgICAgJ2RyYWdPZmZzZXQnXG4gICAgICBdLFxuICAgICAgc3R5bGVzOiBbXG4gICAgICAgICd0cmFuc2xhdGVYJyxcbiAgICAgICAgJ3RyYW5zbGF0ZVknLFxuICAgICAgICAnc2NhbGVYJyxcbiAgICAgICAgJ3NjYWxlWScsXG4gICAgICAgICdvcGFjaXR5JyxcbiAgICAgICAgJ2hlaWdodCdcbiAgICAgIF0sXG5cbiAgICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgICAgc2NhbGVYOiBJVEVNX1NDQUxFX1NQUklORyxcbiAgICAgICAgc2NhbGVZOiBJVEVNX1NDQUxFX1NQUklORyxcbiAgICAgICAgdHJhbnNsYXRlWDogSVRFTV9UUkFOU0xBVEVfU1BSSU5HLFxuICAgICAgICB0cmFuc2xhdGVZOiBJVEVNX1RSQU5TTEFURV9TUFJJTkcsXG4gICAgICAgIG9wYWNpdHk6IHsgdHlwZTogJ3R3ZWVuJywgZHVyYXRpb246IDE1MCB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICB2YXIgZ2V0SXRlbUluZGV4QnlQb3NpdGlvbiA9IGZ1bmN0aW9uIGdldEl0ZW1JbmRleEJ5UG9zaXRpb24oXG4gICAgdmlldyxcbiAgICBjaGlsZHJlbixcbiAgICBwb3NpdGlvbkluVmlld1xuICApIHtcbiAgICBpZiAoIXBvc2l0aW9uSW5WaWV3KSByZXR1cm47XG5cbiAgICB2YXIgaG9yaXpvbnRhbFNwYWNlID0gdmlldy5yZWN0LmVsZW1lbnQud2lkdGg7XG4gICAgLy8gY29uc3QgY2hpbGRyZW4gPSB2aWV3LmNoaWxkVmlld3M7XG4gICAgdmFyIGwgPSBjaGlsZHJlbi5sZW5ndGg7XG4gICAgdmFyIGxhc3QgPSBudWxsO1xuXG4gICAgLy8gLTEsIGRvbid0IG1vdmUgaXRlbXMgdG8gYWNjb21vZGF0ZSAoZWl0aGVyIGFkZCB0byB0b3Agb3IgYm90dG9tKVxuICAgIGlmIChsID09PSAwIHx8IHBvc2l0aW9uSW5WaWV3LnRvcCA8IGNoaWxkcmVuWzBdLnJlY3QuZWxlbWVudC50b3ApIHJldHVybiAtMTtcblxuICAgIC8vIGxldCdzIGdldCB0aGUgaXRlbSB3aWR0aFxuICAgIHZhciBpdGVtID0gY2hpbGRyZW5bMF07XG4gICAgdmFyIGl0ZW1SZWN0ID0gaXRlbS5yZWN0LmVsZW1lbnQ7XG4gICAgdmFyIGl0ZW1Ib3Jpem9udGFsTWFyZ2luID0gaXRlbVJlY3QubWFyZ2luTGVmdCArIGl0ZW1SZWN0Lm1hcmdpblJpZ2h0O1xuICAgIHZhciBpdGVtV2lkdGggPSBpdGVtUmVjdC53aWR0aCArIGl0ZW1Ib3Jpem9udGFsTWFyZ2luO1xuICAgIHZhciBpdGVtc1BlclJvdyA9IE1hdGgucm91bmQoaG9yaXpvbnRhbFNwYWNlIC8gaXRlbVdpZHRoKTtcblxuICAgIC8vIHN0YWNrXG4gICAgaWYgKGl0ZW1zUGVyUm93ID09PSAxKSB7XG4gICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbDsgaW5kZXgrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpbmRleF07XG4gICAgICAgIHZhciBjaGlsZE1pZCA9IGNoaWxkLnJlY3Qub3V0ZXIudG9wICsgY2hpbGQucmVjdC5lbGVtZW50LmhlaWdodCAqIDAuNTtcbiAgICAgICAgaWYgKHBvc2l0aW9uSW5WaWV3LnRvcCA8IGNoaWxkTWlkKSB7XG4gICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbDtcbiAgICB9XG5cbiAgICAvLyBncmlkXG4gICAgdmFyIGl0ZW1WZXJ0aWNhbE1hcmdpbiA9IGl0ZW1SZWN0Lm1hcmdpblRvcCArIGl0ZW1SZWN0Lm1hcmdpbkJvdHRvbTtcbiAgICB2YXIgaXRlbUhlaWdodCA9IGl0ZW1SZWN0LmhlaWdodCArIGl0ZW1WZXJ0aWNhbE1hcmdpbjtcbiAgICBmb3IgKHZhciBfaW5kZXggPSAwOyBfaW5kZXggPCBsOyBfaW5kZXgrKykge1xuICAgICAgdmFyIGluZGV4WCA9IF9pbmRleCAlIGl0ZW1zUGVyUm93O1xuICAgICAgdmFyIGluZGV4WSA9IE1hdGguZmxvb3IoX2luZGV4IC8gaXRlbXNQZXJSb3cpO1xuXG4gICAgICB2YXIgb2Zmc2V0WCA9IGluZGV4WCAqIGl0ZW1XaWR0aDtcbiAgICAgIHZhciBvZmZzZXRZID0gaW5kZXhZICogaXRlbUhlaWdodDtcblxuICAgICAgdmFyIGl0ZW1Ub3AgPSBvZmZzZXRZIC0gaXRlbVJlY3QubWFyZ2luVG9wO1xuICAgICAgdmFyIGl0ZW1SaWdodCA9IG9mZnNldFggKyBpdGVtV2lkdGg7XG4gICAgICB2YXIgaXRlbUJvdHRvbSA9IG9mZnNldFkgKyBpdGVtSGVpZ2h0ICsgaXRlbVJlY3QubWFyZ2luQm90dG9tO1xuXG4gICAgICBpZiAocG9zaXRpb25JblZpZXcudG9wIDwgaXRlbUJvdHRvbSAmJiBwb3NpdGlvbkluVmlldy50b3AgPiBpdGVtVG9wKSB7XG4gICAgICAgIGlmIChwb3NpdGlvbkluVmlldy5sZWZ0IDwgaXRlbVJpZ2h0KSB7XG4gICAgICAgICAgcmV0dXJuIF9pbmRleDtcbiAgICAgICAgfSBlbHNlIGlmIChfaW5kZXggIT09IGwgLSAxKSB7XG4gICAgICAgICAgbGFzdCA9IF9pbmRleDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsYXN0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChsYXN0ICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbGFzdDtcbiAgICB9XG5cbiAgICByZXR1cm4gbDtcbiAgfTtcblxuICB2YXIgZHJvcEFyZWFEaW1lbnNpb25zID0ge1xuICAgIGhlaWdodDogMCxcbiAgICB3aWR0aDogMCxcbiAgICBnZXQgZ2V0SGVpZ2h0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuaGVpZ2h0O1xuICAgIH0sXG4gICAgc2V0IHNldEhlaWdodCh2YWwpIHtcbiAgICAgIGlmICh0aGlzLmhlaWdodCA9PT0gMCB8fCB2YWwgPT09IDApIHRoaXMuaGVpZ2h0ID0gdmFsO1xuICAgIH0sXG4gICAgZ2V0IGdldFdpZHRoKCkge1xuICAgICAgcmV0dXJuIHRoaXMud2lkdGg7XG4gICAgfSxcbiAgICBzZXQgc2V0V2lkdGgodmFsKSB7XG4gICAgICBpZiAodGhpcy53aWR0aCA9PT0gMCB8fCB2YWwgPT09IDApIHRoaXMud2lkdGggPSB2YWw7XG4gICAgfSxcbiAgICBzZXREaW1lbnNpb25zOiBmdW5jdGlvbiBzZXREaW1lbnNpb25zKGhlaWdodCwgd2lkdGgpIHtcbiAgICAgIGlmICh0aGlzLmhlaWdodCA9PT0gMCB8fCBoZWlnaHQgPT09IDApIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgaWYgKHRoaXMud2lkdGggPT09IDAgfHwgd2lkdGggPT09IDApIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGNyZWF0ZSQ4ID0gZnVuY3Rpb24gY3JlYXRlKF9yZWYpIHtcbiAgICB2YXIgcm9vdCA9IF9yZWYucm9vdDtcbiAgICAvLyBuZWVkIHRvIHNldCByb2xlIHRvIGxpc3QgYXMgb3RoZXJ3aXNlIGl0IHdvbid0IGJlIHJlYWQgYXMgYSBsaXN0IGJ5IFZvaWNlT3ZlclxuICAgIGF0dHIocm9vdC5lbGVtZW50LCAncm9sZScsICdsaXN0Jyk7XG5cbiAgICByb290LnJlZi5sYXN0SXRlbVNwYW53RGF0ZSA9IERhdGUubm93KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEluc2VydHMgYSBuZXcgaXRlbVxuICAgKiBAcGFyYW0gcm9vdFxuICAgKiBAcGFyYW0gYWN0aW9uXG4gICAqL1xuICB2YXIgYWRkSXRlbVZpZXcgPSBmdW5jdGlvbiBhZGRJdGVtVmlldyhfcmVmMikge1xuICAgIHZhciByb290ID0gX3JlZjIucm9vdCxcbiAgICAgIGFjdGlvbiA9IF9yZWYyLmFjdGlvbjtcbiAgICB2YXIgaWQgPSBhY3Rpb24uaWQsXG4gICAgICBpbmRleCA9IGFjdGlvbi5pbmRleCxcbiAgICAgIGludGVyYWN0aW9uTWV0aG9kID0gYWN0aW9uLmludGVyYWN0aW9uTWV0aG9kO1xuXG4gICAgcm9vdC5yZWYuYWRkSW5kZXggPSBpbmRleDtcblxuICAgIHZhciBub3cgPSBEYXRlLm5vdygpO1xuICAgIHZhciBzcGF3bkRhdGUgPSBub3c7XG4gICAgdmFyIG9wYWNpdHkgPSAxO1xuXG4gICAgaWYgKGludGVyYWN0aW9uTWV0aG9kICE9PSBJbnRlcmFjdGlvbk1ldGhvZC5OT05FKSB7XG4gICAgICBvcGFjaXR5ID0gMDtcbiAgICAgIHZhciBjb29sZG93biA9IHJvb3QucXVlcnkoJ0dFVF9JVEVNX0lOU0VSVF9JTlRFUlZBTCcpO1xuICAgICAgdmFyIGRpc3QgPSBub3cgLSByb290LnJlZi5sYXN0SXRlbVNwYW53RGF0ZTtcbiAgICAgIHNwYXduRGF0ZSA9IGRpc3QgPCBjb29sZG93biA/IG5vdyArIChjb29sZG93biAtIGRpc3QpIDogbm93O1xuICAgIH1cblxuICAgIHJvb3QucmVmLmxhc3RJdGVtU3BhbndEYXRlID0gc3Bhd25EYXRlO1xuXG4gICAgcm9vdC5hcHBlbmRDaGlsZFZpZXcoXG4gICAgICByb290LmNyZWF0ZUNoaWxkVmlldyhcbiAgICAgICAgLy8gdmlldyB0eXBlXG4gICAgICAgIGl0ZW0sXG5cbiAgICAgICAgLy8gcHJvcHNcbiAgICAgICAge1xuICAgICAgICAgIHNwYXduRGF0ZTogc3Bhd25EYXRlLFxuICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICBvcGFjaXR5OiBvcGFjaXR5LFxuICAgICAgICAgIGludGVyYWN0aW9uTWV0aG9kOiBpbnRlcmFjdGlvbk1ldGhvZFxuICAgICAgICB9XG4gICAgICApLFxuXG4gICAgICBpbmRleFxuICAgICk7XG4gIH07XG5cbiAgdmFyIG1vdmVJdGVtID0gZnVuY3Rpb24gbW92ZUl0ZW0oaXRlbSwgeCwgeSkge1xuICAgIHZhciB2eCA9XG4gICAgICBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IDA7XG4gICAgdmFyIHZ5ID1cbiAgICAgIGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogMTtcblxuICAgIC8vIHNldCB0byBudWxsIHRvIHJlbW92ZSBhbmltYXRpb24gd2hpbGUgZHJhZ2dpbmdcbiAgICBpZiAoaXRlbS5kcmFnT2Zmc2V0KSB7XG4gICAgICBpdGVtLnRyYW5zbGF0ZVggPSBudWxsO1xuICAgICAgaXRlbS50cmFuc2xhdGVZID0gbnVsbDtcbiAgICAgIGl0ZW0udHJhbnNsYXRlWCA9IGl0ZW0uZHJhZ09yaWdpbi54ICsgaXRlbS5kcmFnT2Zmc2V0Lng7XG4gICAgICBpdGVtLnRyYW5zbGF0ZVkgPSBpdGVtLmRyYWdPcmlnaW4ueSArIGl0ZW0uZHJhZ09mZnNldC55O1xuICAgICAgaXRlbS5zY2FsZVggPSAxLjAyNTtcbiAgICAgIGl0ZW0uc2NhbGVZID0gMS4wMjU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGl0ZW0udHJhbnNsYXRlWCA9IHg7XG4gICAgICBpdGVtLnRyYW5zbGF0ZVkgPSB5O1xuXG4gICAgICBpZiAoRGF0ZS5ub3coKSA+IGl0ZW0uc3Bhd25EYXRlKSB7XG4gICAgICAgIC8vIHJldmVhbCBlbGVtZW50XG4gICAgICAgIGlmIChpdGVtLm9wYWNpdHkgPT09IDApIHtcbiAgICAgICAgICBpbnRyb0l0ZW1WaWV3KGl0ZW0sIHgsIHksIHZ4LCB2eSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBtYWtlIHN1cmUgaXMgZGVmYXVsdCBzY2FsZSBldmVyeSBmcmFtZVxuICAgICAgICBpdGVtLnNjYWxlWCA9IDE7XG4gICAgICAgIGl0ZW0uc2NhbGVZID0gMTtcbiAgICAgICAgaXRlbS5vcGFjaXR5ID0gMTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFyIGludHJvSXRlbVZpZXcgPSBmdW5jdGlvbiBpbnRyb0l0ZW1WaWV3KGl0ZW0sIHgsIHksIHZ4LCB2eSkge1xuICAgIGlmIChpdGVtLmludGVyYWN0aW9uTWV0aG9kID09PSBJbnRlcmFjdGlvbk1ldGhvZC5OT05FKSB7XG4gICAgICBpdGVtLnRyYW5zbGF0ZVggPSBudWxsO1xuICAgICAgaXRlbS50cmFuc2xhdGVYID0geDtcbiAgICAgIGl0ZW0udHJhbnNsYXRlWSA9IG51bGw7XG4gICAgICBpdGVtLnRyYW5zbGF0ZVkgPSB5O1xuICAgIH0gZWxzZSBpZiAoaXRlbS5pbnRlcmFjdGlvbk1ldGhvZCA9PT0gSW50ZXJhY3Rpb25NZXRob2QuRFJPUCkge1xuICAgICAgaXRlbS50cmFuc2xhdGVYID0gbnVsbDtcbiAgICAgIGl0ZW0udHJhbnNsYXRlWCA9IHggLSB2eCAqIDIwO1xuXG4gICAgICBpdGVtLnRyYW5zbGF0ZVkgPSBudWxsO1xuICAgICAgaXRlbS50cmFuc2xhdGVZID0geSAtIHZ5ICogMTA7XG5cbiAgICAgIGl0ZW0uc2NhbGVYID0gMC44O1xuICAgICAgaXRlbS5zY2FsZVkgPSAwLjg7XG4gICAgfSBlbHNlIGlmIChpdGVtLmludGVyYWN0aW9uTWV0aG9kID09PSBJbnRlcmFjdGlvbk1ldGhvZC5CUk9XU0UpIHtcbiAgICAgIGl0ZW0udHJhbnNsYXRlWSA9IG51bGw7XG4gICAgICBpdGVtLnRyYW5zbGF0ZVkgPSB5IC0gMzA7XG4gICAgfSBlbHNlIGlmIChpdGVtLmludGVyYWN0aW9uTWV0aG9kID09PSBJbnRlcmFjdGlvbk1ldGhvZC5BUEkpIHtcbiAgICAgIGl0ZW0udHJhbnNsYXRlWCA9IG51bGw7XG4gICAgICBpdGVtLnRyYW5zbGF0ZVggPSB4IC0gMzA7XG4gICAgICBpdGVtLnRyYW5zbGF0ZVkgPSBudWxsO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlcyBhbiBleGlzdGluZyBpdGVtXG4gICAqIEBwYXJhbSByb290XG4gICAqIEBwYXJhbSBhY3Rpb25cbiAgICovXG4gIHZhciByZW1vdmVJdGVtVmlldyA9IGZ1bmN0aW9uIHJlbW92ZUl0ZW1WaWV3KF9yZWYzKSB7XG4gICAgdmFyIHJvb3QgPSBfcmVmMy5yb290LFxuICAgICAgYWN0aW9uID0gX3JlZjMuYWN0aW9uO1xuICAgIHZhciBpZCA9IGFjdGlvbi5pZDtcblxuICAgIC8vIGdldCB0aGUgdmlldyBtYXRjaGluZyB0aGUgZ2l2ZW4gaWRcbiAgICB2YXIgdmlldyA9IHJvb3QuY2hpbGRWaWV3cy5maW5kKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICByZXR1cm4gY2hpbGQuaWQgPT09IGlkO1xuICAgIH0pO1xuXG4gICAgLy8gaWYgbm8gdmlldyBmb3VuZCwgZXhpdFxuICAgIGlmICghdmlldykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGFuaW1hdGUgdmlldyBvdXQgb2Ygdmlld1xuICAgIHZpZXcuc2NhbGVYID0gMC45O1xuICAgIHZpZXcuc2NhbGVZID0gMC45O1xuICAgIHZpZXcub3BhY2l0eSA9IDA7XG5cbiAgICAvLyBtYXJrIGZvciByZW1vdmFsXG4gICAgdmlldy5tYXJrZWRGb3JSZW1vdmFsID0gdHJ1ZTtcbiAgfTtcblxuICB2YXIgZ2V0SXRlbUhlaWdodCA9IGZ1bmN0aW9uIGdldEl0ZW1IZWlnaHQoY2hpbGQpIHtcbiAgICByZXR1cm4gKFxuICAgICAgY2hpbGQucmVjdC5lbGVtZW50LmhlaWdodCArXG4gICAgICBjaGlsZC5yZWN0LmVsZW1lbnQubWFyZ2luQm90dG9tICogMC41ICtcbiAgICAgIGNoaWxkLnJlY3QuZWxlbWVudC5tYXJnaW5Ub3AgKiAwLjVcbiAgICApO1xuICB9O1xuICB2YXIgZ2V0SXRlbVdpZHRoID0gZnVuY3Rpb24gZ2V0SXRlbVdpZHRoKGNoaWxkKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIGNoaWxkLnJlY3QuZWxlbWVudC53aWR0aCArXG4gICAgICBjaGlsZC5yZWN0LmVsZW1lbnQubWFyZ2luTGVmdCAqIDAuNSArXG4gICAgICBjaGlsZC5yZWN0LmVsZW1lbnQubWFyZ2luUmlnaHQgKiAwLjVcbiAgICApO1xuICB9O1xuXG4gIHZhciBkcmFnSXRlbSA9IGZ1bmN0aW9uIGRyYWdJdGVtKF9yZWY0KSB7XG4gICAgdmFyIHJvb3QgPSBfcmVmNC5yb290LFxuICAgICAgYWN0aW9uID0gX3JlZjQuYWN0aW9uO1xuICAgIHZhciBpZCA9IGFjdGlvbi5pZCxcbiAgICAgIGRyYWdTdGF0ZSA9IGFjdGlvbi5kcmFnU3RhdGU7XG5cbiAgICAvLyByZWZlcmVuY2UgdG8gaXRlbVxuICAgIHZhciBpdGVtID0gcm9vdC5xdWVyeSgnR0VUX0lURU0nLCB7IGlkOiBpZCB9KTtcblxuICAgIC8vIGdldCB0aGUgdmlldyBtYXRjaGluZyB0aGUgZ2l2ZW4gaWRcbiAgICB2YXIgdmlldyA9IHJvb3QuY2hpbGRWaWV3cy5maW5kKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICByZXR1cm4gY2hpbGQuaWQgPT09IGlkO1xuICAgIH0pO1xuXG4gICAgdmFyIG51bUl0ZW1zID0gcm9vdC5jaGlsZFZpZXdzLmxlbmd0aDtcbiAgICB2YXIgb2xkSW5kZXggPSBkcmFnU3RhdGUuZ2V0SXRlbUluZGV4KGl0ZW0pO1xuXG4gICAgLy8gaWYgbm8gdmlldyBmb3VuZCwgZXhpdFxuICAgIGlmICghdmlldykgcmV0dXJuO1xuXG4gICAgdmFyIGRyYWdQb3NpdGlvbiA9IHtcbiAgICAgIHg6IHZpZXcuZHJhZ09yaWdpbi54ICsgdmlldy5kcmFnT2Zmc2V0LnggKyB2aWV3LmRyYWdDZW50ZXIueCxcbiAgICAgIHk6IHZpZXcuZHJhZ09yaWdpbi55ICsgdmlldy5kcmFnT2Zmc2V0LnkgKyB2aWV3LmRyYWdDZW50ZXIueVxuXG4gICAgICAvLyBnZXQgZHJhZyBhcmVhIGRpbWVuc2lvbnNcbiAgICB9O1xuICAgIHZhciBkcmFnSGVpZ2h0ID0gZ2V0SXRlbUhlaWdodCh2aWV3KTtcbiAgICB2YXIgZHJhZ1dpZHRoID0gZ2V0SXRlbVdpZHRoKHZpZXcpO1xuXG4gICAgLy8gZ2V0IHJvd3MgYW5kIGNvbHVtbnMgKFRoZXJlIHdpbGwgYWx3YXlzIGJlIGF0IGxlYXN0IG9uZSByb3cgYW5kIG9uZSBjb2x1bW4gaWYgYSBmaWxlIGlzIHByZXNlbnQpXG4gICAgdmFyIGNvbHMgPSBNYXRoLmZsb29yKHJvb3QucmVjdC5vdXRlci53aWR0aCAvIGRyYWdXaWR0aCk7XG4gICAgaWYgKGNvbHMgPiBudW1JdGVtcykgY29scyA9IG51bUl0ZW1zO1xuXG4gICAgLy8gcm93cyBhcmUgdXNlZCB0byBmaW5kIHdoZW4gd2UgaGF2ZSBsZWZ0IHRoZSBwcmV2aWV3IGFyZWEgYm91bmRpbmcgYm94XG4gICAgdmFyIHJvd3MgPSBNYXRoLmZsb29yKG51bUl0ZW1zIC8gY29scyArIDEpO1xuXG4gICAgZHJvcEFyZWFEaW1lbnNpb25zLnNldEhlaWdodCA9IGRyYWdIZWlnaHQgKiByb3dzO1xuICAgIGRyb3BBcmVhRGltZW5zaW9ucy5zZXRXaWR0aCA9IGRyYWdXaWR0aCAqIGNvbHM7XG5cbiAgICAvLyBnZXQgbmV3IGluZGV4IG9mIGRyYWdnZWQgaXRlbVxuICAgIHZhciBsb2NhdGlvbiA9IHtcbiAgICAgIHk6IE1hdGguZmxvb3IoZHJhZ1Bvc2l0aW9uLnkgLyBkcmFnSGVpZ2h0KSxcbiAgICAgIHg6IE1hdGguZmxvb3IoZHJhZ1Bvc2l0aW9uLnggLyBkcmFnV2lkdGgpLFxuICAgICAgZ2V0R3JpZEluZGV4OiBmdW5jdGlvbiBnZXRHcmlkSW5kZXgoKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBkcmFnUG9zaXRpb24ueSA+IGRyb3BBcmVhRGltZW5zaW9ucy5nZXRIZWlnaHQgfHxcbiAgICAgICAgICBkcmFnUG9zaXRpb24ueSA8IDAgfHxcbiAgICAgICAgICBkcmFnUG9zaXRpb24ueCA+IGRyb3BBcmVhRGltZW5zaW9ucy5nZXRXaWR0aCB8fFxuICAgICAgICAgIGRyYWdQb3NpdGlvbi54IDwgMFxuICAgICAgICApXG4gICAgICAgICAgcmV0dXJuIG9sZEluZGV4O1xuICAgICAgICByZXR1cm4gdGhpcy55ICogY29scyArIHRoaXMueDtcbiAgICAgIH0sXG4gICAgICBnZXRDb2xJbmRleDogZnVuY3Rpb24gZ2V0Q29sSW5kZXgoKSB7XG4gICAgICAgIHZhciBpdGVtcyA9IHJvb3QucXVlcnkoJ0dFVF9BQ1RJVkVfSVRFTVMnKTtcbiAgICAgICAgdmFyIHZpc2libGVDaGlsZHJlbiA9IHJvb3QuY2hpbGRWaWV3cy5maWx0ZXIoZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgICByZXR1cm4gY2hpbGQucmVjdC5lbGVtZW50LmhlaWdodDtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IGl0ZW1zLm1hcChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgcmV0dXJuIHZpc2libGVDaGlsZHJlbi5maW5kKGZ1bmN0aW9uKGNoaWxkVmlldykge1xuICAgICAgICAgICAgcmV0dXJuIGNoaWxkVmlldy5pZCA9PT0gaXRlbS5pZDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBjdXJyZW50SW5kZXggPSBjaGlsZHJlbi5maW5kSW5kZXgoZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgICByZXR1cm4gY2hpbGQgPT09IHZpZXc7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgZHJhZ0hlaWdodCA9IGdldEl0ZW1IZWlnaHQodmlldyk7XG4gICAgICAgIHZhciBsID0gY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICB2YXIgaWR4ID0gbDtcbiAgICAgICAgdmFyIGNoaWxkSGVpZ2h0ID0gMDtcbiAgICAgICAgdmFyIGNoaWxkQm90dG9tID0gMDtcbiAgICAgICAgdmFyIGNoaWxkVG9wID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBjaGlsZEhlaWdodCA9IGdldEl0ZW1IZWlnaHQoY2hpbGRyZW5baV0pO1xuICAgICAgICAgIGNoaWxkVG9wID0gY2hpbGRCb3R0b207XG4gICAgICAgICAgY2hpbGRCb3R0b20gPSBjaGlsZFRvcCArIGNoaWxkSGVpZ2h0O1xuICAgICAgICAgIGlmIChkcmFnUG9zaXRpb24ueSA8IGNoaWxkQm90dG9tKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudEluZGV4ID4gaSkge1xuICAgICAgICAgICAgICBpZiAoZHJhZ1Bvc2l0aW9uLnkgPCBjaGlsZFRvcCArIGRyYWdIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBpZHggPSBpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWR4ID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaWR4O1xuICAgICAgfVxuXG4gICAgICAvLyBnZXQgbmV3IGluZGV4XG4gICAgfTtcbiAgICB2YXIgaW5kZXggPSBjb2xzID4gMSA/IGxvY2F0aW9uLmdldEdyaWRJbmRleCgpIDogbG9jYXRpb24uZ2V0Q29sSW5kZXgoKTtcbiAgICByb290LmRpc3BhdGNoKCdNT1ZFX0lURU0nLCB7IHF1ZXJ5OiB2aWV3LCBpbmRleDogaW5kZXggfSk7XG5cbiAgICAvLyBpZiB0aGUgaW5kZXggb2YgdGhlIGl0ZW0gY2hhbmdlZCwgZGlzcGF0Y2ggcmVvcmRlciBhY3Rpb25cbiAgICB2YXIgY3VycmVudEluZGV4ID0gZHJhZ1N0YXRlLmdldEluZGV4KCk7XG5cbiAgICBpZiAoY3VycmVudEluZGV4ID09PSB1bmRlZmluZWQgfHwgY3VycmVudEluZGV4ICE9PSBpbmRleCkge1xuICAgICAgZHJhZ1N0YXRlLnNldEluZGV4KGluZGV4KTtcblxuICAgICAgaWYgKGN1cnJlbnRJbmRleCA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG5cbiAgICAgIHJvb3QuZGlzcGF0Y2goJ0RJRF9SRU9SREVSX0lURU1TJywge1xuICAgICAgICBpdGVtczogcm9vdC5xdWVyeSgnR0VUX0FDVElWRV9JVEVNUycpLFxuICAgICAgICBvcmlnaW46IG9sZEluZGV4LFxuICAgICAgICB0YXJnZXQ6IGluZGV4XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldHVwIGFjdGlvbiByb3V0ZXNcbiAgICovXG4gIHZhciByb3V0ZSQyID0gY3JlYXRlUm91dGUoe1xuICAgIERJRF9BRERfSVRFTTogYWRkSXRlbVZpZXcsXG4gICAgRElEX1JFTU9WRV9JVEVNOiByZW1vdmVJdGVtVmlldyxcbiAgICBESURfRFJBR19JVEVNOiBkcmFnSXRlbVxuICB9KTtcblxuICAvKipcbiAgICogV3JpdGUgdG8gdmlld1xuICAgKiBAcGFyYW0gcm9vdFxuICAgKiBAcGFyYW0gYWN0aW9uc1xuICAgKiBAcGFyYW0gcHJvcHNcbiAgICovXG4gIHZhciB3cml0ZSQ1ID0gZnVuY3Rpb24gd3JpdGUoX3JlZjUpIHtcbiAgICB2YXIgcm9vdCA9IF9yZWY1LnJvb3QsXG4gICAgICBwcm9wcyA9IF9yZWY1LnByb3BzLFxuICAgICAgYWN0aW9ucyA9IF9yZWY1LmFjdGlvbnMsXG4gICAgICBzaG91bGRPcHRpbWl6ZSA9IF9yZWY1LnNob3VsZE9wdGltaXplO1xuXG4gICAgLy8gcm91dGUgYWN0aW9uc1xuICAgIHJvdXRlJDIoeyByb290OiByb290LCBwcm9wczogcHJvcHMsIGFjdGlvbnM6IGFjdGlvbnMgfSk7XG4gICAgdmFyIGRyYWdDb29yZGluYXRlcyA9IHByb3BzLmRyYWdDb29yZGluYXRlcztcblxuICAgIC8vIGF2YWlsYWJsZSBzcGFjZSBvbiBob3Jpem9udGFsIGF4aXNcbiAgICB2YXIgaG9yaXpvbnRhbFNwYWNlID0gcm9vdC5yZWN0LmVsZW1lbnQud2lkdGg7XG5cbiAgICAvLyBvbmx5IGRyYXcgY2hpbGRyZW4gdGhhdCBoYXZlIGRpbWVuc2lvbnNcbiAgICB2YXIgdmlzaWJsZUNoaWxkcmVuID0gcm9vdC5jaGlsZFZpZXdzLmZpbHRlcihmdW5jdGlvbihjaGlsZCkge1xuICAgICAgcmV0dXJuIGNoaWxkLnJlY3QuZWxlbWVudC5oZWlnaHQ7XG4gICAgfSk7XG5cbiAgICAvLyBzb3J0IGJhc2VkIG9uIGN1cnJlbnQgYWN0aXZlIGl0ZW1zXG4gICAgdmFyIGNoaWxkcmVuID0gcm9vdFxuICAgICAgLnF1ZXJ5KCdHRVRfQUNUSVZFX0lURU1TJylcbiAgICAgIC5tYXAoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICByZXR1cm4gdmlzaWJsZUNoaWxkcmVuLmZpbmQoZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgICByZXR1cm4gY2hpbGQuaWQgPT09IGl0ZW0uaWQ7XG4gICAgICAgIH0pO1xuICAgICAgfSlcbiAgICAgIC5maWx0ZXIoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgIH0pO1xuXG4gICAgLy8gZ2V0IGluZGV4XG4gICAgdmFyIGRyYWdJbmRleCA9IGRyYWdDb29yZGluYXRlc1xuICAgICAgPyBnZXRJdGVtSW5kZXhCeVBvc2l0aW9uKHJvb3QsIGNoaWxkcmVuLCBkcmFnQ29vcmRpbmF0ZXMpXG4gICAgICA6IG51bGw7XG5cbiAgICAvLyBhZGQgaW5kZXggaXMgdXNlZCB0byByZXNlcnZlIHRoZSBkcm9wcGVkL2FkZGVkIGl0ZW0gaW5kZXggdGlsbCB0aGUgYWN0dWFsIGl0ZW0gaXMgcmVuZGVyZWRcbiAgICB2YXIgYWRkSW5kZXggPSByb290LnJlZi5hZGRJbmRleCB8fCBudWxsO1xuXG4gICAgLy8gYWRkIGluZGV4IG5vIGxvbmdlciBuZWVkZWQgdGlsbCBwb3NzaWJseSBuZXh0IGRyYXdcbiAgICByb290LnJlZi5hZGRJbmRleCA9IG51bGw7XG5cbiAgICB2YXIgZHJhZ0luZGV4T2Zmc2V0ID0gMDtcbiAgICB2YXIgcmVtb3ZlSW5kZXhPZmZzZXQgPSAwO1xuICAgIHZhciBhZGRJbmRleE9mZnNldCA9IDA7XG5cbiAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID09PSAwKSByZXR1cm47XG5cbiAgICB2YXIgY2hpbGRSZWN0ID0gY2hpbGRyZW5bMF0ucmVjdC5lbGVtZW50O1xuICAgIHZhciBpdGVtVmVydGljYWxNYXJnaW4gPSBjaGlsZFJlY3QubWFyZ2luVG9wICsgY2hpbGRSZWN0Lm1hcmdpbkJvdHRvbTtcbiAgICB2YXIgaXRlbUhvcml6b250YWxNYXJnaW4gPSBjaGlsZFJlY3QubWFyZ2luTGVmdCArIGNoaWxkUmVjdC5tYXJnaW5SaWdodDtcbiAgICB2YXIgaXRlbVdpZHRoID0gY2hpbGRSZWN0LndpZHRoICsgaXRlbUhvcml6b250YWxNYXJnaW47XG4gICAgdmFyIGl0ZW1IZWlnaHQgPSBjaGlsZFJlY3QuaGVpZ2h0ICsgaXRlbVZlcnRpY2FsTWFyZ2luO1xuICAgIHZhciBpdGVtc1BlclJvdyA9IE1hdGgucm91bmQoaG9yaXpvbnRhbFNwYWNlIC8gaXRlbVdpZHRoKTtcblxuICAgIC8vIHN0YWNrXG4gICAgaWYgKGl0ZW1zUGVyUm93ID09PSAxKSB7XG4gICAgICB2YXIgb2Zmc2V0WSA9IDA7XG4gICAgICB2YXIgZHJhZ09mZnNldCA9IDA7XG5cbiAgICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24oY2hpbGQsIGluZGV4KSB7XG4gICAgICAgIGlmIChkcmFnSW5kZXgpIHtcbiAgICAgICAgICB2YXIgZGlzdCA9IGluZGV4IC0gZHJhZ0luZGV4O1xuICAgICAgICAgIGlmIChkaXN0ID09PSAtMikge1xuICAgICAgICAgICAgZHJhZ09mZnNldCA9IC1pdGVtVmVydGljYWxNYXJnaW4gKiAwLjI1O1xuICAgICAgICAgIH0gZWxzZSBpZiAoZGlzdCA9PT0gLTEpIHtcbiAgICAgICAgICAgIGRyYWdPZmZzZXQgPSAtaXRlbVZlcnRpY2FsTWFyZ2luICogMC43NTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGRpc3QgPT09IDApIHtcbiAgICAgICAgICAgIGRyYWdPZmZzZXQgPSBpdGVtVmVydGljYWxNYXJnaW4gKiAwLjc1O1xuICAgICAgICAgIH0gZWxzZSBpZiAoZGlzdCA9PT0gMSkge1xuICAgICAgICAgICAgZHJhZ09mZnNldCA9IGl0ZW1WZXJ0aWNhbE1hcmdpbiAqIDAuMjU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRyYWdPZmZzZXQgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzaG91bGRPcHRpbWl6ZSkge1xuICAgICAgICAgIGNoaWxkLnRyYW5zbGF0ZVggPSBudWxsO1xuICAgICAgICAgIGNoaWxkLnRyYW5zbGF0ZVkgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFjaGlsZC5tYXJrZWRGb3JSZW1vdmFsKSB7XG4gICAgICAgICAgbW92ZUl0ZW0oY2hpbGQsIDAsIG9mZnNldFkgKyBkcmFnT2Zmc2V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpdGVtSGVpZ2h0ID0gY2hpbGQucmVjdC5lbGVtZW50LmhlaWdodCArIGl0ZW1WZXJ0aWNhbE1hcmdpbjtcblxuICAgICAgICB2YXIgdmlzdWFsSGVpZ2h0ID1cbiAgICAgICAgICBpdGVtSGVpZ2h0ICogKGNoaWxkLm1hcmtlZEZvclJlbW92YWwgPyBjaGlsZC5vcGFjaXR5IDogMSk7XG5cbiAgICAgICAgb2Zmc2V0WSArPSB2aXN1YWxIZWlnaHQ7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLy8gZ3JpZFxuICAgIGVsc2Uge1xuICAgICAgdmFyIHByZXZYID0gMDtcbiAgICAgIHZhciBwcmV2WSA9IDA7XG5cbiAgICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24oY2hpbGQsIGluZGV4KSB7XG4gICAgICAgIGlmIChpbmRleCA9PT0gZHJhZ0luZGV4KSB7XG4gICAgICAgICAgZHJhZ0luZGV4T2Zmc2V0ID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbmRleCA9PT0gYWRkSW5kZXgpIHtcbiAgICAgICAgICBhZGRJbmRleE9mZnNldCArPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoaWxkLm1hcmtlZEZvclJlbW92YWwgJiYgY2hpbGQub3BhY2l0eSA8IDAuNSkge1xuICAgICAgICAgIHJlbW92ZUluZGV4T2Zmc2V0IC09IDE7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdmlzdWFsSW5kZXggPVxuICAgICAgICAgIGluZGV4ICsgYWRkSW5kZXhPZmZzZXQgKyBkcmFnSW5kZXhPZmZzZXQgKyByZW1vdmVJbmRleE9mZnNldDtcblxuICAgICAgICB2YXIgaW5kZXhYID0gdmlzdWFsSW5kZXggJSBpdGVtc1BlclJvdztcbiAgICAgICAgdmFyIGluZGV4WSA9IE1hdGguZmxvb3IodmlzdWFsSW5kZXggLyBpdGVtc1BlclJvdyk7XG5cbiAgICAgICAgdmFyIG9mZnNldFggPSBpbmRleFggKiBpdGVtV2lkdGg7XG4gICAgICAgIHZhciBvZmZzZXRZID0gaW5kZXhZICogaXRlbUhlaWdodDtcblxuICAgICAgICB2YXIgdmVjdG9yWCA9IE1hdGguc2lnbihvZmZzZXRYIC0gcHJldlgpO1xuICAgICAgICB2YXIgdmVjdG9yWSA9IE1hdGguc2lnbihvZmZzZXRZIC0gcHJldlkpO1xuXG4gICAgICAgIHByZXZYID0gb2Zmc2V0WDtcbiAgICAgICAgcHJldlkgPSBvZmZzZXRZO1xuXG4gICAgICAgIGlmIChjaGlsZC5tYXJrZWRGb3JSZW1vdmFsKSByZXR1cm47XG5cbiAgICAgICAgaWYgKHNob3VsZE9wdGltaXplKSB7XG4gICAgICAgICAgY2hpbGQudHJhbnNsYXRlWCA9IG51bGw7XG4gICAgICAgICAgY2hpbGQudHJhbnNsYXRlWSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBtb3ZlSXRlbShjaGlsZCwgb2Zmc2V0WCwgb2Zmc2V0WSwgdmVjdG9yWCwgdmVjdG9yWSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEZpbHRlcnMgYWN0aW9ucyB0aGF0IGFyZSBtZWFudCBzcGVjaWZpY2FsbHkgZm9yIGEgY2VydGFpbiBjaGlsZCBvZiB0aGUgbGlzdFxuICAgKiBAcGFyYW0gY2hpbGRcbiAgICogQHBhcmFtIGFjdGlvbnNcbiAgICovXG4gIHZhciBmaWx0ZXJTZXRJdGVtQWN0aW9ucyA9IGZ1bmN0aW9uIGZpbHRlclNldEl0ZW1BY3Rpb25zKGNoaWxkLCBhY3Rpb25zKSB7XG4gICAgcmV0dXJuIGFjdGlvbnMuZmlsdGVyKGZ1bmN0aW9uKGFjdGlvbikge1xuICAgICAgLy8gaWYgYWN0aW9uIGhhcyBhbiBpZCwgZmlsdGVyIG91dCBhY3Rpb25zIHRoYXQgZG9uJ3QgaGF2ZSB0aGlzIGNoaWxkIGlkXG4gICAgICBpZiAoYWN0aW9uLmRhdGEgJiYgYWN0aW9uLmRhdGEuaWQpIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkLmlkID09PSBhY3Rpb24uZGF0YS5pZDtcbiAgICAgIH1cblxuICAgICAgLy8gYWxsb3cgYWxsIG90aGVyIGFjdGlvbnNcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciBsaXN0ID0gY3JlYXRlVmlldyh7XG4gICAgY3JlYXRlOiBjcmVhdGUkOCxcbiAgICB3cml0ZTogd3JpdGUkNSxcbiAgICB0YWc6ICd1bCcsXG4gICAgbmFtZTogJ2xpc3QnLFxuICAgIGRpZFdyaXRlVmlldzogZnVuY3Rpb24gZGlkV3JpdGVWaWV3KF9yZWY2KSB7XG4gICAgICB2YXIgcm9vdCA9IF9yZWY2LnJvb3Q7XG4gICAgICByb290LmNoaWxkVmlld3NcbiAgICAgICAgLmZpbHRlcihmdW5jdGlvbih2aWV3KSB7XG4gICAgICAgICAgcmV0dXJuIHZpZXcubWFya2VkRm9yUmVtb3ZhbCAmJiB2aWV3Lm9wYWNpdHkgPT09IDAgJiYgdmlldy5yZXN0aW5nO1xuICAgICAgICB9KVxuICAgICAgICAuZm9yRWFjaChmdW5jdGlvbih2aWV3KSB7XG4gICAgICAgICAgdmlldy5fZGVzdHJveSgpO1xuICAgICAgICAgIHJvb3QucmVtb3ZlQ2hpbGRWaWV3KHZpZXcpO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIGZpbHRlckZyYW1lQWN0aW9uc0ZvckNoaWxkOiBmaWx0ZXJTZXRJdGVtQWN0aW9ucyxcbiAgICBtaXhpbnM6IHtcbiAgICAgIGFwaXM6IFsnZHJhZ0Nvb3JkaW5hdGVzJ11cbiAgICB9XG4gIH0pO1xuXG4gIHZhciBjcmVhdGUkOSA9IGZ1bmN0aW9uIGNyZWF0ZShfcmVmKSB7XG4gICAgdmFyIHJvb3QgPSBfcmVmLnJvb3QsXG4gICAgICBwcm9wcyA9IF9yZWYucHJvcHM7XG4gICAgcm9vdC5yZWYubGlzdCA9IHJvb3QuYXBwZW5kQ2hpbGRWaWV3KHJvb3QuY3JlYXRlQ2hpbGRWaWV3KGxpc3QpKTtcbiAgICBwcm9wcy5kcmFnQ29vcmRpbmF0ZXMgPSBudWxsO1xuICAgIHByb3BzLm92ZXJmbG93aW5nID0gZmFsc2U7XG4gIH07XG5cbiAgdmFyIHN0b3JlRHJhZ0Nvb3JkaW5hdGVzID0gZnVuY3Rpb24gc3RvcmVEcmFnQ29vcmRpbmF0ZXMoX3JlZjIpIHtcbiAgICB2YXIgcm9vdCA9IF9yZWYyLnJvb3QsXG4gICAgICBwcm9wcyA9IF9yZWYyLnByb3BzLFxuICAgICAgYWN0aW9uID0gX3JlZjIuYWN0aW9uO1xuICAgIGlmICghcm9vdC5xdWVyeSgnR0VUX0lURU1fSU5TRVJUX0xPQ0FUSU9OX0ZSRUVET00nKSkgcmV0dXJuO1xuICAgIHByb3BzLmRyYWdDb29yZGluYXRlcyA9IHtcbiAgICAgIGxlZnQ6IGFjdGlvbi5wb3NpdGlvbi5zY29wZUxlZnQgLSByb290LnJlZi5saXN0LnJlY3QuZWxlbWVudC5sZWZ0LFxuICAgICAgdG9wOlxuICAgICAgICBhY3Rpb24ucG9zaXRpb24uc2NvcGVUb3AgLVxuICAgICAgICAocm9vdC5yZWN0Lm91dGVyLnRvcCArXG4gICAgICAgICAgcm9vdC5yZWN0LmVsZW1lbnQubWFyZ2luVG9wICtcbiAgICAgICAgICByb290LnJlY3QuZWxlbWVudC5zY3JvbGxUb3ApXG4gICAgfTtcbiAgfTtcblxuICB2YXIgY2xlYXJEcmFnQ29vcmRpbmF0ZXMgPSBmdW5jdGlvbiBjbGVhckRyYWdDb29yZGluYXRlcyhfcmVmMykge1xuICAgIHZhciBwcm9wcyA9IF9yZWYzLnByb3BzO1xuICAgIHByb3BzLmRyYWdDb29yZGluYXRlcyA9IG51bGw7XG4gIH07XG5cbiAgdmFyIHJvdXRlJDMgPSBjcmVhdGVSb3V0ZSh7XG4gICAgRElEX0RSQUc6IHN0b3JlRHJhZ0Nvb3JkaW5hdGVzLFxuICAgIERJRF9FTkRfRFJBRzogY2xlYXJEcmFnQ29vcmRpbmF0ZXNcbiAgfSk7XG5cbiAgdmFyIHdyaXRlJDYgPSBmdW5jdGlvbiB3cml0ZShfcmVmNCkge1xuICAgIHZhciByb290ID0gX3JlZjQucm9vdCxcbiAgICAgIHByb3BzID0gX3JlZjQucHJvcHMsXG4gICAgICBhY3Rpb25zID0gX3JlZjQuYWN0aW9ucztcblxuICAgIC8vIHJvdXRlIGFjdGlvbnNcbiAgICByb3V0ZSQzKHsgcm9vdDogcm9vdCwgcHJvcHM6IHByb3BzLCBhY3Rpb25zOiBhY3Rpb25zIH0pO1xuXG4gICAgLy8gY3VycmVudCBkcmFnIHBvc2l0aW9uXG4gICAgcm9vdC5yZWYubGlzdC5kcmFnQ29vcmRpbmF0ZXMgPSBwcm9wcy5kcmFnQ29vcmRpbmF0ZXM7XG5cbiAgICAvLyBpZiBjdXJyZW50bHkgb3ZlcmZsb3dpbmcgYnV0IG5vIGxvbmdlciByZWNlaXZlZCBvdmVyZmxvd1xuICAgIGlmIChwcm9wcy5vdmVyZmxvd2luZyAmJiAhcHJvcHMub3ZlcmZsb3cpIHtcbiAgICAgIHByb3BzLm92ZXJmbG93aW5nID0gZmFsc2U7XG5cbiAgICAgIC8vIHJlc2V0IG92ZXJmbG93IHN0YXRlXG4gICAgICByb290LmVsZW1lbnQuZGF0YXNldC5zdGF0ZSA9ICcnO1xuICAgICAgcm9vdC5oZWlnaHQgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIGlmIGlzIG5vdCBvdmVyZmxvd2luZyBjdXJyZW50bHkgYnV0IGRvZXMgcmVjZWl2ZSBvdmVyZmxvdyB2YWx1ZVxuICAgIGlmIChwcm9wcy5vdmVyZmxvdykge1xuICAgICAgdmFyIG5ld0hlaWdodCA9IE1hdGgucm91bmQocHJvcHMub3ZlcmZsb3cpO1xuICAgICAgaWYgKG5ld0hlaWdodCAhPT0gcm9vdC5oZWlnaHQpIHtcbiAgICAgICAgcHJvcHMub3ZlcmZsb3dpbmcgPSB0cnVlO1xuICAgICAgICByb290LmVsZW1lbnQuZGF0YXNldC5zdGF0ZSA9ICdvdmVyZmxvdyc7XG4gICAgICAgIHJvb3QuaGVpZ2h0ID0gbmV3SGVpZ2h0O1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgbGlzdFNjcm9sbGVyID0gY3JlYXRlVmlldyh7XG4gICAgY3JlYXRlOiBjcmVhdGUkOSxcbiAgICB3cml0ZTogd3JpdGUkNixcbiAgICBuYW1lOiAnbGlzdC1zY3JvbGxlcicsXG4gICAgbWl4aW5zOiB7XG4gICAgICBhcGlzOiBbJ292ZXJmbG93JywgJ2RyYWdDb29yZGluYXRlcyddLFxuICAgICAgc3R5bGVzOiBbJ2hlaWdodCcsICd0cmFuc2xhdGVZJ10sXG4gICAgICBhbmltYXRpb25zOiB7XG4gICAgICAgIHRyYW5zbGF0ZVk6ICdzcHJpbmcnXG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICB2YXIgYXR0clRvZ2dsZSA9IGZ1bmN0aW9uIGF0dHJUb2dnbGUoZWxlbWVudCwgbmFtZSwgc3RhdGUpIHtcbiAgICB2YXIgZW5hYmxlZFZhbHVlID1cbiAgICAgIGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogJyc7XG4gICAgaWYgKHN0YXRlKSB7XG4gICAgICBhdHRyKGVsZW1lbnQsIG5hbWUsIGVuYWJsZWRWYWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgcmVzZXRGaWxlSW5wdXQgPSBmdW5jdGlvbiByZXNldEZpbGVJbnB1dChpbnB1dCkge1xuICAgIC8vIG5vIHZhbHVlLCBubyBuZWVkIHRvIHJlc2V0XG4gICAgaWYgKCFpbnB1dCB8fCBpbnB1dC52YWx1ZSA9PT0gJycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgLy8gZm9yIG1vZGVybiBicm93c2Vyc1xuICAgICAgaW5wdXQudmFsdWUgPSAnJztcbiAgICB9IGNhdGNoIChlcnIpIHt9XG5cbiAgICAvLyBmb3IgSUUxMFxuICAgIGlmIChpbnB1dC52YWx1ZSkge1xuICAgICAgLy8gcXVpY2tseSBhcHBlbmQgaW5wdXQgdG8gdGVtcCBmb3JtIGFuZCByZXNldCBmb3JtXG4gICAgICB2YXIgZm9ybSA9IGNyZWF0ZUVsZW1lbnQkMSgnZm9ybScpO1xuICAgICAgdmFyIHBhcmVudE5vZGUgPSBpbnB1dC5wYXJlbnROb2RlO1xuICAgICAgdmFyIHJlZiA9IGlucHV0Lm5leHRTaWJsaW5nO1xuICAgICAgZm9ybS5hcHBlbmRDaGlsZChpbnB1dCk7XG4gICAgICBmb3JtLnJlc2V0KCk7XG5cbiAgICAgIC8vIHJlLWluamVjdCBpbnB1dCB3aGVyZSBpdCBvcmlnaW5hbGx5IHdhc1xuICAgICAgaWYgKHJlZikge1xuICAgICAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShpbnB1dCwgcmVmKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcmVudE5vZGUuYXBwZW5kQ2hpbGQoaW5wdXQpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgY3JlYXRlJGEgPSBmdW5jdGlvbiBjcmVhdGUoX3JlZikge1xuICAgIHZhciByb290ID0gX3JlZi5yb290LFxuICAgICAgcHJvcHMgPSBfcmVmLnByb3BzO1xuXG4gICAgLy8gc2V0IGlkIHNvIGNhbiBiZSByZWZlcmVuY2VkIGZyb20gb3V0c2lkZSBsYWJlbHNcbiAgICByb290LmVsZW1lbnQuaWQgPSAnZmlsZXBvbmQtLWJyb3dzZXItJyArIHByb3BzLmlkO1xuXG4gICAgLy8gc2V0IG5hbWUgb2YgZWxlbWVudCAoaXMgcmVtb3ZlZCB3aGVuIGEgdmFsdWUgaXMgc2V0KVxuICAgIGF0dHIocm9vdC5lbGVtZW50LCAnbmFtZScsIHJvb3QucXVlcnkoJ0dFVF9OQU1FJykpO1xuXG4gICAgLy8gd2UgaGF2ZSB0byBsaW5rIHRoaXMgZWxlbWVudCB0byB0aGUgc3RhdHVzIGVsZW1lbnRcbiAgICBhdHRyKHJvb3QuZWxlbWVudCwgJ2FyaWEtY29udHJvbHMnLCAnZmlsZXBvbmQtLWFzc2lzdGFudC0nICsgcHJvcHMuaWQpO1xuXG4gICAgLy8gc2V0IGxhYmVsLCB3ZSB1c2UgbGFiZWxsZWQgYnkgYXMgb3RoZXJ3aXNlIHRoZSBzY3JlZW5yZWFkZXIgZG9lcyBub3QgcmVhZCB0aGUgXCJicm93c2VcIiB0ZXh0IGluIHRoZSBsYWJlbCAoYXMgaXQgaGFzIHRhYmluZGV4OiAwKVxuICAgIGF0dHIocm9vdC5lbGVtZW50LCAnYXJpYS1sYWJlbGxlZGJ5JywgJ2ZpbGVwb25kLS1kcm9wLWxhYmVsLScgKyBwcm9wcy5pZCk7XG5cbiAgICAvLyBzZXQgY29uZmlndXJhYmxlIHByb3BzXG4gICAgc2V0QWNjZXB0ZWRGaWxlVHlwZXMoe1xuICAgICAgcm9vdDogcm9vdCxcbiAgICAgIGFjdGlvbjogeyB2YWx1ZTogcm9vdC5xdWVyeSgnR0VUX0FDQ0VQVEVEX0ZJTEVfVFlQRVMnKSB9XG4gICAgfSk7XG4gICAgdG9nZ2xlQWxsb3dNdWx0aXBsZSh7XG4gICAgICByb290OiByb290LFxuICAgICAgYWN0aW9uOiB7IHZhbHVlOiByb290LnF1ZXJ5KCdHRVRfQUxMT1dfTVVMVElQTEUnKSB9XG4gICAgfSk7XG4gICAgdG9nZ2xlRGlyZWN0b3J5RmlsdGVyKHtcbiAgICAgIHJvb3Q6IHJvb3QsXG4gICAgICBhY3Rpb246IHsgdmFsdWU6IHJvb3QucXVlcnkoJ0dFVF9BTExPV19ESVJFQ1RPUklFU19PTkxZJykgfVxuICAgIH0pO1xuICAgIHRvZ2dsZURpc2FibGVkKHsgcm9vdDogcm9vdCB9KTtcbiAgICB0b2dnbGVSZXF1aXJlZCh7XG4gICAgICByb290OiByb290LFxuICAgICAgYWN0aW9uOiB7IHZhbHVlOiByb290LnF1ZXJ5KCdHRVRfUkVRVUlSRUQnKSB9XG4gICAgfSk7XG4gICAgc2V0Q2FwdHVyZU1ldGhvZCh7XG4gICAgICByb290OiByb290LFxuICAgICAgYWN0aW9uOiB7IHZhbHVlOiByb290LnF1ZXJ5KCdHRVRfQ0FQVFVSRV9NRVRIT0QnKSB9XG4gICAgfSk7XG5cbiAgICAvLyBoYW5kbGUgY2hhbmdlcyB0byB0aGUgaW5wdXQgZmllbGRcbiAgICByb290LnJlZi5oYW5kbGVDaGFuZ2UgPSBmdW5jdGlvbihlKSB7XG4gICAgICBpZiAoIXJvb3QuZWxlbWVudC52YWx1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIGV4dHJhY3QgZmlsZXMgYW5kIG1vdmUgdmFsdWUgb2Ygd2Via2l0UmVsYXRpdmVQYXRoIHBhdGggdG8gX3JlbGF0aXZlUGF0aFxuICAgICAgdmFyIGZpbGVzID0gQXJyYXkuZnJvbShyb290LmVsZW1lbnQuZmlsZXMpLm1hcChmdW5jdGlvbihmaWxlKSB7XG4gICAgICAgIGZpbGUuX3JlbGF0aXZlUGF0aCA9IGZpbGUud2Via2l0UmVsYXRpdmVQYXRoO1xuICAgICAgICByZXR1cm4gZmlsZTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyB3ZSBhZGQgYSBsaXR0bGUgZGVsYXkgc28gdGhlIE9TIGZpbGUgc2VsZWN0IHdpbmRvdyBjYW4gbW92ZSBvdXQgb2YgdGhlIHdheSBiZWZvcmUgd2UgYWRkIG91ciBmaWxlXG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBsb2FkIGZpbGVzXG4gICAgICAgIHByb3BzLm9ubG9hZChmaWxlcyk7XG5cbiAgICAgICAgLy8gcmVzZXQgaW5wdXQsIGl0J3MganVzdCBmb3IgZXhwb3NpbmcgYSBtZXRob2QgdG8gZHJvcCBmaWxlcywgc2hvdWxkIG5vdCByZXRhaW4gYW55IHN0YXRlXG4gICAgICAgIHJlc2V0RmlsZUlucHV0KHJvb3QuZWxlbWVudCk7XG4gICAgICB9LCAyNTApO1xuICAgIH07XG5cbiAgICByb290LmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgcm9vdC5yZWYuaGFuZGxlQ2hhbmdlKTtcbiAgfTtcblxuICB2YXIgc2V0QWNjZXB0ZWRGaWxlVHlwZXMgPSBmdW5jdGlvbiBzZXRBY2NlcHRlZEZpbGVUeXBlcyhfcmVmMikge1xuICAgIHZhciByb290ID0gX3JlZjIucm9vdCxcbiAgICAgIGFjdGlvbiA9IF9yZWYyLmFjdGlvbjtcbiAgICBpZiAoIXJvb3QucXVlcnkoJ0dFVF9BTExPV19TWU5DX0FDQ0VQVF9BVFRSSUJVVEUnKSkgcmV0dXJuO1xuICAgIGF0dHJUb2dnbGUoXG4gICAgICByb290LmVsZW1lbnQsXG4gICAgICAnYWNjZXB0JyxcbiAgICAgICEhYWN0aW9uLnZhbHVlLFxuICAgICAgYWN0aW9uLnZhbHVlID8gYWN0aW9uLnZhbHVlLmpvaW4oJywnKSA6ICcnXG4gICAgKTtcbiAgfTtcblxuICB2YXIgdG9nZ2xlQWxsb3dNdWx0aXBsZSA9IGZ1bmN0aW9uIHRvZ2dsZUFsbG93TXVsdGlwbGUoX3JlZjMpIHtcbiAgICB2YXIgcm9vdCA9IF9yZWYzLnJvb3QsXG4gICAgICBhY3Rpb24gPSBfcmVmMy5hY3Rpb247XG4gICAgYXR0clRvZ2dsZShyb290LmVsZW1lbnQsICdtdWx0aXBsZScsIGFjdGlvbi52YWx1ZSk7XG4gIH07XG5cbiAgdmFyIHRvZ2dsZURpcmVjdG9yeUZpbHRlciA9IGZ1bmN0aW9uIHRvZ2dsZURpcmVjdG9yeUZpbHRlcihfcmVmNCkge1xuICAgIHZhciByb290ID0gX3JlZjQucm9vdCxcbiAgICAgIGFjdGlvbiA9IF9yZWY0LmFjdGlvbjtcbiAgICBhdHRyVG9nZ2xlKHJvb3QuZWxlbWVudCwgJ3dlYmtpdGRpcmVjdG9yeScsIGFjdGlvbi52YWx1ZSk7XG4gIH07XG5cbiAgdmFyIHRvZ2dsZURpc2FibGVkID0gZnVuY3Rpb24gdG9nZ2xlRGlzYWJsZWQoX3JlZjUpIHtcbiAgICB2YXIgcm9vdCA9IF9yZWY1LnJvb3Q7XG4gICAgdmFyIGlzRGlzYWJsZWQgPSByb290LnF1ZXJ5KCdHRVRfRElTQUJMRUQnKTtcbiAgICB2YXIgZG9lc0FsbG93QnJvd3NlID0gcm9vdC5xdWVyeSgnR0VUX0FMTE9XX0JST1dTRScpO1xuICAgIHZhciBkaXNhYmxlRmllbGQgPSBpc0Rpc2FibGVkIHx8ICFkb2VzQWxsb3dCcm93c2U7XG4gICAgYXR0clRvZ2dsZShyb290LmVsZW1lbnQsICdkaXNhYmxlZCcsIGRpc2FibGVGaWVsZCk7XG4gIH07XG5cbiAgdmFyIHRvZ2dsZVJlcXVpcmVkID0gZnVuY3Rpb24gdG9nZ2xlUmVxdWlyZWQoX3JlZjYpIHtcbiAgICB2YXIgcm9vdCA9IF9yZWY2LnJvb3QsXG4gICAgICBhY3Rpb24gPSBfcmVmNi5hY3Rpb247XG4gICAgLy8gd2FudCB0byByZW1vdmUgcmVxdWlyZWQsIGFsd2F5cyBwb3NzaWJsZVxuICAgIGlmICghYWN0aW9uLnZhbHVlKSB7XG4gICAgICBhdHRyVG9nZ2xlKHJvb3QuZWxlbWVudCwgJ3JlcXVpcmVkJywgZmFsc2UpO1xuICAgIH1cbiAgICAvLyBpZiB3YW50IHRvIG1ha2UgcmVxdWlyZWQsIG9ubHkgcG9zc2libGUgd2hlbiB6ZXJvIGl0ZW1zXG4gICAgZWxzZSBpZiAocm9vdC5xdWVyeSgnR0VUX1RPVEFMX0lURU1TJykgPT09IDApIHtcbiAgICAgIGF0dHJUb2dnbGUocm9vdC5lbGVtZW50LCAncmVxdWlyZWQnLCB0cnVlKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHNldENhcHR1cmVNZXRob2QgPSBmdW5jdGlvbiBzZXRDYXB0dXJlTWV0aG9kKF9yZWY3KSB7XG4gICAgdmFyIHJvb3QgPSBfcmVmNy5yb290LFxuICAgICAgYWN0aW9uID0gX3JlZjcuYWN0aW9uO1xuICAgIGF0dHJUb2dnbGUoXG4gICAgICByb290LmVsZW1lbnQsXG4gICAgICAnY2FwdHVyZScsXG4gICAgICAhIWFjdGlvbi52YWx1ZSxcbiAgICAgIGFjdGlvbi52YWx1ZSA9PT0gdHJ1ZSA/ICcnIDogYWN0aW9uLnZhbHVlXG4gICAgKTtcbiAgfTtcblxuICB2YXIgdXBkYXRlUmVxdWlyZWRTdGF0dXMgPSBmdW5jdGlvbiB1cGRhdGVSZXF1aXJlZFN0YXR1cyhfcmVmOCkge1xuICAgIHZhciByb290ID0gX3JlZjgucm9vdDtcbiAgICB2YXIgZWxlbWVudCA9IHJvb3QuZWxlbWVudDtcbiAgICAvLyBhbHdheXMgcmVtb3ZlIHRoZSByZXF1aXJlZCBhdHRyaWJ1dGUgd2hlbiBtb3JlIHRoYW4gemVybyBpdGVtc1xuICAgIGlmIChyb290LnF1ZXJ5KCdHRVRfVE9UQUxfSVRFTVMnKSA+IDApIHtcbiAgICAgIGF0dHJUb2dnbGUoZWxlbWVudCwgJ3JlcXVpcmVkJywgZmFsc2UpO1xuICAgICAgYXR0clRvZ2dsZShlbGVtZW50LCAnbmFtZScsIGZhbHNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gYWRkIG5hbWUgYXR0cmlidXRlXG4gICAgICBhdHRyVG9nZ2xlKGVsZW1lbnQsICduYW1lJywgdHJ1ZSwgcm9vdC5xdWVyeSgnR0VUX05BTUUnKSk7XG5cbiAgICAgIC8vIHJlbW92ZSBhbnkgdmFsaWRhdGlvbiBtZXNzYWdlc1xuICAgICAgdmFyIHNob3VsZENoZWNrVmFsaWRpdHkgPSByb290LnF1ZXJ5KCdHRVRfQ0hFQ0tfVkFMSURJVFknKTtcbiAgICAgIGlmIChzaG91bGRDaGVja1ZhbGlkaXR5KSB7XG4gICAgICAgIGVsZW1lbnQuc2V0Q3VzdG9tVmFsaWRpdHkoJycpO1xuICAgICAgfVxuXG4gICAgICAvLyB3ZSBvbmx5IGFkZCByZXF1aXJlZCBpZiB0aGUgZmllbGQgaGFzIGJlZW4gZGVlbWVkIHJlcXVpcmVkXG4gICAgICBpZiAocm9vdC5xdWVyeSgnR0VUX1JFUVVJUkVEJykpIHtcbiAgICAgICAgYXR0clRvZ2dsZShlbGVtZW50LCAncmVxdWlyZWQnLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFyIHVwZGF0ZUZpZWxkVmFsaWRpdHlTdGF0dXMgPSBmdW5jdGlvbiB1cGRhdGVGaWVsZFZhbGlkaXR5U3RhdHVzKF9yZWY5KSB7XG4gICAgdmFyIHJvb3QgPSBfcmVmOS5yb290O1xuICAgIHZhciBzaG91bGRDaGVja1ZhbGlkaXR5ID0gcm9vdC5xdWVyeSgnR0VUX0NIRUNLX1ZBTElESVRZJyk7XG4gICAgaWYgKCFzaG91bGRDaGVja1ZhbGlkaXR5KSByZXR1cm47XG4gICAgcm9vdC5lbGVtZW50LnNldEN1c3RvbVZhbGlkaXR5KHJvb3QucXVlcnkoJ0dFVF9MQUJFTF9JTlZBTElEX0ZJRUxEJykpO1xuICB9O1xuXG4gIHZhciBicm93c2VyID0gY3JlYXRlVmlldyh7XG4gICAgdGFnOiAnaW5wdXQnLFxuICAgIG5hbWU6ICdicm93c2VyJyxcbiAgICBpZ25vcmVSZWN0OiB0cnVlLFxuICAgIGlnbm9yZVJlY3RVcGRhdGU6IHRydWUsXG4gICAgYXR0cmlidXRlczoge1xuICAgICAgdHlwZTogJ2ZpbGUnXG4gICAgfSxcblxuICAgIGNyZWF0ZTogY3JlYXRlJGEsXG4gICAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveShfcmVmMTApIHtcbiAgICAgIHZhciByb290ID0gX3JlZjEwLnJvb3Q7XG4gICAgICByb290LmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgcm9vdC5yZWYuaGFuZGxlQ2hhbmdlKTtcbiAgICB9LFxuICAgIHdyaXRlOiBjcmVhdGVSb3V0ZSh7XG4gICAgICBESURfTE9BRF9JVEVNOiB1cGRhdGVSZXF1aXJlZFN0YXR1cyxcbiAgICAgIERJRF9SRU1PVkVfSVRFTTogdXBkYXRlUmVxdWlyZWRTdGF0dXMsXG4gICAgICBESURfVEhST1dfSVRFTV9JTlZBTElEOiB1cGRhdGVGaWVsZFZhbGlkaXR5U3RhdHVzLFxuXG4gICAgICBESURfU0VUX0RJU0FCTEVEOiB0b2dnbGVEaXNhYmxlZCxcbiAgICAgIERJRF9TRVRfQUxMT1dfQlJPV1NFOiB0b2dnbGVEaXNhYmxlZCxcbiAgICAgIERJRF9TRVRfQUxMT1dfRElSRUNUT1JJRVNfT05MWTogdG9nZ2xlRGlyZWN0b3J5RmlsdGVyLFxuICAgICAgRElEX1NFVF9BTExPV19NVUxUSVBMRTogdG9nZ2xlQWxsb3dNdWx0aXBsZSxcbiAgICAgIERJRF9TRVRfQUNDRVBURURfRklMRV9UWVBFUzogc2V0QWNjZXB0ZWRGaWxlVHlwZXMsXG4gICAgICBESURfU0VUX0NBUFRVUkVfTUVUSE9EOiBzZXRDYXB0dXJlTWV0aG9kLFxuICAgICAgRElEX1NFVF9SRVFVSVJFRDogdG9nZ2xlUmVxdWlyZWRcbiAgICB9KVxuICB9KTtcblxuICB2YXIgS2V5ID0ge1xuICAgIEVOVEVSOiAxMyxcbiAgICBTUEFDRTogMzJcbiAgfTtcblxuICB2YXIgY3JlYXRlJGIgPSBmdW5jdGlvbiBjcmVhdGUoX3JlZikge1xuICAgIHZhciByb290ID0gX3JlZi5yb290LFxuICAgICAgcHJvcHMgPSBfcmVmLnByb3BzO1xuXG4gICAgLy8gY3JlYXRlIHRoZSBsYWJlbCBhbmQgbGluayBpdCB0byB0aGUgZmlsZSBicm93c2VyXG4gICAgdmFyIGxhYmVsID0gY3JlYXRlRWxlbWVudCQxKCdsYWJlbCcpO1xuICAgIGF0dHIobGFiZWwsICdmb3InLCAnZmlsZXBvbmQtLWJyb3dzZXItJyArIHByb3BzLmlkKTtcblxuICAgIC8vIHVzZSBmb3IgbGFiZWxpbmcgZmlsZSBpbnB1dCAoYXJpYS1sYWJlbGxlZGJ5IG9uIGZpbGUgaW5wdXQpXG4gICAgYXR0cihsYWJlbCwgJ2lkJywgJ2ZpbGVwb25kLS1kcm9wLWxhYmVsLScgKyBwcm9wcy5pZCk7XG5cbiAgICAvLyBoaWRlIHRoZSBsYWJlbCBmb3Igc2NyZWVucmVhZGVycywgdGhlIGlucHV0IGVsZW1lbnQgd2lsbCByZWFkIHRoZSBjb250ZW50cyBvZiB0aGUgbGFiZWwgd2hlbiBpdCdzIGZvY3Vzc2VkLiBJZiB3ZSBkb24ndCBzZXQgYXJpYS1oaWRkZW4gdGhlIHNjcmVlbnJlYWRlciB3aWxsIGFsc28gbmF2aWdhdGUgdGhlIGNvbnRlbnRzIG9mIHRoZSBsYWJlbCBzZXBhcmF0ZWx5IGZyb20gdGhlIGlucHV0LlxuICAgIGF0dHIobGFiZWwsICdhcmlhLWhpZGRlbicsICd0cnVlJyk7XG5cbiAgICAvLyBoYW5kbGUga2V5c1xuICAgIHJvb3QucmVmLmhhbmRsZUtleURvd24gPSBmdW5jdGlvbihlKSB7XG4gICAgICB2YXIgaXNBY3RpdmF0aW9uS2V5ID0gZS5rZXlDb2RlID09PSBLZXkuRU5URVIgfHwgZS5rZXlDb2RlID09PSBLZXkuU1BBQ0U7XG4gICAgICBpZiAoIWlzQWN0aXZhdGlvbktleSkgcmV0dXJuO1xuICAgICAgLy8gc3RvcHMgZnJvbSB0cmlnZ2VyaW5nIHRoZSBlbGVtZW50IGEgc2Vjb25kIHRpbWVcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgLy8gY2xpY2sgbGluayAod2lsbCB0aGVuIGluIHR1cm4gYWN0aXZhdGUgZmlsZSBpbnB1dClcbiAgICAgIHJvb3QucmVmLmxhYmVsLmNsaWNrKCk7XG4gICAgfTtcblxuICAgIHJvb3QucmVmLmhhbmRsZUNsaWNrID0gZnVuY3Rpb24oZSkge1xuICAgICAgdmFyIGlzTGFiZWxDbGljayA9IGUudGFyZ2V0ID09PSBsYWJlbCB8fCBsYWJlbC5jb250YWlucyhlLnRhcmdldCk7XG5cbiAgICAgIC8vIGRvbid0IHdhbnQgdG8gY2xpY2sgdHdpY2VcbiAgICAgIGlmIChpc0xhYmVsQ2xpY2spIHJldHVybjtcblxuICAgICAgLy8gY2xpY2sgbGluayAod2lsbCB0aGVuIGluIHR1cm4gYWN0aXZhdGUgZmlsZSBpbnB1dClcbiAgICAgIHJvb3QucmVmLmxhYmVsLmNsaWNrKCk7XG4gICAgfTtcblxuICAgIC8vIGF0dGFjaCBldmVudHNcbiAgICBsYWJlbC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgcm9vdC5yZWYuaGFuZGxlS2V5RG93bik7XG4gICAgcm9vdC5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgcm9vdC5yZWYuaGFuZGxlQ2xpY2spO1xuXG4gICAgLy8gdXBkYXRlXG4gICAgdXBkYXRlTGFiZWxWYWx1ZShsYWJlbCwgcHJvcHMuY2FwdGlvbik7XG5cbiAgICAvLyBhZGQhXG4gICAgcm9vdC5hcHBlbmRDaGlsZChsYWJlbCk7XG4gICAgcm9vdC5yZWYubGFiZWwgPSBsYWJlbDtcbiAgfTtcblxuICB2YXIgdXBkYXRlTGFiZWxWYWx1ZSA9IGZ1bmN0aW9uIHVwZGF0ZUxhYmVsVmFsdWUobGFiZWwsIHZhbHVlKSB7XG4gICAgbGFiZWwuaW5uZXJIVE1MID0gdmFsdWU7XG4gICAgdmFyIGNsaWNrYWJsZSA9IGxhYmVsLnF1ZXJ5U2VsZWN0b3IoJy5maWxlcG9uZC0tbGFiZWwtYWN0aW9uJyk7XG4gICAgaWYgKGNsaWNrYWJsZSkge1xuICAgICAgYXR0cihjbGlja2FibGUsICd0YWJpbmRleCcsICcwJyk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcblxuICB2YXIgZHJvcExhYmVsID0gY3JlYXRlVmlldyh7XG4gICAgbmFtZTogJ2Ryb3AtbGFiZWwnLFxuICAgIGlnbm9yZVJlY3Q6IHRydWUsXG4gICAgY3JlYXRlOiBjcmVhdGUkYixcbiAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KF9yZWYyKSB7XG4gICAgICB2YXIgcm9vdCA9IF9yZWYyLnJvb3Q7XG4gICAgICByb290LnJlZi5sYWJlbC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgcm9vdC5yZWYuaGFuZGxlS2V5RG93bik7XG4gICAgICByb290LmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCByb290LnJlZi5oYW5kbGVDbGljayk7XG4gICAgfSxcbiAgICB3cml0ZTogY3JlYXRlUm91dGUoe1xuICAgICAgRElEX1NFVF9MQUJFTF9JRExFOiBmdW5jdGlvbiBESURfU0VUX0xBQkVMX0lETEUoX3JlZjMpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmMy5yb290LFxuICAgICAgICAgIGFjdGlvbiA9IF9yZWYzLmFjdGlvbjtcbiAgICAgICAgdXBkYXRlTGFiZWxWYWx1ZShyb290LnJlZi5sYWJlbCwgYWN0aW9uLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9KSxcblxuICAgIG1peGluczoge1xuICAgICAgc3R5bGVzOiBbJ29wYWNpdHknLCAndHJhbnNsYXRlWCcsICd0cmFuc2xhdGVZJ10sXG4gICAgICBhbmltYXRpb25zOiB7XG4gICAgICAgIG9wYWNpdHk6IHsgdHlwZTogJ3R3ZWVuJywgZHVyYXRpb246IDE1MCB9LFxuICAgICAgICB0cmFuc2xhdGVYOiAnc3ByaW5nJyxcbiAgICAgICAgdHJhbnNsYXRlWTogJ3NwcmluZydcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHZhciBibG9iID0gY3JlYXRlVmlldyh7XG4gICAgbmFtZTogJ2RyaXAtYmxvYicsXG4gICAgaWdub3JlUmVjdDogdHJ1ZSxcbiAgICBtaXhpbnM6IHtcbiAgICAgIHN0eWxlczogWyd0cmFuc2xhdGVYJywgJ3RyYW5zbGF0ZVknLCAnc2NhbGVYJywgJ3NjYWxlWScsICdvcGFjaXR5J10sXG4gICAgICBhbmltYXRpb25zOiB7XG4gICAgICAgIHNjYWxlWDogJ3NwcmluZycsXG4gICAgICAgIHNjYWxlWTogJ3NwcmluZycsXG4gICAgICAgIHRyYW5zbGF0ZVg6ICdzcHJpbmcnLFxuICAgICAgICB0cmFuc2xhdGVZOiAnc3ByaW5nJyxcbiAgICAgICAgb3BhY2l0eTogeyB0eXBlOiAndHdlZW4nLCBkdXJhdGlvbjogMjUwIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHZhciBhZGRCbG9iID0gZnVuY3Rpb24gYWRkQmxvYihfcmVmKSB7XG4gICAgdmFyIHJvb3QgPSBfcmVmLnJvb3Q7XG4gICAgdmFyIGNlbnRlclggPSByb290LnJlY3QuZWxlbWVudC53aWR0aCAqIDAuNTtcbiAgICB2YXIgY2VudGVyWSA9IHJvb3QucmVjdC5lbGVtZW50LmhlaWdodCAqIDAuNTtcblxuICAgIHJvb3QucmVmLmJsb2IgPSByb290LmFwcGVuZENoaWxkVmlldyhcbiAgICAgIHJvb3QuY3JlYXRlQ2hpbGRWaWV3KGJsb2IsIHtcbiAgICAgICAgb3BhY2l0eTogMCxcbiAgICAgICAgc2NhbGVYOiAyLjUsXG4gICAgICAgIHNjYWxlWTogMi41LFxuICAgICAgICB0cmFuc2xhdGVYOiBjZW50ZXJYLFxuICAgICAgICB0cmFuc2xhdGVZOiBjZW50ZXJZXG4gICAgICB9KVxuICAgICk7XG4gIH07XG5cbiAgdmFyIG1vdmVCbG9iID0gZnVuY3Rpb24gbW92ZUJsb2IoX3JlZjIpIHtcbiAgICB2YXIgcm9vdCA9IF9yZWYyLnJvb3QsXG4gICAgICBhY3Rpb24gPSBfcmVmMi5hY3Rpb247XG4gICAgaWYgKCFyb290LnJlZi5ibG9iKSB7XG4gICAgICBhZGRCbG9iKHsgcm9vdDogcm9vdCB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICByb290LnJlZi5ibG9iLnRyYW5zbGF0ZVggPSBhY3Rpb24ucG9zaXRpb24uc2NvcGVMZWZ0O1xuICAgIHJvb3QucmVmLmJsb2IudHJhbnNsYXRlWSA9IGFjdGlvbi5wb3NpdGlvbi5zY29wZVRvcDtcbiAgICByb290LnJlZi5ibG9iLnNjYWxlWCA9IDE7XG4gICAgcm9vdC5yZWYuYmxvYi5zY2FsZVkgPSAxO1xuICAgIHJvb3QucmVmLmJsb2Iub3BhY2l0eSA9IDE7XG4gIH07XG5cbiAgdmFyIGhpZGVCbG9iID0gZnVuY3Rpb24gaGlkZUJsb2IoX3JlZjMpIHtcbiAgICB2YXIgcm9vdCA9IF9yZWYzLnJvb3Q7XG4gICAgaWYgKCFyb290LnJlZi5ibG9iKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJvb3QucmVmLmJsb2Iub3BhY2l0eSA9IDA7XG4gIH07XG5cbiAgdmFyIGV4cGxvZGVCbG9iID0gZnVuY3Rpb24gZXhwbG9kZUJsb2IoX3JlZjQpIHtcbiAgICB2YXIgcm9vdCA9IF9yZWY0LnJvb3Q7XG4gICAgaWYgKCFyb290LnJlZi5ibG9iKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJvb3QucmVmLmJsb2Iuc2NhbGVYID0gMi41O1xuICAgIHJvb3QucmVmLmJsb2Iuc2NhbGVZID0gMi41O1xuICAgIHJvb3QucmVmLmJsb2Iub3BhY2l0eSA9IDA7XG4gIH07XG5cbiAgdmFyIHdyaXRlJDcgPSBmdW5jdGlvbiB3cml0ZShfcmVmNSkge1xuICAgIHZhciByb290ID0gX3JlZjUucm9vdCxcbiAgICAgIHByb3BzID0gX3JlZjUucHJvcHMsXG4gICAgICBhY3Rpb25zID0gX3JlZjUuYWN0aW9ucztcbiAgICByb3V0ZSQ0KHsgcm9vdDogcm9vdCwgcHJvcHM6IHByb3BzLCBhY3Rpb25zOiBhY3Rpb25zIH0pO1xuICAgIHZhciBibG9iID0gcm9vdC5yZWYuYmxvYjtcblxuICAgIGlmIChhY3Rpb25zLmxlbmd0aCA9PT0gMCAmJiBibG9iICYmIGJsb2Iub3BhY2l0eSA9PT0gMCkge1xuICAgICAgcm9vdC5yZW1vdmVDaGlsZFZpZXcoYmxvYik7XG4gICAgICByb290LnJlZi5ibG9iID0gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHJvdXRlJDQgPSBjcmVhdGVSb3V0ZSh7XG4gICAgRElEX0RSQUc6IG1vdmVCbG9iLFxuICAgIERJRF9EUk9QOiBleHBsb2RlQmxvYixcbiAgICBESURfRU5EX0RSQUc6IGhpZGVCbG9iXG4gIH0pO1xuXG4gIHZhciBkcmlwID0gY3JlYXRlVmlldyh7XG4gICAgaWdub3JlUmVjdDogdHJ1ZSxcbiAgICBpZ25vcmVSZWN0VXBkYXRlOiB0cnVlLFxuICAgIG5hbWU6ICdkcmlwJyxcbiAgICB3cml0ZTogd3JpdGUkN1xuICB9KTtcblxuICB2YXIgY3JlYXRlJGMgPSBmdW5jdGlvbiBjcmVhdGUoX3JlZikge1xuICAgIHZhciByb290ID0gX3JlZi5yb290O1xuICAgIHJldHVybiAocm9vdC5yZWYuZmllbGRzID0ge30pO1xuICB9O1xuXG4gIHZhciBnZXRGaWVsZCA9IGZ1bmN0aW9uIGdldEZpZWxkKHJvb3QsIGlkKSB7XG4gICAgcmV0dXJuIHJvb3QucmVmLmZpZWxkc1tpZF07XG4gIH07XG5cbiAgdmFyIHN5bmNGaWVsZFBvc2l0aW9uc1dpdGhJdGVtcyA9IGZ1bmN0aW9uIHN5bmNGaWVsZFBvc2l0aW9uc1dpdGhJdGVtcyhyb290KSB7XG4gICAgcm9vdC5xdWVyeSgnR0VUX0FDVElWRV9JVEVNUycpLmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xuICAgICAgaWYgKCFyb290LnJlZi5maWVsZHNbaXRlbS5pZF0pIHJldHVybjtcbiAgICAgIHJvb3QuZWxlbWVudC5hcHBlbmRDaGlsZChyb290LnJlZi5maWVsZHNbaXRlbS5pZF0pO1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciBkaWRSZW9yZGVySXRlbXMgPSBmdW5jdGlvbiBkaWRSZW9yZGVySXRlbXMoX3JlZjIpIHtcbiAgICB2YXIgcm9vdCA9IF9yZWYyLnJvb3Q7XG4gICAgcmV0dXJuIHN5bmNGaWVsZFBvc2l0aW9uc1dpdGhJdGVtcyhyb290KTtcbiAgfTtcblxuICB2YXIgZGlkQWRkSXRlbSA9IGZ1bmN0aW9uIGRpZEFkZEl0ZW0oX3JlZjMpIHtcbiAgICB2YXIgcm9vdCA9IF9yZWYzLnJvb3QsXG4gICAgICBhY3Rpb24gPSBfcmVmMy5hY3Rpb247XG4gICAgdmFyIGRhdGFDb250YWluZXIgPSBjcmVhdGVFbGVtZW50JDEoJ2lucHV0Jyk7XG4gICAgZGF0YUNvbnRhaW5lci50eXBlID0gJ2hpZGRlbic7XG4gICAgZGF0YUNvbnRhaW5lci5uYW1lID0gcm9vdC5xdWVyeSgnR0VUX05BTUUnKTtcbiAgICBkYXRhQ29udGFpbmVyLmRpc2FibGVkID0gcm9vdC5xdWVyeSgnR0VUX0RJU0FCTEVEJyk7XG4gICAgcm9vdC5yZWYuZmllbGRzW2FjdGlvbi5pZF0gPSBkYXRhQ29udGFpbmVyO1xuICAgIHN5bmNGaWVsZFBvc2l0aW9uc1dpdGhJdGVtcyhyb290KTtcbiAgfTtcblxuICB2YXIgZGlkTG9hZEl0ZW0kMSA9IGZ1bmN0aW9uIGRpZExvYWRJdGVtKF9yZWY0KSB7XG4gICAgdmFyIHJvb3QgPSBfcmVmNC5yb290LFxuICAgICAgYWN0aW9uID0gX3JlZjQuYWN0aW9uO1xuICAgIHZhciBmaWVsZCA9IGdldEZpZWxkKHJvb3QsIGFjdGlvbi5pZCk7XG4gICAgaWYgKCFmaWVsZCB8fCBhY3Rpb24uc2VydmVyRmlsZVJlZmVyZW5jZSA9PT0gbnVsbCkgcmV0dXJuO1xuICAgIGZpZWxkLnZhbHVlID0gYWN0aW9uLnNlcnZlckZpbGVSZWZlcmVuY2U7XG4gIH07XG5cbiAgdmFyIGRpZFNldERpc2FibGVkID0gZnVuY3Rpb24gZGlkU2V0RGlzYWJsZWQoX3JlZjUpIHtcbiAgICB2YXIgcm9vdCA9IF9yZWY1LnJvb3Q7XG4gICAgcm9vdC5lbGVtZW50LmRpc2FibGVkID0gcm9vdC5xdWVyeSgnR0VUX0RJU0FCTEVEJyk7XG4gIH07XG5cbiAgdmFyIGRpZFJlbW92ZUl0ZW0gPSBmdW5jdGlvbiBkaWRSZW1vdmVJdGVtKF9yZWY2KSB7XG4gICAgdmFyIHJvb3QgPSBfcmVmNi5yb290LFxuICAgICAgYWN0aW9uID0gX3JlZjYuYWN0aW9uO1xuICAgIHZhciBmaWVsZCA9IGdldEZpZWxkKHJvb3QsIGFjdGlvbi5pZCk7XG4gICAgaWYgKCFmaWVsZCkgcmV0dXJuO1xuICAgIGlmIChmaWVsZC5wYXJlbnROb2RlKSBmaWVsZC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGZpZWxkKTtcbiAgICBkZWxldGUgcm9vdC5yZWYuZmllbGRzW2FjdGlvbi5pZF07XG4gIH07XG5cbiAgdmFyIGRpZERlZmluZVZhbHVlID0gZnVuY3Rpb24gZGlkRGVmaW5lVmFsdWUoX3JlZjcpIHtcbiAgICB2YXIgcm9vdCA9IF9yZWY3LnJvb3QsXG4gICAgICBhY3Rpb24gPSBfcmVmNy5hY3Rpb247XG4gICAgdmFyIGZpZWxkID0gZ2V0RmllbGQocm9vdCwgYWN0aW9uLmlkKTtcbiAgICBpZiAoIWZpZWxkKSByZXR1cm47XG4gICAgaWYgKGFjdGlvbi52YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgZmllbGQucmVtb3ZlQXR0cmlidXRlKCd2YWx1ZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmaWVsZC52YWx1ZSA9IGFjdGlvbi52YWx1ZTtcbiAgICB9XG4gICAgc3luY0ZpZWxkUG9zaXRpb25zV2l0aEl0ZW1zKHJvb3QpO1xuICB9O1xuXG4gIHZhciB3cml0ZSQ4ID0gY3JlYXRlUm91dGUoe1xuICAgIERJRF9TRVRfRElTQUJMRUQ6IGRpZFNldERpc2FibGVkLFxuICAgIERJRF9BRERfSVRFTTogZGlkQWRkSXRlbSxcbiAgICBESURfTE9BRF9JVEVNOiBkaWRMb2FkSXRlbSQxLFxuICAgIERJRF9SRU1PVkVfSVRFTTogZGlkUmVtb3ZlSXRlbSxcbiAgICBESURfREVGSU5FX1ZBTFVFOiBkaWREZWZpbmVWYWx1ZSxcbiAgICBESURfUkVPUkRFUl9JVEVNUzogZGlkUmVvcmRlckl0ZW1zLFxuICAgIERJRF9TT1JUX0lURU1TOiBkaWRSZW9yZGVySXRlbXNcbiAgfSk7XG5cbiAgdmFyIGRhdGEgPSBjcmVhdGVWaWV3KHtcbiAgICB0YWc6ICdmaWVsZHNldCcsXG4gICAgbmFtZTogJ2RhdGEnLFxuICAgIGNyZWF0ZTogY3JlYXRlJGMsXG4gICAgd3JpdGU6IHdyaXRlJDgsXG4gICAgaWdub3JlUmVjdDogdHJ1ZVxuICB9KTtcblxuICB2YXIgZ2V0Um9vdE5vZGUgPSBmdW5jdGlvbiBnZXRSb290Tm9kZShlbGVtZW50KSB7XG4gICAgcmV0dXJuICdnZXRSb290Tm9kZScgaW4gZWxlbWVudCA/IGVsZW1lbnQuZ2V0Um9vdE5vZGUoKSA6IGRvY3VtZW50O1xuICB9O1xuXG4gIHZhciBpbWFnZXMgPSBbJ2pwZycsICdqcGVnJywgJ3BuZycsICdnaWYnLCAnYm1wJywgJ3dlYnAnLCAnc3ZnJywgJ3RpZmYnXTtcbiAgdmFyIHRleHQkMSA9IFsnY3NzJywgJ2NzdicsICdodG1sJywgJ3R4dCddO1xuICB2YXIgbWFwID0ge1xuICAgIHppcDogJ3ppcHxjb21wcmVzc2VkJyxcbiAgICBlcHViOiAnYXBwbGljYXRpb24vZXB1Yit6aXAnXG4gIH07XG5cbiAgdmFyIGd1ZXNzdGltYXRlTWltZVR5cGUgPSBmdW5jdGlvbiBndWVzc3RpbWF0ZU1pbWVUeXBlKCkge1xuICAgIHZhciBleHRlbnNpb24gPVxuICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAnJztcbiAgICBleHRlbnNpb24gPSBleHRlbnNpb24udG9Mb3dlckNhc2UoKTtcbiAgICBpZiAoaW1hZ2VzLmluY2x1ZGVzKGV4dGVuc2lvbikpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgICdpbWFnZS8nICtcbiAgICAgICAgKGV4dGVuc2lvbiA9PT0gJ2pwZydcbiAgICAgICAgICA/ICdqcGVnJ1xuICAgICAgICAgIDogZXh0ZW5zaW9uID09PSAnc3ZnJ1xuICAgICAgICAgID8gJ3N2Zyt4bWwnXG4gICAgICAgICAgOiBleHRlbnNpb24pXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAodGV4dCQxLmluY2x1ZGVzKGV4dGVuc2lvbikpIHtcbiAgICAgIHJldHVybiAndGV4dC8nICsgZXh0ZW5zaW9uO1xuICAgIH1cblxuICAgIHJldHVybiBtYXBbZXh0ZW5zaW9uXSB8fCAnJztcbiAgfTtcblxuICB2YXIgcmVxdWVzdERhdGFUcmFuc2Zlckl0ZW1zID0gZnVuY3Rpb24gcmVxdWVzdERhdGFUcmFuc2Zlckl0ZW1zKFxuICAgIGRhdGFUcmFuc2ZlclxuICApIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAvLyB0cnkgdG8gZ2V0IGxpbmtzIGZyb20gdHJhbnNmZXIsIGlmIGZvdW5kIHdlJ2xsIGV4aXQgaW1tZWRpYXRlbHkgKHVubGVzcyBhIGZpbGUgaXMgaW4gdGhlIGRhdGFUcmFuc2ZlciBhcyB3ZWxsLCB0aGlzIGlzIGJlY2F1c2UgRmlyZWZveCBjb3VsZCByZXByZXNlbnQgdGhlIGZpbGUgYXMgYSBVUkwgYW5kIGEgZmlsZSBvYmplY3QgYXQgdGhlIHNhbWUgdGltZSlcbiAgICAgIHZhciBsaW5rcyA9IGdldExpbmtzKGRhdGFUcmFuc2Zlcik7XG4gICAgICBpZiAobGlua3MubGVuZ3RoICYmICFoYXNGaWxlcyhkYXRhVHJhbnNmZXIpKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlKGxpbmtzKTtcbiAgICAgIH1cbiAgICAgIC8vIHRyeSB0byBnZXQgZmlsZXMgZnJvbSB0aGUgdHJhbnNmZXJcbiAgICAgIGdldEZpbGVzKGRhdGFUcmFuc2ZlcikudGhlbihyZXNvbHZlKTtcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogVGVzdCBpZiBkYXRhdHJhbnNmZXIgaGFzIGZpbGVzXG4gICAqL1xuICB2YXIgaGFzRmlsZXMgPSBmdW5jdGlvbiBoYXNGaWxlcyhkYXRhVHJhbnNmZXIpIHtcbiAgICBpZiAoZGF0YVRyYW5zZmVyLmZpbGVzKSByZXR1cm4gZGF0YVRyYW5zZmVyLmZpbGVzLmxlbmd0aCA+IDA7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBFeHRyYWN0cyBmaWxlcyBmcm9tIGEgRGF0YVRyYW5zZmVyIG9iamVjdFxuICAgKi9cbiAgdmFyIGdldEZpbGVzID0gZnVuY3Rpb24gZ2V0RmlsZXMoZGF0YVRyYW5zZmVyKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgLy8gZ2V0IHRoZSB0cmFuc2ZlciBpdGVtcyBhcyBwcm9taXNlc1xuICAgICAgdmFyIHByb21pc2VkRmlsZXMgPSAoZGF0YVRyYW5zZmVyLml0ZW1zXG4gICAgICAgID8gQXJyYXkuZnJvbShkYXRhVHJhbnNmZXIuaXRlbXMpXG4gICAgICAgIDogW11cbiAgICAgIClcbiAgICAgICAgLy8gb25seSBrZWVwIGZpbGUgc3lzdGVtIGl0ZW1zIChmaWxlcyBhbmQgZGlyZWN0b3JpZXMpXG4gICAgICAgIC5maWx0ZXIoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgIHJldHVybiBpc0ZpbGVTeXN0ZW1JdGVtKGl0ZW0pO1xuICAgICAgICB9KVxuXG4gICAgICAgIC8vIG1hcCBlYWNoIGl0ZW0gdG8gcHJvbWlzZVxuICAgICAgICAubWFwKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICByZXR1cm4gZ2V0RmlsZXNGcm9tSXRlbShpdGVtKTtcbiAgICAgICAgfSk7XG5cbiAgICAgIC8vIGlmIGlzIGVtcHR5LCBzZWUgaWYgd2UgY2FuIGV4dHJhY3Qgc29tZSBpbmZvIGZyb20gdGhlIGZpbGVzIHByb3BlcnR5IGFzIGEgZmFsbGJhY2tcbiAgICAgIGlmICghcHJvbWlzZWRGaWxlcy5sZW5ndGgpIHtcbiAgICAgICAgLy8gVE9ETzogdGVzdCBmb3IgZGlyZWN0b3JpZXMgKHNob3VsZCBub3QgYmUgYWxsb3dlZClcbiAgICAgICAgLy8gVXNlIEZpbGVSZWFkZXIsIHByb2JsZW0gaXMgdGhhdCB0aGUgZmlsZXMgcHJvcGVydHkgZ2V0cyBsb3N0IGluIHRoZSBwcm9jZXNzXG4gICAgICAgIHJlc29sdmUoZGF0YVRyYW5zZmVyLmZpbGVzID8gQXJyYXkuZnJvbShkYXRhVHJhbnNmZXIuZmlsZXMpIDogW10pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIGRvbmUhXG4gICAgICBQcm9taXNlLmFsbChwcm9taXNlZEZpbGVzKVxuICAgICAgICAudGhlbihmdW5jdGlvbihyZXR1cm5lZEZpbGVHcm91cHMpIHtcbiAgICAgICAgICAvLyBmbGF0dGVuIGdyb3Vwc1xuICAgICAgICAgIHZhciBmaWxlcyA9IFtdO1xuICAgICAgICAgIHJldHVybmVkRmlsZUdyb3Vwcy5mb3JFYWNoKGZ1bmN0aW9uKGdyb3VwKSB7XG4gICAgICAgICAgICBmaWxlcy5wdXNoLmFwcGx5KGZpbGVzLCBncm91cCk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAvLyBkb25lIChmaWx0ZXIgb3V0IGVtcHR5IGZpbGVzKSFcbiAgICAgICAgICByZXNvbHZlKFxuICAgICAgICAgICAgZmlsZXNcbiAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbihmaWxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpbGU7XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24oZmlsZSkge1xuICAgICAgICAgICAgICAgIGlmICghZmlsZS5fcmVsYXRpdmVQYXRoKVxuICAgICAgICAgICAgICAgICAgZmlsZS5fcmVsYXRpdmVQYXRoID0gZmlsZS53ZWJraXRSZWxhdGl2ZVBhdGg7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpbGU7XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKGNvbnNvbGUuZXJyb3IpO1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciBpc0ZpbGVTeXN0ZW1JdGVtID0gZnVuY3Rpb24gaXNGaWxlU3lzdGVtSXRlbShpdGVtKSB7XG4gICAgaWYgKGlzRW50cnkoaXRlbSkpIHtcbiAgICAgIHZhciBlbnRyeSA9IGdldEFzRW50cnkoaXRlbSk7XG4gICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgcmV0dXJuIGVudHJ5LmlzRmlsZSB8fCBlbnRyeS5pc0RpcmVjdG9yeTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGl0ZW0ua2luZCA9PT0gJ2ZpbGUnO1xuICB9O1xuXG4gIHZhciBnZXRGaWxlc0Zyb21JdGVtID0gZnVuY3Rpb24gZ2V0RmlsZXNGcm9tSXRlbShpdGVtKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgaWYgKGlzRGlyZWN0b3J5RW50cnkoaXRlbSkpIHtcbiAgICAgICAgZ2V0RmlsZXNJbkRpcmVjdG9yeShnZXRBc0VudHJ5KGl0ZW0pKVxuICAgICAgICAgIC50aGVuKHJlc29sdmUpXG4gICAgICAgICAgLmNhdGNoKHJlamVjdCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcmVzb2x2ZShbaXRlbS5nZXRBc0ZpbGUoKV0pO1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciBnZXRGaWxlc0luRGlyZWN0b3J5ID0gZnVuY3Rpb24gZ2V0RmlsZXNJbkRpcmVjdG9yeShlbnRyeSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciBmaWxlcyA9IFtdO1xuXG4gICAgICAvLyB0aGUgdG90YWwgZW50cmllcyB0byByZWFkXG4gICAgICB2YXIgZGlyQ291bnRlciA9IDA7XG4gICAgICB2YXIgZmlsZUNvdW50ZXIgPSAwO1xuXG4gICAgICB2YXIgcmVzb2x2ZUlmRG9uZSA9IGZ1bmN0aW9uIHJlc29sdmVJZkRvbmUoKSB7XG4gICAgICAgIGlmIChmaWxlQ291bnRlciA9PT0gMCAmJiBkaXJDb3VudGVyID09PSAwKSB7XG4gICAgICAgICAgcmVzb2x2ZShmaWxlcyk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8vIHRoZSByZWN1cnNpdmUgZnVuY3Rpb25cbiAgICAgIHZhciByZWFkRW50cmllcyA9IGZ1bmN0aW9uIHJlYWRFbnRyaWVzKGRpckVudHJ5KSB7XG4gICAgICAgIGRpckNvdW50ZXIrKztcblxuICAgICAgICB2YXIgZGlyZWN0b3J5UmVhZGVyID0gZGlyRW50cnkuY3JlYXRlUmVhZGVyKCk7XG5cbiAgICAgICAgLy8gZGlyZWN0b3JpZXMgYXJlIHJldHVybmVkIGluIGJhdGNoZXMsIHdlIG5lZWQgdG8gcHJvY2VzcyBhbGwgYmF0Y2hlcyBiZWZvcmUgd2UncmUgZG9uZVxuICAgICAgICB2YXIgcmVhZEJhdGNoID0gZnVuY3Rpb24gcmVhZEJhdGNoKCkge1xuICAgICAgICAgIGRpcmVjdG9yeVJlYWRlci5yZWFkRW50cmllcyhmdW5jdGlvbihlbnRyaWVzKSB7XG4gICAgICAgICAgICBpZiAoZW50cmllcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgZGlyQ291bnRlci0tO1xuICAgICAgICAgICAgICByZXNvbHZlSWZEb25lKCk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZW50cmllcy5mb3JFYWNoKGZ1bmN0aW9uKGVudHJ5KSB7XG4gICAgICAgICAgICAgIC8vIHJlY3Vyc2l2ZWx5IHJlYWQgbW9yZSBkaXJlY3Rvcmllc1xuICAgICAgICAgICAgICBpZiAoZW50cnkuaXNEaXJlY3RvcnkpIHtcbiAgICAgICAgICAgICAgICByZWFkRW50cmllcyhlbnRyeSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gcmVhZCBhcyBmaWxlXG4gICAgICAgICAgICAgICAgZmlsZUNvdW50ZXIrKztcblxuICAgICAgICAgICAgICAgIGVudHJ5LmZpbGUoZnVuY3Rpb24oZmlsZSkge1xuICAgICAgICAgICAgICAgICAgdmFyIGNvcnJlY3RlZEZpbGUgPSBjb3JyZWN0TWlzc2luZ0ZpbGVUeXBlKGZpbGUpO1xuICAgICAgICAgICAgICAgICAgaWYgKGVudHJ5LmZ1bGxQYXRoKVxuICAgICAgICAgICAgICAgICAgICBjb3JyZWN0ZWRGaWxlLl9yZWxhdGl2ZVBhdGggPSBlbnRyeS5mdWxsUGF0aDtcbiAgICAgICAgICAgICAgICAgIGZpbGVzLnB1c2goY29ycmVjdGVkRmlsZSk7XG4gICAgICAgICAgICAgICAgICBmaWxlQ291bnRlci0tO1xuICAgICAgICAgICAgICAgICAgcmVzb2x2ZUlmRG9uZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gdHJ5IHRvIGdldCBuZXh0IGJhdGNoIG9mIGZpbGVzXG4gICAgICAgICAgICByZWFkQmF0Y2goKTtcbiAgICAgICAgICB9LCByZWplY3QpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHJlYWQgZmlyc3QgYmF0Y2ggb2YgZmlsZXNcbiAgICAgICAgcmVhZEJhdGNoKCk7XG4gICAgICB9O1xuXG4gICAgICAvLyBnbyFcbiAgICAgIHJlYWRFbnRyaWVzKGVudHJ5KTtcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgY29ycmVjdE1pc3NpbmdGaWxlVHlwZSA9IGZ1bmN0aW9uIGNvcnJlY3RNaXNzaW5nRmlsZVR5cGUoZmlsZSkge1xuICAgIGlmIChmaWxlLnR5cGUubGVuZ3RoKSByZXR1cm4gZmlsZTtcbiAgICB2YXIgZGF0ZSA9IGZpbGUubGFzdE1vZGlmaWVkRGF0ZTtcbiAgICB2YXIgbmFtZSA9IGZpbGUubmFtZTtcbiAgICB2YXIgdHlwZSA9IGd1ZXNzdGltYXRlTWltZVR5cGUoZ2V0RXh0ZW5zaW9uRnJvbUZpbGVuYW1lKGZpbGUubmFtZSkpO1xuICAgIGlmICghdHlwZS5sZW5ndGgpIHJldHVybiBmaWxlO1xuICAgIGZpbGUgPSBmaWxlLnNsaWNlKDAsIGZpbGUuc2l6ZSwgdHlwZSk7XG4gICAgZmlsZS5uYW1lID0gbmFtZTtcbiAgICBmaWxlLmxhc3RNb2RpZmllZERhdGUgPSBkYXRlO1xuICAgIHJldHVybiBmaWxlO1xuICB9O1xuXG4gIHZhciBpc0RpcmVjdG9yeUVudHJ5ID0gZnVuY3Rpb24gaXNEaXJlY3RvcnlFbnRyeShpdGVtKSB7XG4gICAgcmV0dXJuIGlzRW50cnkoaXRlbSkgJiYgKGdldEFzRW50cnkoaXRlbSkgfHwge30pLmlzRGlyZWN0b3J5O1xuICB9O1xuXG4gIHZhciBpc0VudHJ5ID0gZnVuY3Rpb24gaXNFbnRyeShpdGVtKSB7XG4gICAgcmV0dXJuICd3ZWJraXRHZXRBc0VudHJ5JyBpbiBpdGVtO1xuICB9O1xuXG4gIHZhciBnZXRBc0VudHJ5ID0gZnVuY3Rpb24gZ2V0QXNFbnRyeShpdGVtKSB7XG4gICAgcmV0dXJuIGl0ZW0ud2Via2l0R2V0QXNFbnRyeSgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBFeHRyYWN0cyBsaW5rcyBmcm9tIGEgRGF0YVRyYW5zZmVyIG9iamVjdFxuICAgKi9cbiAgdmFyIGdldExpbmtzID0gZnVuY3Rpb24gZ2V0TGlua3MoZGF0YVRyYW5zZmVyKSB7XG4gICAgdmFyIGxpbmtzID0gW107XG4gICAgdHJ5IHtcbiAgICAgIC8vIGxvb2sgaW4gbWV0YSBkYXRhIHByb3BlcnR5XG4gICAgICBsaW5rcyA9IGdldExpbmtzRnJvbVRyYW5zZmVyTWV0YURhdGEoZGF0YVRyYW5zZmVyKTtcbiAgICAgIGlmIChsaW5rcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGxpbmtzO1xuICAgICAgfVxuICAgICAgbGlua3MgPSBnZXRMaW5rc0Zyb21UcmFuc2ZlclVSTERhdGEoZGF0YVRyYW5zZmVyKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBub3BlIG5vcGUgbm9wZSAocHJvYmFibHkgSUUgdHJvdWJsZSlcbiAgICB9XG4gICAgcmV0dXJuIGxpbmtzO1xuICB9O1xuXG4gIHZhciBnZXRMaW5rc0Zyb21UcmFuc2ZlclVSTERhdGEgPSBmdW5jdGlvbiBnZXRMaW5rc0Zyb21UcmFuc2ZlclVSTERhdGEoXG4gICAgZGF0YVRyYW5zZmVyXG4gICkge1xuICAgIHZhciBkYXRhID0gZGF0YVRyYW5zZmVyLmdldERhdGEoJ3VybCcpO1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycgJiYgZGF0YS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBbZGF0YV07XG4gICAgfVxuICAgIHJldHVybiBbXTtcbiAgfTtcblxuICB2YXIgZ2V0TGlua3NGcm9tVHJhbnNmZXJNZXRhRGF0YSA9IGZ1bmN0aW9uIGdldExpbmtzRnJvbVRyYW5zZmVyTWV0YURhdGEoXG4gICAgZGF0YVRyYW5zZmVyXG4gICkge1xuICAgIHZhciBkYXRhID0gZGF0YVRyYW5zZmVyLmdldERhdGEoJ3RleHQvaHRtbCcpO1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycgJiYgZGF0YS5sZW5ndGgpIHtcbiAgICAgIHZhciBtYXRjaGVzID0gZGF0YS5tYXRjaCgvc3JjXFxzKj1cXHMqXCIoLis/KVwiLyk7XG4gICAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICByZXR1cm4gW21hdGNoZXNbMV1dO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW107XG4gIH07XG5cbiAgdmFyIGRyYWdORHJvcE9ic2VydmVycyA9IFtdO1xuXG4gIHZhciBldmVudFBvc2l0aW9uID0gZnVuY3Rpb24gZXZlbnRQb3NpdGlvbihlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhZ2VMZWZ0OiBlLnBhZ2VYLFxuICAgICAgcGFnZVRvcDogZS5wYWdlWSxcbiAgICAgIHNjb3BlTGVmdDogZS5vZmZzZXRYIHx8IGUubGF5ZXJYLFxuICAgICAgc2NvcGVUb3A6IGUub2Zmc2V0WSB8fCBlLmxheWVyWVxuICAgIH07XG4gIH07XG5cbiAgdmFyIGNyZWF0ZURyYWdORHJvcENsaWVudCA9IGZ1bmN0aW9uIGNyZWF0ZURyYWdORHJvcENsaWVudChcbiAgICBlbGVtZW50LFxuICAgIHNjb3BlVG9PYnNlcnZlLFxuICAgIGZpbHRlckVsZW1lbnRcbiAgKSB7XG4gICAgdmFyIG9ic2VydmVyID0gZ2V0RHJhZ05Ecm9wT2JzZXJ2ZXIoc2NvcGVUb09ic2VydmUpO1xuXG4gICAgdmFyIGNsaWVudCA9IHtcbiAgICAgIGVsZW1lbnQ6IGVsZW1lbnQsXG4gICAgICBmaWx0ZXJFbGVtZW50OiBmaWx0ZXJFbGVtZW50LFxuICAgICAgc3RhdGU6IG51bGwsXG4gICAgICBvbmRyb3A6IGZ1bmN0aW9uIG9uZHJvcCgpIHt9LFxuICAgICAgb25lbnRlcjogZnVuY3Rpb24gb25lbnRlcigpIHt9LFxuICAgICAgb25kcmFnOiBmdW5jdGlvbiBvbmRyYWcoKSB7fSxcbiAgICAgIG9uZXhpdDogZnVuY3Rpb24gb25leGl0KCkge30sXG4gICAgICBvbmxvYWQ6IGZ1bmN0aW9uIG9ubG9hZCgpIHt9LFxuICAgICAgYWxsb3dkcm9wOiBmdW5jdGlvbiBhbGxvd2Ryb3AoKSB7fVxuICAgIH07XG5cbiAgICBjbGllbnQuZGVzdHJveSA9IG9ic2VydmVyLmFkZExpc3RlbmVyKGNsaWVudCk7XG5cbiAgICByZXR1cm4gY2xpZW50O1xuICB9O1xuXG4gIHZhciBnZXREcmFnTkRyb3BPYnNlcnZlciA9IGZ1bmN0aW9uIGdldERyYWdORHJvcE9ic2VydmVyKGVsZW1lbnQpIHtcbiAgICAvLyBzZWUgaWYgYWxyZWFkeSBleGlzdHMsIGlmIHNvLCByZXR1cm5cbiAgICB2YXIgb2JzZXJ2ZXIgPSBkcmFnTkRyb3BPYnNlcnZlcnMuZmluZChmdW5jdGlvbihpdGVtKSB7XG4gICAgICByZXR1cm4gaXRlbS5lbGVtZW50ID09PSBlbGVtZW50O1xuICAgIH0pO1xuICAgIGlmIChvYnNlcnZlcikge1xuICAgICAgcmV0dXJuIG9ic2VydmVyO1xuICAgIH1cblxuICAgIC8vIGNyZWF0ZSBuZXcgb2JzZXJ2ZXIsIGRvZXMgbm90IHlldCBleGlzdCBmb3IgdGhpcyBlbGVtZW50XG4gICAgdmFyIG5ld09ic2VydmVyID0gY3JlYXRlRHJhZ05Ecm9wT2JzZXJ2ZXIoZWxlbWVudCk7XG4gICAgZHJhZ05Ecm9wT2JzZXJ2ZXJzLnB1c2gobmV3T2JzZXJ2ZXIpO1xuICAgIHJldHVybiBuZXdPYnNlcnZlcjtcbiAgfTtcblxuICB2YXIgY3JlYXRlRHJhZ05Ecm9wT2JzZXJ2ZXIgPSBmdW5jdGlvbiBjcmVhdGVEcmFnTkRyb3BPYnNlcnZlcihlbGVtZW50KSB7XG4gICAgdmFyIGNsaWVudHMgPSBbXTtcblxuICAgIHZhciByb3V0ZXMgPSB7XG4gICAgICBkcmFnZW50ZXI6IGRyYWdlbnRlcixcbiAgICAgIGRyYWdvdmVyOiBkcmFnb3ZlcixcbiAgICAgIGRyYWdsZWF2ZTogZHJhZ2xlYXZlLFxuICAgICAgZHJvcDogZHJvcFxuICAgIH07XG5cbiAgICB2YXIgaGFuZGxlcnMgPSB7fTtcblxuICAgIGZvcmluKHJvdXRlcywgZnVuY3Rpb24oZXZlbnQsIGNyZWF0ZUhhbmRsZXIpIHtcbiAgICAgIGhhbmRsZXJzW2V2ZW50XSA9IGNyZWF0ZUhhbmRsZXIoZWxlbWVudCwgY2xpZW50cyk7XG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXJzW2V2ZW50XSwgZmFsc2UpO1xuICAgIH0pO1xuXG4gICAgdmFyIG9ic2VydmVyID0ge1xuICAgICAgZWxlbWVudDogZWxlbWVudCxcbiAgICAgIGFkZExpc3RlbmVyOiBmdW5jdGlvbiBhZGRMaXN0ZW5lcihjbGllbnQpIHtcbiAgICAgICAgLy8gYWRkIGFzIGNsaWVudFxuICAgICAgICBjbGllbnRzLnB1c2goY2xpZW50KTtcblxuICAgICAgICAvLyByZXR1cm4gcmVtb3ZlTGlzdGVuZXIgZnVuY3Rpb25cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIC8vIHJlbW92ZSBjbGllbnRcbiAgICAgICAgICBjbGllbnRzLnNwbGljZShjbGllbnRzLmluZGV4T2YoY2xpZW50KSwgMSk7XG5cbiAgICAgICAgICAvLyBpZiBubyBtb3JlIGNsaWVudHMsIGNsZWFuIHVwIG9ic2VydmVyXG4gICAgICAgICAgaWYgKGNsaWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBkcmFnTkRyb3BPYnNlcnZlcnMuc3BsaWNlKGRyYWdORHJvcE9ic2VydmVycy5pbmRleE9mKG9ic2VydmVyKSwgMSk7XG5cbiAgICAgICAgICAgIGZvcmluKHJvdXRlcywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyc1tldmVudF0sIGZhbHNlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIG9ic2VydmVyO1xuICB9O1xuXG4gIHZhciBlbGVtZW50RnJvbVBvaW50ID0gZnVuY3Rpb24gZWxlbWVudEZyb21Qb2ludChyb290LCBwb2ludCkge1xuICAgIGlmICghKCdlbGVtZW50RnJvbVBvaW50JyBpbiByb290KSkge1xuICAgICAgcm9vdCA9IGRvY3VtZW50O1xuICAgIH1cbiAgICByZXR1cm4gcm9vdC5lbGVtZW50RnJvbVBvaW50KHBvaW50LngsIHBvaW50LnkpO1xuICB9O1xuXG4gIHZhciBpc0V2ZW50VGFyZ2V0ID0gZnVuY3Rpb24gaXNFdmVudFRhcmdldChlLCB0YXJnZXQpIHtcbiAgICAvLyBnZXQgcm9vdFxuICAgIHZhciByb290ID0gZ2V0Um9vdE5vZGUodGFyZ2V0KTtcblxuICAgIC8vIGdldCBlbGVtZW50IGF0IHBvc2l0aW9uXG4gICAgLy8gaWYgcm9vdCBpcyBub3QgYWN0dWFsIHNoYWRvdyBET00gYW5kIGRvZXMgbm90IGhhdmUgZWxlbWVudEZyb21Qb2ludCBtZXRob2QsIHVzZSB0aGUgb25lIG9uIGRvY3VtZW50XG4gICAgdmFyIGVsZW1lbnRBdFBvc2l0aW9uID0gZWxlbWVudEZyb21Qb2ludChyb290LCB7XG4gICAgICB4OiBlLnBhZ2VYIC0gd2luZG93LnBhZ2VYT2Zmc2V0LFxuICAgICAgeTogZS5wYWdlWSAtIHdpbmRvdy5wYWdlWU9mZnNldFxuICAgIH0pO1xuXG4gICAgLy8gdGVzdCBpZiB0YXJnZXQgaXMgdGhlIGVsZW1lbnQgb3IgaWYgb25lIG9mIGl0cyBjaGlsZHJlbiBpc1xuICAgIHJldHVybiBlbGVtZW50QXRQb3NpdGlvbiA9PT0gdGFyZ2V0IHx8IHRhcmdldC5jb250YWlucyhlbGVtZW50QXRQb3NpdGlvbik7XG4gIH07XG5cbiAgdmFyIGluaXRpYWxUYXJnZXQgPSBudWxsO1xuXG4gIHZhciBzZXREcm9wRWZmZWN0ID0gZnVuY3Rpb24gc2V0RHJvcEVmZmVjdChkYXRhVHJhbnNmZXIsIGVmZmVjdCkge1xuICAgIC8vIGlzIGluIHRyeSBjYXRjaCBhcyBJRTExIHdpbGwgdGhyb3cgZXJyb3IgaWYgbm90XG4gICAgdHJ5IHtcbiAgICAgIGRhdGFUcmFuc2Zlci5kcm9wRWZmZWN0ID0gZWZmZWN0O1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH07XG5cbiAgdmFyIGRyYWdlbnRlciA9IGZ1bmN0aW9uIGRyYWdlbnRlcihyb290LCBjbGllbnRzKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGUpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgaW5pdGlhbFRhcmdldCA9IGUudGFyZ2V0O1xuXG4gICAgICBjbGllbnRzLmZvckVhY2goZnVuY3Rpb24oY2xpZW50KSB7XG4gICAgICAgIHZhciBlbGVtZW50ID0gY2xpZW50LmVsZW1lbnQsXG4gICAgICAgICAgb25lbnRlciA9IGNsaWVudC5vbmVudGVyO1xuXG4gICAgICAgIGlmIChpc0V2ZW50VGFyZ2V0KGUsIGVsZW1lbnQpKSB7XG4gICAgICAgICAgY2xpZW50LnN0YXRlID0gJ2VudGVyJztcblxuICAgICAgICAgIC8vIGZpcmUgZW50ZXIgZXZlbnRcbiAgICAgICAgICBvbmVudGVyKGV2ZW50UG9zaXRpb24oZSkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBkcmFnb3ZlciA9IGZ1bmN0aW9uIGRyYWdvdmVyKHJvb3QsIGNsaWVudHMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oZSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICB2YXIgZGF0YVRyYW5zZmVyID0gZS5kYXRhVHJhbnNmZXI7XG5cbiAgICAgIHJlcXVlc3REYXRhVHJhbnNmZXJJdGVtcyhkYXRhVHJhbnNmZXIpLnRoZW4oZnVuY3Rpb24oaXRlbXMpIHtcbiAgICAgICAgdmFyIG92ZXJEcm9wVGFyZ2V0ID0gZmFsc2U7XG5cbiAgICAgICAgY2xpZW50cy5zb21lKGZ1bmN0aW9uKGNsaWVudCkge1xuICAgICAgICAgIHZhciBmaWx0ZXJFbGVtZW50ID0gY2xpZW50LmZpbHRlckVsZW1lbnQsXG4gICAgICAgICAgICBlbGVtZW50ID0gY2xpZW50LmVsZW1lbnQsXG4gICAgICAgICAgICBvbmVudGVyID0gY2xpZW50Lm9uZW50ZXIsXG4gICAgICAgICAgICBvbmV4aXQgPSBjbGllbnQub25leGl0LFxuICAgICAgICAgICAgb25kcmFnID0gY2xpZW50Lm9uZHJhZyxcbiAgICAgICAgICAgIGFsbG93ZHJvcCA9IGNsaWVudC5hbGxvd2Ryb3A7XG5cbiAgICAgICAgICAvLyBieSBkZWZhdWx0IHdlIGNhbiBkcm9wXG4gICAgICAgICAgc2V0RHJvcEVmZmVjdChkYXRhVHJhbnNmZXIsICdjb3B5Jyk7XG5cbiAgICAgICAgICAvLyBhbGxvdyB0cmFuc2ZlciBvZiB0aGVzZSBpdGVtc1xuICAgICAgICAgIHZhciBhbGxvd3NUcmFuc2ZlciA9IGFsbG93ZHJvcChpdGVtcyk7XG5cbiAgICAgICAgICAvLyBvbmx5IHVzZWQgd2hlbiBjYW4gYmUgZHJvcHBlZCBvbiBwYWdlXG4gICAgICAgICAgaWYgKCFhbGxvd3NUcmFuc2Zlcikge1xuICAgICAgICAgICAgc2V0RHJvcEVmZmVjdChkYXRhVHJhbnNmZXIsICdub25lJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gdGFyZ2V0dGluZyB0aGlzIGNsaWVudFxuICAgICAgICAgIGlmIChpc0V2ZW50VGFyZ2V0KGUsIGVsZW1lbnQpKSB7XG4gICAgICAgICAgICBvdmVyRHJvcFRhcmdldCA9IHRydWU7XG5cbiAgICAgICAgICAgIC8vIGhhZCBubyBwcmV2aW91cyBzdGF0ZSwgbWVhbnMgd2UgYXJlIGVudGVyaW5nIHRoaXMgY2xpZW50XG4gICAgICAgICAgICBpZiAoY2xpZW50LnN0YXRlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIGNsaWVudC5zdGF0ZSA9ICdlbnRlcic7XG4gICAgICAgICAgICAgIG9uZW50ZXIoZXZlbnRQb3NpdGlvbihlKSk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gbm93IG92ZXIgZWxlbWVudCAobm8gbWF0dGVyIGlmIGl0IGFsbG93cyB0aGUgZHJvcCBvciBub3QpXG4gICAgICAgICAgICBjbGllbnQuc3RhdGUgPSAnb3Zlcic7XG5cbiAgICAgICAgICAgIC8vIG5lZWRzIHRvIGFsbG93IHRyYW5zZmVyXG4gICAgICAgICAgICBpZiAoZmlsdGVyRWxlbWVudCAmJiAhYWxsb3dzVHJhbnNmZXIpIHtcbiAgICAgICAgICAgICAgc2V0RHJvcEVmZmVjdChkYXRhVHJhbnNmZXIsICdub25lJyk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZHJhZ2dpbmdcbiAgICAgICAgICAgIG9uZHJhZyhldmVudFBvc2l0aW9uKGUpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gc2hvdWxkIGJlIG92ZXIgYW4gZWxlbWVudCB0byBkcm9wXG4gICAgICAgICAgICBpZiAoZmlsdGVyRWxlbWVudCAmJiAhb3ZlckRyb3BUYXJnZXQpIHtcbiAgICAgICAgICAgICAgc2V0RHJvcEVmZmVjdChkYXRhVHJhbnNmZXIsICdub25lJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIG1pZ2h0IGhhdmUganVzdCBsZWZ0IHRoaXMgY2xpZW50P1xuICAgICAgICAgICAgaWYgKGNsaWVudC5zdGF0ZSkge1xuICAgICAgICAgICAgICBjbGllbnQuc3RhdGUgPSBudWxsO1xuICAgICAgICAgICAgICBvbmV4aXQoZXZlbnRQb3NpdGlvbihlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIGRyb3AgPSBmdW5jdGlvbiBkcm9wKHJvb3QsIGNsaWVudHMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oZSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICB2YXIgZGF0YVRyYW5zZmVyID0gZS5kYXRhVHJhbnNmZXI7XG5cbiAgICAgIHJlcXVlc3REYXRhVHJhbnNmZXJJdGVtcyhkYXRhVHJhbnNmZXIpLnRoZW4oZnVuY3Rpb24oaXRlbXMpIHtcbiAgICAgICAgY2xpZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGNsaWVudCkge1xuICAgICAgICAgIHZhciBmaWx0ZXJFbGVtZW50ID0gY2xpZW50LmZpbHRlckVsZW1lbnQsXG4gICAgICAgICAgICBlbGVtZW50ID0gY2xpZW50LmVsZW1lbnQsXG4gICAgICAgICAgICBvbmRyb3AgPSBjbGllbnQub25kcm9wLFxuICAgICAgICAgICAgb25leGl0ID0gY2xpZW50Lm9uZXhpdCxcbiAgICAgICAgICAgIGFsbG93ZHJvcCA9IGNsaWVudC5hbGxvd2Ryb3A7XG5cbiAgICAgICAgICBjbGllbnQuc3RhdGUgPSBudWxsO1xuXG4gICAgICAgICAgLy8gaWYgd2UncmUgZmlsdGVyaW5nIG9uIGVsZW1lbnQgd2UgbmVlZCB0byBiZSBvdmVyIHRoZSBlbGVtZW50IHRvIGRyb3BcbiAgICAgICAgICBpZiAoZmlsdGVyRWxlbWVudCAmJiAhaXNFdmVudFRhcmdldChlLCBlbGVtZW50KSkgcmV0dXJuO1xuXG4gICAgICAgICAgLy8gbm8gdHJhbnNmZXIgZm9yIHRoaXMgY2xpZW50XG4gICAgICAgICAgaWYgKCFhbGxvd2Ryb3AoaXRlbXMpKSByZXR1cm4gb25leGl0KGV2ZW50UG9zaXRpb24oZSkpO1xuXG4gICAgICAgICAgLy8gd2UgY2FuIGRyb3AgdGhlc2UgaXRlbXMgb24gdGhpcyBjbGllbnRcbiAgICAgICAgICBvbmRyb3AoZXZlbnRQb3NpdGlvbihlKSwgaXRlbXMpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIGRyYWdsZWF2ZSA9IGZ1bmN0aW9uIGRyYWdsZWF2ZShyb290LCBjbGllbnRzKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmIChpbml0aWFsVGFyZ2V0ICE9PSBlLnRhcmdldCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNsaWVudHMuZm9yRWFjaChmdW5jdGlvbihjbGllbnQpIHtcbiAgICAgICAgdmFyIG9uZXhpdCA9IGNsaWVudC5vbmV4aXQ7XG5cbiAgICAgICAgY2xpZW50LnN0YXRlID0gbnVsbDtcblxuICAgICAgICBvbmV4aXQoZXZlbnRQb3NpdGlvbihlKSk7XG4gICAgICB9KTtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBjcmVhdGVIb3BwZXIgPSBmdW5jdGlvbiBjcmVhdGVIb3BwZXIoc2NvcGUsIHZhbGlkYXRlSXRlbXMsIG9wdGlvbnMpIHtcbiAgICAvLyBpcyBub3cgaG9wcGVyIHNjb3BlXG4gICAgc2NvcGUuY2xhc3NMaXN0LmFkZCgnZmlsZXBvbmQtLWhvcHBlcicpO1xuXG4gICAgLy8gc2hvcnRjdXRzXG4gICAgdmFyIGNhdGNoZXNEcm9wc09uUGFnZSA9IG9wdGlvbnMuY2F0Y2hlc0Ryb3BzT25QYWdlLFxuICAgICAgcmVxdWlyZXNEcm9wT25FbGVtZW50ID0gb3B0aW9ucy5yZXF1aXJlc0Ryb3BPbkVsZW1lbnQsXG4gICAgICBfb3B0aW9ucyRmaWx0ZXJJdGVtcyA9IG9wdGlvbnMuZmlsdGVySXRlbXMsXG4gICAgICBmaWx0ZXJJdGVtcyA9XG4gICAgICAgIF9vcHRpb25zJGZpbHRlckl0ZW1zID09PSB2b2lkIDBcbiAgICAgICAgICA/IGZ1bmN0aW9uKGl0ZW1zKSB7XG4gICAgICAgICAgICAgIHJldHVybiBpdGVtcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICA6IF9vcHRpb25zJGZpbHRlckl0ZW1zO1xuXG4gICAgLy8gY3JlYXRlIGEgZG5kIGNsaWVudFxuICAgIHZhciBjbGllbnQgPSBjcmVhdGVEcmFnTkRyb3BDbGllbnQoXG4gICAgICBzY29wZSxcbiAgICAgIGNhdGNoZXNEcm9wc09uUGFnZSA/IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCA6IHNjb3BlLFxuICAgICAgcmVxdWlyZXNEcm9wT25FbGVtZW50XG4gICAgKTtcblxuICAgIC8vIGN1cnJlbnQgY2xpZW50IHN0YXRlXG4gICAgdmFyIGxhc3RTdGF0ZSA9ICcnO1xuICAgIHZhciBjdXJyZW50U3RhdGUgPSAnJztcblxuICAgIC8vIGRldGVybWluZXMgaWYgYSBmaWxlIG1heSBiZSBkcm9wcGVkXG4gICAgY2xpZW50LmFsbG93ZHJvcCA9IGZ1bmN0aW9uKGl0ZW1zKSB7XG4gICAgICAvLyBUT0RPOiBpZiB3ZSBjYW4sIHRocm93IGVycm9yIHRvIGluZGljYXRlIHRoZSBpdGVtcyBjYW5ub3QgYnkgZHJvcHBlZFxuXG4gICAgICByZXR1cm4gdmFsaWRhdGVJdGVtcyhmaWx0ZXJJdGVtcyhpdGVtcykpO1xuICAgIH07XG5cbiAgICBjbGllbnQub25kcm9wID0gZnVuY3Rpb24ocG9zaXRpb24sIGl0ZW1zKSB7XG4gICAgICB2YXIgZmlsdGVyZWRJdGVtcyA9IGZpbHRlckl0ZW1zKGl0ZW1zKTtcblxuICAgICAgaWYgKCF2YWxpZGF0ZUl0ZW1zKGZpbHRlcmVkSXRlbXMpKSB7XG4gICAgICAgIGFwaS5vbmRyYWdlbmQocG9zaXRpb24pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGN1cnJlbnRTdGF0ZSA9ICdkcmFnLWRyb3AnO1xuXG4gICAgICBhcGkub25sb2FkKGZpbHRlcmVkSXRlbXMsIHBvc2l0aW9uKTtcbiAgICB9O1xuXG4gICAgY2xpZW50Lm9uZHJhZyA9IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XG4gICAgICBhcGkub25kcmFnKHBvc2l0aW9uKTtcbiAgICB9O1xuXG4gICAgY2xpZW50Lm9uZW50ZXIgPSBmdW5jdGlvbihwb3NpdGlvbikge1xuICAgICAgY3VycmVudFN0YXRlID0gJ2RyYWctb3Zlcic7XG5cbiAgICAgIGFwaS5vbmRyYWdzdGFydChwb3NpdGlvbik7XG4gICAgfTtcblxuICAgIGNsaWVudC5vbmV4aXQgPSBmdW5jdGlvbihwb3NpdGlvbikge1xuICAgICAgY3VycmVudFN0YXRlID0gJ2RyYWctZXhpdCc7XG5cbiAgICAgIGFwaS5vbmRyYWdlbmQocG9zaXRpb24pO1xuICAgIH07XG5cbiAgICB2YXIgYXBpID0ge1xuICAgICAgdXBkYXRlSG9wcGVyU3RhdGU6IGZ1bmN0aW9uIHVwZGF0ZUhvcHBlclN0YXRlKCkge1xuICAgICAgICBpZiAobGFzdFN0YXRlICE9PSBjdXJyZW50U3RhdGUpIHtcbiAgICAgICAgICBzY29wZS5kYXRhc2V0LmhvcHBlclN0YXRlID0gY3VycmVudFN0YXRlO1xuICAgICAgICAgIGxhc3RTdGF0ZSA9IGN1cnJlbnRTdGF0ZTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9ubG9hZDogZnVuY3Rpb24gb25sb2FkKCkge30sXG4gICAgICBvbmRyYWdzdGFydDogZnVuY3Rpb24gb25kcmFnc3RhcnQoKSB7fSxcbiAgICAgIG9uZHJhZzogZnVuY3Rpb24gb25kcmFnKCkge30sXG4gICAgICBvbmRyYWdlbmQ6IGZ1bmN0aW9uIG9uZHJhZ2VuZCgpIHt9LFxuICAgICAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgLy8gZGVzdHJveSBjbGllbnRcbiAgICAgICAgY2xpZW50LmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIGFwaTtcbiAgfTtcblxuICB2YXIgbGlzdGVuaW5nID0gZmFsc2U7XG4gIHZhciBsaXN0ZW5lcnMkMSA9IFtdO1xuXG4gIHZhciBoYW5kbGVQYXN0ZSA9IGZ1bmN0aW9uIGhhbmRsZVBhc3RlKGUpIHtcbiAgICAvLyBpZiBpcyBwYXN0aW5nIGluIGlucHV0IG9yIHRleHRhcmVhIGFuZCB0aGUgdGFyZ2V0IGlzIG91dHNpZGUgb2YgYSBmaWxlcG9uZCBzY29wZSwgaWdub3JlXG4gICAgdmFyIGFjdGl2ZUVsID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICBpZiAoYWN0aXZlRWwgJiYgL3RleHRhcmVhfGlucHV0L2kudGVzdChhY3RpdmVFbC5ub2RlTmFtZSkpIHtcbiAgICAgIC8vIHRlc3QgdGV4dGFyZWEgb3IgaW5wdXQgaXMgY29udGFpbmVkIGluIGZpbGVwb25kIHJvb3RcbiAgICAgIHZhciBpblNjb3BlID0gZmFsc2U7XG4gICAgICB2YXIgZWxlbWVudCA9IGFjdGl2ZUVsO1xuICAgICAgd2hpbGUgKGVsZW1lbnQgIT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgaWYgKGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdmaWxlcG9uZC0tcm9vdCcpKSB7XG4gICAgICAgICAgaW5TY29wZSA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpblNjb3BlKSByZXR1cm47XG4gICAgfVxuXG4gICAgcmVxdWVzdERhdGFUcmFuc2Zlckl0ZW1zKGUuY2xpcGJvYXJkRGF0YSkudGhlbihmdW5jdGlvbihmaWxlcykge1xuICAgICAgLy8gbm8gZmlsZXMgcmVjZWl2ZWRcbiAgICAgIGlmICghZmlsZXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gbm90aWZ5IGxpc3RlbmVycyBvZiByZWNlaXZlZCBmaWxlc1xuICAgICAgbGlzdGVuZXJzJDEuZm9yRWFjaChmdW5jdGlvbihsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gbGlzdGVuZXIoZmlsZXMpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIGxpc3RlbiA9IGZ1bmN0aW9uIGxpc3RlbihjYikge1xuICAgIC8vIGNhbid0IGFkZCB0d2ljZVxuICAgIGlmIChsaXN0ZW5lcnMkMS5pbmNsdWRlcyhjYikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBhZGQgaW5pdGlhbCBsaXN0ZW5lclxuICAgIGxpc3RlbmVycyQxLnB1c2goY2IpO1xuXG4gICAgLy8gc2V0dXAgcGFzdGUgbGlzdGVuZXIgZm9yIGVudGlyZSBwYWdlXG4gICAgaWYgKGxpc3RlbmluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxpc3RlbmluZyA9IHRydWU7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncGFzdGUnLCBoYW5kbGVQYXN0ZSk7XG4gIH07XG5cbiAgdmFyIHVubGlzdGVuID0gZnVuY3Rpb24gdW5saXN0ZW4obGlzdGVuZXIpIHtcbiAgICBhcnJheVJlbW92ZShsaXN0ZW5lcnMkMSwgbGlzdGVuZXJzJDEuaW5kZXhPZihsaXN0ZW5lcikpO1xuXG4gICAgLy8gY2xlYW4gdXBcbiAgICBpZiAobGlzdGVuZXJzJDEubGVuZ3RoID09PSAwKSB7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdwYXN0ZScsIGhhbmRsZVBhc3RlKTtcbiAgICAgIGxpc3RlbmluZyA9IGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICB2YXIgY3JlYXRlUGFzdGVyID0gZnVuY3Rpb24gY3JlYXRlUGFzdGVyKCkge1xuICAgIHZhciBjYiA9IGZ1bmN0aW9uIGNiKGZpbGVzKSB7XG4gICAgICBhcGkub25sb2FkKGZpbGVzKTtcbiAgICB9O1xuXG4gICAgdmFyIGFwaSA9IHtcbiAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIHVubGlzdGVuKGNiKTtcbiAgICAgIH0sXG4gICAgICBvbmxvYWQ6IGZ1bmN0aW9uIG9ubG9hZCgpIHt9XG4gICAgfTtcblxuICAgIGxpc3RlbihjYik7XG5cbiAgICByZXR1cm4gYXBpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIHRoZSBmaWxlIHZpZXdcbiAgICovXG4gIHZhciBjcmVhdGUkZCA9IGZ1bmN0aW9uIGNyZWF0ZShfcmVmKSB7XG4gICAgdmFyIHJvb3QgPSBfcmVmLnJvb3QsXG4gICAgICBwcm9wcyA9IF9yZWYucHJvcHM7XG4gICAgcm9vdC5lbGVtZW50LmlkID0gJ2ZpbGVwb25kLS1hc3Npc3RhbnQtJyArIHByb3BzLmlkO1xuICAgIGF0dHIocm9vdC5lbGVtZW50LCAncm9sZScsICdzdGF0dXMnKTtcbiAgICBhdHRyKHJvb3QuZWxlbWVudCwgJ2FyaWEtbGl2ZScsICdwb2xpdGUnKTtcbiAgICBhdHRyKHJvb3QuZWxlbWVudCwgJ2FyaWEtcmVsZXZhbnQnLCAnYWRkaXRpb25zJyk7XG4gIH07XG5cbiAgdmFyIGFkZEZpbGVzTm90aWZpY2F0aW9uVGltZW91dCA9IG51bGw7XG4gIHZhciBub3RpZmljYXRpb25DbGVhclRpbWVvdXQgPSBudWxsO1xuXG4gIHZhciBmaWxlbmFtZXMgPSBbXTtcblxuICB2YXIgYXNzaXN0ID0gZnVuY3Rpb24gYXNzaXN0KHJvb3QsIG1lc3NhZ2UpIHtcbiAgICByb290LmVsZW1lbnQudGV4dENvbnRlbnQgPSBtZXNzYWdlO1xuICB9O1xuXG4gIHZhciBjbGVhciQxID0gZnVuY3Rpb24gY2xlYXIocm9vdCkge1xuICAgIHJvb3QuZWxlbWVudC50ZXh0Q29udGVudCA9ICcnO1xuICB9O1xuXG4gIHZhciBsaXN0TW9kaWZpZWQgPSBmdW5jdGlvbiBsaXN0TW9kaWZpZWQocm9vdCwgZmlsZW5hbWUsIGxhYmVsKSB7XG4gICAgdmFyIHRvdGFsID0gcm9vdC5xdWVyeSgnR0VUX1RPVEFMX0lURU1TJyk7XG4gICAgYXNzaXN0KFxuICAgICAgcm9vdCxcbiAgICAgIGxhYmVsICtcbiAgICAgICAgJyAnICtcbiAgICAgICAgZmlsZW5hbWUgK1xuICAgICAgICAnLCAnICtcbiAgICAgICAgdG90YWwgK1xuICAgICAgICAnICcgK1xuICAgICAgICAodG90YWwgPT09IDFcbiAgICAgICAgICA/IHJvb3QucXVlcnkoJ0dFVF9MQUJFTF9GSUxFX0NPVU5UX1NJTkdVTEFSJylcbiAgICAgICAgICA6IHJvb3QucXVlcnkoJ0dFVF9MQUJFTF9GSUxFX0NPVU5UX1BMVVJBTCcpKVxuICAgICk7XG5cbiAgICAvLyBjbGVhciBncm91cCBhZnRlciBzZXQgYW1vdW50IG9mIHRpbWUgc28gdGhlIHN0YXR1cyBpcyBub3QgcmVhZCB0d2ljZVxuICAgIGNsZWFyVGltZW91dChub3RpZmljYXRpb25DbGVhclRpbWVvdXQpO1xuICAgIG5vdGlmaWNhdGlvbkNsZWFyVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBjbGVhciQxKHJvb3QpO1xuICAgIH0sIDE1MDApO1xuICB9O1xuXG4gIHZhciBpc1VzaW5nRmlsZVBvbmQgPSBmdW5jdGlvbiBpc1VzaW5nRmlsZVBvbmQocm9vdCkge1xuICAgIHJldHVybiByb290LmVsZW1lbnQucGFyZW50Tm9kZS5jb250YWlucyhkb2N1bWVudC5hY3RpdmVFbGVtZW50KTtcbiAgfTtcblxuICB2YXIgaXRlbUFkZGVkID0gZnVuY3Rpb24gaXRlbUFkZGVkKF9yZWYyKSB7XG4gICAgdmFyIHJvb3QgPSBfcmVmMi5yb290LFxuICAgICAgYWN0aW9uID0gX3JlZjIuYWN0aW9uO1xuICAgIGlmICghaXNVc2luZ0ZpbGVQb25kKHJvb3QpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcm9vdC5lbGVtZW50LnRleHRDb250ZW50ID0gJyc7XG4gICAgdmFyIGl0ZW0gPSByb290LnF1ZXJ5KCdHRVRfSVRFTScsIGFjdGlvbi5pZCk7XG4gICAgZmlsZW5hbWVzLnB1c2goaXRlbS5maWxlbmFtZSk7XG5cbiAgICBjbGVhclRpbWVvdXQoYWRkRmlsZXNOb3RpZmljYXRpb25UaW1lb3V0KTtcbiAgICBhZGRGaWxlc05vdGlmaWNhdGlvblRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgbGlzdE1vZGlmaWVkKFxuICAgICAgICByb290LFxuICAgICAgICBmaWxlbmFtZXMuam9pbignLCAnKSxcbiAgICAgICAgcm9vdC5xdWVyeSgnR0VUX0xBQkVMX0ZJTEVfQURERUQnKVxuICAgICAgKTtcblxuICAgICAgZmlsZW5hbWVzLmxlbmd0aCA9IDA7XG4gICAgfSwgNzUwKTtcbiAgfTtcblxuICB2YXIgaXRlbVJlbW92ZWQgPSBmdW5jdGlvbiBpdGVtUmVtb3ZlZChfcmVmMykge1xuICAgIHZhciByb290ID0gX3JlZjMucm9vdCxcbiAgICAgIGFjdGlvbiA9IF9yZWYzLmFjdGlvbjtcbiAgICBpZiAoIWlzVXNpbmdGaWxlUG9uZChyb290KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBpdGVtID0gYWN0aW9uLml0ZW07XG4gICAgbGlzdE1vZGlmaWVkKHJvb3QsIGl0ZW0uZmlsZW5hbWUsIHJvb3QucXVlcnkoJ0dFVF9MQUJFTF9GSUxFX1JFTU9WRUQnKSk7XG4gIH07XG5cbiAgdmFyIGl0ZW1Qcm9jZXNzZWQgPSBmdW5jdGlvbiBpdGVtUHJvY2Vzc2VkKF9yZWY0KSB7XG4gICAgdmFyIHJvb3QgPSBfcmVmNC5yb290LFxuICAgICAgYWN0aW9uID0gX3JlZjQuYWN0aW9uO1xuICAgIC8vIHdpbGwgYWxzbyBub3RpZnkgdGhlIHVzZXIgd2hlbiBGaWxlUG9uZCBpcyBub3QgYmVpbmcgdXNlZCwgYXMgdGhlIHVzZXIgbWlnaHQgYmUgb2NjdXBpZWQgd2l0aCBvdGhlciBhY3Rpdml0aWVzIHdoaWxlIHVwbG9hZGluZyBhIGZpbGVcblxuICAgIHZhciBpdGVtID0gcm9vdC5xdWVyeSgnR0VUX0lURU0nLCBhY3Rpb24uaWQpO1xuICAgIHZhciBmaWxlbmFtZSA9IGl0ZW0uZmlsZW5hbWU7XG4gICAgdmFyIGxhYmVsID0gcm9vdC5xdWVyeSgnR0VUX0xBQkVMX0ZJTEVfUFJPQ0VTU0lOR19DT01QTEVURScpO1xuXG4gICAgYXNzaXN0KHJvb3QsIGZpbGVuYW1lICsgJyAnICsgbGFiZWwpO1xuICB9O1xuXG4gIHZhciBpdGVtUHJvY2Vzc2VkVW5kbyA9IGZ1bmN0aW9uIGl0ZW1Qcm9jZXNzZWRVbmRvKF9yZWY1KSB7XG4gICAgdmFyIHJvb3QgPSBfcmVmNS5yb290LFxuICAgICAgYWN0aW9uID0gX3JlZjUuYWN0aW9uO1xuICAgIHZhciBpdGVtID0gcm9vdC5xdWVyeSgnR0VUX0lURU0nLCBhY3Rpb24uaWQpO1xuICAgIHZhciBmaWxlbmFtZSA9IGl0ZW0uZmlsZW5hbWU7XG4gICAgdmFyIGxhYmVsID0gcm9vdC5xdWVyeSgnR0VUX0xBQkVMX0ZJTEVfUFJPQ0VTU0lOR19BQk9SVEVEJyk7XG5cbiAgICBhc3Npc3Qocm9vdCwgZmlsZW5hbWUgKyAnICcgKyBsYWJlbCk7XG4gIH07XG5cbiAgdmFyIGl0ZW1FcnJvciA9IGZ1bmN0aW9uIGl0ZW1FcnJvcihfcmVmNikge1xuICAgIHZhciByb290ID0gX3JlZjYucm9vdCxcbiAgICAgIGFjdGlvbiA9IF9yZWY2LmFjdGlvbjtcbiAgICB2YXIgaXRlbSA9IHJvb3QucXVlcnkoJ0dFVF9JVEVNJywgYWN0aW9uLmlkKTtcbiAgICB2YXIgZmlsZW5hbWUgPSBpdGVtLmZpbGVuYW1lO1xuXG4gICAgLy8gd2lsbCBhbHNvIG5vdGlmeSB0aGUgdXNlciB3aGVuIEZpbGVQb25kIGlzIG5vdCBiZWluZyB1c2VkLCBhcyB0aGUgdXNlciBtaWdodCBiZSBvY2N1cGllZCB3aXRoIG90aGVyIGFjdGl2aXRpZXMgd2hpbGUgdXBsb2FkaW5nIGEgZmlsZVxuXG4gICAgYXNzaXN0KHJvb3QsIGFjdGlvbi5zdGF0dXMubWFpbiArICcgJyArIGZpbGVuYW1lICsgJyAnICsgYWN0aW9uLnN0YXR1cy5zdWIpO1xuICB9O1xuXG4gIHZhciBhc3Npc3RhbnQgPSBjcmVhdGVWaWV3KHtcbiAgICBjcmVhdGU6IGNyZWF0ZSRkLFxuICAgIGlnbm9yZVJlY3Q6IHRydWUsXG4gICAgaWdub3JlUmVjdFVwZGF0ZTogdHJ1ZSxcbiAgICB3cml0ZTogY3JlYXRlUm91dGUoe1xuICAgICAgRElEX0xPQURfSVRFTTogaXRlbUFkZGVkLFxuICAgICAgRElEX1JFTU9WRV9JVEVNOiBpdGVtUmVtb3ZlZCxcbiAgICAgIERJRF9DT01QTEVURV9JVEVNX1BST0NFU1NJTkc6IGl0ZW1Qcm9jZXNzZWQsXG5cbiAgICAgIERJRF9BQk9SVF9JVEVNX1BST0NFU1NJTkc6IGl0ZW1Qcm9jZXNzZWRVbmRvLFxuICAgICAgRElEX1JFVkVSVF9JVEVNX1BST0NFU1NJTkc6IGl0ZW1Qcm9jZXNzZWRVbmRvLFxuXG4gICAgICBESURfVEhST1dfSVRFTV9SRU1PVkVfRVJST1I6IGl0ZW1FcnJvcixcbiAgICAgIERJRF9USFJPV19JVEVNX0xPQURfRVJST1I6IGl0ZW1FcnJvcixcbiAgICAgIERJRF9USFJPV19JVEVNX0lOVkFMSUQ6IGl0ZW1FcnJvcixcbiAgICAgIERJRF9USFJPV19JVEVNX1BST0NFU1NJTkdfRVJST1I6IGl0ZW1FcnJvclxuICAgIH0pLFxuXG4gICAgdGFnOiAnc3BhbicsXG4gICAgbmFtZTogJ2Fzc2lzdGFudCdcbiAgfSk7XG5cbiAgdmFyIHRvQ2FtZWxzID0gZnVuY3Rpb24gdG9DYW1lbHMoc3RyaW5nKSB7XG4gICAgdmFyIHNlcGFyYXRvciA9XG4gICAgICBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICctJztcbiAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UobmV3IFJlZ0V4cChzZXBhcmF0b3IgKyAnLicsICdnJyksIGZ1bmN0aW9uKHN1Yikge1xuICAgICAgcmV0dXJuIHN1Yi5jaGFyQXQoMSkudG9VcHBlckNhc2UoKTtcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgZGVib3VuY2UgPSBmdW5jdGlvbiBkZWJvdW5jZShmdW5jKSB7XG4gICAgdmFyIGludGVydmFsID1cbiAgICAgIGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMTY7XG4gICAgdmFyIGltbWlkaWF0ZU9ubHkgPVxuICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB0cnVlO1xuICAgIHZhciBsYXN0ID0gRGF0ZS5ub3coKTtcbiAgICB2YXIgdGltZW91dCA9IG51bGw7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBmb3IgKFxuICAgICAgICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwO1xuICAgICAgICBfa2V5IDwgX2xlbjtcbiAgICAgICAgX2tleSsrXG4gICAgICApIHtcbiAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcblxuICAgICAgdmFyIGRpc3QgPSBEYXRlLm5vdygpIC0gbGFzdDtcblxuICAgICAgdmFyIGZuID0gZnVuY3Rpb24gZm4oKSB7XG4gICAgICAgIGxhc3QgPSBEYXRlLm5vdygpO1xuICAgICAgICBmdW5jLmFwcGx5KHZvaWQgMCwgYXJncyk7XG4gICAgICB9O1xuXG4gICAgICBpZiAoZGlzdCA8IGludGVydmFsKSB7XG4gICAgICAgIC8vIHdlIG5lZWQgdG8gZGVsYXkgYnkgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBpbnRlcnZhbCBhbmQgZGlzdFxuICAgICAgICAvLyBmb3IgZXhhbXBsZTogaWYgZGlzdGFuY2UgaXMgMTAgbXMgYW5kIGludGVydmFsIGlzIDE2IG1zLFxuICAgICAgICAvLyB3ZSBuZWVkIHRvIHdhaXQgYW4gYWRkaXRpb25hbCA2bXMgYmVmb3JlIGNhbGxpbmcgdGhlIGZ1bmN0aW9uKVxuICAgICAgICBpZiAoIWltbWlkaWF0ZU9ubHkpIHtcbiAgICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChmbiwgaW50ZXJ2YWwgLSBkaXN0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZ28hXG4gICAgICAgIGZuKCk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICB2YXIgTUFYX0ZJTEVTX0xJTUlUID0gMTAwMDAwMDtcblxuICB2YXIgcHJldmVudCA9IGZ1bmN0aW9uIHByZXZlbnQoZSkge1xuICAgIHJldHVybiBlLnByZXZlbnREZWZhdWx0KCk7XG4gIH07XG5cbiAgdmFyIGNyZWF0ZSRlID0gZnVuY3Rpb24gY3JlYXRlKF9yZWYpIHtcbiAgICB2YXIgcm9vdCA9IF9yZWYucm9vdCxcbiAgICAgIHByb3BzID0gX3JlZi5wcm9wcztcblxuICAgIC8vIEFkZCBpZFxuICAgIHZhciBpZCA9IHJvb3QucXVlcnkoJ0dFVF9JRCcpO1xuICAgIGlmIChpZCkge1xuICAgICAgcm9vdC5lbGVtZW50LmlkID0gaWQ7XG4gICAgfVxuXG4gICAgLy8gQWRkIGNsYXNzTmFtZVxuICAgIHZhciBjbGFzc05hbWUgPSByb290LnF1ZXJ5KCdHRVRfQ0xBU1NfTkFNRScpO1xuICAgIGlmIChjbGFzc05hbWUpIHtcbiAgICAgIGNsYXNzTmFtZVxuICAgICAgICAuc3BsaXQoJyAnKVxuICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gbmFtZS5sZW5ndGg7XG4gICAgICAgIH0pXG4gICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICByb290LmVsZW1lbnQuY2xhc3NMaXN0LmFkZChuYW1lKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gRmllbGQgbGFiZWxcbiAgICByb290LnJlZi5sYWJlbCA9IHJvb3QuYXBwZW5kQ2hpbGRWaWV3KFxuICAgICAgcm9vdC5jcmVhdGVDaGlsZFZpZXcoXG4gICAgICAgIGRyb3BMYWJlbCxcbiAgICAgICAgT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB0cmFuc2xhdGVZOiBudWxsLFxuICAgICAgICAgIGNhcHRpb246IHJvb3QucXVlcnkoJ0dFVF9MQUJFTF9JRExFJylcbiAgICAgICAgfSlcbiAgICAgIClcbiAgICApO1xuXG4gICAgLy8gTGlzdCBvZiBpdGVtc1xuICAgIHJvb3QucmVmLmxpc3QgPSByb290LmFwcGVuZENoaWxkVmlldyhcbiAgICAgIHJvb3QuY3JlYXRlQ2hpbGRWaWV3KGxpc3RTY3JvbGxlciwgeyB0cmFuc2xhdGVZOiBudWxsIH0pXG4gICAgKTtcblxuICAgIC8vIEJhY2tncm91bmQgcGFuZWxcbiAgICByb290LnJlZi5wYW5lbCA9IHJvb3QuYXBwZW5kQ2hpbGRWaWV3KFxuICAgICAgcm9vdC5jcmVhdGVDaGlsZFZpZXcocGFuZWwsIHsgbmFtZTogJ3BhbmVsLXJvb3QnIH0pXG4gICAgKTtcblxuICAgIC8vIEFzc2lzdGFudCBub3RpZmllcyBhc3Npc3RpdmUgdGVjaCB3aGVuIGNvbnRlbnQgY2hhbmdlc1xuICAgIHJvb3QucmVmLmFzc2lzdGFudCA9IHJvb3QuYXBwZW5kQ2hpbGRWaWV3KFxuICAgICAgcm9vdC5jcmVhdGVDaGlsZFZpZXcoYXNzaXN0YW50LCBPYmplY3QuYXNzaWduKHt9LCBwcm9wcykpXG4gICAgKTtcblxuICAgIC8vIERhdGFcbiAgICByb290LnJlZi5kYXRhID0gcm9vdC5hcHBlbmRDaGlsZFZpZXcoXG4gICAgICByb290LmNyZWF0ZUNoaWxkVmlldyhkYXRhLCBPYmplY3QuYXNzaWduKHt9LCBwcm9wcykpXG4gICAgKTtcblxuICAgIC8vIE1lYXN1cmUgKHRlc3RzIGlmIGZpeGVkIGhlaWdodCB3YXMgc2V0KVxuICAgIC8vIERPQ1RZUEUgbmVlZHMgdG8gYmUgc2V0IGZvciB0aGlzIHRvIHdvcmtcbiAgICByb290LnJlZi5tZWFzdXJlID0gY3JlYXRlRWxlbWVudCQxKCdkaXYnKTtcbiAgICByb290LnJlZi5tZWFzdXJlLnN0eWxlLmhlaWdodCA9ICcxMDAlJztcbiAgICByb290LmVsZW1lbnQuYXBwZW5kQ2hpbGQocm9vdC5yZWYubWVhc3VyZSk7XG5cbiAgICAvLyBpbmZvcm1hdGlvbiBvbiB0aGUgcm9vdCBoZWlnaHQgb3IgZml4ZWQgaGVpZ2h0IHN0YXR1c1xuICAgIHJvb3QucmVmLmJvdW5kcyA9IG51bGw7XG5cbiAgICAvLyBhcHBseSBpbml0aWFsIHN0eWxlIHByb3BlcnRpZXNcbiAgICByb290XG4gICAgICAucXVlcnkoJ0dFVF9TVFlMRVMnKVxuICAgICAgLmZpbHRlcihmdW5jdGlvbihzdHlsZSkge1xuICAgICAgICByZXR1cm4gIWlzRW1wdHkoc3R5bGUudmFsdWUpO1xuICAgICAgfSlcbiAgICAgIC5tYXAoZnVuY3Rpb24oX3JlZjIpIHtcbiAgICAgICAgdmFyIG5hbWUgPSBfcmVmMi5uYW1lLFxuICAgICAgICAgIHZhbHVlID0gX3JlZjIudmFsdWU7XG4gICAgICAgIHJvb3QuZWxlbWVudC5kYXRhc2V0W25hbWVdID0gdmFsdWU7XG4gICAgICB9KTtcblxuICAgIC8vIGRldGVybWluZSBpZiB3aWR0aCBjaGFuZ2VkXG4gICAgcm9vdC5yZWYud2lkdGhQcmV2aW91cyA9IG51bGw7XG4gICAgcm9vdC5yZWYud2lkdGhVcGRhdGVkID0gZGVib3VuY2UoZnVuY3Rpb24oKSB7XG4gICAgICByb290LnJlZi51cGRhdGVIaXN0b3J5ID0gW107XG4gICAgICByb290LmRpc3BhdGNoKCdESURfUkVTSVpFX1JPT1QnKTtcbiAgICB9LCAyNTApO1xuXG4gICAgLy8gaGlzdG9yeSBvZiB1cGRhdGVzXG4gICAgcm9vdC5yZWYucHJldmlvdXNBc3BlY3RSYXRpbyA9IG51bGw7XG4gICAgcm9vdC5yZWYudXBkYXRlSGlzdG9yeSA9IFtdO1xuXG4gICAgLy8gcHJldmVudCBzY3JvbGxpbmcgYW5kIHpvb21pbmcgb24gaU9TIChvbmx5IGlmIHN1cHBvcnRzIHBvaW50ZXIgZXZlbnRzLCBmb3IgdGhlbiB3ZSBjYW4gZW5hYmxlIHJlb3JkZXIpXG4gICAgdmFyIGNhbkhvdmVyID0gd2luZG93Lm1hdGNoTWVkaWEoJyhwb2ludGVyOiBmaW5lKSBhbmQgKGhvdmVyOiBob3ZlciknKVxuICAgICAgLm1hdGNoZXM7XG4gICAgdmFyIGhhc1BvaW50ZXJFdmVudHMgPSAnUG9pbnRlckV2ZW50JyBpbiB3aW5kb3c7XG4gICAgaWYgKHJvb3QucXVlcnkoJ0dFVF9BTExPV19SRU9SREVSJykgJiYgaGFzUG9pbnRlckV2ZW50cyAmJiAhY2FuSG92ZXIpIHtcbiAgICAgIHJvb3QuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBwcmV2ZW50LCB7IHBhc3NpdmU6IGZhbHNlIH0pO1xuICAgICAgcm9vdC5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2dlc3R1cmVzdGFydCcsIHByZXZlbnQpO1xuICAgIH1cblxuICAgIC8vIGFkZCBjcmVkaXRzXG4gICAgdmFyIGNyZWRpdHMgPSByb290LnF1ZXJ5KCdHRVRfQ1JFRElUUycpO1xuICAgIHZhciBoYXNDcmVkaXRzID0gY3JlZGl0cy5sZW5ndGggPT09IDI7XG4gICAgaWYgKGhhc0NyZWRpdHMpIHtcbiAgICAgIHZhciBmcmFnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgICAgZnJhZy5jbGFzc05hbWUgPSAnZmlsZXBvbmQtLWNyZWRpdHMnO1xuICAgICAgZnJhZy5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcbiAgICAgIGZyYWcuaHJlZiA9IGNyZWRpdHNbMF07XG4gICAgICBmcmFnLnRhYmluZGV4ID0gLTE7XG4gICAgICBmcmFnLnRhcmdldCA9ICdfYmxhbmsnO1xuICAgICAgZnJhZy5yZWwgPSAnbm9vcGVuZXIgbm9yZWZlcnJlcic7XG4gICAgICBmcmFnLnRleHRDb250ZW50ID0gY3JlZGl0c1sxXTtcbiAgICAgIHJvb3QuZWxlbWVudC5hcHBlbmRDaGlsZChmcmFnKTtcbiAgICAgIHJvb3QucmVmLmNyZWRpdHMgPSBmcmFnO1xuICAgIH1cbiAgfTtcblxuICB2YXIgd3JpdGUkOSA9IGZ1bmN0aW9uIHdyaXRlKF9yZWYzKSB7XG4gICAgdmFyIHJvb3QgPSBfcmVmMy5yb290LFxuICAgICAgcHJvcHMgPSBfcmVmMy5wcm9wcyxcbiAgICAgIGFjdGlvbnMgPSBfcmVmMy5hY3Rpb25zO1xuXG4gICAgLy8gcm91dGUgYWN0aW9uc1xuICAgIHJvdXRlJDUoeyByb290OiByb290LCBwcm9wczogcHJvcHMsIGFjdGlvbnM6IGFjdGlvbnMgfSk7XG5cbiAgICAvLyBhcHBseSBzdHlsZSBwcm9wZXJ0aWVzXG4gICAgYWN0aW9uc1xuICAgICAgLmZpbHRlcihmdW5jdGlvbihhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIC9eRElEX1NFVF9TVFlMRV8vLnRlc3QoYWN0aW9uLnR5cGUpO1xuICAgICAgfSlcbiAgICAgIC5maWx0ZXIoZnVuY3Rpb24oYWN0aW9uKSB7XG4gICAgICAgIHJldHVybiAhaXNFbXB0eShhY3Rpb24uZGF0YS52YWx1ZSk7XG4gICAgICB9KVxuICAgICAgLm1hcChmdW5jdGlvbihfcmVmNCkge1xuICAgICAgICB2YXIgdHlwZSA9IF9yZWY0LnR5cGUsXG4gICAgICAgICAgZGF0YSA9IF9yZWY0LmRhdGE7XG4gICAgICAgIHZhciBuYW1lID0gdG9DYW1lbHModHlwZS5zdWJzdHIoOCkudG9Mb3dlckNhc2UoKSwgJ18nKTtcbiAgICAgICAgcm9vdC5lbGVtZW50LmRhdGFzZXRbbmFtZV0gPSBkYXRhLnZhbHVlO1xuICAgICAgICByb290LmludmFsaWRhdGVMYXlvdXQoKTtcbiAgICAgIH0pO1xuXG4gICAgaWYgKHJvb3QucmVjdC5lbGVtZW50LmhpZGRlbikgcmV0dXJuO1xuXG4gICAgaWYgKHJvb3QucmVjdC5lbGVtZW50LndpZHRoICE9PSByb290LnJlZi53aWR0aFByZXZpb3VzKSB7XG4gICAgICByb290LnJlZi53aWR0aFByZXZpb3VzID0gcm9vdC5yZWN0LmVsZW1lbnQud2lkdGg7XG4gICAgICByb290LnJlZi53aWR0aFVwZGF0ZWQoKTtcbiAgICB9XG5cbiAgICAvLyBnZXQgYm94IGJvdW5kcywgd2UgZG8gdGhpcyBvbmx5IG9uY2VcbiAgICB2YXIgYm91bmRzID0gcm9vdC5yZWYuYm91bmRzO1xuICAgIGlmICghYm91bmRzKSB7XG4gICAgICBib3VuZHMgPSByb290LnJlZi5ib3VuZHMgPSBjYWxjdWxhdGVSb290Qm91bmRpbmdCb3hIZWlnaHQocm9vdCk7XG5cbiAgICAgIC8vIGRlc3Ryb3kgbWVhc3VyZSBlbGVtZW50XG4gICAgICByb290LmVsZW1lbnQucmVtb3ZlQ2hpbGQocm9vdC5yZWYubWVhc3VyZSk7XG4gICAgICByb290LnJlZi5tZWFzdXJlID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBnZXQgcXVpY2sgcmVmZXJlbmNlcyB0byB2YXJpb3VzIGhpZ2ggbGV2ZWwgcGFydHMgb2YgdGhlIHVwbG9hZCB0b29sXG4gICAgdmFyIF9yb290JHJlZiA9IHJvb3QucmVmLFxuICAgICAgaG9wcGVyID0gX3Jvb3QkcmVmLmhvcHBlcixcbiAgICAgIGxhYmVsID0gX3Jvb3QkcmVmLmxhYmVsLFxuICAgICAgbGlzdCA9IF9yb290JHJlZi5saXN0LFxuICAgICAgcGFuZWwgPSBfcm9vdCRyZWYucGFuZWw7XG5cbiAgICAvLyBzZXRzIGNvcnJlY3Qgc3RhdGUgdG8gaG9wcGVyIHNjb3BlXG4gICAgaWYgKGhvcHBlcikge1xuICAgICAgaG9wcGVyLnVwZGF0ZUhvcHBlclN0YXRlKCk7XG4gICAgfVxuXG4gICAgLy8gYm9vbCB0byBpbmRpY2F0ZSBpZiB3ZSdyZSBmdWxsIG9yIG5vdFxuICAgIHZhciBhc3BlY3RSYXRpbyA9IHJvb3QucXVlcnkoJ0dFVF9QQU5FTF9BU1BFQ1RfUkFUSU8nKTtcbiAgICB2YXIgaXNNdWx0aUl0ZW0gPSByb290LnF1ZXJ5KCdHRVRfQUxMT1dfTVVMVElQTEUnKTtcbiAgICB2YXIgdG90YWxJdGVtcyA9IHJvb3QucXVlcnkoJ0dFVF9UT1RBTF9JVEVNUycpO1xuICAgIHZhciBtYXhJdGVtcyA9IGlzTXVsdGlJdGVtXG4gICAgICA/IHJvb3QucXVlcnkoJ0dFVF9NQVhfRklMRVMnKSB8fCBNQVhfRklMRVNfTElNSVRcbiAgICAgIDogMTtcbiAgICB2YXIgYXRNYXhDYXBhY2l0eSA9IHRvdGFsSXRlbXMgPT09IG1heEl0ZW1zO1xuXG4gICAgLy8gYWN0aW9uIHVzZWQgdG8gYWRkIGl0ZW1cbiAgICB2YXIgYWRkQWN0aW9uID0gYWN0aW9ucy5maW5kKGZ1bmN0aW9uKGFjdGlvbikge1xuICAgICAgcmV0dXJuIGFjdGlvbi50eXBlID09PSAnRElEX0FERF9JVEVNJztcbiAgICB9KTtcblxuICAgIC8vIGlmIHJlYWNoZWQgbWF4IGNhcGFjaXR5IGFuZCB3ZSd2ZSBqdXN0IHJlYWNoZWQgaXRcbiAgICBpZiAoYXRNYXhDYXBhY2l0eSAmJiBhZGRBY3Rpb24pIHtcbiAgICAgIC8vIGdldCBpbnRlcmFjdGlvbiB0eXBlXG4gICAgICB2YXIgaW50ZXJhY3Rpb25NZXRob2QgPSBhZGRBY3Rpb24uZGF0YS5pbnRlcmFjdGlvbk1ldGhvZDtcblxuICAgICAgLy8gaGlkZSBsYWJlbFxuICAgICAgbGFiZWwub3BhY2l0eSA9IDA7XG5cbiAgICAgIGlmIChpc011bHRpSXRlbSkge1xuICAgICAgICBsYWJlbC50cmFuc2xhdGVZID0gLTQwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGludGVyYWN0aW9uTWV0aG9kID09PSBJbnRlcmFjdGlvbk1ldGhvZC5BUEkpIHtcbiAgICAgICAgICBsYWJlbC50cmFuc2xhdGVYID0gNDA7XG4gICAgICAgIH0gZWxzZSBpZiAoaW50ZXJhY3Rpb25NZXRob2QgPT09IEludGVyYWN0aW9uTWV0aG9kLkJST1dTRSkge1xuICAgICAgICAgIGxhYmVsLnRyYW5zbGF0ZVkgPSA0MDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsYWJlbC50cmFuc2xhdGVZID0gMzA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFhdE1heENhcGFjaXR5KSB7XG4gICAgICBsYWJlbC5vcGFjaXR5ID0gMTtcbiAgICAgIGxhYmVsLnRyYW5zbGF0ZVggPSAwO1xuICAgICAgbGFiZWwudHJhbnNsYXRlWSA9IDA7XG4gICAgfVxuXG4gICAgdmFyIGxpc3RJdGVtTWFyZ2luID0gY2FsY3VsYXRlTGlzdEl0ZW1NYXJnaW4ocm9vdCk7XG5cbiAgICB2YXIgbGlzdEhlaWdodCA9IGNhbGN1bGF0ZUxpc3RIZWlnaHQocm9vdCk7XG5cbiAgICB2YXIgbGFiZWxIZWlnaHQgPSBsYWJlbC5yZWN0LmVsZW1lbnQuaGVpZ2h0O1xuICAgIHZhciBjdXJyZW50TGFiZWxIZWlnaHQgPSAhaXNNdWx0aUl0ZW0gfHwgYXRNYXhDYXBhY2l0eSA/IDAgOiBsYWJlbEhlaWdodDtcblxuICAgIHZhciBsaXN0TWFyZ2luVG9wID0gYXRNYXhDYXBhY2l0eSA/IGxpc3QucmVjdC5lbGVtZW50Lm1hcmdpblRvcCA6IDA7XG4gICAgdmFyIGxpc3RNYXJnaW5Cb3R0b20gPVxuICAgICAgdG90YWxJdGVtcyA9PT0gMCA/IDAgOiBsaXN0LnJlY3QuZWxlbWVudC5tYXJnaW5Cb3R0b207XG5cbiAgICB2YXIgdmlzdWFsSGVpZ2h0ID1cbiAgICAgIGN1cnJlbnRMYWJlbEhlaWdodCArIGxpc3RNYXJnaW5Ub3AgKyBsaXN0SGVpZ2h0LnZpc3VhbCArIGxpc3RNYXJnaW5Cb3R0b207XG4gICAgdmFyIGJvdW5kc0hlaWdodCA9XG4gICAgICBjdXJyZW50TGFiZWxIZWlnaHQgKyBsaXN0TWFyZ2luVG9wICsgbGlzdEhlaWdodC5ib3VuZHMgKyBsaXN0TWFyZ2luQm90dG9tO1xuXG4gICAgLy8gbGluayBsaXN0IHRvIGxhYmVsIGJvdHRvbSBwb3NpdGlvblxuICAgIGxpc3QudHJhbnNsYXRlWSA9XG4gICAgICBNYXRoLm1heCgwLCBjdXJyZW50TGFiZWxIZWlnaHQgLSBsaXN0LnJlY3QuZWxlbWVudC5tYXJnaW5Ub3ApIC1cbiAgICAgIGxpc3RJdGVtTWFyZ2luLnRvcDtcblxuICAgIGlmIChhc3BlY3RSYXRpbykge1xuICAgICAgLy8gZml4ZWQgYXNwZWN0IHJhdGlvXG5cbiAgICAgIC8vIGNhbGN1bGF0ZSBoZWlnaHQgYmFzZWQgb24gd2lkdGhcbiAgICAgIHZhciB3aWR0aCA9IHJvb3QucmVjdC5lbGVtZW50LndpZHRoO1xuICAgICAgdmFyIGhlaWdodCA9IHdpZHRoICogYXNwZWN0UmF0aW87XG5cbiAgICAgIC8vIGNsZWFyIGhpc3RvcnkgaWYgYXNwZWN0IHJhdGlvIGhhcyBjaGFuZ2VkXG4gICAgICBpZiAoYXNwZWN0UmF0aW8gIT09IHJvb3QucmVmLnByZXZpb3VzQXNwZWN0UmF0aW8pIHtcbiAgICAgICAgcm9vdC5yZWYucHJldmlvdXNBc3BlY3RSYXRpbyA9IGFzcGVjdFJhdGlvO1xuICAgICAgICByb290LnJlZi51cGRhdGVIaXN0b3J5ID0gW107XG4gICAgICB9XG5cbiAgICAgIC8vIHJlbWVtYmVyIHRoaXMgd2lkdGhcbiAgICAgIHZhciBoaXN0b3J5ID0gcm9vdC5yZWYudXBkYXRlSGlzdG9yeTtcbiAgICAgIGhpc3RvcnkucHVzaCh3aWR0aCk7XG5cbiAgICAgIHZhciBNQVhfQk9VTkNFUyA9IDI7XG4gICAgICBpZiAoaGlzdG9yeS5sZW5ndGggPiBNQVhfQk9VTkNFUyAqIDIpIHtcbiAgICAgICAgdmFyIGwgPSBoaXN0b3J5Lmxlbmd0aDtcbiAgICAgICAgdmFyIGJvdHRvbSA9IGwgLSAxMDtcbiAgICAgICAgdmFyIGJvdW5jZXMgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gbDsgaSA+PSBib3R0b207IGktLSkge1xuICAgICAgICAgIGlmIChoaXN0b3J5W2ldID09PSBoaXN0b3J5W2kgLSAyXSkge1xuICAgICAgICAgICAgYm91bmNlcysrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChib3VuY2VzID49IE1BWF9CT1VOQ0VTKSB7XG4gICAgICAgICAgICAvLyBkb250IGFkanVzdCBoZWlnaHRcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gZml4IGhlaWdodCBvZiBwYW5lbCBzbyBpdCBhZGhlcmVzIHRvIGFzcGVjdCByYXRpb1xuICAgICAgcGFuZWwuc2NhbGFibGUgPSBmYWxzZTtcbiAgICAgIHBhbmVsLmhlaWdodCA9IGhlaWdodDtcblxuICAgICAgLy8gYXZhaWxhYmxlIGhlaWdodCBmb3IgbGlzdFxuICAgICAgdmFyIGxpc3RBdmFpbGFibGVIZWlnaHQgPVxuICAgICAgICAvLyB0aGUgaGVpZ2h0IG9mIHRoZSBwYW5lbCBtaW51cyB0aGUgbGFiZWwgaGVpZ2h0XG4gICAgICAgIGhlaWdodCAtXG4gICAgICAgIGN1cnJlbnRMYWJlbEhlaWdodCAtXG4gICAgICAgIC8vIHRoZSByb29tIHdlIGxlYXZlIG9wZW4gYmV0d2VlbiB0aGUgZW5kIG9mIHRoZSBsaXN0IGFuZCB0aGUgcGFuZWwgYm90dG9tXG4gICAgICAgIChsaXN0TWFyZ2luQm90dG9tIC0gbGlzdEl0ZW1NYXJnaW4uYm90dG9tKSAtXG4gICAgICAgIC8vIGlmIHdlJ3JlIGZ1bGwgd2UgbmVlZCB0byBsZWF2ZSBzb21lIHJvb20gYmV0d2VlbiB0aGUgdG9wIG9mIHRoZSBwYW5lbCBhbmQgdGhlIGxpc3RcbiAgICAgICAgKGF0TWF4Q2FwYWNpdHkgPyBsaXN0TWFyZ2luVG9wIDogMCk7XG5cbiAgICAgIGlmIChsaXN0SGVpZ2h0LnZpc3VhbCA+IGxpc3RBdmFpbGFibGVIZWlnaHQpIHtcbiAgICAgICAgbGlzdC5vdmVyZmxvdyA9IGxpc3RBdmFpbGFibGVIZWlnaHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaXN0Lm92ZXJmbG93ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLy8gc2V0IGNvbnRhaW5lciBib3VuZHMgKHNvIHB1c2hlcyBzaWJsaW5ncyBkb3dud2FyZHMpXG4gICAgICByb290LmhlaWdodCA9IGhlaWdodDtcbiAgICB9IGVsc2UgaWYgKGJvdW5kcy5maXhlZEhlaWdodCkge1xuICAgICAgLy8gZml4ZWQgaGVpZ2h0XG5cbiAgICAgIC8vIGZpeCBoZWlnaHQgb2YgcGFuZWxcbiAgICAgIHBhbmVsLnNjYWxhYmxlID0gZmFsc2U7XG5cbiAgICAgIC8vIGF2YWlsYWJsZSBoZWlnaHQgZm9yIGxpc3RcbiAgICAgIHZhciBfbGlzdEF2YWlsYWJsZUhlaWdodCA9XG4gICAgICAgIC8vIHRoZSBoZWlnaHQgb2YgdGhlIHBhbmVsIG1pbnVzIHRoZSBsYWJlbCBoZWlnaHRcbiAgICAgICAgYm91bmRzLmZpeGVkSGVpZ2h0IC1cbiAgICAgICAgY3VycmVudExhYmVsSGVpZ2h0IC1cbiAgICAgICAgLy8gdGhlIHJvb20gd2UgbGVhdmUgb3BlbiBiZXR3ZWVuIHRoZSBlbmQgb2YgdGhlIGxpc3QgYW5kIHRoZSBwYW5lbCBib3R0b21cbiAgICAgICAgKGxpc3RNYXJnaW5Cb3R0b20gLSBsaXN0SXRlbU1hcmdpbi5ib3R0b20pIC1cbiAgICAgICAgLy8gaWYgd2UncmUgZnVsbCB3ZSBuZWVkIHRvIGxlYXZlIHNvbWUgcm9vbSBiZXR3ZWVuIHRoZSB0b3Agb2YgdGhlIHBhbmVsIGFuZCB0aGUgbGlzdFxuICAgICAgICAoYXRNYXhDYXBhY2l0eSA/IGxpc3RNYXJnaW5Ub3AgOiAwKTtcblxuICAgICAgLy8gc2V0IGxpc3QgaGVpZ2h0XG4gICAgICBpZiAobGlzdEhlaWdodC52aXN1YWwgPiBfbGlzdEF2YWlsYWJsZUhlaWdodCkge1xuICAgICAgICBsaXN0Lm92ZXJmbG93ID0gX2xpc3RBdmFpbGFibGVIZWlnaHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaXN0Lm92ZXJmbG93ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLy8gbm8gbmVlZCB0byBzZXQgY29udGFpbmVyIGJvdW5kcyBhcyB0aGVzZSBhcmUgaGFuZGxlcyBieSBDU1MgZml4ZWQgaGVpZ2h0XG4gICAgfSBlbHNlIGlmIChib3VuZHMuY2FwcGVkSGVpZ2h0KSB7XG4gICAgICAvLyBtYXgtaGVpZ2h0XG5cbiAgICAgIC8vIG5vdCBhIGZpeGVkIGhlaWdodCBwYW5lbFxuICAgICAgdmFyIGlzQ2FwcGVkSGVpZ2h0ID0gdmlzdWFsSGVpZ2h0ID49IGJvdW5kcy5jYXBwZWRIZWlnaHQ7XG4gICAgICB2YXIgcGFuZWxIZWlnaHQgPSBNYXRoLm1pbihib3VuZHMuY2FwcGVkSGVpZ2h0LCB2aXN1YWxIZWlnaHQpO1xuICAgICAgcGFuZWwuc2NhbGFibGUgPSB0cnVlO1xuICAgICAgcGFuZWwuaGVpZ2h0ID0gaXNDYXBwZWRIZWlnaHRcbiAgICAgICAgPyBwYW5lbEhlaWdodFxuICAgICAgICA6IHBhbmVsSGVpZ2h0IC0gbGlzdEl0ZW1NYXJnaW4udG9wIC0gbGlzdEl0ZW1NYXJnaW4uYm90dG9tO1xuXG4gICAgICAvLyBhdmFpbGFibGUgaGVpZ2h0IGZvciBsaXN0XG4gICAgICB2YXIgX2xpc3RBdmFpbGFibGVIZWlnaHQyID1cbiAgICAgICAgLy8gdGhlIGhlaWdodCBvZiB0aGUgcGFuZWwgbWludXMgdGhlIGxhYmVsIGhlaWdodFxuICAgICAgICBwYW5lbEhlaWdodCAtXG4gICAgICAgIGN1cnJlbnRMYWJlbEhlaWdodCAtXG4gICAgICAgIC8vIHRoZSByb29tIHdlIGxlYXZlIG9wZW4gYmV0d2VlbiB0aGUgZW5kIG9mIHRoZSBsaXN0IGFuZCB0aGUgcGFuZWwgYm90dG9tXG4gICAgICAgIChsaXN0TWFyZ2luQm90dG9tIC0gbGlzdEl0ZW1NYXJnaW4uYm90dG9tKSAtXG4gICAgICAgIC8vIGlmIHdlJ3JlIGZ1bGwgd2UgbmVlZCB0byBsZWF2ZSBzb21lIHJvb20gYmV0d2VlbiB0aGUgdG9wIG9mIHRoZSBwYW5lbCBhbmQgdGhlIGxpc3RcbiAgICAgICAgKGF0TWF4Q2FwYWNpdHkgPyBsaXN0TWFyZ2luVG9wIDogMCk7XG5cbiAgICAgIC8vIHNldCBsaXN0IGhlaWdodCAoaWYgaXMgb3ZlcmZsb3dpbmcpXG4gICAgICBpZiAoXG4gICAgICAgIHZpc3VhbEhlaWdodCA+IGJvdW5kcy5jYXBwZWRIZWlnaHQgJiZcbiAgICAgICAgbGlzdEhlaWdodC52aXN1YWwgPiBfbGlzdEF2YWlsYWJsZUhlaWdodDJcbiAgICAgICkge1xuICAgICAgICBsaXN0Lm92ZXJmbG93ID0gX2xpc3RBdmFpbGFibGVIZWlnaHQyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGlzdC5vdmVyZmxvdyA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIC8vIHNldCBjb250YWluZXIgYm91bmRzIChzbyBwdXNoZXMgc2libGluZ3MgZG93bndhcmRzKVxuICAgICAgcm9vdC5oZWlnaHQgPSBNYXRoLm1pbihcbiAgICAgICAgYm91bmRzLmNhcHBlZEhlaWdodCxcbiAgICAgICAgYm91bmRzSGVpZ2h0IC0gbGlzdEl0ZW1NYXJnaW4udG9wIC0gbGlzdEl0ZW1NYXJnaW4uYm90dG9tXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBmbGV4aWJsZSBoZWlnaHRcblxuICAgICAgLy8gbm90IGEgZml4ZWQgaGVpZ2h0IHBhbmVsXG4gICAgICB2YXIgaXRlbU1hcmdpbiA9XG4gICAgICAgIHRvdGFsSXRlbXMgPiAwID8gbGlzdEl0ZW1NYXJnaW4udG9wICsgbGlzdEl0ZW1NYXJnaW4uYm90dG9tIDogMDtcbiAgICAgIHBhbmVsLnNjYWxhYmxlID0gdHJ1ZTtcbiAgICAgIHBhbmVsLmhlaWdodCA9IE1hdGgubWF4KGxhYmVsSGVpZ2h0LCB2aXN1YWxIZWlnaHQgLSBpdGVtTWFyZ2luKTtcblxuICAgICAgLy8gc2V0IGNvbnRhaW5lciBib3VuZHMgKHNvIHB1c2hlcyBzaWJsaW5ncyBkb3dud2FyZHMpXG4gICAgICByb290LmhlaWdodCA9IE1hdGgubWF4KGxhYmVsSGVpZ2h0LCBib3VuZHNIZWlnaHQgLSBpdGVtTWFyZ2luKTtcbiAgICB9XG5cbiAgICAvLyBtb3ZlIGNyZWRpdHMgdG8gYm90dG9tXG4gICAgaWYgKHJvb3QucmVmLmNyZWRpdHMgJiYgcGFuZWwuaGVpZ2h0Q3VycmVudClcbiAgICAgIHJvb3QucmVmLmNyZWRpdHMuc3R5bGUudHJhbnNmb3JtID1cbiAgICAgICAgJ3RyYW5zbGF0ZVkoJyArIHBhbmVsLmhlaWdodEN1cnJlbnQgKyAncHgpJztcbiAgfTtcblxuICB2YXIgY2FsY3VsYXRlTGlzdEl0ZW1NYXJnaW4gPSBmdW5jdGlvbiBjYWxjdWxhdGVMaXN0SXRlbU1hcmdpbihyb290KSB7XG4gICAgdmFyIGl0ZW0gPSByb290LnJlZi5saXN0LmNoaWxkVmlld3NbMF0uY2hpbGRWaWV3c1swXTtcbiAgICByZXR1cm4gaXRlbVxuICAgICAgPyB7XG4gICAgICAgICAgdG9wOiBpdGVtLnJlY3QuZWxlbWVudC5tYXJnaW5Ub3AsXG4gICAgICAgICAgYm90dG9tOiBpdGVtLnJlY3QuZWxlbWVudC5tYXJnaW5Cb3R0b21cbiAgICAgICAgfVxuICAgICAgOiB7XG4gICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgIGJvdHRvbTogMFxuICAgICAgICB9O1xuICB9O1xuXG4gIHZhciBjYWxjdWxhdGVMaXN0SGVpZ2h0ID0gZnVuY3Rpb24gY2FsY3VsYXRlTGlzdEhlaWdodChyb290KSB7XG4gICAgdmFyIHZpc3VhbCA9IDA7XG4gICAgdmFyIGJvdW5kcyA9IDA7XG5cbiAgICAvLyBnZXQgZmlsZSBsaXN0IHJlZmVyZW5jZVxuICAgIHZhciBzY3JvbGxMaXN0ID0gcm9vdC5yZWYubGlzdDtcbiAgICB2YXIgaXRlbUxpc3QgPSBzY3JvbGxMaXN0LmNoaWxkVmlld3NbMF07XG4gICAgdmFyIHZpc2libGVDaGlsZHJlbiA9IGl0ZW1MaXN0LmNoaWxkVmlld3MuZmlsdGVyKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICByZXR1cm4gY2hpbGQucmVjdC5lbGVtZW50LmhlaWdodDtcbiAgICB9KTtcbiAgICB2YXIgY2hpbGRyZW4gPSByb290XG4gICAgICAucXVlcnkoJ0dFVF9BQ1RJVkVfSVRFTVMnKVxuICAgICAgLm1hcChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgIHJldHVybiB2aXNpYmxlQ2hpbGRyZW4uZmluZChmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICAgIHJldHVybiBjaGlsZC5pZCA9PT0gaXRlbS5pZDtcbiAgICAgICAgfSk7XG4gICAgICB9KVxuICAgICAgLmZpbHRlcihmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgfSk7XG5cbiAgICAvLyBubyBjaGlsZHJlbiwgZG9uZSFcbiAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID09PSAwKSByZXR1cm4geyB2aXN1YWw6IHZpc3VhbCwgYm91bmRzOiBib3VuZHMgfTtcblxuICAgIHZhciBob3Jpem9udGFsU3BhY2UgPSBpdGVtTGlzdC5yZWN0LmVsZW1lbnQud2lkdGg7XG4gICAgdmFyIGRyYWdJbmRleCA9IGdldEl0ZW1JbmRleEJ5UG9zaXRpb24oXG4gICAgICBpdGVtTGlzdCxcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgc2Nyb2xsTGlzdC5kcmFnQ29vcmRpbmF0ZXNcbiAgICApO1xuXG4gICAgdmFyIGNoaWxkUmVjdCA9IGNoaWxkcmVuWzBdLnJlY3QuZWxlbWVudDtcblxuICAgIHZhciBpdGVtVmVydGljYWxNYXJnaW4gPSBjaGlsZFJlY3QubWFyZ2luVG9wICsgY2hpbGRSZWN0Lm1hcmdpbkJvdHRvbTtcbiAgICB2YXIgaXRlbUhvcml6b250YWxNYXJnaW4gPSBjaGlsZFJlY3QubWFyZ2luTGVmdCArIGNoaWxkUmVjdC5tYXJnaW5SaWdodDtcblxuICAgIHZhciBpdGVtV2lkdGggPSBjaGlsZFJlY3Qud2lkdGggKyBpdGVtSG9yaXpvbnRhbE1hcmdpbjtcbiAgICB2YXIgaXRlbUhlaWdodCA9IGNoaWxkUmVjdC5oZWlnaHQgKyBpdGVtVmVydGljYWxNYXJnaW47XG5cbiAgICB2YXIgbmV3SXRlbSA9IHR5cGVvZiBkcmFnSW5kZXggIT09ICd1bmRlZmluZWQnICYmIGRyYWdJbmRleCA+PSAwID8gMSA6IDA7XG4gICAgdmFyIHJlbW92ZWRJdGVtID0gY2hpbGRyZW4uZmluZChmdW5jdGlvbihjaGlsZCkge1xuICAgICAgcmV0dXJuIGNoaWxkLm1hcmtlZEZvclJlbW92YWwgJiYgY2hpbGQub3BhY2l0eSA8IDAuNDU7XG4gICAgfSlcbiAgICAgID8gLTFcbiAgICAgIDogMDtcbiAgICB2YXIgdmVydGljYWxJdGVtQ291bnQgPSBjaGlsZHJlbi5sZW5ndGggKyBuZXdJdGVtICsgcmVtb3ZlZEl0ZW07XG4gICAgdmFyIGl0ZW1zUGVyUm93ID0gTWF0aC5yb3VuZChob3Jpem9udGFsU3BhY2UgLyBpdGVtV2lkdGgpO1xuXG4gICAgLy8gc3RhY2tcbiAgICBpZiAoaXRlbXNQZXJSb3cgPT09IDEpIHtcbiAgICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICB2YXIgaGVpZ2h0ID0gaXRlbS5yZWN0LmVsZW1lbnQuaGVpZ2h0ICsgaXRlbVZlcnRpY2FsTWFyZ2luO1xuICAgICAgICBib3VuZHMgKz0gaGVpZ2h0O1xuICAgICAgICB2aXN1YWwgKz0gaGVpZ2h0ICogaXRlbS5vcGFjaXR5O1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIGdyaWRcbiAgICBlbHNlIHtcbiAgICAgIGJvdW5kcyA9IE1hdGguY2VpbCh2ZXJ0aWNhbEl0ZW1Db3VudCAvIGl0ZW1zUGVyUm93KSAqIGl0ZW1IZWlnaHQ7XG4gICAgICB2aXN1YWwgPSBib3VuZHM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgdmlzdWFsOiB2aXN1YWwsIGJvdW5kczogYm91bmRzIH07XG4gIH07XG5cbiAgdmFyIGNhbGN1bGF0ZVJvb3RCb3VuZGluZ0JveEhlaWdodCA9IGZ1bmN0aW9uIGNhbGN1bGF0ZVJvb3RCb3VuZGluZ0JveEhlaWdodChcbiAgICByb290XG4gICkge1xuICAgIHZhciBoZWlnaHQgPSByb290LnJlZi5tZWFzdXJlSGVpZ2h0IHx8IG51bGw7XG4gICAgdmFyIGNhcHBlZEhlaWdodCA9IHBhcnNlSW50KHJvb3Quc3R5bGUubWF4SGVpZ2h0LCAxMCkgfHwgbnVsbDtcbiAgICB2YXIgZml4ZWRIZWlnaHQgPSBoZWlnaHQgPT09IDAgPyBudWxsIDogaGVpZ2h0O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGNhcHBlZEhlaWdodDogY2FwcGVkSGVpZ2h0LFxuICAgICAgZml4ZWRIZWlnaHQ6IGZpeGVkSGVpZ2h0XG4gICAgfTtcbiAgfTtcblxuICB2YXIgZXhjZWVkc01heEZpbGVzID0gZnVuY3Rpb24gZXhjZWVkc01heEZpbGVzKHJvb3QsIGl0ZW1zKSB7XG4gICAgdmFyIGFsbG93UmVwbGFjZSA9IHJvb3QucXVlcnkoJ0dFVF9BTExPV19SRVBMQUNFJyk7XG4gICAgdmFyIGFsbG93TXVsdGlwbGUgPSByb290LnF1ZXJ5KCdHRVRfQUxMT1dfTVVMVElQTEUnKTtcbiAgICB2YXIgdG90YWxJdGVtcyA9IHJvb3QucXVlcnkoJ0dFVF9UT1RBTF9JVEVNUycpO1xuICAgIHZhciBtYXhJdGVtcyA9IHJvb3QucXVlcnkoJ0dFVF9NQVhfRklMRVMnKTtcblxuICAgIC8vIHRvdGFsIGFtb3VudCBvZiBpdGVtcyBiZWluZyBkcmFnZ2VkXG4gICAgdmFyIHRvdGFsQnJvd3NlSXRlbXMgPSBpdGVtcy5sZW5ndGg7XG5cbiAgICAvLyBpZiBkb2VzIG5vdCBhbGxvdyBtdWx0aXBsZSBpdGVtcyBhbmQgZHJhZ2dpbmcgbW9yZSB0aGFuIG9uZSBpdGVtXG4gICAgaWYgKCFhbGxvd011bHRpcGxlICYmIHRvdGFsQnJvd3NlSXRlbXMgPiAxKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBsaW1pdCBtYXggaXRlbXMgdG8gb25lIGlmIG5vdCBhbGxvd2VkIHRvIGRyb3AgbXVsdGlwbGUgaXRlbXNcbiAgICBtYXhJdGVtcyA9IGFsbG93TXVsdGlwbGUgPyBtYXhJdGVtcyA6IGFsbG93UmVwbGFjZSA/IG1heEl0ZW1zIDogMTtcblxuICAgIC8vIG5vIG1vcmUgcm9vbT9cbiAgICB2YXIgaGFzTWF4SXRlbXMgPSBpc0ludChtYXhJdGVtcyk7XG4gICAgaWYgKGhhc01heEl0ZW1zICYmIHRvdGFsSXRlbXMgKyB0b3RhbEJyb3dzZUl0ZW1zID4gbWF4SXRlbXMpIHtcbiAgICAgIHJvb3QuZGlzcGF0Y2goJ0RJRF9USFJPV19NQVhfRklMRVMnLCB7XG4gICAgICAgIHNvdXJjZTogaXRlbXMsXG4gICAgICAgIGVycm9yOiBjcmVhdGVSZXNwb25zZSgnd2FybmluZycsIDAsICdNYXggZmlsZXMnKVxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICB2YXIgZ2V0RHJhZ0luZGV4ID0gZnVuY3Rpb24gZ2V0RHJhZ0luZGV4KGxpc3QsIGNoaWxkcmVuLCBwb3NpdGlvbikge1xuICAgIHZhciBpdGVtTGlzdCA9IGxpc3QuY2hpbGRWaWV3c1swXTtcbiAgICByZXR1cm4gZ2V0SXRlbUluZGV4QnlQb3NpdGlvbihpdGVtTGlzdCwgY2hpbGRyZW4sIHtcbiAgICAgIGxlZnQ6IHBvc2l0aW9uLnNjb3BlTGVmdCAtIGl0ZW1MaXN0LnJlY3QuZWxlbWVudC5sZWZ0LFxuICAgICAgdG9wOlxuICAgICAgICBwb3NpdGlvbi5zY29wZVRvcCAtXG4gICAgICAgIChsaXN0LnJlY3Qub3V0ZXIudG9wICtcbiAgICAgICAgICBsaXN0LnJlY3QuZWxlbWVudC5tYXJnaW5Ub3AgK1xuICAgICAgICAgIGxpc3QucmVjdC5lbGVtZW50LnNjcm9sbFRvcClcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogRW5hYmxlIG9yIGRpc2FibGUgZmlsZSBkcm9wIGZ1bmN0aW9uYWxpdHlcbiAgICovXG4gIHZhciB0b2dnbGVEcm9wID0gZnVuY3Rpb24gdG9nZ2xlRHJvcChyb290KSB7XG4gICAgdmFyIGlzQWxsb3dlZCA9IHJvb3QucXVlcnkoJ0dFVF9BTExPV19EUk9QJyk7XG4gICAgdmFyIGlzRGlzYWJsZWQgPSByb290LnF1ZXJ5KCdHRVRfRElTQUJMRUQnKTtcbiAgICB2YXIgZW5hYmxlZCA9IGlzQWxsb3dlZCAmJiAhaXNEaXNhYmxlZDtcbiAgICBpZiAoZW5hYmxlZCAmJiAhcm9vdC5yZWYuaG9wcGVyKSB7XG4gICAgICB2YXIgaG9wcGVyID0gY3JlYXRlSG9wcGVyKFxuICAgICAgICByb290LmVsZW1lbnQsXG4gICAgICAgIGZ1bmN0aW9uKGl0ZW1zKSB7XG4gICAgICAgICAgLy8gYWxsb3cgcXVpY2sgdmFsaWRhdGlvbiBvZiBkcm9wcGVkIGl0ZW1zXG4gICAgICAgICAgdmFyIGJlZm9yZURyb3BGaWxlID1cbiAgICAgICAgICAgIHJvb3QucXVlcnkoJ0dFVF9CRUZPUkVfRFJPUF9GSUxFJykgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAvLyBhbGwgaXRlbXMgc2hvdWxkIGJlIHZhbGlkYXRlZCBieSBhbGwgZmlsdGVycyBhcyB2YWxpZFxuICAgICAgICAgIHZhciBkcm9wVmFsaWRhdGlvbiA9IHJvb3QucXVlcnkoJ0dFVF9EUk9QX1ZBTElEQVRJT04nKTtcbiAgICAgICAgICByZXR1cm4gZHJvcFZhbGlkYXRpb25cbiAgICAgICAgICAgID8gaXRlbXMuZXZlcnkoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgICBhcHBseUZpbHRlcnMoJ0FMTE9XX0hPUFBFUl9JVEVNJywgaXRlbSwge1xuICAgICAgICAgICAgICAgICAgICBxdWVyeTogcm9vdC5xdWVyeVxuICAgICAgICAgICAgICAgICAgfSkuZXZlcnkoZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgPT09IHRydWU7XG4gICAgICAgICAgICAgICAgICB9KSAmJiBiZWZvcmVEcm9wRmlsZShpdGVtKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICA6IHRydWU7XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBmaWx0ZXJJdGVtczogZnVuY3Rpb24gZmlsdGVySXRlbXMoaXRlbXMpIHtcbiAgICAgICAgICAgIHZhciBpZ25vcmVkRmlsZXMgPSByb290LnF1ZXJ5KCdHRVRfSUdOT1JFRF9GSUxFUycpO1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW1zLmZpbHRlcihmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgIGlmIChpc0ZpbGUoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gIWlnbm9yZWRGaWxlcy5pbmNsdWRlcyhpdGVtLm5hbWUudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNhdGNoZXNEcm9wc09uUGFnZTogcm9vdC5xdWVyeSgnR0VUX0RST1BfT05fUEFHRScpLFxuICAgICAgICAgIHJlcXVpcmVzRHJvcE9uRWxlbWVudDogcm9vdC5xdWVyeSgnR0VUX0RST1BfT05fRUxFTUVOVCcpXG4gICAgICAgIH1cbiAgICAgICk7XG5cbiAgICAgIGhvcHBlci5vbmxvYWQgPSBmdW5jdGlvbihpdGVtcywgcG9zaXRpb24pIHtcbiAgICAgICAgLy8gZ2V0IGl0ZW0gY2hpbGRyZW4gZWxlbWVudHMgYW5kIHNvcnQgYmFzZWQgb24gbGlzdCBzb3J0XG4gICAgICAgIHZhciBsaXN0ID0gcm9vdC5yZWYubGlzdC5jaGlsZFZpZXdzWzBdO1xuICAgICAgICB2YXIgdmlzaWJsZUNoaWxkcmVuID0gbGlzdC5jaGlsZFZpZXdzLmZpbHRlcihmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICAgIHJldHVybiBjaGlsZC5yZWN0LmVsZW1lbnQuaGVpZ2h0O1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gcm9vdFxuICAgICAgICAgIC5xdWVyeSgnR0VUX0FDVElWRV9JVEVNUycpXG4gICAgICAgICAgLm1hcChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gdmlzaWJsZUNoaWxkcmVuLmZpbmQoZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkLmlkID09PSBpdGVtLmlkO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSlcbiAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgIGFwcGx5RmlsdGVyQ2hhaW4oJ0FERF9JVEVNUycsIGl0ZW1zLCB7IGRpc3BhdGNoOiByb290LmRpc3BhdGNoIH0pLnRoZW4oXG4gICAgICAgICAgZnVuY3Rpb24ocXVldWUpIHtcbiAgICAgICAgICAgIC8vIHRoZXNlIGZpbGVzIGRvbid0IGZpdCBzbyBzdG9wIGhlcmVcbiAgICAgICAgICAgIGlmIChleGNlZWRzTWF4RmlsZXMocm9vdCwgcXVldWUpKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgIC8vIGdvXG4gICAgICAgICAgICByb290LmRpc3BhdGNoKCdBRERfSVRFTVMnLCB7XG4gICAgICAgICAgICAgIGl0ZW1zOiBxdWV1ZSxcbiAgICAgICAgICAgICAgaW5kZXg6IGdldERyYWdJbmRleChyb290LnJlZi5saXN0LCBjaGlsZHJlbiwgcG9zaXRpb24pLFxuICAgICAgICAgICAgICBpbnRlcmFjdGlvbk1ldGhvZDogSW50ZXJhY3Rpb25NZXRob2QuRFJPUFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICApO1xuXG4gICAgICAgIHJvb3QuZGlzcGF0Y2goJ0RJRF9EUk9QJywgeyBwb3NpdGlvbjogcG9zaXRpb24gfSk7XG5cbiAgICAgICAgcm9vdC5kaXNwYXRjaCgnRElEX0VORF9EUkFHJywgeyBwb3NpdGlvbjogcG9zaXRpb24gfSk7XG4gICAgICB9O1xuXG4gICAgICBob3BwZXIub25kcmFnc3RhcnQgPSBmdW5jdGlvbihwb3NpdGlvbikge1xuICAgICAgICByb290LmRpc3BhdGNoKCdESURfU1RBUlRfRFJBRycsIHsgcG9zaXRpb246IHBvc2l0aW9uIH0pO1xuICAgICAgfTtcblxuICAgICAgaG9wcGVyLm9uZHJhZyA9IGRlYm91bmNlKGZ1bmN0aW9uKHBvc2l0aW9uKSB7XG4gICAgICAgIHJvb3QuZGlzcGF0Y2goJ0RJRF9EUkFHJywgeyBwb3NpdGlvbjogcG9zaXRpb24gfSk7XG4gICAgICB9KTtcblxuICAgICAgaG9wcGVyLm9uZHJhZ2VuZCA9IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XG4gICAgICAgIHJvb3QuZGlzcGF0Y2goJ0RJRF9FTkRfRFJBRycsIHsgcG9zaXRpb246IHBvc2l0aW9uIH0pO1xuICAgICAgfTtcblxuICAgICAgcm9vdC5yZWYuaG9wcGVyID0gaG9wcGVyO1xuXG4gICAgICByb290LnJlZi5kcmlwID0gcm9vdC5hcHBlbmRDaGlsZFZpZXcocm9vdC5jcmVhdGVDaGlsZFZpZXcoZHJpcCkpO1xuICAgIH0gZWxzZSBpZiAoIWVuYWJsZWQgJiYgcm9vdC5yZWYuaG9wcGVyKSB7XG4gICAgICByb290LnJlZi5ob3BwZXIuZGVzdHJveSgpO1xuICAgICAgcm9vdC5yZWYuaG9wcGVyID0gbnVsbDtcbiAgICAgIHJvb3QucmVtb3ZlQ2hpbGRWaWV3KHJvb3QucmVmLmRyaXApO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogRW5hYmxlIG9yIGRpc2FibGUgYnJvd3NlIGZ1bmN0aW9uYWxpdHlcbiAgICovXG4gIHZhciB0b2dnbGVCcm93c2UgPSBmdW5jdGlvbiB0b2dnbGVCcm93c2Uocm9vdCwgcHJvcHMpIHtcbiAgICB2YXIgaXNBbGxvd2VkID0gcm9vdC5xdWVyeSgnR0VUX0FMTE9XX0JST1dTRScpO1xuICAgIHZhciBpc0Rpc2FibGVkID0gcm9vdC5xdWVyeSgnR0VUX0RJU0FCTEVEJyk7XG4gICAgdmFyIGVuYWJsZWQgPSBpc0FsbG93ZWQgJiYgIWlzRGlzYWJsZWQ7XG4gICAgaWYgKGVuYWJsZWQgJiYgIXJvb3QucmVmLmJyb3dzZXIpIHtcbiAgICAgIHJvb3QucmVmLmJyb3dzZXIgPSByb290LmFwcGVuZENoaWxkVmlldyhcbiAgICAgICAgcm9vdC5jcmVhdGVDaGlsZFZpZXcoXG4gICAgICAgICAgYnJvd3NlcixcbiAgICAgICAgICBPYmplY3QuYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgICAgb25sb2FkOiBmdW5jdGlvbiBvbmxvYWQoaXRlbXMpIHtcbiAgICAgICAgICAgICAgYXBwbHlGaWx0ZXJDaGFpbignQUREX0lURU1TJywgaXRlbXMsIHtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaDogcm9vdC5kaXNwYXRjaFxuICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKHF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhlc2UgZmlsZXMgZG9uJ3QgZml0IHNvIHN0b3AgaGVyZVxuICAgICAgICAgICAgICAgIGlmIChleGNlZWRzTWF4RmlsZXMocm9vdCwgcXVldWUpKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAvLyBhZGQgaXRlbXMhXG4gICAgICAgICAgICAgICAgcm9vdC5kaXNwYXRjaCgnQUREX0lURU1TJywge1xuICAgICAgICAgICAgICAgICAgaXRlbXM6IHF1ZXVlLFxuICAgICAgICAgICAgICAgICAgaW5kZXg6IC0xLFxuICAgICAgICAgICAgICAgICAgaW50ZXJhY3Rpb25NZXRob2Q6IEludGVyYWN0aW9uTWV0aG9kLkJST1dTRVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICApLFxuXG4gICAgICAgIDBcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmICghZW5hYmxlZCAmJiByb290LnJlZi5icm93c2VyKSB7XG4gICAgICByb290LnJlbW92ZUNoaWxkVmlldyhyb290LnJlZi5icm93c2VyKTtcbiAgICAgIHJvb3QucmVmLmJyb3dzZXIgPSBudWxsO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogRW5hYmxlIG9yIGRpc2FibGUgcGFzdGUgZnVuY3Rpb25hbGl0eVxuICAgKi9cbiAgdmFyIHRvZ2dsZVBhc3RlID0gZnVuY3Rpb24gdG9nZ2xlUGFzdGUocm9vdCkge1xuICAgIHZhciBpc0FsbG93ZWQgPSByb290LnF1ZXJ5KCdHRVRfQUxMT1dfUEFTVEUnKTtcbiAgICB2YXIgaXNEaXNhYmxlZCA9IHJvb3QucXVlcnkoJ0dFVF9ESVNBQkxFRCcpO1xuICAgIHZhciBlbmFibGVkID0gaXNBbGxvd2VkICYmICFpc0Rpc2FibGVkO1xuICAgIGlmIChlbmFibGVkICYmICFyb290LnJlZi5wYXN0ZXIpIHtcbiAgICAgIHJvb3QucmVmLnBhc3RlciA9IGNyZWF0ZVBhc3RlcigpO1xuICAgICAgcm9vdC5yZWYucGFzdGVyLm9ubG9hZCA9IGZ1bmN0aW9uKGl0ZW1zKSB7XG4gICAgICAgIGFwcGx5RmlsdGVyQ2hhaW4oJ0FERF9JVEVNUycsIGl0ZW1zLCB7IGRpc3BhdGNoOiByb290LmRpc3BhdGNoIH0pLnRoZW4oXG4gICAgICAgICAgZnVuY3Rpb24ocXVldWUpIHtcbiAgICAgICAgICAgIC8vIHRoZXNlIGZpbGVzIGRvbid0IGZpdCBzbyBzdG9wIGhlcmVcbiAgICAgICAgICAgIGlmIChleGNlZWRzTWF4RmlsZXMocm9vdCwgcXVldWUpKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgIC8vIGFkZCBpdGVtcyFcbiAgICAgICAgICAgIHJvb3QuZGlzcGF0Y2goJ0FERF9JVEVNUycsIHtcbiAgICAgICAgICAgICAgaXRlbXM6IHF1ZXVlLFxuICAgICAgICAgICAgICBpbmRleDogLTEsXG4gICAgICAgICAgICAgIGludGVyYWN0aW9uTWV0aG9kOiBJbnRlcmFjdGlvbk1ldGhvZC5QQVNURVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKCFlbmFibGVkICYmIHJvb3QucmVmLnBhc3Rlcikge1xuICAgICAgcm9vdC5yZWYucGFzdGVyLmRlc3Ryb3koKTtcbiAgICAgIHJvb3QucmVmLnBhc3RlciA9IG51bGw7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSb3V0ZSBhY3Rpb25zXG4gICAqL1xuICB2YXIgcm91dGUkNSA9IGNyZWF0ZVJvdXRlKHtcbiAgICBESURfU0VUX0FMTE9XX0JST1dTRTogZnVuY3Rpb24gRElEX1NFVF9BTExPV19CUk9XU0UoX3JlZjUpIHtcbiAgICAgIHZhciByb290ID0gX3JlZjUucm9vdCxcbiAgICAgICAgcHJvcHMgPSBfcmVmNS5wcm9wcztcbiAgICAgIHRvZ2dsZUJyb3dzZShyb290LCBwcm9wcyk7XG4gICAgfSxcbiAgICBESURfU0VUX0FMTE9XX0RST1A6IGZ1bmN0aW9uIERJRF9TRVRfQUxMT1dfRFJPUChfcmVmNikge1xuICAgICAgdmFyIHJvb3QgPSBfcmVmNi5yb290O1xuICAgICAgdG9nZ2xlRHJvcChyb290KTtcbiAgICB9LFxuICAgIERJRF9TRVRfQUxMT1dfUEFTVEU6IGZ1bmN0aW9uIERJRF9TRVRfQUxMT1dfUEFTVEUoX3JlZjcpIHtcbiAgICAgIHZhciByb290ID0gX3JlZjcucm9vdDtcbiAgICAgIHRvZ2dsZVBhc3RlKHJvb3QpO1xuICAgIH0sXG4gICAgRElEX1NFVF9ESVNBQkxFRDogZnVuY3Rpb24gRElEX1NFVF9ESVNBQkxFRChfcmVmOCkge1xuICAgICAgdmFyIHJvb3QgPSBfcmVmOC5yb290LFxuICAgICAgICBwcm9wcyA9IF9yZWY4LnByb3BzO1xuICAgICAgdG9nZ2xlRHJvcChyb290KTtcbiAgICAgIHRvZ2dsZVBhc3RlKHJvb3QpO1xuICAgICAgdG9nZ2xlQnJvd3NlKHJvb3QsIHByb3BzKTtcbiAgICAgIHZhciBpc0Rpc2FibGVkID0gcm9vdC5xdWVyeSgnR0VUX0RJU0FCTEVEJyk7XG4gICAgICBpZiAoaXNEaXNhYmxlZCkge1xuICAgICAgICByb290LmVsZW1lbnQuZGF0YXNldC5kaXNhYmxlZCA9ICdkaXNhYmxlZCc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkZWxldGUgcm9vdC5lbGVtZW50LmRhdGFzZXQuZGlzYWJsZWQ7IDw9IHRoaXMgZG9lcyBub3Qgd29yayBvbiBpT1MgMTBcbiAgICAgICAgcm9vdC5lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1kaXNhYmxlZCcpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgdmFyIHJvb3QgPSBjcmVhdGVWaWV3KHtcbiAgICBuYW1lOiAncm9vdCcsXG4gICAgcmVhZDogZnVuY3Rpb24gcmVhZChfcmVmOSkge1xuICAgICAgdmFyIHJvb3QgPSBfcmVmOS5yb290O1xuICAgICAgaWYgKHJvb3QucmVmLm1lYXN1cmUpIHtcbiAgICAgICAgcm9vdC5yZWYubWVhc3VyZUhlaWdodCA9IHJvb3QucmVmLm1lYXN1cmUub2Zmc2V0SGVpZ2h0O1xuICAgICAgfVxuICAgIH0sXG4gICAgY3JlYXRlOiBjcmVhdGUkZSxcbiAgICB3cml0ZTogd3JpdGUkOSxcbiAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KF9yZWYxMCkge1xuICAgICAgdmFyIHJvb3QgPSBfcmVmMTAucm9vdDtcbiAgICAgIGlmIChyb290LnJlZi5wYXN0ZXIpIHtcbiAgICAgICAgcm9vdC5yZWYucGFzdGVyLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICAgIGlmIChyb290LnJlZi5ob3BwZXIpIHtcbiAgICAgICAgcm9vdC5yZWYuaG9wcGVyLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICAgIHJvb3QuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBwcmV2ZW50KTtcbiAgICAgIHJvb3QuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdnZXN0dXJlc3RhcnQnLCBwcmV2ZW50KTtcbiAgICB9LFxuICAgIG1peGluczoge1xuICAgICAgc3R5bGVzOiBbJ2hlaWdodCddXG4gICAgfVxuICB9KTtcblxuICAvLyBjcmVhdGVzIHRoZSBhcHBcbiAgdmFyIGNyZWF0ZUFwcCA9IGZ1bmN0aW9uIGNyZWF0ZUFwcCgpIHtcbiAgICB2YXIgaW5pdGlhbE9wdGlvbnMgPVxuICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICAvLyBsZXQgZWxlbWVudFxuICAgIHZhciBvcmlnaW5hbEVsZW1lbnQgPSBudWxsO1xuXG4gICAgLy8gZ2V0IGRlZmF1bHQgb3B0aW9uc1xuICAgIHZhciBkZWZhdWx0T3B0aW9ucyA9IGdldE9wdGlvbnMoKTtcblxuICAgIC8vIGNyZWF0ZSB0aGUgZGF0YSBzdG9yZSwgdGhpcyB3aWxsIGNvbnRhaW4gYWxsIG91ciBhcHAgaW5mb1xuICAgIHZhciBzdG9yZSA9IGNyZWF0ZVN0b3JlKFxuICAgICAgLy8gaW5pdGlhbCBzdGF0ZSAoc2hvdWxkIGJlIHNlcmlhbGl6YWJsZSlcbiAgICAgIGNyZWF0ZUluaXRpYWxTdGF0ZShkZWZhdWx0T3B0aW9ucyksXG5cbiAgICAgIC8vIHF1ZXJpZXNcbiAgICAgIFtxdWVyaWVzLCBjcmVhdGVPcHRpb25RdWVyaWVzKGRlZmF1bHRPcHRpb25zKV0sXG5cbiAgICAgIC8vIGFjdGlvbiBoYW5kbGVyc1xuICAgICAgW2FjdGlvbnMsIGNyZWF0ZU9wdGlvbkFjdGlvbnMoZGVmYXVsdE9wdGlvbnMpXVxuICAgICk7XG5cbiAgICAvLyBzZXQgaW5pdGlhbCBvcHRpb25zXG4gICAgc3RvcmUuZGlzcGF0Y2goJ1NFVF9PUFRJT05TJywgeyBvcHRpb25zOiBpbml0aWFsT3B0aW9ucyB9KTtcblxuICAgIC8vIGtpY2sgdGhyZWFkIGlmIHZpc2liaWxpdHkgY2hhbmdlc1xuICAgIHZhciB2aXNpYmlsaXR5SGFuZGxlciA9IGZ1bmN0aW9uIHZpc2liaWxpdHlIYW5kbGVyKCkge1xuICAgICAgaWYgKGRvY3VtZW50LmhpZGRlbikgcmV0dXJuO1xuICAgICAgc3RvcmUuZGlzcGF0Y2goJ0tJQ0snKTtcbiAgICB9O1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Zpc2liaWxpdHljaGFuZ2UnLCB2aXNpYmlsaXR5SGFuZGxlcik7XG5cbiAgICAvLyByZS1yZW5kZXIgb24gd2luZG93IHJlc2l6ZSBzdGFydCBhbmQgZmluaXNoXG4gICAgdmFyIHJlc2l6ZURvbmVUaW1lciA9IG51bGw7XG4gICAgdmFyIGlzUmVzaXppbmcgPSBmYWxzZTtcbiAgICB2YXIgaXNSZXNpemluZ0hvcml6b250YWxseSA9IGZhbHNlO1xuICAgIHZhciBpbml0aWFsV2luZG93V2lkdGggPSBudWxsO1xuICAgIHZhciBjdXJyZW50V2luZG93V2lkdGggPSBudWxsO1xuICAgIHZhciByZXNpemVIYW5kbGVyID0gZnVuY3Rpb24gcmVzaXplSGFuZGxlcigpIHtcbiAgICAgIGlmICghaXNSZXNpemluZykge1xuICAgICAgICBpc1Jlc2l6aW5nID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGNsZWFyVGltZW91dChyZXNpemVEb25lVGltZXIpO1xuICAgICAgcmVzaXplRG9uZVRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgaXNSZXNpemluZyA9IGZhbHNlO1xuICAgICAgICBpbml0aWFsV2luZG93V2lkdGggPSBudWxsO1xuICAgICAgICBjdXJyZW50V2luZG93V2lkdGggPSBudWxsO1xuICAgICAgICBpZiAoaXNSZXNpemluZ0hvcml6b250YWxseSkge1xuICAgICAgICAgIGlzUmVzaXppbmdIb3Jpem9udGFsbHkgPSBmYWxzZTtcbiAgICAgICAgICBzdG9yZS5kaXNwYXRjaCgnRElEX1NUT1BfUkVTSVpFJyk7XG4gICAgICAgIH1cbiAgICAgIH0sIDUwMCk7XG4gICAgfTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgcmVzaXplSGFuZGxlcik7XG5cbiAgICAvLyByZW5kZXIgaW5pdGlhbCB2aWV3XG4gICAgdmFyIHZpZXcgPSByb290KHN0b3JlLCB7IGlkOiBnZXRVbmlxdWVJZCgpIH0pO1xuXG4gICAgLy9cbiAgICAvLyBQUklWQVRFIEFQSSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy9cbiAgICB2YXIgaXNSZXN0aW5nID0gZmFsc2U7XG4gICAgdmFyIGlzSGlkZGVuID0gZmFsc2U7XG5cbiAgICB2YXIgcmVhZFdyaXRlQXBpID0ge1xuICAgICAgLy8gbmVjZXNzYXJ5IGZvciB1cGRhdGUgbG9vcFxuXG4gICAgICAvKipcbiAgICAgICAqIFJlYWRzIGZyb20gZG9tIChuZXZlciBjYWxsIG1hbnVhbGx5KVxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuICAgICAgX3JlYWQ6IGZ1bmN0aW9uIF9yZWFkKCkge1xuICAgICAgICAvLyB0ZXN0IGlmIHdlJ3JlIHJlc2l6aW5nIGhvcml6b250YWxseVxuICAgICAgICAvLyBUT0RPOiBzZWUgaWYgd2UgY2FuIG9wdGltaXplIHRoaXMgYnkgbWVhc3VyaW5nIHJvb3QgcmVjdFxuICAgICAgICBpZiAoaXNSZXNpemluZykge1xuICAgICAgICAgIGN1cnJlbnRXaW5kb3dXaWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgICAgICAgIGlmICghaW5pdGlhbFdpbmRvd1dpZHRoKSB7XG4gICAgICAgICAgICBpbml0aWFsV2luZG93V2lkdGggPSBjdXJyZW50V2luZG93V2lkdGg7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgIWlzUmVzaXppbmdIb3Jpem9udGFsbHkgJiZcbiAgICAgICAgICAgIGN1cnJlbnRXaW5kb3dXaWR0aCAhPT0gaW5pdGlhbFdpbmRvd1dpZHRoXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBzdG9yZS5kaXNwYXRjaCgnRElEX1NUQVJUX1JFU0laRScpO1xuICAgICAgICAgICAgaXNSZXNpemluZ0hvcml6b250YWxseSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzSGlkZGVuICYmIGlzUmVzdGluZykge1xuICAgICAgICAgIC8vIHRlc3QgaWYgaXMgbm8gbG9uZ2VyIGhpZGRlblxuICAgICAgICAgIGlzUmVzdGluZyA9IHZpZXcuZWxlbWVudC5vZmZzZXRQYXJlbnQgPT09IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiByZXN0aW5nLCBubyBuZWVkIHRvIHJlYWQgYXMgbnVtYmVycyB3aWxsIHN0aWxsIGFsbCBiZSBjb3JyZWN0XG4gICAgICAgIGlmIChpc1Jlc3RpbmcpIHJldHVybjtcblxuICAgICAgICAvLyByZWFkIHZpZXcgZGF0YVxuICAgICAgICB2aWV3Ll9yZWFkKCk7XG5cbiAgICAgICAgLy8gaWYgaXMgaGlkZGVuIHdlIG5lZWQgdG8ga25vdyBzbyB3ZSBleGl0IHJlc3QgbW9kZSB3aGVuIHJldmVhbGVkXG4gICAgICAgIGlzSGlkZGVuID0gdmlldy5yZWN0LmVsZW1lbnQuaGlkZGVuO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBXcml0ZXMgdG8gZG9tIChuZXZlciBjYWxsIG1hbnVhbGx5KVxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuICAgICAgX3dyaXRlOiBmdW5jdGlvbiBfd3JpdGUodHMpIHtcbiAgICAgICAgLy8gZ2V0IGFsbCBhY3Rpb25zIGZyb20gc3RvcmVcbiAgICAgICAgdmFyIGFjdGlvbnMgPSBzdG9yZVxuICAgICAgICAgIC5wcm9jZXNzQWN0aW9uUXVldWUoKVxuXG4gICAgICAgICAgLy8gZmlsdGVyIG91dCBzZXQgYWN0aW9ucyAodGhlc2Ugd2lsbCBhdXRvbWF0aWNhbGx5IHRyaWdnZXIgRElEX1NFVClcbiAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKGFjdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuICEvXlNFVF8vLnRlc3QoYWN0aW9uLnR5cGUpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGlmIHdhcyBpZGxpbmcgYW5kIG5vIGFjdGlvbnMgc3RvcCBoZXJlXG4gICAgICAgIGlmIChpc1Jlc3RpbmcgJiYgIWFjdGlvbnMubGVuZ3RoKSByZXR1cm47XG5cbiAgICAgICAgLy8gc29tZSBhY3Rpb25zIG1pZ2h0IHRyaWdnZXIgZXZlbnRzXG4gICAgICAgIHJvdXRlQWN0aW9uc1RvRXZlbnRzKGFjdGlvbnMpO1xuXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgdmlld1xuICAgICAgICBpc1Jlc3RpbmcgPSB2aWV3Ll93cml0ZSh0cywgYWN0aW9ucywgaXNSZXNpemluZ0hvcml6b250YWxseSk7XG5cbiAgICAgICAgLy8gd2lsbCBjbGVhbiB1cCBhbGwgYXJjaGl2ZWQgaXRlbXNcbiAgICAgICAgcmVtb3ZlUmVsZWFzZWRJdGVtcyhzdG9yZS5xdWVyeSgnR0VUX0lURU1TJykpO1xuXG4gICAgICAgIC8vIG5vdyBpZGxpbmdcbiAgICAgICAgaWYgKGlzUmVzdGluZykge1xuICAgICAgICAgIHN0b3JlLnByb2Nlc3NEaXNwYXRjaFF1ZXVlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy9cbiAgICAvLyBFWFBPU0UgRVZFTlRTIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvL1xuICAgIHZhciBjcmVhdGVFdmVudCA9IGZ1bmN0aW9uIGNyZWF0ZUV2ZW50KG5hbWUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIC8vIGNyZWF0ZSBkZWZhdWx0IGV2ZW50XG4gICAgICAgIHZhciBldmVudCA9IHtcbiAgICAgICAgICB0eXBlOiBuYW1lXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gbm8gZGF0YSB0byBhZGRcbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY29weSByZWxldmFudCBwcm9wc1xuICAgICAgICBpZiAoZGF0YS5oYXNPd25Qcm9wZXJ0eSgnZXJyb3InKSkge1xuICAgICAgICAgIGV2ZW50LmVycm9yID0gZGF0YS5lcnJvciA/IE9iamVjdC5hc3NpZ24oe30sIGRhdGEuZXJyb3IpIDogbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkYXRhLnN0YXR1cykge1xuICAgICAgICAgIGV2ZW50LnN0YXR1cyA9IE9iamVjdC5hc3NpZ24oe30sIGRhdGEuc3RhdHVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkYXRhLmZpbGUpIHtcbiAgICAgICAgICBldmVudC5vdXRwdXQgPSBkYXRhLmZpbGU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBvbmx5IHNvdXJjZSBpcyBhdmFpbGFibGUsIGVsc2UgYWRkIGl0ZW0gaWYgcG9zc2libGVcbiAgICAgICAgaWYgKGRhdGEuc291cmNlKSB7XG4gICAgICAgICAgZXZlbnQuZmlsZSA9IGRhdGEuc291cmNlO1xuICAgICAgICB9IGVsc2UgaWYgKGRhdGEuaXRlbSB8fCBkYXRhLmlkKSB7XG4gICAgICAgICAgdmFyIGl0ZW0gPSBkYXRhLml0ZW0gPyBkYXRhLml0ZW0gOiBzdG9yZS5xdWVyeSgnR0VUX0lURU0nLCBkYXRhLmlkKTtcbiAgICAgICAgICBldmVudC5maWxlID0gaXRlbSA/IGNyZWF0ZUl0ZW1BUEkoaXRlbSkgOiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbWFwIGFsbCBpdGVtcyBpbiBhIHBvc3NpYmxlIGl0ZW1zIGFycmF5XG4gICAgICAgIGlmIChkYXRhLml0ZW1zKSB7XG4gICAgICAgICAgZXZlbnQuaXRlbXMgPSBkYXRhLml0ZW1zLm1hcChjcmVhdGVJdGVtQVBJKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHRoaXMgaXMgYSBwcm9ncmVzcyBldmVudCBhZGQgdGhlIHByb2dyZXNzIGFtb3VudFxuICAgICAgICBpZiAoL3Byb2dyZXNzLy50ZXN0KG5hbWUpKSB7XG4gICAgICAgICAgZXZlbnQucHJvZ3Jlc3MgPSBkYXRhLnByb2dyZXNzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY29weSByZWxldmFudCBwcm9wc1xuICAgICAgICBpZiAoZGF0YS5oYXNPd25Qcm9wZXJ0eSgnb3JpZ2luJykgJiYgZGF0YS5oYXNPd25Qcm9wZXJ0eSgndGFyZ2V0JykpIHtcbiAgICAgICAgICBldmVudC5vcmlnaW4gPSBkYXRhLm9yaWdpbjtcbiAgICAgICAgICBldmVudC50YXJnZXQgPSBkYXRhLnRhcmdldDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBldmVudDtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBldmVudFJvdXRlcyA9IHtcbiAgICAgIERJRF9ERVNUUk9ZOiBjcmVhdGVFdmVudCgnZGVzdHJveScpLFxuXG4gICAgICBESURfSU5JVDogY3JlYXRlRXZlbnQoJ2luaXQnKSxcblxuICAgICAgRElEX1RIUk9XX01BWF9GSUxFUzogY3JlYXRlRXZlbnQoJ3dhcm5pbmcnKSxcblxuICAgICAgRElEX0lOSVRfSVRFTTogY3JlYXRlRXZlbnQoJ2luaXRmaWxlJyksXG4gICAgICBESURfU1RBUlRfSVRFTV9MT0FEOiBjcmVhdGVFdmVudCgnYWRkZmlsZXN0YXJ0JyksXG4gICAgICBESURfVVBEQVRFX0lURU1fTE9BRF9QUk9HUkVTUzogY3JlYXRlRXZlbnQoJ2FkZGZpbGVwcm9ncmVzcycpLFxuICAgICAgRElEX0xPQURfSVRFTTogY3JlYXRlRXZlbnQoJ2FkZGZpbGUnKSxcblxuICAgICAgRElEX1RIUk9XX0lURU1fSU5WQUxJRDogW2NyZWF0ZUV2ZW50KCdlcnJvcicpLCBjcmVhdGVFdmVudCgnYWRkZmlsZScpXSxcblxuICAgICAgRElEX1RIUk9XX0lURU1fTE9BRF9FUlJPUjogW2NyZWF0ZUV2ZW50KCdlcnJvcicpLCBjcmVhdGVFdmVudCgnYWRkZmlsZScpXSxcblxuICAgICAgRElEX1RIUk9XX0lURU1fUkVNT1ZFX0VSUk9SOiBbXG4gICAgICAgIGNyZWF0ZUV2ZW50KCdlcnJvcicpLFxuICAgICAgICBjcmVhdGVFdmVudCgncmVtb3ZlZmlsZScpXG4gICAgICBdLFxuXG4gICAgICBESURfUFJFUEFSRV9PVVRQVVQ6IGNyZWF0ZUV2ZW50KCdwcmVwYXJlZmlsZScpLFxuXG4gICAgICBESURfU1RBUlRfSVRFTV9QUk9DRVNTSU5HOiBjcmVhdGVFdmVudCgncHJvY2Vzc2ZpbGVzdGFydCcpLFxuICAgICAgRElEX1VQREFURV9JVEVNX1BST0NFU1NfUFJPR1JFU1M6IGNyZWF0ZUV2ZW50KCdwcm9jZXNzZmlsZXByb2dyZXNzJyksXG4gICAgICBESURfQUJPUlRfSVRFTV9QUk9DRVNTSU5HOiBjcmVhdGVFdmVudCgncHJvY2Vzc2ZpbGVhYm9ydCcpLFxuICAgICAgRElEX0NPTVBMRVRFX0lURU1fUFJPQ0VTU0lORzogY3JlYXRlRXZlbnQoJ3Byb2Nlc3NmaWxlJyksXG4gICAgICBESURfQ09NUExFVEVfSVRFTV9QUk9DRVNTSU5HX0FMTDogY3JlYXRlRXZlbnQoJ3Byb2Nlc3NmaWxlcycpLFxuICAgICAgRElEX1JFVkVSVF9JVEVNX1BST0NFU1NJTkc6IGNyZWF0ZUV2ZW50KCdwcm9jZXNzZmlsZXJldmVydCcpLFxuXG4gICAgICBESURfVEhST1dfSVRFTV9QUk9DRVNTSU5HX0VSUk9SOiBbXG4gICAgICAgIGNyZWF0ZUV2ZW50KCdlcnJvcicpLFxuICAgICAgICBjcmVhdGVFdmVudCgncHJvY2Vzc2ZpbGUnKVxuICAgICAgXSxcblxuICAgICAgRElEX1JFTU9WRV9JVEVNOiBjcmVhdGVFdmVudCgncmVtb3ZlZmlsZScpLFxuXG4gICAgICBESURfVVBEQVRFX0lURU1TOiBjcmVhdGVFdmVudCgndXBkYXRlZmlsZXMnKSxcblxuICAgICAgRElEX0FDVElWQVRFX0lURU06IGNyZWF0ZUV2ZW50KCdhY3RpdmF0ZWZpbGUnKSxcblxuICAgICAgRElEX1JFT1JERVJfSVRFTVM6IGNyZWF0ZUV2ZW50KCdyZW9yZGVyZmlsZXMnKVxuICAgIH07XG5cbiAgICB2YXIgZXhwb3NlRXZlbnQgPSBmdW5jdGlvbiBleHBvc2VFdmVudChldmVudCkge1xuICAgICAgLy8gY3JlYXRlIGV2ZW50IG9iamVjdCB0byBiZSBkaXNwYXRjaGVkXG4gICAgICB2YXIgZGV0YWlsID0gT2JqZWN0LmFzc2lnbih7IHBvbmQ6IGV4cG9ydHMgfSwgZXZlbnQpO1xuICAgICAgZGVsZXRlIGRldGFpbC50eXBlO1xuICAgICAgdmlldy5lbGVtZW50LmRpc3BhdGNoRXZlbnQoXG4gICAgICAgIG5ldyBDdXN0b21FdmVudCgnRmlsZVBvbmQ6JyArIGV2ZW50LnR5cGUsIHtcbiAgICAgICAgICAvLyBldmVudCBpbmZvXG4gICAgICAgICAgZGV0YWlsOiBkZXRhaWwsXG5cbiAgICAgICAgICAvLyBldmVudCBiZWhhdmlvdXJcbiAgICAgICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgICAgICAgY29tcG9zZWQ6IHRydWUgLy8gdHJpZ2dlcnMgbGlzdGVuZXJzIG91dHNpZGUgb2Ygc2hhZG93IHJvb3RcbiAgICAgICAgfSlcbiAgICAgICk7XG5cbiAgICAgIC8vIGV2ZW50IG9iamVjdCB0byBwYXJhbXMgdXNlZCBmb3IgYG9uKClgIGV2ZW50IGhhbmRsZXJzIGFuZCBjYWxsYmFja3MgYG9uaW5pdCgpYFxuICAgICAgdmFyIHBhcmFtcyA9IFtdO1xuXG4gICAgICAvLyBpZiBpcyBwb3NzaWJsZSBlcnJvciBldmVudCwgbWFrZSBpdCB0aGUgZmlyc3QgcGFyYW1cbiAgICAgIGlmIChldmVudC5oYXNPd25Qcm9wZXJ0eSgnZXJyb3InKSkge1xuICAgICAgICBwYXJhbXMucHVzaChldmVudC5lcnJvcik7XG4gICAgICB9XG5cbiAgICAgIC8vIGZpbGUgaXMgYWx3YXlzIHNlY3Rpb25cbiAgICAgIGlmIChldmVudC5oYXNPd25Qcm9wZXJ0eSgnZmlsZScpKSB7XG4gICAgICAgIHBhcmFtcy5wdXNoKGV2ZW50LmZpbGUpO1xuICAgICAgfVxuXG4gICAgICAvLyBhcHBlbmQgb3RoZXIgcHJvcHNcbiAgICAgIHZhciBmaWx0ZXJlZCA9IFsndHlwZScsICdlcnJvcicsICdmaWxlJ107XG4gICAgICBPYmplY3Qua2V5cyhldmVudClcbiAgICAgICAgLmZpbHRlcihmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICByZXR1cm4gIWZpbHRlcmVkLmluY2x1ZGVzKGtleSk7XG4gICAgICAgIH0pXG4gICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgIHJldHVybiBwYXJhbXMucHVzaChldmVudFtrZXldKTtcbiAgICAgICAgfSk7XG5cbiAgICAgIC8vIG9uKHR5cGUsICgpID0+IHsgfSlcbiAgICAgIGV4cG9ydHMuZmlyZS5hcHBseShleHBvcnRzLCBbZXZlbnQudHlwZV0uY29uY2F0KHBhcmFtcykpO1xuXG4gICAgICAvLyBvbmluaXQgPSAoKSA9PiB7fVxuICAgICAgdmFyIGhhbmRsZXIgPSBzdG9yZS5xdWVyeSgnR0VUX09OJyArIGV2ZW50LnR5cGUudG9VcHBlckNhc2UoKSk7XG4gICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICBoYW5kbGVyLmFwcGx5KHZvaWQgMCwgcGFyYW1zKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHJvdXRlQWN0aW9uc1RvRXZlbnRzID0gZnVuY3Rpb24gcm91dGVBY3Rpb25zVG9FdmVudHMoYWN0aW9ucykge1xuICAgICAgaWYgKCFhY3Rpb25zLmxlbmd0aCkgcmV0dXJuO1xuICAgICAgYWN0aW9uc1xuICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKGFjdGlvbikge1xuICAgICAgICAgIHJldHVybiBldmVudFJvdXRlc1thY3Rpb24udHlwZV07XG4gICAgICAgIH0pXG4gICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uKGFjdGlvbikge1xuICAgICAgICAgIHZhciByb3V0ZXMgPSBldmVudFJvdXRlc1thY3Rpb24udHlwZV07XG4gICAgICAgICAgKEFycmF5LmlzQXJyYXkocm91dGVzKSA/IHJvdXRlcyA6IFtyb3V0ZXNdKS5mb3JFYWNoKGZ1bmN0aW9uKHJvdXRlKSB7XG4gICAgICAgICAgICAvLyB0aGlzIGlzbid0IGZhbnRhc3RpYywgYnV0IGJlY2F1c2Ugb2YgdGhlIHN0YWNraW5nIG9mIHNldHRpbWVvdXRzIHBsdWdpbnMgY2FuIGhhbmRsZSB0aGUgZGlkX2xvYWQgYmVmb3JlIHRoZSBkaWRfaW5pdFxuICAgICAgICAgICAgaWYgKGFjdGlvbi50eXBlID09PSAnRElEX0lOSVRfSVRFTScpIHtcbiAgICAgICAgICAgICAgZXhwb3NlRXZlbnQocm91dGUoYWN0aW9uLmRhdGEpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgZXhwb3NlRXZlbnQocm91dGUoYWN0aW9uLmRhdGEpKTtcbiAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvL1xuICAgIC8vIFBVQkxJQyBBUEkgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vXG4gICAgdmFyIHNldE9wdGlvbnMgPSBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBzdG9yZS5kaXNwYXRjaCgnU0VUX09QVElPTlMnLCB7IG9wdGlvbnM6IG9wdGlvbnMgfSk7XG4gICAgfTtcblxuICAgIHZhciBnZXRGaWxlID0gZnVuY3Rpb24gZ2V0RmlsZShxdWVyeSkge1xuICAgICAgcmV0dXJuIHN0b3JlLnF1ZXJ5KCdHRVRfQUNUSVZFX0lURU0nLCBxdWVyeSk7XG4gICAgfTtcblxuICAgIHZhciBwcmVwYXJlRmlsZSA9IGZ1bmN0aW9uIHByZXBhcmVGaWxlKHF1ZXJ5KSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHN0b3JlLmRpc3BhdGNoKCdSRVFVRVNUX0lURU1fUFJFUEFSRScsIHtcbiAgICAgICAgICBxdWVyeTogcXVlcnksXG4gICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24gc3VjY2VzcyhpdGVtKSB7XG4gICAgICAgICAgICByZXNvbHZlKGl0ZW0pO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZmFpbHVyZTogZnVuY3Rpb24gZmFpbHVyZShlcnJvcikge1xuICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHZhciBhZGRGaWxlID0gZnVuY3Rpb24gYWRkRmlsZShzb3VyY2UpIHtcbiAgICAgIHZhciBvcHRpb25zID1cbiAgICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgYWRkRmlsZXMoW3sgc291cmNlOiBzb3VyY2UsIG9wdGlvbnM6IG9wdGlvbnMgfV0sIHtcbiAgICAgICAgICBpbmRleDogb3B0aW9ucy5pbmRleFxuICAgICAgICB9KVxuICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKGl0ZW1zKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShpdGVtcyAmJiBpdGVtc1swXSk7XG4gICAgICAgICAgfSlcbiAgICAgICAgICAuY2F0Y2gocmVqZWN0KTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICB2YXIgaXNGaWxlUG9uZEZpbGUgPSBmdW5jdGlvbiBpc0ZpbGVQb25kRmlsZShvYmopIHtcbiAgICAgIHJldHVybiBvYmouZmlsZSAmJiBvYmouaWQ7XG4gICAgfTtcblxuICAgIHZhciByZW1vdmVGaWxlID0gZnVuY3Rpb24gcmVtb3ZlRmlsZShxdWVyeSwgb3B0aW9ucykge1xuICAgICAgLy8gaWYgb25seSBwYXNzZWQgb3B0aW9uc1xuICAgICAgaWYgKHR5cGVvZiBxdWVyeSA9PT0gJ29iamVjdCcgJiYgIWlzRmlsZVBvbmRGaWxlKHF1ZXJ5KSAmJiAhb3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gcXVlcnk7XG4gICAgICAgIHF1ZXJ5ID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICAvLyByZXF1ZXN0IGl0ZW0gcmVtb3ZhbFxuICAgICAgc3RvcmUuZGlzcGF0Y2goXG4gICAgICAgICdSRU1PVkVfSVRFTScsXG4gICAgICAgIE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHsgcXVlcnk6IHF1ZXJ5IH0pXG4gICAgICApO1xuXG4gICAgICAvLyBzZWUgaWYgaXRlbSBoYXMgYmVlbiByZW1vdmVkXG4gICAgICByZXR1cm4gc3RvcmUucXVlcnkoJ0dFVF9BQ1RJVkVfSVRFTScsIHF1ZXJ5KSA9PT0gbnVsbDtcbiAgICB9O1xuXG4gICAgdmFyIGFkZEZpbGVzID0gZnVuY3Rpb24gYWRkRmlsZXMoKSB7XG4gICAgICBmb3IgKFxuICAgICAgICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwO1xuICAgICAgICBfa2V5IDwgX2xlbjtcbiAgICAgICAgX2tleSsrXG4gICAgICApIHtcbiAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgdmFyIHNvdXJjZXMgPSBbXTtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7fTtcblxuICAgICAgICAvLyB1c2VyIHBhc3NlZCBhIHNvdXJjZXMgYXJyYXlcbiAgICAgICAgaWYgKGlzQXJyYXkoYXJnc1swXSkpIHtcbiAgICAgICAgICBzb3VyY2VzLnB1c2guYXBwbHkoc291cmNlcywgYXJnc1swXSk7XG4gICAgICAgICAgT2JqZWN0LmFzc2lnbihvcHRpb25zLCBhcmdzWzFdIHx8IHt9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB1c2VyIHBhc3NlZCBzb3VyY2VzIGFzIGFyZ3VtZW50cywgbGFzdCBvbmUgbWlnaHQgYmUgb3B0aW9ucyBvYmplY3RcbiAgICAgICAgICB2YXIgbGFzdEFyZ3VtZW50ID0gYXJnc1thcmdzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHR5cGVvZiBsYXN0QXJndW1lbnQgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAhKGxhc3RBcmd1bWVudCBpbnN0YW5jZW9mIEJsb2IpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKG9wdGlvbnMsIGFyZ3MucG9wKCkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGFkZCByZXN0IHRvIHNvdXJjZXNcbiAgICAgICAgICBzb3VyY2VzLnB1c2guYXBwbHkoc291cmNlcywgYXJncyk7XG4gICAgICAgIH1cblxuICAgICAgICBzdG9yZS5kaXNwYXRjaCgnQUREX0lURU1TJywge1xuICAgICAgICAgIGl0ZW1zOiBzb3VyY2VzLFxuICAgICAgICAgIGluZGV4OiBvcHRpb25zLmluZGV4LFxuICAgICAgICAgIGludGVyYWN0aW9uTWV0aG9kOiBJbnRlcmFjdGlvbk1ldGhvZC5BUEksXG4gICAgICAgICAgc3VjY2VzczogcmVzb2x2ZSxcbiAgICAgICAgICBmYWlsdXJlOiByZWplY3RcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyIGdldEZpbGVzID0gZnVuY3Rpb24gZ2V0RmlsZXMoKSB7XG4gICAgICByZXR1cm4gc3RvcmUucXVlcnkoJ0dFVF9BQ1RJVkVfSVRFTVMnKTtcbiAgICB9O1xuXG4gICAgdmFyIHByb2Nlc3NGaWxlID0gZnVuY3Rpb24gcHJvY2Vzc0ZpbGUocXVlcnkpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgc3RvcmUuZGlzcGF0Y2goJ1JFUVVFU1RfSVRFTV9QUk9DRVNTSU5HJywge1xuICAgICAgICAgIHF1ZXJ5OiBxdWVyeSxcbiAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiBzdWNjZXNzKGl0ZW0pIHtcbiAgICAgICAgICAgIHJlc29sdmUoaXRlbSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBmYWlsdXJlOiBmdW5jdGlvbiBmYWlsdXJlKGVycm9yKSB7XG4gICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyIHByZXBhcmVGaWxlcyA9IGZ1bmN0aW9uIHByZXBhcmVGaWxlcygpIHtcbiAgICAgIGZvciAoXG4gICAgICAgIHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7XG4gICAgICAgIF9rZXkyIDwgX2xlbjI7XG4gICAgICAgIF9rZXkyKytcbiAgICAgICkge1xuICAgICAgICBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG4gICAgICB2YXIgcXVlcmllcyA9IEFycmF5LmlzQXJyYXkoYXJnc1swXSkgPyBhcmdzWzBdIDogYXJncztcbiAgICAgIHZhciBpdGVtcyA9IHF1ZXJpZXMubGVuZ3RoID8gcXVlcmllcyA6IGdldEZpbGVzKCk7XG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwoaXRlbXMubWFwKHByZXBhcmVGaWxlKSk7XG4gICAgfTtcblxuICAgIHZhciBwcm9jZXNzRmlsZXMgPSBmdW5jdGlvbiBwcm9jZXNzRmlsZXMoKSB7XG4gICAgICBmb3IgKFxuICAgICAgICB2YXIgX2xlbjMgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4zKSwgX2tleTMgPSAwO1xuICAgICAgICBfa2V5MyA8IF9sZW4zO1xuICAgICAgICBfa2V5MysrXG4gICAgICApIHtcbiAgICAgICAgYXJnc1tfa2V5M10gPSBhcmd1bWVudHNbX2tleTNdO1xuICAgICAgfVxuICAgICAgdmFyIHF1ZXJpZXMgPSBBcnJheS5pc0FycmF5KGFyZ3NbMF0pID8gYXJnc1swXSA6IGFyZ3M7XG4gICAgICBpZiAoIXF1ZXJpZXMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBmaWxlcyA9IGdldEZpbGVzKCkuZmlsdGVyKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgIShcbiAgICAgICAgICAgICAgaXRlbS5zdGF0dXMgPT09IEl0ZW1TdGF0dXMuSURMRSAmJlxuICAgICAgICAgICAgICBpdGVtLm9yaWdpbiA9PT0gRmlsZU9yaWdpbi5MT0NBTFxuICAgICAgICAgICAgKSAmJlxuICAgICAgICAgICAgaXRlbS5zdGF0dXMgIT09IEl0ZW1TdGF0dXMuUFJPQ0VTU0lORyAmJlxuICAgICAgICAgICAgaXRlbS5zdGF0dXMgIT09IEl0ZW1TdGF0dXMuUFJPQ0VTU0lOR19DT01QTEVURSAmJlxuICAgICAgICAgICAgaXRlbS5zdGF0dXMgIT09IEl0ZW1TdGF0dXMuUFJPQ0VTU0lOR19SRVZFUlRfRVJST1JcbiAgICAgICAgICApO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoZmlsZXMubWFwKHByb2Nlc3NGaWxlKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwocXVlcmllcy5tYXAocHJvY2Vzc0ZpbGUpKTtcbiAgICB9O1xuXG4gICAgdmFyIHJlbW92ZUZpbGVzID0gZnVuY3Rpb24gcmVtb3ZlRmlsZXMoKSB7XG4gICAgICBmb3IgKFxuICAgICAgICB2YXIgX2xlbjQgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW40KSwgX2tleTQgPSAwO1xuICAgICAgICBfa2V5NCA8IF9sZW40O1xuICAgICAgICBfa2V5NCsrXG4gICAgICApIHtcbiAgICAgICAgYXJnc1tfa2V5NF0gPSBhcmd1bWVudHNbX2tleTRdO1xuICAgICAgfVxuXG4gICAgICB2YXIgcXVlcmllcyA9IEFycmF5LmlzQXJyYXkoYXJnc1swXSkgPyBhcmdzWzBdIDogYXJncztcblxuICAgICAgdmFyIG9wdGlvbnM7XG4gICAgICBpZiAodHlwZW9mIHF1ZXJpZXNbcXVlcmllcy5sZW5ndGggLSAxXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgb3B0aW9ucyA9IHF1ZXJpZXMucG9wKCk7XG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYXJnc1swXSkpIHtcbiAgICAgICAgb3B0aW9ucyA9IGFyZ3NbMV07XG4gICAgICB9XG5cbiAgICAgIHZhciBmaWxlcyA9IGdldEZpbGVzKCk7XG5cbiAgICAgIGlmICghcXVlcmllcy5sZW5ndGgpXG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChcbiAgICAgICAgICBmaWxlcy5tYXAoZnVuY3Rpb24oZmlsZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlbW92ZUZpbGUoZmlsZSwgb3B0aW9ucyk7XG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcblxuICAgICAgLy8gd2hlbiByZW1vdmluZyBieSBpbmRleCB0aGUgaW5kZXhlcyBzaGlmdCBhZnRlciBlYWNoIGZpbGUgcmVtb3ZhbCBzbyB3ZSBuZWVkIHRvIGNvbnZlcnQgaW5kZXhlcyB0byBpZHNcbiAgICAgIHZhciBtYXBwZWRRdWVyaWVzID0gcXVlcmllc1xuICAgICAgICAubWFwKGZ1bmN0aW9uKHF1ZXJ5KSB7XG4gICAgICAgICAgcmV0dXJuIGlzTnVtYmVyKHF1ZXJ5KVxuICAgICAgICAgICAgPyBmaWxlc1txdWVyeV1cbiAgICAgICAgICAgICAgPyBmaWxlc1txdWVyeV0uaWRcbiAgICAgICAgICAgICAgOiBudWxsXG4gICAgICAgICAgICA6IHF1ZXJ5O1xuICAgICAgICB9KVxuICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKHF1ZXJ5KSB7XG4gICAgICAgICAgcmV0dXJuIHF1ZXJ5O1xuICAgICAgICB9KTtcblxuICAgICAgcmV0dXJuIG1hcHBlZFF1ZXJpZXMubWFwKGZ1bmN0aW9uKHEpIHtcbiAgICAgICAgcmV0dXJuIHJlbW92ZUZpbGUocSwgb3B0aW9ucyk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyIGV4cG9ydHMgPSBPYmplY3QuYXNzaWduKFxuICAgICAge30sXG5cbiAgICAgIG9uKCksXG4gICAgICB7fSxcblxuICAgICAgcmVhZFdyaXRlQXBpLFxuICAgICAge30sXG5cbiAgICAgIGNyZWF0ZU9wdGlvbkFQSShzdG9yZSwgZGVmYXVsdE9wdGlvbnMpLFxuICAgICAge1xuICAgICAgICAvKipcbiAgICAgICAgICogT3ZlcnJpZGUgb3B0aW9ucyBkZWZpbmVkIGluIG9wdGlvbnMgb2JqZWN0XG4gICAgICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICAgICAqL1xuICAgICAgICBzZXRPcHRpb25zOiBzZXRPcHRpb25zLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMb2FkIHRoZSBnaXZlbiBmaWxlXG4gICAgICAgICAqIEBwYXJhbSBzb3VyY2UgLSB0aGUgc291cmNlIG9mIHRoZSBmaWxlIChlaXRoZXIgYSBGaWxlLCBiYXNlNjQgZGF0YSB1cmkgb3IgdXJsKVxuICAgICAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIG9iamVjdCwgeyBpbmRleDogMCB9XG4gICAgICAgICAqL1xuICAgICAgICBhZGRGaWxlOiBhZGRGaWxlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMb2FkIHRoZSBnaXZlbiBmaWxlc1xuICAgICAgICAgKiBAcGFyYW0gc291cmNlcyAtIHRoZSBzb3VyY2VzIG9mIHRoZSBmaWxlcyB0byBsb2FkXG4gICAgICAgICAqIEBwYXJhbSBvcHRpb25zIC0gb2JqZWN0LCB7IGluZGV4OiAwIH1cbiAgICAgICAgICovXG4gICAgICAgIGFkZEZpbGVzOiBhZGRGaWxlcyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgZmlsZSBvYmplY3RzIG1hdGNoaW5nIHRoZSBnaXZlbiBxdWVyeVxuICAgICAgICAgKiBAcGFyYW0gcXVlcnkgeyBzdHJpbmcsIG51bWJlciwgbnVsbCB9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRGaWxlOiBnZXRGaWxlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGxvYWQgZmlsZSB3aXRoIGdpdmVuIG5hbWVcbiAgICAgICAgICogQHBhcmFtIHF1ZXJ5IHsgc3RyaW5nLCBudW1iZXIsIG51bGwgIH1cbiAgICAgICAgICovXG4gICAgICAgIHByb2Nlc3NGaWxlOiBwcm9jZXNzRmlsZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVxdWVzdCBwcmVwYXJlIG91dHB1dCBmb3IgZmlsZSB3aXRoIGdpdmVuIG5hbWVcbiAgICAgICAgICogQHBhcmFtIHF1ZXJ5IHsgc3RyaW5nLCBudW1iZXIsIG51bGwgIH1cbiAgICAgICAgICovXG4gICAgICAgIHByZXBhcmVGaWxlOiBwcmVwYXJlRmlsZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3ZlcyBhIGZpbGUgYnkgaXRzIG5hbWVcbiAgICAgICAgICogQHBhcmFtIHF1ZXJ5IHsgc3RyaW5nLCBudW1iZXIsIG51bGwgIH1cbiAgICAgICAgICovXG4gICAgICAgIHJlbW92ZUZpbGU6IHJlbW92ZUZpbGUsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1vdmVzIGEgZmlsZSB0byBhIG5ldyBsb2NhdGlvbiBpbiB0aGUgZmlsZXMgbGlzdFxuICAgICAgICAgKi9cbiAgICAgICAgbW92ZUZpbGU6IGZ1bmN0aW9uIG1vdmVGaWxlKHF1ZXJ5LCBpbmRleCkge1xuICAgICAgICAgIHJldHVybiBzdG9yZS5kaXNwYXRjaCgnTU9WRV9JVEVNJywgeyBxdWVyeTogcXVlcnksIGluZGV4OiBpbmRleCB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhbGwgZmlsZXMgKHdyYXBwZWQgaW4gcHVibGljIGFwaSlcbiAgICAgICAgICovXG4gICAgICAgIGdldEZpbGVzOiBnZXRGaWxlcyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU3RhcnRzIHVwbG9hZGluZyBhbGwgZmlsZXNcbiAgICAgICAgICovXG4gICAgICAgIHByb2Nlc3NGaWxlczogcHJvY2Vzc0ZpbGVzLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDbGVhcnMgYWxsIGZpbGVzIGZyb20gdGhlIGZpbGVzIGxpc3RcbiAgICAgICAgICovXG4gICAgICAgIHJlbW92ZUZpbGVzOiByZW1vdmVGaWxlcyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU3RhcnRzIHByZXBhcmluZyBvdXRwdXQgb2YgYWxsIGZpbGVzXG4gICAgICAgICAqL1xuICAgICAgICBwcmVwYXJlRmlsZXM6IHByZXBhcmVGaWxlcyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU29ydCBsaXN0IG9mIGZpbGVzXG4gICAgICAgICAqL1xuICAgICAgICBzb3J0OiBmdW5jdGlvbiBzb3J0KGNvbXBhcmUpIHtcbiAgICAgICAgICByZXR1cm4gc3RvcmUuZGlzcGF0Y2goJ1NPUlQnLCB7IGNvbXBhcmU6IGNvbXBhcmUgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJyb3dzZSB0aGUgZmlsZSBzeXN0ZW0gZm9yIGEgZmlsZVxuICAgICAgICAgKi9cbiAgICAgICAgYnJvd3NlOiBmdW5jdGlvbiBicm93c2UoKSB7XG4gICAgICAgICAgLy8gbmVlZHMgdG8gYmUgdHJpZ2dlciBkaXJlY3RseSBhcyB1c2VyIGFjdGlvbiBuZWVkcyB0byBiZSB0cmFjZWFibGUgKGlzIG5vdCB0cmFjZWFibGUgaW4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKVxuICAgICAgICAgIHZhciBpbnB1dCA9IHZpZXcuZWxlbWVudC5xdWVyeVNlbGVjdG9yKCdpbnB1dFt0eXBlPWZpbGVdJyk7XG4gICAgICAgICAgaWYgKGlucHV0KSB7XG4gICAgICAgICAgICBpbnB1dC5jbGljaygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVzdHJveXMgdGhlIGFwcFxuICAgICAgICAgKi9cbiAgICAgICAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgICAvLyByZXF1ZXN0IGRlc3RydWN0aW9uXG4gICAgICAgICAgZXhwb3J0cy5maXJlKCdkZXN0cm95Jywgdmlldy5lbGVtZW50KTtcblxuICAgICAgICAgIC8vIHN0b3AgYWN0aXZlIHByb2Nlc3NlcyAoZmlsZSB1cGxvYWRzLCBmZXRjaGVzLCBzdHVmZiBsaWtlIHRoYXQpXG4gICAgICAgICAgLy8gbG9vcCBvdmVyIGl0ZW1zIGFuZCBkZXBlbmRpbmcgb24gc3RhdGVzIGNhbGwgYWJvcnQgZm9yIG9uZ29pbmcgcHJvY2Vzc2VzXG4gICAgICAgICAgc3RvcmUuZGlzcGF0Y2goJ0FCT1JUX0FMTCcpO1xuXG4gICAgICAgICAgLy8gZGVzdHJveSB2aWV3XG4gICAgICAgICAgdmlldy5fZGVzdHJveSgpO1xuXG4gICAgICAgICAgLy8gc3RvcCBsaXN0ZW5pbmcgdG8gcmVzaXplXG4gICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHJlc2l6ZUhhbmRsZXIpO1xuXG4gICAgICAgICAgLy8gc3RvcCBsaXN0ZW5pbmcgdG8gdGhlIHZpc2libGl0eWNoYW5nZSBldmVudFxuICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Zpc2liaWxpdHljaGFuZ2UnLCB2aXNpYmlsaXR5SGFuZGxlcik7XG5cbiAgICAgICAgICAvLyBkaXNwYXRjaCBkZXN0cm95XG4gICAgICAgICAgc3RvcmUuZGlzcGF0Y2goJ0RJRF9ERVNUUk9ZJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluc2VydHMgdGhlIHBsdWdpbiBiZWZvcmUgdGhlIHRhcmdldCBlbGVtZW50XG4gICAgICAgICAqL1xuICAgICAgICBpbnNlcnRCZWZvcmU6IGZ1bmN0aW9uIGluc2VydEJlZm9yZSQxKGVsZW1lbnQpIHtcbiAgICAgICAgICByZXR1cm4gaW5zZXJ0QmVmb3JlKHZpZXcuZWxlbWVudCwgZWxlbWVudCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluc2VydHMgdGhlIHBsdWdpbiBhZnRlciB0aGUgdGFyZ2V0IGVsZW1lbnRcbiAgICAgICAgICovXG4gICAgICAgIGluc2VydEFmdGVyOiBmdW5jdGlvbiBpbnNlcnRBZnRlciQxKGVsZW1lbnQpIHtcbiAgICAgICAgICByZXR1cm4gaW5zZXJ0QWZ0ZXIodmlldy5lbGVtZW50LCBlbGVtZW50KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQXBwZW5kcyB0aGUgcGx1Z2luIHRvIHRoZSB0YXJnZXQgZWxlbWVudFxuICAgICAgICAgKi9cbiAgICAgICAgYXBwZW5kVG86IGZ1bmN0aW9uIGFwcGVuZFRvKGVsZW1lbnQpIHtcbiAgICAgICAgICByZXR1cm4gZWxlbWVudC5hcHBlbmRDaGlsZCh2aWV3LmVsZW1lbnQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXBsYWNlcyBhbiBlbGVtZW50IHdpdGggdGhlIGFwcFxuICAgICAgICAgKi9cbiAgICAgICAgcmVwbGFjZUVsZW1lbnQ6IGZ1bmN0aW9uIHJlcGxhY2VFbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgICAgICAvLyBpbnNlcnQgdGhlIGFwcCBiZWZvcmUgdGhlIGVsZW1lbnRcbiAgICAgICAgICBpbnNlcnRCZWZvcmUodmlldy5lbGVtZW50LCBlbGVtZW50KTtcblxuICAgICAgICAgIC8vIHJlbW92ZSB0aGUgb3JpZ2luYWwgZWxlbWVudFxuICAgICAgICAgIGVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbGVtZW50KTtcblxuICAgICAgICAgIC8vIHJlbWVtYmVyIG9yaWdpbmFsIGVsZW1lbnRcbiAgICAgICAgICBvcmlnaW5hbEVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXN0b3JlcyB0aGUgb3JpZ2luYWwgZWxlbWVudFxuICAgICAgICAgKi9cbiAgICAgICAgcmVzdG9yZUVsZW1lbnQ6IGZ1bmN0aW9uIHJlc3RvcmVFbGVtZW50KCkge1xuICAgICAgICAgIGlmICghb3JpZ2luYWxFbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm47IC8vIG5vIGVsZW1lbnQgdG8gcmVzdG9yZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHJlc3RvcmUgb3JpZ2luYWwgZWxlbWVudFxuICAgICAgICAgIGluc2VydEFmdGVyKG9yaWdpbmFsRWxlbWVudCwgdmlldy5lbGVtZW50KTtcblxuICAgICAgICAgIC8vIHJlbW92ZSBvdXIgZWxlbWVudFxuICAgICAgICAgIHZpZXcuZWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHZpZXcuZWxlbWVudCk7XG5cbiAgICAgICAgICAvLyByZW1vdmUgcmVmZXJlbmNlXG4gICAgICAgICAgb3JpZ2luYWxFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBhcHAgcm9vdCBpcyBhdHRhY2hlZCB0byBnaXZlbiBlbGVtZW50XG4gICAgICAgICAqIEBwYXJhbSBlbGVtZW50XG4gICAgICAgICAqL1xuICAgICAgICBpc0F0dGFjaGVkVG86IGZ1bmN0aW9uIGlzQXR0YWNoZWRUbyhlbGVtZW50KSB7XG4gICAgICAgICAgcmV0dXJuIHZpZXcuZWxlbWVudCA9PT0gZWxlbWVudCB8fCBvcmlnaW5hbEVsZW1lbnQgPT09IGVsZW1lbnQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIHJvb3QgZWxlbWVudFxuICAgICAgICAgKi9cbiAgICAgICAgZWxlbWVudDoge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHZpZXcuZWxlbWVudDtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgcG9uZCBzdGF0dXNcbiAgICAgICAgICovXG4gICAgICAgIHN0YXR1czoge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHN0b3JlLnF1ZXJ5KCdHRVRfU1RBVFVTJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgKTtcblxuICAgIC8vIERvbmUhXG4gICAgc3RvcmUuZGlzcGF0Y2goJ0RJRF9JTklUJyk7XG5cbiAgICAvLyBjcmVhdGUgYWN0dWFsIGFwaSBvYmplY3RcbiAgICByZXR1cm4gY3JlYXRlT2JqZWN0KGV4cG9ydHMpO1xuICB9O1xuXG4gIHZhciBjcmVhdGVBcHBPYmplY3QgPSBmdW5jdGlvbiBjcmVhdGVBcHBPYmplY3QoKSB7XG4gICAgdmFyIGN1c3RvbU9wdGlvbnMgPVxuICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICAvLyBkZWZhdWx0IG9wdGlvbnNcbiAgICB2YXIgZGVmYXVsdE9wdGlvbnMgPSB7fTtcbiAgICBmb3JpbihnZXRPcHRpb25zKCksIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgIGRlZmF1bHRPcHRpb25zW2tleV0gPSB2YWx1ZVswXTtcbiAgICB9KTtcblxuICAgIC8vIHNldCBhcHAgb3B0aW9uc1xuICAgIHZhciBhcHAgPSBjcmVhdGVBcHAoXG4gICAgICBPYmplY3QuYXNzaWduKFxuICAgICAgICB7fSxcblxuICAgICAgICBkZWZhdWx0T3B0aW9ucyxcbiAgICAgICAge30sXG5cbiAgICAgICAgY3VzdG9tT3B0aW9uc1xuICAgICAgKVxuICAgICk7XG5cbiAgICAvLyByZXR1cm4gdGhlIHBsdWdpbiBpbnN0YW5jZVxuICAgIHJldHVybiBhcHA7XG4gIH07XG5cbiAgdmFyIGxvd2VyQ2FzZUZpcnN0TGV0dGVyID0gZnVuY3Rpb24gbG93ZXJDYXNlRmlyc3RMZXR0ZXIoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZy5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKSArIHN0cmluZy5zbGljZSgxKTtcbiAgfTtcblxuICB2YXIgYXR0cmlidXRlTmFtZVRvUHJvcGVydHlOYW1lID0gZnVuY3Rpb24gYXR0cmlidXRlTmFtZVRvUHJvcGVydHlOYW1lKFxuICAgIGF0dHJpYnV0ZU5hbWVcbiAgKSB7XG4gICAgcmV0dXJuIHRvQ2FtZWxzKGF0dHJpYnV0ZU5hbWUucmVwbGFjZSgvXmRhdGEtLywgJycpKTtcbiAgfTtcblxuICB2YXIgbWFwT2JqZWN0ID0gZnVuY3Rpb24gbWFwT2JqZWN0KG9iamVjdCwgcHJvcGVydHlNYXApIHtcbiAgICAvLyByZW1vdmUgdW53YW50ZWRcbiAgICBmb3Jpbihwcm9wZXJ0eU1hcCwgZnVuY3Rpb24oc2VsZWN0b3IsIG1hcHBpbmcpIHtcbiAgICAgIGZvcmluKG9iamVjdCwgZnVuY3Rpb24ocHJvcGVydHksIHZhbHVlKSB7XG4gICAgICAgIC8vIGNyZWF0ZSByZWdleHAgc2hvcnRjdXRcbiAgICAgICAgdmFyIHNlbGVjdG9yUmVnRXhwID0gbmV3IFJlZ0V4cChzZWxlY3Rvcik7XG5cbiAgICAgICAgLy8gdGVzdHMgaWZcbiAgICAgICAgdmFyIG1hdGNoZXMgPSBzZWxlY3RvclJlZ0V4cC50ZXN0KHByb3BlcnR5KTtcblxuICAgICAgICAvLyBubyBtYXRjaCwgc2tpcFxuICAgICAgICBpZiAoIW1hdGNoZXMpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB0aGVyZSdzIGEgbWFwcGluZywgdGhlIG9yaWdpbmFsIHByb3BlcnR5IGlzIGFsd2F5cyByZW1vdmVkXG4gICAgICAgIGRlbGV0ZSBvYmplY3RbcHJvcGVydHldO1xuXG4gICAgICAgIC8vIHNob3VsZCBvbmx5IHJlbW92ZSwgd2UgZG9uZSFcbiAgICAgICAgaWYgKG1hcHBpbmcgPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbW92ZSB2YWx1ZSB0byBuZXcgcHJvcGVydHlcbiAgICAgICAgaWYgKGlzU3RyaW5nKG1hcHBpbmcpKSB7XG4gICAgICAgICAgb2JqZWN0W21hcHBpbmddID0gdmFsdWU7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbW92ZSB0byBncm91cFxuICAgICAgICB2YXIgZ3JvdXAgPSBtYXBwaW5nLmdyb3VwO1xuICAgICAgICBpZiAoaXNPYmplY3QobWFwcGluZykgJiYgIW9iamVjdFtncm91cF0pIHtcbiAgICAgICAgICBvYmplY3RbZ3JvdXBdID0ge307XG4gICAgICAgIH1cblxuICAgICAgICBvYmplY3RbZ3JvdXBdW1xuICAgICAgICAgIGxvd2VyQ2FzZUZpcnN0TGV0dGVyKHByb3BlcnR5LnJlcGxhY2Uoc2VsZWN0b3JSZWdFeHAsICcnKSlcbiAgICAgICAgXSA9IHZhbHVlO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIGRvIHN1Ym1hcHBpbmdcbiAgICAgIGlmIChtYXBwaW5nLm1hcHBpbmcpIHtcbiAgICAgICAgbWFwT2JqZWN0KG9iamVjdFttYXBwaW5nLmdyb3VwXSwgbWFwcGluZy5tYXBwaW5nKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICB2YXIgZ2V0QXR0cmlidXRlc0FzT2JqZWN0ID0gZnVuY3Rpb24gZ2V0QXR0cmlidXRlc0FzT2JqZWN0KG5vZGUpIHtcbiAgICB2YXIgYXR0cmlidXRlTWFwcGluZyA9XG4gICAgICBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIC8vIHR1cm4gYXR0cmlidXRlcyBpbnRvIG9iamVjdFxuICAgIHZhciBhdHRyaWJ1dGVzID0gW107XG4gICAgZm9yaW4obm9kZS5hdHRyaWJ1dGVzLCBmdW5jdGlvbihpbmRleCkge1xuICAgICAgYXR0cmlidXRlcy5wdXNoKG5vZGUuYXR0cmlidXRlc1tpbmRleF0pO1xuICAgIH0pO1xuXG4gICAgdmFyIG91dHB1dCA9IGF0dHJpYnV0ZXNcbiAgICAgIC5maWx0ZXIoZnVuY3Rpb24oYXR0cmlidXRlKSB7XG4gICAgICAgIHJldHVybiBhdHRyaWJ1dGUubmFtZTtcbiAgICAgIH0pXG4gICAgICAucmVkdWNlKGZ1bmN0aW9uKG9iaiwgYXR0cmlidXRlKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGF0dHIobm9kZSwgYXR0cmlidXRlLm5hbWUpO1xuXG4gICAgICAgIG9ialthdHRyaWJ1dGVOYW1lVG9Qcm9wZXJ0eU5hbWUoYXR0cmlidXRlLm5hbWUpXSA9XG4gICAgICAgICAgdmFsdWUgPT09IGF0dHJpYnV0ZS5uYW1lID8gdHJ1ZSA6IHZhbHVlO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgfSwge30pO1xuXG4gICAgLy8gZG8gbWFwcGluZyBvZiBvYmplY3QgcHJvcGVydGllc1xuICAgIG1hcE9iamVjdChvdXRwdXQsIGF0dHJpYnV0ZU1hcHBpbmcpO1xuXG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfTtcblxuICB2YXIgY3JlYXRlQXBwQXRFbGVtZW50ID0gZnVuY3Rpb24gY3JlYXRlQXBwQXRFbGVtZW50KGVsZW1lbnQpIHtcbiAgICB2YXIgb3B0aW9ucyA9XG4gICAgICBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgLy8gaG93IGF0dHJpYnV0ZXMgb2YgdGhlIGlucHV0IGVsZW1lbnQgYXJlIG1hcHBlZCB0byB0aGUgb3B0aW9ucyBmb3IgdGhlIHBsdWdpblxuICAgIHZhciBhdHRyaWJ1dGVNYXBwaW5nID0ge1xuICAgICAgLy8gdHJhbnNsYXRlIHRvIG90aGVyIG5hbWVcbiAgICAgICdeY2xhc3MkJzogJ2NsYXNzTmFtZScsXG4gICAgICAnXm11bHRpcGxlJCc6ICdhbGxvd011bHRpcGxlJyxcbiAgICAgICdeY2FwdHVyZSQnOiAnY2FwdHVyZU1ldGhvZCcsXG4gICAgICAnXndlYmtpdGRpcmVjdG9yeSQnOiAnYWxsb3dEaXJlY3Rvcmllc09ubHknLFxuXG4gICAgICAvLyBncm91cCB1bmRlciBzaW5nbGUgcHJvcGVydHlcbiAgICAgICdec2VydmVyJzoge1xuICAgICAgICBncm91cDogJ3NlcnZlcicsXG4gICAgICAgIG1hcHBpbmc6IHtcbiAgICAgICAgICAnXnByb2Nlc3MnOiB7XG4gICAgICAgICAgICBncm91cDogJ3Byb2Nlc3MnXG4gICAgICAgICAgfSxcblxuICAgICAgICAgICdecmV2ZXJ0Jzoge1xuICAgICAgICAgICAgZ3JvdXA6ICdyZXZlcnQnXG4gICAgICAgICAgfSxcblxuICAgICAgICAgICdeZmV0Y2gnOiB7XG4gICAgICAgICAgICBncm91cDogJ2ZldGNoJ1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICAnXnJlc3RvcmUnOiB7XG4gICAgICAgICAgICBncm91cDogJ3Jlc3RvcmUnXG4gICAgICAgICAgfSxcblxuICAgICAgICAgICdebG9hZCc6IHtcbiAgICAgICAgICAgIGdyb3VwOiAnbG9hZCdcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIC8vIGRvbid0IGluY2x1ZGUgaW4gb2JqZWN0XG4gICAgICAnXnR5cGUkJzogZmFsc2UsXG4gICAgICAnXmZpbGVzJCc6IGZhbHNlXG4gICAgfTtcblxuICAgIC8vIGFkZCBhZGRpdGlvbmFsIG9wdGlvbiB0cmFuc2xhdG9yc1xuICAgIGFwcGx5RmlsdGVycygnU0VUX0FUVFJJQlVURV9UT19PUFRJT05fTUFQJywgYXR0cmlidXRlTWFwcGluZyk7XG5cbiAgICAvLyBjcmVhdGUgZmluYWwgb3B0aW9ucyBvYmplY3QgYnkgc2V0dGluZyBvcHRpb25zIG9iamVjdCBhbmQgdGhlbiBvdmVycmlkaW5nIG9wdGlvbnMgc3VwcGxpZWQgb24gZWxlbWVudFxuICAgIHZhciBtZXJnZWRPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7XG5cbiAgICB2YXIgYXR0cmlidXRlT3B0aW9ucyA9IGdldEF0dHJpYnV0ZXNBc09iamVjdChcbiAgICAgIGVsZW1lbnQubm9kZU5hbWUgPT09ICdGSUVMRFNFVCdcbiAgICAgICAgPyBlbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ2lucHV0W3R5cGU9ZmlsZV0nKVxuICAgICAgICA6IGVsZW1lbnQsXG4gICAgICBhdHRyaWJ1dGVNYXBwaW5nXG4gICAgKTtcblxuICAgIC8vIG1lcmdlIHdpdGggb3B0aW9ucyBvYmplY3RcbiAgICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVPcHRpb25zKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgaWYgKGlzT2JqZWN0KGF0dHJpYnV0ZU9wdGlvbnNba2V5XSkpIHtcbiAgICAgICAgaWYgKCFpc09iamVjdChtZXJnZWRPcHRpb25zW2tleV0pKSB7XG4gICAgICAgICAgbWVyZ2VkT3B0aW9uc1trZXldID0ge307XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmFzc2lnbihtZXJnZWRPcHRpb25zW2tleV0sIGF0dHJpYnV0ZU9wdGlvbnNba2V5XSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtZXJnZWRPcHRpb25zW2tleV0gPSBhdHRyaWJ1dGVPcHRpb25zW2tleV07XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBpZiBwYXJlbnQgaXMgYSBmaWVsZHNldCwgZ2V0IGZpbGVzIGZyb20gcGFyZW50IGJ5IHNlbGVjdGluZyBhbGwgaW5wdXQgZmllbGRzIHRoYXQgYXJlIG5vdCBmaWxlIHVwbG9hZCBmaWVsZHNcbiAgICAvLyB0aGVzZSB3aWxsIHRoZW4gYmUgYXV0b21hdGljYWxseSBzZXQgdG8gdGhlIGluaXRpYWwgZmlsZXNcbiAgICBtZXJnZWRPcHRpb25zLmZpbGVzID0gKG9wdGlvbnMuZmlsZXMgfHwgW10pLmNvbmNhdChcbiAgICAgIEFycmF5LmZyb20oZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dDpub3QoW3R5cGU9ZmlsZV0pJykpLm1hcChcbiAgICAgICAgZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc291cmNlOiBpbnB1dC52YWx1ZSxcbiAgICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgdHlwZTogaW5wdXQuZGF0YXNldC50eXBlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgKVxuICAgICk7XG5cbiAgICAvLyBidWlsZCBwbHVnaW5cbiAgICB2YXIgYXBwID0gY3JlYXRlQXBwT2JqZWN0KG1lcmdlZE9wdGlvbnMpO1xuXG4gICAgLy8gYWRkIGFscmVhZHkgc2VsZWN0ZWQgZmlsZXNcbiAgICBpZiAoZWxlbWVudC5maWxlcykge1xuICAgICAgQXJyYXkuZnJvbShlbGVtZW50LmZpbGVzKS5mb3JFYWNoKGZ1bmN0aW9uKGZpbGUpIHtcbiAgICAgICAgYXBwLmFkZEZpbGUoZmlsZSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyByZXBsYWNlIHRoZSB0YXJnZXQgZWxlbWVudFxuICAgIGFwcC5yZXBsYWNlRWxlbWVudChlbGVtZW50KTtcblxuICAgIC8vIGV4cG9zZVxuICAgIHJldHVybiBhcHA7XG4gIH07XG5cbiAgLy8gaWYgYW4gZWxlbWVudCBpcyBwYXNzZWQsIHdlIGNyZWF0ZSB0aGUgaW5zdGFuY2UgYXQgdGhhdCBlbGVtZW50LCBpZiBub3QsIHdlIGp1c3QgY3JlYXRlIGFuIHVwIG9iamVjdFxuICB2YXIgY3JlYXRlQXBwJDEgPSBmdW5jdGlvbiBjcmVhdGVBcHAoKSB7XG4gICAgcmV0dXJuIGlzTm9kZShhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMF0pXG4gICAgICA/IGNyZWF0ZUFwcEF0RWxlbWVudC5hcHBseSh2b2lkIDAsIGFyZ3VtZW50cylcbiAgICAgIDogY3JlYXRlQXBwT2JqZWN0LmFwcGx5KHZvaWQgMCwgYXJndW1lbnRzKTtcbiAgfTtcblxuICB2YXIgUFJJVkFURV9NRVRIT0RTID0gWydmaXJlJywgJ19yZWFkJywgJ193cml0ZSddO1xuXG4gIHZhciBjcmVhdGVBcHBBUEkgPSBmdW5jdGlvbiBjcmVhdGVBcHBBUEkoYXBwKSB7XG4gICAgdmFyIGFwaSA9IHt9O1xuXG4gICAgY29weU9iamVjdFByb3BlcnRpZXNUb09iamVjdChhcHAsIGFwaSwgUFJJVkFURV9NRVRIT0RTKTtcblxuICAgIHJldHVybiBhcGk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIHBsYWNlaG9sZGVycyBpbiBnaXZlbiBzdHJpbmcgd2l0aCByZXBsYWNlbWVudHNcbiAgICogQHBhcmFtIHN0cmluZyAtIFwiRm9vIHtiYXJ9XCJcIlxuICAgKiBAcGFyYW0gcmVwbGFjZW1lbnRzIC0geyBcImJhclwiOiAxMCB9XG4gICAqL1xuICB2YXIgcmVwbGFjZUluU3RyaW5nID0gZnVuY3Rpb24gcmVwbGFjZUluU3RyaW5nKHN0cmluZywgcmVwbGFjZW1lbnRzKSB7XG4gICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC8oPzp7KFthLXpBLVpdKyl9KS9nLCBmdW5jdGlvbihtYXRjaCwgZ3JvdXApIHtcbiAgICAgIHJldHVybiByZXBsYWNlbWVudHNbZ3JvdXBdO1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciBjcmVhdGVXb3JrZXIgPSBmdW5jdGlvbiBjcmVhdGVXb3JrZXIoZm4pIHtcbiAgICB2YXIgd29ya2VyQmxvYiA9IG5ldyBCbG9iKFsnKCcsIGZuLnRvU3RyaW5nKCksICcpKCknXSwge1xuICAgICAgdHlwZTogJ2FwcGxpY2F0aW9uL2phdmFzY3JpcHQnXG4gICAgfSk7XG5cbiAgICB2YXIgd29ya2VyVVJMID0gVVJMLmNyZWF0ZU9iamVjdFVSTCh3b3JrZXJCbG9iKTtcbiAgICB2YXIgd29ya2VyID0gbmV3IFdvcmtlcih3b3JrZXJVUkwpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHRyYW5zZmVyOiBmdW5jdGlvbiB0cmFuc2ZlcihtZXNzYWdlLCBjYikge30sXG4gICAgICBwb3N0OiBmdW5jdGlvbiBwb3N0KG1lc3NhZ2UsIGNiLCB0cmFuc2Zlckxpc3QpIHtcbiAgICAgICAgdmFyIGlkID0gZ2V0VW5pcXVlSWQoKTtcblxuICAgICAgICB3b3JrZXIub25tZXNzYWdlID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgIGlmIChlLmRhdGEuaWQgPT09IGlkKSB7XG4gICAgICAgICAgICBjYihlLmRhdGEubWVzc2FnZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHdvcmtlci5wb3N0TWVzc2FnZShcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICBtZXNzYWdlOiBtZXNzYWdlXG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHRyYW5zZmVyTGlzdFxuICAgICAgICApO1xuICAgICAgfSxcbiAgICAgIHRlcm1pbmF0ZTogZnVuY3Rpb24gdGVybWluYXRlKCkge1xuICAgICAgICB3b3JrZXIudGVybWluYXRlKCk7XG4gICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwod29ya2VyVVJMKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIHZhciBsb2FkSW1hZ2UgPSBmdW5jdGlvbiBsb2FkSW1hZ2UodXJsKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIGltZyA9IG5ldyBJbWFnZSgpO1xuICAgICAgaW1nLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXNvbHZlKGltZyk7XG4gICAgICB9O1xuICAgICAgaW1nLm9uZXJyb3IgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH07XG4gICAgICBpbWcuc3JjID0gdXJsO1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciByZW5hbWVGaWxlID0gZnVuY3Rpb24gcmVuYW1lRmlsZShmaWxlLCBuYW1lKSB7XG4gICAgdmFyIHJlbmFtZWRGaWxlID0gZmlsZS5zbGljZSgwLCBmaWxlLnNpemUsIGZpbGUudHlwZSk7XG4gICAgcmVuYW1lZEZpbGUubGFzdE1vZGlmaWVkRGF0ZSA9IGZpbGUubGFzdE1vZGlmaWVkRGF0ZTtcbiAgICByZW5hbWVkRmlsZS5uYW1lID0gbmFtZTtcbiAgICByZXR1cm4gcmVuYW1lZEZpbGU7XG4gIH07XG5cbiAgdmFyIGNvcHlGaWxlID0gZnVuY3Rpb24gY29weUZpbGUoZmlsZSkge1xuICAgIHJldHVybiByZW5hbWVGaWxlKGZpbGUsIGZpbGUubmFtZSk7XG4gIH07XG5cbiAgLy8gYWxyZWFkeSByZWdpc3RlcmVkIHBsdWdpbnMgKGNhbid0IHJlZ2lzdGVyIHR3aWNlKVxuICB2YXIgcmVnaXN0ZXJlZFBsdWdpbnMgPSBbXTtcblxuICAvLyBwYXNzIHV0aWxzIHRvIHBsdWdpblxuICB2YXIgY3JlYXRlQXBwUGx1Z2luID0gZnVuY3Rpb24gY3JlYXRlQXBwUGx1Z2luKHBsdWdpbikge1xuICAgIC8vIGFscmVhZHkgcmVnaXN0ZXJlZFxuICAgIGlmIChyZWdpc3RlcmVkUGx1Z2lucy5pbmNsdWRlcyhwbHVnaW4pKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gcmVtZW1iZXIgdGhpcyBwbHVnaW5cbiAgICByZWdpc3RlcmVkUGx1Z2lucy5wdXNoKHBsdWdpbik7XG5cbiAgICAvLyBzZXR1cCFcbiAgICB2YXIgcGx1Z2luT3V0bGluZSA9IHBsdWdpbih7XG4gICAgICBhZGRGaWx0ZXI6IGFkZEZpbHRlcixcbiAgICAgIHV0aWxzOiB7XG4gICAgICAgIFR5cGU6IFR5cGUsXG4gICAgICAgIGZvcmluOiBmb3JpbixcbiAgICAgICAgaXNTdHJpbmc6IGlzU3RyaW5nLFxuICAgICAgICBpc0ZpbGU6IGlzRmlsZSxcbiAgICAgICAgdG9OYXR1cmFsRmlsZVNpemU6IHRvTmF0dXJhbEZpbGVTaXplLFxuICAgICAgICByZXBsYWNlSW5TdHJpbmc6IHJlcGxhY2VJblN0cmluZyxcbiAgICAgICAgZ2V0RXh0ZW5zaW9uRnJvbUZpbGVuYW1lOiBnZXRFeHRlbnNpb25Gcm9tRmlsZW5hbWUsXG4gICAgICAgIGdldEZpbGVuYW1lV2l0aG91dEV4dGVuc2lvbjogZ2V0RmlsZW5hbWVXaXRob3V0RXh0ZW5zaW9uLFxuICAgICAgICBndWVzc3RpbWF0ZU1pbWVUeXBlOiBndWVzc3RpbWF0ZU1pbWVUeXBlLFxuICAgICAgICBnZXRGaWxlRnJvbUJsb2I6IGdldEZpbGVGcm9tQmxvYixcbiAgICAgICAgZ2V0RmlsZW5hbWVGcm9tVVJMOiBnZXRGaWxlbmFtZUZyb21VUkwsXG4gICAgICAgIGNyZWF0ZVJvdXRlOiBjcmVhdGVSb3V0ZSxcbiAgICAgICAgY3JlYXRlV29ya2VyOiBjcmVhdGVXb3JrZXIsXG4gICAgICAgIGNyZWF0ZVZpZXc6IGNyZWF0ZVZpZXcsXG4gICAgICAgIGNyZWF0ZUl0ZW1BUEk6IGNyZWF0ZUl0ZW1BUEksXG4gICAgICAgIGxvYWRJbWFnZTogbG9hZEltYWdlLFxuICAgICAgICBjb3B5RmlsZTogY29weUZpbGUsXG4gICAgICAgIHJlbmFtZUZpbGU6IHJlbmFtZUZpbGUsXG4gICAgICAgIGNyZWF0ZUJsb2I6IGNyZWF0ZUJsb2IsXG4gICAgICAgIGFwcGx5RmlsdGVyQ2hhaW46IGFwcGx5RmlsdGVyQ2hhaW4sXG4gICAgICAgIHRleHQ6IHRleHQsXG4gICAgICAgIGdldE51bWVyaWNBc3BlY3RSYXRpb0Zyb21TdHJpbmc6IGdldE51bWVyaWNBc3BlY3RSYXRpb0Zyb21TdHJpbmdcbiAgICAgIH0sXG5cbiAgICAgIHZpZXdzOiB7XG4gICAgICAgIGZpbGVBY3Rpb25CdXR0b246IGZpbGVBY3Rpb25CdXR0b25cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIGFkZCBwbHVnaW4gb3B0aW9ucyB0byBkZWZhdWx0IG9wdGlvbnNcbiAgICBleHRlbmREZWZhdWx0T3B0aW9ucyhwbHVnaW5PdXRsaW5lLm9wdGlvbnMpO1xuICB9O1xuXG4gIC8vIGZlYXR1cmUgZGV0ZWN0aW9uIHVzZWQgYnkgc3VwcG9ydGVkKCkgbWV0aG9kXG4gIHZhciBpc09wZXJhTWluaSA9IGZ1bmN0aW9uIGlzT3BlcmFNaW5pKCkge1xuICAgIHJldHVybiAoXG4gICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwod2luZG93Lm9wZXJhbWluaSkgPT09ICdbb2JqZWN0IE9wZXJhTWluaV0nXG4gICAgKTtcbiAgfTtcbiAgdmFyIGhhc1Byb21pc2VzID0gZnVuY3Rpb24gaGFzUHJvbWlzZXMoKSB7XG4gICAgcmV0dXJuICdQcm9taXNlJyBpbiB3aW5kb3c7XG4gIH07XG4gIHZhciBoYXNCbG9iU2xpY2UgPSBmdW5jdGlvbiBoYXNCbG9iU2xpY2UoKSB7XG4gICAgcmV0dXJuICdzbGljZScgaW4gQmxvYi5wcm90b3R5cGU7XG4gIH07XG4gIHZhciBoYXNDcmVhdGVPYmplY3RVUkwgPSBmdW5jdGlvbiBoYXNDcmVhdGVPYmplY3RVUkwoKSB7XG4gICAgcmV0dXJuICdVUkwnIGluIHdpbmRvdyAmJiAnY3JlYXRlT2JqZWN0VVJMJyBpbiB3aW5kb3cuVVJMO1xuICB9O1xuICB2YXIgaGFzVmlzaWJpbGl0eSA9IGZ1bmN0aW9uIGhhc1Zpc2liaWxpdHkoKSB7XG4gICAgcmV0dXJuICd2aXNpYmlsaXR5U3RhdGUnIGluIGRvY3VtZW50O1xuICB9O1xuICB2YXIgaGFzVGltaW5nID0gZnVuY3Rpb24gaGFzVGltaW5nKCkge1xuICAgIHJldHVybiAncGVyZm9ybWFuY2UnIGluIHdpbmRvdztcbiAgfTsgLy8gaU9TIDgueFxuICB2YXIgaGFzQ1NTU3VwcG9ydHMgPSBmdW5jdGlvbiBoYXNDU1NTdXBwb3J0cygpIHtcbiAgICByZXR1cm4gJ3N1cHBvcnRzJyBpbiAod2luZG93LkNTUyB8fCB7fSk7XG4gIH07IC8vIHVzZSB0byBkZXRlY3QgU2FmYXJpIDkrXG4gIHZhciBpc0lFMTEgPSBmdW5jdGlvbiBpc0lFMTEoKSB7XG4gICAgcmV0dXJuIC9NU0lFfFRyaWRlbnQvLnRlc3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpO1xuICB9O1xuXG4gIHZhciBzdXBwb3J0ZWQgPSAoZnVuY3Rpb24oKSB7XG4gICAgLy8gUnVucyBpbW1lZGlhdGVseSBhbmQgdGhlbiByZW1lbWJlcnMgcmVzdWx0IGZvciBzdWJzZXF1ZW50IGNhbGxzXG4gICAgdmFyIGlzU3VwcG9ydGVkID1cbiAgICAgIC8vIEhhcyB0byBiZSBhIGJyb3dzZXJcbiAgICAgIGlzQnJvd3NlcigpICYmXG4gICAgICAvLyBDYW4ndCBydW4gb24gT3BlcmEgTWluaSBkdWUgdG8gbGFjayBvZiBldmVyeXRoaW5nXG4gICAgICAhaXNPcGVyYU1pbmkoKSAmJlxuICAgICAgLy8gUmVxdWlyZSB0aGVzZSBBUElzIHRvIGZlYXR1cmUgZGV0ZWN0IGEgbW9kZXJuIGJyb3dzZXJcbiAgICAgIGhhc1Zpc2liaWxpdHkoKSAmJlxuICAgICAgaGFzUHJvbWlzZXMoKSAmJlxuICAgICAgaGFzQmxvYlNsaWNlKCkgJiZcbiAgICAgIGhhc0NyZWF0ZU9iamVjdFVSTCgpICYmXG4gICAgICBoYXNUaW1pbmcoKSAmJlxuICAgICAgLy8gZG9lc24ndCBuZWVkIENTU1N1cHBvcnRzIGJ1dCBpcyBhIGdvb2Qgd2F5IHRvIGRldGVjdCBTYWZhcmkgOSsgKHdlIGRvIHdhbnQgdG8gc3VwcG9ydCBJRTExIHRob3VnaClcbiAgICAgIChoYXNDU1NTdXBwb3J0cygpIHx8IGlzSUUxMSgpKTtcblxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBpc1N1cHBvcnRlZDtcbiAgICB9O1xuICB9KSgpO1xuXG4gIC8qKlxuICAgKiBQbHVnaW4gaW50ZXJuYWwgc3RhdGUgKG92ZXIgYWxsIGluc3RhbmNlcylcbiAgICovXG4gIHZhciBzdGF0ZSA9IHtcbiAgICAvLyBhY3RpdmUgYXBwIGluc3RhbmNlcywgdXNlZCB0byByZWRyYXcgdGhlIGFwcHMgYW5kIHRvIGZpbmQgdGhlIGxhdGVyXG4gICAgYXBwczogW11cbiAgfTtcblxuICAvLyBwbHVnaW4gbmFtZVxuICB2YXIgbmFtZSA9ICdmaWxlcG9uZCc7XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBQbHVnaW4gbWV0aG9kc1xuICAgKi9cbiAgdmFyIGZuID0gZnVuY3Rpb24gZm4oKSB7fTtcbiAgZXhwb3J0cy5TdGF0dXMgPSB7fTtcbiAgZXhwb3J0cy5GaWxlU3RhdHVzID0ge307XG4gIGV4cG9ydHMuRmlsZU9yaWdpbiA9IHt9O1xuICBleHBvcnRzLk9wdGlvblR5cGVzID0ge307XG4gIGV4cG9ydHMuY3JlYXRlID0gZm47XG4gIGV4cG9ydHMuZGVzdHJveSA9IGZuO1xuICBleHBvcnRzLnBhcnNlID0gZm47XG4gIGV4cG9ydHMuZmluZCA9IGZuO1xuICBleHBvcnRzLnJlZ2lzdGVyUGx1Z2luID0gZm47XG4gIGV4cG9ydHMuZ2V0T3B0aW9ucyA9IGZuO1xuICBleHBvcnRzLnNldE9wdGlvbnMgPSBmbjtcblxuICAvLyBpZiBub3Qgc3VwcG9ydGVkLCBubyBBUElcbiAgaWYgKHN1cHBvcnRlZCgpKSB7XG4gICAgLy8gc3RhcnQgcGFpbnRlciBhbmQgZmlyZSBsb2FkIGV2ZW50XG4gICAgY3JlYXRlUGFpbnRlcihcbiAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICBzdGF0ZS5hcHBzLmZvckVhY2goZnVuY3Rpb24oYXBwKSB7XG4gICAgICAgICAgcmV0dXJuIGFwcC5fcmVhZCgpO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBmdW5jdGlvbih0cykge1xuICAgICAgICBzdGF0ZS5hcHBzLmZvckVhY2goZnVuY3Rpb24oYXBwKSB7XG4gICAgICAgICAgcmV0dXJuIGFwcC5fd3JpdGUodHMpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICApO1xuXG4gICAgLy8gZmlyZSBsb2FkZWQgZXZlbnQgc28gd2Uga25vdyB3aGVuIEZpbGVQb25kIGlzIGF2YWlsYWJsZVxuICAgIHZhciBkaXNwYXRjaCA9IGZ1bmN0aW9uIGRpc3BhdGNoKCkge1xuICAgICAgLy8gbGV0IG90aGVycyBrbm93IHdlIGhhdmUgYXJlYSByZWFkeVxuICAgICAgZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChcbiAgICAgICAgbmV3IEN1c3RvbUV2ZW50KCdGaWxlUG9uZDpsb2FkZWQnLCB7XG4gICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICBzdXBwb3J0ZWQ6IHN1cHBvcnRlZCxcbiAgICAgICAgICAgIGNyZWF0ZTogZXhwb3J0cy5jcmVhdGUsXG4gICAgICAgICAgICBkZXN0cm95OiBleHBvcnRzLmRlc3Ryb3ksXG4gICAgICAgICAgICBwYXJzZTogZXhwb3J0cy5wYXJzZSxcbiAgICAgICAgICAgIGZpbmQ6IGV4cG9ydHMuZmluZCxcbiAgICAgICAgICAgIHJlZ2lzdGVyUGx1Z2luOiBleHBvcnRzLnJlZ2lzdGVyUGx1Z2luLFxuICAgICAgICAgICAgc2V0T3B0aW9uczogZXhwb3J0cy5zZXRPcHRpb25zXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgKTtcblxuICAgICAgLy8gY2xlYW4gdXAgZXZlbnRcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBkaXNwYXRjaCk7XG4gICAgfTtcblxuICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlICE9PSAnbG9hZGluZycpIHtcbiAgICAgIC8vIG1vdmUgdG8gYmFjayBvZiBleGVjdXRpb24gcXVldWUsIEZpbGVQb25kIHNob3VsZCBoYXZlIGJlZW4gZXhwb3J0ZWQgYnkgdGhlblxuICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGRpc3BhdGNoKCk7XG4gICAgICB9LCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGRpc3BhdGNoKTtcbiAgICB9XG5cbiAgICAvLyB1cGRhdGVzIHRoZSBPcHRpb25UeXBlcyBvYmplY3QgYmFzZWQgb24gdGhlIGN1cnJlbnQgb3B0aW9uc1xuICAgIHZhciB1cGRhdGVPcHRpb25UeXBlcyA9IGZ1bmN0aW9uIHVwZGF0ZU9wdGlvblR5cGVzKCkge1xuICAgICAgcmV0dXJuIGZvcmluKGdldE9wdGlvbnMoKSwgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICBleHBvcnRzLk9wdGlvblR5cGVzW2tleV0gPSB2YWx1ZVsxXTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBleHBvcnRzLlN0YXR1cyA9IE9iamVjdC5hc3NpZ24oe30sIFN0YXR1cyk7XG4gICAgZXhwb3J0cy5GaWxlT3JpZ2luID0gT2JqZWN0LmFzc2lnbih7fSwgRmlsZU9yaWdpbik7XG4gICAgZXhwb3J0cy5GaWxlU3RhdHVzID0gT2JqZWN0LmFzc2lnbih7fSwgSXRlbVN0YXR1cyk7XG5cbiAgICBleHBvcnRzLk9wdGlvblR5cGVzID0ge307XG4gICAgdXBkYXRlT3B0aW9uVHlwZXMoKTtcblxuICAgIC8vIGNyZWF0ZSBtZXRob2QsIGNyZWF0ZXMgYXBwcyBhbmQgYWRkcyB0aGVtIHRvIHRoZSBhcHAgYXJyYXlcbiAgICBleHBvcnRzLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgICAgIHZhciBhcHAgPSBjcmVhdGVBcHAkMS5hcHBseSh2b2lkIDAsIGFyZ3VtZW50cyk7XG4gICAgICBhcHAub24oJ2Rlc3Ryb3knLCBleHBvcnRzLmRlc3Ryb3kpO1xuICAgICAgc3RhdGUuYXBwcy5wdXNoKGFwcCk7XG4gICAgICByZXR1cm4gY3JlYXRlQXBwQVBJKGFwcCk7XG4gICAgfTtcblxuICAgIC8vIGRlc3Ryb3lzIGFwcHMgYW5kIHJlbW92ZXMgdGhlbSBmcm9tIHRoZSBhcHAgYXJyYXlcbiAgICBleHBvcnRzLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KGhvb2spIHtcbiAgICAgIC8vIHJldHVybnMgdHJ1ZSBpZiB0aGUgYXBwIHdhcyBkZXN0cm95ZWQgc3VjY2Vzc2Z1bGx5XG4gICAgICB2YXIgaW5kZXhUb1JlbW92ZSA9IHN0YXRlLmFwcHMuZmluZEluZGV4KGZ1bmN0aW9uKGFwcCkge1xuICAgICAgICByZXR1cm4gYXBwLmlzQXR0YWNoZWRUbyhob29rKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKGluZGV4VG9SZW1vdmUgPj0gMCkge1xuICAgICAgICAvLyByZW1vdmUgZnJvbSBhcHBzXG4gICAgICAgIHZhciBhcHAgPSBzdGF0ZS5hcHBzLnNwbGljZShpbmRleFRvUmVtb3ZlLCAxKVswXTtcblxuICAgICAgICAvLyByZXN0b3JlIG9yaWdpbmFsIGRvbSBlbGVtZW50XG4gICAgICAgIGFwcC5yZXN0b3JlRWxlbWVudCgpO1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIC8vIHBhcnNlcyB0aGUgZ2l2ZW4gY29udGV4dCBmb3IgcGx1Z2lucyAoZG9lcyBub3QgaW5jbHVkZSB0aGUgY29udGV4dCBlbGVtZW50IGl0c2VsZilcbiAgICBleHBvcnRzLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UoY29udGV4dCkge1xuICAgICAgLy8gZ2V0IGFsbCBwb3NzaWJsZSBob29rc1xuICAgICAgdmFyIG1hdGNoZWRIb29rcyA9IEFycmF5LmZyb20oY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCcuJyArIG5hbWUpKTtcblxuICAgICAgLy8gZmlsdGVyIG91dCBhbHJlYWR5IGFjdGl2ZSBob29rc1xuICAgICAgdmFyIG5ld0hvb2tzID0gbWF0Y2hlZEhvb2tzLmZpbHRlcihmdW5jdGlvbihuZXdIb29rKSB7XG4gICAgICAgIHJldHVybiAhc3RhdGUuYXBwcy5maW5kKGZ1bmN0aW9uKGFwcCkge1xuICAgICAgICAgIHJldHVybiBhcHAuaXNBdHRhY2hlZFRvKG5ld0hvb2spO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBjcmVhdGUgbmV3IGluc3RhbmNlIGZvciBlYWNoIGhvb2tcbiAgICAgIHJldHVybiBuZXdIb29rcy5tYXAoZnVuY3Rpb24oaG9vaykge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5jcmVhdGUoaG9vayk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gcmV0dXJucyBhbiBhcHAgYmFzZWQgb24gdGhlIGdpdmVuIGVsZW1lbnQgaG9va1xuICAgIGV4cG9ydHMuZmluZCA9IGZ1bmN0aW9uIGZpbmQoaG9vaykge1xuICAgICAgdmFyIGFwcCA9IHN0YXRlLmFwcHMuZmluZChmdW5jdGlvbihhcHApIHtcbiAgICAgICAgcmV0dXJuIGFwcC5pc0F0dGFjaGVkVG8oaG9vayk7XG4gICAgICB9KTtcbiAgICAgIGlmICghYXBwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNyZWF0ZUFwcEFQSShhcHApO1xuICAgIH07XG5cbiAgICAvLyBhZGRzIGEgcGx1Z2luIGV4dGVuc2lvblxuICAgIGV4cG9ydHMucmVnaXN0ZXJQbHVnaW4gPSBmdW5jdGlvbiByZWdpc3RlclBsdWdpbigpIHtcbiAgICAgIGZvciAoXG4gICAgICAgIHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcGx1Z2lucyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7XG4gICAgICAgIF9rZXkgPCBfbGVuO1xuICAgICAgICBfa2V5KytcbiAgICAgICkge1xuICAgICAgICBwbHVnaW5zW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICAvLyByZWdpc3RlciBwbHVnaW5zXG4gICAgICBwbHVnaW5zLmZvckVhY2goY3JlYXRlQXBwUGx1Z2luKTtcblxuICAgICAgLy8gdXBkYXRlIE9wdGlvblR5cGVzLCBlYWNoIHBsdWdpbiBtaWdodCBoYXZlIGV4dGVuZGVkIHRoZSBkZWZhdWx0IG9wdGlvbnNcbiAgICAgIHVwZGF0ZU9wdGlvblR5cGVzKCk7XG4gICAgfTtcblxuICAgIGV4cG9ydHMuZ2V0T3B0aW9ucyA9IGZ1bmN0aW9uIGdldE9wdGlvbnMkMSgpIHtcbiAgICAgIHZhciBvcHRzID0ge307XG4gICAgICBmb3JpbihnZXRPcHRpb25zKCksIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgb3B0c1trZXldID0gdmFsdWVbMF07XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBvcHRzO1xuICAgIH07XG5cbiAgICBleHBvcnRzLnNldE9wdGlvbnMgPSBmdW5jdGlvbiBzZXRPcHRpb25zJDEob3B0cykge1xuICAgICAgaWYgKGlzT2JqZWN0KG9wdHMpKSB7XG4gICAgICAgIC8vIHVwZGF0ZSBleGlzdGluZyBwbHVnaW5zXG4gICAgICAgIHN0YXRlLmFwcHMuZm9yRWFjaChmdW5jdGlvbihhcHApIHtcbiAgICAgICAgICBhcHAuc2V0T3B0aW9ucyhvcHRzKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gb3ZlcnJpZGUgZGVmYXVsdHNcbiAgICAgICAgc2V0T3B0aW9ucyhvcHRzKTtcbiAgICAgIH1cblxuICAgICAgLy8gcmV0dXJuIG5ldyBvcHRpb25zXG4gICAgICByZXR1cm4gZXhwb3J0cy5nZXRPcHRpb25zKCk7XG4gICAgfTtcbiAgfVxuXG4gIGV4cG9ydHMuc3VwcG9ydGVkID0gc3VwcG9ydGVkO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG59KTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/filepond/dist/filepond.js\n");

/***/ }),

/***/ "./node_modules/filepond/dist/filepond.min.css":
/*!*****************************************************!*\
  !*** ./node_modules/filepond/dist/filepond.min.css ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\nvar content = __webpack_require__(/*! !../../css-loader??ref--10-1!../../postcss-loader/src??ref--10-2!./filepond.min.css */ \"./node_modules/css-loader/index.js?!./node_modules/postcss-loader/src/index.js?!./node_modules/filepond/dist/filepond.min.css\");\n\nif(typeof content === 'string') content = [[module.i, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = __webpack_require__(/*! ../../style-loader/lib/addStyles.js */ \"./node_modules/style-loader/lib/addStyles.js\")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(false) {}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmlsZXBvbmQvZGlzdC9maWxlcG9uZC5taW4uY3NzPzk2NzAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUNBLGNBQWMsbUJBQU8sQ0FBQywwTkFBd0c7O0FBRTlILDRDQUE0QyxRQUFTOztBQUVyRDtBQUNBOzs7O0FBSUEsZUFBZTs7QUFFZjtBQUNBOztBQUVBLGFBQWEsbUJBQU8sQ0FBQyx5RkFBc0M7O0FBRTNEOztBQUVBLEdBQUcsS0FBVSxFQUFFIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2ZpbGVwb25kL2Rpc3QvZmlsZXBvbmQubWluLmNzcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9jc3MtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTEwLTEhLi4vLi4vcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9yZWYtLTEwLTIhLi9maWxlcG9uZC5taW4uY3NzXCIpO1xuXG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcblxudmFyIHRyYW5zZm9ybTtcbnZhciBpbnNlcnRJbnRvO1xuXG5cblxudmFyIG9wdGlvbnMgPSB7XCJobXJcIjp0cnVlfVxuXG5vcHRpb25zLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVxub3B0aW9ucy5pbnNlcnRJbnRvID0gdW5kZWZpbmVkO1xuXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi8uLi9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcblxuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG5cbmlmKG1vZHVsZS5ob3QpIHtcblx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uL2Nzcy1sb2FkZXIvaW5kZXguanM/P3JlZi0tMTAtMSEuLi8uLi9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3JlZi0tMTAtMiEuL2ZpbGVwb25kLm1pbi5jc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9jc3MtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTEwLTEhLi4vLi4vcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9yZWYtLTEwLTIhLi9maWxlcG9uZC5taW4uY3NzXCIpO1xuXG5cdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cblx0XHR2YXIgbG9jYWxzID0gKGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdHZhciBrZXksIGlkeCA9IDA7XG5cblx0XHRcdGZvcihrZXkgaW4gYSkge1xuXHRcdFx0XHRpZighYiB8fCBhW2tleV0gIT09IGJba2V5XSkgcmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRpZHgrKztcblx0XHRcdH1cblxuXHRcdFx0Zm9yKGtleSBpbiBiKSBpZHgtLTtcblxuXHRcdFx0cmV0dXJuIGlkeCA9PT0gMDtcblx0XHR9KGNvbnRlbnQubG9jYWxzLCBuZXdDb250ZW50LmxvY2FscykpO1xuXG5cdFx0aWYoIWxvY2FscykgdGhyb3cgbmV3IEVycm9yKCdBYm9ydGluZyBDU1MgSE1SIGR1ZSB0byBjaGFuZ2VkIGNzcy1tb2R1bGVzIGxvY2Fscy4nKTtcblxuXHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0fSk7XG5cblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/filepond/dist/filepond.min.css\n");

/***/ }),

/***/ "./node_modules/js-beautify/js/index.js":
/*!**********************************************!*\
  !*** ./node_modules/js-beautify/js/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*jshint node:true */\n/* globals define */\n/*\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n\n*/\n\n\n\n/**\nThe following batches are equivalent:\n\nvar beautify_js = require('js-beautify');\nvar beautify_js = require('js-beautify').js;\nvar beautify_js = require('js-beautify').js_beautify;\n\nvar beautify_css = require('js-beautify').css;\nvar beautify_css = require('js-beautify').css_beautify;\n\nvar beautify_html = require('js-beautify').html;\nvar beautify_html = require('js-beautify').html_beautify;\n\nAll methods returned accept two arguments, the source string and an options object.\n**/\n\nfunction get_beautify(js_beautify, css_beautify, html_beautify) {\n  // the default is js\n  var beautify = function(src, config) {\n    return js_beautify.js_beautify(src, config);\n  };\n\n  // short aliases\n  beautify.js = js_beautify.js_beautify;\n  beautify.css = css_beautify.css_beautify;\n  beautify.html = html_beautify.html_beautify;\n\n  // legacy aliases\n  beautify.js_beautify = js_beautify.js_beautify;\n  beautify.css_beautify = css_beautify.css_beautify;\n  beautify.html_beautify = html_beautify.html_beautify;\n\n  return beautify;\n}\n\nif (true) {\n  // Add support for AMD ( https://github.com/amdjs/amdjs-api/wiki/AMD#defineamd-property- )\n  !(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n    __webpack_require__(/*! ./lib/beautify */ \"./node_modules/js-beautify/js/lib/beautify.js\"),\n    __webpack_require__(/*! ./lib/beautify-css */ \"./node_modules/js-beautify/js/lib/beautify-css.js\"),\n    __webpack_require__(/*! ./lib/beautify-html */ \"./node_modules/js-beautify/js/lib/beautify-html.js\")\n  ], __WEBPACK_AMD_DEFINE_RESULT__ = (function(js_beautify, css_beautify, html_beautify) {\n    return get_beautify(js_beautify, css_beautify, html_beautify);\n  }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n} else {}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanMtYmVhdXRpZnkvanMvaW5kZXguanM/ZTU1MiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRWE7O0FBRWI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLElBQUksSUFBMEM7QUFDOUM7QUFDQSxFQUFFLGlDQUFPO0FBQ1QsSUFBSSwwRkFBZ0I7QUFDcEIsSUFBSSxrR0FBb0I7QUFDeEIsSUFBSSxvR0FBcUI7QUFDekIsR0FBRyxtQ0FBRTtBQUNMO0FBQ0EsR0FBRztBQUFBLG9HQUFDO0FBQ0osQ0FBQyxNQUFNIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2pzLWJlYXV0aWZ5L2pzL2luZGV4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypqc2hpbnQgbm9kZTp0cnVlICovXG4vKiBnbG9iYWxzIGRlZmluZSAqL1xuLypcbiAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiAgQ29weXJpZ2h0IChjKSAyMDA3LTIwMTggRWluYXIgTGllbG1hbmlzLCBMaWFtIE5ld21hbiwgYW5kIGNvbnRyaWJ1dG9ycy5cblxuICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gIFNPRlRXQVJFLlxuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuVGhlIGZvbGxvd2luZyBiYXRjaGVzIGFyZSBlcXVpdmFsZW50OlxuXG52YXIgYmVhdXRpZnlfanMgPSByZXF1aXJlKCdqcy1iZWF1dGlmeScpO1xudmFyIGJlYXV0aWZ5X2pzID0gcmVxdWlyZSgnanMtYmVhdXRpZnknKS5qcztcbnZhciBiZWF1dGlmeV9qcyA9IHJlcXVpcmUoJ2pzLWJlYXV0aWZ5JykuanNfYmVhdXRpZnk7XG5cbnZhciBiZWF1dGlmeV9jc3MgPSByZXF1aXJlKCdqcy1iZWF1dGlmeScpLmNzcztcbnZhciBiZWF1dGlmeV9jc3MgPSByZXF1aXJlKCdqcy1iZWF1dGlmeScpLmNzc19iZWF1dGlmeTtcblxudmFyIGJlYXV0aWZ5X2h0bWwgPSByZXF1aXJlKCdqcy1iZWF1dGlmeScpLmh0bWw7XG52YXIgYmVhdXRpZnlfaHRtbCA9IHJlcXVpcmUoJ2pzLWJlYXV0aWZ5JykuaHRtbF9iZWF1dGlmeTtcblxuQWxsIG1ldGhvZHMgcmV0dXJuZWQgYWNjZXB0IHR3byBhcmd1bWVudHMsIHRoZSBzb3VyY2Ugc3RyaW5nIGFuZCBhbiBvcHRpb25zIG9iamVjdC5cbioqL1xuXG5mdW5jdGlvbiBnZXRfYmVhdXRpZnkoanNfYmVhdXRpZnksIGNzc19iZWF1dGlmeSwgaHRtbF9iZWF1dGlmeSkge1xuICAvLyB0aGUgZGVmYXVsdCBpcyBqc1xuICB2YXIgYmVhdXRpZnkgPSBmdW5jdGlvbihzcmMsIGNvbmZpZykge1xuICAgIHJldHVybiBqc19iZWF1dGlmeS5qc19iZWF1dGlmeShzcmMsIGNvbmZpZyk7XG4gIH07XG5cbiAgLy8gc2hvcnQgYWxpYXNlc1xuICBiZWF1dGlmeS5qcyA9IGpzX2JlYXV0aWZ5LmpzX2JlYXV0aWZ5O1xuICBiZWF1dGlmeS5jc3MgPSBjc3NfYmVhdXRpZnkuY3NzX2JlYXV0aWZ5O1xuICBiZWF1dGlmeS5odG1sID0gaHRtbF9iZWF1dGlmeS5odG1sX2JlYXV0aWZ5O1xuXG4gIC8vIGxlZ2FjeSBhbGlhc2VzXG4gIGJlYXV0aWZ5LmpzX2JlYXV0aWZ5ID0ganNfYmVhdXRpZnkuanNfYmVhdXRpZnk7XG4gIGJlYXV0aWZ5LmNzc19iZWF1dGlmeSA9IGNzc19iZWF1dGlmeS5jc3NfYmVhdXRpZnk7XG4gIGJlYXV0aWZ5Lmh0bWxfYmVhdXRpZnkgPSBodG1sX2JlYXV0aWZ5Lmh0bWxfYmVhdXRpZnk7XG5cbiAgcmV0dXJuIGJlYXV0aWZ5O1xufVxuXG5pZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcbiAgLy8gQWRkIHN1cHBvcnQgZm9yIEFNRCAoIGh0dHBzOi8vZ2l0aHViLmNvbS9hbWRqcy9hbWRqcy1hcGkvd2lraS9BTUQjZGVmaW5lYW1kLXByb3BlcnR5LSApXG4gIGRlZmluZShbXG4gICAgXCIuL2xpYi9iZWF1dGlmeVwiLFxuICAgIFwiLi9saWIvYmVhdXRpZnktY3NzXCIsXG4gICAgXCIuL2xpYi9iZWF1dGlmeS1odG1sXCJcbiAgXSwgZnVuY3Rpb24oanNfYmVhdXRpZnksIGNzc19iZWF1dGlmeSwgaHRtbF9iZWF1dGlmeSkge1xuICAgIHJldHVybiBnZXRfYmVhdXRpZnkoanNfYmVhdXRpZnksIGNzc19iZWF1dGlmeSwgaHRtbF9iZWF1dGlmeSk7XG4gIH0pO1xufSBlbHNlIHtcbiAgKGZ1bmN0aW9uKG1vZCkge1xuICAgIHZhciBiZWF1dGlmaWVyID0gcmVxdWlyZSgnLi9zcmMvaW5kZXgnKTtcbiAgICBiZWF1dGlmaWVyLmpzX2JlYXV0aWZ5ID0gYmVhdXRpZmllci5qcztcbiAgICBiZWF1dGlmaWVyLmNzc19iZWF1dGlmeSA9IGJlYXV0aWZpZXIuY3NzO1xuICAgIGJlYXV0aWZpZXIuaHRtbF9iZWF1dGlmeSA9IGJlYXV0aWZpZXIuaHRtbDtcblxuICAgIG1vZC5leHBvcnRzID0gZ2V0X2JlYXV0aWZ5KGJlYXV0aWZpZXIsIGJlYXV0aWZpZXIsIGJlYXV0aWZpZXIpO1xuXG4gIH0pKG1vZHVsZSk7XG59Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/js-beautify/js/index.js\n");

/***/ }),

/***/ "./node_modules/js-beautify/js/lib/beautify-css.js":
/*!*********************************************************!*\
  !*** ./node_modules/js-beautify/js/lib/beautify-css.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* AUTO-GENERATED. DO NOT MODIFY. */\n/*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n\n\n CSS Beautifier\n---------------\n\n    Written by Harutyun Amirjanyan, (amirjanyan@gmail.com)\n\n    Based on code initially developed by: Einar Lielmanis, <einar@beautifier.io>\n        https://beautifier.io/\n\n    Usage:\n        css_beautify(source_text);\n        css_beautify(source_text, options);\n\n    The options are (default in brackets):\n        indent_size (4)                         — indentation size,\n        indent_char (space)                     — character to indent with,\n        selector_separator_newline (true)       - separate selectors with newline or\n                                                  not (e.g. \"a,\\nbr\" or \"a, br\")\n        end_with_newline (false)                - end with a newline\n        newline_between_rules (true)            - add a new line after every css rule\n        space_around_selector_separator (false) - ensure space around selector separators:\n                                                  '>', '+', '~' (e.g. \"a>b\" -> \"a > b\")\n    e.g\n\n    css_beautify(css_source_text, {\n      'indent_size': 1,\n      'indent_char': '\\t',\n      'selector_separator': ' ',\n      'end_with_newline': false,\n      'newline_between_rules': true,\n      'space_around_selector_separator': true\n    });\n*/\n\n// http://www.w3.org/TR/CSS21/syndata.html#tokenization\n// http://www.w3.org/TR/css3-syntax/\n\n(function() {\n\n/* GENERATED_BUILD_OUTPUT */\nvar legacy_beautify_css =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 15);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */,\n/* 1 */,\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*jshint node:true */\n/*\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/\n\n\n\nfunction OutputLine(parent) {\n  this.__parent = parent;\n  this.__character_count = 0;\n  // use indent_count as a marker for this.__lines that have preserved indentation\n  this.__indent_count = -1;\n  this.__alignment_count = 0;\n  this.__wrap_point_index = 0;\n  this.__wrap_point_character_count = 0;\n  this.__wrap_point_indent_count = -1;\n  this.__wrap_point_alignment_count = 0;\n\n  this.__items = [];\n}\n\nOutputLine.prototype.clone_empty = function() {\n  var line = new OutputLine(this.__parent);\n  line.set_indent(this.__indent_count, this.__alignment_count);\n  return line;\n};\n\nOutputLine.prototype.item = function(index) {\n  if (index < 0) {\n    return this.__items[this.__items.length + index];\n  } else {\n    return this.__items[index];\n  }\n};\n\nOutputLine.prototype.has_match = function(pattern) {\n  for (var lastCheckedOutput = this.__items.length - 1; lastCheckedOutput >= 0; lastCheckedOutput--) {\n    if (this.__items[lastCheckedOutput].match(pattern)) {\n      return true;\n    }\n  }\n  return false;\n};\n\nOutputLine.prototype.set_indent = function(indent, alignment) {\n  if (this.is_empty()) {\n    this.__indent_count = indent || 0;\n    this.__alignment_count = alignment || 0;\n    this.__character_count = this.__parent.get_indent_size(this.__indent_count, this.__alignment_count);\n  }\n};\n\nOutputLine.prototype._set_wrap_point = function() {\n  if (this.__parent.wrap_line_length) {\n    this.__wrap_point_index = this.__items.length;\n    this.__wrap_point_character_count = this.__character_count;\n    this.__wrap_point_indent_count = this.__parent.next_line.__indent_count;\n    this.__wrap_point_alignment_count = this.__parent.next_line.__alignment_count;\n  }\n};\n\nOutputLine.prototype._should_wrap = function() {\n  return this.__wrap_point_index &&\n    this.__character_count > this.__parent.wrap_line_length &&\n    this.__wrap_point_character_count > this.__parent.next_line.__character_count;\n};\n\nOutputLine.prototype._allow_wrap = function() {\n  if (this._should_wrap()) {\n    this.__parent.add_new_line();\n    var next = this.__parent.current_line;\n    next.set_indent(this.__wrap_point_indent_count, this.__wrap_point_alignment_count);\n    next.__items = this.__items.slice(this.__wrap_point_index);\n    this.__items = this.__items.slice(0, this.__wrap_point_index);\n\n    next.__character_count += this.__character_count - this.__wrap_point_character_count;\n    this.__character_count = this.__wrap_point_character_count;\n\n    if (next.__items[0] === \" \") {\n      next.__items.splice(0, 1);\n      next.__character_count -= 1;\n    }\n    return true;\n  }\n  return false;\n};\n\nOutputLine.prototype.is_empty = function() {\n  return this.__items.length === 0;\n};\n\nOutputLine.prototype.last = function() {\n  if (!this.is_empty()) {\n    return this.__items[this.__items.length - 1];\n  } else {\n    return null;\n  }\n};\n\nOutputLine.prototype.push = function(item) {\n  this.__items.push(item);\n  var last_newline_index = item.lastIndexOf('\\n');\n  if (last_newline_index !== -1) {\n    this.__character_count = item.length - last_newline_index;\n  } else {\n    this.__character_count += item.length;\n  }\n};\n\nOutputLine.prototype.pop = function() {\n  var item = null;\n  if (!this.is_empty()) {\n    item = this.__items.pop();\n    this.__character_count -= item.length;\n  }\n  return item;\n};\n\n\nOutputLine.prototype._remove_indent = function() {\n  if (this.__indent_count > 0) {\n    this.__indent_count -= 1;\n    this.__character_count -= this.__parent.indent_size;\n  }\n};\n\nOutputLine.prototype._remove_wrap_indent = function() {\n  if (this.__wrap_point_indent_count > 0) {\n    this.__wrap_point_indent_count -= 1;\n  }\n};\nOutputLine.prototype.trim = function() {\n  while (this.last() === ' ') {\n    this.__items.pop();\n    this.__character_count -= 1;\n  }\n};\n\nOutputLine.prototype.toString = function() {\n  var result = '';\n  if (this.is_empty()) {\n    if (this.__parent.indent_empty_lines) {\n      result = this.__parent.get_indent_string(this.__indent_count);\n    }\n  } else {\n    result = this.__parent.get_indent_string(this.__indent_count, this.__alignment_count);\n    result += this.__items.join('');\n  }\n  return result;\n};\n\nfunction IndentStringCache(options, baseIndentString) {\n  this.__cache = [''];\n  this.__indent_size = options.indent_size;\n  this.__indent_string = options.indent_char;\n  if (!options.indent_with_tabs) {\n    this.__indent_string = new Array(options.indent_size + 1).join(options.indent_char);\n  }\n\n  // Set to null to continue support for auto detection of base indent\n  baseIndentString = baseIndentString || '';\n  if (options.indent_level > 0) {\n    baseIndentString = new Array(options.indent_level + 1).join(this.__indent_string);\n  }\n\n  this.__base_string = baseIndentString;\n  this.__base_string_length = baseIndentString.length;\n}\n\nIndentStringCache.prototype.get_indent_size = function(indent, column) {\n  var result = this.__base_string_length;\n  column = column || 0;\n  if (indent < 0) {\n    result = 0;\n  }\n  result += indent * this.__indent_size;\n  result += column;\n  return result;\n};\n\nIndentStringCache.prototype.get_indent_string = function(indent_level, column) {\n  var result = this.__base_string;\n  column = column || 0;\n  if (indent_level < 0) {\n    indent_level = 0;\n    result = '';\n  }\n  column += indent_level * this.__indent_size;\n  this.__ensure_cache(column);\n  result += this.__cache[column];\n  return result;\n};\n\nIndentStringCache.prototype.__ensure_cache = function(column) {\n  while (column >= this.__cache.length) {\n    this.__add_column();\n  }\n};\n\nIndentStringCache.prototype.__add_column = function() {\n  var column = this.__cache.length;\n  var indent = 0;\n  var result = '';\n  if (this.__indent_size && column >= this.__indent_size) {\n    indent = Math.floor(column / this.__indent_size);\n    column -= indent * this.__indent_size;\n    result = new Array(indent + 1).join(this.__indent_string);\n  }\n  if (column) {\n    result += new Array(column + 1).join(' ');\n  }\n\n  this.__cache.push(result);\n};\n\nfunction Output(options, baseIndentString) {\n  this.__indent_cache = new IndentStringCache(options, baseIndentString);\n  this.raw = false;\n  this._end_with_newline = options.end_with_newline;\n  this.indent_size = options.indent_size;\n  this.wrap_line_length = options.wrap_line_length;\n  this.indent_empty_lines = options.indent_empty_lines;\n  this.__lines = [];\n  this.previous_line = null;\n  this.current_line = null;\n  this.next_line = new OutputLine(this);\n  this.space_before_token = false;\n  this.non_breaking_space = false;\n  this.previous_token_wrapped = false;\n  // initialize\n  this.__add_outputline();\n}\n\nOutput.prototype.__add_outputline = function() {\n  this.previous_line = this.current_line;\n  this.current_line = this.next_line.clone_empty();\n  this.__lines.push(this.current_line);\n};\n\nOutput.prototype.get_line_number = function() {\n  return this.__lines.length;\n};\n\nOutput.prototype.get_indent_string = function(indent, column) {\n  return this.__indent_cache.get_indent_string(indent, column);\n};\n\nOutput.prototype.get_indent_size = function(indent, column) {\n  return this.__indent_cache.get_indent_size(indent, column);\n};\n\nOutput.prototype.is_empty = function() {\n  return !this.previous_line && this.current_line.is_empty();\n};\n\nOutput.prototype.add_new_line = function(force_newline) {\n  // never newline at the start of file\n  // otherwise, newline only if we didn't just add one or we're forced\n  if (this.is_empty() ||\n    (!force_newline && this.just_added_newline())) {\n    return false;\n  }\n\n  // if raw output is enabled, don't print additional newlines,\n  // but still return True as though you had\n  if (!this.raw) {\n    this.__add_outputline();\n  }\n  return true;\n};\n\nOutput.prototype.get_code = function(eol) {\n  this.trim(true);\n\n  // handle some edge cases where the last tokens\n  // has text that ends with newline(s)\n  var last_item = this.current_line.pop();\n  if (last_item) {\n    if (last_item[last_item.length - 1] === '\\n') {\n      last_item = last_item.replace(/\\n+$/g, '');\n    }\n    this.current_line.push(last_item);\n  }\n\n  if (this._end_with_newline) {\n    this.__add_outputline();\n  }\n\n  var sweet_code = this.__lines.join('\\n');\n\n  if (eol !== '\\n') {\n    sweet_code = sweet_code.replace(/[\\n]/g, eol);\n  }\n  return sweet_code;\n};\n\nOutput.prototype.set_wrap_point = function() {\n  this.current_line._set_wrap_point();\n};\n\nOutput.prototype.set_indent = function(indent, alignment) {\n  indent = indent || 0;\n  alignment = alignment || 0;\n\n  // Next line stores alignment values\n  this.next_line.set_indent(indent, alignment);\n\n  // Never indent your first output indent at the start of the file\n  if (this.__lines.length > 1) {\n    this.current_line.set_indent(indent, alignment);\n    return true;\n  }\n\n  this.current_line.set_indent();\n  return false;\n};\n\nOutput.prototype.add_raw_token = function(token) {\n  for (var x = 0; x < token.newlines; x++) {\n    this.__add_outputline();\n  }\n  this.current_line.set_indent(-1);\n  this.current_line.push(token.whitespace_before);\n  this.current_line.push(token.text);\n  this.space_before_token = false;\n  this.non_breaking_space = false;\n  this.previous_token_wrapped = false;\n};\n\nOutput.prototype.add_token = function(printable_token) {\n  this.__add_space_before_token();\n  this.current_line.push(printable_token);\n  this.space_before_token = false;\n  this.non_breaking_space = false;\n  this.previous_token_wrapped = this.current_line._allow_wrap();\n};\n\nOutput.prototype.__add_space_before_token = function() {\n  if (this.space_before_token && !this.just_added_newline()) {\n    if (!this.non_breaking_space) {\n      this.set_wrap_point();\n    }\n    this.current_line.push(' ');\n  }\n};\n\nOutput.prototype.remove_indent = function(index) {\n  var output_length = this.__lines.length;\n  while (index < output_length) {\n    this.__lines[index]._remove_indent();\n    index++;\n  }\n  this.current_line._remove_wrap_indent();\n};\n\nOutput.prototype.trim = function(eat_newlines) {\n  eat_newlines = (eat_newlines === undefined) ? false : eat_newlines;\n\n  this.current_line.trim();\n\n  while (eat_newlines && this.__lines.length > 1 &&\n    this.current_line.is_empty()) {\n    this.__lines.pop();\n    this.current_line = this.__lines[this.__lines.length - 1];\n    this.current_line.trim();\n  }\n\n  this.previous_line = this.__lines.length > 1 ?\n    this.__lines[this.__lines.length - 2] : null;\n};\n\nOutput.prototype.just_added_newline = function() {\n  return this.current_line.is_empty();\n};\n\nOutput.prototype.just_added_blankline = function() {\n  return this.is_empty() ||\n    (this.current_line.is_empty() && this.previous_line.is_empty());\n};\n\nOutput.prototype.ensure_empty_line_above = function(starts_with, ends_with) {\n  var index = this.__lines.length - 2;\n  while (index >= 0) {\n    var potentialEmptyLine = this.__lines[index];\n    if (potentialEmptyLine.is_empty()) {\n      break;\n    } else if (potentialEmptyLine.item(0).indexOf(starts_with) !== 0 &&\n      potentialEmptyLine.item(-1) !== ends_with) {\n      this.__lines.splice(index + 1, 0, new OutputLine(this));\n      this.previous_line = this.__lines[this.__lines.length - 2];\n      break;\n    }\n    index--;\n  }\n};\n\nmodule.exports.Output = Output;\n\n\n/***/ }),\n/* 3 */,\n/* 4 */,\n/* 5 */,\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*jshint node:true */\n/*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/\n\n\n\nfunction Options(options, merge_child_field) {\n  this.raw_options = _mergeOpts(options, merge_child_field);\n\n  // Support passing the source text back with no change\n  this.disabled = this._get_boolean('disabled');\n\n  this.eol = this._get_characters('eol', 'auto');\n  this.end_with_newline = this._get_boolean('end_with_newline');\n  this.indent_size = this._get_number('indent_size', 4);\n  this.indent_char = this._get_characters('indent_char', ' ');\n  this.indent_level = this._get_number('indent_level');\n\n  this.preserve_newlines = this._get_boolean('preserve_newlines', true);\n  this.max_preserve_newlines = this._get_number('max_preserve_newlines', 32786);\n  if (!this.preserve_newlines) {\n    this.max_preserve_newlines = 0;\n  }\n\n  this.indent_with_tabs = this._get_boolean('indent_with_tabs', this.indent_char === '\\t');\n  if (this.indent_with_tabs) {\n    this.indent_char = '\\t';\n\n    // indent_size behavior changed after 1.8.6\n    // It used to be that indent_size would be\n    // set to 1 for indent_with_tabs. That is no longer needed and\n    // actually doesn't make sense - why not use spaces? Further,\n    // that might produce unexpected behavior - tabs being used\n    // for single-column alignment. So, when indent_with_tabs is true\n    // and indent_size is 1, reset indent_size to 4.\n    if (this.indent_size === 1) {\n      this.indent_size = 4;\n    }\n  }\n\n  // Backwards compat with 1.3.x\n  this.wrap_line_length = this._get_number('wrap_line_length', this._get_number('max_char'));\n\n  this.indent_empty_lines = this._get_boolean('indent_empty_lines');\n\n  // valid templating languages ['django', 'erb', 'handlebars', 'php']\n  // For now, 'auto' = all off for javascript, all on for html (and inline javascript).\n  // other values ignored\n  this.templating = this._get_selection_list('templating', ['auto', 'none', 'django', 'erb', 'handlebars', 'php'], ['auto']);\n}\n\nOptions.prototype._get_array = function(name, default_value) {\n  var option_value = this.raw_options[name];\n  var result = default_value || [];\n  if (typeof option_value === 'object') {\n    if (option_value !== null && typeof option_value.concat === 'function') {\n      result = option_value.concat();\n    }\n  } else if (typeof option_value === 'string') {\n    result = option_value.split(/[^a-zA-Z0-9_\\/\\-]+/);\n  }\n  return result;\n};\n\nOptions.prototype._get_boolean = function(name, default_value) {\n  var option_value = this.raw_options[name];\n  var result = option_value === undefined ? !!default_value : !!option_value;\n  return result;\n};\n\nOptions.prototype._get_characters = function(name, default_value) {\n  var option_value = this.raw_options[name];\n  var result = default_value || '';\n  if (typeof option_value === 'string') {\n    result = option_value.replace(/\\\\r/, '\\r').replace(/\\\\n/, '\\n').replace(/\\\\t/, '\\t');\n  }\n  return result;\n};\n\nOptions.prototype._get_number = function(name, default_value) {\n  var option_value = this.raw_options[name];\n  default_value = parseInt(default_value, 10);\n  if (isNaN(default_value)) {\n    default_value = 0;\n  }\n  var result = parseInt(option_value, 10);\n  if (isNaN(result)) {\n    result = default_value;\n  }\n  return result;\n};\n\nOptions.prototype._get_selection = function(name, selection_list, default_value) {\n  var result = this._get_selection_list(name, selection_list, default_value);\n  if (result.length !== 1) {\n    throw new Error(\n      \"Invalid Option Value: The option '\" + name + \"' can only be one of the following values:\\n\" +\n      selection_list + \"\\nYou passed in: '\" + this.raw_options[name] + \"'\");\n  }\n\n  return result[0];\n};\n\n\nOptions.prototype._get_selection_list = function(name, selection_list, default_value) {\n  if (!selection_list || selection_list.length === 0) {\n    throw new Error(\"Selection list cannot be empty.\");\n  }\n\n  default_value = default_value || [selection_list[0]];\n  if (!this._is_valid_selection(default_value, selection_list)) {\n    throw new Error(\"Invalid Default Value!\");\n  }\n\n  var result = this._get_array(name, default_value);\n  if (!this._is_valid_selection(result, selection_list)) {\n    throw new Error(\n      \"Invalid Option Value: The option '\" + name + \"' can contain only the following values:\\n\" +\n      selection_list + \"\\nYou passed in: '\" + this.raw_options[name] + \"'\");\n  }\n\n  return result;\n};\n\nOptions.prototype._is_valid_selection = function(result, selection_list) {\n  return result.length && selection_list.length &&\n    !result.some(function(item) { return selection_list.indexOf(item) === -1; });\n};\n\n\n// merges child options up with the parent options object\n// Example: obj = {a: 1, b: {a: 2}}\n//          mergeOpts(obj, 'b')\n//\n//          Returns: {a: 2}\nfunction _mergeOpts(allOptions, childFieldName) {\n  var finalOpts = {};\n  allOptions = _normalizeOpts(allOptions);\n  var name;\n\n  for (name in allOptions) {\n    if (name !== childFieldName) {\n      finalOpts[name] = allOptions[name];\n    }\n  }\n\n  //merge in the per type settings for the childFieldName\n  if (childFieldName && allOptions[childFieldName]) {\n    for (name in allOptions[childFieldName]) {\n      finalOpts[name] = allOptions[childFieldName][name];\n    }\n  }\n  return finalOpts;\n}\n\nfunction _normalizeOpts(options) {\n  var convertedOpts = {};\n  var key;\n\n  for (key in options) {\n    var newKey = key.replace(/-/g, \"_\");\n    convertedOpts[newKey] = options[key];\n  }\n  return convertedOpts;\n}\n\nmodule.exports.Options = Options;\nmodule.exports.normalizeOpts = _normalizeOpts;\nmodule.exports.mergeOpts = _mergeOpts;\n\n\n/***/ }),\n/* 7 */,\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*jshint node:true */\n/*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/\n\n\n\nvar regexp_has_sticky = RegExp.prototype.hasOwnProperty('sticky');\n\nfunction InputScanner(input_string) {\n  this.__input = input_string || '';\n  this.__input_length = this.__input.length;\n  this.__position = 0;\n}\n\nInputScanner.prototype.restart = function() {\n  this.__position = 0;\n};\n\nInputScanner.prototype.back = function() {\n  if (this.__position > 0) {\n    this.__position -= 1;\n  }\n};\n\nInputScanner.prototype.hasNext = function() {\n  return this.__position < this.__input_length;\n};\n\nInputScanner.prototype.next = function() {\n  var val = null;\n  if (this.hasNext()) {\n    val = this.__input.charAt(this.__position);\n    this.__position += 1;\n  }\n  return val;\n};\n\nInputScanner.prototype.peek = function(index) {\n  var val = null;\n  index = index || 0;\n  index += this.__position;\n  if (index >= 0 && index < this.__input_length) {\n    val = this.__input.charAt(index);\n  }\n  return val;\n};\n\n// This is a JavaScript only helper function (not in python)\n// Javascript doesn't have a match method\n// and not all implementation support \"sticky\" flag.\n// If they do not support sticky then both this.match() and this.test() method\n// must get the match and check the index of the match.\n// If sticky is supported and set, this method will use it.\n// Otherwise it will check that global is set, and fall back to the slower method.\nInputScanner.prototype.__match = function(pattern, index) {\n  pattern.lastIndex = index;\n  var pattern_match = pattern.exec(this.__input);\n\n  if (pattern_match && !(regexp_has_sticky && pattern.sticky)) {\n    if (pattern_match.index !== index) {\n      pattern_match = null;\n    }\n  }\n\n  return pattern_match;\n};\n\nInputScanner.prototype.test = function(pattern, index) {\n  index = index || 0;\n  index += this.__position;\n\n  if (index >= 0 && index < this.__input_length) {\n    return !!this.__match(pattern, index);\n  } else {\n    return false;\n  }\n};\n\nInputScanner.prototype.testChar = function(pattern, index) {\n  // test one character regex match\n  var val = this.peek(index);\n  pattern.lastIndex = 0;\n  return val !== null && pattern.test(val);\n};\n\nInputScanner.prototype.match = function(pattern) {\n  var pattern_match = this.__match(pattern, this.__position);\n  if (pattern_match) {\n    this.__position += pattern_match[0].length;\n  } else {\n    pattern_match = null;\n  }\n  return pattern_match;\n};\n\nInputScanner.prototype.read = function(starting_pattern, until_pattern, until_after) {\n  var val = '';\n  var match;\n  if (starting_pattern) {\n    match = this.match(starting_pattern);\n    if (match) {\n      val += match[0];\n    }\n  }\n  if (until_pattern && (match || !starting_pattern)) {\n    val += this.readUntil(until_pattern, until_after);\n  }\n  return val;\n};\n\nInputScanner.prototype.readUntil = function(pattern, until_after) {\n  var val = '';\n  var match_index = this.__position;\n  pattern.lastIndex = this.__position;\n  var pattern_match = pattern.exec(this.__input);\n  if (pattern_match) {\n    match_index = pattern_match.index;\n    if (until_after) {\n      match_index += pattern_match[0].length;\n    }\n  } else {\n    match_index = this.__input_length;\n  }\n\n  val = this.__input.substring(this.__position, match_index);\n  this.__position = match_index;\n  return val;\n};\n\nInputScanner.prototype.readUntilAfter = function(pattern) {\n  return this.readUntil(pattern, true);\n};\n\nInputScanner.prototype.get_regexp = function(pattern, match_from) {\n  var result = null;\n  var flags = 'g';\n  if (match_from && regexp_has_sticky) {\n    flags = 'y';\n  }\n  // strings are converted to regexp\n  if (typeof pattern === \"string\" && pattern !== '') {\n    // result = new RegExp(pattern.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&'), flags);\n    result = new RegExp(pattern, flags);\n  } else if (pattern) {\n    result = new RegExp(pattern.source, flags);\n  }\n  return result;\n};\n\nInputScanner.prototype.get_literal_regexp = function(literal_string) {\n  return RegExp(literal_string.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&'));\n};\n\n/* css beautifier legacy helpers */\nInputScanner.prototype.peekUntilAfter = function(pattern) {\n  var start = this.__position;\n  var val = this.readUntilAfter(pattern);\n  this.__position = start;\n  return val;\n};\n\nInputScanner.prototype.lookBack = function(testVal) {\n  var start = this.__position - 1;\n  return start >= testVal.length && this.__input.substring(start - testVal.length, start)\n    .toLowerCase() === testVal;\n};\n\nmodule.exports.InputScanner = InputScanner;\n\n\n/***/ }),\n/* 9 */,\n/* 10 */,\n/* 11 */,\n/* 12 */,\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*jshint node:true */\n/*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/\n\n\n\nfunction Directives(start_block_pattern, end_block_pattern) {\n  start_block_pattern = typeof start_block_pattern === 'string' ? start_block_pattern : start_block_pattern.source;\n  end_block_pattern = typeof end_block_pattern === 'string' ? end_block_pattern : end_block_pattern.source;\n  this.__directives_block_pattern = new RegExp(start_block_pattern + / beautify( \\w+[:]\\w+)+ /.source + end_block_pattern, 'g');\n  this.__directive_pattern = / (\\w+)[:](\\w+)/g;\n\n  this.__directives_end_ignore_pattern = new RegExp(start_block_pattern + /\\sbeautify\\signore:end\\s/.source + end_block_pattern, 'g');\n}\n\nDirectives.prototype.get_directives = function(text) {\n  if (!text.match(this.__directives_block_pattern)) {\n    return null;\n  }\n\n  var directives = {};\n  this.__directive_pattern.lastIndex = 0;\n  var directive_match = this.__directive_pattern.exec(text);\n\n  while (directive_match) {\n    directives[directive_match[1]] = directive_match[2];\n    directive_match = this.__directive_pattern.exec(text);\n  }\n\n  return directives;\n};\n\nDirectives.prototype.readIgnored = function(input) {\n  return input.readUntilAfter(this.__directives_end_ignore_pattern);\n};\n\n\nmodule.exports.Directives = Directives;\n\n\n/***/ }),\n/* 14 */,\n/* 15 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*jshint node:true */\n/*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/\n\n\n\nvar Beautifier = __webpack_require__(16).Beautifier,\n  Options = __webpack_require__(17).Options;\n\nfunction css_beautify(source_text, options) {\n  var beautifier = new Beautifier(source_text, options);\n  return beautifier.beautify();\n}\n\nmodule.exports = css_beautify;\nmodule.exports.defaultOptions = function() {\n  return new Options();\n};\n\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*jshint node:true */\n/*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/\n\n\n\nvar Options = __webpack_require__(17).Options;\nvar Output = __webpack_require__(2).Output;\nvar InputScanner = __webpack_require__(8).InputScanner;\nvar Directives = __webpack_require__(13).Directives;\n\nvar directives_core = new Directives(/\\/\\*/, /\\*\\//);\n\nvar lineBreak = /\\r\\n|[\\r\\n]/;\nvar allLineBreaks = /\\r\\n|[\\r\\n]/g;\n\n// tokenizer\nvar whitespaceChar = /\\s/;\nvar whitespacePattern = /(?:\\s|\\n)+/g;\nvar block_comment_pattern = /\\/\\*(?:[\\s\\S]*?)((?:\\*\\/)|$)/g;\nvar comment_pattern = /\\/\\/(?:[^\\n\\r\\u2028\\u2029]*)/g;\n\nfunction Beautifier(source_text, options) {\n  this._source_text = source_text || '';\n  // Allow the setting of language/file-type specific options\n  // with inheritance of overall settings\n  this._options = new Options(options);\n  this._ch = null;\n  this._input = null;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/At-rule\n  this.NESTED_AT_RULE = {\n    \"@page\": true,\n    \"@font-face\": true,\n    \"@keyframes\": true,\n    // also in CONDITIONAL_GROUP_RULE below\n    \"@media\": true,\n    \"@supports\": true,\n    \"@document\": true\n  };\n  this.CONDITIONAL_GROUP_RULE = {\n    \"@media\": true,\n    \"@supports\": true,\n    \"@document\": true\n  };\n\n}\n\nBeautifier.prototype.eatString = function(endChars) {\n  var result = '';\n  this._ch = this._input.next();\n  while (this._ch) {\n    result += this._ch;\n    if (this._ch === \"\\\\\") {\n      result += this._input.next();\n    } else if (endChars.indexOf(this._ch) !== -1 || this._ch === \"\\n\") {\n      break;\n    }\n    this._ch = this._input.next();\n  }\n  return result;\n};\n\n// Skips any white space in the source text from the current position.\n// When allowAtLeastOneNewLine is true, will output new lines for each\n// newline character found; if the user has preserve_newlines off, only\n// the first newline will be output\nBeautifier.prototype.eatWhitespace = function(allowAtLeastOneNewLine) {\n  var result = whitespaceChar.test(this._input.peek());\n  var isFirstNewLine = true;\n\n  while (whitespaceChar.test(this._input.peek())) {\n    this._ch = this._input.next();\n    if (allowAtLeastOneNewLine && this._ch === '\\n') {\n      if (this._options.preserve_newlines || isFirstNewLine) {\n        isFirstNewLine = false;\n        this._output.add_new_line(true);\n      }\n    }\n  }\n  return result;\n};\n\n// Nested pseudo-class if we are insideRule\n// and the next special character found opens\n// a new block\nBeautifier.prototype.foundNestedPseudoClass = function() {\n  var openParen = 0;\n  var i = 1;\n  var ch = this._input.peek(i);\n  while (ch) {\n    if (ch === \"{\") {\n      return true;\n    } else if (ch === '(') {\n      // pseudoclasses can contain ()\n      openParen += 1;\n    } else if (ch === ')') {\n      if (openParen === 0) {\n        return false;\n      }\n      openParen -= 1;\n    } else if (ch === \";\" || ch === \"}\") {\n      return false;\n    }\n    i++;\n    ch = this._input.peek(i);\n  }\n  return false;\n};\n\nBeautifier.prototype.print_string = function(output_string) {\n  this._output.set_indent(this._indentLevel);\n  this._output.non_breaking_space = true;\n  this._output.add_token(output_string);\n};\n\nBeautifier.prototype.preserveSingleSpace = function(isAfterSpace) {\n  if (isAfterSpace) {\n    this._output.space_before_token = true;\n  }\n};\n\nBeautifier.prototype.indent = function() {\n  this._indentLevel++;\n};\n\nBeautifier.prototype.outdent = function() {\n  if (this._indentLevel > 0) {\n    this._indentLevel--;\n  }\n};\n\n/*_____________________--------------------_____________________*/\n\nBeautifier.prototype.beautify = function() {\n  if (this._options.disabled) {\n    return this._source_text;\n  }\n\n  var source_text = this._source_text;\n  var eol = this._options.eol;\n  if (eol === 'auto') {\n    eol = '\\n';\n    if (source_text && lineBreak.test(source_text || '')) {\n      eol = source_text.match(lineBreak)[0];\n    }\n  }\n\n\n  // HACK: newline parsing inconsistent. This brute force normalizes the this._input.\n  source_text = source_text.replace(allLineBreaks, '\\n');\n\n  // reset\n  var baseIndentString = source_text.match(/^[\\t ]*/)[0];\n\n  this._output = new Output(this._options, baseIndentString);\n  this._input = new InputScanner(source_text);\n  this._indentLevel = 0;\n  this._nestedLevel = 0;\n\n  this._ch = null;\n  var parenLevel = 0;\n\n  var insideRule = false;\n  // This is the value side of a property value pair (blue in the following ex)\n  // label { content: blue }\n  var insidePropertyValue = false;\n  var enteringConditionalGroup = false;\n  var insideAtExtend = false;\n  var insideAtImport = false;\n  var topCharacter = this._ch;\n  var whitespace;\n  var isAfterSpace;\n  var previous_ch;\n\n  while (true) {\n    whitespace = this._input.read(whitespacePattern);\n    isAfterSpace = whitespace !== '';\n    previous_ch = topCharacter;\n    this._ch = this._input.next();\n    if (this._ch === '\\\\' && this._input.hasNext()) {\n      this._ch += this._input.next();\n    }\n    topCharacter = this._ch;\n\n    if (!this._ch) {\n      break;\n    } else if (this._ch === '/' && this._input.peek() === '*') {\n      // /* css comment */\n      // Always start block comments on a new line.\n      // This handles scenarios where a block comment immediately\n      // follows a property definition on the same line or where\n      // minified code is being beautified.\n      this._output.add_new_line();\n      this._input.back();\n\n      var comment = this._input.read(block_comment_pattern);\n\n      // Handle ignore directive\n      var directives = directives_core.get_directives(comment);\n      if (directives && directives.ignore === 'start') {\n        comment += directives_core.readIgnored(this._input);\n      }\n\n      this.print_string(comment);\n\n      // Ensures any new lines following the comment are preserved\n      this.eatWhitespace(true);\n\n      // Block comments are followed by a new line so they don't\n      // share a line with other properties\n      this._output.add_new_line();\n    } else if (this._ch === '/' && this._input.peek() === '/') {\n      // // single line comment\n      // Preserves the space before a comment\n      // on the same line as a rule\n      this._output.space_before_token = true;\n      this._input.back();\n      this.print_string(this._input.read(comment_pattern));\n\n      // Ensures any new lines following the comment are preserved\n      this.eatWhitespace(true);\n    } else if (this._ch === '@') {\n      this.preserveSingleSpace(isAfterSpace);\n\n      // deal with less propery mixins @{...}\n      if (this._input.peek() === '{') {\n        this.print_string(this._ch + this.eatString('}'));\n      } else {\n        this.print_string(this._ch);\n\n        // strip trailing space, if present, for hash property checks\n        var variableOrRule = this._input.peekUntilAfter(/[: ,;{}()[\\]\\/='\"]/g);\n\n        if (variableOrRule.match(/[ :]$/)) {\n          // we have a variable or pseudo-class, add it and insert one space before continuing\n          variableOrRule = this.eatString(\": \").replace(/\\s$/, '');\n          this.print_string(variableOrRule);\n          this._output.space_before_token = true;\n        }\n\n        variableOrRule = variableOrRule.replace(/\\s$/, '');\n\n        if (variableOrRule === 'extend') {\n          insideAtExtend = true;\n        } else if (variableOrRule === 'import') {\n          insideAtImport = true;\n        }\n\n        // might be a nesting at-rule\n        if (variableOrRule in this.NESTED_AT_RULE) {\n          this._nestedLevel += 1;\n          if (variableOrRule in this.CONDITIONAL_GROUP_RULE) {\n            enteringConditionalGroup = true;\n          }\n          // might be less variable\n        } else if (!insideRule && parenLevel === 0 && variableOrRule.indexOf(':') !== -1) {\n          insidePropertyValue = true;\n          this.indent();\n        }\n      }\n    } else if (this._ch === '#' && this._input.peek() === '{') {\n      this.preserveSingleSpace(isAfterSpace);\n      this.print_string(this._ch + this.eatString('}'));\n    } else if (this._ch === '{') {\n      if (insidePropertyValue) {\n        insidePropertyValue = false;\n        this.outdent();\n      }\n\n      // when entering conditional groups, only rulesets are allowed\n      if (enteringConditionalGroup) {\n        enteringConditionalGroup = false;\n        insideRule = (this._indentLevel >= this._nestedLevel);\n      } else {\n        // otherwise, declarations are also allowed\n        insideRule = (this._indentLevel >= this._nestedLevel - 1);\n      }\n      if (this._options.newline_between_rules && insideRule) {\n        if (this._output.previous_line && this._output.previous_line.item(-1) !== '{') {\n          this._output.ensure_empty_line_above('/', ',');\n        }\n      }\n\n      this._output.space_before_token = true;\n\n      // The difference in print_string and indent order is necessary to indent the '{' correctly\n      if (this._options.brace_style === 'expand') {\n        this._output.add_new_line();\n        this.print_string(this._ch);\n        this.indent();\n        this._output.set_indent(this._indentLevel);\n      } else {\n        this.indent();\n        this.print_string(this._ch);\n      }\n\n      this.eatWhitespace(true);\n      this._output.add_new_line();\n    } else if (this._ch === '}') {\n      this.outdent();\n      this._output.add_new_line();\n      if (previous_ch === '{') {\n        this._output.trim(true);\n      }\n      insideAtImport = false;\n      insideAtExtend = false;\n      if (insidePropertyValue) {\n        this.outdent();\n        insidePropertyValue = false;\n      }\n      this.print_string(this._ch);\n      insideRule = false;\n      if (this._nestedLevel) {\n        this._nestedLevel--;\n      }\n\n      this.eatWhitespace(true);\n      this._output.add_new_line();\n\n      if (this._options.newline_between_rules && !this._output.just_added_blankline()) {\n        if (this._input.peek() !== '}') {\n          this._output.add_new_line(true);\n        }\n      }\n    } else if (this._ch === \":\") {\n      if ((insideRule || enteringConditionalGroup) && !(this._input.lookBack(\"&\") || this.foundNestedPseudoClass()) && !this._input.lookBack(\"(\") && !insideAtExtend && parenLevel === 0) {\n        // 'property: value' delimiter\n        // which could be in a conditional group query\n        this.print_string(':');\n        if (!insidePropertyValue) {\n          insidePropertyValue = true;\n          this._output.space_before_token = true;\n          this.eatWhitespace(true);\n          this.indent();\n        }\n      } else {\n        // sass/less parent reference don't use a space\n        // sass nested pseudo-class don't use a space\n\n        // preserve space before pseudoclasses/pseudoelements, as it means \"in any child\"\n        if (this._input.lookBack(\" \")) {\n          this._output.space_before_token = true;\n        }\n        if (this._input.peek() === \":\") {\n          // pseudo-element\n          this._ch = this._input.next();\n          this.print_string(\"::\");\n        } else {\n          // pseudo-class\n          this.print_string(':');\n        }\n      }\n    } else if (this._ch === '\"' || this._ch === '\\'') {\n      this.preserveSingleSpace(isAfterSpace);\n      this.print_string(this._ch + this.eatString(this._ch));\n      this.eatWhitespace(true);\n    } else if (this._ch === ';') {\n      if (parenLevel === 0) {\n        if (insidePropertyValue) {\n          this.outdent();\n          insidePropertyValue = false;\n        }\n        insideAtExtend = false;\n        insideAtImport = false;\n        this.print_string(this._ch);\n        this.eatWhitespace(true);\n\n        // This maintains single line comments on the same\n        // line. Block comments are also affected, but\n        // a new line is always output before one inside\n        // that section\n        if (this._input.peek() !== '/') {\n          this._output.add_new_line();\n        }\n      } else {\n        this.print_string(this._ch);\n        this.eatWhitespace(true);\n        this._output.space_before_token = true;\n      }\n    } else if (this._ch === '(') { // may be a url\n      if (this._input.lookBack(\"url\")) {\n        this.print_string(this._ch);\n        this.eatWhitespace();\n        parenLevel++;\n        this.indent();\n        this._ch = this._input.next();\n        if (this._ch === ')' || this._ch === '\"' || this._ch === '\\'') {\n          this._input.back();\n        } else if (this._ch) {\n          this.print_string(this._ch + this.eatString(')'));\n          if (parenLevel) {\n            parenLevel--;\n            this.outdent();\n          }\n        }\n      } else {\n        this.preserveSingleSpace(isAfterSpace);\n        this.print_string(this._ch);\n        this.eatWhitespace();\n        parenLevel++;\n        this.indent();\n      }\n    } else if (this._ch === ')') {\n      if (parenLevel) {\n        parenLevel--;\n        this.outdent();\n      }\n      this.print_string(this._ch);\n    } else if (this._ch === ',') {\n      this.print_string(this._ch);\n      this.eatWhitespace(true);\n      if (this._options.selector_separator_newline && !insidePropertyValue && parenLevel === 0 && !insideAtImport) {\n        this._output.add_new_line();\n      } else {\n        this._output.space_before_token = true;\n      }\n    } else if ((this._ch === '>' || this._ch === '+' || this._ch === '~') && !insidePropertyValue && parenLevel === 0) {\n      //handle combinator spacing\n      if (this._options.space_around_combinator) {\n        this._output.space_before_token = true;\n        this.print_string(this._ch);\n        this._output.space_before_token = true;\n      } else {\n        this.print_string(this._ch);\n        this.eatWhitespace();\n        // squash extra whitespace\n        if (this._ch && whitespaceChar.test(this._ch)) {\n          this._ch = '';\n        }\n      }\n    } else if (this._ch === ']') {\n      this.print_string(this._ch);\n    } else if (this._ch === '[') {\n      this.preserveSingleSpace(isAfterSpace);\n      this.print_string(this._ch);\n    } else if (this._ch === '=') { // no whitespace before or after\n      this.eatWhitespace();\n      this.print_string('=');\n      if (whitespaceChar.test(this._ch)) {\n        this._ch = '';\n      }\n    } else if (this._ch === '!' && !this._input.lookBack(\"\\\\\")) { // !important\n      this.print_string(' ');\n      this.print_string(this._ch);\n    } else {\n      this.preserveSingleSpace(isAfterSpace);\n      this.print_string(this._ch);\n    }\n  }\n\n  var sweetCode = this._output.get_code(eol);\n\n  return sweetCode;\n};\n\nmodule.exports.Beautifier = Beautifier;\n\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*jshint node:true */\n/*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/\n\n\n\nvar BaseOptions = __webpack_require__(6).Options;\n\nfunction Options(options) {\n  BaseOptions.call(this, options, 'css');\n\n  this.selector_separator_newline = this._get_boolean('selector_separator_newline', true);\n  this.newline_between_rules = this._get_boolean('newline_between_rules', true);\n  var space_around_selector_separator = this._get_boolean('space_around_selector_separator');\n  this.space_around_combinator = this._get_boolean('space_around_combinator') || space_around_selector_separator;\n\n  var brace_style_split = this._get_selection_list('brace_style', ['collapse', 'expand', 'end-expand', 'none', 'preserve-inline']);\n  this.brace_style = 'collapse';\n  for (var bs = 0; bs < brace_style_split.length; bs++) {\n    if (brace_style_split[bs] !== 'expand') {\n      // default to collapse, as only collapse|expand is implemented for now\n      this.brace_style = 'collapse';\n    } else {\n      this.brace_style = brace_style_split[bs];\n    }\n  }\n}\nOptions.prototype = new BaseOptions();\n\n\n\nmodule.exports.Options = Options;\n\n\n/***/ })\n/******/ ]);\nvar css_beautify = legacy_beautify_css;\n/* Footer */\nif (true) {\n    // Add support for AMD ( https://github.com/amdjs/amdjs-api/wiki/AMD#defineamd-property- )\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n        return {\n            css_beautify: css_beautify\n        };\n    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n} else {}\n\n}());\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanMtYmVhdXRpZnkvanMvbGliL2JlYXV0aWZ5LWNzcy5qcz80ZDdjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxnQ0FBZ0M7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLGtCQUFrQjtBQUNsRjtBQUNBLHlEQUF5RCxjQUFjO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGlDQUFpQztBQUNsRix3SEFBd0gsbUJBQW1CLEVBQUU7QUFDN0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDBCQUEwQixFQUFFO0FBQy9ELHlDQUF5QyxlQUFlO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsK0RBQStEO0FBQzdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdURBQXVELHdCQUF3QjtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixvQkFBb0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQ0FBaUMsNENBQTRDLEVBQUU7QUFDL0U7OztBQUdBO0FBQ0EsbUJBQW1CLFVBQVU7QUFDN0I7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNERBQTREO0FBQzVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7OztBQUdBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssbUJBQW1CLGNBQWM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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RSxtQ0FBRTtBQUNmO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFBQSxvR0FBQztBQUNOLENBQUMsTUFBTSxFQVVOOztBQUVELENBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvanMtYmVhdXRpZnkvanMvbGliL2JlYXV0aWZ5LWNzcy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIEFVVE8tR0VORVJBVEVELiBETyBOT1QgTU9ESUZZLiAqL1xuLypcblxuICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxOCBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgU09GVFdBUkUuXG5cblxuIENTUyBCZWF1dGlmaWVyXG4tLS0tLS0tLS0tLS0tLS1cblxuICAgIFdyaXR0ZW4gYnkgSGFydXR5dW4gQW1pcmphbnlhbiwgKGFtaXJqYW55YW5AZ21haWwuY29tKVxuXG4gICAgQmFzZWQgb24gY29kZSBpbml0aWFsbHkgZGV2ZWxvcGVkIGJ5OiBFaW5hciBMaWVsbWFuaXMsIDxlaW5hckBiZWF1dGlmaWVyLmlvPlxuICAgICAgICBodHRwczovL2JlYXV0aWZpZXIuaW8vXG5cbiAgICBVc2FnZTpcbiAgICAgICAgY3NzX2JlYXV0aWZ5KHNvdXJjZV90ZXh0KTtcbiAgICAgICAgY3NzX2JlYXV0aWZ5KHNvdXJjZV90ZXh0LCBvcHRpb25zKTtcblxuICAgIFRoZSBvcHRpb25zIGFyZSAoZGVmYXVsdCBpbiBicmFja2V0cyk6XG4gICAgICAgIGluZGVudF9zaXplICg0KSAgICAgICAgICAgICAgICAgICAgICAgICDigJQgaW5kZW50YXRpb24gc2l6ZSxcbiAgICAgICAgaW5kZW50X2NoYXIgKHNwYWNlKSAgICAgICAgICAgICAgICAgICAgIOKAlCBjaGFyYWN0ZXIgdG8gaW5kZW50IHdpdGgsXG4gICAgICAgIHNlbGVjdG9yX3NlcGFyYXRvcl9uZXdsaW5lICh0cnVlKSAgICAgICAtIHNlcGFyYXRlIHNlbGVjdG9ycyB3aXRoIG5ld2xpbmUgb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm90IChlLmcuIFwiYSxcXG5iclwiIG9yIFwiYSwgYnJcIilcbiAgICAgICAgZW5kX3dpdGhfbmV3bGluZSAoZmFsc2UpICAgICAgICAgICAgICAgIC0gZW5kIHdpdGggYSBuZXdsaW5lXG4gICAgICAgIG5ld2xpbmVfYmV0d2Vlbl9ydWxlcyAodHJ1ZSkgICAgICAgICAgICAtIGFkZCBhIG5ldyBsaW5lIGFmdGVyIGV2ZXJ5IGNzcyBydWxlXG4gICAgICAgIHNwYWNlX2Fyb3VuZF9zZWxlY3Rvcl9zZXBhcmF0b3IgKGZhbHNlKSAtIGVuc3VyZSBzcGFjZSBhcm91bmQgc2VsZWN0b3Igc2VwYXJhdG9yczpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJz4nLCAnKycsICd+JyAoZS5nLiBcImE+YlwiIC0+IFwiYSA+IGJcIilcbiAgICBlLmdcblxuICAgIGNzc19iZWF1dGlmeShjc3Nfc291cmNlX3RleHQsIHtcbiAgICAgICdpbmRlbnRfc2l6ZSc6IDEsXG4gICAgICAnaW5kZW50X2NoYXInOiAnXFx0JyxcbiAgICAgICdzZWxlY3Rvcl9zZXBhcmF0b3InOiAnICcsXG4gICAgICAnZW5kX3dpdGhfbmV3bGluZSc6IGZhbHNlLFxuICAgICAgJ25ld2xpbmVfYmV0d2Vlbl9ydWxlcyc6IHRydWUsXG4gICAgICAnc3BhY2VfYXJvdW5kX3NlbGVjdG9yX3NlcGFyYXRvcic6IHRydWVcbiAgICB9KTtcbiovXG5cbi8vIGh0dHA6Ly93d3cudzMub3JnL1RSL0NTUzIxL3N5bmRhdGEuaHRtbCN0b2tlbml6YXRpb25cbi8vIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtc3ludGF4L1xuXG4oZnVuY3Rpb24oKSB7XG5cbi8qIEdFTkVSQVRFRF9CVUlMRF9PVVRQVVQgKi9cbnZhciBsZWdhY3lfYmVhdXRpZnlfY3NzID1cbi8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0aTogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubCA9IHRydWU7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4vKioqKioqLyBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4vKioqKioqLyBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuLyoqKioqKi8gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4vKioqKioqLyBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuLyoqKioqKi8gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbi8qKioqKiovIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuLyoqKioqKi8gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbi8qKioqKiovIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuLyoqKioqKi8gXHRcdHJldHVybiBucztcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuLyoqKioqKi8gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuLyoqKioqKi8gXHRcdHJldHVybiBnZXR0ZXI7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gMTUpO1xuLyoqKioqKi8gfSlcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAoW1xuLyogMCAqLyxcbi8qIDEgKi8sXG4vKiAyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLypqc2hpbnQgbm9kZTp0cnVlICovXG4vKlxuICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxOCBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgU09GVFdBUkUuXG4qL1xuXG5cblxuZnVuY3Rpb24gT3V0cHV0TGluZShwYXJlbnQpIHtcbiAgdGhpcy5fX3BhcmVudCA9IHBhcmVudDtcbiAgdGhpcy5fX2NoYXJhY3Rlcl9jb3VudCA9IDA7XG4gIC8vIHVzZSBpbmRlbnRfY291bnQgYXMgYSBtYXJrZXIgZm9yIHRoaXMuX19saW5lcyB0aGF0IGhhdmUgcHJlc2VydmVkIGluZGVudGF0aW9uXG4gIHRoaXMuX19pbmRlbnRfY291bnQgPSAtMTtcbiAgdGhpcy5fX2FsaWdubWVudF9jb3VudCA9IDA7XG4gIHRoaXMuX193cmFwX3BvaW50X2luZGV4ID0gMDtcbiAgdGhpcy5fX3dyYXBfcG9pbnRfY2hhcmFjdGVyX2NvdW50ID0gMDtcbiAgdGhpcy5fX3dyYXBfcG9pbnRfaW5kZW50X2NvdW50ID0gLTE7XG4gIHRoaXMuX193cmFwX3BvaW50X2FsaWdubWVudF9jb3VudCA9IDA7XG5cbiAgdGhpcy5fX2l0ZW1zID0gW107XG59XG5cbk91dHB1dExpbmUucHJvdG90eXBlLmNsb25lX2VtcHR5ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBsaW5lID0gbmV3IE91dHB1dExpbmUodGhpcy5fX3BhcmVudCk7XG4gIGxpbmUuc2V0X2luZGVudCh0aGlzLl9faW5kZW50X2NvdW50LCB0aGlzLl9fYWxpZ25tZW50X2NvdW50KTtcbiAgcmV0dXJuIGxpbmU7XG59O1xuXG5PdXRwdXRMaW5lLnByb3RvdHlwZS5pdGVtID0gZnVuY3Rpb24oaW5kZXgpIHtcbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybiB0aGlzLl9faXRlbXNbdGhpcy5fX2l0ZW1zLmxlbmd0aCArIGluZGV4XTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdGhpcy5fX2l0ZW1zW2luZGV4XTtcbiAgfVxufTtcblxuT3V0cHV0TGluZS5wcm90b3R5cGUuaGFzX21hdGNoID0gZnVuY3Rpb24ocGF0dGVybikge1xuICBmb3IgKHZhciBsYXN0Q2hlY2tlZE91dHB1dCA9IHRoaXMuX19pdGVtcy5sZW5ndGggLSAxOyBsYXN0Q2hlY2tlZE91dHB1dCA+PSAwOyBsYXN0Q2hlY2tlZE91dHB1dC0tKSB7XG4gICAgaWYgKHRoaXMuX19pdGVtc1tsYXN0Q2hlY2tlZE91dHB1dF0ubWF0Y2gocGF0dGVybikpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5PdXRwdXRMaW5lLnByb3RvdHlwZS5zZXRfaW5kZW50ID0gZnVuY3Rpb24oaW5kZW50LCBhbGlnbm1lbnQpIHtcbiAgaWYgKHRoaXMuaXNfZW1wdHkoKSkge1xuICAgIHRoaXMuX19pbmRlbnRfY291bnQgPSBpbmRlbnQgfHwgMDtcbiAgICB0aGlzLl9fYWxpZ25tZW50X2NvdW50ID0gYWxpZ25tZW50IHx8IDA7XG4gICAgdGhpcy5fX2NoYXJhY3Rlcl9jb3VudCA9IHRoaXMuX19wYXJlbnQuZ2V0X2luZGVudF9zaXplKHRoaXMuX19pbmRlbnRfY291bnQsIHRoaXMuX19hbGlnbm1lbnRfY291bnQpO1xuICB9XG59O1xuXG5PdXRwdXRMaW5lLnByb3RvdHlwZS5fc2V0X3dyYXBfcG9pbnQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuX19wYXJlbnQud3JhcF9saW5lX2xlbmd0aCkge1xuICAgIHRoaXMuX193cmFwX3BvaW50X2luZGV4ID0gdGhpcy5fX2l0ZW1zLmxlbmd0aDtcbiAgICB0aGlzLl9fd3JhcF9wb2ludF9jaGFyYWN0ZXJfY291bnQgPSB0aGlzLl9fY2hhcmFjdGVyX2NvdW50O1xuICAgIHRoaXMuX193cmFwX3BvaW50X2luZGVudF9jb3VudCA9IHRoaXMuX19wYXJlbnQubmV4dF9saW5lLl9faW5kZW50X2NvdW50O1xuICAgIHRoaXMuX193cmFwX3BvaW50X2FsaWdubWVudF9jb3VudCA9IHRoaXMuX19wYXJlbnQubmV4dF9saW5lLl9fYWxpZ25tZW50X2NvdW50O1xuICB9XG59O1xuXG5PdXRwdXRMaW5lLnByb3RvdHlwZS5fc2hvdWxkX3dyYXAgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX193cmFwX3BvaW50X2luZGV4ICYmXG4gICAgdGhpcy5fX2NoYXJhY3Rlcl9jb3VudCA+IHRoaXMuX19wYXJlbnQud3JhcF9saW5lX2xlbmd0aCAmJlxuICAgIHRoaXMuX193cmFwX3BvaW50X2NoYXJhY3Rlcl9jb3VudCA+IHRoaXMuX19wYXJlbnQubmV4dF9saW5lLl9fY2hhcmFjdGVyX2NvdW50O1xufTtcblxuT3V0cHV0TGluZS5wcm90b3R5cGUuX2FsbG93X3dyYXAgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuX3Nob3VsZF93cmFwKCkpIHtcbiAgICB0aGlzLl9fcGFyZW50LmFkZF9uZXdfbGluZSgpO1xuICAgIHZhciBuZXh0ID0gdGhpcy5fX3BhcmVudC5jdXJyZW50X2xpbmU7XG4gICAgbmV4dC5zZXRfaW5kZW50KHRoaXMuX193cmFwX3BvaW50X2luZGVudF9jb3VudCwgdGhpcy5fX3dyYXBfcG9pbnRfYWxpZ25tZW50X2NvdW50KTtcbiAgICBuZXh0Ll9faXRlbXMgPSB0aGlzLl9faXRlbXMuc2xpY2UodGhpcy5fX3dyYXBfcG9pbnRfaW5kZXgpO1xuICAgIHRoaXMuX19pdGVtcyA9IHRoaXMuX19pdGVtcy5zbGljZSgwLCB0aGlzLl9fd3JhcF9wb2ludF9pbmRleCk7XG5cbiAgICBuZXh0Ll9fY2hhcmFjdGVyX2NvdW50ICs9IHRoaXMuX19jaGFyYWN0ZXJfY291bnQgLSB0aGlzLl9fd3JhcF9wb2ludF9jaGFyYWN0ZXJfY291bnQ7XG4gICAgdGhpcy5fX2NoYXJhY3Rlcl9jb3VudCA9IHRoaXMuX193cmFwX3BvaW50X2NoYXJhY3Rlcl9jb3VudDtcblxuICAgIGlmIChuZXh0Ll9faXRlbXNbMF0gPT09IFwiIFwiKSB7XG4gICAgICBuZXh0Ll9faXRlbXMuc3BsaWNlKDAsIDEpO1xuICAgICAgbmV4dC5fX2NoYXJhY3Rlcl9jb3VudCAtPSAxO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5PdXRwdXRMaW5lLnByb3RvdHlwZS5pc19lbXB0eSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fX2l0ZW1zLmxlbmd0aCA9PT0gMDtcbn07XG5cbk91dHB1dExpbmUucHJvdG90eXBlLmxhc3QgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLmlzX2VtcHR5KCkpIHtcbiAgICByZXR1cm4gdGhpcy5fX2l0ZW1zW3RoaXMuX19pdGVtcy5sZW5ndGggLSAxXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufTtcblxuT3V0cHV0TGluZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgdGhpcy5fX2l0ZW1zLnB1c2goaXRlbSk7XG4gIHZhciBsYXN0X25ld2xpbmVfaW5kZXggPSBpdGVtLmxhc3RJbmRleE9mKCdcXG4nKTtcbiAgaWYgKGxhc3RfbmV3bGluZV9pbmRleCAhPT0gLTEpIHtcbiAgICB0aGlzLl9fY2hhcmFjdGVyX2NvdW50ID0gaXRlbS5sZW5ndGggLSBsYXN0X25ld2xpbmVfaW5kZXg7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fX2NoYXJhY3Rlcl9jb3VudCArPSBpdGVtLmxlbmd0aDtcbiAgfVxufTtcblxuT3V0cHV0TGluZS5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24oKSB7XG4gIHZhciBpdGVtID0gbnVsbDtcbiAgaWYgKCF0aGlzLmlzX2VtcHR5KCkpIHtcbiAgICBpdGVtID0gdGhpcy5fX2l0ZW1zLnBvcCgpO1xuICAgIHRoaXMuX19jaGFyYWN0ZXJfY291bnQgLT0gaXRlbS5sZW5ndGg7XG4gIH1cbiAgcmV0dXJuIGl0ZW07XG59O1xuXG5cbk91dHB1dExpbmUucHJvdG90eXBlLl9yZW1vdmVfaW5kZW50ID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLl9faW5kZW50X2NvdW50ID4gMCkge1xuICAgIHRoaXMuX19pbmRlbnRfY291bnQgLT0gMTtcbiAgICB0aGlzLl9fY2hhcmFjdGVyX2NvdW50IC09IHRoaXMuX19wYXJlbnQuaW5kZW50X3NpemU7XG4gIH1cbn07XG5cbk91dHB1dExpbmUucHJvdG90eXBlLl9yZW1vdmVfd3JhcF9pbmRlbnQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuX193cmFwX3BvaW50X2luZGVudF9jb3VudCA+IDApIHtcbiAgICB0aGlzLl9fd3JhcF9wb2ludF9pbmRlbnRfY291bnQgLT0gMTtcbiAgfVxufTtcbk91dHB1dExpbmUucHJvdG90eXBlLnRyaW0gPSBmdW5jdGlvbigpIHtcbiAgd2hpbGUgKHRoaXMubGFzdCgpID09PSAnICcpIHtcbiAgICB0aGlzLl9faXRlbXMucG9wKCk7XG4gICAgdGhpcy5fX2NoYXJhY3Rlcl9jb3VudCAtPSAxO1xuICB9XG59O1xuXG5PdXRwdXRMaW5lLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcmVzdWx0ID0gJyc7XG4gIGlmICh0aGlzLmlzX2VtcHR5KCkpIHtcbiAgICBpZiAodGhpcy5fX3BhcmVudC5pbmRlbnRfZW1wdHlfbGluZXMpIHtcbiAgICAgIHJlc3VsdCA9IHRoaXMuX19wYXJlbnQuZ2V0X2luZGVudF9zdHJpbmcodGhpcy5fX2luZGVudF9jb3VudCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJlc3VsdCA9IHRoaXMuX19wYXJlbnQuZ2V0X2luZGVudF9zdHJpbmcodGhpcy5fX2luZGVudF9jb3VudCwgdGhpcy5fX2FsaWdubWVudF9jb3VudCk7XG4gICAgcmVzdWx0ICs9IHRoaXMuX19pdGVtcy5qb2luKCcnKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuZnVuY3Rpb24gSW5kZW50U3RyaW5nQ2FjaGUob3B0aW9ucywgYmFzZUluZGVudFN0cmluZykge1xuICB0aGlzLl9fY2FjaGUgPSBbJyddO1xuICB0aGlzLl9faW5kZW50X3NpemUgPSBvcHRpb25zLmluZGVudF9zaXplO1xuICB0aGlzLl9faW5kZW50X3N0cmluZyA9IG9wdGlvbnMuaW5kZW50X2NoYXI7XG4gIGlmICghb3B0aW9ucy5pbmRlbnRfd2l0aF90YWJzKSB7XG4gICAgdGhpcy5fX2luZGVudF9zdHJpbmcgPSBuZXcgQXJyYXkob3B0aW9ucy5pbmRlbnRfc2l6ZSArIDEpLmpvaW4ob3B0aW9ucy5pbmRlbnRfY2hhcik7XG4gIH1cblxuICAvLyBTZXQgdG8gbnVsbCB0byBjb250aW51ZSBzdXBwb3J0IGZvciBhdXRvIGRldGVjdGlvbiBvZiBiYXNlIGluZGVudFxuICBiYXNlSW5kZW50U3RyaW5nID0gYmFzZUluZGVudFN0cmluZyB8fCAnJztcbiAgaWYgKG9wdGlvbnMuaW5kZW50X2xldmVsID4gMCkge1xuICAgIGJhc2VJbmRlbnRTdHJpbmcgPSBuZXcgQXJyYXkob3B0aW9ucy5pbmRlbnRfbGV2ZWwgKyAxKS5qb2luKHRoaXMuX19pbmRlbnRfc3RyaW5nKTtcbiAgfVxuXG4gIHRoaXMuX19iYXNlX3N0cmluZyA9IGJhc2VJbmRlbnRTdHJpbmc7XG4gIHRoaXMuX19iYXNlX3N0cmluZ19sZW5ndGggPSBiYXNlSW5kZW50U3RyaW5nLmxlbmd0aDtcbn1cblxuSW5kZW50U3RyaW5nQ2FjaGUucHJvdG90eXBlLmdldF9pbmRlbnRfc2l6ZSA9IGZ1bmN0aW9uKGluZGVudCwgY29sdW1uKSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLl9fYmFzZV9zdHJpbmdfbGVuZ3RoO1xuICBjb2x1bW4gPSBjb2x1bW4gfHwgMDtcbiAgaWYgKGluZGVudCA8IDApIHtcbiAgICByZXN1bHQgPSAwO1xuICB9XG4gIHJlc3VsdCArPSBpbmRlbnQgKiB0aGlzLl9faW5kZW50X3NpemU7XG4gIHJlc3VsdCArPSBjb2x1bW47XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5JbmRlbnRTdHJpbmdDYWNoZS5wcm90b3R5cGUuZ2V0X2luZGVudF9zdHJpbmcgPSBmdW5jdGlvbihpbmRlbnRfbGV2ZWwsIGNvbHVtbikge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5fX2Jhc2Vfc3RyaW5nO1xuICBjb2x1bW4gPSBjb2x1bW4gfHwgMDtcbiAgaWYgKGluZGVudF9sZXZlbCA8IDApIHtcbiAgICBpbmRlbnRfbGV2ZWwgPSAwO1xuICAgIHJlc3VsdCA9ICcnO1xuICB9XG4gIGNvbHVtbiArPSBpbmRlbnRfbGV2ZWwgKiB0aGlzLl9faW5kZW50X3NpemU7XG4gIHRoaXMuX19lbnN1cmVfY2FjaGUoY29sdW1uKTtcbiAgcmVzdWx0ICs9IHRoaXMuX19jYWNoZVtjb2x1bW5dO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuSW5kZW50U3RyaW5nQ2FjaGUucHJvdG90eXBlLl9fZW5zdXJlX2NhY2hlID0gZnVuY3Rpb24oY29sdW1uKSB7XG4gIHdoaWxlIChjb2x1bW4gPj0gdGhpcy5fX2NhY2hlLmxlbmd0aCkge1xuICAgIHRoaXMuX19hZGRfY29sdW1uKCk7XG4gIH1cbn07XG5cbkluZGVudFN0cmluZ0NhY2hlLnByb3RvdHlwZS5fX2FkZF9jb2x1bW4gPSBmdW5jdGlvbigpIHtcbiAgdmFyIGNvbHVtbiA9IHRoaXMuX19jYWNoZS5sZW5ndGg7XG4gIHZhciBpbmRlbnQgPSAwO1xuICB2YXIgcmVzdWx0ID0gJyc7XG4gIGlmICh0aGlzLl9faW5kZW50X3NpemUgJiYgY29sdW1uID49IHRoaXMuX19pbmRlbnRfc2l6ZSkge1xuICAgIGluZGVudCA9IE1hdGguZmxvb3IoY29sdW1uIC8gdGhpcy5fX2luZGVudF9zaXplKTtcbiAgICBjb2x1bW4gLT0gaW5kZW50ICogdGhpcy5fX2luZGVudF9zaXplO1xuICAgIHJlc3VsdCA9IG5ldyBBcnJheShpbmRlbnQgKyAxKS5qb2luKHRoaXMuX19pbmRlbnRfc3RyaW5nKTtcbiAgfVxuICBpZiAoY29sdW1uKSB7XG4gICAgcmVzdWx0ICs9IG5ldyBBcnJheShjb2x1bW4gKyAxKS5qb2luKCcgJyk7XG4gIH1cblxuICB0aGlzLl9fY2FjaGUucHVzaChyZXN1bHQpO1xufTtcblxuZnVuY3Rpb24gT3V0cHV0KG9wdGlvbnMsIGJhc2VJbmRlbnRTdHJpbmcpIHtcbiAgdGhpcy5fX2luZGVudF9jYWNoZSA9IG5ldyBJbmRlbnRTdHJpbmdDYWNoZShvcHRpb25zLCBiYXNlSW5kZW50U3RyaW5nKTtcbiAgdGhpcy5yYXcgPSBmYWxzZTtcbiAgdGhpcy5fZW5kX3dpdGhfbmV3bGluZSA9IG9wdGlvbnMuZW5kX3dpdGhfbmV3bGluZTtcbiAgdGhpcy5pbmRlbnRfc2l6ZSA9IG9wdGlvbnMuaW5kZW50X3NpemU7XG4gIHRoaXMud3JhcF9saW5lX2xlbmd0aCA9IG9wdGlvbnMud3JhcF9saW5lX2xlbmd0aDtcbiAgdGhpcy5pbmRlbnRfZW1wdHlfbGluZXMgPSBvcHRpb25zLmluZGVudF9lbXB0eV9saW5lcztcbiAgdGhpcy5fX2xpbmVzID0gW107XG4gIHRoaXMucHJldmlvdXNfbGluZSA9IG51bGw7XG4gIHRoaXMuY3VycmVudF9saW5lID0gbnVsbDtcbiAgdGhpcy5uZXh0X2xpbmUgPSBuZXcgT3V0cHV0TGluZSh0aGlzKTtcbiAgdGhpcy5zcGFjZV9iZWZvcmVfdG9rZW4gPSBmYWxzZTtcbiAgdGhpcy5ub25fYnJlYWtpbmdfc3BhY2UgPSBmYWxzZTtcbiAgdGhpcy5wcmV2aW91c190b2tlbl93cmFwcGVkID0gZmFsc2U7XG4gIC8vIGluaXRpYWxpemVcbiAgdGhpcy5fX2FkZF9vdXRwdXRsaW5lKCk7XG59XG5cbk91dHB1dC5wcm90b3R5cGUuX19hZGRfb3V0cHV0bGluZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnByZXZpb3VzX2xpbmUgPSB0aGlzLmN1cnJlbnRfbGluZTtcbiAgdGhpcy5jdXJyZW50X2xpbmUgPSB0aGlzLm5leHRfbGluZS5jbG9uZV9lbXB0eSgpO1xuICB0aGlzLl9fbGluZXMucHVzaCh0aGlzLmN1cnJlbnRfbGluZSk7XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLmdldF9saW5lX251bWJlciA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fX2xpbmVzLmxlbmd0aDtcbn07XG5cbk91dHB1dC5wcm90b3R5cGUuZ2V0X2luZGVudF9zdHJpbmcgPSBmdW5jdGlvbihpbmRlbnQsIGNvbHVtbikge1xuICByZXR1cm4gdGhpcy5fX2luZGVudF9jYWNoZS5nZXRfaW5kZW50X3N0cmluZyhpbmRlbnQsIGNvbHVtbik7XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLmdldF9pbmRlbnRfc2l6ZSA9IGZ1bmN0aW9uKGluZGVudCwgY29sdW1uKSB7XG4gIHJldHVybiB0aGlzLl9faW5kZW50X2NhY2hlLmdldF9pbmRlbnRfc2l6ZShpbmRlbnQsIGNvbHVtbik7XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLmlzX2VtcHR5ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAhdGhpcy5wcmV2aW91c19saW5lICYmIHRoaXMuY3VycmVudF9saW5lLmlzX2VtcHR5KCk7XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLmFkZF9uZXdfbGluZSA9IGZ1bmN0aW9uKGZvcmNlX25ld2xpbmUpIHtcbiAgLy8gbmV2ZXIgbmV3bGluZSBhdCB0aGUgc3RhcnQgb2YgZmlsZVxuICAvLyBvdGhlcndpc2UsIG5ld2xpbmUgb25seSBpZiB3ZSBkaWRuJ3QganVzdCBhZGQgb25lIG9yIHdlJ3JlIGZvcmNlZFxuICBpZiAodGhpcy5pc19lbXB0eSgpIHx8XG4gICAgKCFmb3JjZV9uZXdsaW5lICYmIHRoaXMuanVzdF9hZGRlZF9uZXdsaW5lKCkpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gaWYgcmF3IG91dHB1dCBpcyBlbmFibGVkLCBkb24ndCBwcmludCBhZGRpdGlvbmFsIG5ld2xpbmVzLFxuICAvLyBidXQgc3RpbGwgcmV0dXJuIFRydWUgYXMgdGhvdWdoIHlvdSBoYWRcbiAgaWYgKCF0aGlzLnJhdykge1xuICAgIHRoaXMuX19hZGRfb3V0cHV0bGluZSgpO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuT3V0cHV0LnByb3RvdHlwZS5nZXRfY29kZSA9IGZ1bmN0aW9uKGVvbCkge1xuICB0aGlzLnRyaW0odHJ1ZSk7XG5cbiAgLy8gaGFuZGxlIHNvbWUgZWRnZSBjYXNlcyB3aGVyZSB0aGUgbGFzdCB0b2tlbnNcbiAgLy8gaGFzIHRleHQgdGhhdCBlbmRzIHdpdGggbmV3bGluZShzKVxuICB2YXIgbGFzdF9pdGVtID0gdGhpcy5jdXJyZW50X2xpbmUucG9wKCk7XG4gIGlmIChsYXN0X2l0ZW0pIHtcbiAgICBpZiAobGFzdF9pdGVtW2xhc3RfaXRlbS5sZW5ndGggLSAxXSA9PT0gJ1xcbicpIHtcbiAgICAgIGxhc3RfaXRlbSA9IGxhc3RfaXRlbS5yZXBsYWNlKC9cXG4rJC9nLCAnJyk7XG4gICAgfVxuICAgIHRoaXMuY3VycmVudF9saW5lLnB1c2gobGFzdF9pdGVtKTtcbiAgfVxuXG4gIGlmICh0aGlzLl9lbmRfd2l0aF9uZXdsaW5lKSB7XG4gICAgdGhpcy5fX2FkZF9vdXRwdXRsaW5lKCk7XG4gIH1cblxuICB2YXIgc3dlZXRfY29kZSA9IHRoaXMuX19saW5lcy5qb2luKCdcXG4nKTtcblxuICBpZiAoZW9sICE9PSAnXFxuJykge1xuICAgIHN3ZWV0X2NvZGUgPSBzd2VldF9jb2RlLnJlcGxhY2UoL1tcXG5dL2csIGVvbCk7XG4gIH1cbiAgcmV0dXJuIHN3ZWV0X2NvZGU7XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLnNldF93cmFwX3BvaW50ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuY3VycmVudF9saW5lLl9zZXRfd3JhcF9wb2ludCgpO1xufTtcblxuT3V0cHV0LnByb3RvdHlwZS5zZXRfaW5kZW50ID0gZnVuY3Rpb24oaW5kZW50LCBhbGlnbm1lbnQpIHtcbiAgaW5kZW50ID0gaW5kZW50IHx8IDA7XG4gIGFsaWdubWVudCA9IGFsaWdubWVudCB8fCAwO1xuXG4gIC8vIE5leHQgbGluZSBzdG9yZXMgYWxpZ25tZW50IHZhbHVlc1xuICB0aGlzLm5leHRfbGluZS5zZXRfaW5kZW50KGluZGVudCwgYWxpZ25tZW50KTtcblxuICAvLyBOZXZlciBpbmRlbnQgeW91ciBmaXJzdCBvdXRwdXQgaW5kZW50IGF0IHRoZSBzdGFydCBvZiB0aGUgZmlsZVxuICBpZiAodGhpcy5fX2xpbmVzLmxlbmd0aCA+IDEpIHtcbiAgICB0aGlzLmN1cnJlbnRfbGluZS5zZXRfaW5kZW50KGluZGVudCwgYWxpZ25tZW50KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHRoaXMuY3VycmVudF9saW5lLnNldF9pbmRlbnQoKTtcbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuT3V0cHV0LnByb3RvdHlwZS5hZGRfcmF3X3Rva2VuID0gZnVuY3Rpb24odG9rZW4pIHtcbiAgZm9yICh2YXIgeCA9IDA7IHggPCB0b2tlbi5uZXdsaW5lczsgeCsrKSB7XG4gICAgdGhpcy5fX2FkZF9vdXRwdXRsaW5lKCk7XG4gIH1cbiAgdGhpcy5jdXJyZW50X2xpbmUuc2V0X2luZGVudCgtMSk7XG4gIHRoaXMuY3VycmVudF9saW5lLnB1c2godG9rZW4ud2hpdGVzcGFjZV9iZWZvcmUpO1xuICB0aGlzLmN1cnJlbnRfbGluZS5wdXNoKHRva2VuLnRleHQpO1xuICB0aGlzLnNwYWNlX2JlZm9yZV90b2tlbiA9IGZhbHNlO1xuICB0aGlzLm5vbl9icmVha2luZ19zcGFjZSA9IGZhbHNlO1xuICB0aGlzLnByZXZpb3VzX3Rva2VuX3dyYXBwZWQgPSBmYWxzZTtcbn07XG5cbk91dHB1dC5wcm90b3R5cGUuYWRkX3Rva2VuID0gZnVuY3Rpb24ocHJpbnRhYmxlX3Rva2VuKSB7XG4gIHRoaXMuX19hZGRfc3BhY2VfYmVmb3JlX3Rva2VuKCk7XG4gIHRoaXMuY3VycmVudF9saW5lLnB1c2gocHJpbnRhYmxlX3Rva2VuKTtcbiAgdGhpcy5zcGFjZV9iZWZvcmVfdG9rZW4gPSBmYWxzZTtcbiAgdGhpcy5ub25fYnJlYWtpbmdfc3BhY2UgPSBmYWxzZTtcbiAgdGhpcy5wcmV2aW91c190b2tlbl93cmFwcGVkID0gdGhpcy5jdXJyZW50X2xpbmUuX2FsbG93X3dyYXAoKTtcbn07XG5cbk91dHB1dC5wcm90b3R5cGUuX19hZGRfc3BhY2VfYmVmb3JlX3Rva2VuID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLnNwYWNlX2JlZm9yZV90b2tlbiAmJiAhdGhpcy5qdXN0X2FkZGVkX25ld2xpbmUoKSkge1xuICAgIGlmICghdGhpcy5ub25fYnJlYWtpbmdfc3BhY2UpIHtcbiAgICAgIHRoaXMuc2V0X3dyYXBfcG9pbnQoKTtcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50X2xpbmUucHVzaCgnICcpO1xuICB9XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLnJlbW92ZV9pbmRlbnQgPSBmdW5jdGlvbihpbmRleCkge1xuICB2YXIgb3V0cHV0X2xlbmd0aCA9IHRoaXMuX19saW5lcy5sZW5ndGg7XG4gIHdoaWxlIChpbmRleCA8IG91dHB1dF9sZW5ndGgpIHtcbiAgICB0aGlzLl9fbGluZXNbaW5kZXhdLl9yZW1vdmVfaW5kZW50KCk7XG4gICAgaW5kZXgrKztcbiAgfVxuICB0aGlzLmN1cnJlbnRfbGluZS5fcmVtb3ZlX3dyYXBfaW5kZW50KCk7XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLnRyaW0gPSBmdW5jdGlvbihlYXRfbmV3bGluZXMpIHtcbiAgZWF0X25ld2xpbmVzID0gKGVhdF9uZXdsaW5lcyA9PT0gdW5kZWZpbmVkKSA/IGZhbHNlIDogZWF0X25ld2xpbmVzO1xuXG4gIHRoaXMuY3VycmVudF9saW5lLnRyaW0oKTtcblxuICB3aGlsZSAoZWF0X25ld2xpbmVzICYmIHRoaXMuX19saW5lcy5sZW5ndGggPiAxICYmXG4gICAgdGhpcy5jdXJyZW50X2xpbmUuaXNfZW1wdHkoKSkge1xuICAgIHRoaXMuX19saW5lcy5wb3AoKTtcbiAgICB0aGlzLmN1cnJlbnRfbGluZSA9IHRoaXMuX19saW5lc1t0aGlzLl9fbGluZXMubGVuZ3RoIC0gMV07XG4gICAgdGhpcy5jdXJyZW50X2xpbmUudHJpbSgpO1xuICB9XG5cbiAgdGhpcy5wcmV2aW91c19saW5lID0gdGhpcy5fX2xpbmVzLmxlbmd0aCA+IDEgP1xuICAgIHRoaXMuX19saW5lc1t0aGlzLl9fbGluZXMubGVuZ3RoIC0gMl0gOiBudWxsO1xufTtcblxuT3V0cHV0LnByb3RvdHlwZS5qdXN0X2FkZGVkX25ld2xpbmUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuY3VycmVudF9saW5lLmlzX2VtcHR5KCk7XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLmp1c3RfYWRkZWRfYmxhbmtsaW5lID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmlzX2VtcHR5KCkgfHxcbiAgICAodGhpcy5jdXJyZW50X2xpbmUuaXNfZW1wdHkoKSAmJiB0aGlzLnByZXZpb3VzX2xpbmUuaXNfZW1wdHkoKSk7XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLmVuc3VyZV9lbXB0eV9saW5lX2Fib3ZlID0gZnVuY3Rpb24oc3RhcnRzX3dpdGgsIGVuZHNfd2l0aCkge1xuICB2YXIgaW5kZXggPSB0aGlzLl9fbGluZXMubGVuZ3RoIC0gMjtcbiAgd2hpbGUgKGluZGV4ID49IDApIHtcbiAgICB2YXIgcG90ZW50aWFsRW1wdHlMaW5lID0gdGhpcy5fX2xpbmVzW2luZGV4XTtcbiAgICBpZiAocG90ZW50aWFsRW1wdHlMaW5lLmlzX2VtcHR5KCkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSBpZiAocG90ZW50aWFsRW1wdHlMaW5lLml0ZW0oMCkuaW5kZXhPZihzdGFydHNfd2l0aCkgIT09IDAgJiZcbiAgICAgIHBvdGVudGlhbEVtcHR5TGluZS5pdGVtKC0xKSAhPT0gZW5kc193aXRoKSB7XG4gICAgICB0aGlzLl9fbGluZXMuc3BsaWNlKGluZGV4ICsgMSwgMCwgbmV3IE91dHB1dExpbmUodGhpcykpO1xuICAgICAgdGhpcy5wcmV2aW91c19saW5lID0gdGhpcy5fX2xpbmVzW3RoaXMuX19saW5lcy5sZW5ndGggLSAyXTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpbmRleC0tO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5PdXRwdXQgPSBPdXRwdXQ7XG5cblxuLyoqKi8gfSksXG4vKiAzICovLFxuLyogNCAqLyxcbi8qIDUgKi8sXG4vKiA2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLypqc2hpbnQgbm9kZTp0cnVlICovXG4vKlxuXG4gIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4gIENvcHlyaWdodCAoYykgMjAwNy0yMDE4IEVpbmFyIExpZWxtYW5pcywgTGlhbSBOZXdtYW4sIGFuZCBjb250cmlidXRvcnMuXG5cbiAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICBTT0ZUV0FSRS5cbiovXG5cblxuXG5mdW5jdGlvbiBPcHRpb25zKG9wdGlvbnMsIG1lcmdlX2NoaWxkX2ZpZWxkKSB7XG4gIHRoaXMucmF3X29wdGlvbnMgPSBfbWVyZ2VPcHRzKG9wdGlvbnMsIG1lcmdlX2NoaWxkX2ZpZWxkKTtcblxuICAvLyBTdXBwb3J0IHBhc3NpbmcgdGhlIHNvdXJjZSB0ZXh0IGJhY2sgd2l0aCBubyBjaGFuZ2VcbiAgdGhpcy5kaXNhYmxlZCA9IHRoaXMuX2dldF9ib29sZWFuKCdkaXNhYmxlZCcpO1xuXG4gIHRoaXMuZW9sID0gdGhpcy5fZ2V0X2NoYXJhY3RlcnMoJ2VvbCcsICdhdXRvJyk7XG4gIHRoaXMuZW5kX3dpdGhfbmV3bGluZSA9IHRoaXMuX2dldF9ib29sZWFuKCdlbmRfd2l0aF9uZXdsaW5lJyk7XG4gIHRoaXMuaW5kZW50X3NpemUgPSB0aGlzLl9nZXRfbnVtYmVyKCdpbmRlbnRfc2l6ZScsIDQpO1xuICB0aGlzLmluZGVudF9jaGFyID0gdGhpcy5fZ2V0X2NoYXJhY3RlcnMoJ2luZGVudF9jaGFyJywgJyAnKTtcbiAgdGhpcy5pbmRlbnRfbGV2ZWwgPSB0aGlzLl9nZXRfbnVtYmVyKCdpbmRlbnRfbGV2ZWwnKTtcblxuICB0aGlzLnByZXNlcnZlX25ld2xpbmVzID0gdGhpcy5fZ2V0X2Jvb2xlYW4oJ3ByZXNlcnZlX25ld2xpbmVzJywgdHJ1ZSk7XG4gIHRoaXMubWF4X3ByZXNlcnZlX25ld2xpbmVzID0gdGhpcy5fZ2V0X251bWJlcignbWF4X3ByZXNlcnZlX25ld2xpbmVzJywgMzI3ODYpO1xuICBpZiAoIXRoaXMucHJlc2VydmVfbmV3bGluZXMpIHtcbiAgICB0aGlzLm1heF9wcmVzZXJ2ZV9uZXdsaW5lcyA9IDA7XG4gIH1cblxuICB0aGlzLmluZGVudF93aXRoX3RhYnMgPSB0aGlzLl9nZXRfYm9vbGVhbignaW5kZW50X3dpdGhfdGFicycsIHRoaXMuaW5kZW50X2NoYXIgPT09ICdcXHQnKTtcbiAgaWYgKHRoaXMuaW5kZW50X3dpdGhfdGFicykge1xuICAgIHRoaXMuaW5kZW50X2NoYXIgPSAnXFx0JztcblxuICAgIC8vIGluZGVudF9zaXplIGJlaGF2aW9yIGNoYW5nZWQgYWZ0ZXIgMS44LjZcbiAgICAvLyBJdCB1c2VkIHRvIGJlIHRoYXQgaW5kZW50X3NpemUgd291bGQgYmVcbiAgICAvLyBzZXQgdG8gMSBmb3IgaW5kZW50X3dpdGhfdGFicy4gVGhhdCBpcyBubyBsb25nZXIgbmVlZGVkIGFuZFxuICAgIC8vIGFjdHVhbGx5IGRvZXNuJ3QgbWFrZSBzZW5zZSAtIHdoeSBub3QgdXNlIHNwYWNlcz8gRnVydGhlcixcbiAgICAvLyB0aGF0IG1pZ2h0IHByb2R1Y2UgdW5leHBlY3RlZCBiZWhhdmlvciAtIHRhYnMgYmVpbmcgdXNlZFxuICAgIC8vIGZvciBzaW5nbGUtY29sdW1uIGFsaWdubWVudC4gU28sIHdoZW4gaW5kZW50X3dpdGhfdGFicyBpcyB0cnVlXG4gICAgLy8gYW5kIGluZGVudF9zaXplIGlzIDEsIHJlc2V0IGluZGVudF9zaXplIHRvIDQuXG4gICAgaWYgKHRoaXMuaW5kZW50X3NpemUgPT09IDEpIHtcbiAgICAgIHRoaXMuaW5kZW50X3NpemUgPSA0O1xuICAgIH1cbiAgfVxuXG4gIC8vIEJhY2t3YXJkcyBjb21wYXQgd2l0aCAxLjMueFxuICB0aGlzLndyYXBfbGluZV9sZW5ndGggPSB0aGlzLl9nZXRfbnVtYmVyKCd3cmFwX2xpbmVfbGVuZ3RoJywgdGhpcy5fZ2V0X251bWJlcignbWF4X2NoYXInKSk7XG5cbiAgdGhpcy5pbmRlbnRfZW1wdHlfbGluZXMgPSB0aGlzLl9nZXRfYm9vbGVhbignaW5kZW50X2VtcHR5X2xpbmVzJyk7XG5cbiAgLy8gdmFsaWQgdGVtcGxhdGluZyBsYW5ndWFnZXMgWydkamFuZ28nLCAnZXJiJywgJ2hhbmRsZWJhcnMnLCAncGhwJ11cbiAgLy8gRm9yIG5vdywgJ2F1dG8nID0gYWxsIG9mZiBmb3IgamF2YXNjcmlwdCwgYWxsIG9uIGZvciBodG1sIChhbmQgaW5saW5lIGphdmFzY3JpcHQpLlxuICAvLyBvdGhlciB2YWx1ZXMgaWdub3JlZFxuICB0aGlzLnRlbXBsYXRpbmcgPSB0aGlzLl9nZXRfc2VsZWN0aW9uX2xpc3QoJ3RlbXBsYXRpbmcnLCBbJ2F1dG8nLCAnbm9uZScsICdkamFuZ28nLCAnZXJiJywgJ2hhbmRsZWJhcnMnLCAncGhwJ10sIFsnYXV0byddKTtcbn1cblxuT3B0aW9ucy5wcm90b3R5cGUuX2dldF9hcnJheSA9IGZ1bmN0aW9uKG5hbWUsIGRlZmF1bHRfdmFsdWUpIHtcbiAgdmFyIG9wdGlvbl92YWx1ZSA9IHRoaXMucmF3X29wdGlvbnNbbmFtZV07XG4gIHZhciByZXN1bHQgPSBkZWZhdWx0X3ZhbHVlIHx8IFtdO1xuICBpZiAodHlwZW9mIG9wdGlvbl92YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICBpZiAob3B0aW9uX3ZhbHVlICE9PSBudWxsICYmIHR5cGVvZiBvcHRpb25fdmFsdWUuY29uY2F0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXN1bHQgPSBvcHRpb25fdmFsdWUuY29uY2F0KCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25fdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmVzdWx0ID0gb3B0aW9uX3ZhbHVlLnNwbGl0KC9bXmEtekEtWjAtOV9cXC9cXC1dKy8pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5PcHRpb25zLnByb3RvdHlwZS5fZ2V0X2Jvb2xlYW4gPSBmdW5jdGlvbihuYW1lLCBkZWZhdWx0X3ZhbHVlKSB7XG4gIHZhciBvcHRpb25fdmFsdWUgPSB0aGlzLnJhd19vcHRpb25zW25hbWVdO1xuICB2YXIgcmVzdWx0ID0gb3B0aW9uX3ZhbHVlID09PSB1bmRlZmluZWQgPyAhIWRlZmF1bHRfdmFsdWUgOiAhIW9wdGlvbl92YWx1ZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbk9wdGlvbnMucHJvdG90eXBlLl9nZXRfY2hhcmFjdGVycyA9IGZ1bmN0aW9uKG5hbWUsIGRlZmF1bHRfdmFsdWUpIHtcbiAgdmFyIG9wdGlvbl92YWx1ZSA9IHRoaXMucmF3X29wdGlvbnNbbmFtZV07XG4gIHZhciByZXN1bHQgPSBkZWZhdWx0X3ZhbHVlIHx8ICcnO1xuICBpZiAodHlwZW9mIG9wdGlvbl92YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXN1bHQgPSBvcHRpb25fdmFsdWUucmVwbGFjZSgvXFxcXHIvLCAnXFxyJykucmVwbGFjZSgvXFxcXG4vLCAnXFxuJykucmVwbGFjZSgvXFxcXHQvLCAnXFx0Jyk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbk9wdGlvbnMucHJvdG90eXBlLl9nZXRfbnVtYmVyID0gZnVuY3Rpb24obmFtZSwgZGVmYXVsdF92YWx1ZSkge1xuICB2YXIgb3B0aW9uX3ZhbHVlID0gdGhpcy5yYXdfb3B0aW9uc1tuYW1lXTtcbiAgZGVmYXVsdF92YWx1ZSA9IHBhcnNlSW50KGRlZmF1bHRfdmFsdWUsIDEwKTtcbiAgaWYgKGlzTmFOKGRlZmF1bHRfdmFsdWUpKSB7XG4gICAgZGVmYXVsdF92YWx1ZSA9IDA7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IHBhcnNlSW50KG9wdGlvbl92YWx1ZSwgMTApO1xuICBpZiAoaXNOYU4ocmVzdWx0KSkge1xuICAgIHJlc3VsdCA9IGRlZmF1bHRfdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbk9wdGlvbnMucHJvdG90eXBlLl9nZXRfc2VsZWN0aW9uID0gZnVuY3Rpb24obmFtZSwgc2VsZWN0aW9uX2xpc3QsIGRlZmF1bHRfdmFsdWUpIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMuX2dldF9zZWxlY3Rpb25fbGlzdChuYW1lLCBzZWxlY3Rpb25fbGlzdCwgZGVmYXVsdF92YWx1ZSk7XG4gIGlmIChyZXN1bHQubGVuZ3RoICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJJbnZhbGlkIE9wdGlvbiBWYWx1ZTogVGhlIG9wdGlvbiAnXCIgKyBuYW1lICsgXCInIGNhbiBvbmx5IGJlIG9uZSBvZiB0aGUgZm9sbG93aW5nIHZhbHVlczpcXG5cIiArXG4gICAgICBzZWxlY3Rpb25fbGlzdCArIFwiXFxuWW91IHBhc3NlZCBpbjogJ1wiICsgdGhpcy5yYXdfb3B0aW9uc1tuYW1lXSArIFwiJ1wiKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHRbMF07XG59O1xuXG5cbk9wdGlvbnMucHJvdG90eXBlLl9nZXRfc2VsZWN0aW9uX2xpc3QgPSBmdW5jdGlvbihuYW1lLCBzZWxlY3Rpb25fbGlzdCwgZGVmYXVsdF92YWx1ZSkge1xuICBpZiAoIXNlbGVjdGlvbl9saXN0IHx8IHNlbGVjdGlvbl9saXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlNlbGVjdGlvbiBsaXN0IGNhbm5vdCBiZSBlbXB0eS5cIik7XG4gIH1cblxuICBkZWZhdWx0X3ZhbHVlID0gZGVmYXVsdF92YWx1ZSB8fCBbc2VsZWN0aW9uX2xpc3RbMF1dO1xuICBpZiAoIXRoaXMuX2lzX3ZhbGlkX3NlbGVjdGlvbihkZWZhdWx0X3ZhbHVlLCBzZWxlY3Rpb25fbGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIERlZmF1bHQgVmFsdWUhXCIpO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IHRoaXMuX2dldF9hcnJheShuYW1lLCBkZWZhdWx0X3ZhbHVlKTtcbiAgaWYgKCF0aGlzLl9pc192YWxpZF9zZWxlY3Rpb24ocmVzdWx0LCBzZWxlY3Rpb25fbGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIkludmFsaWQgT3B0aW9uIFZhbHVlOiBUaGUgb3B0aW9uICdcIiArIG5hbWUgKyBcIicgY2FuIGNvbnRhaW4gb25seSB0aGUgZm9sbG93aW5nIHZhbHVlczpcXG5cIiArXG4gICAgICBzZWxlY3Rpb25fbGlzdCArIFwiXFxuWW91IHBhc3NlZCBpbjogJ1wiICsgdGhpcy5yYXdfb3B0aW9uc1tuYW1lXSArIFwiJ1wiKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5PcHRpb25zLnByb3RvdHlwZS5faXNfdmFsaWRfc2VsZWN0aW9uID0gZnVuY3Rpb24ocmVzdWx0LCBzZWxlY3Rpb25fbGlzdCkge1xuICByZXR1cm4gcmVzdWx0Lmxlbmd0aCAmJiBzZWxlY3Rpb25fbGlzdC5sZW5ndGggJiZcbiAgICAhcmVzdWx0LnNvbWUoZnVuY3Rpb24oaXRlbSkgeyByZXR1cm4gc2VsZWN0aW9uX2xpc3QuaW5kZXhPZihpdGVtKSA9PT0gLTE7IH0pO1xufTtcblxuXG4vLyBtZXJnZXMgY2hpbGQgb3B0aW9ucyB1cCB3aXRoIHRoZSBwYXJlbnQgb3B0aW9ucyBvYmplY3Rcbi8vIEV4YW1wbGU6IG9iaiA9IHthOiAxLCBiOiB7YTogMn19XG4vLyAgICAgICAgICBtZXJnZU9wdHMob2JqLCAnYicpXG4vL1xuLy8gICAgICAgICAgUmV0dXJuczoge2E6IDJ9XG5mdW5jdGlvbiBfbWVyZ2VPcHRzKGFsbE9wdGlvbnMsIGNoaWxkRmllbGROYW1lKSB7XG4gIHZhciBmaW5hbE9wdHMgPSB7fTtcbiAgYWxsT3B0aW9ucyA9IF9ub3JtYWxpemVPcHRzKGFsbE9wdGlvbnMpO1xuICB2YXIgbmFtZTtcblxuICBmb3IgKG5hbWUgaW4gYWxsT3B0aW9ucykge1xuICAgIGlmIChuYW1lICE9PSBjaGlsZEZpZWxkTmFtZSkge1xuICAgICAgZmluYWxPcHRzW25hbWVdID0gYWxsT3B0aW9uc1tuYW1lXTtcbiAgICB9XG4gIH1cblxuICAvL21lcmdlIGluIHRoZSBwZXIgdHlwZSBzZXR0aW5ncyBmb3IgdGhlIGNoaWxkRmllbGROYW1lXG4gIGlmIChjaGlsZEZpZWxkTmFtZSAmJiBhbGxPcHRpb25zW2NoaWxkRmllbGROYW1lXSkge1xuICAgIGZvciAobmFtZSBpbiBhbGxPcHRpb25zW2NoaWxkRmllbGROYW1lXSkge1xuICAgICAgZmluYWxPcHRzW25hbWVdID0gYWxsT3B0aW9uc1tjaGlsZEZpZWxkTmFtZV1bbmFtZV07XG4gICAgfVxuICB9XG4gIHJldHVybiBmaW5hbE9wdHM7XG59XG5cbmZ1bmN0aW9uIF9ub3JtYWxpemVPcHRzKG9wdGlvbnMpIHtcbiAgdmFyIGNvbnZlcnRlZE9wdHMgPSB7fTtcbiAgdmFyIGtleTtcblxuICBmb3IgKGtleSBpbiBvcHRpb25zKSB7XG4gICAgdmFyIG5ld0tleSA9IGtleS5yZXBsYWNlKC8tL2csIFwiX1wiKTtcbiAgICBjb252ZXJ0ZWRPcHRzW25ld0tleV0gPSBvcHRpb25zW2tleV07XG4gIH1cbiAgcmV0dXJuIGNvbnZlcnRlZE9wdHM7XG59XG5cbm1vZHVsZS5leHBvcnRzLk9wdGlvbnMgPSBPcHRpb25zO1xubW9kdWxlLmV4cG9ydHMubm9ybWFsaXplT3B0cyA9IF9ub3JtYWxpemVPcHRzO1xubW9kdWxlLmV4cG9ydHMubWVyZ2VPcHRzID0gX21lcmdlT3B0cztcblxuXG4vKioqLyB9KSxcbi8qIDcgKi8sXG4vKiA4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLypqc2hpbnQgbm9kZTp0cnVlICovXG4vKlxuXG4gIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4gIENvcHlyaWdodCAoYykgMjAwNy0yMDE4IEVpbmFyIExpZWxtYW5pcywgTGlhbSBOZXdtYW4sIGFuZCBjb250cmlidXRvcnMuXG5cbiAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICBTT0ZUV0FSRS5cbiovXG5cblxuXG52YXIgcmVnZXhwX2hhc19zdGlja3kgPSBSZWdFeHAucHJvdG90eXBlLmhhc093blByb3BlcnR5KCdzdGlja3knKTtcblxuZnVuY3Rpb24gSW5wdXRTY2FubmVyKGlucHV0X3N0cmluZykge1xuICB0aGlzLl9faW5wdXQgPSBpbnB1dF9zdHJpbmcgfHwgJyc7XG4gIHRoaXMuX19pbnB1dF9sZW5ndGggPSB0aGlzLl9faW5wdXQubGVuZ3RoO1xuICB0aGlzLl9fcG9zaXRpb24gPSAwO1xufVxuXG5JbnB1dFNjYW5uZXIucHJvdG90eXBlLnJlc3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fX3Bvc2l0aW9uID0gMDtcbn07XG5cbklucHV0U2Nhbm5lci5wcm90b3R5cGUuYmFjayA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5fX3Bvc2l0aW9uID4gMCkge1xuICAgIHRoaXMuX19wb3NpdGlvbiAtPSAxO1xuICB9XG59O1xuXG5JbnB1dFNjYW5uZXIucHJvdG90eXBlLmhhc05leHQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX19wb3NpdGlvbiA8IHRoaXMuX19pbnB1dF9sZW5ndGg7XG59O1xuXG5JbnB1dFNjYW5uZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHZhbCA9IG51bGw7XG4gIGlmICh0aGlzLmhhc05leHQoKSkge1xuICAgIHZhbCA9IHRoaXMuX19pbnB1dC5jaGFyQXQodGhpcy5fX3Bvc2l0aW9uKTtcbiAgICB0aGlzLl9fcG9zaXRpb24gKz0gMTtcbiAgfVxuICByZXR1cm4gdmFsO1xufTtcblxuSW5wdXRTY2FubmVyLnByb3RvdHlwZS5wZWVrID0gZnVuY3Rpb24oaW5kZXgpIHtcbiAgdmFyIHZhbCA9IG51bGw7XG4gIGluZGV4ID0gaW5kZXggfHwgMDtcbiAgaW5kZXggKz0gdGhpcy5fX3Bvc2l0aW9uO1xuICBpZiAoaW5kZXggPj0gMCAmJiBpbmRleCA8IHRoaXMuX19pbnB1dF9sZW5ndGgpIHtcbiAgICB2YWwgPSB0aGlzLl9faW5wdXQuY2hhckF0KGluZGV4KTtcbiAgfVxuICByZXR1cm4gdmFsO1xufTtcblxuLy8gVGhpcyBpcyBhIEphdmFTY3JpcHQgb25seSBoZWxwZXIgZnVuY3Rpb24gKG5vdCBpbiBweXRob24pXG4vLyBKYXZhc2NyaXB0IGRvZXNuJ3QgaGF2ZSBhIG1hdGNoIG1ldGhvZFxuLy8gYW5kIG5vdCBhbGwgaW1wbGVtZW50YXRpb24gc3VwcG9ydCBcInN0aWNreVwiIGZsYWcuXG4vLyBJZiB0aGV5IGRvIG5vdCBzdXBwb3J0IHN0aWNreSB0aGVuIGJvdGggdGhpcy5tYXRjaCgpIGFuZCB0aGlzLnRlc3QoKSBtZXRob2Rcbi8vIG11c3QgZ2V0IHRoZSBtYXRjaCBhbmQgY2hlY2sgdGhlIGluZGV4IG9mIHRoZSBtYXRjaC5cbi8vIElmIHN0aWNreSBpcyBzdXBwb3J0ZWQgYW5kIHNldCwgdGhpcyBtZXRob2Qgd2lsbCB1c2UgaXQuXG4vLyBPdGhlcndpc2UgaXQgd2lsbCBjaGVjayB0aGF0IGdsb2JhbCBpcyBzZXQsIGFuZCBmYWxsIGJhY2sgdG8gdGhlIHNsb3dlciBtZXRob2QuXG5JbnB1dFNjYW5uZXIucHJvdG90eXBlLl9fbWF0Y2ggPSBmdW5jdGlvbihwYXR0ZXJuLCBpbmRleCkge1xuICBwYXR0ZXJuLmxhc3RJbmRleCA9IGluZGV4O1xuICB2YXIgcGF0dGVybl9tYXRjaCA9IHBhdHRlcm4uZXhlYyh0aGlzLl9faW5wdXQpO1xuXG4gIGlmIChwYXR0ZXJuX21hdGNoICYmICEocmVnZXhwX2hhc19zdGlja3kgJiYgcGF0dGVybi5zdGlja3kpKSB7XG4gICAgaWYgKHBhdHRlcm5fbWF0Y2guaW5kZXggIT09IGluZGV4KSB7XG4gICAgICBwYXR0ZXJuX21hdGNoID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGF0dGVybl9tYXRjaDtcbn07XG5cbklucHV0U2Nhbm5lci5wcm90b3R5cGUudGVzdCA9IGZ1bmN0aW9uKHBhdHRlcm4sIGluZGV4KSB7XG4gIGluZGV4ID0gaW5kZXggfHwgMDtcbiAgaW5kZXggKz0gdGhpcy5fX3Bvc2l0aW9uO1xuXG4gIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgdGhpcy5fX2lucHV0X2xlbmd0aCkge1xuICAgIHJldHVybiAhIXRoaXMuX19tYXRjaChwYXR0ZXJuLCBpbmRleCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG5JbnB1dFNjYW5uZXIucHJvdG90eXBlLnRlc3RDaGFyID0gZnVuY3Rpb24ocGF0dGVybiwgaW5kZXgpIHtcbiAgLy8gdGVzdCBvbmUgY2hhcmFjdGVyIHJlZ2V4IG1hdGNoXG4gIHZhciB2YWwgPSB0aGlzLnBlZWsoaW5kZXgpO1xuICBwYXR0ZXJuLmxhc3RJbmRleCA9IDA7XG4gIHJldHVybiB2YWwgIT09IG51bGwgJiYgcGF0dGVybi50ZXN0KHZhbCk7XG59O1xuXG5JbnB1dFNjYW5uZXIucHJvdG90eXBlLm1hdGNoID0gZnVuY3Rpb24ocGF0dGVybikge1xuICB2YXIgcGF0dGVybl9tYXRjaCA9IHRoaXMuX19tYXRjaChwYXR0ZXJuLCB0aGlzLl9fcG9zaXRpb24pO1xuICBpZiAocGF0dGVybl9tYXRjaCkge1xuICAgIHRoaXMuX19wb3NpdGlvbiArPSBwYXR0ZXJuX21hdGNoWzBdLmxlbmd0aDtcbiAgfSBlbHNlIHtcbiAgICBwYXR0ZXJuX21hdGNoID0gbnVsbDtcbiAgfVxuICByZXR1cm4gcGF0dGVybl9tYXRjaDtcbn07XG5cbklucHV0U2Nhbm5lci5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uKHN0YXJ0aW5nX3BhdHRlcm4sIHVudGlsX3BhdHRlcm4sIHVudGlsX2FmdGVyKSB7XG4gIHZhciB2YWwgPSAnJztcbiAgdmFyIG1hdGNoO1xuICBpZiAoc3RhcnRpbmdfcGF0dGVybikge1xuICAgIG1hdGNoID0gdGhpcy5tYXRjaChzdGFydGluZ19wYXR0ZXJuKTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIHZhbCArPSBtYXRjaFswXTtcbiAgICB9XG4gIH1cbiAgaWYgKHVudGlsX3BhdHRlcm4gJiYgKG1hdGNoIHx8ICFzdGFydGluZ19wYXR0ZXJuKSkge1xuICAgIHZhbCArPSB0aGlzLnJlYWRVbnRpbCh1bnRpbF9wYXR0ZXJuLCB1bnRpbF9hZnRlcik7XG4gIH1cbiAgcmV0dXJuIHZhbDtcbn07XG5cbklucHV0U2Nhbm5lci5wcm90b3R5cGUucmVhZFVudGlsID0gZnVuY3Rpb24ocGF0dGVybiwgdW50aWxfYWZ0ZXIpIHtcbiAgdmFyIHZhbCA9ICcnO1xuICB2YXIgbWF0Y2hfaW5kZXggPSB0aGlzLl9fcG9zaXRpb247XG4gIHBhdHRlcm4ubGFzdEluZGV4ID0gdGhpcy5fX3Bvc2l0aW9uO1xuICB2YXIgcGF0dGVybl9tYXRjaCA9IHBhdHRlcm4uZXhlYyh0aGlzLl9faW5wdXQpO1xuICBpZiAocGF0dGVybl9tYXRjaCkge1xuICAgIG1hdGNoX2luZGV4ID0gcGF0dGVybl9tYXRjaC5pbmRleDtcbiAgICBpZiAodW50aWxfYWZ0ZXIpIHtcbiAgICAgIG1hdGNoX2luZGV4ICs9IHBhdHRlcm5fbWF0Y2hbMF0ubGVuZ3RoO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBtYXRjaF9pbmRleCA9IHRoaXMuX19pbnB1dF9sZW5ndGg7XG4gIH1cblxuICB2YWwgPSB0aGlzLl9faW5wdXQuc3Vic3RyaW5nKHRoaXMuX19wb3NpdGlvbiwgbWF0Y2hfaW5kZXgpO1xuICB0aGlzLl9fcG9zaXRpb24gPSBtYXRjaF9pbmRleDtcbiAgcmV0dXJuIHZhbDtcbn07XG5cbklucHV0U2Nhbm5lci5wcm90b3R5cGUucmVhZFVudGlsQWZ0ZXIgPSBmdW5jdGlvbihwYXR0ZXJuKSB7XG4gIHJldHVybiB0aGlzLnJlYWRVbnRpbChwYXR0ZXJuLCB0cnVlKTtcbn07XG5cbklucHV0U2Nhbm5lci5wcm90b3R5cGUuZ2V0X3JlZ2V4cCA9IGZ1bmN0aW9uKHBhdHRlcm4sIG1hdGNoX2Zyb20pIHtcbiAgdmFyIHJlc3VsdCA9IG51bGw7XG4gIHZhciBmbGFncyA9ICdnJztcbiAgaWYgKG1hdGNoX2Zyb20gJiYgcmVnZXhwX2hhc19zdGlja3kpIHtcbiAgICBmbGFncyA9ICd5JztcbiAgfVxuICAvLyBzdHJpbmdzIGFyZSBjb252ZXJ0ZWQgdG8gcmVnZXhwXG4gIGlmICh0eXBlb2YgcGF0dGVybiA9PT0gXCJzdHJpbmdcIiAmJiBwYXR0ZXJuICE9PSAnJykge1xuICAgIC8vIHJlc3VsdCA9IG5ldyBSZWdFeHAocGF0dGVybi5yZXBsYWNlKC9bLVxcL1xcXFxeJCorPy4oKXxbXFxde31dL2csICdcXFxcJCYnKSwgZmxhZ3MpO1xuICAgIHJlc3VsdCA9IG5ldyBSZWdFeHAocGF0dGVybiwgZmxhZ3MpO1xuICB9IGVsc2UgaWYgKHBhdHRlcm4pIHtcbiAgICByZXN1bHQgPSBuZXcgUmVnRXhwKHBhdHRlcm4uc291cmNlLCBmbGFncyk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbklucHV0U2Nhbm5lci5wcm90b3R5cGUuZ2V0X2xpdGVyYWxfcmVnZXhwID0gZnVuY3Rpb24obGl0ZXJhbF9zdHJpbmcpIHtcbiAgcmV0dXJuIFJlZ0V4cChsaXRlcmFsX3N0cmluZy5yZXBsYWNlKC9bLVxcL1xcXFxeJCorPy4oKXxbXFxde31dL2csICdcXFxcJCYnKSk7XG59O1xuXG4vKiBjc3MgYmVhdXRpZmllciBsZWdhY3kgaGVscGVycyAqL1xuSW5wdXRTY2FubmVyLnByb3RvdHlwZS5wZWVrVW50aWxBZnRlciA9IGZ1bmN0aW9uKHBhdHRlcm4pIHtcbiAgdmFyIHN0YXJ0ID0gdGhpcy5fX3Bvc2l0aW9uO1xuICB2YXIgdmFsID0gdGhpcy5yZWFkVW50aWxBZnRlcihwYXR0ZXJuKTtcbiAgdGhpcy5fX3Bvc2l0aW9uID0gc3RhcnQ7XG4gIHJldHVybiB2YWw7XG59O1xuXG5JbnB1dFNjYW5uZXIucHJvdG90eXBlLmxvb2tCYWNrID0gZnVuY3Rpb24odGVzdFZhbCkge1xuICB2YXIgc3RhcnQgPSB0aGlzLl9fcG9zaXRpb24gLSAxO1xuICByZXR1cm4gc3RhcnQgPj0gdGVzdFZhbC5sZW5ndGggJiYgdGhpcy5fX2lucHV0LnN1YnN0cmluZyhzdGFydCAtIHRlc3RWYWwubGVuZ3RoLCBzdGFydClcbiAgICAudG9Mb3dlckNhc2UoKSA9PT0gdGVzdFZhbDtcbn07XG5cbm1vZHVsZS5leHBvcnRzLklucHV0U2Nhbm5lciA9IElucHV0U2Nhbm5lcjtcblxuXG4vKioqLyB9KSxcbi8qIDkgKi8sXG4vKiAxMCAqLyxcbi8qIDExICovLFxuLyogMTIgKi8sXG4vKiAxMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qanNoaW50IG5vZGU6dHJ1ZSAqL1xuLypcblxuICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxOCBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgU09GVFdBUkUuXG4qL1xuXG5cblxuZnVuY3Rpb24gRGlyZWN0aXZlcyhzdGFydF9ibG9ja19wYXR0ZXJuLCBlbmRfYmxvY2tfcGF0dGVybikge1xuICBzdGFydF9ibG9ja19wYXR0ZXJuID0gdHlwZW9mIHN0YXJ0X2Jsb2NrX3BhdHRlcm4gPT09ICdzdHJpbmcnID8gc3RhcnRfYmxvY2tfcGF0dGVybiA6IHN0YXJ0X2Jsb2NrX3BhdHRlcm4uc291cmNlO1xuICBlbmRfYmxvY2tfcGF0dGVybiA9IHR5cGVvZiBlbmRfYmxvY2tfcGF0dGVybiA9PT0gJ3N0cmluZycgPyBlbmRfYmxvY2tfcGF0dGVybiA6IGVuZF9ibG9ja19wYXR0ZXJuLnNvdXJjZTtcbiAgdGhpcy5fX2RpcmVjdGl2ZXNfYmxvY2tfcGF0dGVybiA9IG5ldyBSZWdFeHAoc3RhcnRfYmxvY2tfcGF0dGVybiArIC8gYmVhdXRpZnkoIFxcdytbOl1cXHcrKSsgLy5zb3VyY2UgKyBlbmRfYmxvY2tfcGF0dGVybiwgJ2cnKTtcbiAgdGhpcy5fX2RpcmVjdGl2ZV9wYXR0ZXJuID0gLyAoXFx3KylbOl0oXFx3KykvZztcblxuICB0aGlzLl9fZGlyZWN0aXZlc19lbmRfaWdub3JlX3BhdHRlcm4gPSBuZXcgUmVnRXhwKHN0YXJ0X2Jsb2NrX3BhdHRlcm4gKyAvXFxzYmVhdXRpZnlcXHNpZ25vcmU6ZW5kXFxzLy5zb3VyY2UgKyBlbmRfYmxvY2tfcGF0dGVybiwgJ2cnKTtcbn1cblxuRGlyZWN0aXZlcy5wcm90b3R5cGUuZ2V0X2RpcmVjdGl2ZXMgPSBmdW5jdGlvbih0ZXh0KSB7XG4gIGlmICghdGV4dC5tYXRjaCh0aGlzLl9fZGlyZWN0aXZlc19ibG9ja19wYXR0ZXJuKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGRpcmVjdGl2ZXMgPSB7fTtcbiAgdGhpcy5fX2RpcmVjdGl2ZV9wYXR0ZXJuLmxhc3RJbmRleCA9IDA7XG4gIHZhciBkaXJlY3RpdmVfbWF0Y2ggPSB0aGlzLl9fZGlyZWN0aXZlX3BhdHRlcm4uZXhlYyh0ZXh0KTtcblxuICB3aGlsZSAoZGlyZWN0aXZlX21hdGNoKSB7XG4gICAgZGlyZWN0aXZlc1tkaXJlY3RpdmVfbWF0Y2hbMV1dID0gZGlyZWN0aXZlX21hdGNoWzJdO1xuICAgIGRpcmVjdGl2ZV9tYXRjaCA9IHRoaXMuX19kaXJlY3RpdmVfcGF0dGVybi5leGVjKHRleHQpO1xuICB9XG5cbiAgcmV0dXJuIGRpcmVjdGl2ZXM7XG59O1xuXG5EaXJlY3RpdmVzLnByb3RvdHlwZS5yZWFkSWdub3JlZCA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIHJldHVybiBpbnB1dC5yZWFkVW50aWxBZnRlcih0aGlzLl9fZGlyZWN0aXZlc19lbmRfaWdub3JlX3BhdHRlcm4pO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cy5EaXJlY3RpdmVzID0gRGlyZWN0aXZlcztcblxuXG4vKioqLyB9KSxcbi8qIDE0ICovLFxuLyogMTUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKmpzaGludCBub2RlOnRydWUgKi9cbi8qXG5cbiAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiAgQ29weXJpZ2h0IChjKSAyMDA3LTIwMTggRWluYXIgTGllbG1hbmlzLCBMaWFtIE5ld21hbiwgYW5kIGNvbnRyaWJ1dG9ycy5cblxuICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gIFNPRlRXQVJFLlxuKi9cblxuXG5cbnZhciBCZWF1dGlmaWVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNikuQmVhdXRpZmllcixcbiAgT3B0aW9ucyA9IF9fd2VicGFja19yZXF1aXJlX18oMTcpLk9wdGlvbnM7XG5cbmZ1bmN0aW9uIGNzc19iZWF1dGlmeShzb3VyY2VfdGV4dCwgb3B0aW9ucykge1xuICB2YXIgYmVhdXRpZmllciA9IG5ldyBCZWF1dGlmaWVyKHNvdXJjZV90ZXh0LCBvcHRpb25zKTtcbiAgcmV0dXJuIGJlYXV0aWZpZXIuYmVhdXRpZnkoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjc3NfYmVhdXRpZnk7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0T3B0aW9ucyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IE9wdGlvbnMoKTtcbn07XG5cblxuLyoqKi8gfSksXG4vKiAxNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qanNoaW50IG5vZGU6dHJ1ZSAqL1xuLypcblxuICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxOCBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgU09GVFdBUkUuXG4qL1xuXG5cblxudmFyIE9wdGlvbnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KS5PcHRpb25zO1xudmFyIE91dHB1dCA9IF9fd2VicGFja19yZXF1aXJlX18oMikuT3V0cHV0O1xudmFyIElucHV0U2Nhbm5lciA9IF9fd2VicGFja19yZXF1aXJlX18oOCkuSW5wdXRTY2FubmVyO1xudmFyIERpcmVjdGl2ZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKS5EaXJlY3RpdmVzO1xuXG52YXIgZGlyZWN0aXZlc19jb3JlID0gbmV3IERpcmVjdGl2ZXMoL1xcL1xcKi8sIC9cXCpcXC8vKTtcblxudmFyIGxpbmVCcmVhayA9IC9cXHJcXG58W1xcclxcbl0vO1xudmFyIGFsbExpbmVCcmVha3MgPSAvXFxyXFxufFtcXHJcXG5dL2c7XG5cbi8vIHRva2VuaXplclxudmFyIHdoaXRlc3BhY2VDaGFyID0gL1xccy87XG52YXIgd2hpdGVzcGFjZVBhdHRlcm4gPSAvKD86XFxzfFxcbikrL2c7XG52YXIgYmxvY2tfY29tbWVudF9wYXR0ZXJuID0gL1xcL1xcKig/OltcXHNcXFNdKj8pKCg/OlxcKlxcLyl8JCkvZztcbnZhciBjb21tZW50X3BhdHRlcm4gPSAvXFwvXFwvKD86W15cXG5cXHJcXHUyMDI4XFx1MjAyOV0qKS9nO1xuXG5mdW5jdGlvbiBCZWF1dGlmaWVyKHNvdXJjZV90ZXh0LCBvcHRpb25zKSB7XG4gIHRoaXMuX3NvdXJjZV90ZXh0ID0gc291cmNlX3RleHQgfHwgJyc7XG4gIC8vIEFsbG93IHRoZSBzZXR0aW5nIG9mIGxhbmd1YWdlL2ZpbGUtdHlwZSBzcGVjaWZpYyBvcHRpb25zXG4gIC8vIHdpdGggaW5oZXJpdGFuY2Ugb2Ygb3ZlcmFsbCBzZXR0aW5nc1xuICB0aGlzLl9vcHRpb25zID0gbmV3IE9wdGlvbnMob3B0aW9ucyk7XG4gIHRoaXMuX2NoID0gbnVsbDtcbiAgdGhpcy5faW5wdXQgPSBudWxsO1xuXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9BdC1ydWxlXG4gIHRoaXMuTkVTVEVEX0FUX1JVTEUgPSB7XG4gICAgXCJAcGFnZVwiOiB0cnVlLFxuICAgIFwiQGZvbnQtZmFjZVwiOiB0cnVlLFxuICAgIFwiQGtleWZyYW1lc1wiOiB0cnVlLFxuICAgIC8vIGFsc28gaW4gQ09ORElUSU9OQUxfR1JPVVBfUlVMRSBiZWxvd1xuICAgIFwiQG1lZGlhXCI6IHRydWUsXG4gICAgXCJAc3VwcG9ydHNcIjogdHJ1ZSxcbiAgICBcIkBkb2N1bWVudFwiOiB0cnVlXG4gIH07XG4gIHRoaXMuQ09ORElUSU9OQUxfR1JPVVBfUlVMRSA9IHtcbiAgICBcIkBtZWRpYVwiOiB0cnVlLFxuICAgIFwiQHN1cHBvcnRzXCI6IHRydWUsXG4gICAgXCJAZG9jdW1lbnRcIjogdHJ1ZVxuICB9O1xuXG59XG5cbkJlYXV0aWZpZXIucHJvdG90eXBlLmVhdFN0cmluZyA9IGZ1bmN0aW9uKGVuZENoYXJzKSB7XG4gIHZhciByZXN1bHQgPSAnJztcbiAgdGhpcy5fY2ggPSB0aGlzLl9pbnB1dC5uZXh0KCk7XG4gIHdoaWxlICh0aGlzLl9jaCkge1xuICAgIHJlc3VsdCArPSB0aGlzLl9jaDtcbiAgICBpZiAodGhpcy5fY2ggPT09IFwiXFxcXFwiKSB7XG4gICAgICByZXN1bHQgKz0gdGhpcy5faW5wdXQubmV4dCgpO1xuICAgIH0gZWxzZSBpZiAoZW5kQ2hhcnMuaW5kZXhPZih0aGlzLl9jaCkgIT09IC0xIHx8IHRoaXMuX2NoID09PSBcIlxcblwiKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgdGhpcy5fY2ggPSB0aGlzLl9pbnB1dC5uZXh0KCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8vIFNraXBzIGFueSB3aGl0ZSBzcGFjZSBpbiB0aGUgc291cmNlIHRleHQgZnJvbSB0aGUgY3VycmVudCBwb3NpdGlvbi5cbi8vIFdoZW4gYWxsb3dBdExlYXN0T25lTmV3TGluZSBpcyB0cnVlLCB3aWxsIG91dHB1dCBuZXcgbGluZXMgZm9yIGVhY2hcbi8vIG5ld2xpbmUgY2hhcmFjdGVyIGZvdW5kOyBpZiB0aGUgdXNlciBoYXMgcHJlc2VydmVfbmV3bGluZXMgb2ZmLCBvbmx5XG4vLyB0aGUgZmlyc3QgbmV3bGluZSB3aWxsIGJlIG91dHB1dFxuQmVhdXRpZmllci5wcm90b3R5cGUuZWF0V2hpdGVzcGFjZSA9IGZ1bmN0aW9uKGFsbG93QXRMZWFzdE9uZU5ld0xpbmUpIHtcbiAgdmFyIHJlc3VsdCA9IHdoaXRlc3BhY2VDaGFyLnRlc3QodGhpcy5faW5wdXQucGVlaygpKTtcbiAgdmFyIGlzRmlyc3ROZXdMaW5lID0gdHJ1ZTtcblxuICB3aGlsZSAod2hpdGVzcGFjZUNoYXIudGVzdCh0aGlzLl9pbnB1dC5wZWVrKCkpKSB7XG4gICAgdGhpcy5fY2ggPSB0aGlzLl9pbnB1dC5uZXh0KCk7XG4gICAgaWYgKGFsbG93QXRMZWFzdE9uZU5ld0xpbmUgJiYgdGhpcy5fY2ggPT09ICdcXG4nKSB7XG4gICAgICBpZiAodGhpcy5fb3B0aW9ucy5wcmVzZXJ2ZV9uZXdsaW5lcyB8fCBpc0ZpcnN0TmV3TGluZSkge1xuICAgICAgICBpc0ZpcnN0TmV3TGluZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9vdXRwdXQuYWRkX25ld19saW5lKHRydWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gTmVzdGVkIHBzZXVkby1jbGFzcyBpZiB3ZSBhcmUgaW5zaWRlUnVsZVxuLy8gYW5kIHRoZSBuZXh0IHNwZWNpYWwgY2hhcmFjdGVyIGZvdW5kIG9wZW5zXG4vLyBhIG5ldyBibG9ja1xuQmVhdXRpZmllci5wcm90b3R5cGUuZm91bmROZXN0ZWRQc2V1ZG9DbGFzcyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgb3BlblBhcmVuID0gMDtcbiAgdmFyIGkgPSAxO1xuICB2YXIgY2ggPSB0aGlzLl9pbnB1dC5wZWVrKGkpO1xuICB3aGlsZSAoY2gpIHtcbiAgICBpZiAoY2ggPT09IFwie1wiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGNoID09PSAnKCcpIHtcbiAgICAgIC8vIHBzZXVkb2NsYXNzZXMgY2FuIGNvbnRhaW4gKClcbiAgICAgIG9wZW5QYXJlbiArPSAxO1xuICAgIH0gZWxzZSBpZiAoY2ggPT09ICcpJykge1xuICAgICAgaWYgKG9wZW5QYXJlbiA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBvcGVuUGFyZW4gLT0gMTtcbiAgICB9IGVsc2UgaWYgKGNoID09PSBcIjtcIiB8fCBjaCA9PT0gXCJ9XCIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaSsrO1xuICAgIGNoID0gdGhpcy5faW5wdXQucGVlayhpKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5wcmludF9zdHJpbmcgPSBmdW5jdGlvbihvdXRwdXRfc3RyaW5nKSB7XG4gIHRoaXMuX291dHB1dC5zZXRfaW5kZW50KHRoaXMuX2luZGVudExldmVsKTtcbiAgdGhpcy5fb3V0cHV0Lm5vbl9icmVha2luZ19zcGFjZSA9IHRydWU7XG4gIHRoaXMuX291dHB1dC5hZGRfdG9rZW4ob3V0cHV0X3N0cmluZyk7XG59O1xuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5wcmVzZXJ2ZVNpbmdsZVNwYWNlID0gZnVuY3Rpb24oaXNBZnRlclNwYWNlKSB7XG4gIGlmIChpc0FmdGVyU3BhY2UpIHtcbiAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgfVxufTtcblxuQmVhdXRpZmllci5wcm90b3R5cGUuaW5kZW50ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2luZGVudExldmVsKys7XG59O1xuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5vdXRkZW50ID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLl9pbmRlbnRMZXZlbCA+IDApIHtcbiAgICB0aGlzLl9pbmRlbnRMZXZlbC0tO1xuICB9XG59O1xuXG4vKl9fX19fX19fX19fX19fX19fX19fXy0tLS0tLS0tLS0tLS0tLS0tLS0tX19fX19fX19fX19fX19fX19fX19fKi9cblxuQmVhdXRpZmllci5wcm90b3R5cGUuYmVhdXRpZnkgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuX29wdGlvbnMuZGlzYWJsZWQpIHtcbiAgICByZXR1cm4gdGhpcy5fc291cmNlX3RleHQ7XG4gIH1cblxuICB2YXIgc291cmNlX3RleHQgPSB0aGlzLl9zb3VyY2VfdGV4dDtcbiAgdmFyIGVvbCA9IHRoaXMuX29wdGlvbnMuZW9sO1xuICBpZiAoZW9sID09PSAnYXV0bycpIHtcbiAgICBlb2wgPSAnXFxuJztcbiAgICBpZiAoc291cmNlX3RleHQgJiYgbGluZUJyZWFrLnRlc3Qoc291cmNlX3RleHQgfHwgJycpKSB7XG4gICAgICBlb2wgPSBzb3VyY2VfdGV4dC5tYXRjaChsaW5lQnJlYWspWzBdO1xuICAgIH1cbiAgfVxuXG5cbiAgLy8gSEFDSzogbmV3bGluZSBwYXJzaW5nIGluY29uc2lzdGVudC4gVGhpcyBicnV0ZSBmb3JjZSBub3JtYWxpemVzIHRoZSB0aGlzLl9pbnB1dC5cbiAgc291cmNlX3RleHQgPSBzb3VyY2VfdGV4dC5yZXBsYWNlKGFsbExpbmVCcmVha3MsICdcXG4nKTtcblxuICAvLyByZXNldFxuICB2YXIgYmFzZUluZGVudFN0cmluZyA9IHNvdXJjZV90ZXh0Lm1hdGNoKC9eW1xcdCBdKi8pWzBdO1xuXG4gIHRoaXMuX291dHB1dCA9IG5ldyBPdXRwdXQodGhpcy5fb3B0aW9ucywgYmFzZUluZGVudFN0cmluZyk7XG4gIHRoaXMuX2lucHV0ID0gbmV3IElucHV0U2Nhbm5lcihzb3VyY2VfdGV4dCk7XG4gIHRoaXMuX2luZGVudExldmVsID0gMDtcbiAgdGhpcy5fbmVzdGVkTGV2ZWwgPSAwO1xuXG4gIHRoaXMuX2NoID0gbnVsbDtcbiAgdmFyIHBhcmVuTGV2ZWwgPSAwO1xuXG4gIHZhciBpbnNpZGVSdWxlID0gZmFsc2U7XG4gIC8vIFRoaXMgaXMgdGhlIHZhbHVlIHNpZGUgb2YgYSBwcm9wZXJ0eSB2YWx1ZSBwYWlyIChibHVlIGluIHRoZSBmb2xsb3dpbmcgZXgpXG4gIC8vIGxhYmVsIHsgY29udGVudDogYmx1ZSB9XG4gIHZhciBpbnNpZGVQcm9wZXJ0eVZhbHVlID0gZmFsc2U7XG4gIHZhciBlbnRlcmluZ0NvbmRpdGlvbmFsR3JvdXAgPSBmYWxzZTtcbiAgdmFyIGluc2lkZUF0RXh0ZW5kID0gZmFsc2U7XG4gIHZhciBpbnNpZGVBdEltcG9ydCA9IGZhbHNlO1xuICB2YXIgdG9wQ2hhcmFjdGVyID0gdGhpcy5fY2g7XG4gIHZhciB3aGl0ZXNwYWNlO1xuICB2YXIgaXNBZnRlclNwYWNlO1xuICB2YXIgcHJldmlvdXNfY2g7XG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICB3aGl0ZXNwYWNlID0gdGhpcy5faW5wdXQucmVhZCh3aGl0ZXNwYWNlUGF0dGVybik7XG4gICAgaXNBZnRlclNwYWNlID0gd2hpdGVzcGFjZSAhPT0gJyc7XG4gICAgcHJldmlvdXNfY2ggPSB0b3BDaGFyYWN0ZXI7XG4gICAgdGhpcy5fY2ggPSB0aGlzLl9pbnB1dC5uZXh0KCk7XG4gICAgaWYgKHRoaXMuX2NoID09PSAnXFxcXCcgJiYgdGhpcy5faW5wdXQuaGFzTmV4dCgpKSB7XG4gICAgICB0aGlzLl9jaCArPSB0aGlzLl9pbnB1dC5uZXh0KCk7XG4gICAgfVxuICAgIHRvcENoYXJhY3RlciA9IHRoaXMuX2NoO1xuXG4gICAgaWYgKCF0aGlzLl9jaCkge1xuICAgICAgYnJlYWs7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9jaCA9PT0gJy8nICYmIHRoaXMuX2lucHV0LnBlZWsoKSA9PT0gJyonKSB7XG4gICAgICAvLyAvKiBjc3MgY29tbWVudCAqL1xuICAgICAgLy8gQWx3YXlzIHN0YXJ0IGJsb2NrIGNvbW1lbnRzIG9uIGEgbmV3IGxpbmUuXG4gICAgICAvLyBUaGlzIGhhbmRsZXMgc2NlbmFyaW9zIHdoZXJlIGEgYmxvY2sgY29tbWVudCBpbW1lZGlhdGVseVxuICAgICAgLy8gZm9sbG93cyBhIHByb3BlcnR5IGRlZmluaXRpb24gb24gdGhlIHNhbWUgbGluZSBvciB3aGVyZVxuICAgICAgLy8gbWluaWZpZWQgY29kZSBpcyBiZWluZyBiZWF1dGlmaWVkLlxuICAgICAgdGhpcy5fb3V0cHV0LmFkZF9uZXdfbGluZSgpO1xuICAgICAgdGhpcy5faW5wdXQuYmFjaygpO1xuXG4gICAgICB2YXIgY29tbWVudCA9IHRoaXMuX2lucHV0LnJlYWQoYmxvY2tfY29tbWVudF9wYXR0ZXJuKTtcblxuICAgICAgLy8gSGFuZGxlIGlnbm9yZSBkaXJlY3RpdmVcbiAgICAgIHZhciBkaXJlY3RpdmVzID0gZGlyZWN0aXZlc19jb3JlLmdldF9kaXJlY3RpdmVzKGNvbW1lbnQpO1xuICAgICAgaWYgKGRpcmVjdGl2ZXMgJiYgZGlyZWN0aXZlcy5pZ25vcmUgPT09ICdzdGFydCcpIHtcbiAgICAgICAgY29tbWVudCArPSBkaXJlY3RpdmVzX2NvcmUucmVhZElnbm9yZWQodGhpcy5faW5wdXQpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnByaW50X3N0cmluZyhjb21tZW50KTtcblxuICAgICAgLy8gRW5zdXJlcyBhbnkgbmV3IGxpbmVzIGZvbGxvd2luZyB0aGUgY29tbWVudCBhcmUgcHJlc2VydmVkXG4gICAgICB0aGlzLmVhdFdoaXRlc3BhY2UodHJ1ZSk7XG5cbiAgICAgIC8vIEJsb2NrIGNvbW1lbnRzIGFyZSBmb2xsb3dlZCBieSBhIG5ldyBsaW5lIHNvIHRoZXkgZG9uJ3RcbiAgICAgIC8vIHNoYXJlIGEgbGluZSB3aXRoIG90aGVyIHByb3BlcnRpZXNcbiAgICAgIHRoaXMuX291dHB1dC5hZGRfbmV3X2xpbmUoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2NoID09PSAnLycgJiYgdGhpcy5faW5wdXQucGVlaygpID09PSAnLycpIHtcbiAgICAgIC8vIC8vIHNpbmdsZSBsaW5lIGNvbW1lbnRcbiAgICAgIC8vIFByZXNlcnZlcyB0aGUgc3BhY2UgYmVmb3JlIGEgY29tbWVudFxuICAgICAgLy8gb24gdGhlIHNhbWUgbGluZSBhcyBhIHJ1bGVcbiAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgdGhpcy5faW5wdXQuYmFjaygpO1xuICAgICAgdGhpcy5wcmludF9zdHJpbmcodGhpcy5faW5wdXQucmVhZChjb21tZW50X3BhdHRlcm4pKTtcblxuICAgICAgLy8gRW5zdXJlcyBhbnkgbmV3IGxpbmVzIGZvbGxvd2luZyB0aGUgY29tbWVudCBhcmUgcHJlc2VydmVkXG4gICAgICB0aGlzLmVhdFdoaXRlc3BhY2UodHJ1ZSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9jaCA9PT0gJ0AnKSB7XG4gICAgICB0aGlzLnByZXNlcnZlU2luZ2xlU3BhY2UoaXNBZnRlclNwYWNlKTtcblxuICAgICAgLy8gZGVhbCB3aXRoIGxlc3MgcHJvcGVyeSBtaXhpbnMgQHsuLi59XG4gICAgICBpZiAodGhpcy5faW5wdXQucGVlaygpID09PSAneycpIHtcbiAgICAgICAgdGhpcy5wcmludF9zdHJpbmcodGhpcy5fY2ggKyB0aGlzLmVhdFN0cmluZygnfScpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucHJpbnRfc3RyaW5nKHRoaXMuX2NoKTtcblxuICAgICAgICAvLyBzdHJpcCB0cmFpbGluZyBzcGFjZSwgaWYgcHJlc2VudCwgZm9yIGhhc2ggcHJvcGVydHkgY2hlY2tzXG4gICAgICAgIHZhciB2YXJpYWJsZU9yUnVsZSA9IHRoaXMuX2lucHV0LnBlZWtVbnRpbEFmdGVyKC9bOiAsO3t9KClbXFxdXFwvPSdcIl0vZyk7XG5cbiAgICAgICAgaWYgKHZhcmlhYmxlT3JSdWxlLm1hdGNoKC9bIDpdJC8pKSB7XG4gICAgICAgICAgLy8gd2UgaGF2ZSBhIHZhcmlhYmxlIG9yIHBzZXVkby1jbGFzcywgYWRkIGl0IGFuZCBpbnNlcnQgb25lIHNwYWNlIGJlZm9yZSBjb250aW51aW5nXG4gICAgICAgICAgdmFyaWFibGVPclJ1bGUgPSB0aGlzLmVhdFN0cmluZyhcIjogXCIpLnJlcGxhY2UoL1xccyQvLCAnJyk7XG4gICAgICAgICAgdGhpcy5wcmludF9zdHJpbmcodmFyaWFibGVPclJ1bGUpO1xuICAgICAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyaWFibGVPclJ1bGUgPSB2YXJpYWJsZU9yUnVsZS5yZXBsYWNlKC9cXHMkLywgJycpO1xuXG4gICAgICAgIGlmICh2YXJpYWJsZU9yUnVsZSA9PT0gJ2V4dGVuZCcpIHtcbiAgICAgICAgICBpbnNpZGVBdEV4dGVuZCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAodmFyaWFibGVPclJ1bGUgPT09ICdpbXBvcnQnKSB7XG4gICAgICAgICAgaW5zaWRlQXRJbXBvcnQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbWlnaHQgYmUgYSBuZXN0aW5nIGF0LXJ1bGVcbiAgICAgICAgaWYgKHZhcmlhYmxlT3JSdWxlIGluIHRoaXMuTkVTVEVEX0FUX1JVTEUpIHtcbiAgICAgICAgICB0aGlzLl9uZXN0ZWRMZXZlbCArPSAxO1xuICAgICAgICAgIGlmICh2YXJpYWJsZU9yUnVsZSBpbiB0aGlzLkNPTkRJVElPTkFMX0dST1VQX1JVTEUpIHtcbiAgICAgICAgICAgIGVudGVyaW5nQ29uZGl0aW9uYWxHcm91cCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIG1pZ2h0IGJlIGxlc3MgdmFyaWFibGVcbiAgICAgICAgfSBlbHNlIGlmICghaW5zaWRlUnVsZSAmJiBwYXJlbkxldmVsID09PSAwICYmIHZhcmlhYmxlT3JSdWxlLmluZGV4T2YoJzonKSAhPT0gLTEpIHtcbiAgICAgICAgICBpbnNpZGVQcm9wZXJ0eVZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLmluZGVudCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLl9jaCA9PT0gJyMnICYmIHRoaXMuX2lucHV0LnBlZWsoKSA9PT0gJ3snKSB7XG4gICAgICB0aGlzLnByZXNlcnZlU2luZ2xlU3BhY2UoaXNBZnRlclNwYWNlKTtcbiAgICAgIHRoaXMucHJpbnRfc3RyaW5nKHRoaXMuX2NoICsgdGhpcy5lYXRTdHJpbmcoJ30nKSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9jaCA9PT0gJ3snKSB7XG4gICAgICBpZiAoaW5zaWRlUHJvcGVydHlWYWx1ZSkge1xuICAgICAgICBpbnNpZGVQcm9wZXJ0eVZhbHVlID0gZmFsc2U7XG4gICAgICAgIHRoaXMub3V0ZGVudCgpO1xuICAgICAgfVxuXG4gICAgICAvLyB3aGVuIGVudGVyaW5nIGNvbmRpdGlvbmFsIGdyb3Vwcywgb25seSBydWxlc2V0cyBhcmUgYWxsb3dlZFxuICAgICAgaWYgKGVudGVyaW5nQ29uZGl0aW9uYWxHcm91cCkge1xuICAgICAgICBlbnRlcmluZ0NvbmRpdGlvbmFsR3JvdXAgPSBmYWxzZTtcbiAgICAgICAgaW5zaWRlUnVsZSA9ICh0aGlzLl9pbmRlbnRMZXZlbCA+PSB0aGlzLl9uZXN0ZWRMZXZlbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBvdGhlcndpc2UsIGRlY2xhcmF0aW9ucyBhcmUgYWxzbyBhbGxvd2VkXG4gICAgICAgIGluc2lkZVJ1bGUgPSAodGhpcy5faW5kZW50TGV2ZWwgPj0gdGhpcy5fbmVzdGVkTGV2ZWwgLSAxKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9vcHRpb25zLm5ld2xpbmVfYmV0d2Vlbl9ydWxlcyAmJiBpbnNpZGVSdWxlKSB7XG4gICAgICAgIGlmICh0aGlzLl9vdXRwdXQucHJldmlvdXNfbGluZSAmJiB0aGlzLl9vdXRwdXQucHJldmlvdXNfbGluZS5pdGVtKC0xKSAhPT0gJ3snKSB7XG4gICAgICAgICAgdGhpcy5fb3V0cHV0LmVuc3VyZV9lbXB0eV9saW5lX2Fib3ZlKCcvJywgJywnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcblxuICAgICAgLy8gVGhlIGRpZmZlcmVuY2UgaW4gcHJpbnRfc3RyaW5nIGFuZCBpbmRlbnQgb3JkZXIgaXMgbmVjZXNzYXJ5IHRvIGluZGVudCB0aGUgJ3snIGNvcnJlY3RseVxuICAgICAgaWYgKHRoaXMuX29wdGlvbnMuYnJhY2Vfc3R5bGUgPT09ICdleHBhbmQnKSB7XG4gICAgICAgIHRoaXMuX291dHB1dC5hZGRfbmV3X2xpbmUoKTtcbiAgICAgICAgdGhpcy5wcmludF9zdHJpbmcodGhpcy5fY2gpO1xuICAgICAgICB0aGlzLmluZGVudCgpO1xuICAgICAgICB0aGlzLl9vdXRwdXQuc2V0X2luZGVudCh0aGlzLl9pbmRlbnRMZXZlbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmluZGVudCgpO1xuICAgICAgICB0aGlzLnByaW50X3N0cmluZyh0aGlzLl9jaCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZWF0V2hpdGVzcGFjZSh0cnVlKTtcbiAgICAgIHRoaXMuX291dHB1dC5hZGRfbmV3X2xpbmUoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2NoID09PSAnfScpIHtcbiAgICAgIHRoaXMub3V0ZGVudCgpO1xuICAgICAgdGhpcy5fb3V0cHV0LmFkZF9uZXdfbGluZSgpO1xuICAgICAgaWYgKHByZXZpb3VzX2NoID09PSAneycpIHtcbiAgICAgICAgdGhpcy5fb3V0cHV0LnRyaW0odHJ1ZSk7XG4gICAgICB9XG4gICAgICBpbnNpZGVBdEltcG9ydCA9IGZhbHNlO1xuICAgICAgaW5zaWRlQXRFeHRlbmQgPSBmYWxzZTtcbiAgICAgIGlmIChpbnNpZGVQcm9wZXJ0eVZhbHVlKSB7XG4gICAgICAgIHRoaXMub3V0ZGVudCgpO1xuICAgICAgICBpbnNpZGVQcm9wZXJ0eVZhbHVlID0gZmFsc2U7XG4gICAgICB9XG4gICAgICB0aGlzLnByaW50X3N0cmluZyh0aGlzLl9jaCk7XG4gICAgICBpbnNpZGVSdWxlID0gZmFsc2U7XG4gICAgICBpZiAodGhpcy5fbmVzdGVkTGV2ZWwpIHtcbiAgICAgICAgdGhpcy5fbmVzdGVkTGV2ZWwtLTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5lYXRXaGl0ZXNwYWNlKHRydWUpO1xuICAgICAgdGhpcy5fb3V0cHV0LmFkZF9uZXdfbGluZSgpO1xuXG4gICAgICBpZiAodGhpcy5fb3B0aW9ucy5uZXdsaW5lX2JldHdlZW5fcnVsZXMgJiYgIXRoaXMuX291dHB1dC5qdXN0X2FkZGVkX2JsYW5rbGluZSgpKSB7XG4gICAgICAgIGlmICh0aGlzLl9pbnB1dC5wZWVrKCkgIT09ICd9Jykge1xuICAgICAgICAgIHRoaXMuX291dHB1dC5hZGRfbmV3X2xpbmUodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuX2NoID09PSBcIjpcIikge1xuICAgICAgaWYgKChpbnNpZGVSdWxlIHx8IGVudGVyaW5nQ29uZGl0aW9uYWxHcm91cCkgJiYgISh0aGlzLl9pbnB1dC5sb29rQmFjayhcIiZcIikgfHwgdGhpcy5mb3VuZE5lc3RlZFBzZXVkb0NsYXNzKCkpICYmICF0aGlzLl9pbnB1dC5sb29rQmFjayhcIihcIikgJiYgIWluc2lkZUF0RXh0ZW5kICYmIHBhcmVuTGV2ZWwgPT09IDApIHtcbiAgICAgICAgLy8gJ3Byb3BlcnR5OiB2YWx1ZScgZGVsaW1pdGVyXG4gICAgICAgIC8vIHdoaWNoIGNvdWxkIGJlIGluIGEgY29uZGl0aW9uYWwgZ3JvdXAgcXVlcnlcbiAgICAgICAgdGhpcy5wcmludF9zdHJpbmcoJzonKTtcbiAgICAgICAgaWYgKCFpbnNpZGVQcm9wZXJ0eVZhbHVlKSB7XG4gICAgICAgICAgaW5zaWRlUHJvcGVydHlWYWx1ZSA9IHRydWU7XG4gICAgICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICAgICAgdGhpcy5lYXRXaGl0ZXNwYWNlKHRydWUpO1xuICAgICAgICAgIHRoaXMuaW5kZW50KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHNhc3MvbGVzcyBwYXJlbnQgcmVmZXJlbmNlIGRvbid0IHVzZSBhIHNwYWNlXG4gICAgICAgIC8vIHNhc3MgbmVzdGVkIHBzZXVkby1jbGFzcyBkb24ndCB1c2UgYSBzcGFjZVxuXG4gICAgICAgIC8vIHByZXNlcnZlIHNwYWNlIGJlZm9yZSBwc2V1ZG9jbGFzc2VzL3BzZXVkb2VsZW1lbnRzLCBhcyBpdCBtZWFucyBcImluIGFueSBjaGlsZFwiXG4gICAgICAgIGlmICh0aGlzLl9pbnB1dC5sb29rQmFjayhcIiBcIikpIHtcbiAgICAgICAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5faW5wdXQucGVlaygpID09PSBcIjpcIikge1xuICAgICAgICAgIC8vIHBzZXVkby1lbGVtZW50XG4gICAgICAgICAgdGhpcy5fY2ggPSB0aGlzLl9pbnB1dC5uZXh0KCk7XG4gICAgICAgICAgdGhpcy5wcmludF9zdHJpbmcoXCI6OlwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBwc2V1ZG8tY2xhc3NcbiAgICAgICAgICB0aGlzLnByaW50X3N0cmluZygnOicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLl9jaCA9PT0gJ1wiJyB8fCB0aGlzLl9jaCA9PT0gJ1xcJycpIHtcbiAgICAgIHRoaXMucHJlc2VydmVTaW5nbGVTcGFjZShpc0FmdGVyU3BhY2UpO1xuICAgICAgdGhpcy5wcmludF9zdHJpbmcodGhpcy5fY2ggKyB0aGlzLmVhdFN0cmluZyh0aGlzLl9jaCkpO1xuICAgICAgdGhpcy5lYXRXaGl0ZXNwYWNlKHRydWUpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fY2ggPT09ICc7Jykge1xuICAgICAgaWYgKHBhcmVuTGV2ZWwgPT09IDApIHtcbiAgICAgICAgaWYgKGluc2lkZVByb3BlcnR5VmFsdWUpIHtcbiAgICAgICAgICB0aGlzLm91dGRlbnQoKTtcbiAgICAgICAgICBpbnNpZGVQcm9wZXJ0eVZhbHVlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaW5zaWRlQXRFeHRlbmQgPSBmYWxzZTtcbiAgICAgICAgaW5zaWRlQXRJbXBvcnQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wcmludF9zdHJpbmcodGhpcy5fY2gpO1xuICAgICAgICB0aGlzLmVhdFdoaXRlc3BhY2UodHJ1ZSk7XG5cbiAgICAgICAgLy8gVGhpcyBtYWludGFpbnMgc2luZ2xlIGxpbmUgY29tbWVudHMgb24gdGhlIHNhbWVcbiAgICAgICAgLy8gbGluZS4gQmxvY2sgY29tbWVudHMgYXJlIGFsc28gYWZmZWN0ZWQsIGJ1dFxuICAgICAgICAvLyBhIG5ldyBsaW5lIGlzIGFsd2F5cyBvdXRwdXQgYmVmb3JlIG9uZSBpbnNpZGVcbiAgICAgICAgLy8gdGhhdCBzZWN0aW9uXG4gICAgICAgIGlmICh0aGlzLl9pbnB1dC5wZWVrKCkgIT09ICcvJykge1xuICAgICAgICAgIHRoaXMuX291dHB1dC5hZGRfbmV3X2xpbmUoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wcmludF9zdHJpbmcodGhpcy5fY2gpO1xuICAgICAgICB0aGlzLmVhdFdoaXRlc3BhY2UodHJ1ZSk7XG4gICAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5fY2ggPT09ICcoJykgeyAvLyBtYXkgYmUgYSB1cmxcbiAgICAgIGlmICh0aGlzLl9pbnB1dC5sb29rQmFjayhcInVybFwiKSkge1xuICAgICAgICB0aGlzLnByaW50X3N0cmluZyh0aGlzLl9jaCk7XG4gICAgICAgIHRoaXMuZWF0V2hpdGVzcGFjZSgpO1xuICAgICAgICBwYXJlbkxldmVsKys7XG4gICAgICAgIHRoaXMuaW5kZW50KCk7XG4gICAgICAgIHRoaXMuX2NoID0gdGhpcy5faW5wdXQubmV4dCgpO1xuICAgICAgICBpZiAodGhpcy5fY2ggPT09ICcpJyB8fCB0aGlzLl9jaCA9PT0gJ1wiJyB8fCB0aGlzLl9jaCA9PT0gJ1xcJycpIHtcbiAgICAgICAgICB0aGlzLl9pbnB1dC5iYWNrKCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fY2gpIHtcbiAgICAgICAgICB0aGlzLnByaW50X3N0cmluZyh0aGlzLl9jaCArIHRoaXMuZWF0U3RyaW5nKCcpJykpO1xuICAgICAgICAgIGlmIChwYXJlbkxldmVsKSB7XG4gICAgICAgICAgICBwYXJlbkxldmVsLS07XG4gICAgICAgICAgICB0aGlzLm91dGRlbnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucHJlc2VydmVTaW5nbGVTcGFjZShpc0FmdGVyU3BhY2UpO1xuICAgICAgICB0aGlzLnByaW50X3N0cmluZyh0aGlzLl9jaCk7XG4gICAgICAgIHRoaXMuZWF0V2hpdGVzcGFjZSgpO1xuICAgICAgICBwYXJlbkxldmVsKys7XG4gICAgICAgIHRoaXMuaW5kZW50KCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLl9jaCA9PT0gJyknKSB7XG4gICAgICBpZiAocGFyZW5MZXZlbCkge1xuICAgICAgICBwYXJlbkxldmVsLS07XG4gICAgICAgIHRoaXMub3V0ZGVudCgpO1xuICAgICAgfVxuICAgICAgdGhpcy5wcmludF9zdHJpbmcodGhpcy5fY2gpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fY2ggPT09ICcsJykge1xuICAgICAgdGhpcy5wcmludF9zdHJpbmcodGhpcy5fY2gpO1xuICAgICAgdGhpcy5lYXRXaGl0ZXNwYWNlKHRydWUpO1xuICAgICAgaWYgKHRoaXMuX29wdGlvbnMuc2VsZWN0b3Jfc2VwYXJhdG9yX25ld2xpbmUgJiYgIWluc2lkZVByb3BlcnR5VmFsdWUgJiYgcGFyZW5MZXZlbCA9PT0gMCAmJiAhaW5zaWRlQXRJbXBvcnQpIHtcbiAgICAgICAgdGhpcy5fb3V0cHV0LmFkZF9uZXdfbGluZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICgodGhpcy5fY2ggPT09ICc+JyB8fCB0aGlzLl9jaCA9PT0gJysnIHx8IHRoaXMuX2NoID09PSAnficpICYmICFpbnNpZGVQcm9wZXJ0eVZhbHVlICYmIHBhcmVuTGV2ZWwgPT09IDApIHtcbiAgICAgIC8vaGFuZGxlIGNvbWJpbmF0b3Igc3BhY2luZ1xuICAgICAgaWYgKHRoaXMuX29wdGlvbnMuc3BhY2VfYXJvdW5kX2NvbWJpbmF0b3IpIHtcbiAgICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICAgIHRoaXMucHJpbnRfc3RyaW5nKHRoaXMuX2NoKTtcbiAgICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnByaW50X3N0cmluZyh0aGlzLl9jaCk7XG4gICAgICAgIHRoaXMuZWF0V2hpdGVzcGFjZSgpO1xuICAgICAgICAvLyBzcXVhc2ggZXh0cmEgd2hpdGVzcGFjZVxuICAgICAgICBpZiAodGhpcy5fY2ggJiYgd2hpdGVzcGFjZUNoYXIudGVzdCh0aGlzLl9jaCkpIHtcbiAgICAgICAgICB0aGlzLl9jaCA9ICcnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLl9jaCA9PT0gJ10nKSB7XG4gICAgICB0aGlzLnByaW50X3N0cmluZyh0aGlzLl9jaCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9jaCA9PT0gJ1snKSB7XG4gICAgICB0aGlzLnByZXNlcnZlU2luZ2xlU3BhY2UoaXNBZnRlclNwYWNlKTtcbiAgICAgIHRoaXMucHJpbnRfc3RyaW5nKHRoaXMuX2NoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2NoID09PSAnPScpIHsgLy8gbm8gd2hpdGVzcGFjZSBiZWZvcmUgb3IgYWZ0ZXJcbiAgICAgIHRoaXMuZWF0V2hpdGVzcGFjZSgpO1xuICAgICAgdGhpcy5wcmludF9zdHJpbmcoJz0nKTtcbiAgICAgIGlmICh3aGl0ZXNwYWNlQ2hhci50ZXN0KHRoaXMuX2NoKSkge1xuICAgICAgICB0aGlzLl9jaCA9ICcnO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5fY2ggPT09ICchJyAmJiAhdGhpcy5faW5wdXQubG9va0JhY2soXCJcXFxcXCIpKSB7IC8vICFpbXBvcnRhbnRcbiAgICAgIHRoaXMucHJpbnRfc3RyaW5nKCcgJyk7XG4gICAgICB0aGlzLnByaW50X3N0cmluZyh0aGlzLl9jaCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucHJlc2VydmVTaW5nbGVTcGFjZShpc0FmdGVyU3BhY2UpO1xuICAgICAgdGhpcy5wcmludF9zdHJpbmcodGhpcy5fY2gpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBzd2VldENvZGUgPSB0aGlzLl9vdXRwdXQuZ2V0X2NvZGUoZW9sKTtcblxuICByZXR1cm4gc3dlZXRDb2RlO1xufTtcblxubW9kdWxlLmV4cG9ydHMuQmVhdXRpZmllciA9IEJlYXV0aWZpZXI7XG5cblxuLyoqKi8gfSksXG4vKiAxNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qanNoaW50IG5vZGU6dHJ1ZSAqL1xuLypcblxuICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxOCBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgU09GVFdBUkUuXG4qL1xuXG5cblxudmFyIEJhc2VPcHRpb25zID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KS5PcHRpb25zO1xuXG5mdW5jdGlvbiBPcHRpb25zKG9wdGlvbnMpIHtcbiAgQmFzZU9wdGlvbnMuY2FsbCh0aGlzLCBvcHRpb25zLCAnY3NzJyk7XG5cbiAgdGhpcy5zZWxlY3Rvcl9zZXBhcmF0b3JfbmV3bGluZSA9IHRoaXMuX2dldF9ib29sZWFuKCdzZWxlY3Rvcl9zZXBhcmF0b3JfbmV3bGluZScsIHRydWUpO1xuICB0aGlzLm5ld2xpbmVfYmV0d2Vlbl9ydWxlcyA9IHRoaXMuX2dldF9ib29sZWFuKCduZXdsaW5lX2JldHdlZW5fcnVsZXMnLCB0cnVlKTtcbiAgdmFyIHNwYWNlX2Fyb3VuZF9zZWxlY3Rvcl9zZXBhcmF0b3IgPSB0aGlzLl9nZXRfYm9vbGVhbignc3BhY2VfYXJvdW5kX3NlbGVjdG9yX3NlcGFyYXRvcicpO1xuICB0aGlzLnNwYWNlX2Fyb3VuZF9jb21iaW5hdG9yID0gdGhpcy5fZ2V0X2Jvb2xlYW4oJ3NwYWNlX2Fyb3VuZF9jb21iaW5hdG9yJykgfHwgc3BhY2VfYXJvdW5kX3NlbGVjdG9yX3NlcGFyYXRvcjtcblxuICB2YXIgYnJhY2Vfc3R5bGVfc3BsaXQgPSB0aGlzLl9nZXRfc2VsZWN0aW9uX2xpc3QoJ2JyYWNlX3N0eWxlJywgWydjb2xsYXBzZScsICdleHBhbmQnLCAnZW5kLWV4cGFuZCcsICdub25lJywgJ3ByZXNlcnZlLWlubGluZSddKTtcbiAgdGhpcy5icmFjZV9zdHlsZSA9ICdjb2xsYXBzZSc7XG4gIGZvciAodmFyIGJzID0gMDsgYnMgPCBicmFjZV9zdHlsZV9zcGxpdC5sZW5ndGg7IGJzKyspIHtcbiAgICBpZiAoYnJhY2Vfc3R5bGVfc3BsaXRbYnNdICE9PSAnZXhwYW5kJykge1xuICAgICAgLy8gZGVmYXVsdCB0byBjb2xsYXBzZSwgYXMgb25seSBjb2xsYXBzZXxleHBhbmQgaXMgaW1wbGVtZW50ZWQgZm9yIG5vd1xuICAgICAgdGhpcy5icmFjZV9zdHlsZSA9ICdjb2xsYXBzZSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYnJhY2Vfc3R5bGUgPSBicmFjZV9zdHlsZV9zcGxpdFtic107XG4gICAgfVxuICB9XG59XG5PcHRpb25zLnByb3RvdHlwZSA9IG5ldyBCYXNlT3B0aW9ucygpO1xuXG5cblxubW9kdWxlLmV4cG9ydHMuT3B0aW9ucyA9IE9wdGlvbnM7XG5cblxuLyoqKi8gfSlcbi8qKioqKiovIF0pO1xudmFyIGNzc19iZWF1dGlmeSA9IGxlZ2FjeV9iZWF1dGlmeV9jc3M7XG4vKiBGb290ZXIgKi9cbmlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuICAgIC8vIEFkZCBzdXBwb3J0IGZvciBBTUQgKCBodHRwczovL2dpdGh1Yi5jb20vYW1kanMvYW1kanMtYXBpL3dpa2kvQU1EI2RlZmluZWFtZC1wcm9wZXJ0eS0gKVxuICAgIGRlZmluZShbXSwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjc3NfYmVhdXRpZnk6IGNzc19iZWF1dGlmeVxuICAgICAgICB9O1xuICAgIH0pO1xufSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIC8vIEFkZCBzdXBwb3J0IGZvciBDb21tb25KUy4gSnVzdCBwdXQgdGhpcyBmaWxlIHNvbWV3aGVyZSBvbiB5b3VyIHJlcXVpcmUucGF0aHNcbiAgICAvLyBhbmQgeW91IHdpbGwgYmUgYWJsZSB0byBgdmFyIGh0bWxfYmVhdXRpZnkgPSByZXF1aXJlKFwiYmVhdXRpZnlcIikuaHRtbF9iZWF1dGlmeWAuXG4gICAgZXhwb3J0cy5jc3NfYmVhdXRpZnkgPSBjc3NfYmVhdXRpZnk7XG59IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAvLyBJZiB3ZSdyZSBydW5uaW5nIGEgd2ViIHBhZ2UgYW5kIGRvbid0IGhhdmUgZWl0aGVyIG9mIHRoZSBhYm92ZSwgYWRkIG91ciBvbmUgZ2xvYmFsXG4gICAgd2luZG93LmNzc19iZWF1dGlmeSA9IGNzc19iZWF1dGlmeTtcbn0gZWxzZSBpZiAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIC8vIElmIHdlIGRvbid0IGV2ZW4gaGF2ZSB3aW5kb3csIHRyeSBnbG9iYWwuXG4gICAgZ2xvYmFsLmNzc19iZWF1dGlmeSA9IGNzc19iZWF1dGlmeTtcbn1cblxufSgpKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/js-beautify/js/lib/beautify-css.js\n");

/***/ }),

/***/ "./node_modules/js-beautify/js/lib/beautify-html.js":
/*!**********************************************************!*\
  !*** ./node_modules/js-beautify/js/lib/beautify-html.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* AUTO-GENERATED. DO NOT MODIFY. */\n/*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n\n\n Style HTML\n---------------\n\n  Written by Nochum Sossonko, (nsossonko@hotmail.com)\n\n  Based on code initially developed by: Einar Lielmanis, <einar@beautifier.io>\n    https://beautifier.io/\n\n  Usage:\n    style_html(html_source);\n\n    style_html(html_source, options);\n\n  The options are:\n    indent_inner_html (default false)  — indent <head> and <body> sections,\n    indent_size (default 4)          — indentation size,\n    indent_char (default space)      — character to indent with,\n    wrap_line_length (default 250)            -  maximum amount of characters per line (0 = disable)\n    brace_style (default \"collapse\") - \"collapse\" | \"expand\" | \"end-expand\" | \"none\"\n            put braces on the same line as control statements (default), or put braces on own line (Allman / ANSI style), or just put end braces on own line, or attempt to keep them where they are.\n    inline (defaults to inline tags) - list of tags to be considered inline tags\n    unformatted (defaults to inline tags) - list of tags, that shouldn't be reformatted\n    content_unformatted (defaults to [\"pre\", \"textarea\"] tags) - list of tags, whose content shouldn't be reformatted\n    indent_scripts (default normal)  - \"keep\"|\"separate\"|\"normal\"\n    preserve_newlines (default true) - whether existing line breaks before elements should be preserved\n                                        Only works before elements, not inside tags or for text.\n    max_preserve_newlines (default unlimited) - maximum number of line breaks to be preserved in one chunk\n    indent_handlebars (default false) - format and indent {{#foo}} and {{/foo}}\n    end_with_newline (false)          - end with a newline\n    extra_liners (default [head,body,/html]) -List of tags that should have an extra newline before them.\n\n    e.g.\n\n    style_html(html_source, {\n      'indent_inner_html': false,\n      'indent_size': 2,\n      'indent_char': ' ',\n      'wrap_line_length': 78,\n      'brace_style': 'expand',\n      'preserve_newlines': true,\n      'max_preserve_newlines': 5,\n      'indent_handlebars': false,\n      'extra_liners': ['/html']\n    });\n*/\n\n(function() {\n\n/* GENERATED_BUILD_OUTPUT */\nvar legacy_beautify_html =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 18);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */,\n/* 1 */,\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*jshint node:true */\n/*\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/\n\n\n\nfunction OutputLine(parent) {\n  this.__parent = parent;\n  this.__character_count = 0;\n  // use indent_count as a marker for this.__lines that have preserved indentation\n  this.__indent_count = -1;\n  this.__alignment_count = 0;\n  this.__wrap_point_index = 0;\n  this.__wrap_point_character_count = 0;\n  this.__wrap_point_indent_count = -1;\n  this.__wrap_point_alignment_count = 0;\n\n  this.__items = [];\n}\n\nOutputLine.prototype.clone_empty = function() {\n  var line = new OutputLine(this.__parent);\n  line.set_indent(this.__indent_count, this.__alignment_count);\n  return line;\n};\n\nOutputLine.prototype.item = function(index) {\n  if (index < 0) {\n    return this.__items[this.__items.length + index];\n  } else {\n    return this.__items[index];\n  }\n};\n\nOutputLine.prototype.has_match = function(pattern) {\n  for (var lastCheckedOutput = this.__items.length - 1; lastCheckedOutput >= 0; lastCheckedOutput--) {\n    if (this.__items[lastCheckedOutput].match(pattern)) {\n      return true;\n    }\n  }\n  return false;\n};\n\nOutputLine.prototype.set_indent = function(indent, alignment) {\n  if (this.is_empty()) {\n    this.__indent_count = indent || 0;\n    this.__alignment_count = alignment || 0;\n    this.__character_count = this.__parent.get_indent_size(this.__indent_count, this.__alignment_count);\n  }\n};\n\nOutputLine.prototype._set_wrap_point = function() {\n  if (this.__parent.wrap_line_length) {\n    this.__wrap_point_index = this.__items.length;\n    this.__wrap_point_character_count = this.__character_count;\n    this.__wrap_point_indent_count = this.__parent.next_line.__indent_count;\n    this.__wrap_point_alignment_count = this.__parent.next_line.__alignment_count;\n  }\n};\n\nOutputLine.prototype._should_wrap = function() {\n  return this.__wrap_point_index &&\n    this.__character_count > this.__parent.wrap_line_length &&\n    this.__wrap_point_character_count > this.__parent.next_line.__character_count;\n};\n\nOutputLine.prototype._allow_wrap = function() {\n  if (this._should_wrap()) {\n    this.__parent.add_new_line();\n    var next = this.__parent.current_line;\n    next.set_indent(this.__wrap_point_indent_count, this.__wrap_point_alignment_count);\n    next.__items = this.__items.slice(this.__wrap_point_index);\n    this.__items = this.__items.slice(0, this.__wrap_point_index);\n\n    next.__character_count += this.__character_count - this.__wrap_point_character_count;\n    this.__character_count = this.__wrap_point_character_count;\n\n    if (next.__items[0] === \" \") {\n      next.__items.splice(0, 1);\n      next.__character_count -= 1;\n    }\n    return true;\n  }\n  return false;\n};\n\nOutputLine.prototype.is_empty = function() {\n  return this.__items.length === 0;\n};\n\nOutputLine.prototype.last = function() {\n  if (!this.is_empty()) {\n    return this.__items[this.__items.length - 1];\n  } else {\n    return null;\n  }\n};\n\nOutputLine.prototype.push = function(item) {\n  this.__items.push(item);\n  var last_newline_index = item.lastIndexOf('\\n');\n  if (last_newline_index !== -1) {\n    this.__character_count = item.length - last_newline_index;\n  } else {\n    this.__character_count += item.length;\n  }\n};\n\nOutputLine.prototype.pop = function() {\n  var item = null;\n  if (!this.is_empty()) {\n    item = this.__items.pop();\n    this.__character_count -= item.length;\n  }\n  return item;\n};\n\n\nOutputLine.prototype._remove_indent = function() {\n  if (this.__indent_count > 0) {\n    this.__indent_count -= 1;\n    this.__character_count -= this.__parent.indent_size;\n  }\n};\n\nOutputLine.prototype._remove_wrap_indent = function() {\n  if (this.__wrap_point_indent_count > 0) {\n    this.__wrap_point_indent_count -= 1;\n  }\n};\nOutputLine.prototype.trim = function() {\n  while (this.last() === ' ') {\n    this.__items.pop();\n    this.__character_count -= 1;\n  }\n};\n\nOutputLine.prototype.toString = function() {\n  var result = '';\n  if (this.is_empty()) {\n    if (this.__parent.indent_empty_lines) {\n      result = this.__parent.get_indent_string(this.__indent_count);\n    }\n  } else {\n    result = this.__parent.get_indent_string(this.__indent_count, this.__alignment_count);\n    result += this.__items.join('');\n  }\n  return result;\n};\n\nfunction IndentStringCache(options, baseIndentString) {\n  this.__cache = [''];\n  this.__indent_size = options.indent_size;\n  this.__indent_string = options.indent_char;\n  if (!options.indent_with_tabs) {\n    this.__indent_string = new Array(options.indent_size + 1).join(options.indent_char);\n  }\n\n  // Set to null to continue support for auto detection of base indent\n  baseIndentString = baseIndentString || '';\n  if (options.indent_level > 0) {\n    baseIndentString = new Array(options.indent_level + 1).join(this.__indent_string);\n  }\n\n  this.__base_string = baseIndentString;\n  this.__base_string_length = baseIndentString.length;\n}\n\nIndentStringCache.prototype.get_indent_size = function(indent, column) {\n  var result = this.__base_string_length;\n  column = column || 0;\n  if (indent < 0) {\n    result = 0;\n  }\n  result += indent * this.__indent_size;\n  result += column;\n  return result;\n};\n\nIndentStringCache.prototype.get_indent_string = function(indent_level, column) {\n  var result = this.__base_string;\n  column = column || 0;\n  if (indent_level < 0) {\n    indent_level = 0;\n    result = '';\n  }\n  column += indent_level * this.__indent_size;\n  this.__ensure_cache(column);\n  result += this.__cache[column];\n  return result;\n};\n\nIndentStringCache.prototype.__ensure_cache = function(column) {\n  while (column >= this.__cache.length) {\n    this.__add_column();\n  }\n};\n\nIndentStringCache.prototype.__add_column = function() {\n  var column = this.__cache.length;\n  var indent = 0;\n  var result = '';\n  if (this.__indent_size && column >= this.__indent_size) {\n    indent = Math.floor(column / this.__indent_size);\n    column -= indent * this.__indent_size;\n    result = new Array(indent + 1).join(this.__indent_string);\n  }\n  if (column) {\n    result += new Array(column + 1).join(' ');\n  }\n\n  this.__cache.push(result);\n};\n\nfunction Output(options, baseIndentString) {\n  this.__indent_cache = new IndentStringCache(options, baseIndentString);\n  this.raw = false;\n  this._end_with_newline = options.end_with_newline;\n  this.indent_size = options.indent_size;\n  this.wrap_line_length = options.wrap_line_length;\n  this.indent_empty_lines = options.indent_empty_lines;\n  this.__lines = [];\n  this.previous_line = null;\n  this.current_line = null;\n  this.next_line = new OutputLine(this);\n  this.space_before_token = false;\n  this.non_breaking_space = false;\n  this.previous_token_wrapped = false;\n  // initialize\n  this.__add_outputline();\n}\n\nOutput.prototype.__add_outputline = function() {\n  this.previous_line = this.current_line;\n  this.current_line = this.next_line.clone_empty();\n  this.__lines.push(this.current_line);\n};\n\nOutput.prototype.get_line_number = function() {\n  return this.__lines.length;\n};\n\nOutput.prototype.get_indent_string = function(indent, column) {\n  return this.__indent_cache.get_indent_string(indent, column);\n};\n\nOutput.prototype.get_indent_size = function(indent, column) {\n  return this.__indent_cache.get_indent_size(indent, column);\n};\n\nOutput.prototype.is_empty = function() {\n  return !this.previous_line && this.current_line.is_empty();\n};\n\nOutput.prototype.add_new_line = function(force_newline) {\n  // never newline at the start of file\n  // otherwise, newline only if we didn't just add one or we're forced\n  if (this.is_empty() ||\n    (!force_newline && this.just_added_newline())) {\n    return false;\n  }\n\n  // if raw output is enabled, don't print additional newlines,\n  // but still return True as though you had\n  if (!this.raw) {\n    this.__add_outputline();\n  }\n  return true;\n};\n\nOutput.prototype.get_code = function(eol) {\n  this.trim(true);\n\n  // handle some edge cases where the last tokens\n  // has text that ends with newline(s)\n  var last_item = this.current_line.pop();\n  if (last_item) {\n    if (last_item[last_item.length - 1] === '\\n') {\n      last_item = last_item.replace(/\\n+$/g, '');\n    }\n    this.current_line.push(last_item);\n  }\n\n  if (this._end_with_newline) {\n    this.__add_outputline();\n  }\n\n  var sweet_code = this.__lines.join('\\n');\n\n  if (eol !== '\\n') {\n    sweet_code = sweet_code.replace(/[\\n]/g, eol);\n  }\n  return sweet_code;\n};\n\nOutput.prototype.set_wrap_point = function() {\n  this.current_line._set_wrap_point();\n};\n\nOutput.prototype.set_indent = function(indent, alignment) {\n  indent = indent || 0;\n  alignment = alignment || 0;\n\n  // Next line stores alignment values\n  this.next_line.set_indent(indent, alignment);\n\n  // Never indent your first output indent at the start of the file\n  if (this.__lines.length > 1) {\n    this.current_line.set_indent(indent, alignment);\n    return true;\n  }\n\n  this.current_line.set_indent();\n  return false;\n};\n\nOutput.prototype.add_raw_token = function(token) {\n  for (var x = 0; x < token.newlines; x++) {\n    this.__add_outputline();\n  }\n  this.current_line.set_indent(-1);\n  this.current_line.push(token.whitespace_before);\n  this.current_line.push(token.text);\n  this.space_before_token = false;\n  this.non_breaking_space = false;\n  this.previous_token_wrapped = false;\n};\n\nOutput.prototype.add_token = function(printable_token) {\n  this.__add_space_before_token();\n  this.current_line.push(printable_token);\n  this.space_before_token = false;\n  this.non_breaking_space = false;\n  this.previous_token_wrapped = this.current_line._allow_wrap();\n};\n\nOutput.prototype.__add_space_before_token = function() {\n  if (this.space_before_token && !this.just_added_newline()) {\n    if (!this.non_breaking_space) {\n      this.set_wrap_point();\n    }\n    this.current_line.push(' ');\n  }\n};\n\nOutput.prototype.remove_indent = function(index) {\n  var output_length = this.__lines.length;\n  while (index < output_length) {\n    this.__lines[index]._remove_indent();\n    index++;\n  }\n  this.current_line._remove_wrap_indent();\n};\n\nOutput.prototype.trim = function(eat_newlines) {\n  eat_newlines = (eat_newlines === undefined) ? false : eat_newlines;\n\n  this.current_line.trim();\n\n  while (eat_newlines && this.__lines.length > 1 &&\n    this.current_line.is_empty()) {\n    this.__lines.pop();\n    this.current_line = this.__lines[this.__lines.length - 1];\n    this.current_line.trim();\n  }\n\n  this.previous_line = this.__lines.length > 1 ?\n    this.__lines[this.__lines.length - 2] : null;\n};\n\nOutput.prototype.just_added_newline = function() {\n  return this.current_line.is_empty();\n};\n\nOutput.prototype.just_added_blankline = function() {\n  return this.is_empty() ||\n    (this.current_line.is_empty() && this.previous_line.is_empty());\n};\n\nOutput.prototype.ensure_empty_line_above = function(starts_with, ends_with) {\n  var index = this.__lines.length - 2;\n  while (index >= 0) {\n    var potentialEmptyLine = this.__lines[index];\n    if (potentialEmptyLine.is_empty()) {\n      break;\n    } else if (potentialEmptyLine.item(0).indexOf(starts_with) !== 0 &&\n      potentialEmptyLine.item(-1) !== ends_with) {\n      this.__lines.splice(index + 1, 0, new OutputLine(this));\n      this.previous_line = this.__lines[this.__lines.length - 2];\n      break;\n    }\n    index--;\n  }\n};\n\nmodule.exports.Output = Output;\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*jshint node:true */\n/*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/\n\n\n\nfunction Token(type, text, newlines, whitespace_before) {\n  this.type = type;\n  this.text = text;\n\n  // comments_before are\n  // comments that have a new line before them\n  // and may or may not have a newline after\n  // this is a set of comments before\n  this.comments_before = null; /* inline comment*/\n\n\n  // this.comments_after =  new TokenStream(); // no new line before and newline after\n  this.newlines = newlines || 0;\n  this.whitespace_before = whitespace_before || '';\n  this.parent = null;\n  this.next = null;\n  this.previous = null;\n  this.opened = null;\n  this.closed = null;\n  this.directives = null;\n}\n\n\nmodule.exports.Token = Token;\n\n\n/***/ }),\n/* 4 */,\n/* 5 */,\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*jshint node:true */\n/*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/\n\n\n\nfunction Options(options, merge_child_field) {\n  this.raw_options = _mergeOpts(options, merge_child_field);\n\n  // Support passing the source text back with no change\n  this.disabled = this._get_boolean('disabled');\n\n  this.eol = this._get_characters('eol', 'auto');\n  this.end_with_newline = this._get_boolean('end_with_newline');\n  this.indent_size = this._get_number('indent_size', 4);\n  this.indent_char = this._get_characters('indent_char', ' ');\n  this.indent_level = this._get_number('indent_level');\n\n  this.preserve_newlines = this._get_boolean('preserve_newlines', true);\n  this.max_preserve_newlines = this._get_number('max_preserve_newlines', 32786);\n  if (!this.preserve_newlines) {\n    this.max_preserve_newlines = 0;\n  }\n\n  this.indent_with_tabs = this._get_boolean('indent_with_tabs', this.indent_char === '\\t');\n  if (this.indent_with_tabs) {\n    this.indent_char = '\\t';\n\n    // indent_size behavior changed after 1.8.6\n    // It used to be that indent_size would be\n    // set to 1 for indent_with_tabs. That is no longer needed and\n    // actually doesn't make sense - why not use spaces? Further,\n    // that might produce unexpected behavior - tabs being used\n    // for single-column alignment. So, when indent_with_tabs is true\n    // and indent_size is 1, reset indent_size to 4.\n    if (this.indent_size === 1) {\n      this.indent_size = 4;\n    }\n  }\n\n  // Backwards compat with 1.3.x\n  this.wrap_line_length = this._get_number('wrap_line_length', this._get_number('max_char'));\n\n  this.indent_empty_lines = this._get_boolean('indent_empty_lines');\n\n  // valid templating languages ['django', 'erb', 'handlebars', 'php']\n  // For now, 'auto' = all off for javascript, all on for html (and inline javascript).\n  // other values ignored\n  this.templating = this._get_selection_list('templating', ['auto', 'none', 'django', 'erb', 'handlebars', 'php'], ['auto']);\n}\n\nOptions.prototype._get_array = function(name, default_value) {\n  var option_value = this.raw_options[name];\n  var result = default_value || [];\n  if (typeof option_value === 'object') {\n    if (option_value !== null && typeof option_value.concat === 'function') {\n      result = option_value.concat();\n    }\n  } else if (typeof option_value === 'string') {\n    result = option_value.split(/[^a-zA-Z0-9_\\/\\-]+/);\n  }\n  return result;\n};\n\nOptions.prototype._get_boolean = function(name, default_value) {\n  var option_value = this.raw_options[name];\n  var result = option_value === undefined ? !!default_value : !!option_value;\n  return result;\n};\n\nOptions.prototype._get_characters = function(name, default_value) {\n  var option_value = this.raw_options[name];\n  var result = default_value || '';\n  if (typeof option_value === 'string') {\n    result = option_value.replace(/\\\\r/, '\\r').replace(/\\\\n/, '\\n').replace(/\\\\t/, '\\t');\n  }\n  return result;\n};\n\nOptions.prototype._get_number = function(name, default_value) {\n  var option_value = this.raw_options[name];\n  default_value = parseInt(default_value, 10);\n  if (isNaN(default_value)) {\n    default_value = 0;\n  }\n  var result = parseInt(option_value, 10);\n  if (isNaN(result)) {\n    result = default_value;\n  }\n  return result;\n};\n\nOptions.prototype._get_selection = function(name, selection_list, default_value) {\n  var result = this._get_selection_list(name, selection_list, default_value);\n  if (result.length !== 1) {\n    throw new Error(\n      \"Invalid Option Value: The option '\" + name + \"' can only be one of the following values:\\n\" +\n      selection_list + \"\\nYou passed in: '\" + this.raw_options[name] + \"'\");\n  }\n\n  return result[0];\n};\n\n\nOptions.prototype._get_selection_list = function(name, selection_list, default_value) {\n  if (!selection_list || selection_list.length === 0) {\n    throw new Error(\"Selection list cannot be empty.\");\n  }\n\n  default_value = default_value || [selection_list[0]];\n  if (!this._is_valid_selection(default_value, selection_list)) {\n    throw new Error(\"Invalid Default Value!\");\n  }\n\n  var result = this._get_array(name, default_value);\n  if (!this._is_valid_selection(result, selection_list)) {\n    throw new Error(\n      \"Invalid Option Value: The option '\" + name + \"' can contain only the following values:\\n\" +\n      selection_list + \"\\nYou passed in: '\" + this.raw_options[name] + \"'\");\n  }\n\n  return result;\n};\n\nOptions.prototype._is_valid_selection = function(result, selection_list) {\n  return result.length && selection_list.length &&\n    !result.some(function(item) { return selection_list.indexOf(item) === -1; });\n};\n\n\n// merges child options up with the parent options object\n// Example: obj = {a: 1, b: {a: 2}}\n//          mergeOpts(obj, 'b')\n//\n//          Returns: {a: 2}\nfunction _mergeOpts(allOptions, childFieldName) {\n  var finalOpts = {};\n  allOptions = _normalizeOpts(allOptions);\n  var name;\n\n  for (name in allOptions) {\n    if (name !== childFieldName) {\n      finalOpts[name] = allOptions[name];\n    }\n  }\n\n  //merge in the per type settings for the childFieldName\n  if (childFieldName && allOptions[childFieldName]) {\n    for (name in allOptions[childFieldName]) {\n      finalOpts[name] = allOptions[childFieldName][name];\n    }\n  }\n  return finalOpts;\n}\n\nfunction _normalizeOpts(options) {\n  var convertedOpts = {};\n  var key;\n\n  for (key in options) {\n    var newKey = key.replace(/-/g, \"_\");\n    convertedOpts[newKey] = options[key];\n  }\n  return convertedOpts;\n}\n\nmodule.exports.Options = Options;\nmodule.exports.normalizeOpts = _normalizeOpts;\nmodule.exports.mergeOpts = _mergeOpts;\n\n\n/***/ }),\n/* 7 */,\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*jshint node:true */\n/*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/\n\n\n\nvar regexp_has_sticky = RegExp.prototype.hasOwnProperty('sticky');\n\nfunction InputScanner(input_string) {\n  this.__input = input_string || '';\n  this.__input_length = this.__input.length;\n  this.__position = 0;\n}\n\nInputScanner.prototype.restart = function() {\n  this.__position = 0;\n};\n\nInputScanner.prototype.back = function() {\n  if (this.__position > 0) {\n    this.__position -= 1;\n  }\n};\n\nInputScanner.prototype.hasNext = function() {\n  return this.__position < this.__input_length;\n};\n\nInputScanner.prototype.next = function() {\n  var val = null;\n  if (this.hasNext()) {\n    val = this.__input.charAt(this.__position);\n    this.__position += 1;\n  }\n  return val;\n};\n\nInputScanner.prototype.peek = function(index) {\n  var val = null;\n  index = index || 0;\n  index += this.__position;\n  if (index >= 0 && index < this.__input_length) {\n    val = this.__input.charAt(index);\n  }\n  return val;\n};\n\n// This is a JavaScript only helper function (not in python)\n// Javascript doesn't have a match method\n// and not all implementation support \"sticky\" flag.\n// If they do not support sticky then both this.match() and this.test() method\n// must get the match and check the index of the match.\n// If sticky is supported and set, this method will use it.\n// Otherwise it will check that global is set, and fall back to the slower method.\nInputScanner.prototype.__match = function(pattern, index) {\n  pattern.lastIndex = index;\n  var pattern_match = pattern.exec(this.__input);\n\n  if (pattern_match && !(regexp_has_sticky && pattern.sticky)) {\n    if (pattern_match.index !== index) {\n      pattern_match = null;\n    }\n  }\n\n  return pattern_match;\n};\n\nInputScanner.prototype.test = function(pattern, index) {\n  index = index || 0;\n  index += this.__position;\n\n  if (index >= 0 && index < this.__input_length) {\n    return !!this.__match(pattern, index);\n  } else {\n    return false;\n  }\n};\n\nInputScanner.prototype.testChar = function(pattern, index) {\n  // test one character regex match\n  var val = this.peek(index);\n  pattern.lastIndex = 0;\n  return val !== null && pattern.test(val);\n};\n\nInputScanner.prototype.match = function(pattern) {\n  var pattern_match = this.__match(pattern, this.__position);\n  if (pattern_match) {\n    this.__position += pattern_match[0].length;\n  } else {\n    pattern_match = null;\n  }\n  return pattern_match;\n};\n\nInputScanner.prototype.read = function(starting_pattern, until_pattern, until_after) {\n  var val = '';\n  var match;\n  if (starting_pattern) {\n    match = this.match(starting_pattern);\n    if (match) {\n      val += match[0];\n    }\n  }\n  if (until_pattern && (match || !starting_pattern)) {\n    val += this.readUntil(until_pattern, until_after);\n  }\n  return val;\n};\n\nInputScanner.prototype.readUntil = function(pattern, until_after) {\n  var val = '';\n  var match_index = this.__position;\n  pattern.lastIndex = this.__position;\n  var pattern_match = pattern.exec(this.__input);\n  if (pattern_match) {\n    match_index = pattern_match.index;\n    if (until_after) {\n      match_index += pattern_match[0].length;\n    }\n  } else {\n    match_index = this.__input_length;\n  }\n\n  val = this.__input.substring(this.__position, match_index);\n  this.__position = match_index;\n  return val;\n};\n\nInputScanner.prototype.readUntilAfter = function(pattern) {\n  return this.readUntil(pattern, true);\n};\n\nInputScanner.prototype.get_regexp = function(pattern, match_from) {\n  var result = null;\n  var flags = 'g';\n  if (match_from && regexp_has_sticky) {\n    flags = 'y';\n  }\n  // strings are converted to regexp\n  if (typeof pattern === \"string\" && pattern !== '') {\n    // result = new RegExp(pattern.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&'), flags);\n    result = new RegExp(pattern, flags);\n  } else if (pattern) {\n    result = new RegExp(pattern.source, flags);\n  }\n  return result;\n};\n\nInputScanner.prototype.get_literal_regexp = function(literal_string) {\n  return RegExp(literal_string.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&'));\n};\n\n/* css beautifier legacy helpers */\nInputScanner.prototype.peekUntilAfter = function(pattern) {\n  var start = this.__position;\n  var val = this.readUntilAfter(pattern);\n  this.__position = start;\n  return val;\n};\n\nInputScanner.prototype.lookBack = function(testVal) {\n  var start = this.__position - 1;\n  return start >= testVal.length && this.__input.substring(start - testVal.length, start)\n    .toLowerCase() === testVal;\n};\n\nmodule.exports.InputScanner = InputScanner;\n\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*jshint node:true */\n/*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/\n\n\n\nvar InputScanner = __webpack_require__(8).InputScanner;\nvar Token = __webpack_require__(3).Token;\nvar TokenStream = __webpack_require__(10).TokenStream;\nvar WhitespacePattern = __webpack_require__(11).WhitespacePattern;\n\nvar TOKEN = {\n  START: 'TK_START',\n  RAW: 'TK_RAW',\n  EOF: 'TK_EOF'\n};\n\nvar Tokenizer = function(input_string, options) {\n  this._input = new InputScanner(input_string);\n  this._options = options || {};\n  this.__tokens = null;\n\n  this._patterns = {};\n  this._patterns.whitespace = new WhitespacePattern(this._input);\n};\n\nTokenizer.prototype.tokenize = function() {\n  this._input.restart();\n  this.__tokens = new TokenStream();\n\n  this._reset();\n\n  var current;\n  var previous = new Token(TOKEN.START, '');\n  var open_token = null;\n  var open_stack = [];\n  var comments = new TokenStream();\n\n  while (previous.type !== TOKEN.EOF) {\n    current = this._get_next_token(previous, open_token);\n    while (this._is_comment(current)) {\n      comments.add(current);\n      current = this._get_next_token(previous, open_token);\n    }\n\n    if (!comments.isEmpty()) {\n      current.comments_before = comments;\n      comments = new TokenStream();\n    }\n\n    current.parent = open_token;\n\n    if (this._is_opening(current)) {\n      open_stack.push(open_token);\n      open_token = current;\n    } else if (open_token && this._is_closing(current, open_token)) {\n      current.opened = open_token;\n      open_token.closed = current;\n      open_token = open_stack.pop();\n      current.parent = open_token;\n    }\n\n    current.previous = previous;\n    previous.next = current;\n\n    this.__tokens.add(current);\n    previous = current;\n  }\n\n  return this.__tokens;\n};\n\n\nTokenizer.prototype._is_first_token = function() {\n  return this.__tokens.isEmpty();\n};\n\nTokenizer.prototype._reset = function() {};\n\nTokenizer.prototype._get_next_token = function(previous_token, open_token) { // jshint unused:false\n  this._readWhitespace();\n  var resulting_string = this._input.read(/.+/g);\n  if (resulting_string) {\n    return this._create_token(TOKEN.RAW, resulting_string);\n  } else {\n    return this._create_token(TOKEN.EOF, '');\n  }\n};\n\nTokenizer.prototype._is_comment = function(current_token) { // jshint unused:false\n  return false;\n};\n\nTokenizer.prototype._is_opening = function(current_token) { // jshint unused:false\n  return false;\n};\n\nTokenizer.prototype._is_closing = function(current_token, open_token) { // jshint unused:false\n  return false;\n};\n\nTokenizer.prototype._create_token = function(type, text) {\n  var token = new Token(type, text,\n    this._patterns.whitespace.newline_count,\n    this._patterns.whitespace.whitespace_before_token);\n  return token;\n};\n\nTokenizer.prototype._readWhitespace = function() {\n  return this._patterns.whitespace.read();\n};\n\n\n\nmodule.exports.Tokenizer = Tokenizer;\nmodule.exports.TOKEN = TOKEN;\n\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*jshint node:true */\n/*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/\n\n\n\nfunction TokenStream(parent_token) {\n  // private\n  this.__tokens = [];\n  this.__tokens_length = this.__tokens.length;\n  this.__position = 0;\n  this.__parent_token = parent_token;\n}\n\nTokenStream.prototype.restart = function() {\n  this.__position = 0;\n};\n\nTokenStream.prototype.isEmpty = function() {\n  return this.__tokens_length === 0;\n};\n\nTokenStream.prototype.hasNext = function() {\n  return this.__position < this.__tokens_length;\n};\n\nTokenStream.prototype.next = function() {\n  var val = null;\n  if (this.hasNext()) {\n    val = this.__tokens[this.__position];\n    this.__position += 1;\n  }\n  return val;\n};\n\nTokenStream.prototype.peek = function(index) {\n  var val = null;\n  index = index || 0;\n  index += this.__position;\n  if (index >= 0 && index < this.__tokens_length) {\n    val = this.__tokens[index];\n  }\n  return val;\n};\n\nTokenStream.prototype.add = function(token) {\n  if (this.__parent_token) {\n    token.parent = this.__parent_token;\n  }\n  this.__tokens.push(token);\n  this.__tokens_length += 1;\n};\n\nmodule.exports.TokenStream = TokenStream;\n\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*jshint node:true */\n/*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/\n\n\n\nvar Pattern = __webpack_require__(12).Pattern;\n\nfunction WhitespacePattern(input_scanner, parent) {\n  Pattern.call(this, input_scanner, parent);\n  if (parent) {\n    this._line_regexp = this._input.get_regexp(parent._line_regexp);\n  } else {\n    this.__set_whitespace_patterns('', '');\n  }\n\n  this.newline_count = 0;\n  this.whitespace_before_token = '';\n}\nWhitespacePattern.prototype = new Pattern();\n\nWhitespacePattern.prototype.__set_whitespace_patterns = function(whitespace_chars, newline_chars) {\n  whitespace_chars += '\\\\t ';\n  newline_chars += '\\\\n\\\\r';\n\n  this._match_pattern = this._input.get_regexp(\n    '[' + whitespace_chars + newline_chars + ']+', true);\n  this._newline_regexp = this._input.get_regexp(\n    '\\\\r\\\\n|[' + newline_chars + ']');\n};\n\nWhitespacePattern.prototype.read = function() {\n  this.newline_count = 0;\n  this.whitespace_before_token = '';\n\n  var resulting_string = this._input.read(this._match_pattern);\n  if (resulting_string === ' ') {\n    this.whitespace_before_token = ' ';\n  } else if (resulting_string) {\n    var matches = this.__split(this._newline_regexp, resulting_string);\n    this.newline_count = matches.length - 1;\n    this.whitespace_before_token = matches[this.newline_count];\n  }\n\n  return resulting_string;\n};\n\nWhitespacePattern.prototype.matching = function(whitespace_chars, newline_chars) {\n  var result = this._create();\n  result.__set_whitespace_patterns(whitespace_chars, newline_chars);\n  result._update();\n  return result;\n};\n\nWhitespacePattern.prototype._create = function() {\n  return new WhitespacePattern(this._input, this);\n};\n\nWhitespacePattern.prototype.__split = function(regexp, input_string) {\n  regexp.lastIndex = 0;\n  var start_index = 0;\n  var result = [];\n  var next_match = regexp.exec(input_string);\n  while (next_match) {\n    result.push(input_string.substring(start_index, next_match.index));\n    start_index = next_match.index + next_match[0].length;\n    next_match = regexp.exec(input_string);\n  }\n\n  if (start_index < input_string.length) {\n    result.push(input_string.substring(start_index, input_string.length));\n  } else {\n    result.push('');\n  }\n\n  return result;\n};\n\n\n\nmodule.exports.WhitespacePattern = WhitespacePattern;\n\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*jshint node:true */\n/*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/\n\n\n\nfunction Pattern(input_scanner, parent) {\n  this._input = input_scanner;\n  this._starting_pattern = null;\n  this._match_pattern = null;\n  this._until_pattern = null;\n  this._until_after = false;\n\n  if (parent) {\n    this._starting_pattern = this._input.get_regexp(parent._starting_pattern, true);\n    this._match_pattern = this._input.get_regexp(parent._match_pattern, true);\n    this._until_pattern = this._input.get_regexp(parent._until_pattern);\n    this._until_after = parent._until_after;\n  }\n}\n\nPattern.prototype.read = function() {\n  var result = this._input.read(this._starting_pattern);\n  if (!this._starting_pattern || result) {\n    result += this._input.read(this._match_pattern, this._until_pattern, this._until_after);\n  }\n  return result;\n};\n\nPattern.prototype.read_match = function() {\n  return this._input.match(this._match_pattern);\n};\n\nPattern.prototype.until_after = function(pattern) {\n  var result = this._create();\n  result._until_after = true;\n  result._until_pattern = this._input.get_regexp(pattern);\n  result._update();\n  return result;\n};\n\nPattern.prototype.until = function(pattern) {\n  var result = this._create();\n  result._until_after = false;\n  result._until_pattern = this._input.get_regexp(pattern);\n  result._update();\n  return result;\n};\n\nPattern.prototype.starting_with = function(pattern) {\n  var result = this._create();\n  result._starting_pattern = this._input.get_regexp(pattern, true);\n  result._update();\n  return result;\n};\n\nPattern.prototype.matching = function(pattern) {\n  var result = this._create();\n  result._match_pattern = this._input.get_regexp(pattern, true);\n  result._update();\n  return result;\n};\n\nPattern.prototype._create = function() {\n  return new Pattern(this._input, this);\n};\n\nPattern.prototype._update = function() {};\n\nmodule.exports.Pattern = Pattern;\n\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*jshint node:true */\n/*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/\n\n\n\nfunction Directives(start_block_pattern, end_block_pattern) {\n  start_block_pattern = typeof start_block_pattern === 'string' ? start_block_pattern : start_block_pattern.source;\n  end_block_pattern = typeof end_block_pattern === 'string' ? end_block_pattern : end_block_pattern.source;\n  this.__directives_block_pattern = new RegExp(start_block_pattern + / beautify( \\w+[:]\\w+)+ /.source + end_block_pattern, 'g');\n  this.__directive_pattern = / (\\w+)[:](\\w+)/g;\n\n  this.__directives_end_ignore_pattern = new RegExp(start_block_pattern + /\\sbeautify\\signore:end\\s/.source + end_block_pattern, 'g');\n}\n\nDirectives.prototype.get_directives = function(text) {\n  if (!text.match(this.__directives_block_pattern)) {\n    return null;\n  }\n\n  var directives = {};\n  this.__directive_pattern.lastIndex = 0;\n  var directive_match = this.__directive_pattern.exec(text);\n\n  while (directive_match) {\n    directives[directive_match[1]] = directive_match[2];\n    directive_match = this.__directive_pattern.exec(text);\n  }\n\n  return directives;\n};\n\nDirectives.prototype.readIgnored = function(input) {\n  return input.readUntilAfter(this.__directives_end_ignore_pattern);\n};\n\n\nmodule.exports.Directives = Directives;\n\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*jshint node:true */\n/*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/\n\n\n\nvar Pattern = __webpack_require__(12).Pattern;\n\n\nvar template_names = {\n  django: false,\n  erb: false,\n  handlebars: false,\n  php: false\n};\n\n// This lets templates appear anywhere we would do a readUntil\n// The cost is higher but it is pay to play.\nfunction TemplatablePattern(input_scanner, parent) {\n  Pattern.call(this, input_scanner, parent);\n  this.__template_pattern = null;\n  this._disabled = Object.assign({}, template_names);\n  this._excluded = Object.assign({}, template_names);\n\n  if (parent) {\n    this.__template_pattern = this._input.get_regexp(parent.__template_pattern);\n    this._excluded = Object.assign(this._excluded, parent._excluded);\n    this._disabled = Object.assign(this._disabled, parent._disabled);\n  }\n  var pattern = new Pattern(input_scanner);\n  this.__patterns = {\n    handlebars_comment: pattern.starting_with(/{{!--/).until_after(/--}}/),\n    handlebars_unescaped: pattern.starting_with(/{{{/).until_after(/}}}/),\n    handlebars: pattern.starting_with(/{{/).until_after(/}}/),\n    php: pattern.starting_with(/<\\?(?:[=]|php)/).until_after(/\\?>/),\n    erb: pattern.starting_with(/<%[^%]/).until_after(/[^%]%>/),\n    // django coflicts with handlebars a bit.\n    django: pattern.starting_with(/{%/).until_after(/%}/),\n    django_value: pattern.starting_with(/{{/).until_after(/}}/),\n    django_comment: pattern.starting_with(/{#/).until_after(/#}/)\n  };\n}\nTemplatablePattern.prototype = new Pattern();\n\nTemplatablePattern.prototype._create = function() {\n  return new TemplatablePattern(this._input, this);\n};\n\nTemplatablePattern.prototype._update = function() {\n  this.__set_templated_pattern();\n};\n\nTemplatablePattern.prototype.disable = function(language) {\n  var result = this._create();\n  result._disabled[language] = true;\n  result._update();\n  return result;\n};\n\nTemplatablePattern.prototype.read_options = function(options) {\n  var result = this._create();\n  for (var language in template_names) {\n    result._disabled[language] = options.templating.indexOf(language) === -1;\n  }\n  result._update();\n  return result;\n};\n\nTemplatablePattern.prototype.exclude = function(language) {\n  var result = this._create();\n  result._excluded[language] = true;\n  result._update();\n  return result;\n};\n\nTemplatablePattern.prototype.read = function() {\n  var result = '';\n  if (this._match_pattern) {\n    result = this._input.read(this._starting_pattern);\n  } else {\n    result = this._input.read(this._starting_pattern, this.__template_pattern);\n  }\n  var next = this._read_template();\n  while (next) {\n    if (this._match_pattern) {\n      next += this._input.read(this._match_pattern);\n    } else {\n      next += this._input.readUntil(this.__template_pattern);\n    }\n    result += next;\n    next = this._read_template();\n  }\n\n  if (this._until_after) {\n    result += this._input.readUntilAfter(this._until_pattern);\n  }\n  return result;\n};\n\nTemplatablePattern.prototype.__set_templated_pattern = function() {\n  var items = [];\n\n  if (!this._disabled.php) {\n    items.push(this.__patterns.php._starting_pattern.source);\n  }\n  if (!this._disabled.handlebars) {\n    items.push(this.__patterns.handlebars._starting_pattern.source);\n  }\n  if (!this._disabled.erb) {\n    items.push(this.__patterns.erb._starting_pattern.source);\n  }\n  if (!this._disabled.django) {\n    items.push(this.__patterns.django._starting_pattern.source);\n    items.push(this.__patterns.django_value._starting_pattern.source);\n    items.push(this.__patterns.django_comment._starting_pattern.source);\n  }\n\n  if (this._until_pattern) {\n    items.push(this._until_pattern.source);\n  }\n  this.__template_pattern = this._input.get_regexp('(?:' + items.join('|') + ')');\n};\n\nTemplatablePattern.prototype._read_template = function() {\n  var resulting_string = '';\n  var c = this._input.peek();\n  if (c === '<') {\n    var peek1 = this._input.peek(1);\n    //if we're in a comment, do something special\n    // We treat all comments as literals, even more than preformatted tags\n    // we just look for the appropriate close tag\n    if (!this._disabled.php && !this._excluded.php && peek1 === '?') {\n      resulting_string = resulting_string ||\n        this.__patterns.php.read();\n    }\n    if (!this._disabled.erb && !this._excluded.erb && peek1 === '%') {\n      resulting_string = resulting_string ||\n        this.__patterns.erb.read();\n    }\n  } else if (c === '{') {\n    if (!this._disabled.handlebars && !this._excluded.handlebars) {\n      resulting_string = resulting_string ||\n        this.__patterns.handlebars_comment.read();\n      resulting_string = resulting_string ||\n        this.__patterns.handlebars_unescaped.read();\n      resulting_string = resulting_string ||\n        this.__patterns.handlebars.read();\n    }\n    if (!this._disabled.django) {\n      // django coflicts with handlebars a bit.\n      if (!this._excluded.django && !this._excluded.handlebars) {\n        resulting_string = resulting_string ||\n          this.__patterns.django_value.read();\n      }\n      if (!this._excluded.django) {\n        resulting_string = resulting_string ||\n          this.__patterns.django_comment.read();\n        resulting_string = resulting_string ||\n          this.__patterns.django.read();\n      }\n    }\n  }\n  return resulting_string;\n};\n\n\nmodule.exports.TemplatablePattern = TemplatablePattern;\n\n\n/***/ }),\n/* 15 */,\n/* 16 */,\n/* 17 */,\n/* 18 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*jshint node:true */\n/*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/\n\n\n\nvar Beautifier = __webpack_require__(19).Beautifier,\n  Options = __webpack_require__(20).Options;\n\nfunction style_html(html_source, options, js_beautify, css_beautify) {\n  var beautifier = new Beautifier(html_source, options, js_beautify, css_beautify);\n  return beautifier.beautify();\n}\n\nmodule.exports = style_html;\nmodule.exports.defaultOptions = function() {\n  return new Options();\n};\n\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*jshint node:true */\n/*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/\n\n\n\nvar Options = __webpack_require__(20).Options;\nvar Output = __webpack_require__(2).Output;\nvar Tokenizer = __webpack_require__(21).Tokenizer;\nvar TOKEN = __webpack_require__(21).TOKEN;\n\nvar lineBreak = /\\r\\n|[\\r\\n]/;\nvar allLineBreaks = /\\r\\n|[\\r\\n]/g;\n\nvar Printer = function(options, base_indent_string) { //handles input/output and some other printing functions\n\n  this.indent_level = 0;\n  this.alignment_size = 0;\n  this.max_preserve_newlines = options.max_preserve_newlines;\n  this.preserve_newlines = options.preserve_newlines;\n\n  this._output = new Output(options, base_indent_string);\n\n};\n\nPrinter.prototype.current_line_has_match = function(pattern) {\n  return this._output.current_line.has_match(pattern);\n};\n\nPrinter.prototype.set_space_before_token = function(value, non_breaking) {\n  this._output.space_before_token = value;\n  this._output.non_breaking_space = non_breaking;\n};\n\nPrinter.prototype.set_wrap_point = function() {\n  this._output.set_indent(this.indent_level, this.alignment_size);\n  this._output.set_wrap_point();\n};\n\n\nPrinter.prototype.add_raw_token = function(token) {\n  this._output.add_raw_token(token);\n};\n\nPrinter.prototype.print_preserved_newlines = function(raw_token) {\n  var newlines = 0;\n  if (raw_token.type !== TOKEN.TEXT && raw_token.previous.type !== TOKEN.TEXT) {\n    newlines = raw_token.newlines ? 1 : 0;\n  }\n\n  if (this.preserve_newlines) {\n    newlines = raw_token.newlines < this.max_preserve_newlines + 1 ? raw_token.newlines : this.max_preserve_newlines + 1;\n  }\n  for (var n = 0; n < newlines; n++) {\n    this.print_newline(n > 0);\n  }\n\n  return newlines !== 0;\n};\n\nPrinter.prototype.traverse_whitespace = function(raw_token) {\n  if (raw_token.whitespace_before || raw_token.newlines) {\n    if (!this.print_preserved_newlines(raw_token)) {\n      this._output.space_before_token = true;\n    }\n    return true;\n  }\n  return false;\n};\n\nPrinter.prototype.previous_token_wrapped = function() {\n  return this._output.previous_token_wrapped;\n};\n\nPrinter.prototype.print_newline = function(force) {\n  this._output.add_new_line(force);\n};\n\nPrinter.prototype.print_token = function(token) {\n  if (token.text) {\n    this._output.set_indent(this.indent_level, this.alignment_size);\n    this._output.add_token(token.text);\n  }\n};\n\nPrinter.prototype.indent = function() {\n  this.indent_level++;\n};\n\nPrinter.prototype.get_full_indent = function(level) {\n  level = this.indent_level + (level || 0);\n  if (level < 1) {\n    return '';\n  }\n\n  return this._output.get_indent_string(level);\n};\n\nvar get_type_attribute = function(start_token) {\n  var result = null;\n  var raw_token = start_token.next;\n\n  // Search attributes for a type attribute\n  while (raw_token.type !== TOKEN.EOF && start_token.closed !== raw_token) {\n    if (raw_token.type === TOKEN.ATTRIBUTE && raw_token.text === 'type') {\n      if (raw_token.next && raw_token.next.type === TOKEN.EQUALS &&\n        raw_token.next.next && raw_token.next.next.type === TOKEN.VALUE) {\n        result = raw_token.next.next.text;\n      }\n      break;\n    }\n    raw_token = raw_token.next;\n  }\n\n  return result;\n};\n\nvar get_custom_beautifier_name = function(tag_check, raw_token) {\n  var typeAttribute = null;\n  var result = null;\n\n  if (!raw_token.closed) {\n    return null;\n  }\n\n  if (tag_check === 'script') {\n    typeAttribute = 'text/javascript';\n  } else if (tag_check === 'style') {\n    typeAttribute = 'text/css';\n  }\n\n  typeAttribute = get_type_attribute(raw_token) || typeAttribute;\n\n  // For script and style tags that have a type attribute, only enable custom beautifiers for matching values\n  // For those without a type attribute use default;\n  if (typeAttribute.search('text/css') > -1) {\n    result = 'css';\n  } else if (typeAttribute.search(/module|((text|application|dojo)\\/(x-)?(javascript|ecmascript|jscript|livescript|(ld\\+)?json|method|aspect))/) > -1) {\n    result = 'javascript';\n  } else if (typeAttribute.search(/(text|application|dojo)\\/(x-)?(html)/) > -1) {\n    result = 'html';\n  } else if (typeAttribute.search(/test\\/null/) > -1) {\n    // Test only mime-type for testing the beautifier when null is passed as beautifing function\n    result = 'null';\n  }\n\n  return result;\n};\n\nfunction in_array(what, arr) {\n  return arr.indexOf(what) !== -1;\n}\n\nfunction TagFrame(parent, parser_token, indent_level) {\n  this.parent = parent || null;\n  this.tag = parser_token ? parser_token.tag_name : '';\n  this.indent_level = indent_level || 0;\n  this.parser_token = parser_token || null;\n}\n\nfunction TagStack(printer) {\n  this._printer = printer;\n  this._current_frame = null;\n}\n\nTagStack.prototype.get_parser_token = function() {\n  return this._current_frame ? this._current_frame.parser_token : null;\n};\n\nTagStack.prototype.record_tag = function(parser_token) { //function to record a tag and its parent in this.tags Object\n  var new_frame = new TagFrame(this._current_frame, parser_token, this._printer.indent_level);\n  this._current_frame = new_frame;\n};\n\nTagStack.prototype._try_pop_frame = function(frame) { //function to retrieve the opening tag to the corresponding closer\n  var parser_token = null;\n\n  if (frame) {\n    parser_token = frame.parser_token;\n    this._printer.indent_level = frame.indent_level;\n    this._current_frame = frame.parent;\n  }\n\n  return parser_token;\n};\n\nTagStack.prototype._get_frame = function(tag_list, stop_list) { //function to retrieve the opening tag to the corresponding closer\n  var frame = this._current_frame;\n\n  while (frame) { //till we reach '' (the initial value);\n    if (tag_list.indexOf(frame.tag) !== -1) { //if this is it use it\n      break;\n    } else if (stop_list && stop_list.indexOf(frame.tag) !== -1) {\n      frame = null;\n      break;\n    }\n    frame = frame.parent;\n  }\n\n  return frame;\n};\n\nTagStack.prototype.try_pop = function(tag, stop_list) { //function to retrieve the opening tag to the corresponding closer\n  var frame = this._get_frame([tag], stop_list);\n  return this._try_pop_frame(frame);\n};\n\nTagStack.prototype.indent_to_tag = function(tag_list) {\n  var frame = this._get_frame(tag_list);\n  if (frame) {\n    this._printer.indent_level = frame.indent_level;\n  }\n};\n\nfunction Beautifier(source_text, options, js_beautify, css_beautify) {\n  //Wrapper function to invoke all the necessary constructors and deal with the output.\n  this._source_text = source_text || '';\n  options = options || {};\n  this._js_beautify = js_beautify;\n  this._css_beautify = css_beautify;\n  this._tag_stack = null;\n\n  // Allow the setting of language/file-type specific options\n  // with inheritance of overall settings\n  var optionHtml = new Options(options, 'html');\n\n  this._options = optionHtml;\n\n  this._is_wrap_attributes_force = this._options.wrap_attributes.substr(0, 'force'.length) === 'force';\n  this._is_wrap_attributes_force_expand_multiline = (this._options.wrap_attributes === 'force-expand-multiline');\n  this._is_wrap_attributes_force_aligned = (this._options.wrap_attributes === 'force-aligned');\n  this._is_wrap_attributes_aligned_multiple = (this._options.wrap_attributes === 'aligned-multiple');\n  this._is_wrap_attributes_preserve = this._options.wrap_attributes.substr(0, 'preserve'.length) === 'preserve';\n  this._is_wrap_attributes_preserve_aligned = (this._options.wrap_attributes === 'preserve-aligned');\n}\n\nBeautifier.prototype.beautify = function() {\n\n  // if disabled, return the input unchanged.\n  if (this._options.disabled) {\n    return this._source_text;\n  }\n\n  var source_text = this._source_text;\n  var eol = this._options.eol;\n  if (this._options.eol === 'auto') {\n    eol = '\\n';\n    if (source_text && lineBreak.test(source_text)) {\n      eol = source_text.match(lineBreak)[0];\n    }\n  }\n\n  // HACK: newline parsing inconsistent. This brute force normalizes the input.\n  source_text = source_text.replace(allLineBreaks, '\\n');\n\n  var baseIndentString = source_text.match(/^[\\t ]*/)[0];\n\n  var last_token = {\n    text: '',\n    type: ''\n  };\n\n  var last_tag_token = new TagOpenParserToken();\n\n  var printer = new Printer(this._options, baseIndentString);\n  var tokens = new Tokenizer(source_text, this._options).tokenize();\n\n  this._tag_stack = new TagStack(printer);\n\n  var parser_token = null;\n  var raw_token = tokens.next();\n  while (raw_token.type !== TOKEN.EOF) {\n\n    if (raw_token.type === TOKEN.TAG_OPEN || raw_token.type === TOKEN.COMMENT) {\n      parser_token = this._handle_tag_open(printer, raw_token, last_tag_token, last_token);\n      last_tag_token = parser_token;\n    } else if ((raw_token.type === TOKEN.ATTRIBUTE || raw_token.type === TOKEN.EQUALS || raw_token.type === TOKEN.VALUE) ||\n      (raw_token.type === TOKEN.TEXT && !last_tag_token.tag_complete)) {\n      parser_token = this._handle_inside_tag(printer, raw_token, last_tag_token, tokens);\n    } else if (raw_token.type === TOKEN.TAG_CLOSE) {\n      parser_token = this._handle_tag_close(printer, raw_token, last_tag_token);\n    } else if (raw_token.type === TOKEN.TEXT) {\n      parser_token = this._handle_text(printer, raw_token, last_tag_token);\n    } else {\n      // This should never happen, but if it does. Print the raw token\n      printer.add_raw_token(raw_token);\n    }\n\n    last_token = parser_token;\n\n    raw_token = tokens.next();\n  }\n  var sweet_code = printer._output.get_code(eol);\n\n  return sweet_code;\n};\n\nBeautifier.prototype._handle_tag_close = function(printer, raw_token, last_tag_token) {\n  var parser_token = {\n    text: raw_token.text,\n    type: raw_token.type\n  };\n  printer.alignment_size = 0;\n  last_tag_token.tag_complete = true;\n\n  printer.set_space_before_token(raw_token.newlines || raw_token.whitespace_before !== '', true);\n  if (last_tag_token.is_unformatted) {\n    printer.add_raw_token(raw_token);\n  } else {\n    if (last_tag_token.tag_start_char === '<') {\n      printer.set_space_before_token(raw_token.text[0] === '/', true); // space before />, no space before >\n      if (this._is_wrap_attributes_force_expand_multiline && last_tag_token.has_wrapped_attrs) {\n        printer.print_newline(false);\n      }\n    }\n    printer.print_token(raw_token);\n\n  }\n\n  if (last_tag_token.indent_content &&\n    !(last_tag_token.is_unformatted || last_tag_token.is_content_unformatted)) {\n    printer.indent();\n\n    // only indent once per opened tag\n    last_tag_token.indent_content = false;\n  }\n\n  if (!last_tag_token.is_inline_element &&\n    !(last_tag_token.is_unformatted || last_tag_token.is_content_unformatted)) {\n    printer.set_wrap_point();\n  }\n\n  return parser_token;\n};\n\nBeautifier.prototype._handle_inside_tag = function(printer, raw_token, last_tag_token, tokens) {\n  var wrapped = last_tag_token.has_wrapped_attrs;\n  var parser_token = {\n    text: raw_token.text,\n    type: raw_token.type\n  };\n\n  printer.set_space_before_token(raw_token.newlines || raw_token.whitespace_before !== '', true);\n  if (last_tag_token.is_unformatted) {\n    printer.add_raw_token(raw_token);\n  } else if (last_tag_token.tag_start_char === '{' && raw_token.type === TOKEN.TEXT) {\n    // For the insides of handlebars allow newlines or a single space between open and contents\n    if (printer.print_preserved_newlines(raw_token)) {\n      raw_token.newlines = 0;\n      printer.add_raw_token(raw_token);\n    } else {\n      printer.print_token(raw_token);\n    }\n  } else {\n    if (raw_token.type === TOKEN.ATTRIBUTE) {\n      printer.set_space_before_token(true);\n      last_tag_token.attr_count += 1;\n    } else if (raw_token.type === TOKEN.EQUALS) { //no space before =\n      printer.set_space_before_token(false);\n    } else if (raw_token.type === TOKEN.VALUE && raw_token.previous.type === TOKEN.EQUALS) { //no space before value\n      printer.set_space_before_token(false);\n    }\n\n    if (raw_token.type === TOKEN.ATTRIBUTE && last_tag_token.tag_start_char === '<') {\n      if (this._is_wrap_attributes_preserve || this._is_wrap_attributes_preserve_aligned) {\n        printer.traverse_whitespace(raw_token);\n        wrapped = wrapped || raw_token.newlines !== 0;\n      }\n\n\n      if (this._is_wrap_attributes_force) {\n        var force_attr_wrap = last_tag_token.attr_count > 1;\n        if (this._is_wrap_attributes_force_expand_multiline && last_tag_token.attr_count === 1) {\n          var is_only_attribute = true;\n          var peek_index = 0;\n          var peek_token;\n          do {\n            peek_token = tokens.peek(peek_index);\n            if (peek_token.type === TOKEN.ATTRIBUTE) {\n              is_only_attribute = false;\n              break;\n            }\n            peek_index += 1;\n          } while (peek_index < 4 && peek_token.type !== TOKEN.EOF && peek_token.type !== TOKEN.TAG_CLOSE);\n\n          force_attr_wrap = !is_only_attribute;\n        }\n\n        if (force_attr_wrap) {\n          printer.print_newline(false);\n          wrapped = true;\n        }\n      }\n    }\n    printer.print_token(raw_token);\n    wrapped = wrapped || printer.previous_token_wrapped();\n    last_tag_token.has_wrapped_attrs = wrapped;\n  }\n  return parser_token;\n};\n\nBeautifier.prototype._handle_text = function(printer, raw_token, last_tag_token) {\n  var parser_token = {\n    text: raw_token.text,\n    type: 'TK_CONTENT'\n  };\n  if (last_tag_token.custom_beautifier_name) { //check if we need to format javascript\n    this._print_custom_beatifier_text(printer, raw_token, last_tag_token);\n  } else if (last_tag_token.is_unformatted || last_tag_token.is_content_unformatted) {\n    printer.add_raw_token(raw_token);\n  } else {\n    printer.traverse_whitespace(raw_token);\n    printer.print_token(raw_token);\n  }\n  return parser_token;\n};\n\nBeautifier.prototype._print_custom_beatifier_text = function(printer, raw_token, last_tag_token) {\n  var local = this;\n  if (raw_token.text !== '') {\n\n    var text = raw_token.text,\n      _beautifier,\n      script_indent_level = 1,\n      pre = '',\n      post = '';\n    if (last_tag_token.custom_beautifier_name === 'javascript' && typeof this._js_beautify === 'function') {\n      _beautifier = this._js_beautify;\n    } else if (last_tag_token.custom_beautifier_name === 'css' && typeof this._css_beautify === 'function') {\n      _beautifier = this._css_beautify;\n    } else if (last_tag_token.custom_beautifier_name === 'html') {\n      _beautifier = function(html_source, options) {\n        var beautifier = new Beautifier(html_source, options, local._js_beautify, local._css_beautify);\n        return beautifier.beautify();\n      };\n    }\n\n    if (this._options.indent_scripts === \"keep\") {\n      script_indent_level = 0;\n    } else if (this._options.indent_scripts === \"separate\") {\n      script_indent_level = -printer.indent_level;\n    }\n\n    var indentation = printer.get_full_indent(script_indent_level);\n\n    // if there is at least one empty line at the end of this text, strip it\n    // we'll be adding one back after the text but before the containing tag.\n    text = text.replace(/\\n[ \\t]*$/, '');\n\n    // Handle the case where content is wrapped in a comment or cdata.\n    if (last_tag_token.custom_beautifier_name !== 'html' &&\n      text[0] === '<' && text.match(/^(<!--|<!\\[CDATA\\[)/)) {\n      var matched = /^(<!--[^\\n]*|<!\\[CDATA\\[)(\\n?)([ \\t\\n]*)([\\s\\S]*)(-->|]]>)$/.exec(text);\n\n      // if we start to wrap but don't finish, print raw\n      if (!matched) {\n        printer.add_raw_token(raw_token);\n        return;\n      }\n\n      pre = indentation + matched[1] + '\\n';\n      text = matched[4];\n      if (matched[5]) {\n        post = indentation + matched[5];\n      }\n\n      // if there is at least one empty line at the end of this text, strip it\n      // we'll be adding one back after the text but before the containing tag.\n      text = text.replace(/\\n[ \\t]*$/, '');\n\n      if (matched[2] || matched[3].indexOf('\\n') !== -1) {\n        // if the first line of the non-comment text has spaces\n        // use that as the basis for indenting in null case.\n        matched = matched[3].match(/[ \\t]+$/);\n        if (matched) {\n          raw_token.whitespace_before = matched[0];\n        }\n      }\n    }\n\n    if (text) {\n      if (_beautifier) {\n\n        // call the Beautifier if avaliable\n        var Child_options = function() {\n          this.eol = '\\n';\n        };\n        Child_options.prototype = this._options.raw_options;\n        var child_options = new Child_options();\n        text = _beautifier(indentation + text, child_options);\n      } else {\n        // simply indent the string otherwise\n        var white = raw_token.whitespace_before;\n        if (white) {\n          text = text.replace(new RegExp('\\n(' + white + ')?', 'g'), '\\n');\n        }\n\n        text = indentation + text.replace(/\\n/g, '\\n' + indentation);\n      }\n    }\n\n    if (pre) {\n      if (!text) {\n        text = pre + post;\n      } else {\n        text = pre + text + '\\n' + post;\n      }\n    }\n\n    printer.print_newline(false);\n    if (text) {\n      raw_token.text = text;\n      raw_token.whitespace_before = '';\n      raw_token.newlines = 0;\n      printer.add_raw_token(raw_token);\n      printer.print_newline(true);\n    }\n  }\n};\n\nBeautifier.prototype._handle_tag_open = function(printer, raw_token, last_tag_token, last_token) {\n  var parser_token = this._get_tag_open_token(raw_token);\n\n  if ((last_tag_token.is_unformatted || last_tag_token.is_content_unformatted) &&\n    !last_tag_token.is_empty_element &&\n    raw_token.type === TOKEN.TAG_OPEN && raw_token.text.indexOf('</') === 0) {\n    // End element tags for unformatted or content_unformatted elements\n    // are printed raw to keep any newlines inside them exactly the same.\n    printer.add_raw_token(raw_token);\n    parser_token.start_tag_token = this._tag_stack.try_pop(parser_token.tag_name);\n  } else {\n    printer.traverse_whitespace(raw_token);\n    this._set_tag_position(printer, raw_token, parser_token, last_tag_token, last_token);\n    if (!parser_token.is_inline_element) {\n      printer.set_wrap_point();\n    }\n    printer.print_token(raw_token);\n  }\n\n  //indent attributes an auto, forced, aligned or forced-align line-wrap\n  if (this._is_wrap_attributes_force_aligned || this._is_wrap_attributes_aligned_multiple || this._is_wrap_attributes_preserve_aligned) {\n    parser_token.alignment_size = raw_token.text.length + 1;\n  }\n\n  if (!parser_token.tag_complete && !parser_token.is_unformatted) {\n    printer.alignment_size = parser_token.alignment_size;\n  }\n\n  return parser_token;\n};\n\nvar TagOpenParserToken = function(parent, raw_token) {\n  this.parent = parent || null;\n  this.text = '';\n  this.type = 'TK_TAG_OPEN';\n  this.tag_name = '';\n  this.is_inline_element = false;\n  this.is_unformatted = false;\n  this.is_content_unformatted = false;\n  this.is_empty_element = false;\n  this.is_start_tag = false;\n  this.is_end_tag = false;\n  this.indent_content = false;\n  this.multiline_content = false;\n  this.custom_beautifier_name = null;\n  this.start_tag_token = null;\n  this.attr_count = 0;\n  this.has_wrapped_attrs = false;\n  this.alignment_size = 0;\n  this.tag_complete = false;\n  this.tag_start_char = '';\n  this.tag_check = '';\n\n  if (!raw_token) {\n    this.tag_complete = true;\n  } else {\n    var tag_check_match;\n\n    this.tag_start_char = raw_token.text[0];\n    this.text = raw_token.text;\n\n    if (this.tag_start_char === '<') {\n      tag_check_match = raw_token.text.match(/^<([^\\s>]*)/);\n      this.tag_check = tag_check_match ? tag_check_match[1] : '';\n    } else {\n      tag_check_match = raw_token.text.match(/^{{(?:[\\^]|#\\*?)?([^\\s}]+)/);\n      this.tag_check = tag_check_match ? tag_check_match[1] : '';\n\n      // handle \"{{#> myPartial}}\n      if (raw_token.text === '{{#>' && this.tag_check === '>' && raw_token.next !== null) {\n        this.tag_check = raw_token.next.text;\n      }\n    }\n    this.tag_check = this.tag_check.toLowerCase();\n\n    if (raw_token.type === TOKEN.COMMENT) {\n      this.tag_complete = true;\n    }\n\n    this.is_start_tag = this.tag_check.charAt(0) !== '/';\n    this.tag_name = !this.is_start_tag ? this.tag_check.substr(1) : this.tag_check;\n    this.is_end_tag = !this.is_start_tag ||\n      (raw_token.closed && raw_token.closed.text === '/>');\n\n    // handlebars tags that don't start with # or ^ are single_tags, and so also start and end.\n    this.is_end_tag = this.is_end_tag ||\n      (this.tag_start_char === '{' && (this.text.length < 3 || (/[^#\\^]/.test(this.text.charAt(2)))));\n  }\n};\n\nBeautifier.prototype._get_tag_open_token = function(raw_token) { //function to get a full tag and parse its type\n  var parser_token = new TagOpenParserToken(this._tag_stack.get_parser_token(), raw_token);\n\n  parser_token.alignment_size = this._options.wrap_attributes_indent_size;\n\n  parser_token.is_end_tag = parser_token.is_end_tag ||\n    in_array(parser_token.tag_check, this._options.void_elements);\n\n  parser_token.is_empty_element = parser_token.tag_complete ||\n    (parser_token.is_start_tag && parser_token.is_end_tag);\n\n  parser_token.is_unformatted = !parser_token.tag_complete && in_array(parser_token.tag_check, this._options.unformatted);\n  parser_token.is_content_unformatted = !parser_token.is_empty_element && in_array(parser_token.tag_check, this._options.content_unformatted);\n  parser_token.is_inline_element = in_array(parser_token.tag_name, this._options.inline) || parser_token.tag_start_char === '{';\n\n  return parser_token;\n};\n\nBeautifier.prototype._set_tag_position = function(printer, raw_token, parser_token, last_tag_token, last_token) {\n\n  if (!parser_token.is_empty_element) {\n    if (parser_token.is_end_tag) { //this tag is a double tag so check for tag-ending\n      parser_token.start_tag_token = this._tag_stack.try_pop(parser_token.tag_name); //remove it and all ancestors\n    } else { // it's a start-tag\n      // check if this tag is starting an element that has optional end element\n      // and do an ending needed\n      if (this._do_optional_end_element(parser_token)) {\n        if (!parser_token.is_inline_element) {\n          printer.print_newline(false);\n        }\n      }\n\n      this._tag_stack.record_tag(parser_token); //push it on the tag stack\n\n      if ((parser_token.tag_name === 'script' || parser_token.tag_name === 'style') &&\n        !(parser_token.is_unformatted || parser_token.is_content_unformatted)) {\n        parser_token.custom_beautifier_name = get_custom_beautifier_name(parser_token.tag_check, raw_token);\n      }\n    }\n  }\n\n  if (in_array(parser_token.tag_check, this._options.extra_liners)) { //check if this double needs an extra line\n    printer.print_newline(false);\n    if (!printer._output.just_added_blankline()) {\n      printer.print_newline(true);\n    }\n  }\n\n  if (parser_token.is_empty_element) { //if this tag name is a single tag type (either in the list or has a closing /)\n\n    // if you hit an else case, reset the indent level if you are inside an:\n    // 'if', 'unless', or 'each' block.\n    if (parser_token.tag_start_char === '{' && parser_token.tag_check === 'else') {\n      this._tag_stack.indent_to_tag(['if', 'unless', 'each']);\n      parser_token.indent_content = true;\n      // Don't add a newline if opening {{#if}} tag is on the current line\n      var foundIfOnCurrentLine = printer.current_line_has_match(/{{#if/);\n      if (!foundIfOnCurrentLine) {\n        printer.print_newline(false);\n      }\n    }\n\n    // Don't add a newline before elements that should remain where they are.\n    if (parser_token.tag_name === '!--' && last_token.type === TOKEN.TAG_CLOSE &&\n      last_tag_token.is_end_tag && parser_token.text.indexOf('\\n') === -1) {\n      //Do nothing. Leave comments on same line.\n    } else {\n      if (!(parser_token.is_inline_element || parser_token.is_unformatted)) {\n        printer.print_newline(false);\n      }\n      this._calcluate_parent_multiline(printer, parser_token);\n    }\n  } else if (parser_token.is_end_tag) { //this tag is a double tag so check for tag-ending\n    var do_end_expand = false;\n\n    // deciding whether a block is multiline should not be this hard\n    do_end_expand = parser_token.start_tag_token && parser_token.start_tag_token.multiline_content;\n    do_end_expand = do_end_expand || (!parser_token.is_inline_element &&\n      !(last_tag_token.is_inline_element || last_tag_token.is_unformatted) &&\n      !(last_token.type === TOKEN.TAG_CLOSE && parser_token.start_tag_token === last_tag_token) &&\n      last_token.type !== 'TK_CONTENT'\n    );\n\n    if (parser_token.is_content_unformatted || parser_token.is_unformatted) {\n      do_end_expand = false;\n    }\n\n    if (do_end_expand) {\n      printer.print_newline(false);\n    }\n  } else { // it's a start-tag\n    parser_token.indent_content = !parser_token.custom_beautifier_name;\n\n    if (parser_token.tag_start_char === '<') {\n      if (parser_token.tag_name === 'html') {\n        parser_token.indent_content = this._options.indent_inner_html;\n      } else if (parser_token.tag_name === 'head') {\n        parser_token.indent_content = this._options.indent_head_inner_html;\n      } else if (parser_token.tag_name === 'body') {\n        parser_token.indent_content = this._options.indent_body_inner_html;\n      }\n    }\n\n    if (!(parser_token.is_inline_element || parser_token.is_unformatted) &&\n      (last_token.type !== 'TK_CONTENT' || parser_token.is_content_unformatted)) {\n      printer.print_newline(false);\n    }\n\n    this._calcluate_parent_multiline(printer, parser_token);\n  }\n};\n\nBeautifier.prototype._calcluate_parent_multiline = function(printer, parser_token) {\n  if (parser_token.parent && printer._output.just_added_newline() &&\n    !((parser_token.is_inline_element || parser_token.is_unformatted) && parser_token.parent.is_inline_element)) {\n    parser_token.parent.multiline_content = true;\n  }\n};\n\n//To be used for <p> tag special case:\nvar p_closers = ['address', 'article', 'aside', 'blockquote', 'details', 'div', 'dl', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'header', 'hr', 'main', 'nav', 'ol', 'p', 'pre', 'section', 'table', 'ul'];\nvar p_parent_excludes = ['a', 'audio', 'del', 'ins', 'map', 'noscript', 'video'];\n\nBeautifier.prototype._do_optional_end_element = function(parser_token) {\n  var result = null;\n  // NOTE: cases of \"if there is no more content in the parent element\"\n  // are handled automatically by the beautifier.\n  // It assumes parent or ancestor close tag closes all children.\n  // https://www.w3.org/TR/html5/syntax.html#optional-tags\n  if (parser_token.is_empty_element || !parser_token.is_start_tag || !parser_token.parent) {\n    return;\n\n  }\n\n  if (parser_token.tag_name === 'body') {\n    // A head element’s end tag may be omitted if the head element is not immediately followed by a space character or a comment.\n    result = result || this._tag_stack.try_pop('head');\n\n    //} else if (parser_token.tag_name === 'body') {\n    // DONE: A body element’s end tag may be omitted if the body element is not immediately followed by a comment.\n\n  } else if (parser_token.tag_name === 'li') {\n    // An li element’s end tag may be omitted if the li element is immediately followed by another li element or if there is no more content in the parent element.\n    result = result || this._tag_stack.try_pop('li', ['ol', 'ul']);\n\n  } else if (parser_token.tag_name === 'dd' || parser_token.tag_name === 'dt') {\n    // A dd element’s end tag may be omitted if the dd element is immediately followed by another dd element or a dt element, or if there is no more content in the parent element.\n    // A dt element’s end tag may be omitted if the dt element is immediately followed by another dt element or a dd element.\n    result = result || this._tag_stack.try_pop('dt', ['dl']);\n    result = result || this._tag_stack.try_pop('dd', ['dl']);\n\n\n  } else if (parser_token.parent.tag_name === 'p' && p_closers.indexOf(parser_token.tag_name) !== -1) {\n    // IMPORTANT: this else-if works because p_closers has no overlap with any other element we look for in this method\n    // check for the parent element is an HTML element that is not an <a>, <audio>, <del>, <ins>, <map>, <noscript>, or <video> element,  or an autonomous custom element.\n    // To do this right, this needs to be coded as an inclusion of the inverse of the exclusion above.\n    // But to start with (if we ignore \"autonomous custom elements\") the exclusion would be fine.\n    var p_parent = parser_token.parent.parent;\n    if (!p_parent || p_parent_excludes.indexOf(p_parent.tag_name) === -1) {\n      result = result || this._tag_stack.try_pop('p');\n    }\n  } else if (parser_token.tag_name === 'rp' || parser_token.tag_name === 'rt') {\n    // An rt element’s end tag may be omitted if the rt element is immediately followed by an rt or rp element, or if there is no more content in the parent element.\n    // An rp element’s end tag may be omitted if the rp element is immediately followed by an rt or rp element, or if there is no more content in the parent element.\n    result = result || this._tag_stack.try_pop('rt', ['ruby', 'rtc']);\n    result = result || this._tag_stack.try_pop('rp', ['ruby', 'rtc']);\n\n  } else if (parser_token.tag_name === 'optgroup') {\n    // An optgroup element’s end tag may be omitted if the optgroup element is immediately followed by another optgroup element, or if there is no more content in the parent element.\n    // An option element’s end tag may be omitted if the option element is immediately followed by another option element, or if it is immediately followed by an optgroup element, or if there is no more content in the parent element.\n    result = result || this._tag_stack.try_pop('optgroup', ['select']);\n    //result = result || this._tag_stack.try_pop('option', ['select']);\n\n  } else if (parser_token.tag_name === 'option') {\n    // An option element’s end tag may be omitted if the option element is immediately followed by another option element, or if it is immediately followed by an optgroup element, or if there is no more content in the parent element.\n    result = result || this._tag_stack.try_pop('option', ['select', 'datalist', 'optgroup']);\n\n  } else if (parser_token.tag_name === 'colgroup') {\n    // DONE: A colgroup element’s end tag may be omitted if the colgroup element is not immediately followed by a space character or a comment.\n    // A caption element's end tag may be ommitted if a colgroup, thead, tfoot, tbody, or tr element is started.\n    result = result || this._tag_stack.try_pop('caption', ['table']);\n\n  } else if (parser_token.tag_name === 'thead') {\n    // A colgroup element's end tag may be ommitted if a thead, tfoot, tbody, or tr element is started.\n    // A caption element's end tag may be ommitted if a colgroup, thead, tfoot, tbody, or tr element is started.\n    result = result || this._tag_stack.try_pop('caption', ['table']);\n    result = result || this._tag_stack.try_pop('colgroup', ['table']);\n\n    //} else if (parser_token.tag_name === 'caption') {\n    // DONE: A caption element’s end tag may be omitted if the caption element is not immediately followed by a space character or a comment.\n\n  } else if (parser_token.tag_name === 'tbody' || parser_token.tag_name === 'tfoot') {\n    // A thead element’s end tag may be omitted if the thead element is immediately followed by a tbody or tfoot element.\n    // A tbody element’s end tag may be omitted if the tbody element is immediately followed by a tbody or tfoot element, or if there is no more content in the parent element.\n    // A colgroup element's end tag may be ommitted if a thead, tfoot, tbody, or tr element is started.\n    // A caption element's end tag may be ommitted if a colgroup, thead, tfoot, tbody, or tr element is started.\n    result = result || this._tag_stack.try_pop('caption', ['table']);\n    result = result || this._tag_stack.try_pop('colgroup', ['table']);\n    result = result || this._tag_stack.try_pop('thead', ['table']);\n    result = result || this._tag_stack.try_pop('tbody', ['table']);\n\n    //} else if (parser_token.tag_name === 'tfoot') {\n    // DONE: A tfoot element’s end tag may be omitted if there is no more content in the parent element.\n\n  } else if (parser_token.tag_name === 'tr') {\n    // A tr element’s end tag may be omitted if the tr element is immediately followed by another tr element, or if there is no more content in the parent element.\n    // A colgroup element's end tag may be ommitted if a thead, tfoot, tbody, or tr element is started.\n    // A caption element's end tag may be ommitted if a colgroup, thead, tfoot, tbody, or tr element is started.\n    result = result || this._tag_stack.try_pop('caption', ['table']);\n    result = result || this._tag_stack.try_pop('colgroup', ['table']);\n    result = result || this._tag_stack.try_pop('tr', ['table', 'thead', 'tbody', 'tfoot']);\n\n  } else if (parser_token.tag_name === 'th' || parser_token.tag_name === 'td') {\n    // A td element’s end tag may be omitted if the td element is immediately followed by a td or th element, or if there is no more content in the parent element.\n    // A th element’s end tag may be omitted if the th element is immediately followed by a td or th element, or if there is no more content in the parent element.\n    result = result || this._tag_stack.try_pop('td', ['table', 'thead', 'tbody', 'tfoot', 'tr']);\n    result = result || this._tag_stack.try_pop('th', ['table', 'thead', 'tbody', 'tfoot', 'tr']);\n  }\n\n  // Start element omission not handled currently\n  // A head element’s start tag may be omitted if the element is empty, or if the first thing inside the head element is an element.\n  // A tbody element’s start tag may be omitted if the first thing inside the tbody element is a tr element, and if the element is not immediately preceded by a tbody, thead, or tfoot element whose end tag has been omitted. (It can’t be omitted if the element is empty.)\n  // A colgroup element’s start tag may be omitted if the first thing inside the colgroup element is a col element, and if the element is not immediately preceded by another colgroup element whose end tag has been omitted. (It can’t be omitted if the element is empty.)\n\n  // Fix up the parent of the parser token\n  parser_token.parent = this._tag_stack.get_parser_token();\n\n  return result;\n};\n\nmodule.exports.Beautifier = Beautifier;\n\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*jshint node:true */\n/*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/\n\n\n\nvar BaseOptions = __webpack_require__(6).Options;\n\nfunction Options(options) {\n  BaseOptions.call(this, options, 'html');\n  if (this.templating.length === 1 && this.templating[0] === 'auto') {\n    this.templating = ['django', 'erb', 'handlebars', 'php'];\n  }\n\n  this.indent_inner_html = this._get_boolean('indent_inner_html');\n  this.indent_body_inner_html = this._get_boolean('indent_body_inner_html', true);\n  this.indent_head_inner_html = this._get_boolean('indent_head_inner_html', true);\n\n  this.indent_handlebars = this._get_boolean('indent_handlebars', true);\n  this.wrap_attributes = this._get_selection('wrap_attributes',\n    ['auto', 'force', 'force-aligned', 'force-expand-multiline', 'aligned-multiple', 'preserve', 'preserve-aligned']);\n  this.wrap_attributes_indent_size = this._get_number('wrap_attributes_indent_size', this.indent_size);\n  this.extra_liners = this._get_array('extra_liners', ['head', 'body', '/html']);\n\n  // Block vs inline elements\n  // https://developer.mozilla.org/en-US/docs/Web/HTML/Block-level_elements\n  // https://developer.mozilla.org/en-US/docs/Web/HTML/Inline_elements\n  // https://www.w3.org/TR/html5/dom.html#phrasing-content\n  this.inline = this._get_array('inline', [\n    'a', 'abbr', 'area', 'audio', 'b', 'bdi', 'bdo', 'br', 'button', 'canvas', 'cite',\n    'code', 'data', 'datalist', 'del', 'dfn', 'em', 'embed', 'i', 'iframe', 'img',\n    'input', 'ins', 'kbd', 'keygen', 'label', 'map', 'mark', 'math', 'meter', 'noscript',\n    'object', 'output', 'progress', 'q', 'ruby', 's', 'samp', /* 'script', */ 'select', 'small',\n    'span', 'strong', 'sub', 'sup', 'svg', 'template', 'textarea', 'time', 'u', 'var',\n    'video', 'wbr', 'text',\n    // obsolete inline tags\n    'acronym', 'big', 'strike', 'tt'\n  ]);\n  this.void_elements = this._get_array('void_elements', [\n    // HTLM void elements - aka self-closing tags - aka singletons\n    // https://www.w3.org/html/wg/drafts/html/master/syntax.html#void-elements\n    'area', 'base', 'br', 'col', 'embed', 'hr', 'img', 'input', 'keygen',\n    'link', 'menuitem', 'meta', 'param', 'source', 'track', 'wbr',\n    // NOTE: Optional tags are too complex for a simple list\n    // they are hard coded in _do_optional_end_element\n\n    // Doctype and xml elements\n    '!doctype', '?xml',\n\n    // obsolete tags\n    // basefont: https://www.computerhope.com/jargon/h/html-basefont-tag.htm\n    // isndex: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/isindex\n    'basefont', 'isindex'\n  ]);\n  this.unformatted = this._get_array('unformatted', []);\n  this.content_unformatted = this._get_array('content_unformatted', [\n    'pre', 'textarea'\n  ]);\n  this.unformatted_content_delimiter = this._get_characters('unformatted_content_delimiter');\n  this.indent_scripts = this._get_selection('indent_scripts', ['normal', 'keep', 'separate']);\n\n}\nOptions.prototype = new BaseOptions();\n\n\n\nmodule.exports.Options = Options;\n\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*jshint node:true */\n/*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/\n\n\n\nvar BaseTokenizer = __webpack_require__(9).Tokenizer;\nvar BASETOKEN = __webpack_require__(9).TOKEN;\nvar Directives = __webpack_require__(13).Directives;\nvar TemplatablePattern = __webpack_require__(14).TemplatablePattern;\nvar Pattern = __webpack_require__(12).Pattern;\n\nvar TOKEN = {\n  TAG_OPEN: 'TK_TAG_OPEN',\n  TAG_CLOSE: 'TK_TAG_CLOSE',\n  ATTRIBUTE: 'TK_ATTRIBUTE',\n  EQUALS: 'TK_EQUALS',\n  VALUE: 'TK_VALUE',\n  COMMENT: 'TK_COMMENT',\n  TEXT: 'TK_TEXT',\n  UNKNOWN: 'TK_UNKNOWN',\n  START: BASETOKEN.START,\n  RAW: BASETOKEN.RAW,\n  EOF: BASETOKEN.EOF\n};\n\nvar directives_core = new Directives(/<\\!--/, /-->/);\n\nvar Tokenizer = function(input_string, options) {\n  BaseTokenizer.call(this, input_string, options);\n  this._current_tag_name = '';\n\n  // Words end at whitespace or when a tag starts\n  // if we are indenting handlebars, they are considered tags\n  var templatable_reader = new TemplatablePattern(this._input).read_options(this._options);\n  var pattern_reader = new Pattern(this._input);\n\n  this.__patterns = {\n    word: templatable_reader.until(/[\\n\\r\\t <]/),\n    single_quote: templatable_reader.until_after(/'/),\n    double_quote: templatable_reader.until_after(/\"/),\n    attribute: templatable_reader.until(/[\\n\\r\\t =>]|\\/>/),\n    element_name: templatable_reader.until(/[\\n\\r\\t >\\/]/),\n\n    handlebars_comment: pattern_reader.starting_with(/{{!--/).until_after(/--}}/),\n    handlebars: pattern_reader.starting_with(/{{/).until_after(/}}/),\n    handlebars_open: pattern_reader.until(/[\\n\\r\\t }]/),\n    handlebars_raw_close: pattern_reader.until(/}}/),\n    comment: pattern_reader.starting_with(/<!--/).until_after(/-->/),\n    cdata: pattern_reader.starting_with(/<!\\[CDATA\\[/).until_after(/]]>/),\n    // https://en.wikipedia.org/wiki/Conditional_comment\n    conditional_comment: pattern_reader.starting_with(/<!\\[/).until_after(/]>/),\n    processing: pattern_reader.starting_with(/<\\?/).until_after(/\\?>/)\n  };\n\n  if (this._options.indent_handlebars) {\n    this.__patterns.word = this.__patterns.word.exclude('handlebars');\n  }\n\n  this._unformatted_content_delimiter = null;\n\n  if (this._options.unformatted_content_delimiter) {\n    var literal_regexp = this._input.get_literal_regexp(this._options.unformatted_content_delimiter);\n    this.__patterns.unformatted_content_delimiter =\n      pattern_reader.matching(literal_regexp)\n      .until_after(literal_regexp);\n  }\n};\nTokenizer.prototype = new BaseTokenizer();\n\nTokenizer.prototype._is_comment = function(current_token) { // jshint unused:false\n  return false; //current_token.type === TOKEN.COMMENT || current_token.type === TOKEN.UNKNOWN;\n};\n\nTokenizer.prototype._is_opening = function(current_token) {\n  return current_token.type === TOKEN.TAG_OPEN;\n};\n\nTokenizer.prototype._is_closing = function(current_token, open_token) {\n  return current_token.type === TOKEN.TAG_CLOSE &&\n    (open_token && (\n      ((current_token.text === '>' || current_token.text === '/>') && open_token.text[0] === '<') ||\n      (current_token.text === '}}' && open_token.text[0] === '{' && open_token.text[1] === '{')));\n};\n\nTokenizer.prototype._reset = function() {\n  this._current_tag_name = '';\n};\n\nTokenizer.prototype._get_next_token = function(previous_token, open_token) { // jshint unused:false\n  var token = null;\n  this._readWhitespace();\n  var c = this._input.peek();\n\n  if (c === null) {\n    return this._create_token(TOKEN.EOF, '');\n  }\n\n  token = token || this._read_open_handlebars(c, open_token);\n  token = token || this._read_attribute(c, previous_token, open_token);\n  token = token || this._read_close(c, open_token);\n  token = token || this._read_raw_content(c, previous_token, open_token);\n  token = token || this._read_content_word(c);\n  token = token || this._read_comment_or_cdata(c);\n  token = token || this._read_processing(c);\n  token = token || this._read_open(c, open_token);\n  token = token || this._create_token(TOKEN.UNKNOWN, this._input.next());\n\n  return token;\n};\n\nTokenizer.prototype._read_comment_or_cdata = function(c) { // jshint unused:false\n  var token = null;\n  var resulting_string = null;\n  var directives = null;\n\n  if (c === '<') {\n    var peek1 = this._input.peek(1);\n    // We treat all comments as literals, even more than preformatted tags\n    // we only look for the appropriate closing marker\n    if (peek1 === '!') {\n      resulting_string = this.__patterns.comment.read();\n\n      // only process directive on html comments\n      if (resulting_string) {\n        directives = directives_core.get_directives(resulting_string);\n        if (directives && directives.ignore === 'start') {\n          resulting_string += directives_core.readIgnored(this._input);\n        }\n      } else {\n        resulting_string = this.__patterns.cdata.read();\n      }\n    }\n\n    if (resulting_string) {\n      token = this._create_token(TOKEN.COMMENT, resulting_string);\n      token.directives = directives;\n    }\n  }\n\n  return token;\n};\n\nTokenizer.prototype._read_processing = function(c) { // jshint unused:false\n  var token = null;\n  var resulting_string = null;\n  var directives = null;\n\n  if (c === '<') {\n    var peek1 = this._input.peek(1);\n    if (peek1 === '!' || peek1 === '?') {\n      resulting_string = this.__patterns.conditional_comment.read();\n      resulting_string = resulting_string || this.__patterns.processing.read();\n    }\n\n    if (resulting_string) {\n      token = this._create_token(TOKEN.COMMENT, resulting_string);\n      token.directives = directives;\n    }\n  }\n\n  return token;\n};\n\nTokenizer.prototype._read_open = function(c, open_token) {\n  var resulting_string = null;\n  var token = null;\n  if (!open_token) {\n    if (c === '<') {\n\n      resulting_string = this._input.next();\n      if (this._input.peek() === '/') {\n        resulting_string += this._input.next();\n      }\n      resulting_string += this.__patterns.element_name.read();\n      token = this._create_token(TOKEN.TAG_OPEN, resulting_string);\n    }\n  }\n  return token;\n};\n\nTokenizer.prototype._read_open_handlebars = function(c, open_token) {\n  var resulting_string = null;\n  var token = null;\n  if (!open_token) {\n    if (this._options.indent_handlebars && c === '{' && this._input.peek(1) === '{') {\n      if (this._input.peek(2) === '!') {\n        resulting_string = this.__patterns.handlebars_comment.read();\n        resulting_string = resulting_string || this.__patterns.handlebars.read();\n        token = this._create_token(TOKEN.COMMENT, resulting_string);\n      } else {\n        resulting_string = this.__patterns.handlebars_open.read();\n        token = this._create_token(TOKEN.TAG_OPEN, resulting_string);\n      }\n    }\n  }\n  return token;\n};\n\n\nTokenizer.prototype._read_close = function(c, open_token) {\n  var resulting_string = null;\n  var token = null;\n  if (open_token) {\n    if (open_token.text[0] === '<' && (c === '>' || (c === '/' && this._input.peek(1) === '>'))) {\n      resulting_string = this._input.next();\n      if (c === '/') { //  for close tag \"/>\"\n        resulting_string += this._input.next();\n      }\n      token = this._create_token(TOKEN.TAG_CLOSE, resulting_string);\n    } else if (open_token.text[0] === '{' && c === '}' && this._input.peek(1) === '}') {\n      this._input.next();\n      this._input.next();\n      token = this._create_token(TOKEN.TAG_CLOSE, '}}');\n    }\n  }\n\n  return token;\n};\n\nTokenizer.prototype._read_attribute = function(c, previous_token, open_token) {\n  var token = null;\n  var resulting_string = '';\n  if (open_token && open_token.text[0] === '<') {\n\n    if (c === '=') {\n      token = this._create_token(TOKEN.EQUALS, this._input.next());\n    } else if (c === '\"' || c === \"'\") {\n      var content = this._input.next();\n      if (c === '\"') {\n        content += this.__patterns.double_quote.read();\n      } else {\n        content += this.__patterns.single_quote.read();\n      }\n      token = this._create_token(TOKEN.VALUE, content);\n    } else {\n      resulting_string = this.__patterns.attribute.read();\n\n      if (resulting_string) {\n        if (previous_token.type === TOKEN.EQUALS) {\n          token = this._create_token(TOKEN.VALUE, resulting_string);\n        } else {\n          token = this._create_token(TOKEN.ATTRIBUTE, resulting_string);\n        }\n      }\n    }\n  }\n  return token;\n};\n\nTokenizer.prototype._is_content_unformatted = function(tag_name) {\n  // void_elements have no content and so cannot have unformatted content\n  // script and style tags should always be read as unformatted content\n  // finally content_unformatted and unformatted element contents are unformatted\n  return this._options.void_elements.indexOf(tag_name) === -1 &&\n    (this._options.content_unformatted.indexOf(tag_name) !== -1 ||\n      this._options.unformatted.indexOf(tag_name) !== -1);\n};\n\n\nTokenizer.prototype._read_raw_content = function(c, previous_token, open_token) { // jshint unused:false\n  var resulting_string = '';\n  if (open_token && open_token.text[0] === '{') {\n    resulting_string = this.__patterns.handlebars_raw_close.read();\n  } else if (previous_token.type === TOKEN.TAG_CLOSE &&\n    previous_token.opened.text[0] === '<' && previous_token.text[0] !== '/') {\n    // ^^ empty tag has no content \n    var tag_name = previous_token.opened.text.substr(1).toLowerCase();\n    if (tag_name === 'script' || tag_name === 'style') {\n      // Script and style tags are allowed to have comments wrapping their content\n      // or just have regular content.\n      var token = this._read_comment_or_cdata(c);\n      if (token) {\n        token.type = TOKEN.TEXT;\n        return token;\n      }\n      resulting_string = this._input.readUntil(new RegExp('</' + tag_name + '[\\\\n\\\\r\\\\t ]*?>', 'ig'));\n    } else if (this._is_content_unformatted(tag_name)) {\n\n      resulting_string = this._input.readUntil(new RegExp('</' + tag_name + '[\\\\n\\\\r\\\\t ]*?>', 'ig'));\n    }\n  }\n\n  if (resulting_string) {\n    return this._create_token(TOKEN.TEXT, resulting_string);\n  }\n\n  return null;\n};\n\nTokenizer.prototype._read_content_word = function(c) {\n  var resulting_string = '';\n  if (this._options.unformatted_content_delimiter) {\n    if (c === this._options.unformatted_content_delimiter[0]) {\n      resulting_string = this.__patterns.unformatted_content_delimiter.read();\n    }\n  }\n\n  if (!resulting_string) {\n    resulting_string = this.__patterns.word.read();\n  }\n  if (resulting_string) {\n    return this._create_token(TOKEN.TEXT, resulting_string);\n  }\n};\n\nmodule.exports.Tokenizer = Tokenizer;\nmodule.exports.TOKEN = TOKEN;\n\n\n/***/ })\n/******/ ]);\nvar style_html = legacy_beautify_html;\n/* Footer */\nif (true) {\n    // Add support for AMD ( https://github.com/amdjs/amdjs-api/wiki/AMD#defineamd-property- )\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, __webpack_require__(/*! ./beautify */ \"./node_modules/js-beautify/js/lib/beautify.js\"), __webpack_require__(/*! ./beautify-css */ \"./node_modules/js-beautify/js/lib/beautify-css.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function(requireamd) {\n        var js_beautify = __webpack_require__(/*! ./beautify */ \"./node_modules/js-beautify/js/lib/beautify.js\");\n        var css_beautify = __webpack_require__(/*! ./beautify-css */ \"./node_modules/js-beautify/js/lib/beautify-css.js\");\n\n        return {\n            html_beautify: function(html_source, options) {\n                return style_html(html_source, options, js_beautify.js_beautify, css_beautify.css_beautify);\n            }\n        };\n    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n} else { var css_beautify, js_beautify; }\n\n}());\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanMtYmVhdXRpZnkvanMvbGliL2JlYXV0aWZ5LWh0bWwuanM/YTZjMSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxNQUFNLE9BQU87QUFDekU7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGdDQUFnQztBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0Usa0JBQWtCO0FBQ2xGO0FBQ0EseURBQXlELGNBQWM7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsaUNBQWlDO0FBQ2xGLHdIQUF3SCxtQkFBbUIsRUFBRTtBQUM3STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsMEJBQTBCLEVBQUU7QUFDL0QseUNBQXlDLGVBQWU7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCwrREFBK0Q7QUFDN0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1REFBdUQsd0JBQXdCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLG9CQUFvQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qjs7O0FBRzlCLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUNBQWlDLDRDQUE0QyxFQUFFO0FBQy9FOzs7QUFHQTtBQUNBLG1CQUFtQixVQUFVO0FBQzdCO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDREQUE0RDtBQUM1RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLDRFQUE0RTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUEsMkRBQTJEO0FBQzNEO0FBQ0E7O0FBRUEsMkRBQTJEO0FBQzNEO0FBQ0E7O0FBRUEsdUVBQXVFO0FBQ3ZFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOzs7O0FBSUE7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsbUNBQW1DOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCx1QkFBdUI7QUFDeEUsb0RBQW9ELG1CQUFtQjtBQUN2RSx5Q0FBeUMsa0JBQWtCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxtQkFBbUI7QUFDdkQsMkNBQTJDLGtCQUFrQjtBQUM3RCw0Q0FBNEMsbUJBQW1CO0FBQy9EO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxrQkFBa0I7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxxREFBcUQ7O0FBRXJEO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGNBQWM7QUFDL0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTs7QUFFQSxxREFBcUQ7QUFDckQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLCtEQUErRDtBQUMvRDs7QUFFQSxpQkFBaUI7QUFDakIsNkNBQTZDO0FBQzdDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsOENBQThDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSyw0Q0FBNEM7QUFDakQ7QUFDQSxLQUFLLHVGQUF1RjtBQUM1RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxpREFBaUQsb0JBQW9CO0FBQ3JFOztBQUVBLG1CQUFtQjtBQUNuQixnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTs7QUFFQSxnRUFBZ0U7QUFDaEU7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4SEFBOEg7O0FBRTlIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxrQ0FBa0M7QUFDbEMsb0ZBQW9GO0FBQ3BGLEtBQUssT0FBTztBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtDQUErQzs7QUFFL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFFQUFxRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNDQUFzQzs7QUFFdEM7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0EsMENBQTBDLEtBQUs7QUFDL0MsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLG9DQUFvQztBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRyxPQUFPO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7O0FBRUEsR0FBRztBQUNIO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7QUFJQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdEQUF3RCx1QkFBdUI7QUFDL0UsZ0RBQWdELGtCQUFrQjtBQUNsRSxvREFBb0Q7QUFDcEQsa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyREFBMkQ7QUFDM0QsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyw4QkFBOEIsOEJBQThCO0FBQzdGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw0RUFBNEU7QUFDNUU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCwrQkFBK0I7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxLQUFLLG1DQUFtQyxhQUFhLCtCQUErQjtBQUNwRjtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLGlGQUFpRjtBQUNqRjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsSUFBSSxJQUEwQztBQUM5QztBQUNBLElBQUksaUNBQU8sQ0FBQyxtQkFBUyxFQUFFLHNGQUFZLEVBQUUsOEZBQWdCLENBQUMsbUNBQUU7QUFDeEQsMEJBQTBCLG1CQUFVLENBQUMsaUVBQVk7QUFDakQsMkJBQTJCLG1CQUFVLENBQUMseUVBQWdCOztBQUV0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUFBLG9HQUFDO0FBQ04sQ0FBQyxNQUFNLGtDQW1CTjs7QUFFRCxDQUFDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2pzLWJlYXV0aWZ5L2pzL2xpYi9iZWF1dGlmeS1odG1sLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyogQVVUTy1HRU5FUkFURUQuIERPIE5PVCBNT0RJRlkuICovXG4vKlxuXG4gIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4gIENvcHlyaWdodCAoYykgMjAwNy0yMDE4IEVpbmFyIExpZWxtYW5pcywgTGlhbSBOZXdtYW4sIGFuZCBjb250cmlidXRvcnMuXG5cbiAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICBTT0ZUV0FSRS5cblxuXG4gU3R5bGUgSFRNTFxuLS0tLS0tLS0tLS0tLS0tXG5cbiAgV3JpdHRlbiBieSBOb2NodW0gU29zc29ua28sIChuc29zc29ua29AaG90bWFpbC5jb20pXG5cbiAgQmFzZWQgb24gY29kZSBpbml0aWFsbHkgZGV2ZWxvcGVkIGJ5OiBFaW5hciBMaWVsbWFuaXMsIDxlaW5hckBiZWF1dGlmaWVyLmlvPlxuICAgIGh0dHBzOi8vYmVhdXRpZmllci5pby9cblxuICBVc2FnZTpcbiAgICBzdHlsZV9odG1sKGh0bWxfc291cmNlKTtcblxuICAgIHN0eWxlX2h0bWwoaHRtbF9zb3VyY2UsIG9wdGlvbnMpO1xuXG4gIFRoZSBvcHRpb25zIGFyZTpcbiAgICBpbmRlbnRfaW5uZXJfaHRtbCAoZGVmYXVsdCBmYWxzZSkgIOKAlCBpbmRlbnQgPGhlYWQ+IGFuZCA8Ym9keT4gc2VjdGlvbnMsXG4gICAgaW5kZW50X3NpemUgKGRlZmF1bHQgNCkgICAgICAgICAg4oCUIGluZGVudGF0aW9uIHNpemUsXG4gICAgaW5kZW50X2NoYXIgKGRlZmF1bHQgc3BhY2UpICAgICAg4oCUIGNoYXJhY3RlciB0byBpbmRlbnQgd2l0aCxcbiAgICB3cmFwX2xpbmVfbGVuZ3RoIChkZWZhdWx0IDI1MCkgICAgICAgICAgICAtICBtYXhpbXVtIGFtb3VudCBvZiBjaGFyYWN0ZXJzIHBlciBsaW5lICgwID0gZGlzYWJsZSlcbiAgICBicmFjZV9zdHlsZSAoZGVmYXVsdCBcImNvbGxhcHNlXCIpIC0gXCJjb2xsYXBzZVwiIHwgXCJleHBhbmRcIiB8IFwiZW5kLWV4cGFuZFwiIHwgXCJub25lXCJcbiAgICAgICAgICAgIHB1dCBicmFjZXMgb24gdGhlIHNhbWUgbGluZSBhcyBjb250cm9sIHN0YXRlbWVudHMgKGRlZmF1bHQpLCBvciBwdXQgYnJhY2VzIG9uIG93biBsaW5lIChBbGxtYW4gLyBBTlNJIHN0eWxlKSwgb3IganVzdCBwdXQgZW5kIGJyYWNlcyBvbiBvd24gbGluZSwgb3IgYXR0ZW1wdCB0byBrZWVwIHRoZW0gd2hlcmUgdGhleSBhcmUuXG4gICAgaW5saW5lIChkZWZhdWx0cyB0byBpbmxpbmUgdGFncykgLSBsaXN0IG9mIHRhZ3MgdG8gYmUgY29uc2lkZXJlZCBpbmxpbmUgdGFnc1xuICAgIHVuZm9ybWF0dGVkIChkZWZhdWx0cyB0byBpbmxpbmUgdGFncykgLSBsaXN0IG9mIHRhZ3MsIHRoYXQgc2hvdWxkbid0IGJlIHJlZm9ybWF0dGVkXG4gICAgY29udGVudF91bmZvcm1hdHRlZCAoZGVmYXVsdHMgdG8gW1wicHJlXCIsIFwidGV4dGFyZWFcIl0gdGFncykgLSBsaXN0IG9mIHRhZ3MsIHdob3NlIGNvbnRlbnQgc2hvdWxkbid0IGJlIHJlZm9ybWF0dGVkXG4gICAgaW5kZW50X3NjcmlwdHMgKGRlZmF1bHQgbm9ybWFsKSAgLSBcImtlZXBcInxcInNlcGFyYXRlXCJ8XCJub3JtYWxcIlxuICAgIHByZXNlcnZlX25ld2xpbmVzIChkZWZhdWx0IHRydWUpIC0gd2hldGhlciBleGlzdGluZyBsaW5lIGJyZWFrcyBiZWZvcmUgZWxlbWVudHMgc2hvdWxkIGJlIHByZXNlcnZlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9ubHkgd29ya3MgYmVmb3JlIGVsZW1lbnRzLCBub3QgaW5zaWRlIHRhZ3Mgb3IgZm9yIHRleHQuXG4gICAgbWF4X3ByZXNlcnZlX25ld2xpbmVzIChkZWZhdWx0IHVubGltaXRlZCkgLSBtYXhpbXVtIG51bWJlciBvZiBsaW5lIGJyZWFrcyB0byBiZSBwcmVzZXJ2ZWQgaW4gb25lIGNodW5rXG4gICAgaW5kZW50X2hhbmRsZWJhcnMgKGRlZmF1bHQgZmFsc2UpIC0gZm9ybWF0IGFuZCBpbmRlbnQge3sjZm9vfX0gYW5kIHt7L2Zvb319XG4gICAgZW5kX3dpdGhfbmV3bGluZSAoZmFsc2UpICAgICAgICAgIC0gZW5kIHdpdGggYSBuZXdsaW5lXG4gICAgZXh0cmFfbGluZXJzIChkZWZhdWx0IFtoZWFkLGJvZHksL2h0bWxdKSAtTGlzdCBvZiB0YWdzIHRoYXQgc2hvdWxkIGhhdmUgYW4gZXh0cmEgbmV3bGluZSBiZWZvcmUgdGhlbS5cblxuICAgIGUuZy5cblxuICAgIHN0eWxlX2h0bWwoaHRtbF9zb3VyY2UsIHtcbiAgICAgICdpbmRlbnRfaW5uZXJfaHRtbCc6IGZhbHNlLFxuICAgICAgJ2luZGVudF9zaXplJzogMixcbiAgICAgICdpbmRlbnRfY2hhcic6ICcgJyxcbiAgICAgICd3cmFwX2xpbmVfbGVuZ3RoJzogNzgsXG4gICAgICAnYnJhY2Vfc3R5bGUnOiAnZXhwYW5kJyxcbiAgICAgICdwcmVzZXJ2ZV9uZXdsaW5lcyc6IHRydWUsXG4gICAgICAnbWF4X3ByZXNlcnZlX25ld2xpbmVzJzogNSxcbiAgICAgICdpbmRlbnRfaGFuZGxlYmFycyc6IGZhbHNlLFxuICAgICAgJ2V4dHJhX2xpbmVycyc6IFsnL2h0bWwnXVxuICAgIH0pO1xuKi9cblxuKGZ1bmN0aW9uKCkge1xuXG4vKiBHRU5FUkFURURfQlVJTERfT1VUUFVUICovXG52YXIgbGVnYWN5X2JlYXV0aWZ5X2h0bWwgPVxuLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRpOiBtb2R1bGVJZCxcbi8qKioqKiovIFx0XHRcdGw6IGZhbHNlLFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbi8qKioqKiovIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbi8qKioqKiovIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4vKioqKioqLyBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuLyoqKioqKi8gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4vKioqKioqLyBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbi8qKioqKiovIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbi8qKioqKiovIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuLyoqKioqKi8gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4vKioqKioqLyBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuLyoqKioqKi8gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbi8qKioqKiovIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4vKioqKioqLyBcdFx0cmV0dXJuIG5zO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4vKioqKioqLyBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4vKioqKioqLyBcdFx0cmV0dXJuIGdldHRlcjtcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAxOCk7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIChbXG4vKiAwICovLFxuLyogMSAqLyxcbi8qIDIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKmpzaGludCBub2RlOnRydWUgKi9cbi8qXG4gIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4gIENvcHlyaWdodCAoYykgMjAwNy0yMDE4IEVpbmFyIExpZWxtYW5pcywgTGlhbSBOZXdtYW4sIGFuZCBjb250cmlidXRvcnMuXG5cbiAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICBTT0ZUV0FSRS5cbiovXG5cblxuXG5mdW5jdGlvbiBPdXRwdXRMaW5lKHBhcmVudCkge1xuICB0aGlzLl9fcGFyZW50ID0gcGFyZW50O1xuICB0aGlzLl9fY2hhcmFjdGVyX2NvdW50ID0gMDtcbiAgLy8gdXNlIGluZGVudF9jb3VudCBhcyBhIG1hcmtlciBmb3IgdGhpcy5fX2xpbmVzIHRoYXQgaGF2ZSBwcmVzZXJ2ZWQgaW5kZW50YXRpb25cbiAgdGhpcy5fX2luZGVudF9jb3VudCA9IC0xO1xuICB0aGlzLl9fYWxpZ25tZW50X2NvdW50ID0gMDtcbiAgdGhpcy5fX3dyYXBfcG9pbnRfaW5kZXggPSAwO1xuICB0aGlzLl9fd3JhcF9wb2ludF9jaGFyYWN0ZXJfY291bnQgPSAwO1xuICB0aGlzLl9fd3JhcF9wb2ludF9pbmRlbnRfY291bnQgPSAtMTtcbiAgdGhpcy5fX3dyYXBfcG9pbnRfYWxpZ25tZW50X2NvdW50ID0gMDtcblxuICB0aGlzLl9faXRlbXMgPSBbXTtcbn1cblxuT3V0cHV0TGluZS5wcm90b3R5cGUuY2xvbmVfZW1wdHkgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGxpbmUgPSBuZXcgT3V0cHV0TGluZSh0aGlzLl9fcGFyZW50KTtcbiAgbGluZS5zZXRfaW5kZW50KHRoaXMuX19pbmRlbnRfY291bnQsIHRoaXMuX19hbGlnbm1lbnRfY291bnQpO1xuICByZXR1cm4gbGluZTtcbn07XG5cbk91dHB1dExpbmUucHJvdG90eXBlLml0ZW0gPSBmdW5jdGlvbihpbmRleCkge1xuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgcmV0dXJuIHRoaXMuX19pdGVtc1t0aGlzLl9faXRlbXMubGVuZ3RoICsgaW5kZXhdO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0aGlzLl9faXRlbXNbaW5kZXhdO1xuICB9XG59O1xuXG5PdXRwdXRMaW5lLnByb3RvdHlwZS5oYXNfbWF0Y2ggPSBmdW5jdGlvbihwYXR0ZXJuKSB7XG4gIGZvciAodmFyIGxhc3RDaGVja2VkT3V0cHV0ID0gdGhpcy5fX2l0ZW1zLmxlbmd0aCAtIDE7IGxhc3RDaGVja2VkT3V0cHV0ID49IDA7IGxhc3RDaGVja2VkT3V0cHV0LS0pIHtcbiAgICBpZiAodGhpcy5fX2l0ZW1zW2xhc3RDaGVja2VkT3V0cHV0XS5tYXRjaChwYXR0ZXJuKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbk91dHB1dExpbmUucHJvdG90eXBlLnNldF9pbmRlbnQgPSBmdW5jdGlvbihpbmRlbnQsIGFsaWdubWVudCkge1xuICBpZiAodGhpcy5pc19lbXB0eSgpKSB7XG4gICAgdGhpcy5fX2luZGVudF9jb3VudCA9IGluZGVudCB8fCAwO1xuICAgIHRoaXMuX19hbGlnbm1lbnRfY291bnQgPSBhbGlnbm1lbnQgfHwgMDtcbiAgICB0aGlzLl9fY2hhcmFjdGVyX2NvdW50ID0gdGhpcy5fX3BhcmVudC5nZXRfaW5kZW50X3NpemUodGhpcy5fX2luZGVudF9jb3VudCwgdGhpcy5fX2FsaWdubWVudF9jb3VudCk7XG4gIH1cbn07XG5cbk91dHB1dExpbmUucHJvdG90eXBlLl9zZXRfd3JhcF9wb2ludCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5fX3BhcmVudC53cmFwX2xpbmVfbGVuZ3RoKSB7XG4gICAgdGhpcy5fX3dyYXBfcG9pbnRfaW5kZXggPSB0aGlzLl9faXRlbXMubGVuZ3RoO1xuICAgIHRoaXMuX193cmFwX3BvaW50X2NoYXJhY3Rlcl9jb3VudCA9IHRoaXMuX19jaGFyYWN0ZXJfY291bnQ7XG4gICAgdGhpcy5fX3dyYXBfcG9pbnRfaW5kZW50X2NvdW50ID0gdGhpcy5fX3BhcmVudC5uZXh0X2xpbmUuX19pbmRlbnRfY291bnQ7XG4gICAgdGhpcy5fX3dyYXBfcG9pbnRfYWxpZ25tZW50X2NvdW50ID0gdGhpcy5fX3BhcmVudC5uZXh0X2xpbmUuX19hbGlnbm1lbnRfY291bnQ7XG4gIH1cbn07XG5cbk91dHB1dExpbmUucHJvdG90eXBlLl9zaG91bGRfd3JhcCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fX3dyYXBfcG9pbnRfaW5kZXggJiZcbiAgICB0aGlzLl9fY2hhcmFjdGVyX2NvdW50ID4gdGhpcy5fX3BhcmVudC53cmFwX2xpbmVfbGVuZ3RoICYmXG4gICAgdGhpcy5fX3dyYXBfcG9pbnRfY2hhcmFjdGVyX2NvdW50ID4gdGhpcy5fX3BhcmVudC5uZXh0X2xpbmUuX19jaGFyYWN0ZXJfY291bnQ7XG59O1xuXG5PdXRwdXRMaW5lLnByb3RvdHlwZS5fYWxsb3dfd3JhcCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5fc2hvdWxkX3dyYXAoKSkge1xuICAgIHRoaXMuX19wYXJlbnQuYWRkX25ld19saW5lKCk7XG4gICAgdmFyIG5leHQgPSB0aGlzLl9fcGFyZW50LmN1cnJlbnRfbGluZTtcbiAgICBuZXh0LnNldF9pbmRlbnQodGhpcy5fX3dyYXBfcG9pbnRfaW5kZW50X2NvdW50LCB0aGlzLl9fd3JhcF9wb2ludF9hbGlnbm1lbnRfY291bnQpO1xuICAgIG5leHQuX19pdGVtcyA9IHRoaXMuX19pdGVtcy5zbGljZSh0aGlzLl9fd3JhcF9wb2ludF9pbmRleCk7XG4gICAgdGhpcy5fX2l0ZW1zID0gdGhpcy5fX2l0ZW1zLnNsaWNlKDAsIHRoaXMuX193cmFwX3BvaW50X2luZGV4KTtcblxuICAgIG5leHQuX19jaGFyYWN0ZXJfY291bnQgKz0gdGhpcy5fX2NoYXJhY3Rlcl9jb3VudCAtIHRoaXMuX193cmFwX3BvaW50X2NoYXJhY3Rlcl9jb3VudDtcbiAgICB0aGlzLl9fY2hhcmFjdGVyX2NvdW50ID0gdGhpcy5fX3dyYXBfcG9pbnRfY2hhcmFjdGVyX2NvdW50O1xuXG4gICAgaWYgKG5leHQuX19pdGVtc1swXSA9PT0gXCIgXCIpIHtcbiAgICAgIG5leHQuX19pdGVtcy5zcGxpY2UoMCwgMSk7XG4gICAgICBuZXh0Ll9fY2hhcmFjdGVyX2NvdW50IC09IDE7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbk91dHB1dExpbmUucHJvdG90eXBlLmlzX2VtcHR5ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9faXRlbXMubGVuZ3RoID09PSAwO1xufTtcblxuT3V0cHV0TGluZS5wcm90b3R5cGUubGFzdCA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMuaXNfZW1wdHkoKSkge1xuICAgIHJldHVybiB0aGlzLl9faXRlbXNbdGhpcy5fX2l0ZW1zLmxlbmd0aCAtIDFdO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59O1xuXG5PdXRwdXRMaW5lLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24oaXRlbSkge1xuICB0aGlzLl9faXRlbXMucHVzaChpdGVtKTtcbiAgdmFyIGxhc3RfbmV3bGluZV9pbmRleCA9IGl0ZW0ubGFzdEluZGV4T2YoJ1xcbicpO1xuICBpZiAobGFzdF9uZXdsaW5lX2luZGV4ICE9PSAtMSkge1xuICAgIHRoaXMuX19jaGFyYWN0ZXJfY291bnQgPSBpdGVtLmxlbmd0aCAtIGxhc3RfbmV3bGluZV9pbmRleDtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9fY2hhcmFjdGVyX2NvdW50ICs9IGl0ZW0ubGVuZ3RoO1xuICB9XG59O1xuXG5PdXRwdXRMaW5lLnByb3RvdHlwZS5wb3AgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGl0ZW0gPSBudWxsO1xuICBpZiAoIXRoaXMuaXNfZW1wdHkoKSkge1xuICAgIGl0ZW0gPSB0aGlzLl9faXRlbXMucG9wKCk7XG4gICAgdGhpcy5fX2NoYXJhY3Rlcl9jb3VudCAtPSBpdGVtLmxlbmd0aDtcbiAgfVxuICByZXR1cm4gaXRlbTtcbn07XG5cblxuT3V0cHV0TGluZS5wcm90b3R5cGUuX3JlbW92ZV9pbmRlbnQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuX19pbmRlbnRfY291bnQgPiAwKSB7XG4gICAgdGhpcy5fX2luZGVudF9jb3VudCAtPSAxO1xuICAgIHRoaXMuX19jaGFyYWN0ZXJfY291bnQgLT0gdGhpcy5fX3BhcmVudC5pbmRlbnRfc2l6ZTtcbiAgfVxufTtcblxuT3V0cHV0TGluZS5wcm90b3R5cGUuX3JlbW92ZV93cmFwX2luZGVudCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5fX3dyYXBfcG9pbnRfaW5kZW50X2NvdW50ID4gMCkge1xuICAgIHRoaXMuX193cmFwX3BvaW50X2luZGVudF9jb3VudCAtPSAxO1xuICB9XG59O1xuT3V0cHV0TGluZS5wcm90b3R5cGUudHJpbSA9IGZ1bmN0aW9uKCkge1xuICB3aGlsZSAodGhpcy5sYXN0KCkgPT09ICcgJykge1xuICAgIHRoaXMuX19pdGVtcy5wb3AoKTtcbiAgICB0aGlzLl9fY2hhcmFjdGVyX2NvdW50IC09IDE7XG4gIH1cbn07XG5cbk91dHB1dExpbmUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHZhciByZXN1bHQgPSAnJztcbiAgaWYgKHRoaXMuaXNfZW1wdHkoKSkge1xuICAgIGlmICh0aGlzLl9fcGFyZW50LmluZGVudF9lbXB0eV9saW5lcykge1xuICAgICAgcmVzdWx0ID0gdGhpcy5fX3BhcmVudC5nZXRfaW5kZW50X3N0cmluZyh0aGlzLl9faW5kZW50X2NvdW50KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0ID0gdGhpcy5fX3BhcmVudC5nZXRfaW5kZW50X3N0cmluZyh0aGlzLl9faW5kZW50X2NvdW50LCB0aGlzLl9fYWxpZ25tZW50X2NvdW50KTtcbiAgICByZXN1bHQgKz0gdGhpcy5fX2l0ZW1zLmpvaW4oJycpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5mdW5jdGlvbiBJbmRlbnRTdHJpbmdDYWNoZShvcHRpb25zLCBiYXNlSW5kZW50U3RyaW5nKSB7XG4gIHRoaXMuX19jYWNoZSA9IFsnJ107XG4gIHRoaXMuX19pbmRlbnRfc2l6ZSA9IG9wdGlvbnMuaW5kZW50X3NpemU7XG4gIHRoaXMuX19pbmRlbnRfc3RyaW5nID0gb3B0aW9ucy5pbmRlbnRfY2hhcjtcbiAgaWYgKCFvcHRpb25zLmluZGVudF93aXRoX3RhYnMpIHtcbiAgICB0aGlzLl9faW5kZW50X3N0cmluZyA9IG5ldyBBcnJheShvcHRpb25zLmluZGVudF9zaXplICsgMSkuam9pbihvcHRpb25zLmluZGVudF9jaGFyKTtcbiAgfVxuXG4gIC8vIFNldCB0byBudWxsIHRvIGNvbnRpbnVlIHN1cHBvcnQgZm9yIGF1dG8gZGV0ZWN0aW9uIG9mIGJhc2UgaW5kZW50XG4gIGJhc2VJbmRlbnRTdHJpbmcgPSBiYXNlSW5kZW50U3RyaW5nIHx8ICcnO1xuICBpZiAob3B0aW9ucy5pbmRlbnRfbGV2ZWwgPiAwKSB7XG4gICAgYmFzZUluZGVudFN0cmluZyA9IG5ldyBBcnJheShvcHRpb25zLmluZGVudF9sZXZlbCArIDEpLmpvaW4odGhpcy5fX2luZGVudF9zdHJpbmcpO1xuICB9XG5cbiAgdGhpcy5fX2Jhc2Vfc3RyaW5nID0gYmFzZUluZGVudFN0cmluZztcbiAgdGhpcy5fX2Jhc2Vfc3RyaW5nX2xlbmd0aCA9IGJhc2VJbmRlbnRTdHJpbmcubGVuZ3RoO1xufVxuXG5JbmRlbnRTdHJpbmdDYWNoZS5wcm90b3R5cGUuZ2V0X2luZGVudF9zaXplID0gZnVuY3Rpb24oaW5kZW50LCBjb2x1bW4pIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMuX19iYXNlX3N0cmluZ19sZW5ndGg7XG4gIGNvbHVtbiA9IGNvbHVtbiB8fCAwO1xuICBpZiAoaW5kZW50IDwgMCkge1xuICAgIHJlc3VsdCA9IDA7XG4gIH1cbiAgcmVzdWx0ICs9IGluZGVudCAqIHRoaXMuX19pbmRlbnRfc2l6ZTtcbiAgcmVzdWx0ICs9IGNvbHVtbjtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbkluZGVudFN0cmluZ0NhY2hlLnByb3RvdHlwZS5nZXRfaW5kZW50X3N0cmluZyA9IGZ1bmN0aW9uKGluZGVudF9sZXZlbCwgY29sdW1uKSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLl9fYmFzZV9zdHJpbmc7XG4gIGNvbHVtbiA9IGNvbHVtbiB8fCAwO1xuICBpZiAoaW5kZW50X2xldmVsIDwgMCkge1xuICAgIGluZGVudF9sZXZlbCA9IDA7XG4gICAgcmVzdWx0ID0gJyc7XG4gIH1cbiAgY29sdW1uICs9IGluZGVudF9sZXZlbCAqIHRoaXMuX19pbmRlbnRfc2l6ZTtcbiAgdGhpcy5fX2Vuc3VyZV9jYWNoZShjb2x1bW4pO1xuICByZXN1bHQgKz0gdGhpcy5fX2NhY2hlW2NvbHVtbl07XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5JbmRlbnRTdHJpbmdDYWNoZS5wcm90b3R5cGUuX19lbnN1cmVfY2FjaGUgPSBmdW5jdGlvbihjb2x1bW4pIHtcbiAgd2hpbGUgKGNvbHVtbiA+PSB0aGlzLl9fY2FjaGUubGVuZ3RoKSB7XG4gICAgdGhpcy5fX2FkZF9jb2x1bW4oKTtcbiAgfVxufTtcblxuSW5kZW50U3RyaW5nQ2FjaGUucHJvdG90eXBlLl9fYWRkX2NvbHVtbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgY29sdW1uID0gdGhpcy5fX2NhY2hlLmxlbmd0aDtcbiAgdmFyIGluZGVudCA9IDA7XG4gIHZhciByZXN1bHQgPSAnJztcbiAgaWYgKHRoaXMuX19pbmRlbnRfc2l6ZSAmJiBjb2x1bW4gPj0gdGhpcy5fX2luZGVudF9zaXplKSB7XG4gICAgaW5kZW50ID0gTWF0aC5mbG9vcihjb2x1bW4gLyB0aGlzLl9faW5kZW50X3NpemUpO1xuICAgIGNvbHVtbiAtPSBpbmRlbnQgKiB0aGlzLl9faW5kZW50X3NpemU7XG4gICAgcmVzdWx0ID0gbmV3IEFycmF5KGluZGVudCArIDEpLmpvaW4odGhpcy5fX2luZGVudF9zdHJpbmcpO1xuICB9XG4gIGlmIChjb2x1bW4pIHtcbiAgICByZXN1bHQgKz0gbmV3IEFycmF5KGNvbHVtbiArIDEpLmpvaW4oJyAnKTtcbiAgfVxuXG4gIHRoaXMuX19jYWNoZS5wdXNoKHJlc3VsdCk7XG59O1xuXG5mdW5jdGlvbiBPdXRwdXQob3B0aW9ucywgYmFzZUluZGVudFN0cmluZykge1xuICB0aGlzLl9faW5kZW50X2NhY2hlID0gbmV3IEluZGVudFN0cmluZ0NhY2hlKG9wdGlvbnMsIGJhc2VJbmRlbnRTdHJpbmcpO1xuICB0aGlzLnJhdyA9IGZhbHNlO1xuICB0aGlzLl9lbmRfd2l0aF9uZXdsaW5lID0gb3B0aW9ucy5lbmRfd2l0aF9uZXdsaW5lO1xuICB0aGlzLmluZGVudF9zaXplID0gb3B0aW9ucy5pbmRlbnRfc2l6ZTtcbiAgdGhpcy53cmFwX2xpbmVfbGVuZ3RoID0gb3B0aW9ucy53cmFwX2xpbmVfbGVuZ3RoO1xuICB0aGlzLmluZGVudF9lbXB0eV9saW5lcyA9IG9wdGlvbnMuaW5kZW50X2VtcHR5X2xpbmVzO1xuICB0aGlzLl9fbGluZXMgPSBbXTtcbiAgdGhpcy5wcmV2aW91c19saW5lID0gbnVsbDtcbiAgdGhpcy5jdXJyZW50X2xpbmUgPSBudWxsO1xuICB0aGlzLm5leHRfbGluZSA9IG5ldyBPdXRwdXRMaW5lKHRoaXMpO1xuICB0aGlzLnNwYWNlX2JlZm9yZV90b2tlbiA9IGZhbHNlO1xuICB0aGlzLm5vbl9icmVha2luZ19zcGFjZSA9IGZhbHNlO1xuICB0aGlzLnByZXZpb3VzX3Rva2VuX3dyYXBwZWQgPSBmYWxzZTtcbiAgLy8gaW5pdGlhbGl6ZVxuICB0aGlzLl9fYWRkX291dHB1dGxpbmUoKTtcbn1cblxuT3V0cHV0LnByb3RvdHlwZS5fX2FkZF9vdXRwdXRsaW5lID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMucHJldmlvdXNfbGluZSA9IHRoaXMuY3VycmVudF9saW5lO1xuICB0aGlzLmN1cnJlbnRfbGluZSA9IHRoaXMubmV4dF9saW5lLmNsb25lX2VtcHR5KCk7XG4gIHRoaXMuX19saW5lcy5wdXNoKHRoaXMuY3VycmVudF9saW5lKTtcbn07XG5cbk91dHB1dC5wcm90b3R5cGUuZ2V0X2xpbmVfbnVtYmVyID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9fbGluZXMubGVuZ3RoO1xufTtcblxuT3V0cHV0LnByb3RvdHlwZS5nZXRfaW5kZW50X3N0cmluZyA9IGZ1bmN0aW9uKGluZGVudCwgY29sdW1uKSB7XG4gIHJldHVybiB0aGlzLl9faW5kZW50X2NhY2hlLmdldF9pbmRlbnRfc3RyaW5nKGluZGVudCwgY29sdW1uKTtcbn07XG5cbk91dHB1dC5wcm90b3R5cGUuZ2V0X2luZGVudF9zaXplID0gZnVuY3Rpb24oaW5kZW50LCBjb2x1bW4pIHtcbiAgcmV0dXJuIHRoaXMuX19pbmRlbnRfY2FjaGUuZ2V0X2luZGVudF9zaXplKGluZGVudCwgY29sdW1uKTtcbn07XG5cbk91dHB1dC5wcm90b3R5cGUuaXNfZW1wdHkgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICF0aGlzLnByZXZpb3VzX2xpbmUgJiYgdGhpcy5jdXJyZW50X2xpbmUuaXNfZW1wdHkoKTtcbn07XG5cbk91dHB1dC5wcm90b3R5cGUuYWRkX25ld19saW5lID0gZnVuY3Rpb24oZm9yY2VfbmV3bGluZSkge1xuICAvLyBuZXZlciBuZXdsaW5lIGF0IHRoZSBzdGFydCBvZiBmaWxlXG4gIC8vIG90aGVyd2lzZSwgbmV3bGluZSBvbmx5IGlmIHdlIGRpZG4ndCBqdXN0IGFkZCBvbmUgb3Igd2UncmUgZm9yY2VkXG4gIGlmICh0aGlzLmlzX2VtcHR5KCkgfHxcbiAgICAoIWZvcmNlX25ld2xpbmUgJiYgdGhpcy5qdXN0X2FkZGVkX25ld2xpbmUoKSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBpZiByYXcgb3V0cHV0IGlzIGVuYWJsZWQsIGRvbid0IHByaW50IGFkZGl0aW9uYWwgbmV3bGluZXMsXG4gIC8vIGJ1dCBzdGlsbCByZXR1cm4gVHJ1ZSBhcyB0aG91Z2ggeW91IGhhZFxuICBpZiAoIXRoaXMucmF3KSB7XG4gICAgdGhpcy5fX2FkZF9vdXRwdXRsaW5lKCk7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLmdldF9jb2RlID0gZnVuY3Rpb24oZW9sKSB7XG4gIHRoaXMudHJpbSh0cnVlKTtcblxuICAvLyBoYW5kbGUgc29tZSBlZGdlIGNhc2VzIHdoZXJlIHRoZSBsYXN0IHRva2Vuc1xuICAvLyBoYXMgdGV4dCB0aGF0IGVuZHMgd2l0aCBuZXdsaW5lKHMpXG4gIHZhciBsYXN0X2l0ZW0gPSB0aGlzLmN1cnJlbnRfbGluZS5wb3AoKTtcbiAgaWYgKGxhc3RfaXRlbSkge1xuICAgIGlmIChsYXN0X2l0ZW1bbGFzdF9pdGVtLmxlbmd0aCAtIDFdID09PSAnXFxuJykge1xuICAgICAgbGFzdF9pdGVtID0gbGFzdF9pdGVtLnJlcGxhY2UoL1xcbiskL2csICcnKTtcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50X2xpbmUucHVzaChsYXN0X2l0ZW0pO1xuICB9XG5cbiAgaWYgKHRoaXMuX2VuZF93aXRoX25ld2xpbmUpIHtcbiAgICB0aGlzLl9fYWRkX291dHB1dGxpbmUoKTtcbiAgfVxuXG4gIHZhciBzd2VldF9jb2RlID0gdGhpcy5fX2xpbmVzLmpvaW4oJ1xcbicpO1xuXG4gIGlmIChlb2wgIT09ICdcXG4nKSB7XG4gICAgc3dlZXRfY29kZSA9IHN3ZWV0X2NvZGUucmVwbGFjZSgvW1xcbl0vZywgZW9sKTtcbiAgfVxuICByZXR1cm4gc3dlZXRfY29kZTtcbn07XG5cbk91dHB1dC5wcm90b3R5cGUuc2V0X3dyYXBfcG9pbnQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5jdXJyZW50X2xpbmUuX3NldF93cmFwX3BvaW50KCk7XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLnNldF9pbmRlbnQgPSBmdW5jdGlvbihpbmRlbnQsIGFsaWdubWVudCkge1xuICBpbmRlbnQgPSBpbmRlbnQgfHwgMDtcbiAgYWxpZ25tZW50ID0gYWxpZ25tZW50IHx8IDA7XG5cbiAgLy8gTmV4dCBsaW5lIHN0b3JlcyBhbGlnbm1lbnQgdmFsdWVzXG4gIHRoaXMubmV4dF9saW5lLnNldF9pbmRlbnQoaW5kZW50LCBhbGlnbm1lbnQpO1xuXG4gIC8vIE5ldmVyIGluZGVudCB5b3VyIGZpcnN0IG91dHB1dCBpbmRlbnQgYXQgdGhlIHN0YXJ0IG9mIHRoZSBmaWxlXG4gIGlmICh0aGlzLl9fbGluZXMubGVuZ3RoID4gMSkge1xuICAgIHRoaXMuY3VycmVudF9saW5lLnNldF9pbmRlbnQoaW5kZW50LCBhbGlnbm1lbnQpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgdGhpcy5jdXJyZW50X2xpbmUuc2V0X2luZGVudCgpO1xuICByZXR1cm4gZmFsc2U7XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLmFkZF9yYXdfdG9rZW4gPSBmdW5jdGlvbih0b2tlbikge1xuICBmb3IgKHZhciB4ID0gMDsgeCA8IHRva2VuLm5ld2xpbmVzOyB4KyspIHtcbiAgICB0aGlzLl9fYWRkX291dHB1dGxpbmUoKTtcbiAgfVxuICB0aGlzLmN1cnJlbnRfbGluZS5zZXRfaW5kZW50KC0xKTtcbiAgdGhpcy5jdXJyZW50X2xpbmUucHVzaCh0b2tlbi53aGl0ZXNwYWNlX2JlZm9yZSk7XG4gIHRoaXMuY3VycmVudF9saW5lLnB1c2godG9rZW4udGV4dCk7XG4gIHRoaXMuc3BhY2VfYmVmb3JlX3Rva2VuID0gZmFsc2U7XG4gIHRoaXMubm9uX2JyZWFraW5nX3NwYWNlID0gZmFsc2U7XG4gIHRoaXMucHJldmlvdXNfdG9rZW5fd3JhcHBlZCA9IGZhbHNlO1xufTtcblxuT3V0cHV0LnByb3RvdHlwZS5hZGRfdG9rZW4gPSBmdW5jdGlvbihwcmludGFibGVfdG9rZW4pIHtcbiAgdGhpcy5fX2FkZF9zcGFjZV9iZWZvcmVfdG9rZW4oKTtcbiAgdGhpcy5jdXJyZW50X2xpbmUucHVzaChwcmludGFibGVfdG9rZW4pO1xuICB0aGlzLnNwYWNlX2JlZm9yZV90b2tlbiA9IGZhbHNlO1xuICB0aGlzLm5vbl9icmVha2luZ19zcGFjZSA9IGZhbHNlO1xuICB0aGlzLnByZXZpb3VzX3Rva2VuX3dyYXBwZWQgPSB0aGlzLmN1cnJlbnRfbGluZS5fYWxsb3dfd3JhcCgpO1xufTtcblxuT3V0cHV0LnByb3RvdHlwZS5fX2FkZF9zcGFjZV9iZWZvcmVfdG9rZW4gPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuc3BhY2VfYmVmb3JlX3Rva2VuICYmICF0aGlzLmp1c3RfYWRkZWRfbmV3bGluZSgpKSB7XG4gICAgaWYgKCF0aGlzLm5vbl9icmVha2luZ19zcGFjZSkge1xuICAgICAgdGhpcy5zZXRfd3JhcF9wb2ludCgpO1xuICAgIH1cbiAgICB0aGlzLmN1cnJlbnRfbGluZS5wdXNoKCcgJyk7XG4gIH1cbn07XG5cbk91dHB1dC5wcm90b3R5cGUucmVtb3ZlX2luZGVudCA9IGZ1bmN0aW9uKGluZGV4KSB7XG4gIHZhciBvdXRwdXRfbGVuZ3RoID0gdGhpcy5fX2xpbmVzLmxlbmd0aDtcbiAgd2hpbGUgKGluZGV4IDwgb3V0cHV0X2xlbmd0aCkge1xuICAgIHRoaXMuX19saW5lc1tpbmRleF0uX3JlbW92ZV9pbmRlbnQoKTtcbiAgICBpbmRleCsrO1xuICB9XG4gIHRoaXMuY3VycmVudF9saW5lLl9yZW1vdmVfd3JhcF9pbmRlbnQoKTtcbn07XG5cbk91dHB1dC5wcm90b3R5cGUudHJpbSA9IGZ1bmN0aW9uKGVhdF9uZXdsaW5lcykge1xuICBlYXRfbmV3bGluZXMgPSAoZWF0X25ld2xpbmVzID09PSB1bmRlZmluZWQpID8gZmFsc2UgOiBlYXRfbmV3bGluZXM7XG5cbiAgdGhpcy5jdXJyZW50X2xpbmUudHJpbSgpO1xuXG4gIHdoaWxlIChlYXRfbmV3bGluZXMgJiYgdGhpcy5fX2xpbmVzLmxlbmd0aCA+IDEgJiZcbiAgICB0aGlzLmN1cnJlbnRfbGluZS5pc19lbXB0eSgpKSB7XG4gICAgdGhpcy5fX2xpbmVzLnBvcCgpO1xuICAgIHRoaXMuY3VycmVudF9saW5lID0gdGhpcy5fX2xpbmVzW3RoaXMuX19saW5lcy5sZW5ndGggLSAxXTtcbiAgICB0aGlzLmN1cnJlbnRfbGluZS50cmltKCk7XG4gIH1cblxuICB0aGlzLnByZXZpb3VzX2xpbmUgPSB0aGlzLl9fbGluZXMubGVuZ3RoID4gMSA/XG4gICAgdGhpcy5fX2xpbmVzW3RoaXMuX19saW5lcy5sZW5ndGggLSAyXSA6IG51bGw7XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLmp1c3RfYWRkZWRfbmV3bGluZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5jdXJyZW50X2xpbmUuaXNfZW1wdHkoKTtcbn07XG5cbk91dHB1dC5wcm90b3R5cGUuanVzdF9hZGRlZF9ibGFua2xpbmUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuaXNfZW1wdHkoKSB8fFxuICAgICh0aGlzLmN1cnJlbnRfbGluZS5pc19lbXB0eSgpICYmIHRoaXMucHJldmlvdXNfbGluZS5pc19lbXB0eSgpKTtcbn07XG5cbk91dHB1dC5wcm90b3R5cGUuZW5zdXJlX2VtcHR5X2xpbmVfYWJvdmUgPSBmdW5jdGlvbihzdGFydHNfd2l0aCwgZW5kc193aXRoKSB7XG4gIHZhciBpbmRleCA9IHRoaXMuX19saW5lcy5sZW5ndGggLSAyO1xuICB3aGlsZSAoaW5kZXggPj0gMCkge1xuICAgIHZhciBwb3RlbnRpYWxFbXB0eUxpbmUgPSB0aGlzLl9fbGluZXNbaW5kZXhdO1xuICAgIGlmIChwb3RlbnRpYWxFbXB0eUxpbmUuaXNfZW1wdHkoKSkge1xuICAgICAgYnJlYWs7XG4gICAgfSBlbHNlIGlmIChwb3RlbnRpYWxFbXB0eUxpbmUuaXRlbSgwKS5pbmRleE9mKHN0YXJ0c193aXRoKSAhPT0gMCAmJlxuICAgICAgcG90ZW50aWFsRW1wdHlMaW5lLml0ZW0oLTEpICE9PSBlbmRzX3dpdGgpIHtcbiAgICAgIHRoaXMuX19saW5lcy5zcGxpY2UoaW5kZXggKyAxLCAwLCBuZXcgT3V0cHV0TGluZSh0aGlzKSk7XG4gICAgICB0aGlzLnByZXZpb3VzX2xpbmUgPSB0aGlzLl9fbGluZXNbdGhpcy5fX2xpbmVzLmxlbmd0aCAtIDJdO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGluZGV4LS07XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzLk91dHB1dCA9IE91dHB1dDtcblxuXG4vKioqLyB9KSxcbi8qIDMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKmpzaGludCBub2RlOnRydWUgKi9cbi8qXG5cbiAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiAgQ29weXJpZ2h0IChjKSAyMDA3LTIwMTggRWluYXIgTGllbG1hbmlzLCBMaWFtIE5ld21hbiwgYW5kIGNvbnRyaWJ1dG9ycy5cblxuICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gIFNPRlRXQVJFLlxuKi9cblxuXG5cbmZ1bmN0aW9uIFRva2VuKHR5cGUsIHRleHQsIG5ld2xpbmVzLCB3aGl0ZXNwYWNlX2JlZm9yZSkge1xuICB0aGlzLnR5cGUgPSB0eXBlO1xuICB0aGlzLnRleHQgPSB0ZXh0O1xuXG4gIC8vIGNvbW1lbnRzX2JlZm9yZSBhcmVcbiAgLy8gY29tbWVudHMgdGhhdCBoYXZlIGEgbmV3IGxpbmUgYmVmb3JlIHRoZW1cbiAgLy8gYW5kIG1heSBvciBtYXkgbm90IGhhdmUgYSBuZXdsaW5lIGFmdGVyXG4gIC8vIHRoaXMgaXMgYSBzZXQgb2YgY29tbWVudHMgYmVmb3JlXG4gIHRoaXMuY29tbWVudHNfYmVmb3JlID0gbnVsbDsgLyogaW5saW5lIGNvbW1lbnQqL1xuXG5cbiAgLy8gdGhpcy5jb21tZW50c19hZnRlciA9ICBuZXcgVG9rZW5TdHJlYW0oKTsgLy8gbm8gbmV3IGxpbmUgYmVmb3JlIGFuZCBuZXdsaW5lIGFmdGVyXG4gIHRoaXMubmV3bGluZXMgPSBuZXdsaW5lcyB8fCAwO1xuICB0aGlzLndoaXRlc3BhY2VfYmVmb3JlID0gd2hpdGVzcGFjZV9iZWZvcmUgfHwgJyc7XG4gIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgdGhpcy5wcmV2aW91cyA9IG51bGw7XG4gIHRoaXMub3BlbmVkID0gbnVsbDtcbiAgdGhpcy5jbG9zZWQgPSBudWxsO1xuICB0aGlzLmRpcmVjdGl2ZXMgPSBudWxsO1xufVxuXG5cbm1vZHVsZS5leHBvcnRzLlRva2VuID0gVG9rZW47XG5cblxuLyoqKi8gfSksXG4vKiA0ICovLFxuLyogNSAqLyxcbi8qIDYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKmpzaGludCBub2RlOnRydWUgKi9cbi8qXG5cbiAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiAgQ29weXJpZ2h0IChjKSAyMDA3LTIwMTggRWluYXIgTGllbG1hbmlzLCBMaWFtIE5ld21hbiwgYW5kIGNvbnRyaWJ1dG9ycy5cblxuICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gIFNPRlRXQVJFLlxuKi9cblxuXG5cbmZ1bmN0aW9uIE9wdGlvbnMob3B0aW9ucywgbWVyZ2VfY2hpbGRfZmllbGQpIHtcbiAgdGhpcy5yYXdfb3B0aW9ucyA9IF9tZXJnZU9wdHMob3B0aW9ucywgbWVyZ2VfY2hpbGRfZmllbGQpO1xuXG4gIC8vIFN1cHBvcnQgcGFzc2luZyB0aGUgc291cmNlIHRleHQgYmFjayB3aXRoIG5vIGNoYW5nZVxuICB0aGlzLmRpc2FibGVkID0gdGhpcy5fZ2V0X2Jvb2xlYW4oJ2Rpc2FibGVkJyk7XG5cbiAgdGhpcy5lb2wgPSB0aGlzLl9nZXRfY2hhcmFjdGVycygnZW9sJywgJ2F1dG8nKTtcbiAgdGhpcy5lbmRfd2l0aF9uZXdsaW5lID0gdGhpcy5fZ2V0X2Jvb2xlYW4oJ2VuZF93aXRoX25ld2xpbmUnKTtcbiAgdGhpcy5pbmRlbnRfc2l6ZSA9IHRoaXMuX2dldF9udW1iZXIoJ2luZGVudF9zaXplJywgNCk7XG4gIHRoaXMuaW5kZW50X2NoYXIgPSB0aGlzLl9nZXRfY2hhcmFjdGVycygnaW5kZW50X2NoYXInLCAnICcpO1xuICB0aGlzLmluZGVudF9sZXZlbCA9IHRoaXMuX2dldF9udW1iZXIoJ2luZGVudF9sZXZlbCcpO1xuXG4gIHRoaXMucHJlc2VydmVfbmV3bGluZXMgPSB0aGlzLl9nZXRfYm9vbGVhbigncHJlc2VydmVfbmV3bGluZXMnLCB0cnVlKTtcbiAgdGhpcy5tYXhfcHJlc2VydmVfbmV3bGluZXMgPSB0aGlzLl9nZXRfbnVtYmVyKCdtYXhfcHJlc2VydmVfbmV3bGluZXMnLCAzMjc4Nik7XG4gIGlmICghdGhpcy5wcmVzZXJ2ZV9uZXdsaW5lcykge1xuICAgIHRoaXMubWF4X3ByZXNlcnZlX25ld2xpbmVzID0gMDtcbiAgfVxuXG4gIHRoaXMuaW5kZW50X3dpdGhfdGFicyA9IHRoaXMuX2dldF9ib29sZWFuKCdpbmRlbnRfd2l0aF90YWJzJywgdGhpcy5pbmRlbnRfY2hhciA9PT0gJ1xcdCcpO1xuICBpZiAodGhpcy5pbmRlbnRfd2l0aF90YWJzKSB7XG4gICAgdGhpcy5pbmRlbnRfY2hhciA9ICdcXHQnO1xuXG4gICAgLy8gaW5kZW50X3NpemUgYmVoYXZpb3IgY2hhbmdlZCBhZnRlciAxLjguNlxuICAgIC8vIEl0IHVzZWQgdG8gYmUgdGhhdCBpbmRlbnRfc2l6ZSB3b3VsZCBiZVxuICAgIC8vIHNldCB0byAxIGZvciBpbmRlbnRfd2l0aF90YWJzLiBUaGF0IGlzIG5vIGxvbmdlciBuZWVkZWQgYW5kXG4gICAgLy8gYWN0dWFsbHkgZG9lc24ndCBtYWtlIHNlbnNlIC0gd2h5IG5vdCB1c2Ugc3BhY2VzPyBGdXJ0aGVyLFxuICAgIC8vIHRoYXQgbWlnaHQgcHJvZHVjZSB1bmV4cGVjdGVkIGJlaGF2aW9yIC0gdGFicyBiZWluZyB1c2VkXG4gICAgLy8gZm9yIHNpbmdsZS1jb2x1bW4gYWxpZ25tZW50LiBTbywgd2hlbiBpbmRlbnRfd2l0aF90YWJzIGlzIHRydWVcbiAgICAvLyBhbmQgaW5kZW50X3NpemUgaXMgMSwgcmVzZXQgaW5kZW50X3NpemUgdG8gNC5cbiAgICBpZiAodGhpcy5pbmRlbnRfc2l6ZSA9PT0gMSkge1xuICAgICAgdGhpcy5pbmRlbnRfc2l6ZSA9IDQ7XG4gICAgfVxuICB9XG5cbiAgLy8gQmFja3dhcmRzIGNvbXBhdCB3aXRoIDEuMy54XG4gIHRoaXMud3JhcF9saW5lX2xlbmd0aCA9IHRoaXMuX2dldF9udW1iZXIoJ3dyYXBfbGluZV9sZW5ndGgnLCB0aGlzLl9nZXRfbnVtYmVyKCdtYXhfY2hhcicpKTtcblxuICB0aGlzLmluZGVudF9lbXB0eV9saW5lcyA9IHRoaXMuX2dldF9ib29sZWFuKCdpbmRlbnRfZW1wdHlfbGluZXMnKTtcblxuICAvLyB2YWxpZCB0ZW1wbGF0aW5nIGxhbmd1YWdlcyBbJ2RqYW5nbycsICdlcmInLCAnaGFuZGxlYmFycycsICdwaHAnXVxuICAvLyBGb3Igbm93LCAnYXV0bycgPSBhbGwgb2ZmIGZvciBqYXZhc2NyaXB0LCBhbGwgb24gZm9yIGh0bWwgKGFuZCBpbmxpbmUgamF2YXNjcmlwdCkuXG4gIC8vIG90aGVyIHZhbHVlcyBpZ25vcmVkXG4gIHRoaXMudGVtcGxhdGluZyA9IHRoaXMuX2dldF9zZWxlY3Rpb25fbGlzdCgndGVtcGxhdGluZycsIFsnYXV0bycsICdub25lJywgJ2RqYW5nbycsICdlcmInLCAnaGFuZGxlYmFycycsICdwaHAnXSwgWydhdXRvJ10pO1xufVxuXG5PcHRpb25zLnByb3RvdHlwZS5fZ2V0X2FycmF5ID0gZnVuY3Rpb24obmFtZSwgZGVmYXVsdF92YWx1ZSkge1xuICB2YXIgb3B0aW9uX3ZhbHVlID0gdGhpcy5yYXdfb3B0aW9uc1tuYW1lXTtcbiAgdmFyIHJlc3VsdCA9IGRlZmF1bHRfdmFsdWUgfHwgW107XG4gIGlmICh0eXBlb2Ygb3B0aW9uX3ZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgIGlmIChvcHRpb25fdmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIG9wdGlvbl92YWx1ZS5jb25jYXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJlc3VsdCA9IG9wdGlvbl92YWx1ZS5jb25jYXQoKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbl92YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXN1bHQgPSBvcHRpb25fdmFsdWUuc3BsaXQoL1teYS16QS1aMC05X1xcL1xcLV0rLyk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbk9wdGlvbnMucHJvdG90eXBlLl9nZXRfYm9vbGVhbiA9IGZ1bmN0aW9uKG5hbWUsIGRlZmF1bHRfdmFsdWUpIHtcbiAgdmFyIG9wdGlvbl92YWx1ZSA9IHRoaXMucmF3X29wdGlvbnNbbmFtZV07XG4gIHZhciByZXN1bHQgPSBvcHRpb25fdmFsdWUgPT09IHVuZGVmaW5lZCA/ICEhZGVmYXVsdF92YWx1ZSA6ICEhb3B0aW9uX3ZhbHVlO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuT3B0aW9ucy5wcm90b3R5cGUuX2dldF9jaGFyYWN0ZXJzID0gZnVuY3Rpb24obmFtZSwgZGVmYXVsdF92YWx1ZSkge1xuICB2YXIgb3B0aW9uX3ZhbHVlID0gdGhpcy5yYXdfb3B0aW9uc1tuYW1lXTtcbiAgdmFyIHJlc3VsdCA9IGRlZmF1bHRfdmFsdWUgfHwgJyc7XG4gIGlmICh0eXBlb2Ygb3B0aW9uX3ZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJlc3VsdCA9IG9wdGlvbl92YWx1ZS5yZXBsYWNlKC9cXFxcci8sICdcXHInKS5yZXBsYWNlKC9cXFxcbi8sICdcXG4nKS5yZXBsYWNlKC9cXFxcdC8sICdcXHQnKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuT3B0aW9ucy5wcm90b3R5cGUuX2dldF9udW1iZXIgPSBmdW5jdGlvbihuYW1lLCBkZWZhdWx0X3ZhbHVlKSB7XG4gIHZhciBvcHRpb25fdmFsdWUgPSB0aGlzLnJhd19vcHRpb25zW25hbWVdO1xuICBkZWZhdWx0X3ZhbHVlID0gcGFyc2VJbnQoZGVmYXVsdF92YWx1ZSwgMTApO1xuICBpZiAoaXNOYU4oZGVmYXVsdF92YWx1ZSkpIHtcbiAgICBkZWZhdWx0X3ZhbHVlID0gMDtcbiAgfVxuICB2YXIgcmVzdWx0ID0gcGFyc2VJbnQob3B0aW9uX3ZhbHVlLCAxMCk7XG4gIGlmIChpc05hTihyZXN1bHQpKSB7XG4gICAgcmVzdWx0ID0gZGVmYXVsdF92YWx1ZTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuT3B0aW9ucy5wcm90b3R5cGUuX2dldF9zZWxlY3Rpb24gPSBmdW5jdGlvbihuYW1lLCBzZWxlY3Rpb25fbGlzdCwgZGVmYXVsdF92YWx1ZSkge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5fZ2V0X3NlbGVjdGlvbl9saXN0KG5hbWUsIHNlbGVjdGlvbl9saXN0LCBkZWZhdWx0X3ZhbHVlKTtcbiAgaWYgKHJlc3VsdC5sZW5ndGggIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIkludmFsaWQgT3B0aW9uIFZhbHVlOiBUaGUgb3B0aW9uICdcIiArIG5hbWUgKyBcIicgY2FuIG9ubHkgYmUgb25lIG9mIHRoZSBmb2xsb3dpbmcgdmFsdWVzOlxcblwiICtcbiAgICAgIHNlbGVjdGlvbl9saXN0ICsgXCJcXG5Zb3UgcGFzc2VkIGluOiAnXCIgKyB0aGlzLnJhd19vcHRpb25zW25hbWVdICsgXCInXCIpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdFswXTtcbn07XG5cblxuT3B0aW9ucy5wcm90b3R5cGUuX2dldF9zZWxlY3Rpb25fbGlzdCA9IGZ1bmN0aW9uKG5hbWUsIHNlbGVjdGlvbl9saXN0LCBkZWZhdWx0X3ZhbHVlKSB7XG4gIGlmICghc2VsZWN0aW9uX2xpc3QgfHwgc2VsZWN0aW9uX2xpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiU2VsZWN0aW9uIGxpc3QgY2Fubm90IGJlIGVtcHR5LlwiKTtcbiAgfVxuXG4gIGRlZmF1bHRfdmFsdWUgPSBkZWZhdWx0X3ZhbHVlIHx8IFtzZWxlY3Rpb25fbGlzdFswXV07XG4gIGlmICghdGhpcy5faXNfdmFsaWRfc2VsZWN0aW9uKGRlZmF1bHRfdmFsdWUsIHNlbGVjdGlvbl9saXN0KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgRGVmYXVsdCBWYWx1ZSFcIik7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gdGhpcy5fZ2V0X2FycmF5KG5hbWUsIGRlZmF1bHRfdmFsdWUpO1xuICBpZiAoIXRoaXMuX2lzX3ZhbGlkX3NlbGVjdGlvbihyZXN1bHQsIHNlbGVjdGlvbl9saXN0KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiSW52YWxpZCBPcHRpb24gVmFsdWU6IFRoZSBvcHRpb24gJ1wiICsgbmFtZSArIFwiJyBjYW4gY29udGFpbiBvbmx5IHRoZSBmb2xsb3dpbmcgdmFsdWVzOlxcblwiICtcbiAgICAgIHNlbGVjdGlvbl9saXN0ICsgXCJcXG5Zb3UgcGFzc2VkIGluOiAnXCIgKyB0aGlzLnJhd19vcHRpb25zW25hbWVdICsgXCInXCIpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbk9wdGlvbnMucHJvdG90eXBlLl9pc192YWxpZF9zZWxlY3Rpb24gPSBmdW5jdGlvbihyZXN1bHQsIHNlbGVjdGlvbl9saXN0KSB7XG4gIHJldHVybiByZXN1bHQubGVuZ3RoICYmIHNlbGVjdGlvbl9saXN0Lmxlbmd0aCAmJlxuICAgICFyZXN1bHQuc29tZShmdW5jdGlvbihpdGVtKSB7IHJldHVybiBzZWxlY3Rpb25fbGlzdC5pbmRleE9mKGl0ZW0pID09PSAtMTsgfSk7XG59O1xuXG5cbi8vIG1lcmdlcyBjaGlsZCBvcHRpb25zIHVwIHdpdGggdGhlIHBhcmVudCBvcHRpb25zIG9iamVjdFxuLy8gRXhhbXBsZTogb2JqID0ge2E6IDEsIGI6IHthOiAyfX1cbi8vICAgICAgICAgIG1lcmdlT3B0cyhvYmosICdiJylcbi8vXG4vLyAgICAgICAgICBSZXR1cm5zOiB7YTogMn1cbmZ1bmN0aW9uIF9tZXJnZU9wdHMoYWxsT3B0aW9ucywgY2hpbGRGaWVsZE5hbWUpIHtcbiAgdmFyIGZpbmFsT3B0cyA9IHt9O1xuICBhbGxPcHRpb25zID0gX25vcm1hbGl6ZU9wdHMoYWxsT3B0aW9ucyk7XG4gIHZhciBuYW1lO1xuXG4gIGZvciAobmFtZSBpbiBhbGxPcHRpb25zKSB7XG4gICAgaWYgKG5hbWUgIT09IGNoaWxkRmllbGROYW1lKSB7XG4gICAgICBmaW5hbE9wdHNbbmFtZV0gPSBhbGxPcHRpb25zW25hbWVdO1xuICAgIH1cbiAgfVxuXG4gIC8vbWVyZ2UgaW4gdGhlIHBlciB0eXBlIHNldHRpbmdzIGZvciB0aGUgY2hpbGRGaWVsZE5hbWVcbiAgaWYgKGNoaWxkRmllbGROYW1lICYmIGFsbE9wdGlvbnNbY2hpbGRGaWVsZE5hbWVdKSB7XG4gICAgZm9yIChuYW1lIGluIGFsbE9wdGlvbnNbY2hpbGRGaWVsZE5hbWVdKSB7XG4gICAgICBmaW5hbE9wdHNbbmFtZV0gPSBhbGxPcHRpb25zW2NoaWxkRmllbGROYW1lXVtuYW1lXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZpbmFsT3B0cztcbn1cblxuZnVuY3Rpb24gX25vcm1hbGl6ZU9wdHMob3B0aW9ucykge1xuICB2YXIgY29udmVydGVkT3B0cyA9IHt9O1xuICB2YXIga2V5O1xuXG4gIGZvciAoa2V5IGluIG9wdGlvbnMpIHtcbiAgICB2YXIgbmV3S2V5ID0ga2V5LnJlcGxhY2UoLy0vZywgXCJfXCIpO1xuICAgIGNvbnZlcnRlZE9wdHNbbmV3S2V5XSA9IG9wdGlvbnNba2V5XTtcbiAgfVxuICByZXR1cm4gY29udmVydGVkT3B0cztcbn1cblxubW9kdWxlLmV4cG9ydHMuT3B0aW9ucyA9IE9wdGlvbnM7XG5tb2R1bGUuZXhwb3J0cy5ub3JtYWxpemVPcHRzID0gX25vcm1hbGl6ZU9wdHM7XG5tb2R1bGUuZXhwb3J0cy5tZXJnZU9wdHMgPSBfbWVyZ2VPcHRzO1xuXG5cbi8qKiovIH0pLFxuLyogNyAqLyxcbi8qIDggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKmpzaGludCBub2RlOnRydWUgKi9cbi8qXG5cbiAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiAgQ29weXJpZ2h0IChjKSAyMDA3LTIwMTggRWluYXIgTGllbG1hbmlzLCBMaWFtIE5ld21hbiwgYW5kIGNvbnRyaWJ1dG9ycy5cblxuICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gIFNPRlRXQVJFLlxuKi9cblxuXG5cbnZhciByZWdleHBfaGFzX3N0aWNreSA9IFJlZ0V4cC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkoJ3N0aWNreScpO1xuXG5mdW5jdGlvbiBJbnB1dFNjYW5uZXIoaW5wdXRfc3RyaW5nKSB7XG4gIHRoaXMuX19pbnB1dCA9IGlucHV0X3N0cmluZyB8fCAnJztcbiAgdGhpcy5fX2lucHV0X2xlbmd0aCA9IHRoaXMuX19pbnB1dC5sZW5ndGg7XG4gIHRoaXMuX19wb3NpdGlvbiA9IDA7XG59XG5cbklucHV0U2Nhbm5lci5wcm90b3R5cGUucmVzdGFydCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9fcG9zaXRpb24gPSAwO1xufTtcblxuSW5wdXRTY2FubmVyLnByb3RvdHlwZS5iYWNrID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLl9fcG9zaXRpb24gPiAwKSB7XG4gICAgdGhpcy5fX3Bvc2l0aW9uIC09IDE7XG4gIH1cbn07XG5cbklucHV0U2Nhbm5lci5wcm90b3R5cGUuaGFzTmV4dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fX3Bvc2l0aW9uIDwgdGhpcy5fX2lucHV0X2xlbmd0aDtcbn07XG5cbklucHV0U2Nhbm5lci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgdmFsID0gbnVsbDtcbiAgaWYgKHRoaXMuaGFzTmV4dCgpKSB7XG4gICAgdmFsID0gdGhpcy5fX2lucHV0LmNoYXJBdCh0aGlzLl9fcG9zaXRpb24pO1xuICAgIHRoaXMuX19wb3NpdGlvbiArPSAxO1xuICB9XG4gIHJldHVybiB2YWw7XG59O1xuXG5JbnB1dFNjYW5uZXIucHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbihpbmRleCkge1xuICB2YXIgdmFsID0gbnVsbDtcbiAgaW5kZXggPSBpbmRleCB8fCAwO1xuICBpbmRleCArPSB0aGlzLl9fcG9zaXRpb247XG4gIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgdGhpcy5fX2lucHV0X2xlbmd0aCkge1xuICAgIHZhbCA9IHRoaXMuX19pbnB1dC5jaGFyQXQoaW5kZXgpO1xuICB9XG4gIHJldHVybiB2YWw7XG59O1xuXG4vLyBUaGlzIGlzIGEgSmF2YVNjcmlwdCBvbmx5IGhlbHBlciBmdW5jdGlvbiAobm90IGluIHB5dGhvbilcbi8vIEphdmFzY3JpcHQgZG9lc24ndCBoYXZlIGEgbWF0Y2ggbWV0aG9kXG4vLyBhbmQgbm90IGFsbCBpbXBsZW1lbnRhdGlvbiBzdXBwb3J0IFwic3RpY2t5XCIgZmxhZy5cbi8vIElmIHRoZXkgZG8gbm90IHN1cHBvcnQgc3RpY2t5IHRoZW4gYm90aCB0aGlzLm1hdGNoKCkgYW5kIHRoaXMudGVzdCgpIG1ldGhvZFxuLy8gbXVzdCBnZXQgdGhlIG1hdGNoIGFuZCBjaGVjayB0aGUgaW5kZXggb2YgdGhlIG1hdGNoLlxuLy8gSWYgc3RpY2t5IGlzIHN1cHBvcnRlZCBhbmQgc2V0LCB0aGlzIG1ldGhvZCB3aWxsIHVzZSBpdC5cbi8vIE90aGVyd2lzZSBpdCB3aWxsIGNoZWNrIHRoYXQgZ2xvYmFsIGlzIHNldCwgYW5kIGZhbGwgYmFjayB0byB0aGUgc2xvd2VyIG1ldGhvZC5cbklucHV0U2Nhbm5lci5wcm90b3R5cGUuX19tYXRjaCA9IGZ1bmN0aW9uKHBhdHRlcm4sIGluZGV4KSB7XG4gIHBhdHRlcm4ubGFzdEluZGV4ID0gaW5kZXg7XG4gIHZhciBwYXR0ZXJuX21hdGNoID0gcGF0dGVybi5leGVjKHRoaXMuX19pbnB1dCk7XG5cbiAgaWYgKHBhdHRlcm5fbWF0Y2ggJiYgIShyZWdleHBfaGFzX3N0aWNreSAmJiBwYXR0ZXJuLnN0aWNreSkpIHtcbiAgICBpZiAocGF0dGVybl9tYXRjaC5pbmRleCAhPT0gaW5kZXgpIHtcbiAgICAgIHBhdHRlcm5fbWF0Y2ggPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYXR0ZXJuX21hdGNoO1xufTtcblxuSW5wdXRTY2FubmVyLnByb3RvdHlwZS50ZXN0ID0gZnVuY3Rpb24ocGF0dGVybiwgaW5kZXgpIHtcbiAgaW5kZXggPSBpbmRleCB8fCAwO1xuICBpbmRleCArPSB0aGlzLl9fcG9zaXRpb247XG5cbiAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPCB0aGlzLl9faW5wdXRfbGVuZ3RoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fX21hdGNoKHBhdHRlcm4sIGluZGV4KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbklucHV0U2Nhbm5lci5wcm90b3R5cGUudGVzdENoYXIgPSBmdW5jdGlvbihwYXR0ZXJuLCBpbmRleCkge1xuICAvLyB0ZXN0IG9uZSBjaGFyYWN0ZXIgcmVnZXggbWF0Y2hcbiAgdmFyIHZhbCA9IHRoaXMucGVlayhpbmRleCk7XG4gIHBhdHRlcm4ubGFzdEluZGV4ID0gMDtcbiAgcmV0dXJuIHZhbCAhPT0gbnVsbCAmJiBwYXR0ZXJuLnRlc3QodmFsKTtcbn07XG5cbklucHV0U2Nhbm5lci5wcm90b3R5cGUubWF0Y2ggPSBmdW5jdGlvbihwYXR0ZXJuKSB7XG4gIHZhciBwYXR0ZXJuX21hdGNoID0gdGhpcy5fX21hdGNoKHBhdHRlcm4sIHRoaXMuX19wb3NpdGlvbik7XG4gIGlmIChwYXR0ZXJuX21hdGNoKSB7XG4gICAgdGhpcy5fX3Bvc2l0aW9uICs9IHBhdHRlcm5fbWF0Y2hbMF0ubGVuZ3RoO1xuICB9IGVsc2Uge1xuICAgIHBhdHRlcm5fbWF0Y2ggPSBudWxsO1xuICB9XG4gIHJldHVybiBwYXR0ZXJuX21hdGNoO1xufTtcblxuSW5wdXRTY2FubmVyLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24oc3RhcnRpbmdfcGF0dGVybiwgdW50aWxfcGF0dGVybiwgdW50aWxfYWZ0ZXIpIHtcbiAgdmFyIHZhbCA9ICcnO1xuICB2YXIgbWF0Y2g7XG4gIGlmIChzdGFydGluZ19wYXR0ZXJuKSB7XG4gICAgbWF0Y2ggPSB0aGlzLm1hdGNoKHN0YXJ0aW5nX3BhdHRlcm4pO1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgdmFsICs9IG1hdGNoWzBdO1xuICAgIH1cbiAgfVxuICBpZiAodW50aWxfcGF0dGVybiAmJiAobWF0Y2ggfHwgIXN0YXJ0aW5nX3BhdHRlcm4pKSB7XG4gICAgdmFsICs9IHRoaXMucmVhZFVudGlsKHVudGlsX3BhdHRlcm4sIHVudGlsX2FmdGVyKTtcbiAgfVxuICByZXR1cm4gdmFsO1xufTtcblxuSW5wdXRTY2FubmVyLnByb3RvdHlwZS5yZWFkVW50aWwgPSBmdW5jdGlvbihwYXR0ZXJuLCB1bnRpbF9hZnRlcikge1xuICB2YXIgdmFsID0gJyc7XG4gIHZhciBtYXRjaF9pbmRleCA9IHRoaXMuX19wb3NpdGlvbjtcbiAgcGF0dGVybi5sYXN0SW5kZXggPSB0aGlzLl9fcG9zaXRpb247XG4gIHZhciBwYXR0ZXJuX21hdGNoID0gcGF0dGVybi5leGVjKHRoaXMuX19pbnB1dCk7XG4gIGlmIChwYXR0ZXJuX21hdGNoKSB7XG4gICAgbWF0Y2hfaW5kZXggPSBwYXR0ZXJuX21hdGNoLmluZGV4O1xuICAgIGlmICh1bnRpbF9hZnRlcikge1xuICAgICAgbWF0Y2hfaW5kZXggKz0gcGF0dGVybl9tYXRjaFswXS5sZW5ndGg7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG1hdGNoX2luZGV4ID0gdGhpcy5fX2lucHV0X2xlbmd0aDtcbiAgfVxuXG4gIHZhbCA9IHRoaXMuX19pbnB1dC5zdWJzdHJpbmcodGhpcy5fX3Bvc2l0aW9uLCBtYXRjaF9pbmRleCk7XG4gIHRoaXMuX19wb3NpdGlvbiA9IG1hdGNoX2luZGV4O1xuICByZXR1cm4gdmFsO1xufTtcblxuSW5wdXRTY2FubmVyLnByb3RvdHlwZS5yZWFkVW50aWxBZnRlciA9IGZ1bmN0aW9uKHBhdHRlcm4pIHtcbiAgcmV0dXJuIHRoaXMucmVhZFVudGlsKHBhdHRlcm4sIHRydWUpO1xufTtcblxuSW5wdXRTY2FubmVyLnByb3RvdHlwZS5nZXRfcmVnZXhwID0gZnVuY3Rpb24ocGF0dGVybiwgbWF0Y2hfZnJvbSkge1xuICB2YXIgcmVzdWx0ID0gbnVsbDtcbiAgdmFyIGZsYWdzID0gJ2cnO1xuICBpZiAobWF0Y2hfZnJvbSAmJiByZWdleHBfaGFzX3N0aWNreSkge1xuICAgIGZsYWdzID0gJ3knO1xuICB9XG4gIC8vIHN0cmluZ3MgYXJlIGNvbnZlcnRlZCB0byByZWdleHBcbiAgaWYgKHR5cGVvZiBwYXR0ZXJuID09PSBcInN0cmluZ1wiICYmIHBhdHRlcm4gIT09ICcnKSB7XG4gICAgLy8gcmVzdWx0ID0gbmV3IFJlZ0V4cChwYXR0ZXJuLnJlcGxhY2UoL1stXFwvXFxcXF4kKis/LigpfFtcXF17fV0vZywgJ1xcXFwkJicpLCBmbGFncyk7XG4gICAgcmVzdWx0ID0gbmV3IFJlZ0V4cChwYXR0ZXJuLCBmbGFncyk7XG4gIH0gZWxzZSBpZiAocGF0dGVybikge1xuICAgIHJlc3VsdCA9IG5ldyBSZWdFeHAocGF0dGVybi5zb3VyY2UsIGZsYWdzKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuSW5wdXRTY2FubmVyLnByb3RvdHlwZS5nZXRfbGl0ZXJhbF9yZWdleHAgPSBmdW5jdGlvbihsaXRlcmFsX3N0cmluZykge1xuICByZXR1cm4gUmVnRXhwKGxpdGVyYWxfc3RyaW5nLnJlcGxhY2UoL1stXFwvXFxcXF4kKis/LigpfFtcXF17fV0vZywgJ1xcXFwkJicpKTtcbn07XG5cbi8qIGNzcyBiZWF1dGlmaWVyIGxlZ2FjeSBoZWxwZXJzICovXG5JbnB1dFNjYW5uZXIucHJvdG90eXBlLnBlZWtVbnRpbEFmdGVyID0gZnVuY3Rpb24ocGF0dGVybikge1xuICB2YXIgc3RhcnQgPSB0aGlzLl9fcG9zaXRpb247XG4gIHZhciB2YWwgPSB0aGlzLnJlYWRVbnRpbEFmdGVyKHBhdHRlcm4pO1xuICB0aGlzLl9fcG9zaXRpb24gPSBzdGFydDtcbiAgcmV0dXJuIHZhbDtcbn07XG5cbklucHV0U2Nhbm5lci5wcm90b3R5cGUubG9va0JhY2sgPSBmdW5jdGlvbih0ZXN0VmFsKSB7XG4gIHZhciBzdGFydCA9IHRoaXMuX19wb3NpdGlvbiAtIDE7XG4gIHJldHVybiBzdGFydCA+PSB0ZXN0VmFsLmxlbmd0aCAmJiB0aGlzLl9faW5wdXQuc3Vic3RyaW5nKHN0YXJ0IC0gdGVzdFZhbC5sZW5ndGgsIHN0YXJ0KVxuICAgIC50b0xvd2VyQ2FzZSgpID09PSB0ZXN0VmFsO1xufTtcblxubW9kdWxlLmV4cG9ydHMuSW5wdXRTY2FubmVyID0gSW5wdXRTY2FubmVyO1xuXG5cbi8qKiovIH0pLFxuLyogOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qanNoaW50IG5vZGU6dHJ1ZSAqL1xuLypcblxuICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxOCBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgU09GVFdBUkUuXG4qL1xuXG5cblxudmFyIElucHV0U2Nhbm5lciA9IF9fd2VicGFja19yZXF1aXJlX18oOCkuSW5wdXRTY2FubmVyO1xudmFyIFRva2VuID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKS5Ub2tlbjtcbnZhciBUb2tlblN0cmVhbSA9IF9fd2VicGFja19yZXF1aXJlX18oMTApLlRva2VuU3RyZWFtO1xudmFyIFdoaXRlc3BhY2VQYXR0ZXJuID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSkuV2hpdGVzcGFjZVBhdHRlcm47XG5cbnZhciBUT0tFTiA9IHtcbiAgU1RBUlQ6ICdUS19TVEFSVCcsXG4gIFJBVzogJ1RLX1JBVycsXG4gIEVPRjogJ1RLX0VPRidcbn07XG5cbnZhciBUb2tlbml6ZXIgPSBmdW5jdGlvbihpbnB1dF9zdHJpbmcsIG9wdGlvbnMpIHtcbiAgdGhpcy5faW5wdXQgPSBuZXcgSW5wdXRTY2FubmVyKGlucHV0X3N0cmluZyk7XG4gIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB0aGlzLl9fdG9rZW5zID0gbnVsbDtcblxuICB0aGlzLl9wYXR0ZXJucyA9IHt9O1xuICB0aGlzLl9wYXR0ZXJucy53aGl0ZXNwYWNlID0gbmV3IFdoaXRlc3BhY2VQYXR0ZXJuKHRoaXMuX2lucHV0KTtcbn07XG5cblRva2VuaXplci5wcm90b3R5cGUudG9rZW5pemUgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5faW5wdXQucmVzdGFydCgpO1xuICB0aGlzLl9fdG9rZW5zID0gbmV3IFRva2VuU3RyZWFtKCk7XG5cbiAgdGhpcy5fcmVzZXQoKTtcblxuICB2YXIgY3VycmVudDtcbiAgdmFyIHByZXZpb3VzID0gbmV3IFRva2VuKFRPS0VOLlNUQVJULCAnJyk7XG4gIHZhciBvcGVuX3Rva2VuID0gbnVsbDtcbiAgdmFyIG9wZW5fc3RhY2sgPSBbXTtcbiAgdmFyIGNvbW1lbnRzID0gbmV3IFRva2VuU3RyZWFtKCk7XG5cbiAgd2hpbGUgKHByZXZpb3VzLnR5cGUgIT09IFRPS0VOLkVPRikge1xuICAgIGN1cnJlbnQgPSB0aGlzLl9nZXRfbmV4dF90b2tlbihwcmV2aW91cywgb3Blbl90b2tlbik7XG4gICAgd2hpbGUgKHRoaXMuX2lzX2NvbW1lbnQoY3VycmVudCkpIHtcbiAgICAgIGNvbW1lbnRzLmFkZChjdXJyZW50KTtcbiAgICAgIGN1cnJlbnQgPSB0aGlzLl9nZXRfbmV4dF90b2tlbihwcmV2aW91cywgb3Blbl90b2tlbik7XG4gICAgfVxuXG4gICAgaWYgKCFjb21tZW50cy5pc0VtcHR5KCkpIHtcbiAgICAgIGN1cnJlbnQuY29tbWVudHNfYmVmb3JlID0gY29tbWVudHM7XG4gICAgICBjb21tZW50cyA9IG5ldyBUb2tlblN0cmVhbSgpO1xuICAgIH1cblxuICAgIGN1cnJlbnQucGFyZW50ID0gb3Blbl90b2tlbjtcblxuICAgIGlmICh0aGlzLl9pc19vcGVuaW5nKGN1cnJlbnQpKSB7XG4gICAgICBvcGVuX3N0YWNrLnB1c2gob3Blbl90b2tlbik7XG4gICAgICBvcGVuX3Rva2VuID0gY3VycmVudDtcbiAgICB9IGVsc2UgaWYgKG9wZW5fdG9rZW4gJiYgdGhpcy5faXNfY2xvc2luZyhjdXJyZW50LCBvcGVuX3Rva2VuKSkge1xuICAgICAgY3VycmVudC5vcGVuZWQgPSBvcGVuX3Rva2VuO1xuICAgICAgb3Blbl90b2tlbi5jbG9zZWQgPSBjdXJyZW50O1xuICAgICAgb3Blbl90b2tlbiA9IG9wZW5fc3RhY2sucG9wKCk7XG4gICAgICBjdXJyZW50LnBhcmVudCA9IG9wZW5fdG9rZW47XG4gICAgfVxuXG4gICAgY3VycmVudC5wcmV2aW91cyA9IHByZXZpb3VzO1xuICAgIHByZXZpb3VzLm5leHQgPSBjdXJyZW50O1xuXG4gICAgdGhpcy5fX3Rva2Vucy5hZGQoY3VycmVudCk7XG4gICAgcHJldmlvdXMgPSBjdXJyZW50O1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuX190b2tlbnM7XG59O1xuXG5cblRva2VuaXplci5wcm90b3R5cGUuX2lzX2ZpcnN0X3Rva2VuID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9fdG9rZW5zLmlzRW1wdHkoKTtcbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX3Jlc2V0ID0gZnVuY3Rpb24oKSB7fTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5fZ2V0X25leHRfdG9rZW4gPSBmdW5jdGlvbihwcmV2aW91c190b2tlbiwgb3Blbl90b2tlbikgeyAvLyBqc2hpbnQgdW51c2VkOmZhbHNlXG4gIHRoaXMuX3JlYWRXaGl0ZXNwYWNlKCk7XG4gIHZhciByZXN1bHRpbmdfc3RyaW5nID0gdGhpcy5faW5wdXQucmVhZCgvLisvZyk7XG4gIGlmIChyZXN1bHRpbmdfc3RyaW5nKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NyZWF0ZV90b2tlbihUT0tFTi5SQVcsIHJlc3VsdGluZ19zdHJpbmcpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0aGlzLl9jcmVhdGVfdG9rZW4oVE9LRU4uRU9GLCAnJyk7XG4gIH1cbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX2lzX2NvbW1lbnQgPSBmdW5jdGlvbihjdXJyZW50X3Rva2VuKSB7IC8vIGpzaGludCB1bnVzZWQ6ZmFsc2VcbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5faXNfb3BlbmluZyA9IGZ1bmN0aW9uKGN1cnJlbnRfdG9rZW4pIHsgLy8ganNoaW50IHVudXNlZDpmYWxzZVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9pc19jbG9zaW5nID0gZnVuY3Rpb24oY3VycmVudF90b2tlbiwgb3Blbl90b2tlbikgeyAvLyBqc2hpbnQgdW51c2VkOmZhbHNlXG4gIHJldHVybiBmYWxzZTtcbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX2NyZWF0ZV90b2tlbiA9IGZ1bmN0aW9uKHR5cGUsIHRleHQpIHtcbiAgdmFyIHRva2VuID0gbmV3IFRva2VuKHR5cGUsIHRleHQsXG4gICAgdGhpcy5fcGF0dGVybnMud2hpdGVzcGFjZS5uZXdsaW5lX2NvdW50LFxuICAgIHRoaXMuX3BhdHRlcm5zLndoaXRlc3BhY2Uud2hpdGVzcGFjZV9iZWZvcmVfdG9rZW4pO1xuICByZXR1cm4gdG9rZW47XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9yZWFkV2hpdGVzcGFjZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fcGF0dGVybnMud2hpdGVzcGFjZS5yZWFkKCk7XG59O1xuXG5cblxubW9kdWxlLmV4cG9ydHMuVG9rZW5pemVyID0gVG9rZW5pemVyO1xubW9kdWxlLmV4cG9ydHMuVE9LRU4gPSBUT0tFTjtcblxuXG4vKioqLyB9KSxcbi8qIDEwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLypqc2hpbnQgbm9kZTp0cnVlICovXG4vKlxuXG4gIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4gIENvcHlyaWdodCAoYykgMjAwNy0yMDE4IEVpbmFyIExpZWxtYW5pcywgTGlhbSBOZXdtYW4sIGFuZCBjb250cmlidXRvcnMuXG5cbiAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICBTT0ZUV0FSRS5cbiovXG5cblxuXG5mdW5jdGlvbiBUb2tlblN0cmVhbShwYXJlbnRfdG9rZW4pIHtcbiAgLy8gcHJpdmF0ZVxuICB0aGlzLl9fdG9rZW5zID0gW107XG4gIHRoaXMuX190b2tlbnNfbGVuZ3RoID0gdGhpcy5fX3Rva2Vucy5sZW5ndGg7XG4gIHRoaXMuX19wb3NpdGlvbiA9IDA7XG4gIHRoaXMuX19wYXJlbnRfdG9rZW4gPSBwYXJlbnRfdG9rZW47XG59XG5cblRva2VuU3RyZWFtLnByb3RvdHlwZS5yZXN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX19wb3NpdGlvbiA9IDA7XG59O1xuXG5Ub2tlblN0cmVhbS5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fX3Rva2Vuc19sZW5ndGggPT09IDA7XG59O1xuXG5Ub2tlblN0cmVhbS5wcm90b3R5cGUuaGFzTmV4dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fX3Bvc2l0aW9uIDwgdGhpcy5fX3Rva2Vuc19sZW5ndGg7XG59O1xuXG5Ub2tlblN0cmVhbS5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgdmFsID0gbnVsbDtcbiAgaWYgKHRoaXMuaGFzTmV4dCgpKSB7XG4gICAgdmFsID0gdGhpcy5fX3Rva2Vuc1t0aGlzLl9fcG9zaXRpb25dO1xuICAgIHRoaXMuX19wb3NpdGlvbiArPSAxO1xuICB9XG4gIHJldHVybiB2YWw7XG59O1xuXG5Ub2tlblN0cmVhbS5wcm90b3R5cGUucGVlayA9IGZ1bmN0aW9uKGluZGV4KSB7XG4gIHZhciB2YWwgPSBudWxsO1xuICBpbmRleCA9IGluZGV4IHx8IDA7XG4gIGluZGV4ICs9IHRoaXMuX19wb3NpdGlvbjtcbiAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPCB0aGlzLl9fdG9rZW5zX2xlbmd0aCkge1xuICAgIHZhbCA9IHRoaXMuX190b2tlbnNbaW5kZXhdO1xuICB9XG4gIHJldHVybiB2YWw7XG59O1xuXG5Ub2tlblN0cmVhbS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24odG9rZW4pIHtcbiAgaWYgKHRoaXMuX19wYXJlbnRfdG9rZW4pIHtcbiAgICB0b2tlbi5wYXJlbnQgPSB0aGlzLl9fcGFyZW50X3Rva2VuO1xuICB9XG4gIHRoaXMuX190b2tlbnMucHVzaCh0b2tlbik7XG4gIHRoaXMuX190b2tlbnNfbGVuZ3RoICs9IDE7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5Ub2tlblN0cmVhbSA9IFRva2VuU3RyZWFtO1xuXG5cbi8qKiovIH0pLFxuLyogMTEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKmpzaGludCBub2RlOnRydWUgKi9cbi8qXG5cbiAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiAgQ29weXJpZ2h0IChjKSAyMDA3LTIwMTggRWluYXIgTGllbG1hbmlzLCBMaWFtIE5ld21hbiwgYW5kIGNvbnRyaWJ1dG9ycy5cblxuICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gIFNPRlRXQVJFLlxuKi9cblxuXG5cbnZhciBQYXR0ZXJuID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMikuUGF0dGVybjtcblxuZnVuY3Rpb24gV2hpdGVzcGFjZVBhdHRlcm4oaW5wdXRfc2Nhbm5lciwgcGFyZW50KSB7XG4gIFBhdHRlcm4uY2FsbCh0aGlzLCBpbnB1dF9zY2FubmVyLCBwYXJlbnQpO1xuICBpZiAocGFyZW50KSB7XG4gICAgdGhpcy5fbGluZV9yZWdleHAgPSB0aGlzLl9pbnB1dC5nZXRfcmVnZXhwKHBhcmVudC5fbGluZV9yZWdleHApO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX19zZXRfd2hpdGVzcGFjZV9wYXR0ZXJucygnJywgJycpO1xuICB9XG5cbiAgdGhpcy5uZXdsaW5lX2NvdW50ID0gMDtcbiAgdGhpcy53aGl0ZXNwYWNlX2JlZm9yZV90b2tlbiA9ICcnO1xufVxuV2hpdGVzcGFjZVBhdHRlcm4ucHJvdG90eXBlID0gbmV3IFBhdHRlcm4oKTtcblxuV2hpdGVzcGFjZVBhdHRlcm4ucHJvdG90eXBlLl9fc2V0X3doaXRlc3BhY2VfcGF0dGVybnMgPSBmdW5jdGlvbih3aGl0ZXNwYWNlX2NoYXJzLCBuZXdsaW5lX2NoYXJzKSB7XG4gIHdoaXRlc3BhY2VfY2hhcnMgKz0gJ1xcXFx0ICc7XG4gIG5ld2xpbmVfY2hhcnMgKz0gJ1xcXFxuXFxcXHInO1xuXG4gIHRoaXMuX21hdGNoX3BhdHRlcm4gPSB0aGlzLl9pbnB1dC5nZXRfcmVnZXhwKFxuICAgICdbJyArIHdoaXRlc3BhY2VfY2hhcnMgKyBuZXdsaW5lX2NoYXJzICsgJ10rJywgdHJ1ZSk7XG4gIHRoaXMuX25ld2xpbmVfcmVnZXhwID0gdGhpcy5faW5wdXQuZ2V0X3JlZ2V4cChcbiAgICAnXFxcXHJcXFxcbnxbJyArIG5ld2xpbmVfY2hhcnMgKyAnXScpO1xufTtcblxuV2hpdGVzcGFjZVBhdHRlcm4ucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5uZXdsaW5lX2NvdW50ID0gMDtcbiAgdGhpcy53aGl0ZXNwYWNlX2JlZm9yZV90b2tlbiA9ICcnO1xuXG4gIHZhciByZXN1bHRpbmdfc3RyaW5nID0gdGhpcy5faW5wdXQucmVhZCh0aGlzLl9tYXRjaF9wYXR0ZXJuKTtcbiAgaWYgKHJlc3VsdGluZ19zdHJpbmcgPT09ICcgJykge1xuICAgIHRoaXMud2hpdGVzcGFjZV9iZWZvcmVfdG9rZW4gPSAnICc7XG4gIH0gZWxzZSBpZiAocmVzdWx0aW5nX3N0cmluZykge1xuICAgIHZhciBtYXRjaGVzID0gdGhpcy5fX3NwbGl0KHRoaXMuX25ld2xpbmVfcmVnZXhwLCByZXN1bHRpbmdfc3RyaW5nKTtcbiAgICB0aGlzLm5ld2xpbmVfY291bnQgPSBtYXRjaGVzLmxlbmd0aCAtIDE7XG4gICAgdGhpcy53aGl0ZXNwYWNlX2JlZm9yZV90b2tlbiA9IG1hdGNoZXNbdGhpcy5uZXdsaW5lX2NvdW50XTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHRpbmdfc3RyaW5nO1xufTtcblxuV2hpdGVzcGFjZVBhdHRlcm4ucHJvdG90eXBlLm1hdGNoaW5nID0gZnVuY3Rpb24od2hpdGVzcGFjZV9jaGFycywgbmV3bGluZV9jaGFycykge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5fY3JlYXRlKCk7XG4gIHJlc3VsdC5fX3NldF93aGl0ZXNwYWNlX3BhdHRlcm5zKHdoaXRlc3BhY2VfY2hhcnMsIG5ld2xpbmVfY2hhcnMpO1xuICByZXN1bHQuX3VwZGF0ZSgpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuV2hpdGVzcGFjZVBhdHRlcm4ucHJvdG90eXBlLl9jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBXaGl0ZXNwYWNlUGF0dGVybih0aGlzLl9pbnB1dCwgdGhpcyk7XG59O1xuXG5XaGl0ZXNwYWNlUGF0dGVybi5wcm90b3R5cGUuX19zcGxpdCA9IGZ1bmN0aW9uKHJlZ2V4cCwgaW5wdXRfc3RyaW5nKSB7XG4gIHJlZ2V4cC5sYXN0SW5kZXggPSAwO1xuICB2YXIgc3RhcnRfaW5kZXggPSAwO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBuZXh0X21hdGNoID0gcmVnZXhwLmV4ZWMoaW5wdXRfc3RyaW5nKTtcbiAgd2hpbGUgKG5leHRfbWF0Y2gpIHtcbiAgICByZXN1bHQucHVzaChpbnB1dF9zdHJpbmcuc3Vic3RyaW5nKHN0YXJ0X2luZGV4LCBuZXh0X21hdGNoLmluZGV4KSk7XG4gICAgc3RhcnRfaW5kZXggPSBuZXh0X21hdGNoLmluZGV4ICsgbmV4dF9tYXRjaFswXS5sZW5ndGg7XG4gICAgbmV4dF9tYXRjaCA9IHJlZ2V4cC5leGVjKGlucHV0X3N0cmluZyk7XG4gIH1cblxuICBpZiAoc3RhcnRfaW5kZXggPCBpbnB1dF9zdHJpbmcubGVuZ3RoKSB7XG4gICAgcmVzdWx0LnB1c2goaW5wdXRfc3RyaW5nLnN1YnN0cmluZyhzdGFydF9pbmRleCwgaW5wdXRfc3RyaW5nLmxlbmd0aCkpO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdC5wdXNoKCcnKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cblxubW9kdWxlLmV4cG9ydHMuV2hpdGVzcGFjZVBhdHRlcm4gPSBXaGl0ZXNwYWNlUGF0dGVybjtcblxuXG4vKioqLyB9KSxcbi8qIDEyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLypqc2hpbnQgbm9kZTp0cnVlICovXG4vKlxuXG4gIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4gIENvcHlyaWdodCAoYykgMjAwNy0yMDE4IEVpbmFyIExpZWxtYW5pcywgTGlhbSBOZXdtYW4sIGFuZCBjb250cmlidXRvcnMuXG5cbiAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICBTT0ZUV0FSRS5cbiovXG5cblxuXG5mdW5jdGlvbiBQYXR0ZXJuKGlucHV0X3NjYW5uZXIsIHBhcmVudCkge1xuICB0aGlzLl9pbnB1dCA9IGlucHV0X3NjYW5uZXI7XG4gIHRoaXMuX3N0YXJ0aW5nX3BhdHRlcm4gPSBudWxsO1xuICB0aGlzLl9tYXRjaF9wYXR0ZXJuID0gbnVsbDtcbiAgdGhpcy5fdW50aWxfcGF0dGVybiA9IG51bGw7XG4gIHRoaXMuX3VudGlsX2FmdGVyID0gZmFsc2U7XG5cbiAgaWYgKHBhcmVudCkge1xuICAgIHRoaXMuX3N0YXJ0aW5nX3BhdHRlcm4gPSB0aGlzLl9pbnB1dC5nZXRfcmVnZXhwKHBhcmVudC5fc3RhcnRpbmdfcGF0dGVybiwgdHJ1ZSk7XG4gICAgdGhpcy5fbWF0Y2hfcGF0dGVybiA9IHRoaXMuX2lucHV0LmdldF9yZWdleHAocGFyZW50Ll9tYXRjaF9wYXR0ZXJuLCB0cnVlKTtcbiAgICB0aGlzLl91bnRpbF9wYXR0ZXJuID0gdGhpcy5faW5wdXQuZ2V0X3JlZ2V4cChwYXJlbnQuX3VudGlsX3BhdHRlcm4pO1xuICAgIHRoaXMuX3VudGlsX2FmdGVyID0gcGFyZW50Ll91bnRpbF9hZnRlcjtcbiAgfVxufVxuXG5QYXR0ZXJuLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24oKSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLl9pbnB1dC5yZWFkKHRoaXMuX3N0YXJ0aW5nX3BhdHRlcm4pO1xuICBpZiAoIXRoaXMuX3N0YXJ0aW5nX3BhdHRlcm4gfHwgcmVzdWx0KSB7XG4gICAgcmVzdWx0ICs9IHRoaXMuX2lucHV0LnJlYWQodGhpcy5fbWF0Y2hfcGF0dGVybiwgdGhpcy5fdW50aWxfcGF0dGVybiwgdGhpcy5fdW50aWxfYWZ0ZXIpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5QYXR0ZXJuLnByb3RvdHlwZS5yZWFkX21hdGNoID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9pbnB1dC5tYXRjaCh0aGlzLl9tYXRjaF9wYXR0ZXJuKTtcbn07XG5cblBhdHRlcm4ucHJvdG90eXBlLnVudGlsX2FmdGVyID0gZnVuY3Rpb24ocGF0dGVybikge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5fY3JlYXRlKCk7XG4gIHJlc3VsdC5fdW50aWxfYWZ0ZXIgPSB0cnVlO1xuICByZXN1bHQuX3VudGlsX3BhdHRlcm4gPSB0aGlzLl9pbnB1dC5nZXRfcmVnZXhwKHBhdHRlcm4pO1xuICByZXN1bHQuX3VwZGF0ZSgpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuUGF0dGVybi5wcm90b3R5cGUudW50aWwgPSBmdW5jdGlvbihwYXR0ZXJuKSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLl9jcmVhdGUoKTtcbiAgcmVzdWx0Ll91bnRpbF9hZnRlciA9IGZhbHNlO1xuICByZXN1bHQuX3VudGlsX3BhdHRlcm4gPSB0aGlzLl9pbnB1dC5nZXRfcmVnZXhwKHBhdHRlcm4pO1xuICByZXN1bHQuX3VwZGF0ZSgpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuUGF0dGVybi5wcm90b3R5cGUuc3RhcnRpbmdfd2l0aCA9IGZ1bmN0aW9uKHBhdHRlcm4pIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMuX2NyZWF0ZSgpO1xuICByZXN1bHQuX3N0YXJ0aW5nX3BhdHRlcm4gPSB0aGlzLl9pbnB1dC5nZXRfcmVnZXhwKHBhdHRlcm4sIHRydWUpO1xuICByZXN1bHQuX3VwZGF0ZSgpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuUGF0dGVybi5wcm90b3R5cGUubWF0Y2hpbmcgPSBmdW5jdGlvbihwYXR0ZXJuKSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLl9jcmVhdGUoKTtcbiAgcmVzdWx0Ll9tYXRjaF9wYXR0ZXJuID0gdGhpcy5faW5wdXQuZ2V0X3JlZ2V4cChwYXR0ZXJuLCB0cnVlKTtcbiAgcmVzdWx0Ll91cGRhdGUoKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblBhdHRlcm4ucHJvdG90eXBlLl9jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBQYXR0ZXJuKHRoaXMuX2lucHV0LCB0aGlzKTtcbn07XG5cblBhdHRlcm4ucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbigpIHt9O1xuXG5tb2R1bGUuZXhwb3J0cy5QYXR0ZXJuID0gUGF0dGVybjtcblxuXG4vKioqLyB9KSxcbi8qIDEzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLypqc2hpbnQgbm9kZTp0cnVlICovXG4vKlxuXG4gIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4gIENvcHlyaWdodCAoYykgMjAwNy0yMDE4IEVpbmFyIExpZWxtYW5pcywgTGlhbSBOZXdtYW4sIGFuZCBjb250cmlidXRvcnMuXG5cbiAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICBTT0ZUV0FSRS5cbiovXG5cblxuXG5mdW5jdGlvbiBEaXJlY3RpdmVzKHN0YXJ0X2Jsb2NrX3BhdHRlcm4sIGVuZF9ibG9ja19wYXR0ZXJuKSB7XG4gIHN0YXJ0X2Jsb2NrX3BhdHRlcm4gPSB0eXBlb2Ygc3RhcnRfYmxvY2tfcGF0dGVybiA9PT0gJ3N0cmluZycgPyBzdGFydF9ibG9ja19wYXR0ZXJuIDogc3RhcnRfYmxvY2tfcGF0dGVybi5zb3VyY2U7XG4gIGVuZF9ibG9ja19wYXR0ZXJuID0gdHlwZW9mIGVuZF9ibG9ja19wYXR0ZXJuID09PSAnc3RyaW5nJyA/IGVuZF9ibG9ja19wYXR0ZXJuIDogZW5kX2Jsb2NrX3BhdHRlcm4uc291cmNlO1xuICB0aGlzLl9fZGlyZWN0aXZlc19ibG9ja19wYXR0ZXJuID0gbmV3IFJlZ0V4cChzdGFydF9ibG9ja19wYXR0ZXJuICsgLyBiZWF1dGlmeSggXFx3K1s6XVxcdyspKyAvLnNvdXJjZSArIGVuZF9ibG9ja19wYXR0ZXJuLCAnZycpO1xuICB0aGlzLl9fZGlyZWN0aXZlX3BhdHRlcm4gPSAvIChcXHcrKVs6XShcXHcrKS9nO1xuXG4gIHRoaXMuX19kaXJlY3RpdmVzX2VuZF9pZ25vcmVfcGF0dGVybiA9IG5ldyBSZWdFeHAoc3RhcnRfYmxvY2tfcGF0dGVybiArIC9cXHNiZWF1dGlmeVxcc2lnbm9yZTplbmRcXHMvLnNvdXJjZSArIGVuZF9ibG9ja19wYXR0ZXJuLCAnZycpO1xufVxuXG5EaXJlY3RpdmVzLnByb3RvdHlwZS5nZXRfZGlyZWN0aXZlcyA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgaWYgKCF0ZXh0Lm1hdGNoKHRoaXMuX19kaXJlY3RpdmVzX2Jsb2NrX3BhdHRlcm4pKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgZGlyZWN0aXZlcyA9IHt9O1xuICB0aGlzLl9fZGlyZWN0aXZlX3BhdHRlcm4ubGFzdEluZGV4ID0gMDtcbiAgdmFyIGRpcmVjdGl2ZV9tYXRjaCA9IHRoaXMuX19kaXJlY3RpdmVfcGF0dGVybi5leGVjKHRleHQpO1xuXG4gIHdoaWxlIChkaXJlY3RpdmVfbWF0Y2gpIHtcbiAgICBkaXJlY3RpdmVzW2RpcmVjdGl2ZV9tYXRjaFsxXV0gPSBkaXJlY3RpdmVfbWF0Y2hbMl07XG4gICAgZGlyZWN0aXZlX21hdGNoID0gdGhpcy5fX2RpcmVjdGl2ZV9wYXR0ZXJuLmV4ZWModGV4dCk7XG4gIH1cblxuICByZXR1cm4gZGlyZWN0aXZlcztcbn07XG5cbkRpcmVjdGl2ZXMucHJvdG90eXBlLnJlYWRJZ25vcmVkID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgcmV0dXJuIGlucHV0LnJlYWRVbnRpbEFmdGVyKHRoaXMuX19kaXJlY3RpdmVzX2VuZF9pZ25vcmVfcGF0dGVybik7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzLkRpcmVjdGl2ZXMgPSBEaXJlY3RpdmVzO1xuXG5cbi8qKiovIH0pLFxuLyogMTQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKmpzaGludCBub2RlOnRydWUgKi9cbi8qXG5cbiAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiAgQ29weXJpZ2h0IChjKSAyMDA3LTIwMTggRWluYXIgTGllbG1hbmlzLCBMaWFtIE5ld21hbiwgYW5kIGNvbnRyaWJ1dG9ycy5cblxuICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gIFNPRlRXQVJFLlxuKi9cblxuXG5cbnZhciBQYXR0ZXJuID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMikuUGF0dGVybjtcblxuXG52YXIgdGVtcGxhdGVfbmFtZXMgPSB7XG4gIGRqYW5nbzogZmFsc2UsXG4gIGVyYjogZmFsc2UsXG4gIGhhbmRsZWJhcnM6IGZhbHNlLFxuICBwaHA6IGZhbHNlXG59O1xuXG4vLyBUaGlzIGxldHMgdGVtcGxhdGVzIGFwcGVhciBhbnl3aGVyZSB3ZSB3b3VsZCBkbyBhIHJlYWRVbnRpbFxuLy8gVGhlIGNvc3QgaXMgaGlnaGVyIGJ1dCBpdCBpcyBwYXkgdG8gcGxheS5cbmZ1bmN0aW9uIFRlbXBsYXRhYmxlUGF0dGVybihpbnB1dF9zY2FubmVyLCBwYXJlbnQpIHtcbiAgUGF0dGVybi5jYWxsKHRoaXMsIGlucHV0X3NjYW5uZXIsIHBhcmVudCk7XG4gIHRoaXMuX190ZW1wbGF0ZV9wYXR0ZXJuID0gbnVsbDtcbiAgdGhpcy5fZGlzYWJsZWQgPSBPYmplY3QuYXNzaWduKHt9LCB0ZW1wbGF0ZV9uYW1lcyk7XG4gIHRoaXMuX2V4Y2x1ZGVkID0gT2JqZWN0LmFzc2lnbih7fSwgdGVtcGxhdGVfbmFtZXMpO1xuXG4gIGlmIChwYXJlbnQpIHtcbiAgICB0aGlzLl9fdGVtcGxhdGVfcGF0dGVybiA9IHRoaXMuX2lucHV0LmdldF9yZWdleHAocGFyZW50Ll9fdGVtcGxhdGVfcGF0dGVybik7XG4gICAgdGhpcy5fZXhjbHVkZWQgPSBPYmplY3QuYXNzaWduKHRoaXMuX2V4Y2x1ZGVkLCBwYXJlbnQuX2V4Y2x1ZGVkKTtcbiAgICB0aGlzLl9kaXNhYmxlZCA9IE9iamVjdC5hc3NpZ24odGhpcy5fZGlzYWJsZWQsIHBhcmVudC5fZGlzYWJsZWQpO1xuICB9XG4gIHZhciBwYXR0ZXJuID0gbmV3IFBhdHRlcm4oaW5wdXRfc2Nhbm5lcik7XG4gIHRoaXMuX19wYXR0ZXJucyA9IHtcbiAgICBoYW5kbGViYXJzX2NvbW1lbnQ6IHBhdHRlcm4uc3RhcnRpbmdfd2l0aCgve3shLS0vKS51bnRpbF9hZnRlcigvLS19fS8pLFxuICAgIGhhbmRsZWJhcnNfdW5lc2NhcGVkOiBwYXR0ZXJuLnN0YXJ0aW5nX3dpdGgoL3t7ey8pLnVudGlsX2FmdGVyKC99fX0vKSxcbiAgICBoYW5kbGViYXJzOiBwYXR0ZXJuLnN0YXJ0aW5nX3dpdGgoL3t7LykudW50aWxfYWZ0ZXIoL319LyksXG4gICAgcGhwOiBwYXR0ZXJuLnN0YXJ0aW5nX3dpdGgoLzxcXD8oPzpbPV18cGhwKS8pLnVudGlsX2FmdGVyKC9cXD8+LyksXG4gICAgZXJiOiBwYXR0ZXJuLnN0YXJ0aW5nX3dpdGgoLzwlW14lXS8pLnVudGlsX2FmdGVyKC9bXiVdJT4vKSxcbiAgICAvLyBkamFuZ28gY29mbGljdHMgd2l0aCBoYW5kbGViYXJzIGEgYml0LlxuICAgIGRqYW5nbzogcGF0dGVybi5zdGFydGluZ193aXRoKC97JS8pLnVudGlsX2FmdGVyKC8lfS8pLFxuICAgIGRqYW5nb192YWx1ZTogcGF0dGVybi5zdGFydGluZ193aXRoKC97ey8pLnVudGlsX2FmdGVyKC99fS8pLFxuICAgIGRqYW5nb19jb21tZW50OiBwYXR0ZXJuLnN0YXJ0aW5nX3dpdGgoL3sjLykudW50aWxfYWZ0ZXIoLyN9LylcbiAgfTtcbn1cblRlbXBsYXRhYmxlUGF0dGVybi5wcm90b3R5cGUgPSBuZXcgUGF0dGVybigpO1xuXG5UZW1wbGF0YWJsZVBhdHRlcm4ucHJvdG90eXBlLl9jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUZW1wbGF0YWJsZVBhdHRlcm4odGhpcy5faW5wdXQsIHRoaXMpO1xufTtcblxuVGVtcGxhdGFibGVQYXR0ZXJuLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX19zZXRfdGVtcGxhdGVkX3BhdHRlcm4oKTtcbn07XG5cblRlbXBsYXRhYmxlUGF0dGVybi5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uKGxhbmd1YWdlKSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLl9jcmVhdGUoKTtcbiAgcmVzdWx0Ll9kaXNhYmxlZFtsYW5ndWFnZV0gPSB0cnVlO1xuICByZXN1bHQuX3VwZGF0ZSgpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuVGVtcGxhdGFibGVQYXR0ZXJuLnByb3RvdHlwZS5yZWFkX29wdGlvbnMgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLl9jcmVhdGUoKTtcbiAgZm9yICh2YXIgbGFuZ3VhZ2UgaW4gdGVtcGxhdGVfbmFtZXMpIHtcbiAgICByZXN1bHQuX2Rpc2FibGVkW2xhbmd1YWdlXSA9IG9wdGlvbnMudGVtcGxhdGluZy5pbmRleE9mKGxhbmd1YWdlKSA9PT0gLTE7XG4gIH1cbiAgcmVzdWx0Ll91cGRhdGUoKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblRlbXBsYXRhYmxlUGF0dGVybi5wcm90b3R5cGUuZXhjbHVkZSA9IGZ1bmN0aW9uKGxhbmd1YWdlKSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLl9jcmVhdGUoKTtcbiAgcmVzdWx0Ll9leGNsdWRlZFtsYW5ndWFnZV0gPSB0cnVlO1xuICByZXN1bHQuX3VwZGF0ZSgpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuVGVtcGxhdGFibGVQYXR0ZXJuLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24oKSB7XG4gIHZhciByZXN1bHQgPSAnJztcbiAgaWYgKHRoaXMuX21hdGNoX3BhdHRlcm4pIHtcbiAgICByZXN1bHQgPSB0aGlzLl9pbnB1dC5yZWFkKHRoaXMuX3N0YXJ0aW5nX3BhdHRlcm4pO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdCA9IHRoaXMuX2lucHV0LnJlYWQodGhpcy5fc3RhcnRpbmdfcGF0dGVybiwgdGhpcy5fX3RlbXBsYXRlX3BhdHRlcm4pO1xuICB9XG4gIHZhciBuZXh0ID0gdGhpcy5fcmVhZF90ZW1wbGF0ZSgpO1xuICB3aGlsZSAobmV4dCkge1xuICAgIGlmICh0aGlzLl9tYXRjaF9wYXR0ZXJuKSB7XG4gICAgICBuZXh0ICs9IHRoaXMuX2lucHV0LnJlYWQodGhpcy5fbWF0Y2hfcGF0dGVybik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHQgKz0gdGhpcy5faW5wdXQucmVhZFVudGlsKHRoaXMuX190ZW1wbGF0ZV9wYXR0ZXJuKTtcbiAgICB9XG4gICAgcmVzdWx0ICs9IG5leHQ7XG4gICAgbmV4dCA9IHRoaXMuX3JlYWRfdGVtcGxhdGUoKTtcbiAgfVxuXG4gIGlmICh0aGlzLl91bnRpbF9hZnRlcikge1xuICAgIHJlc3VsdCArPSB0aGlzLl9pbnB1dC5yZWFkVW50aWxBZnRlcih0aGlzLl91bnRpbF9wYXR0ZXJuKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuVGVtcGxhdGFibGVQYXR0ZXJuLnByb3RvdHlwZS5fX3NldF90ZW1wbGF0ZWRfcGF0dGVybiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaXRlbXMgPSBbXTtcblxuICBpZiAoIXRoaXMuX2Rpc2FibGVkLnBocCkge1xuICAgIGl0ZW1zLnB1c2godGhpcy5fX3BhdHRlcm5zLnBocC5fc3RhcnRpbmdfcGF0dGVybi5zb3VyY2UpO1xuICB9XG4gIGlmICghdGhpcy5fZGlzYWJsZWQuaGFuZGxlYmFycykge1xuICAgIGl0ZW1zLnB1c2godGhpcy5fX3BhdHRlcm5zLmhhbmRsZWJhcnMuX3N0YXJ0aW5nX3BhdHRlcm4uc291cmNlKTtcbiAgfVxuICBpZiAoIXRoaXMuX2Rpc2FibGVkLmVyYikge1xuICAgIGl0ZW1zLnB1c2godGhpcy5fX3BhdHRlcm5zLmVyYi5fc3RhcnRpbmdfcGF0dGVybi5zb3VyY2UpO1xuICB9XG4gIGlmICghdGhpcy5fZGlzYWJsZWQuZGphbmdvKSB7XG4gICAgaXRlbXMucHVzaCh0aGlzLl9fcGF0dGVybnMuZGphbmdvLl9zdGFydGluZ19wYXR0ZXJuLnNvdXJjZSk7XG4gICAgaXRlbXMucHVzaCh0aGlzLl9fcGF0dGVybnMuZGphbmdvX3ZhbHVlLl9zdGFydGluZ19wYXR0ZXJuLnNvdXJjZSk7XG4gICAgaXRlbXMucHVzaCh0aGlzLl9fcGF0dGVybnMuZGphbmdvX2NvbW1lbnQuX3N0YXJ0aW5nX3BhdHRlcm4uc291cmNlKTtcbiAgfVxuXG4gIGlmICh0aGlzLl91bnRpbF9wYXR0ZXJuKSB7XG4gICAgaXRlbXMucHVzaCh0aGlzLl91bnRpbF9wYXR0ZXJuLnNvdXJjZSk7XG4gIH1cbiAgdGhpcy5fX3RlbXBsYXRlX3BhdHRlcm4gPSB0aGlzLl9pbnB1dC5nZXRfcmVnZXhwKCcoPzonICsgaXRlbXMuam9pbignfCcpICsgJyknKTtcbn07XG5cblRlbXBsYXRhYmxlUGF0dGVybi5wcm90b3R5cGUuX3JlYWRfdGVtcGxhdGUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJlc3VsdGluZ19zdHJpbmcgPSAnJztcbiAgdmFyIGMgPSB0aGlzLl9pbnB1dC5wZWVrKCk7XG4gIGlmIChjID09PSAnPCcpIHtcbiAgICB2YXIgcGVlazEgPSB0aGlzLl9pbnB1dC5wZWVrKDEpO1xuICAgIC8vaWYgd2UncmUgaW4gYSBjb21tZW50LCBkbyBzb21ldGhpbmcgc3BlY2lhbFxuICAgIC8vIFdlIHRyZWF0IGFsbCBjb21tZW50cyBhcyBsaXRlcmFscywgZXZlbiBtb3JlIHRoYW4gcHJlZm9ybWF0dGVkIHRhZ3NcbiAgICAvLyB3ZSBqdXN0IGxvb2sgZm9yIHRoZSBhcHByb3ByaWF0ZSBjbG9zZSB0YWdcbiAgICBpZiAoIXRoaXMuX2Rpc2FibGVkLnBocCAmJiAhdGhpcy5fZXhjbHVkZWQucGhwICYmIHBlZWsxID09PSAnPycpIHtcbiAgICAgIHJlc3VsdGluZ19zdHJpbmcgPSByZXN1bHRpbmdfc3RyaW5nIHx8XG4gICAgICAgIHRoaXMuX19wYXR0ZXJucy5waHAucmVhZCgpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX2Rpc2FibGVkLmVyYiAmJiAhdGhpcy5fZXhjbHVkZWQuZXJiICYmIHBlZWsxID09PSAnJScpIHtcbiAgICAgIHJlc3VsdGluZ19zdHJpbmcgPSByZXN1bHRpbmdfc3RyaW5nIHx8XG4gICAgICAgIHRoaXMuX19wYXR0ZXJucy5lcmIucmVhZCgpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChjID09PSAneycpIHtcbiAgICBpZiAoIXRoaXMuX2Rpc2FibGVkLmhhbmRsZWJhcnMgJiYgIXRoaXMuX2V4Y2x1ZGVkLmhhbmRsZWJhcnMpIHtcbiAgICAgIHJlc3VsdGluZ19zdHJpbmcgPSByZXN1bHRpbmdfc3RyaW5nIHx8XG4gICAgICAgIHRoaXMuX19wYXR0ZXJucy5oYW5kbGViYXJzX2NvbW1lbnQucmVhZCgpO1xuICAgICAgcmVzdWx0aW5nX3N0cmluZyA9IHJlc3VsdGluZ19zdHJpbmcgfHxcbiAgICAgICAgdGhpcy5fX3BhdHRlcm5zLmhhbmRsZWJhcnNfdW5lc2NhcGVkLnJlYWQoKTtcbiAgICAgIHJlc3VsdGluZ19zdHJpbmcgPSByZXN1bHRpbmdfc3RyaW5nIHx8XG4gICAgICAgIHRoaXMuX19wYXR0ZXJucy5oYW5kbGViYXJzLnJlYWQoKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl9kaXNhYmxlZC5kamFuZ28pIHtcbiAgICAgIC8vIGRqYW5nbyBjb2ZsaWN0cyB3aXRoIGhhbmRsZWJhcnMgYSBiaXQuXG4gICAgICBpZiAoIXRoaXMuX2V4Y2x1ZGVkLmRqYW5nbyAmJiAhdGhpcy5fZXhjbHVkZWQuaGFuZGxlYmFycykge1xuICAgICAgICByZXN1bHRpbmdfc3RyaW5nID0gcmVzdWx0aW5nX3N0cmluZyB8fFxuICAgICAgICAgIHRoaXMuX19wYXR0ZXJucy5kamFuZ29fdmFsdWUucmVhZCgpO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLl9leGNsdWRlZC5kamFuZ28pIHtcbiAgICAgICAgcmVzdWx0aW5nX3N0cmluZyA9IHJlc3VsdGluZ19zdHJpbmcgfHxcbiAgICAgICAgICB0aGlzLl9fcGF0dGVybnMuZGphbmdvX2NvbW1lbnQucmVhZCgpO1xuICAgICAgICByZXN1bHRpbmdfc3RyaW5nID0gcmVzdWx0aW5nX3N0cmluZyB8fFxuICAgICAgICAgIHRoaXMuX19wYXR0ZXJucy5kamFuZ28ucmVhZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0aW5nX3N0cmluZztcbn07XG5cblxubW9kdWxlLmV4cG9ydHMuVGVtcGxhdGFibGVQYXR0ZXJuID0gVGVtcGxhdGFibGVQYXR0ZXJuO1xuXG5cbi8qKiovIH0pLFxuLyogMTUgKi8sXG4vKiAxNiAqLyxcbi8qIDE3ICovLFxuLyogMTggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKmpzaGludCBub2RlOnRydWUgKi9cbi8qXG5cbiAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiAgQ29weXJpZ2h0IChjKSAyMDA3LTIwMTggRWluYXIgTGllbG1hbmlzLCBMaWFtIE5ld21hbiwgYW5kIGNvbnRyaWJ1dG9ycy5cblxuICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gIFNPRlRXQVJFLlxuKi9cblxuXG5cbnZhciBCZWF1dGlmaWVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOSkuQmVhdXRpZmllcixcbiAgT3B0aW9ucyA9IF9fd2VicGFja19yZXF1aXJlX18oMjApLk9wdGlvbnM7XG5cbmZ1bmN0aW9uIHN0eWxlX2h0bWwoaHRtbF9zb3VyY2UsIG9wdGlvbnMsIGpzX2JlYXV0aWZ5LCBjc3NfYmVhdXRpZnkpIHtcbiAgdmFyIGJlYXV0aWZpZXIgPSBuZXcgQmVhdXRpZmllcihodG1sX3NvdXJjZSwgb3B0aW9ucywganNfYmVhdXRpZnksIGNzc19iZWF1dGlmeSk7XG4gIHJldHVybiBiZWF1dGlmaWVyLmJlYXV0aWZ5KCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3R5bGVfaHRtbDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHRPcHRpb25zID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgT3B0aW9ucygpO1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDE5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLypqc2hpbnQgbm9kZTp0cnVlICovXG4vKlxuXG4gIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4gIENvcHlyaWdodCAoYykgMjAwNy0yMDE4IEVpbmFyIExpZWxtYW5pcywgTGlhbSBOZXdtYW4sIGFuZCBjb250cmlidXRvcnMuXG5cbiAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICBTT0ZUV0FSRS5cbiovXG5cblxuXG52YXIgT3B0aW9ucyA9IF9fd2VicGFja19yZXF1aXJlX18oMjApLk9wdGlvbnM7XG52YXIgT3V0cHV0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKS5PdXRwdXQ7XG52YXIgVG9rZW5pemVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMSkuVG9rZW5pemVyO1xudmFyIFRPS0VOID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMSkuVE9LRU47XG5cbnZhciBsaW5lQnJlYWsgPSAvXFxyXFxufFtcXHJcXG5dLztcbnZhciBhbGxMaW5lQnJlYWtzID0gL1xcclxcbnxbXFxyXFxuXS9nO1xuXG52YXIgUHJpbnRlciA9IGZ1bmN0aW9uKG9wdGlvbnMsIGJhc2VfaW5kZW50X3N0cmluZykgeyAvL2hhbmRsZXMgaW5wdXQvb3V0cHV0IGFuZCBzb21lIG90aGVyIHByaW50aW5nIGZ1bmN0aW9uc1xuXG4gIHRoaXMuaW5kZW50X2xldmVsID0gMDtcbiAgdGhpcy5hbGlnbm1lbnRfc2l6ZSA9IDA7XG4gIHRoaXMubWF4X3ByZXNlcnZlX25ld2xpbmVzID0gb3B0aW9ucy5tYXhfcHJlc2VydmVfbmV3bGluZXM7XG4gIHRoaXMucHJlc2VydmVfbmV3bGluZXMgPSBvcHRpb25zLnByZXNlcnZlX25ld2xpbmVzO1xuXG4gIHRoaXMuX291dHB1dCA9IG5ldyBPdXRwdXQob3B0aW9ucywgYmFzZV9pbmRlbnRfc3RyaW5nKTtcblxufTtcblxuUHJpbnRlci5wcm90b3R5cGUuY3VycmVudF9saW5lX2hhc19tYXRjaCA9IGZ1bmN0aW9uKHBhdHRlcm4pIHtcbiAgcmV0dXJuIHRoaXMuX291dHB1dC5jdXJyZW50X2xpbmUuaGFzX21hdGNoKHBhdHRlcm4pO1xufTtcblxuUHJpbnRlci5wcm90b3R5cGUuc2V0X3NwYWNlX2JlZm9yZV90b2tlbiA9IGZ1bmN0aW9uKHZhbHVlLCBub25fYnJlYWtpbmcpIHtcbiAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHZhbHVlO1xuICB0aGlzLl9vdXRwdXQubm9uX2JyZWFraW5nX3NwYWNlID0gbm9uX2JyZWFraW5nO1xufTtcblxuUHJpbnRlci5wcm90b3R5cGUuc2V0X3dyYXBfcG9pbnQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fb3V0cHV0LnNldF9pbmRlbnQodGhpcy5pbmRlbnRfbGV2ZWwsIHRoaXMuYWxpZ25tZW50X3NpemUpO1xuICB0aGlzLl9vdXRwdXQuc2V0X3dyYXBfcG9pbnQoKTtcbn07XG5cblxuUHJpbnRlci5wcm90b3R5cGUuYWRkX3Jhd190b2tlbiA9IGZ1bmN0aW9uKHRva2VuKSB7XG4gIHRoaXMuX291dHB1dC5hZGRfcmF3X3Rva2VuKHRva2VuKTtcbn07XG5cblByaW50ZXIucHJvdG90eXBlLnByaW50X3ByZXNlcnZlZF9uZXdsaW5lcyA9IGZ1bmN0aW9uKHJhd190b2tlbikge1xuICB2YXIgbmV3bGluZXMgPSAwO1xuICBpZiAocmF3X3Rva2VuLnR5cGUgIT09IFRPS0VOLlRFWFQgJiYgcmF3X3Rva2VuLnByZXZpb3VzLnR5cGUgIT09IFRPS0VOLlRFWFQpIHtcbiAgICBuZXdsaW5lcyA9IHJhd190b2tlbi5uZXdsaW5lcyA/IDEgOiAwO1xuICB9XG5cbiAgaWYgKHRoaXMucHJlc2VydmVfbmV3bGluZXMpIHtcbiAgICBuZXdsaW5lcyA9IHJhd190b2tlbi5uZXdsaW5lcyA8IHRoaXMubWF4X3ByZXNlcnZlX25ld2xpbmVzICsgMSA/IHJhd190b2tlbi5uZXdsaW5lcyA6IHRoaXMubWF4X3ByZXNlcnZlX25ld2xpbmVzICsgMTtcbiAgfVxuICBmb3IgKHZhciBuID0gMDsgbiA8IG5ld2xpbmVzOyBuKyspIHtcbiAgICB0aGlzLnByaW50X25ld2xpbmUobiA+IDApO1xuICB9XG5cbiAgcmV0dXJuIG5ld2xpbmVzICE9PSAwO1xufTtcblxuUHJpbnRlci5wcm90b3R5cGUudHJhdmVyc2Vfd2hpdGVzcGFjZSA9IGZ1bmN0aW9uKHJhd190b2tlbikge1xuICBpZiAocmF3X3Rva2VuLndoaXRlc3BhY2VfYmVmb3JlIHx8IHJhd190b2tlbi5uZXdsaW5lcykge1xuICAgIGlmICghdGhpcy5wcmludF9wcmVzZXJ2ZWRfbmV3bGluZXMocmF3X3Rva2VuKSkge1xuICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cblByaW50ZXIucHJvdG90eXBlLnByZXZpb3VzX3Rva2VuX3dyYXBwZWQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX291dHB1dC5wcmV2aW91c190b2tlbl93cmFwcGVkO1xufTtcblxuUHJpbnRlci5wcm90b3R5cGUucHJpbnRfbmV3bGluZSA9IGZ1bmN0aW9uKGZvcmNlKSB7XG4gIHRoaXMuX291dHB1dC5hZGRfbmV3X2xpbmUoZm9yY2UpO1xufTtcblxuUHJpbnRlci5wcm90b3R5cGUucHJpbnRfdG9rZW4gPSBmdW5jdGlvbih0b2tlbikge1xuICBpZiAodG9rZW4udGV4dCkge1xuICAgIHRoaXMuX291dHB1dC5zZXRfaW5kZW50KHRoaXMuaW5kZW50X2xldmVsLCB0aGlzLmFsaWdubWVudF9zaXplKTtcbiAgICB0aGlzLl9vdXRwdXQuYWRkX3Rva2VuKHRva2VuLnRleHQpO1xuICB9XG59O1xuXG5QcmludGVyLnByb3RvdHlwZS5pbmRlbnQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5pbmRlbnRfbGV2ZWwrKztcbn07XG5cblByaW50ZXIucHJvdG90eXBlLmdldF9mdWxsX2luZGVudCA9IGZ1bmN0aW9uKGxldmVsKSB7XG4gIGxldmVsID0gdGhpcy5pbmRlbnRfbGV2ZWwgKyAobGV2ZWwgfHwgMCk7XG4gIGlmIChsZXZlbCA8IDEpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICByZXR1cm4gdGhpcy5fb3V0cHV0LmdldF9pbmRlbnRfc3RyaW5nKGxldmVsKTtcbn07XG5cbnZhciBnZXRfdHlwZV9hdHRyaWJ1dGUgPSBmdW5jdGlvbihzdGFydF90b2tlbikge1xuICB2YXIgcmVzdWx0ID0gbnVsbDtcbiAgdmFyIHJhd190b2tlbiA9IHN0YXJ0X3Rva2VuLm5leHQ7XG5cbiAgLy8gU2VhcmNoIGF0dHJpYnV0ZXMgZm9yIGEgdHlwZSBhdHRyaWJ1dGVcbiAgd2hpbGUgKHJhd190b2tlbi50eXBlICE9PSBUT0tFTi5FT0YgJiYgc3RhcnRfdG9rZW4uY2xvc2VkICE9PSByYXdfdG9rZW4pIHtcbiAgICBpZiAocmF3X3Rva2VuLnR5cGUgPT09IFRPS0VOLkFUVFJJQlVURSAmJiByYXdfdG9rZW4udGV4dCA9PT0gJ3R5cGUnKSB7XG4gICAgICBpZiAocmF3X3Rva2VuLm5leHQgJiYgcmF3X3Rva2VuLm5leHQudHlwZSA9PT0gVE9LRU4uRVFVQUxTICYmXG4gICAgICAgIHJhd190b2tlbi5uZXh0Lm5leHQgJiYgcmF3X3Rva2VuLm5leHQubmV4dC50eXBlID09PSBUT0tFTi5WQUxVRSkge1xuICAgICAgICByZXN1bHQgPSByYXdfdG9rZW4ubmV4dC5uZXh0LnRleHQ7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgcmF3X3Rva2VuID0gcmF3X3Rva2VuLm5leHQ7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxudmFyIGdldF9jdXN0b21fYmVhdXRpZmllcl9uYW1lID0gZnVuY3Rpb24odGFnX2NoZWNrLCByYXdfdG9rZW4pIHtcbiAgdmFyIHR5cGVBdHRyaWJ1dGUgPSBudWxsO1xuICB2YXIgcmVzdWx0ID0gbnVsbDtcblxuICBpZiAoIXJhd190b2tlbi5jbG9zZWQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmICh0YWdfY2hlY2sgPT09ICdzY3JpcHQnKSB7XG4gICAgdHlwZUF0dHJpYnV0ZSA9ICd0ZXh0L2phdmFzY3JpcHQnO1xuICB9IGVsc2UgaWYgKHRhZ19jaGVjayA9PT0gJ3N0eWxlJykge1xuICAgIHR5cGVBdHRyaWJ1dGUgPSAndGV4dC9jc3MnO1xuICB9XG5cbiAgdHlwZUF0dHJpYnV0ZSA9IGdldF90eXBlX2F0dHJpYnV0ZShyYXdfdG9rZW4pIHx8IHR5cGVBdHRyaWJ1dGU7XG5cbiAgLy8gRm9yIHNjcmlwdCBhbmQgc3R5bGUgdGFncyB0aGF0IGhhdmUgYSB0eXBlIGF0dHJpYnV0ZSwgb25seSBlbmFibGUgY3VzdG9tIGJlYXV0aWZpZXJzIGZvciBtYXRjaGluZyB2YWx1ZXNcbiAgLy8gRm9yIHRob3NlIHdpdGhvdXQgYSB0eXBlIGF0dHJpYnV0ZSB1c2UgZGVmYXVsdDtcbiAgaWYgKHR5cGVBdHRyaWJ1dGUuc2VhcmNoKCd0ZXh0L2NzcycpID4gLTEpIHtcbiAgICByZXN1bHQgPSAnY3NzJztcbiAgfSBlbHNlIGlmICh0eXBlQXR0cmlidXRlLnNlYXJjaCgvbW9kdWxlfCgodGV4dHxhcHBsaWNhdGlvbnxkb2pvKVxcLyh4LSk/KGphdmFzY3JpcHR8ZWNtYXNjcmlwdHxqc2NyaXB0fGxpdmVzY3JpcHR8KGxkXFwrKT9qc29ufG1ldGhvZHxhc3BlY3QpKS8pID4gLTEpIHtcbiAgICByZXN1bHQgPSAnamF2YXNjcmlwdCc7XG4gIH0gZWxzZSBpZiAodHlwZUF0dHJpYnV0ZS5zZWFyY2goLyh0ZXh0fGFwcGxpY2F0aW9ufGRvam8pXFwvKHgtKT8oaHRtbCkvKSA+IC0xKSB7XG4gICAgcmVzdWx0ID0gJ2h0bWwnO1xuICB9IGVsc2UgaWYgKHR5cGVBdHRyaWJ1dGUuc2VhcmNoKC90ZXN0XFwvbnVsbC8pID4gLTEpIHtcbiAgICAvLyBUZXN0IG9ubHkgbWltZS10eXBlIGZvciB0ZXN0aW5nIHRoZSBiZWF1dGlmaWVyIHdoZW4gbnVsbCBpcyBwYXNzZWQgYXMgYmVhdXRpZmluZyBmdW5jdGlvblxuICAgIHJlc3VsdCA9ICdudWxsJztcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5mdW5jdGlvbiBpbl9hcnJheSh3aGF0LCBhcnIpIHtcbiAgcmV0dXJuIGFyci5pbmRleE9mKHdoYXQpICE9PSAtMTtcbn1cblxuZnVuY3Rpb24gVGFnRnJhbWUocGFyZW50LCBwYXJzZXJfdG9rZW4sIGluZGVudF9sZXZlbCkge1xuICB0aGlzLnBhcmVudCA9IHBhcmVudCB8fCBudWxsO1xuICB0aGlzLnRhZyA9IHBhcnNlcl90b2tlbiA/IHBhcnNlcl90b2tlbi50YWdfbmFtZSA6ICcnO1xuICB0aGlzLmluZGVudF9sZXZlbCA9IGluZGVudF9sZXZlbCB8fCAwO1xuICB0aGlzLnBhcnNlcl90b2tlbiA9IHBhcnNlcl90b2tlbiB8fCBudWxsO1xufVxuXG5mdW5jdGlvbiBUYWdTdGFjayhwcmludGVyKSB7XG4gIHRoaXMuX3ByaW50ZXIgPSBwcmludGVyO1xuICB0aGlzLl9jdXJyZW50X2ZyYW1lID0gbnVsbDtcbn1cblxuVGFnU3RhY2sucHJvdG90eXBlLmdldF9wYXJzZXJfdG9rZW4gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2N1cnJlbnRfZnJhbWUgPyB0aGlzLl9jdXJyZW50X2ZyYW1lLnBhcnNlcl90b2tlbiA6IG51bGw7XG59O1xuXG5UYWdTdGFjay5wcm90b3R5cGUucmVjb3JkX3RhZyA9IGZ1bmN0aW9uKHBhcnNlcl90b2tlbikgeyAvL2Z1bmN0aW9uIHRvIHJlY29yZCBhIHRhZyBhbmQgaXRzIHBhcmVudCBpbiB0aGlzLnRhZ3MgT2JqZWN0XG4gIHZhciBuZXdfZnJhbWUgPSBuZXcgVGFnRnJhbWUodGhpcy5fY3VycmVudF9mcmFtZSwgcGFyc2VyX3Rva2VuLCB0aGlzLl9wcmludGVyLmluZGVudF9sZXZlbCk7XG4gIHRoaXMuX2N1cnJlbnRfZnJhbWUgPSBuZXdfZnJhbWU7XG59O1xuXG5UYWdTdGFjay5wcm90b3R5cGUuX3RyeV9wb3BfZnJhbWUgPSBmdW5jdGlvbihmcmFtZSkgeyAvL2Z1bmN0aW9uIHRvIHJldHJpZXZlIHRoZSBvcGVuaW5nIHRhZyB0byB0aGUgY29ycmVzcG9uZGluZyBjbG9zZXJcbiAgdmFyIHBhcnNlcl90b2tlbiA9IG51bGw7XG5cbiAgaWYgKGZyYW1lKSB7XG4gICAgcGFyc2VyX3Rva2VuID0gZnJhbWUucGFyc2VyX3Rva2VuO1xuICAgIHRoaXMuX3ByaW50ZXIuaW5kZW50X2xldmVsID0gZnJhbWUuaW5kZW50X2xldmVsO1xuICAgIHRoaXMuX2N1cnJlbnRfZnJhbWUgPSBmcmFtZS5wYXJlbnQ7XG4gIH1cblxuICByZXR1cm4gcGFyc2VyX3Rva2VuO1xufTtcblxuVGFnU3RhY2sucHJvdG90eXBlLl9nZXRfZnJhbWUgPSBmdW5jdGlvbih0YWdfbGlzdCwgc3RvcF9saXN0KSB7IC8vZnVuY3Rpb24gdG8gcmV0cmlldmUgdGhlIG9wZW5pbmcgdGFnIHRvIHRoZSBjb3JyZXNwb25kaW5nIGNsb3NlclxuICB2YXIgZnJhbWUgPSB0aGlzLl9jdXJyZW50X2ZyYW1lO1xuXG4gIHdoaWxlIChmcmFtZSkgeyAvL3RpbGwgd2UgcmVhY2ggJycgKHRoZSBpbml0aWFsIHZhbHVlKTtcbiAgICBpZiAodGFnX2xpc3QuaW5kZXhPZihmcmFtZS50YWcpICE9PSAtMSkgeyAvL2lmIHRoaXMgaXMgaXQgdXNlIGl0XG4gICAgICBicmVhaztcbiAgICB9IGVsc2UgaWYgKHN0b3BfbGlzdCAmJiBzdG9wX2xpc3QuaW5kZXhPZihmcmFtZS50YWcpICE9PSAtMSkge1xuICAgICAgZnJhbWUgPSBudWxsO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGZyYW1lID0gZnJhbWUucGFyZW50O1xuICB9XG5cbiAgcmV0dXJuIGZyYW1lO1xufTtcblxuVGFnU3RhY2sucHJvdG90eXBlLnRyeV9wb3AgPSBmdW5jdGlvbih0YWcsIHN0b3BfbGlzdCkgeyAvL2Z1bmN0aW9uIHRvIHJldHJpZXZlIHRoZSBvcGVuaW5nIHRhZyB0byB0aGUgY29ycmVzcG9uZGluZyBjbG9zZXJcbiAgdmFyIGZyYW1lID0gdGhpcy5fZ2V0X2ZyYW1lKFt0YWddLCBzdG9wX2xpc3QpO1xuICByZXR1cm4gdGhpcy5fdHJ5X3BvcF9mcmFtZShmcmFtZSk7XG59O1xuXG5UYWdTdGFjay5wcm90b3R5cGUuaW5kZW50X3RvX3RhZyA9IGZ1bmN0aW9uKHRhZ19saXN0KSB7XG4gIHZhciBmcmFtZSA9IHRoaXMuX2dldF9mcmFtZSh0YWdfbGlzdCk7XG4gIGlmIChmcmFtZSkge1xuICAgIHRoaXMuX3ByaW50ZXIuaW5kZW50X2xldmVsID0gZnJhbWUuaW5kZW50X2xldmVsO1xuICB9XG59O1xuXG5mdW5jdGlvbiBCZWF1dGlmaWVyKHNvdXJjZV90ZXh0LCBvcHRpb25zLCBqc19iZWF1dGlmeSwgY3NzX2JlYXV0aWZ5KSB7XG4gIC8vV3JhcHBlciBmdW5jdGlvbiB0byBpbnZva2UgYWxsIHRoZSBuZWNlc3NhcnkgY29uc3RydWN0b3JzIGFuZCBkZWFsIHdpdGggdGhlIG91dHB1dC5cbiAgdGhpcy5fc291cmNlX3RleHQgPSBzb3VyY2VfdGV4dCB8fCAnJztcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHRoaXMuX2pzX2JlYXV0aWZ5ID0ganNfYmVhdXRpZnk7XG4gIHRoaXMuX2Nzc19iZWF1dGlmeSA9IGNzc19iZWF1dGlmeTtcbiAgdGhpcy5fdGFnX3N0YWNrID0gbnVsbDtcblxuICAvLyBBbGxvdyB0aGUgc2V0dGluZyBvZiBsYW5ndWFnZS9maWxlLXR5cGUgc3BlY2lmaWMgb3B0aW9uc1xuICAvLyB3aXRoIGluaGVyaXRhbmNlIG9mIG92ZXJhbGwgc2V0dGluZ3NcbiAgdmFyIG9wdGlvbkh0bWwgPSBuZXcgT3B0aW9ucyhvcHRpb25zLCAnaHRtbCcpO1xuXG4gIHRoaXMuX29wdGlvbnMgPSBvcHRpb25IdG1sO1xuXG4gIHRoaXMuX2lzX3dyYXBfYXR0cmlidXRlc19mb3JjZSA9IHRoaXMuX29wdGlvbnMud3JhcF9hdHRyaWJ1dGVzLnN1YnN0cigwLCAnZm9yY2UnLmxlbmd0aCkgPT09ICdmb3JjZSc7XG4gIHRoaXMuX2lzX3dyYXBfYXR0cmlidXRlc19mb3JjZV9leHBhbmRfbXVsdGlsaW5lID0gKHRoaXMuX29wdGlvbnMud3JhcF9hdHRyaWJ1dGVzID09PSAnZm9yY2UtZXhwYW5kLW11bHRpbGluZScpO1xuICB0aGlzLl9pc193cmFwX2F0dHJpYnV0ZXNfZm9yY2VfYWxpZ25lZCA9ICh0aGlzLl9vcHRpb25zLndyYXBfYXR0cmlidXRlcyA9PT0gJ2ZvcmNlLWFsaWduZWQnKTtcbiAgdGhpcy5faXNfd3JhcF9hdHRyaWJ1dGVzX2FsaWduZWRfbXVsdGlwbGUgPSAodGhpcy5fb3B0aW9ucy53cmFwX2F0dHJpYnV0ZXMgPT09ICdhbGlnbmVkLW11bHRpcGxlJyk7XG4gIHRoaXMuX2lzX3dyYXBfYXR0cmlidXRlc19wcmVzZXJ2ZSA9IHRoaXMuX29wdGlvbnMud3JhcF9hdHRyaWJ1dGVzLnN1YnN0cigwLCAncHJlc2VydmUnLmxlbmd0aCkgPT09ICdwcmVzZXJ2ZSc7XG4gIHRoaXMuX2lzX3dyYXBfYXR0cmlidXRlc19wcmVzZXJ2ZV9hbGlnbmVkID0gKHRoaXMuX29wdGlvbnMud3JhcF9hdHRyaWJ1dGVzID09PSAncHJlc2VydmUtYWxpZ25lZCcpO1xufVxuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5iZWF1dGlmeSA9IGZ1bmN0aW9uKCkge1xuXG4gIC8vIGlmIGRpc2FibGVkLCByZXR1cm4gdGhlIGlucHV0IHVuY2hhbmdlZC5cbiAgaWYgKHRoaXMuX29wdGlvbnMuZGlzYWJsZWQpIHtcbiAgICByZXR1cm4gdGhpcy5fc291cmNlX3RleHQ7XG4gIH1cblxuICB2YXIgc291cmNlX3RleHQgPSB0aGlzLl9zb3VyY2VfdGV4dDtcbiAgdmFyIGVvbCA9IHRoaXMuX29wdGlvbnMuZW9sO1xuICBpZiAodGhpcy5fb3B0aW9ucy5lb2wgPT09ICdhdXRvJykge1xuICAgIGVvbCA9ICdcXG4nO1xuICAgIGlmIChzb3VyY2VfdGV4dCAmJiBsaW5lQnJlYWsudGVzdChzb3VyY2VfdGV4dCkpIHtcbiAgICAgIGVvbCA9IHNvdXJjZV90ZXh0Lm1hdGNoKGxpbmVCcmVhaylbMF07XG4gICAgfVxuICB9XG5cbiAgLy8gSEFDSzogbmV3bGluZSBwYXJzaW5nIGluY29uc2lzdGVudC4gVGhpcyBicnV0ZSBmb3JjZSBub3JtYWxpemVzIHRoZSBpbnB1dC5cbiAgc291cmNlX3RleHQgPSBzb3VyY2VfdGV4dC5yZXBsYWNlKGFsbExpbmVCcmVha3MsICdcXG4nKTtcblxuICB2YXIgYmFzZUluZGVudFN0cmluZyA9IHNvdXJjZV90ZXh0Lm1hdGNoKC9eW1xcdCBdKi8pWzBdO1xuXG4gIHZhciBsYXN0X3Rva2VuID0ge1xuICAgIHRleHQ6ICcnLFxuICAgIHR5cGU6ICcnXG4gIH07XG5cbiAgdmFyIGxhc3RfdGFnX3Rva2VuID0gbmV3IFRhZ09wZW5QYXJzZXJUb2tlbigpO1xuXG4gIHZhciBwcmludGVyID0gbmV3IFByaW50ZXIodGhpcy5fb3B0aW9ucywgYmFzZUluZGVudFN0cmluZyk7XG4gIHZhciB0b2tlbnMgPSBuZXcgVG9rZW5pemVyKHNvdXJjZV90ZXh0LCB0aGlzLl9vcHRpb25zKS50b2tlbml6ZSgpO1xuXG4gIHRoaXMuX3RhZ19zdGFjayA9IG5ldyBUYWdTdGFjayhwcmludGVyKTtcblxuICB2YXIgcGFyc2VyX3Rva2VuID0gbnVsbDtcbiAgdmFyIHJhd190b2tlbiA9IHRva2Vucy5uZXh0KCk7XG4gIHdoaWxlIChyYXdfdG9rZW4udHlwZSAhPT0gVE9LRU4uRU9GKSB7XG5cbiAgICBpZiAocmF3X3Rva2VuLnR5cGUgPT09IFRPS0VOLlRBR19PUEVOIHx8IHJhd190b2tlbi50eXBlID09PSBUT0tFTi5DT01NRU5UKSB7XG4gICAgICBwYXJzZXJfdG9rZW4gPSB0aGlzLl9oYW5kbGVfdGFnX29wZW4ocHJpbnRlciwgcmF3X3Rva2VuLCBsYXN0X3RhZ190b2tlbiwgbGFzdF90b2tlbik7XG4gICAgICBsYXN0X3RhZ190b2tlbiA9IHBhcnNlcl90b2tlbjtcbiAgICB9IGVsc2UgaWYgKChyYXdfdG9rZW4udHlwZSA9PT0gVE9LRU4uQVRUUklCVVRFIHx8IHJhd190b2tlbi50eXBlID09PSBUT0tFTi5FUVVBTFMgfHwgcmF3X3Rva2VuLnR5cGUgPT09IFRPS0VOLlZBTFVFKSB8fFxuICAgICAgKHJhd190b2tlbi50eXBlID09PSBUT0tFTi5URVhUICYmICFsYXN0X3RhZ190b2tlbi50YWdfY29tcGxldGUpKSB7XG4gICAgICBwYXJzZXJfdG9rZW4gPSB0aGlzLl9oYW5kbGVfaW5zaWRlX3RhZyhwcmludGVyLCByYXdfdG9rZW4sIGxhc3RfdGFnX3Rva2VuLCB0b2tlbnMpO1xuICAgIH0gZWxzZSBpZiAocmF3X3Rva2VuLnR5cGUgPT09IFRPS0VOLlRBR19DTE9TRSkge1xuICAgICAgcGFyc2VyX3Rva2VuID0gdGhpcy5faGFuZGxlX3RhZ19jbG9zZShwcmludGVyLCByYXdfdG9rZW4sIGxhc3RfdGFnX3Rva2VuKTtcbiAgICB9IGVsc2UgaWYgKHJhd190b2tlbi50eXBlID09PSBUT0tFTi5URVhUKSB7XG4gICAgICBwYXJzZXJfdG9rZW4gPSB0aGlzLl9oYW5kbGVfdGV4dChwcmludGVyLCByYXdfdG9rZW4sIGxhc3RfdGFnX3Rva2VuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuLCBidXQgaWYgaXQgZG9lcy4gUHJpbnQgdGhlIHJhdyB0b2tlblxuICAgICAgcHJpbnRlci5hZGRfcmF3X3Rva2VuKHJhd190b2tlbik7XG4gICAgfVxuXG4gICAgbGFzdF90b2tlbiA9IHBhcnNlcl90b2tlbjtcblxuICAgIHJhd190b2tlbiA9IHRva2Vucy5uZXh0KCk7XG4gIH1cbiAgdmFyIHN3ZWV0X2NvZGUgPSBwcmludGVyLl9vdXRwdXQuZ2V0X2NvZGUoZW9sKTtcblxuICByZXR1cm4gc3dlZXRfY29kZTtcbn07XG5cbkJlYXV0aWZpZXIucHJvdG90eXBlLl9oYW5kbGVfdGFnX2Nsb3NlID0gZnVuY3Rpb24ocHJpbnRlciwgcmF3X3Rva2VuLCBsYXN0X3RhZ190b2tlbikge1xuICB2YXIgcGFyc2VyX3Rva2VuID0ge1xuICAgIHRleHQ6IHJhd190b2tlbi50ZXh0LFxuICAgIHR5cGU6IHJhd190b2tlbi50eXBlXG4gIH07XG4gIHByaW50ZXIuYWxpZ25tZW50X3NpemUgPSAwO1xuICBsYXN0X3RhZ190b2tlbi50YWdfY29tcGxldGUgPSB0cnVlO1xuXG4gIHByaW50ZXIuc2V0X3NwYWNlX2JlZm9yZV90b2tlbihyYXdfdG9rZW4ubmV3bGluZXMgfHwgcmF3X3Rva2VuLndoaXRlc3BhY2VfYmVmb3JlICE9PSAnJywgdHJ1ZSk7XG4gIGlmIChsYXN0X3RhZ190b2tlbi5pc191bmZvcm1hdHRlZCkge1xuICAgIHByaW50ZXIuYWRkX3Jhd190b2tlbihyYXdfdG9rZW4pO1xuICB9IGVsc2Uge1xuICAgIGlmIChsYXN0X3RhZ190b2tlbi50YWdfc3RhcnRfY2hhciA9PT0gJzwnKSB7XG4gICAgICBwcmludGVyLnNldF9zcGFjZV9iZWZvcmVfdG9rZW4ocmF3X3Rva2VuLnRleHRbMF0gPT09ICcvJywgdHJ1ZSk7IC8vIHNwYWNlIGJlZm9yZSAvPiwgbm8gc3BhY2UgYmVmb3JlID5cbiAgICAgIGlmICh0aGlzLl9pc193cmFwX2F0dHJpYnV0ZXNfZm9yY2VfZXhwYW5kX211bHRpbGluZSAmJiBsYXN0X3RhZ190b2tlbi5oYXNfd3JhcHBlZF9hdHRycykge1xuICAgICAgICBwcmludGVyLnByaW50X25ld2xpbmUoZmFsc2UpO1xuICAgICAgfVxuICAgIH1cbiAgICBwcmludGVyLnByaW50X3Rva2VuKHJhd190b2tlbik7XG5cbiAgfVxuXG4gIGlmIChsYXN0X3RhZ190b2tlbi5pbmRlbnRfY29udGVudCAmJlxuICAgICEobGFzdF90YWdfdG9rZW4uaXNfdW5mb3JtYXR0ZWQgfHwgbGFzdF90YWdfdG9rZW4uaXNfY29udGVudF91bmZvcm1hdHRlZCkpIHtcbiAgICBwcmludGVyLmluZGVudCgpO1xuXG4gICAgLy8gb25seSBpbmRlbnQgb25jZSBwZXIgb3BlbmVkIHRhZ1xuICAgIGxhc3RfdGFnX3Rva2VuLmluZGVudF9jb250ZW50ID0gZmFsc2U7XG4gIH1cblxuICBpZiAoIWxhc3RfdGFnX3Rva2VuLmlzX2lubGluZV9lbGVtZW50ICYmXG4gICAgIShsYXN0X3RhZ190b2tlbi5pc191bmZvcm1hdHRlZCB8fCBsYXN0X3RhZ190b2tlbi5pc19jb250ZW50X3VuZm9ybWF0dGVkKSkge1xuICAgIHByaW50ZXIuc2V0X3dyYXBfcG9pbnQoKTtcbiAgfVxuXG4gIHJldHVybiBwYXJzZXJfdG9rZW47XG59O1xuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5faGFuZGxlX2luc2lkZV90YWcgPSBmdW5jdGlvbihwcmludGVyLCByYXdfdG9rZW4sIGxhc3RfdGFnX3Rva2VuLCB0b2tlbnMpIHtcbiAgdmFyIHdyYXBwZWQgPSBsYXN0X3RhZ190b2tlbi5oYXNfd3JhcHBlZF9hdHRycztcbiAgdmFyIHBhcnNlcl90b2tlbiA9IHtcbiAgICB0ZXh0OiByYXdfdG9rZW4udGV4dCxcbiAgICB0eXBlOiByYXdfdG9rZW4udHlwZVxuICB9O1xuXG4gIHByaW50ZXIuc2V0X3NwYWNlX2JlZm9yZV90b2tlbihyYXdfdG9rZW4ubmV3bGluZXMgfHwgcmF3X3Rva2VuLndoaXRlc3BhY2VfYmVmb3JlICE9PSAnJywgdHJ1ZSk7XG4gIGlmIChsYXN0X3RhZ190b2tlbi5pc191bmZvcm1hdHRlZCkge1xuICAgIHByaW50ZXIuYWRkX3Jhd190b2tlbihyYXdfdG9rZW4pO1xuICB9IGVsc2UgaWYgKGxhc3RfdGFnX3Rva2VuLnRhZ19zdGFydF9jaGFyID09PSAneycgJiYgcmF3X3Rva2VuLnR5cGUgPT09IFRPS0VOLlRFWFQpIHtcbiAgICAvLyBGb3IgdGhlIGluc2lkZXMgb2YgaGFuZGxlYmFycyBhbGxvdyBuZXdsaW5lcyBvciBhIHNpbmdsZSBzcGFjZSBiZXR3ZWVuIG9wZW4gYW5kIGNvbnRlbnRzXG4gICAgaWYgKHByaW50ZXIucHJpbnRfcHJlc2VydmVkX25ld2xpbmVzKHJhd190b2tlbikpIHtcbiAgICAgIHJhd190b2tlbi5uZXdsaW5lcyA9IDA7XG4gICAgICBwcmludGVyLmFkZF9yYXdfdG9rZW4ocmF3X3Rva2VuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJpbnRlci5wcmludF90b2tlbihyYXdfdG9rZW4pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAocmF3X3Rva2VuLnR5cGUgPT09IFRPS0VOLkFUVFJJQlVURSkge1xuICAgICAgcHJpbnRlci5zZXRfc3BhY2VfYmVmb3JlX3Rva2VuKHRydWUpO1xuICAgICAgbGFzdF90YWdfdG9rZW4uYXR0cl9jb3VudCArPSAxO1xuICAgIH0gZWxzZSBpZiAocmF3X3Rva2VuLnR5cGUgPT09IFRPS0VOLkVRVUFMUykgeyAvL25vIHNwYWNlIGJlZm9yZSA9XG4gICAgICBwcmludGVyLnNldF9zcGFjZV9iZWZvcmVfdG9rZW4oZmFsc2UpO1xuICAgIH0gZWxzZSBpZiAocmF3X3Rva2VuLnR5cGUgPT09IFRPS0VOLlZBTFVFICYmIHJhd190b2tlbi5wcmV2aW91cy50eXBlID09PSBUT0tFTi5FUVVBTFMpIHsgLy9ubyBzcGFjZSBiZWZvcmUgdmFsdWVcbiAgICAgIHByaW50ZXIuc2V0X3NwYWNlX2JlZm9yZV90b2tlbihmYWxzZSk7XG4gICAgfVxuXG4gICAgaWYgKHJhd190b2tlbi50eXBlID09PSBUT0tFTi5BVFRSSUJVVEUgJiYgbGFzdF90YWdfdG9rZW4udGFnX3N0YXJ0X2NoYXIgPT09ICc8Jykge1xuICAgICAgaWYgKHRoaXMuX2lzX3dyYXBfYXR0cmlidXRlc19wcmVzZXJ2ZSB8fCB0aGlzLl9pc193cmFwX2F0dHJpYnV0ZXNfcHJlc2VydmVfYWxpZ25lZCkge1xuICAgICAgICBwcmludGVyLnRyYXZlcnNlX3doaXRlc3BhY2UocmF3X3Rva2VuKTtcbiAgICAgICAgd3JhcHBlZCA9IHdyYXBwZWQgfHwgcmF3X3Rva2VuLm5ld2xpbmVzICE9PSAwO1xuICAgICAgfVxuXG5cbiAgICAgIGlmICh0aGlzLl9pc193cmFwX2F0dHJpYnV0ZXNfZm9yY2UpIHtcbiAgICAgICAgdmFyIGZvcmNlX2F0dHJfd3JhcCA9IGxhc3RfdGFnX3Rva2VuLmF0dHJfY291bnQgPiAxO1xuICAgICAgICBpZiAodGhpcy5faXNfd3JhcF9hdHRyaWJ1dGVzX2ZvcmNlX2V4cGFuZF9tdWx0aWxpbmUgJiYgbGFzdF90YWdfdG9rZW4uYXR0cl9jb3VudCA9PT0gMSkge1xuICAgICAgICAgIHZhciBpc19vbmx5X2F0dHJpYnV0ZSA9IHRydWU7XG4gICAgICAgICAgdmFyIHBlZWtfaW5kZXggPSAwO1xuICAgICAgICAgIHZhciBwZWVrX3Rva2VuO1xuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIHBlZWtfdG9rZW4gPSB0b2tlbnMucGVlayhwZWVrX2luZGV4KTtcbiAgICAgICAgICAgIGlmIChwZWVrX3Rva2VuLnR5cGUgPT09IFRPS0VOLkFUVFJJQlVURSkge1xuICAgICAgICAgICAgICBpc19vbmx5X2F0dHJpYnV0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBlZWtfaW5kZXggKz0gMTtcbiAgICAgICAgICB9IHdoaWxlIChwZWVrX2luZGV4IDwgNCAmJiBwZWVrX3Rva2VuLnR5cGUgIT09IFRPS0VOLkVPRiAmJiBwZWVrX3Rva2VuLnR5cGUgIT09IFRPS0VOLlRBR19DTE9TRSk7XG5cbiAgICAgICAgICBmb3JjZV9hdHRyX3dyYXAgPSAhaXNfb25seV9hdHRyaWJ1dGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZm9yY2VfYXR0cl93cmFwKSB7XG4gICAgICAgICAgcHJpbnRlci5wcmludF9uZXdsaW5lKGZhbHNlKTtcbiAgICAgICAgICB3cmFwcGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBwcmludGVyLnByaW50X3Rva2VuKHJhd190b2tlbik7XG4gICAgd3JhcHBlZCA9IHdyYXBwZWQgfHwgcHJpbnRlci5wcmV2aW91c190b2tlbl93cmFwcGVkKCk7XG4gICAgbGFzdF90YWdfdG9rZW4uaGFzX3dyYXBwZWRfYXR0cnMgPSB3cmFwcGVkO1xuICB9XG4gIHJldHVybiBwYXJzZXJfdG9rZW47XG59O1xuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5faGFuZGxlX3RleHQgPSBmdW5jdGlvbihwcmludGVyLCByYXdfdG9rZW4sIGxhc3RfdGFnX3Rva2VuKSB7XG4gIHZhciBwYXJzZXJfdG9rZW4gPSB7XG4gICAgdGV4dDogcmF3X3Rva2VuLnRleHQsXG4gICAgdHlwZTogJ1RLX0NPTlRFTlQnXG4gIH07XG4gIGlmIChsYXN0X3RhZ190b2tlbi5jdXN0b21fYmVhdXRpZmllcl9uYW1lKSB7IC8vY2hlY2sgaWYgd2UgbmVlZCB0byBmb3JtYXQgamF2YXNjcmlwdFxuICAgIHRoaXMuX3ByaW50X2N1c3RvbV9iZWF0aWZpZXJfdGV4dChwcmludGVyLCByYXdfdG9rZW4sIGxhc3RfdGFnX3Rva2VuKTtcbiAgfSBlbHNlIGlmIChsYXN0X3RhZ190b2tlbi5pc191bmZvcm1hdHRlZCB8fCBsYXN0X3RhZ190b2tlbi5pc19jb250ZW50X3VuZm9ybWF0dGVkKSB7XG4gICAgcHJpbnRlci5hZGRfcmF3X3Rva2VuKHJhd190b2tlbik7XG4gIH0gZWxzZSB7XG4gICAgcHJpbnRlci50cmF2ZXJzZV93aGl0ZXNwYWNlKHJhd190b2tlbik7XG4gICAgcHJpbnRlci5wcmludF90b2tlbihyYXdfdG9rZW4pO1xuICB9XG4gIHJldHVybiBwYXJzZXJfdG9rZW47XG59O1xuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5fcHJpbnRfY3VzdG9tX2JlYXRpZmllcl90ZXh0ID0gZnVuY3Rpb24ocHJpbnRlciwgcmF3X3Rva2VuLCBsYXN0X3RhZ190b2tlbikge1xuICB2YXIgbG9jYWwgPSB0aGlzO1xuICBpZiAocmF3X3Rva2VuLnRleHQgIT09ICcnKSB7XG5cbiAgICB2YXIgdGV4dCA9IHJhd190b2tlbi50ZXh0LFxuICAgICAgX2JlYXV0aWZpZXIsXG4gICAgICBzY3JpcHRfaW5kZW50X2xldmVsID0gMSxcbiAgICAgIHByZSA9ICcnLFxuICAgICAgcG9zdCA9ICcnO1xuICAgIGlmIChsYXN0X3RhZ190b2tlbi5jdXN0b21fYmVhdXRpZmllcl9uYW1lID09PSAnamF2YXNjcmlwdCcgJiYgdHlwZW9mIHRoaXMuX2pzX2JlYXV0aWZ5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBfYmVhdXRpZmllciA9IHRoaXMuX2pzX2JlYXV0aWZ5O1xuICAgIH0gZWxzZSBpZiAobGFzdF90YWdfdG9rZW4uY3VzdG9tX2JlYXV0aWZpZXJfbmFtZSA9PT0gJ2NzcycgJiYgdHlwZW9mIHRoaXMuX2Nzc19iZWF1dGlmeSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgX2JlYXV0aWZpZXIgPSB0aGlzLl9jc3NfYmVhdXRpZnk7XG4gICAgfSBlbHNlIGlmIChsYXN0X3RhZ190b2tlbi5jdXN0b21fYmVhdXRpZmllcl9uYW1lID09PSAnaHRtbCcpIHtcbiAgICAgIF9iZWF1dGlmaWVyID0gZnVuY3Rpb24oaHRtbF9zb3VyY2UsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGJlYXV0aWZpZXIgPSBuZXcgQmVhdXRpZmllcihodG1sX3NvdXJjZSwgb3B0aW9ucywgbG9jYWwuX2pzX2JlYXV0aWZ5LCBsb2NhbC5fY3NzX2JlYXV0aWZ5KTtcbiAgICAgICAgcmV0dXJuIGJlYXV0aWZpZXIuYmVhdXRpZnkoKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX29wdGlvbnMuaW5kZW50X3NjcmlwdHMgPT09IFwia2VlcFwiKSB7XG4gICAgICBzY3JpcHRfaW5kZW50X2xldmVsID0gMDtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX29wdGlvbnMuaW5kZW50X3NjcmlwdHMgPT09IFwic2VwYXJhdGVcIikge1xuICAgICAgc2NyaXB0X2luZGVudF9sZXZlbCA9IC1wcmludGVyLmluZGVudF9sZXZlbDtcbiAgICB9XG5cbiAgICB2YXIgaW5kZW50YXRpb24gPSBwcmludGVyLmdldF9mdWxsX2luZGVudChzY3JpcHRfaW5kZW50X2xldmVsKTtcblxuICAgIC8vIGlmIHRoZXJlIGlzIGF0IGxlYXN0IG9uZSBlbXB0eSBsaW5lIGF0IHRoZSBlbmQgb2YgdGhpcyB0ZXh0LCBzdHJpcCBpdFxuICAgIC8vIHdlJ2xsIGJlIGFkZGluZyBvbmUgYmFjayBhZnRlciB0aGUgdGV4dCBidXQgYmVmb3JlIHRoZSBjb250YWluaW5nIHRhZy5cbiAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC9cXG5bIFxcdF0qJC8sICcnKTtcblxuICAgIC8vIEhhbmRsZSB0aGUgY2FzZSB3aGVyZSBjb250ZW50IGlzIHdyYXBwZWQgaW4gYSBjb21tZW50IG9yIGNkYXRhLlxuICAgIGlmIChsYXN0X3RhZ190b2tlbi5jdXN0b21fYmVhdXRpZmllcl9uYW1lICE9PSAnaHRtbCcgJiZcbiAgICAgIHRleHRbMF0gPT09ICc8JyAmJiB0ZXh0Lm1hdGNoKC9eKDwhLS18PCFcXFtDREFUQVxcWykvKSkge1xuICAgICAgdmFyIG1hdGNoZWQgPSAvXig8IS0tW15cXG5dKnw8IVxcW0NEQVRBXFxbKShcXG4/KShbIFxcdFxcbl0qKShbXFxzXFxTXSopKC0tPnxdXT4pJC8uZXhlYyh0ZXh0KTtcblxuICAgICAgLy8gaWYgd2Ugc3RhcnQgdG8gd3JhcCBidXQgZG9uJ3QgZmluaXNoLCBwcmludCByYXdcbiAgICAgIGlmICghbWF0Y2hlZCkge1xuICAgICAgICBwcmludGVyLmFkZF9yYXdfdG9rZW4ocmF3X3Rva2VuKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBwcmUgPSBpbmRlbnRhdGlvbiArIG1hdGNoZWRbMV0gKyAnXFxuJztcbiAgICAgIHRleHQgPSBtYXRjaGVkWzRdO1xuICAgICAgaWYgKG1hdGNoZWRbNV0pIHtcbiAgICAgICAgcG9zdCA9IGluZGVudGF0aW9uICsgbWF0Y2hlZFs1XTtcbiAgICAgIH1cblxuICAgICAgLy8gaWYgdGhlcmUgaXMgYXQgbGVhc3Qgb25lIGVtcHR5IGxpbmUgYXQgdGhlIGVuZCBvZiB0aGlzIHRleHQsIHN0cmlwIGl0XG4gICAgICAvLyB3ZSdsbCBiZSBhZGRpbmcgb25lIGJhY2sgYWZ0ZXIgdGhlIHRleHQgYnV0IGJlZm9yZSB0aGUgY29udGFpbmluZyB0YWcuXG4gICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC9cXG5bIFxcdF0qJC8sICcnKTtcblxuICAgICAgaWYgKG1hdGNoZWRbMl0gfHwgbWF0Y2hlZFszXS5pbmRleE9mKCdcXG4nKSAhPT0gLTEpIHtcbiAgICAgICAgLy8gaWYgdGhlIGZpcnN0IGxpbmUgb2YgdGhlIG5vbi1jb21tZW50IHRleHQgaGFzIHNwYWNlc1xuICAgICAgICAvLyB1c2UgdGhhdCBhcyB0aGUgYmFzaXMgZm9yIGluZGVudGluZyBpbiBudWxsIGNhc2UuXG4gICAgICAgIG1hdGNoZWQgPSBtYXRjaGVkWzNdLm1hdGNoKC9bIFxcdF0rJC8pO1xuICAgICAgICBpZiAobWF0Y2hlZCkge1xuICAgICAgICAgIHJhd190b2tlbi53aGl0ZXNwYWNlX2JlZm9yZSA9IG1hdGNoZWRbMF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGV4dCkge1xuICAgICAgaWYgKF9iZWF1dGlmaWVyKSB7XG5cbiAgICAgICAgLy8gY2FsbCB0aGUgQmVhdXRpZmllciBpZiBhdmFsaWFibGVcbiAgICAgICAgdmFyIENoaWxkX29wdGlvbnMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aGlzLmVvbCA9ICdcXG4nO1xuICAgICAgICB9O1xuICAgICAgICBDaGlsZF9vcHRpb25zLnByb3RvdHlwZSA9IHRoaXMuX29wdGlvbnMucmF3X29wdGlvbnM7XG4gICAgICAgIHZhciBjaGlsZF9vcHRpb25zID0gbmV3IENoaWxkX29wdGlvbnMoKTtcbiAgICAgICAgdGV4dCA9IF9iZWF1dGlmaWVyKGluZGVudGF0aW9uICsgdGV4dCwgY2hpbGRfb3B0aW9ucyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBzaW1wbHkgaW5kZW50IHRoZSBzdHJpbmcgb3RoZXJ3aXNlXG4gICAgICAgIHZhciB3aGl0ZSA9IHJhd190b2tlbi53aGl0ZXNwYWNlX2JlZm9yZTtcbiAgICAgICAgaWYgKHdoaXRlKSB7XG4gICAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZShuZXcgUmVnRXhwKCdcXG4oJyArIHdoaXRlICsgJyk/JywgJ2cnKSwgJ1xcbicpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGV4dCA9IGluZGVudGF0aW9uICsgdGV4dC5yZXBsYWNlKC9cXG4vZywgJ1xcbicgKyBpbmRlbnRhdGlvbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHByZSkge1xuICAgICAgaWYgKCF0ZXh0KSB7XG4gICAgICAgIHRleHQgPSBwcmUgKyBwb3N0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGV4dCA9IHByZSArIHRleHQgKyAnXFxuJyArIHBvc3Q7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcHJpbnRlci5wcmludF9uZXdsaW5lKGZhbHNlKTtcbiAgICBpZiAodGV4dCkge1xuICAgICAgcmF3X3Rva2VuLnRleHQgPSB0ZXh0O1xuICAgICAgcmF3X3Rva2VuLndoaXRlc3BhY2VfYmVmb3JlID0gJyc7XG4gICAgICByYXdfdG9rZW4ubmV3bGluZXMgPSAwO1xuICAgICAgcHJpbnRlci5hZGRfcmF3X3Rva2VuKHJhd190b2tlbik7XG4gICAgICBwcmludGVyLnByaW50X25ld2xpbmUodHJ1ZSk7XG4gICAgfVxuICB9XG59O1xuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5faGFuZGxlX3RhZ19vcGVuID0gZnVuY3Rpb24ocHJpbnRlciwgcmF3X3Rva2VuLCBsYXN0X3RhZ190b2tlbiwgbGFzdF90b2tlbikge1xuICB2YXIgcGFyc2VyX3Rva2VuID0gdGhpcy5fZ2V0X3RhZ19vcGVuX3Rva2VuKHJhd190b2tlbik7XG5cbiAgaWYgKChsYXN0X3RhZ190b2tlbi5pc191bmZvcm1hdHRlZCB8fCBsYXN0X3RhZ190b2tlbi5pc19jb250ZW50X3VuZm9ybWF0dGVkKSAmJlxuICAgICFsYXN0X3RhZ190b2tlbi5pc19lbXB0eV9lbGVtZW50ICYmXG4gICAgcmF3X3Rva2VuLnR5cGUgPT09IFRPS0VOLlRBR19PUEVOICYmIHJhd190b2tlbi50ZXh0LmluZGV4T2YoJzwvJykgPT09IDApIHtcbiAgICAvLyBFbmQgZWxlbWVudCB0YWdzIGZvciB1bmZvcm1hdHRlZCBvciBjb250ZW50X3VuZm9ybWF0dGVkIGVsZW1lbnRzXG4gICAgLy8gYXJlIHByaW50ZWQgcmF3IHRvIGtlZXAgYW55IG5ld2xpbmVzIGluc2lkZSB0aGVtIGV4YWN0bHkgdGhlIHNhbWUuXG4gICAgcHJpbnRlci5hZGRfcmF3X3Rva2VuKHJhd190b2tlbik7XG4gICAgcGFyc2VyX3Rva2VuLnN0YXJ0X3RhZ190b2tlbiA9IHRoaXMuX3RhZ19zdGFjay50cnlfcG9wKHBhcnNlcl90b2tlbi50YWdfbmFtZSk7XG4gIH0gZWxzZSB7XG4gICAgcHJpbnRlci50cmF2ZXJzZV93aGl0ZXNwYWNlKHJhd190b2tlbik7XG4gICAgdGhpcy5fc2V0X3RhZ19wb3NpdGlvbihwcmludGVyLCByYXdfdG9rZW4sIHBhcnNlcl90b2tlbiwgbGFzdF90YWdfdG9rZW4sIGxhc3RfdG9rZW4pO1xuICAgIGlmICghcGFyc2VyX3Rva2VuLmlzX2lubGluZV9lbGVtZW50KSB7XG4gICAgICBwcmludGVyLnNldF93cmFwX3BvaW50KCk7XG4gICAgfVxuICAgIHByaW50ZXIucHJpbnRfdG9rZW4ocmF3X3Rva2VuKTtcbiAgfVxuXG4gIC8vaW5kZW50IGF0dHJpYnV0ZXMgYW4gYXV0bywgZm9yY2VkLCBhbGlnbmVkIG9yIGZvcmNlZC1hbGlnbiBsaW5lLXdyYXBcbiAgaWYgKHRoaXMuX2lzX3dyYXBfYXR0cmlidXRlc19mb3JjZV9hbGlnbmVkIHx8IHRoaXMuX2lzX3dyYXBfYXR0cmlidXRlc19hbGlnbmVkX211bHRpcGxlIHx8IHRoaXMuX2lzX3dyYXBfYXR0cmlidXRlc19wcmVzZXJ2ZV9hbGlnbmVkKSB7XG4gICAgcGFyc2VyX3Rva2VuLmFsaWdubWVudF9zaXplID0gcmF3X3Rva2VuLnRleHQubGVuZ3RoICsgMTtcbiAgfVxuXG4gIGlmICghcGFyc2VyX3Rva2VuLnRhZ19jb21wbGV0ZSAmJiAhcGFyc2VyX3Rva2VuLmlzX3VuZm9ybWF0dGVkKSB7XG4gICAgcHJpbnRlci5hbGlnbm1lbnRfc2l6ZSA9IHBhcnNlcl90b2tlbi5hbGlnbm1lbnRfc2l6ZTtcbiAgfVxuXG4gIHJldHVybiBwYXJzZXJfdG9rZW47XG59O1xuXG52YXIgVGFnT3BlblBhcnNlclRva2VuID0gZnVuY3Rpb24ocGFyZW50LCByYXdfdG9rZW4pIHtcbiAgdGhpcy5wYXJlbnQgPSBwYXJlbnQgfHwgbnVsbDtcbiAgdGhpcy50ZXh0ID0gJyc7XG4gIHRoaXMudHlwZSA9ICdUS19UQUdfT1BFTic7XG4gIHRoaXMudGFnX25hbWUgPSAnJztcbiAgdGhpcy5pc19pbmxpbmVfZWxlbWVudCA9IGZhbHNlO1xuICB0aGlzLmlzX3VuZm9ybWF0dGVkID0gZmFsc2U7XG4gIHRoaXMuaXNfY29udGVudF91bmZvcm1hdHRlZCA9IGZhbHNlO1xuICB0aGlzLmlzX2VtcHR5X2VsZW1lbnQgPSBmYWxzZTtcbiAgdGhpcy5pc19zdGFydF90YWcgPSBmYWxzZTtcbiAgdGhpcy5pc19lbmRfdGFnID0gZmFsc2U7XG4gIHRoaXMuaW5kZW50X2NvbnRlbnQgPSBmYWxzZTtcbiAgdGhpcy5tdWx0aWxpbmVfY29udGVudCA9IGZhbHNlO1xuICB0aGlzLmN1c3RvbV9iZWF1dGlmaWVyX25hbWUgPSBudWxsO1xuICB0aGlzLnN0YXJ0X3RhZ190b2tlbiA9IG51bGw7XG4gIHRoaXMuYXR0cl9jb3VudCA9IDA7XG4gIHRoaXMuaGFzX3dyYXBwZWRfYXR0cnMgPSBmYWxzZTtcbiAgdGhpcy5hbGlnbm1lbnRfc2l6ZSA9IDA7XG4gIHRoaXMudGFnX2NvbXBsZXRlID0gZmFsc2U7XG4gIHRoaXMudGFnX3N0YXJ0X2NoYXIgPSAnJztcbiAgdGhpcy50YWdfY2hlY2sgPSAnJztcblxuICBpZiAoIXJhd190b2tlbikge1xuICAgIHRoaXMudGFnX2NvbXBsZXRlID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgdGFnX2NoZWNrX21hdGNoO1xuXG4gICAgdGhpcy50YWdfc3RhcnRfY2hhciA9IHJhd190b2tlbi50ZXh0WzBdO1xuICAgIHRoaXMudGV4dCA9IHJhd190b2tlbi50ZXh0O1xuXG4gICAgaWYgKHRoaXMudGFnX3N0YXJ0X2NoYXIgPT09ICc8Jykge1xuICAgICAgdGFnX2NoZWNrX21hdGNoID0gcmF3X3Rva2VuLnRleHQubWF0Y2goL148KFteXFxzPl0qKS8pO1xuICAgICAgdGhpcy50YWdfY2hlY2sgPSB0YWdfY2hlY2tfbWF0Y2ggPyB0YWdfY2hlY2tfbWF0Y2hbMV0gOiAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgdGFnX2NoZWNrX21hdGNoID0gcmF3X3Rva2VuLnRleHQubWF0Y2goL157eyg/OltcXF5dfCNcXCo/KT8oW15cXHN9XSspLyk7XG4gICAgICB0aGlzLnRhZ19jaGVjayA9IHRhZ19jaGVja19tYXRjaCA/IHRhZ19jaGVja19tYXRjaFsxXSA6ICcnO1xuXG4gICAgICAvLyBoYW5kbGUgXCJ7eyM+IG15UGFydGlhbH19XG4gICAgICBpZiAocmF3X3Rva2VuLnRleHQgPT09ICd7eyM+JyAmJiB0aGlzLnRhZ19jaGVjayA9PT0gJz4nICYmIHJhd190b2tlbi5uZXh0ICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMudGFnX2NoZWNrID0gcmF3X3Rva2VuLm5leHQudGV4dDtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy50YWdfY2hlY2sgPSB0aGlzLnRhZ19jaGVjay50b0xvd2VyQ2FzZSgpO1xuXG4gICAgaWYgKHJhd190b2tlbi50eXBlID09PSBUT0tFTi5DT01NRU5UKSB7XG4gICAgICB0aGlzLnRhZ19jb21wbGV0ZSA9IHRydWU7XG4gICAgfVxuXG4gICAgdGhpcy5pc19zdGFydF90YWcgPSB0aGlzLnRhZ19jaGVjay5jaGFyQXQoMCkgIT09ICcvJztcbiAgICB0aGlzLnRhZ19uYW1lID0gIXRoaXMuaXNfc3RhcnRfdGFnID8gdGhpcy50YWdfY2hlY2suc3Vic3RyKDEpIDogdGhpcy50YWdfY2hlY2s7XG4gICAgdGhpcy5pc19lbmRfdGFnID0gIXRoaXMuaXNfc3RhcnRfdGFnIHx8XG4gICAgICAocmF3X3Rva2VuLmNsb3NlZCAmJiByYXdfdG9rZW4uY2xvc2VkLnRleHQgPT09ICcvPicpO1xuXG4gICAgLy8gaGFuZGxlYmFycyB0YWdzIHRoYXQgZG9uJ3Qgc3RhcnQgd2l0aCAjIG9yIF4gYXJlIHNpbmdsZV90YWdzLCBhbmQgc28gYWxzbyBzdGFydCBhbmQgZW5kLlxuICAgIHRoaXMuaXNfZW5kX3RhZyA9IHRoaXMuaXNfZW5kX3RhZyB8fFxuICAgICAgKHRoaXMudGFnX3N0YXJ0X2NoYXIgPT09ICd7JyAmJiAodGhpcy50ZXh0Lmxlbmd0aCA8IDMgfHwgKC9bXiNcXF5dLy50ZXN0KHRoaXMudGV4dC5jaGFyQXQoMikpKSkpO1xuICB9XG59O1xuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5fZ2V0X3RhZ19vcGVuX3Rva2VuID0gZnVuY3Rpb24ocmF3X3Rva2VuKSB7IC8vZnVuY3Rpb24gdG8gZ2V0IGEgZnVsbCB0YWcgYW5kIHBhcnNlIGl0cyB0eXBlXG4gIHZhciBwYXJzZXJfdG9rZW4gPSBuZXcgVGFnT3BlblBhcnNlclRva2VuKHRoaXMuX3RhZ19zdGFjay5nZXRfcGFyc2VyX3Rva2VuKCksIHJhd190b2tlbik7XG5cbiAgcGFyc2VyX3Rva2VuLmFsaWdubWVudF9zaXplID0gdGhpcy5fb3B0aW9ucy53cmFwX2F0dHJpYnV0ZXNfaW5kZW50X3NpemU7XG5cbiAgcGFyc2VyX3Rva2VuLmlzX2VuZF90YWcgPSBwYXJzZXJfdG9rZW4uaXNfZW5kX3RhZyB8fFxuICAgIGluX2FycmF5KHBhcnNlcl90b2tlbi50YWdfY2hlY2ssIHRoaXMuX29wdGlvbnMudm9pZF9lbGVtZW50cyk7XG5cbiAgcGFyc2VyX3Rva2VuLmlzX2VtcHR5X2VsZW1lbnQgPSBwYXJzZXJfdG9rZW4udGFnX2NvbXBsZXRlIHx8XG4gICAgKHBhcnNlcl90b2tlbi5pc19zdGFydF90YWcgJiYgcGFyc2VyX3Rva2VuLmlzX2VuZF90YWcpO1xuXG4gIHBhcnNlcl90b2tlbi5pc191bmZvcm1hdHRlZCA9ICFwYXJzZXJfdG9rZW4udGFnX2NvbXBsZXRlICYmIGluX2FycmF5KHBhcnNlcl90b2tlbi50YWdfY2hlY2ssIHRoaXMuX29wdGlvbnMudW5mb3JtYXR0ZWQpO1xuICBwYXJzZXJfdG9rZW4uaXNfY29udGVudF91bmZvcm1hdHRlZCA9ICFwYXJzZXJfdG9rZW4uaXNfZW1wdHlfZWxlbWVudCAmJiBpbl9hcnJheShwYXJzZXJfdG9rZW4udGFnX2NoZWNrLCB0aGlzLl9vcHRpb25zLmNvbnRlbnRfdW5mb3JtYXR0ZWQpO1xuICBwYXJzZXJfdG9rZW4uaXNfaW5saW5lX2VsZW1lbnQgPSBpbl9hcnJheShwYXJzZXJfdG9rZW4udGFnX25hbWUsIHRoaXMuX29wdGlvbnMuaW5saW5lKSB8fCBwYXJzZXJfdG9rZW4udGFnX3N0YXJ0X2NoYXIgPT09ICd7JztcblxuICByZXR1cm4gcGFyc2VyX3Rva2VuO1xufTtcblxuQmVhdXRpZmllci5wcm90b3R5cGUuX3NldF90YWdfcG9zaXRpb24gPSBmdW5jdGlvbihwcmludGVyLCByYXdfdG9rZW4sIHBhcnNlcl90b2tlbiwgbGFzdF90YWdfdG9rZW4sIGxhc3RfdG9rZW4pIHtcblxuICBpZiAoIXBhcnNlcl90b2tlbi5pc19lbXB0eV9lbGVtZW50KSB7XG4gICAgaWYgKHBhcnNlcl90b2tlbi5pc19lbmRfdGFnKSB7IC8vdGhpcyB0YWcgaXMgYSBkb3VibGUgdGFnIHNvIGNoZWNrIGZvciB0YWctZW5kaW5nXG4gICAgICBwYXJzZXJfdG9rZW4uc3RhcnRfdGFnX3Rva2VuID0gdGhpcy5fdGFnX3N0YWNrLnRyeV9wb3AocGFyc2VyX3Rva2VuLnRhZ19uYW1lKTsgLy9yZW1vdmUgaXQgYW5kIGFsbCBhbmNlc3RvcnNcbiAgICB9IGVsc2UgeyAvLyBpdCdzIGEgc3RhcnQtdGFnXG4gICAgICAvLyBjaGVjayBpZiB0aGlzIHRhZyBpcyBzdGFydGluZyBhbiBlbGVtZW50IHRoYXQgaGFzIG9wdGlvbmFsIGVuZCBlbGVtZW50XG4gICAgICAvLyBhbmQgZG8gYW4gZW5kaW5nIG5lZWRlZFxuICAgICAgaWYgKHRoaXMuX2RvX29wdGlvbmFsX2VuZF9lbGVtZW50KHBhcnNlcl90b2tlbikpIHtcbiAgICAgICAgaWYgKCFwYXJzZXJfdG9rZW4uaXNfaW5saW5lX2VsZW1lbnQpIHtcbiAgICAgICAgICBwcmludGVyLnByaW50X25ld2xpbmUoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3RhZ19zdGFjay5yZWNvcmRfdGFnKHBhcnNlcl90b2tlbik7IC8vcHVzaCBpdCBvbiB0aGUgdGFnIHN0YWNrXG5cbiAgICAgIGlmICgocGFyc2VyX3Rva2VuLnRhZ19uYW1lID09PSAnc2NyaXB0JyB8fCBwYXJzZXJfdG9rZW4udGFnX25hbWUgPT09ICdzdHlsZScpICYmXG4gICAgICAgICEocGFyc2VyX3Rva2VuLmlzX3VuZm9ybWF0dGVkIHx8IHBhcnNlcl90b2tlbi5pc19jb250ZW50X3VuZm9ybWF0dGVkKSkge1xuICAgICAgICBwYXJzZXJfdG9rZW4uY3VzdG9tX2JlYXV0aWZpZXJfbmFtZSA9IGdldF9jdXN0b21fYmVhdXRpZmllcl9uYW1lKHBhcnNlcl90b2tlbi50YWdfY2hlY2ssIHJhd190b2tlbik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGluX2FycmF5KHBhcnNlcl90b2tlbi50YWdfY2hlY2ssIHRoaXMuX29wdGlvbnMuZXh0cmFfbGluZXJzKSkgeyAvL2NoZWNrIGlmIHRoaXMgZG91YmxlIG5lZWRzIGFuIGV4dHJhIGxpbmVcbiAgICBwcmludGVyLnByaW50X25ld2xpbmUoZmFsc2UpO1xuICAgIGlmICghcHJpbnRlci5fb3V0cHV0Lmp1c3RfYWRkZWRfYmxhbmtsaW5lKCkpIHtcbiAgICAgIHByaW50ZXIucHJpbnRfbmV3bGluZSh0cnVlKTtcbiAgICB9XG4gIH1cblxuICBpZiAocGFyc2VyX3Rva2VuLmlzX2VtcHR5X2VsZW1lbnQpIHsgLy9pZiB0aGlzIHRhZyBuYW1lIGlzIGEgc2luZ2xlIHRhZyB0eXBlIChlaXRoZXIgaW4gdGhlIGxpc3Qgb3IgaGFzIGEgY2xvc2luZyAvKVxuXG4gICAgLy8gaWYgeW91IGhpdCBhbiBlbHNlIGNhc2UsIHJlc2V0IHRoZSBpbmRlbnQgbGV2ZWwgaWYgeW91IGFyZSBpbnNpZGUgYW46XG4gICAgLy8gJ2lmJywgJ3VubGVzcycsIG9yICdlYWNoJyBibG9jay5cbiAgICBpZiAocGFyc2VyX3Rva2VuLnRhZ19zdGFydF9jaGFyID09PSAneycgJiYgcGFyc2VyX3Rva2VuLnRhZ19jaGVjayA9PT0gJ2Vsc2UnKSB7XG4gICAgICB0aGlzLl90YWdfc3RhY2suaW5kZW50X3RvX3RhZyhbJ2lmJywgJ3VubGVzcycsICdlYWNoJ10pO1xuICAgICAgcGFyc2VyX3Rva2VuLmluZGVudF9jb250ZW50ID0gdHJ1ZTtcbiAgICAgIC8vIERvbid0IGFkZCBhIG5ld2xpbmUgaWYgb3BlbmluZyB7eyNpZn19IHRhZyBpcyBvbiB0aGUgY3VycmVudCBsaW5lXG4gICAgICB2YXIgZm91bmRJZk9uQ3VycmVudExpbmUgPSBwcmludGVyLmN1cnJlbnRfbGluZV9oYXNfbWF0Y2goL3t7I2lmLyk7XG4gICAgICBpZiAoIWZvdW5kSWZPbkN1cnJlbnRMaW5lKSB7XG4gICAgICAgIHByaW50ZXIucHJpbnRfbmV3bGluZShmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRG9uJ3QgYWRkIGEgbmV3bGluZSBiZWZvcmUgZWxlbWVudHMgdGhhdCBzaG91bGQgcmVtYWluIHdoZXJlIHRoZXkgYXJlLlxuICAgIGlmIChwYXJzZXJfdG9rZW4udGFnX25hbWUgPT09ICchLS0nICYmIGxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uVEFHX0NMT1NFICYmXG4gICAgICBsYXN0X3RhZ190b2tlbi5pc19lbmRfdGFnICYmIHBhcnNlcl90b2tlbi50ZXh0LmluZGV4T2YoJ1xcbicpID09PSAtMSkge1xuICAgICAgLy9EbyBub3RoaW5nLiBMZWF2ZSBjb21tZW50cyBvbiBzYW1lIGxpbmUuXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghKHBhcnNlcl90b2tlbi5pc19pbmxpbmVfZWxlbWVudCB8fCBwYXJzZXJfdG9rZW4uaXNfdW5mb3JtYXR0ZWQpKSB7XG4gICAgICAgIHByaW50ZXIucHJpbnRfbmV3bGluZShmYWxzZSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9jYWxjbHVhdGVfcGFyZW50X211bHRpbGluZShwcmludGVyLCBwYXJzZXJfdG9rZW4pO1xuICAgIH1cbiAgfSBlbHNlIGlmIChwYXJzZXJfdG9rZW4uaXNfZW5kX3RhZykgeyAvL3RoaXMgdGFnIGlzIGEgZG91YmxlIHRhZyBzbyBjaGVjayBmb3IgdGFnLWVuZGluZ1xuICAgIHZhciBkb19lbmRfZXhwYW5kID0gZmFsc2U7XG5cbiAgICAvLyBkZWNpZGluZyB3aGV0aGVyIGEgYmxvY2sgaXMgbXVsdGlsaW5lIHNob3VsZCBub3QgYmUgdGhpcyBoYXJkXG4gICAgZG9fZW5kX2V4cGFuZCA9IHBhcnNlcl90b2tlbi5zdGFydF90YWdfdG9rZW4gJiYgcGFyc2VyX3Rva2VuLnN0YXJ0X3RhZ190b2tlbi5tdWx0aWxpbmVfY29udGVudDtcbiAgICBkb19lbmRfZXhwYW5kID0gZG9fZW5kX2V4cGFuZCB8fCAoIXBhcnNlcl90b2tlbi5pc19pbmxpbmVfZWxlbWVudCAmJlxuICAgICAgIShsYXN0X3RhZ190b2tlbi5pc19pbmxpbmVfZWxlbWVudCB8fCBsYXN0X3RhZ190b2tlbi5pc191bmZvcm1hdHRlZCkgJiZcbiAgICAgICEobGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5UQUdfQ0xPU0UgJiYgcGFyc2VyX3Rva2VuLnN0YXJ0X3RhZ190b2tlbiA9PT0gbGFzdF90YWdfdG9rZW4pICYmXG4gICAgICBsYXN0X3Rva2VuLnR5cGUgIT09ICdUS19DT05URU5UJ1xuICAgICk7XG5cbiAgICBpZiAocGFyc2VyX3Rva2VuLmlzX2NvbnRlbnRfdW5mb3JtYXR0ZWQgfHwgcGFyc2VyX3Rva2VuLmlzX3VuZm9ybWF0dGVkKSB7XG4gICAgICBkb19lbmRfZXhwYW5kID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGRvX2VuZF9leHBhbmQpIHtcbiAgICAgIHByaW50ZXIucHJpbnRfbmV3bGluZShmYWxzZSk7XG4gICAgfVxuICB9IGVsc2UgeyAvLyBpdCdzIGEgc3RhcnQtdGFnXG4gICAgcGFyc2VyX3Rva2VuLmluZGVudF9jb250ZW50ID0gIXBhcnNlcl90b2tlbi5jdXN0b21fYmVhdXRpZmllcl9uYW1lO1xuXG4gICAgaWYgKHBhcnNlcl90b2tlbi50YWdfc3RhcnRfY2hhciA9PT0gJzwnKSB7XG4gICAgICBpZiAocGFyc2VyX3Rva2VuLnRhZ19uYW1lID09PSAnaHRtbCcpIHtcbiAgICAgICAgcGFyc2VyX3Rva2VuLmluZGVudF9jb250ZW50ID0gdGhpcy5fb3B0aW9ucy5pbmRlbnRfaW5uZXJfaHRtbDtcbiAgICAgIH0gZWxzZSBpZiAocGFyc2VyX3Rva2VuLnRhZ19uYW1lID09PSAnaGVhZCcpIHtcbiAgICAgICAgcGFyc2VyX3Rva2VuLmluZGVudF9jb250ZW50ID0gdGhpcy5fb3B0aW9ucy5pbmRlbnRfaGVhZF9pbm5lcl9odG1sO1xuICAgICAgfSBlbHNlIGlmIChwYXJzZXJfdG9rZW4udGFnX25hbWUgPT09ICdib2R5Jykge1xuICAgICAgICBwYXJzZXJfdG9rZW4uaW5kZW50X2NvbnRlbnQgPSB0aGlzLl9vcHRpb25zLmluZGVudF9ib2R5X2lubmVyX2h0bWw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCEocGFyc2VyX3Rva2VuLmlzX2lubGluZV9lbGVtZW50IHx8IHBhcnNlcl90b2tlbi5pc191bmZvcm1hdHRlZCkgJiZcbiAgICAgIChsYXN0X3Rva2VuLnR5cGUgIT09ICdUS19DT05URU5UJyB8fCBwYXJzZXJfdG9rZW4uaXNfY29udGVudF91bmZvcm1hdHRlZCkpIHtcbiAgICAgIHByaW50ZXIucHJpbnRfbmV3bGluZShmYWxzZSk7XG4gICAgfVxuXG4gICAgdGhpcy5fY2FsY2x1YXRlX3BhcmVudF9tdWx0aWxpbmUocHJpbnRlciwgcGFyc2VyX3Rva2VuKTtcbiAgfVxufTtcblxuQmVhdXRpZmllci5wcm90b3R5cGUuX2NhbGNsdWF0ZV9wYXJlbnRfbXVsdGlsaW5lID0gZnVuY3Rpb24ocHJpbnRlciwgcGFyc2VyX3Rva2VuKSB7XG4gIGlmIChwYXJzZXJfdG9rZW4ucGFyZW50ICYmIHByaW50ZXIuX291dHB1dC5qdXN0X2FkZGVkX25ld2xpbmUoKSAmJlxuICAgICEoKHBhcnNlcl90b2tlbi5pc19pbmxpbmVfZWxlbWVudCB8fCBwYXJzZXJfdG9rZW4uaXNfdW5mb3JtYXR0ZWQpICYmIHBhcnNlcl90b2tlbi5wYXJlbnQuaXNfaW5saW5lX2VsZW1lbnQpKSB7XG4gICAgcGFyc2VyX3Rva2VuLnBhcmVudC5tdWx0aWxpbmVfY29udGVudCA9IHRydWU7XG4gIH1cbn07XG5cbi8vVG8gYmUgdXNlZCBmb3IgPHA+IHRhZyBzcGVjaWFsIGNhc2U6XG52YXIgcF9jbG9zZXJzID0gWydhZGRyZXNzJywgJ2FydGljbGUnLCAnYXNpZGUnLCAnYmxvY2txdW90ZScsICdkZXRhaWxzJywgJ2RpdicsICdkbCcsICdmaWVsZHNldCcsICdmaWdjYXB0aW9uJywgJ2ZpZ3VyZScsICdmb290ZXInLCAnZm9ybScsICdoMScsICdoMicsICdoMycsICdoNCcsICdoNScsICdoNicsICdoZWFkZXInLCAnaHInLCAnbWFpbicsICduYXYnLCAnb2wnLCAncCcsICdwcmUnLCAnc2VjdGlvbicsICd0YWJsZScsICd1bCddO1xudmFyIHBfcGFyZW50X2V4Y2x1ZGVzID0gWydhJywgJ2F1ZGlvJywgJ2RlbCcsICdpbnMnLCAnbWFwJywgJ25vc2NyaXB0JywgJ3ZpZGVvJ107XG5cbkJlYXV0aWZpZXIucHJvdG90eXBlLl9kb19vcHRpb25hbF9lbmRfZWxlbWVudCA9IGZ1bmN0aW9uKHBhcnNlcl90b2tlbikge1xuICB2YXIgcmVzdWx0ID0gbnVsbDtcbiAgLy8gTk9URTogY2FzZXMgb2YgXCJpZiB0aGVyZSBpcyBubyBtb3JlIGNvbnRlbnQgaW4gdGhlIHBhcmVudCBlbGVtZW50XCJcbiAgLy8gYXJlIGhhbmRsZWQgYXV0b21hdGljYWxseSBieSB0aGUgYmVhdXRpZmllci5cbiAgLy8gSXQgYXNzdW1lcyBwYXJlbnQgb3IgYW5jZXN0b3IgY2xvc2UgdGFnIGNsb3NlcyBhbGwgY2hpbGRyZW4uXG4gIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9zeW50YXguaHRtbCNvcHRpb25hbC10YWdzXG4gIGlmIChwYXJzZXJfdG9rZW4uaXNfZW1wdHlfZWxlbWVudCB8fCAhcGFyc2VyX3Rva2VuLmlzX3N0YXJ0X3RhZyB8fCAhcGFyc2VyX3Rva2VuLnBhcmVudCkge1xuICAgIHJldHVybjtcblxuICB9XG5cbiAgaWYgKHBhcnNlcl90b2tlbi50YWdfbmFtZSA9PT0gJ2JvZHknKSB7XG4gICAgLy8gQSBoZWFkIGVsZW1lbnTigJlzIGVuZCB0YWcgbWF5IGJlIG9taXR0ZWQgaWYgdGhlIGhlYWQgZWxlbWVudCBpcyBub3QgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgYSBzcGFjZSBjaGFyYWN0ZXIgb3IgYSBjb21tZW50LlxuICAgIHJlc3VsdCA9IHJlc3VsdCB8fCB0aGlzLl90YWdfc3RhY2sudHJ5X3BvcCgnaGVhZCcpO1xuXG4gICAgLy99IGVsc2UgaWYgKHBhcnNlcl90b2tlbi50YWdfbmFtZSA9PT0gJ2JvZHknKSB7XG4gICAgLy8gRE9ORTogQSBib2R5IGVsZW1lbnTigJlzIGVuZCB0YWcgbWF5IGJlIG9taXR0ZWQgaWYgdGhlIGJvZHkgZWxlbWVudCBpcyBub3QgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgYSBjb21tZW50LlxuXG4gIH0gZWxzZSBpZiAocGFyc2VyX3Rva2VuLnRhZ19uYW1lID09PSAnbGknKSB7XG4gICAgLy8gQW4gbGkgZWxlbWVudOKAmXMgZW5kIHRhZyBtYXkgYmUgb21pdHRlZCBpZiB0aGUgbGkgZWxlbWVudCBpcyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSBhbm90aGVyIGxpIGVsZW1lbnQgb3IgaWYgdGhlcmUgaXMgbm8gbW9yZSBjb250ZW50IGluIHRoZSBwYXJlbnQgZWxlbWVudC5cbiAgICByZXN1bHQgPSByZXN1bHQgfHwgdGhpcy5fdGFnX3N0YWNrLnRyeV9wb3AoJ2xpJywgWydvbCcsICd1bCddKTtcblxuICB9IGVsc2UgaWYgKHBhcnNlcl90b2tlbi50YWdfbmFtZSA9PT0gJ2RkJyB8fCBwYXJzZXJfdG9rZW4udGFnX25hbWUgPT09ICdkdCcpIHtcbiAgICAvLyBBIGRkIGVsZW1lbnTigJlzIGVuZCB0YWcgbWF5IGJlIG9taXR0ZWQgaWYgdGhlIGRkIGVsZW1lbnQgaXMgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgYW5vdGhlciBkZCBlbGVtZW50IG9yIGEgZHQgZWxlbWVudCwgb3IgaWYgdGhlcmUgaXMgbm8gbW9yZSBjb250ZW50IGluIHRoZSBwYXJlbnQgZWxlbWVudC5cbiAgICAvLyBBIGR0IGVsZW1lbnTigJlzIGVuZCB0YWcgbWF5IGJlIG9taXR0ZWQgaWYgdGhlIGR0IGVsZW1lbnQgaXMgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgYW5vdGhlciBkdCBlbGVtZW50IG9yIGEgZGQgZWxlbWVudC5cbiAgICByZXN1bHQgPSByZXN1bHQgfHwgdGhpcy5fdGFnX3N0YWNrLnRyeV9wb3AoJ2R0JywgWydkbCddKTtcbiAgICByZXN1bHQgPSByZXN1bHQgfHwgdGhpcy5fdGFnX3N0YWNrLnRyeV9wb3AoJ2RkJywgWydkbCddKTtcblxuXG4gIH0gZWxzZSBpZiAocGFyc2VyX3Rva2VuLnBhcmVudC50YWdfbmFtZSA9PT0gJ3AnICYmIHBfY2xvc2Vycy5pbmRleE9mKHBhcnNlcl90b2tlbi50YWdfbmFtZSkgIT09IC0xKSB7XG4gICAgLy8gSU1QT1JUQU5UOiB0aGlzIGVsc2UtaWYgd29ya3MgYmVjYXVzZSBwX2Nsb3NlcnMgaGFzIG5vIG92ZXJsYXAgd2l0aCBhbnkgb3RoZXIgZWxlbWVudCB3ZSBsb29rIGZvciBpbiB0aGlzIG1ldGhvZFxuICAgIC8vIGNoZWNrIGZvciB0aGUgcGFyZW50IGVsZW1lbnQgaXMgYW4gSFRNTCBlbGVtZW50IHRoYXQgaXMgbm90IGFuIDxhPiwgPGF1ZGlvPiwgPGRlbD4sIDxpbnM+LCA8bWFwPiwgPG5vc2NyaXB0Piwgb3IgPHZpZGVvPiBlbGVtZW50LCAgb3IgYW4gYXV0b25vbW91cyBjdXN0b20gZWxlbWVudC5cbiAgICAvLyBUbyBkbyB0aGlzIHJpZ2h0LCB0aGlzIG5lZWRzIHRvIGJlIGNvZGVkIGFzIGFuIGluY2x1c2lvbiBvZiB0aGUgaW52ZXJzZSBvZiB0aGUgZXhjbHVzaW9uIGFib3ZlLlxuICAgIC8vIEJ1dCB0byBzdGFydCB3aXRoIChpZiB3ZSBpZ25vcmUgXCJhdXRvbm9tb3VzIGN1c3RvbSBlbGVtZW50c1wiKSB0aGUgZXhjbHVzaW9uIHdvdWxkIGJlIGZpbmUuXG4gICAgdmFyIHBfcGFyZW50ID0gcGFyc2VyX3Rva2VuLnBhcmVudC5wYXJlbnQ7XG4gICAgaWYgKCFwX3BhcmVudCB8fCBwX3BhcmVudF9leGNsdWRlcy5pbmRleE9mKHBfcGFyZW50LnRhZ19uYW1lKSA9PT0gLTEpIHtcbiAgICAgIHJlc3VsdCA9IHJlc3VsdCB8fCB0aGlzLl90YWdfc3RhY2sudHJ5X3BvcCgncCcpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChwYXJzZXJfdG9rZW4udGFnX25hbWUgPT09ICdycCcgfHwgcGFyc2VyX3Rva2VuLnRhZ19uYW1lID09PSAncnQnKSB7XG4gICAgLy8gQW4gcnQgZWxlbWVudOKAmXMgZW5kIHRhZyBtYXkgYmUgb21pdHRlZCBpZiB0aGUgcnQgZWxlbWVudCBpcyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSBhbiBydCBvciBycCBlbGVtZW50LCBvciBpZiB0aGVyZSBpcyBubyBtb3JlIGNvbnRlbnQgaW4gdGhlIHBhcmVudCBlbGVtZW50LlxuICAgIC8vIEFuIHJwIGVsZW1lbnTigJlzIGVuZCB0YWcgbWF5IGJlIG9taXR0ZWQgaWYgdGhlIHJwIGVsZW1lbnQgaXMgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgYW4gcnQgb3IgcnAgZWxlbWVudCwgb3IgaWYgdGhlcmUgaXMgbm8gbW9yZSBjb250ZW50IGluIHRoZSBwYXJlbnQgZWxlbWVudC5cbiAgICByZXN1bHQgPSByZXN1bHQgfHwgdGhpcy5fdGFnX3N0YWNrLnRyeV9wb3AoJ3J0JywgWydydWJ5JywgJ3J0YyddKTtcbiAgICByZXN1bHQgPSByZXN1bHQgfHwgdGhpcy5fdGFnX3N0YWNrLnRyeV9wb3AoJ3JwJywgWydydWJ5JywgJ3J0YyddKTtcblxuICB9IGVsc2UgaWYgKHBhcnNlcl90b2tlbi50YWdfbmFtZSA9PT0gJ29wdGdyb3VwJykge1xuICAgIC8vIEFuIG9wdGdyb3VwIGVsZW1lbnTigJlzIGVuZCB0YWcgbWF5IGJlIG9taXR0ZWQgaWYgdGhlIG9wdGdyb3VwIGVsZW1lbnQgaXMgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgYW5vdGhlciBvcHRncm91cCBlbGVtZW50LCBvciBpZiB0aGVyZSBpcyBubyBtb3JlIGNvbnRlbnQgaW4gdGhlIHBhcmVudCBlbGVtZW50LlxuICAgIC8vIEFuIG9wdGlvbiBlbGVtZW504oCZcyBlbmQgdGFnIG1heSBiZSBvbWl0dGVkIGlmIHRoZSBvcHRpb24gZWxlbWVudCBpcyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSBhbm90aGVyIG9wdGlvbiBlbGVtZW50LCBvciBpZiBpdCBpcyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSBhbiBvcHRncm91cCBlbGVtZW50LCBvciBpZiB0aGVyZSBpcyBubyBtb3JlIGNvbnRlbnQgaW4gdGhlIHBhcmVudCBlbGVtZW50LlxuICAgIHJlc3VsdCA9IHJlc3VsdCB8fCB0aGlzLl90YWdfc3RhY2sudHJ5X3BvcCgnb3B0Z3JvdXAnLCBbJ3NlbGVjdCddKTtcbiAgICAvL3Jlc3VsdCA9IHJlc3VsdCB8fCB0aGlzLl90YWdfc3RhY2sudHJ5X3BvcCgnb3B0aW9uJywgWydzZWxlY3QnXSk7XG5cbiAgfSBlbHNlIGlmIChwYXJzZXJfdG9rZW4udGFnX25hbWUgPT09ICdvcHRpb24nKSB7XG4gICAgLy8gQW4gb3B0aW9uIGVsZW1lbnTigJlzIGVuZCB0YWcgbWF5IGJlIG9taXR0ZWQgaWYgdGhlIG9wdGlvbiBlbGVtZW50IGlzIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IGFub3RoZXIgb3B0aW9uIGVsZW1lbnQsIG9yIGlmIGl0IGlzIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IGFuIG9wdGdyb3VwIGVsZW1lbnQsIG9yIGlmIHRoZXJlIGlzIG5vIG1vcmUgY29udGVudCBpbiB0aGUgcGFyZW50IGVsZW1lbnQuXG4gICAgcmVzdWx0ID0gcmVzdWx0IHx8IHRoaXMuX3RhZ19zdGFjay50cnlfcG9wKCdvcHRpb24nLCBbJ3NlbGVjdCcsICdkYXRhbGlzdCcsICdvcHRncm91cCddKTtcblxuICB9IGVsc2UgaWYgKHBhcnNlcl90b2tlbi50YWdfbmFtZSA9PT0gJ2NvbGdyb3VwJykge1xuICAgIC8vIERPTkU6IEEgY29sZ3JvdXAgZWxlbWVudOKAmXMgZW5kIHRhZyBtYXkgYmUgb21pdHRlZCBpZiB0aGUgY29sZ3JvdXAgZWxlbWVudCBpcyBub3QgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgYSBzcGFjZSBjaGFyYWN0ZXIgb3IgYSBjb21tZW50LlxuICAgIC8vIEEgY2FwdGlvbiBlbGVtZW50J3MgZW5kIHRhZyBtYXkgYmUgb21taXR0ZWQgaWYgYSBjb2xncm91cCwgdGhlYWQsIHRmb290LCB0Ym9keSwgb3IgdHIgZWxlbWVudCBpcyBzdGFydGVkLlxuICAgIHJlc3VsdCA9IHJlc3VsdCB8fCB0aGlzLl90YWdfc3RhY2sudHJ5X3BvcCgnY2FwdGlvbicsIFsndGFibGUnXSk7XG5cbiAgfSBlbHNlIGlmIChwYXJzZXJfdG9rZW4udGFnX25hbWUgPT09ICd0aGVhZCcpIHtcbiAgICAvLyBBIGNvbGdyb3VwIGVsZW1lbnQncyBlbmQgdGFnIG1heSBiZSBvbW1pdHRlZCBpZiBhIHRoZWFkLCB0Zm9vdCwgdGJvZHksIG9yIHRyIGVsZW1lbnQgaXMgc3RhcnRlZC5cbiAgICAvLyBBIGNhcHRpb24gZWxlbWVudCdzIGVuZCB0YWcgbWF5IGJlIG9tbWl0dGVkIGlmIGEgY29sZ3JvdXAsIHRoZWFkLCB0Zm9vdCwgdGJvZHksIG9yIHRyIGVsZW1lbnQgaXMgc3RhcnRlZC5cbiAgICByZXN1bHQgPSByZXN1bHQgfHwgdGhpcy5fdGFnX3N0YWNrLnRyeV9wb3AoJ2NhcHRpb24nLCBbJ3RhYmxlJ10pO1xuICAgIHJlc3VsdCA9IHJlc3VsdCB8fCB0aGlzLl90YWdfc3RhY2sudHJ5X3BvcCgnY29sZ3JvdXAnLCBbJ3RhYmxlJ10pO1xuXG4gICAgLy99IGVsc2UgaWYgKHBhcnNlcl90b2tlbi50YWdfbmFtZSA9PT0gJ2NhcHRpb24nKSB7XG4gICAgLy8gRE9ORTogQSBjYXB0aW9uIGVsZW1lbnTigJlzIGVuZCB0YWcgbWF5IGJlIG9taXR0ZWQgaWYgdGhlIGNhcHRpb24gZWxlbWVudCBpcyBub3QgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgYSBzcGFjZSBjaGFyYWN0ZXIgb3IgYSBjb21tZW50LlxuXG4gIH0gZWxzZSBpZiAocGFyc2VyX3Rva2VuLnRhZ19uYW1lID09PSAndGJvZHknIHx8IHBhcnNlcl90b2tlbi50YWdfbmFtZSA9PT0gJ3Rmb290Jykge1xuICAgIC8vIEEgdGhlYWQgZWxlbWVudOKAmXMgZW5kIHRhZyBtYXkgYmUgb21pdHRlZCBpZiB0aGUgdGhlYWQgZWxlbWVudCBpcyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSBhIHRib2R5IG9yIHRmb290IGVsZW1lbnQuXG4gICAgLy8gQSB0Ym9keSBlbGVtZW504oCZcyBlbmQgdGFnIG1heSBiZSBvbWl0dGVkIGlmIHRoZSB0Ym9keSBlbGVtZW50IGlzIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IGEgdGJvZHkgb3IgdGZvb3QgZWxlbWVudCwgb3IgaWYgdGhlcmUgaXMgbm8gbW9yZSBjb250ZW50IGluIHRoZSBwYXJlbnQgZWxlbWVudC5cbiAgICAvLyBBIGNvbGdyb3VwIGVsZW1lbnQncyBlbmQgdGFnIG1heSBiZSBvbW1pdHRlZCBpZiBhIHRoZWFkLCB0Zm9vdCwgdGJvZHksIG9yIHRyIGVsZW1lbnQgaXMgc3RhcnRlZC5cbiAgICAvLyBBIGNhcHRpb24gZWxlbWVudCdzIGVuZCB0YWcgbWF5IGJlIG9tbWl0dGVkIGlmIGEgY29sZ3JvdXAsIHRoZWFkLCB0Zm9vdCwgdGJvZHksIG9yIHRyIGVsZW1lbnQgaXMgc3RhcnRlZC5cbiAgICByZXN1bHQgPSByZXN1bHQgfHwgdGhpcy5fdGFnX3N0YWNrLnRyeV9wb3AoJ2NhcHRpb24nLCBbJ3RhYmxlJ10pO1xuICAgIHJlc3VsdCA9IHJlc3VsdCB8fCB0aGlzLl90YWdfc3RhY2sudHJ5X3BvcCgnY29sZ3JvdXAnLCBbJ3RhYmxlJ10pO1xuICAgIHJlc3VsdCA9IHJlc3VsdCB8fCB0aGlzLl90YWdfc3RhY2sudHJ5X3BvcCgndGhlYWQnLCBbJ3RhYmxlJ10pO1xuICAgIHJlc3VsdCA9IHJlc3VsdCB8fCB0aGlzLl90YWdfc3RhY2sudHJ5X3BvcCgndGJvZHknLCBbJ3RhYmxlJ10pO1xuXG4gICAgLy99IGVsc2UgaWYgKHBhcnNlcl90b2tlbi50YWdfbmFtZSA9PT0gJ3Rmb290Jykge1xuICAgIC8vIERPTkU6IEEgdGZvb3QgZWxlbWVudOKAmXMgZW5kIHRhZyBtYXkgYmUgb21pdHRlZCBpZiB0aGVyZSBpcyBubyBtb3JlIGNvbnRlbnQgaW4gdGhlIHBhcmVudCBlbGVtZW50LlxuXG4gIH0gZWxzZSBpZiAocGFyc2VyX3Rva2VuLnRhZ19uYW1lID09PSAndHInKSB7XG4gICAgLy8gQSB0ciBlbGVtZW504oCZcyBlbmQgdGFnIG1heSBiZSBvbWl0dGVkIGlmIHRoZSB0ciBlbGVtZW50IGlzIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IGFub3RoZXIgdHIgZWxlbWVudCwgb3IgaWYgdGhlcmUgaXMgbm8gbW9yZSBjb250ZW50IGluIHRoZSBwYXJlbnQgZWxlbWVudC5cbiAgICAvLyBBIGNvbGdyb3VwIGVsZW1lbnQncyBlbmQgdGFnIG1heSBiZSBvbW1pdHRlZCBpZiBhIHRoZWFkLCB0Zm9vdCwgdGJvZHksIG9yIHRyIGVsZW1lbnQgaXMgc3RhcnRlZC5cbiAgICAvLyBBIGNhcHRpb24gZWxlbWVudCdzIGVuZCB0YWcgbWF5IGJlIG9tbWl0dGVkIGlmIGEgY29sZ3JvdXAsIHRoZWFkLCB0Zm9vdCwgdGJvZHksIG9yIHRyIGVsZW1lbnQgaXMgc3RhcnRlZC5cbiAgICByZXN1bHQgPSByZXN1bHQgfHwgdGhpcy5fdGFnX3N0YWNrLnRyeV9wb3AoJ2NhcHRpb24nLCBbJ3RhYmxlJ10pO1xuICAgIHJlc3VsdCA9IHJlc3VsdCB8fCB0aGlzLl90YWdfc3RhY2sudHJ5X3BvcCgnY29sZ3JvdXAnLCBbJ3RhYmxlJ10pO1xuICAgIHJlc3VsdCA9IHJlc3VsdCB8fCB0aGlzLl90YWdfc3RhY2sudHJ5X3BvcCgndHInLCBbJ3RhYmxlJywgJ3RoZWFkJywgJ3Rib2R5JywgJ3Rmb290J10pO1xuXG4gIH0gZWxzZSBpZiAocGFyc2VyX3Rva2VuLnRhZ19uYW1lID09PSAndGgnIHx8IHBhcnNlcl90b2tlbi50YWdfbmFtZSA9PT0gJ3RkJykge1xuICAgIC8vIEEgdGQgZWxlbWVudOKAmXMgZW5kIHRhZyBtYXkgYmUgb21pdHRlZCBpZiB0aGUgdGQgZWxlbWVudCBpcyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSBhIHRkIG9yIHRoIGVsZW1lbnQsIG9yIGlmIHRoZXJlIGlzIG5vIG1vcmUgY29udGVudCBpbiB0aGUgcGFyZW50IGVsZW1lbnQuXG4gICAgLy8gQSB0aCBlbGVtZW504oCZcyBlbmQgdGFnIG1heSBiZSBvbWl0dGVkIGlmIHRoZSB0aCBlbGVtZW50IGlzIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IGEgdGQgb3IgdGggZWxlbWVudCwgb3IgaWYgdGhlcmUgaXMgbm8gbW9yZSBjb250ZW50IGluIHRoZSBwYXJlbnQgZWxlbWVudC5cbiAgICByZXN1bHQgPSByZXN1bHQgfHwgdGhpcy5fdGFnX3N0YWNrLnRyeV9wb3AoJ3RkJywgWyd0YWJsZScsICd0aGVhZCcsICd0Ym9keScsICd0Zm9vdCcsICd0ciddKTtcbiAgICByZXN1bHQgPSByZXN1bHQgfHwgdGhpcy5fdGFnX3N0YWNrLnRyeV9wb3AoJ3RoJywgWyd0YWJsZScsICd0aGVhZCcsICd0Ym9keScsICd0Zm9vdCcsICd0ciddKTtcbiAgfVxuXG4gIC8vIFN0YXJ0IGVsZW1lbnQgb21pc3Npb24gbm90IGhhbmRsZWQgY3VycmVudGx5XG4gIC8vIEEgaGVhZCBlbGVtZW504oCZcyBzdGFydCB0YWcgbWF5IGJlIG9taXR0ZWQgaWYgdGhlIGVsZW1lbnQgaXMgZW1wdHksIG9yIGlmIHRoZSBmaXJzdCB0aGluZyBpbnNpZGUgdGhlIGhlYWQgZWxlbWVudCBpcyBhbiBlbGVtZW50LlxuICAvLyBBIHRib2R5IGVsZW1lbnTigJlzIHN0YXJ0IHRhZyBtYXkgYmUgb21pdHRlZCBpZiB0aGUgZmlyc3QgdGhpbmcgaW5zaWRlIHRoZSB0Ym9keSBlbGVtZW50IGlzIGEgdHIgZWxlbWVudCwgYW5kIGlmIHRoZSBlbGVtZW50IGlzIG5vdCBpbW1lZGlhdGVseSBwcmVjZWRlZCBieSBhIHRib2R5LCB0aGVhZCwgb3IgdGZvb3QgZWxlbWVudCB3aG9zZSBlbmQgdGFnIGhhcyBiZWVuIG9taXR0ZWQuIChJdCBjYW7igJl0IGJlIG9taXR0ZWQgaWYgdGhlIGVsZW1lbnQgaXMgZW1wdHkuKVxuICAvLyBBIGNvbGdyb3VwIGVsZW1lbnTigJlzIHN0YXJ0IHRhZyBtYXkgYmUgb21pdHRlZCBpZiB0aGUgZmlyc3QgdGhpbmcgaW5zaWRlIHRoZSBjb2xncm91cCBlbGVtZW50IGlzIGEgY29sIGVsZW1lbnQsIGFuZCBpZiB0aGUgZWxlbWVudCBpcyBub3QgaW1tZWRpYXRlbHkgcHJlY2VkZWQgYnkgYW5vdGhlciBjb2xncm91cCBlbGVtZW50IHdob3NlIGVuZCB0YWcgaGFzIGJlZW4gb21pdHRlZC4gKEl0IGNhbuKAmXQgYmUgb21pdHRlZCBpZiB0aGUgZWxlbWVudCBpcyBlbXB0eS4pXG5cbiAgLy8gRml4IHVwIHRoZSBwYXJlbnQgb2YgdGhlIHBhcnNlciB0b2tlblxuICBwYXJzZXJfdG9rZW4ucGFyZW50ID0gdGhpcy5fdGFnX3N0YWNrLmdldF9wYXJzZXJfdG9rZW4oKTtcblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxubW9kdWxlLmV4cG9ydHMuQmVhdXRpZmllciA9IEJlYXV0aWZpZXI7XG5cblxuLyoqKi8gfSksXG4vKiAyMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qanNoaW50IG5vZGU6dHJ1ZSAqL1xuLypcblxuICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxOCBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgU09GVFdBUkUuXG4qL1xuXG5cblxudmFyIEJhc2VPcHRpb25zID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KS5PcHRpb25zO1xuXG5mdW5jdGlvbiBPcHRpb25zKG9wdGlvbnMpIHtcbiAgQmFzZU9wdGlvbnMuY2FsbCh0aGlzLCBvcHRpb25zLCAnaHRtbCcpO1xuICBpZiAodGhpcy50ZW1wbGF0aW5nLmxlbmd0aCA9PT0gMSAmJiB0aGlzLnRlbXBsYXRpbmdbMF0gPT09ICdhdXRvJykge1xuICAgIHRoaXMudGVtcGxhdGluZyA9IFsnZGphbmdvJywgJ2VyYicsICdoYW5kbGViYXJzJywgJ3BocCddO1xuICB9XG5cbiAgdGhpcy5pbmRlbnRfaW5uZXJfaHRtbCA9IHRoaXMuX2dldF9ib29sZWFuKCdpbmRlbnRfaW5uZXJfaHRtbCcpO1xuICB0aGlzLmluZGVudF9ib2R5X2lubmVyX2h0bWwgPSB0aGlzLl9nZXRfYm9vbGVhbignaW5kZW50X2JvZHlfaW5uZXJfaHRtbCcsIHRydWUpO1xuICB0aGlzLmluZGVudF9oZWFkX2lubmVyX2h0bWwgPSB0aGlzLl9nZXRfYm9vbGVhbignaW5kZW50X2hlYWRfaW5uZXJfaHRtbCcsIHRydWUpO1xuXG4gIHRoaXMuaW5kZW50X2hhbmRsZWJhcnMgPSB0aGlzLl9nZXRfYm9vbGVhbignaW5kZW50X2hhbmRsZWJhcnMnLCB0cnVlKTtcbiAgdGhpcy53cmFwX2F0dHJpYnV0ZXMgPSB0aGlzLl9nZXRfc2VsZWN0aW9uKCd3cmFwX2F0dHJpYnV0ZXMnLFxuICAgIFsnYXV0bycsICdmb3JjZScsICdmb3JjZS1hbGlnbmVkJywgJ2ZvcmNlLWV4cGFuZC1tdWx0aWxpbmUnLCAnYWxpZ25lZC1tdWx0aXBsZScsICdwcmVzZXJ2ZScsICdwcmVzZXJ2ZS1hbGlnbmVkJ10pO1xuICB0aGlzLndyYXBfYXR0cmlidXRlc19pbmRlbnRfc2l6ZSA9IHRoaXMuX2dldF9udW1iZXIoJ3dyYXBfYXR0cmlidXRlc19pbmRlbnRfc2l6ZScsIHRoaXMuaW5kZW50X3NpemUpO1xuICB0aGlzLmV4dHJhX2xpbmVycyA9IHRoaXMuX2dldF9hcnJheSgnZXh0cmFfbGluZXJzJywgWydoZWFkJywgJ2JvZHknLCAnL2h0bWwnXSk7XG5cbiAgLy8gQmxvY2sgdnMgaW5saW5lIGVsZW1lbnRzXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvQmxvY2stbGV2ZWxfZWxlbWVudHNcbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9JbmxpbmVfZWxlbWVudHNcbiAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2RvbS5odG1sI3BocmFzaW5nLWNvbnRlbnRcbiAgdGhpcy5pbmxpbmUgPSB0aGlzLl9nZXRfYXJyYXkoJ2lubGluZScsIFtcbiAgICAnYScsICdhYmJyJywgJ2FyZWEnLCAnYXVkaW8nLCAnYicsICdiZGknLCAnYmRvJywgJ2JyJywgJ2J1dHRvbicsICdjYW52YXMnLCAnY2l0ZScsXG4gICAgJ2NvZGUnLCAnZGF0YScsICdkYXRhbGlzdCcsICdkZWwnLCAnZGZuJywgJ2VtJywgJ2VtYmVkJywgJ2knLCAnaWZyYW1lJywgJ2ltZycsXG4gICAgJ2lucHV0JywgJ2lucycsICdrYmQnLCAna2V5Z2VuJywgJ2xhYmVsJywgJ21hcCcsICdtYXJrJywgJ21hdGgnLCAnbWV0ZXInLCAnbm9zY3JpcHQnLFxuICAgICdvYmplY3QnLCAnb3V0cHV0JywgJ3Byb2dyZXNzJywgJ3EnLCAncnVieScsICdzJywgJ3NhbXAnLCAvKiAnc2NyaXB0JywgKi8gJ3NlbGVjdCcsICdzbWFsbCcsXG4gICAgJ3NwYW4nLCAnc3Ryb25nJywgJ3N1YicsICdzdXAnLCAnc3ZnJywgJ3RlbXBsYXRlJywgJ3RleHRhcmVhJywgJ3RpbWUnLCAndScsICd2YXInLFxuICAgICd2aWRlbycsICd3YnInLCAndGV4dCcsXG4gICAgLy8gb2Jzb2xldGUgaW5saW5lIHRhZ3NcbiAgICAnYWNyb255bScsICdiaWcnLCAnc3RyaWtlJywgJ3R0J1xuICBdKTtcbiAgdGhpcy52b2lkX2VsZW1lbnRzID0gdGhpcy5fZ2V0X2FycmF5KCd2b2lkX2VsZW1lbnRzJywgW1xuICAgIC8vIEhUTE0gdm9pZCBlbGVtZW50cyAtIGFrYSBzZWxmLWNsb3NpbmcgdGFncyAtIGFrYSBzaW5nbGV0b25zXG4gICAgLy8gaHR0cHM6Ly93d3cudzMub3JnL2h0bWwvd2cvZHJhZnRzL2h0bWwvbWFzdGVyL3N5bnRheC5odG1sI3ZvaWQtZWxlbWVudHNcbiAgICAnYXJlYScsICdiYXNlJywgJ2JyJywgJ2NvbCcsICdlbWJlZCcsICdocicsICdpbWcnLCAnaW5wdXQnLCAna2V5Z2VuJyxcbiAgICAnbGluaycsICdtZW51aXRlbScsICdtZXRhJywgJ3BhcmFtJywgJ3NvdXJjZScsICd0cmFjaycsICd3YnInLFxuICAgIC8vIE5PVEU6IE9wdGlvbmFsIHRhZ3MgYXJlIHRvbyBjb21wbGV4IGZvciBhIHNpbXBsZSBsaXN0XG4gICAgLy8gdGhleSBhcmUgaGFyZCBjb2RlZCBpbiBfZG9fb3B0aW9uYWxfZW5kX2VsZW1lbnRcblxuICAgIC8vIERvY3R5cGUgYW5kIHhtbCBlbGVtZW50c1xuICAgICchZG9jdHlwZScsICc/eG1sJyxcblxuICAgIC8vIG9ic29sZXRlIHRhZ3NcbiAgICAvLyBiYXNlZm9udDogaHR0cHM6Ly93d3cuY29tcHV0ZXJob3BlLmNvbS9qYXJnb24vaC9odG1sLWJhc2Vmb250LXRhZy5odG1cbiAgICAvLyBpc25kZXg6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvRWxlbWVudC9pc2luZGV4XG4gICAgJ2Jhc2Vmb250JywgJ2lzaW5kZXgnXG4gIF0pO1xuICB0aGlzLnVuZm9ybWF0dGVkID0gdGhpcy5fZ2V0X2FycmF5KCd1bmZvcm1hdHRlZCcsIFtdKTtcbiAgdGhpcy5jb250ZW50X3VuZm9ybWF0dGVkID0gdGhpcy5fZ2V0X2FycmF5KCdjb250ZW50X3VuZm9ybWF0dGVkJywgW1xuICAgICdwcmUnLCAndGV4dGFyZWEnXG4gIF0pO1xuICB0aGlzLnVuZm9ybWF0dGVkX2NvbnRlbnRfZGVsaW1pdGVyID0gdGhpcy5fZ2V0X2NoYXJhY3RlcnMoJ3VuZm9ybWF0dGVkX2NvbnRlbnRfZGVsaW1pdGVyJyk7XG4gIHRoaXMuaW5kZW50X3NjcmlwdHMgPSB0aGlzLl9nZXRfc2VsZWN0aW9uKCdpbmRlbnRfc2NyaXB0cycsIFsnbm9ybWFsJywgJ2tlZXAnLCAnc2VwYXJhdGUnXSk7XG5cbn1cbk9wdGlvbnMucHJvdG90eXBlID0gbmV3IEJhc2VPcHRpb25zKCk7XG5cblxuXG5tb2R1bGUuZXhwb3J0cy5PcHRpb25zID0gT3B0aW9ucztcblxuXG4vKioqLyB9KSxcbi8qIDIxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLypqc2hpbnQgbm9kZTp0cnVlICovXG4vKlxuXG4gIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4gIENvcHlyaWdodCAoYykgMjAwNy0yMDE4IEVpbmFyIExpZWxtYW5pcywgTGlhbSBOZXdtYW4sIGFuZCBjb250cmlidXRvcnMuXG5cbiAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICBTT0ZUV0FSRS5cbiovXG5cblxuXG52YXIgQmFzZVRva2VuaXplciA9IF9fd2VicGFja19yZXF1aXJlX18oOSkuVG9rZW5pemVyO1xudmFyIEJBU0VUT0tFTiA9IF9fd2VicGFja19yZXF1aXJlX18oOSkuVE9LRU47XG52YXIgRGlyZWN0aXZlcyA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpLkRpcmVjdGl2ZXM7XG52YXIgVGVtcGxhdGFibGVQYXR0ZXJuID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCkuVGVtcGxhdGFibGVQYXR0ZXJuO1xudmFyIFBhdHRlcm4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKS5QYXR0ZXJuO1xuXG52YXIgVE9LRU4gPSB7XG4gIFRBR19PUEVOOiAnVEtfVEFHX09QRU4nLFxuICBUQUdfQ0xPU0U6ICdUS19UQUdfQ0xPU0UnLFxuICBBVFRSSUJVVEU6ICdUS19BVFRSSUJVVEUnLFxuICBFUVVBTFM6ICdUS19FUVVBTFMnLFxuICBWQUxVRTogJ1RLX1ZBTFVFJyxcbiAgQ09NTUVOVDogJ1RLX0NPTU1FTlQnLFxuICBURVhUOiAnVEtfVEVYVCcsXG4gIFVOS05PV046ICdUS19VTktOT1dOJyxcbiAgU1RBUlQ6IEJBU0VUT0tFTi5TVEFSVCxcbiAgUkFXOiBCQVNFVE9LRU4uUkFXLFxuICBFT0Y6IEJBU0VUT0tFTi5FT0Zcbn07XG5cbnZhciBkaXJlY3RpdmVzX2NvcmUgPSBuZXcgRGlyZWN0aXZlcygvPFxcIS0tLywgLy0tPi8pO1xuXG52YXIgVG9rZW5pemVyID0gZnVuY3Rpb24oaW5wdXRfc3RyaW5nLCBvcHRpb25zKSB7XG4gIEJhc2VUb2tlbml6ZXIuY2FsbCh0aGlzLCBpbnB1dF9zdHJpbmcsIG9wdGlvbnMpO1xuICB0aGlzLl9jdXJyZW50X3RhZ19uYW1lID0gJyc7XG5cbiAgLy8gV29yZHMgZW5kIGF0IHdoaXRlc3BhY2Ugb3Igd2hlbiBhIHRhZyBzdGFydHNcbiAgLy8gaWYgd2UgYXJlIGluZGVudGluZyBoYW5kbGViYXJzLCB0aGV5IGFyZSBjb25zaWRlcmVkIHRhZ3NcbiAgdmFyIHRlbXBsYXRhYmxlX3JlYWRlciA9IG5ldyBUZW1wbGF0YWJsZVBhdHRlcm4odGhpcy5faW5wdXQpLnJlYWRfb3B0aW9ucyh0aGlzLl9vcHRpb25zKTtcbiAgdmFyIHBhdHRlcm5fcmVhZGVyID0gbmV3IFBhdHRlcm4odGhpcy5faW5wdXQpO1xuXG4gIHRoaXMuX19wYXR0ZXJucyA9IHtcbiAgICB3b3JkOiB0ZW1wbGF0YWJsZV9yZWFkZXIudW50aWwoL1tcXG5cXHJcXHQgPF0vKSxcbiAgICBzaW5nbGVfcXVvdGU6IHRlbXBsYXRhYmxlX3JlYWRlci51bnRpbF9hZnRlcigvJy8pLFxuICAgIGRvdWJsZV9xdW90ZTogdGVtcGxhdGFibGVfcmVhZGVyLnVudGlsX2FmdGVyKC9cIi8pLFxuICAgIGF0dHJpYnV0ZTogdGVtcGxhdGFibGVfcmVhZGVyLnVudGlsKC9bXFxuXFxyXFx0ID0+XXxcXC8+LyksXG4gICAgZWxlbWVudF9uYW1lOiB0ZW1wbGF0YWJsZV9yZWFkZXIudW50aWwoL1tcXG5cXHJcXHQgPlxcL10vKSxcblxuICAgIGhhbmRsZWJhcnNfY29tbWVudDogcGF0dGVybl9yZWFkZXIuc3RhcnRpbmdfd2l0aCgve3shLS0vKS51bnRpbF9hZnRlcigvLS19fS8pLFxuICAgIGhhbmRsZWJhcnM6IHBhdHRlcm5fcmVhZGVyLnN0YXJ0aW5nX3dpdGgoL3t7LykudW50aWxfYWZ0ZXIoL319LyksXG4gICAgaGFuZGxlYmFyc19vcGVuOiBwYXR0ZXJuX3JlYWRlci51bnRpbCgvW1xcblxcclxcdCB9XS8pLFxuICAgIGhhbmRsZWJhcnNfcmF3X2Nsb3NlOiBwYXR0ZXJuX3JlYWRlci51bnRpbCgvfX0vKSxcbiAgICBjb21tZW50OiBwYXR0ZXJuX3JlYWRlci5zdGFydGluZ193aXRoKC88IS0tLykudW50aWxfYWZ0ZXIoLy0tPi8pLFxuICAgIGNkYXRhOiBwYXR0ZXJuX3JlYWRlci5zdGFydGluZ193aXRoKC88IVxcW0NEQVRBXFxbLykudW50aWxfYWZ0ZXIoL11dPi8pLFxuICAgIC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbmRpdGlvbmFsX2NvbW1lbnRcbiAgICBjb25kaXRpb25hbF9jb21tZW50OiBwYXR0ZXJuX3JlYWRlci5zdGFydGluZ193aXRoKC88IVxcWy8pLnVudGlsX2FmdGVyKC9dPi8pLFxuICAgIHByb2Nlc3Npbmc6IHBhdHRlcm5fcmVhZGVyLnN0YXJ0aW5nX3dpdGgoLzxcXD8vKS51bnRpbF9hZnRlcigvXFw/Pi8pXG4gIH07XG5cbiAgaWYgKHRoaXMuX29wdGlvbnMuaW5kZW50X2hhbmRsZWJhcnMpIHtcbiAgICB0aGlzLl9fcGF0dGVybnMud29yZCA9IHRoaXMuX19wYXR0ZXJucy53b3JkLmV4Y2x1ZGUoJ2hhbmRsZWJhcnMnKTtcbiAgfVxuXG4gIHRoaXMuX3VuZm9ybWF0dGVkX2NvbnRlbnRfZGVsaW1pdGVyID0gbnVsbDtcblxuICBpZiAodGhpcy5fb3B0aW9ucy51bmZvcm1hdHRlZF9jb250ZW50X2RlbGltaXRlcikge1xuICAgIHZhciBsaXRlcmFsX3JlZ2V4cCA9IHRoaXMuX2lucHV0LmdldF9saXRlcmFsX3JlZ2V4cCh0aGlzLl9vcHRpb25zLnVuZm9ybWF0dGVkX2NvbnRlbnRfZGVsaW1pdGVyKTtcbiAgICB0aGlzLl9fcGF0dGVybnMudW5mb3JtYXR0ZWRfY29udGVudF9kZWxpbWl0ZXIgPVxuICAgICAgcGF0dGVybl9yZWFkZXIubWF0Y2hpbmcobGl0ZXJhbF9yZWdleHApXG4gICAgICAudW50aWxfYWZ0ZXIobGl0ZXJhbF9yZWdleHApO1xuICB9XG59O1xuVG9rZW5pemVyLnByb3RvdHlwZSA9IG5ldyBCYXNlVG9rZW5pemVyKCk7XG5cblRva2VuaXplci5wcm90b3R5cGUuX2lzX2NvbW1lbnQgPSBmdW5jdGlvbihjdXJyZW50X3Rva2VuKSB7IC8vIGpzaGludCB1bnVzZWQ6ZmFsc2VcbiAgcmV0dXJuIGZhbHNlOyAvL2N1cnJlbnRfdG9rZW4udHlwZSA9PT0gVE9LRU4uQ09NTUVOVCB8fCBjdXJyZW50X3Rva2VuLnR5cGUgPT09IFRPS0VOLlVOS05PV047XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9pc19vcGVuaW5nID0gZnVuY3Rpb24oY3VycmVudF90b2tlbikge1xuICByZXR1cm4gY3VycmVudF90b2tlbi50eXBlID09PSBUT0tFTi5UQUdfT1BFTjtcbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX2lzX2Nsb3NpbmcgPSBmdW5jdGlvbihjdXJyZW50X3Rva2VuLCBvcGVuX3Rva2VuKSB7XG4gIHJldHVybiBjdXJyZW50X3Rva2VuLnR5cGUgPT09IFRPS0VOLlRBR19DTE9TRSAmJlxuICAgIChvcGVuX3Rva2VuICYmIChcbiAgICAgICgoY3VycmVudF90b2tlbi50ZXh0ID09PSAnPicgfHwgY3VycmVudF90b2tlbi50ZXh0ID09PSAnLz4nKSAmJiBvcGVuX3Rva2VuLnRleHRbMF0gPT09ICc8JykgfHxcbiAgICAgIChjdXJyZW50X3Rva2VuLnRleHQgPT09ICd9fScgJiYgb3Blbl90b2tlbi50ZXh0WzBdID09PSAneycgJiYgb3Blbl90b2tlbi50ZXh0WzFdID09PSAneycpKSk7XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9yZXNldCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9jdXJyZW50X3RhZ19uYW1lID0gJyc7XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9nZXRfbmV4dF90b2tlbiA9IGZ1bmN0aW9uKHByZXZpb3VzX3Rva2VuLCBvcGVuX3Rva2VuKSB7IC8vIGpzaGludCB1bnVzZWQ6ZmFsc2VcbiAgdmFyIHRva2VuID0gbnVsbDtcbiAgdGhpcy5fcmVhZFdoaXRlc3BhY2UoKTtcbiAgdmFyIGMgPSB0aGlzLl9pbnB1dC5wZWVrKCk7XG5cbiAgaWYgKGMgPT09IG51bGwpIHtcbiAgICByZXR1cm4gdGhpcy5fY3JlYXRlX3Rva2VuKFRPS0VOLkVPRiwgJycpO1xuICB9XG5cbiAgdG9rZW4gPSB0b2tlbiB8fCB0aGlzLl9yZWFkX29wZW5faGFuZGxlYmFycyhjLCBvcGVuX3Rva2VuKTtcbiAgdG9rZW4gPSB0b2tlbiB8fCB0aGlzLl9yZWFkX2F0dHJpYnV0ZShjLCBwcmV2aW91c190b2tlbiwgb3Blbl90b2tlbik7XG4gIHRva2VuID0gdG9rZW4gfHwgdGhpcy5fcmVhZF9jbG9zZShjLCBvcGVuX3Rva2VuKTtcbiAgdG9rZW4gPSB0b2tlbiB8fCB0aGlzLl9yZWFkX3Jhd19jb250ZW50KGMsIHByZXZpb3VzX3Rva2VuLCBvcGVuX3Rva2VuKTtcbiAgdG9rZW4gPSB0b2tlbiB8fCB0aGlzLl9yZWFkX2NvbnRlbnRfd29yZChjKTtcbiAgdG9rZW4gPSB0b2tlbiB8fCB0aGlzLl9yZWFkX2NvbW1lbnRfb3JfY2RhdGEoYyk7XG4gIHRva2VuID0gdG9rZW4gfHwgdGhpcy5fcmVhZF9wcm9jZXNzaW5nKGMpO1xuICB0b2tlbiA9IHRva2VuIHx8IHRoaXMuX3JlYWRfb3BlbihjLCBvcGVuX3Rva2VuKTtcbiAgdG9rZW4gPSB0b2tlbiB8fCB0aGlzLl9jcmVhdGVfdG9rZW4oVE9LRU4uVU5LTk9XTiwgdGhpcy5faW5wdXQubmV4dCgpKTtcblxuICByZXR1cm4gdG9rZW47XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9yZWFkX2NvbW1lbnRfb3JfY2RhdGEgPSBmdW5jdGlvbihjKSB7IC8vIGpzaGludCB1bnVzZWQ6ZmFsc2VcbiAgdmFyIHRva2VuID0gbnVsbDtcbiAgdmFyIHJlc3VsdGluZ19zdHJpbmcgPSBudWxsO1xuICB2YXIgZGlyZWN0aXZlcyA9IG51bGw7XG5cbiAgaWYgKGMgPT09ICc8Jykge1xuICAgIHZhciBwZWVrMSA9IHRoaXMuX2lucHV0LnBlZWsoMSk7XG4gICAgLy8gV2UgdHJlYXQgYWxsIGNvbW1lbnRzIGFzIGxpdGVyYWxzLCBldmVuIG1vcmUgdGhhbiBwcmVmb3JtYXR0ZWQgdGFnc1xuICAgIC8vIHdlIG9ubHkgbG9vayBmb3IgdGhlIGFwcHJvcHJpYXRlIGNsb3NpbmcgbWFya2VyXG4gICAgaWYgKHBlZWsxID09PSAnIScpIHtcbiAgICAgIHJlc3VsdGluZ19zdHJpbmcgPSB0aGlzLl9fcGF0dGVybnMuY29tbWVudC5yZWFkKCk7XG5cbiAgICAgIC8vIG9ubHkgcHJvY2VzcyBkaXJlY3RpdmUgb24gaHRtbCBjb21tZW50c1xuICAgICAgaWYgKHJlc3VsdGluZ19zdHJpbmcpIHtcbiAgICAgICAgZGlyZWN0aXZlcyA9IGRpcmVjdGl2ZXNfY29yZS5nZXRfZGlyZWN0aXZlcyhyZXN1bHRpbmdfc3RyaW5nKTtcbiAgICAgICAgaWYgKGRpcmVjdGl2ZXMgJiYgZGlyZWN0aXZlcy5pZ25vcmUgPT09ICdzdGFydCcpIHtcbiAgICAgICAgICByZXN1bHRpbmdfc3RyaW5nICs9IGRpcmVjdGl2ZXNfY29yZS5yZWFkSWdub3JlZCh0aGlzLl9pbnB1dCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdGluZ19zdHJpbmcgPSB0aGlzLl9fcGF0dGVybnMuY2RhdGEucmVhZCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChyZXN1bHRpbmdfc3RyaW5nKSB7XG4gICAgICB0b2tlbiA9IHRoaXMuX2NyZWF0ZV90b2tlbihUT0tFTi5DT01NRU5ULCByZXN1bHRpbmdfc3RyaW5nKTtcbiAgICAgIHRva2VuLmRpcmVjdGl2ZXMgPSBkaXJlY3RpdmVzO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0b2tlbjtcbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX3JlYWRfcHJvY2Vzc2luZyA9IGZ1bmN0aW9uKGMpIHsgLy8ganNoaW50IHVudXNlZDpmYWxzZVxuICB2YXIgdG9rZW4gPSBudWxsO1xuICB2YXIgcmVzdWx0aW5nX3N0cmluZyA9IG51bGw7XG4gIHZhciBkaXJlY3RpdmVzID0gbnVsbDtcblxuICBpZiAoYyA9PT0gJzwnKSB7XG4gICAgdmFyIHBlZWsxID0gdGhpcy5faW5wdXQucGVlaygxKTtcbiAgICBpZiAocGVlazEgPT09ICchJyB8fCBwZWVrMSA9PT0gJz8nKSB7XG4gICAgICByZXN1bHRpbmdfc3RyaW5nID0gdGhpcy5fX3BhdHRlcm5zLmNvbmRpdGlvbmFsX2NvbW1lbnQucmVhZCgpO1xuICAgICAgcmVzdWx0aW5nX3N0cmluZyA9IHJlc3VsdGluZ19zdHJpbmcgfHwgdGhpcy5fX3BhdHRlcm5zLnByb2Nlc3NpbmcucmVhZCgpO1xuICAgIH1cblxuICAgIGlmIChyZXN1bHRpbmdfc3RyaW5nKSB7XG4gICAgICB0b2tlbiA9IHRoaXMuX2NyZWF0ZV90b2tlbihUT0tFTi5DT01NRU5ULCByZXN1bHRpbmdfc3RyaW5nKTtcbiAgICAgIHRva2VuLmRpcmVjdGl2ZXMgPSBkaXJlY3RpdmVzO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0b2tlbjtcbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX3JlYWRfb3BlbiA9IGZ1bmN0aW9uKGMsIG9wZW5fdG9rZW4pIHtcbiAgdmFyIHJlc3VsdGluZ19zdHJpbmcgPSBudWxsO1xuICB2YXIgdG9rZW4gPSBudWxsO1xuICBpZiAoIW9wZW5fdG9rZW4pIHtcbiAgICBpZiAoYyA9PT0gJzwnKSB7XG5cbiAgICAgIHJlc3VsdGluZ19zdHJpbmcgPSB0aGlzLl9pbnB1dC5uZXh0KCk7XG4gICAgICBpZiAodGhpcy5faW5wdXQucGVlaygpID09PSAnLycpIHtcbiAgICAgICAgcmVzdWx0aW5nX3N0cmluZyArPSB0aGlzLl9pbnB1dC5uZXh0KCk7XG4gICAgICB9XG4gICAgICByZXN1bHRpbmdfc3RyaW5nICs9IHRoaXMuX19wYXR0ZXJucy5lbGVtZW50X25hbWUucmVhZCgpO1xuICAgICAgdG9rZW4gPSB0aGlzLl9jcmVhdGVfdG9rZW4oVE9LRU4uVEFHX09QRU4sIHJlc3VsdGluZ19zdHJpbmcpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdG9rZW47XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9yZWFkX29wZW5faGFuZGxlYmFycyA9IGZ1bmN0aW9uKGMsIG9wZW5fdG9rZW4pIHtcbiAgdmFyIHJlc3VsdGluZ19zdHJpbmcgPSBudWxsO1xuICB2YXIgdG9rZW4gPSBudWxsO1xuICBpZiAoIW9wZW5fdG9rZW4pIHtcbiAgICBpZiAodGhpcy5fb3B0aW9ucy5pbmRlbnRfaGFuZGxlYmFycyAmJiBjID09PSAneycgJiYgdGhpcy5faW5wdXQucGVlaygxKSA9PT0gJ3snKSB7XG4gICAgICBpZiAodGhpcy5faW5wdXQucGVlaygyKSA9PT0gJyEnKSB7XG4gICAgICAgIHJlc3VsdGluZ19zdHJpbmcgPSB0aGlzLl9fcGF0dGVybnMuaGFuZGxlYmFyc19jb21tZW50LnJlYWQoKTtcbiAgICAgICAgcmVzdWx0aW5nX3N0cmluZyA9IHJlc3VsdGluZ19zdHJpbmcgfHwgdGhpcy5fX3BhdHRlcm5zLmhhbmRsZWJhcnMucmVhZCgpO1xuICAgICAgICB0b2tlbiA9IHRoaXMuX2NyZWF0ZV90b2tlbihUT0tFTi5DT01NRU5ULCByZXN1bHRpbmdfc3RyaW5nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdGluZ19zdHJpbmcgPSB0aGlzLl9fcGF0dGVybnMuaGFuZGxlYmFyc19vcGVuLnJlYWQoKTtcbiAgICAgICAgdG9rZW4gPSB0aGlzLl9jcmVhdGVfdG9rZW4oVE9LRU4uVEFHX09QRU4sIHJlc3VsdGluZ19zdHJpbmcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdG9rZW47XG59O1xuXG5cblRva2VuaXplci5wcm90b3R5cGUuX3JlYWRfY2xvc2UgPSBmdW5jdGlvbihjLCBvcGVuX3Rva2VuKSB7XG4gIHZhciByZXN1bHRpbmdfc3RyaW5nID0gbnVsbDtcbiAgdmFyIHRva2VuID0gbnVsbDtcbiAgaWYgKG9wZW5fdG9rZW4pIHtcbiAgICBpZiAob3Blbl90b2tlbi50ZXh0WzBdID09PSAnPCcgJiYgKGMgPT09ICc+JyB8fCAoYyA9PT0gJy8nICYmIHRoaXMuX2lucHV0LnBlZWsoMSkgPT09ICc+JykpKSB7XG4gICAgICByZXN1bHRpbmdfc3RyaW5nID0gdGhpcy5faW5wdXQubmV4dCgpO1xuICAgICAgaWYgKGMgPT09ICcvJykgeyAvLyAgZm9yIGNsb3NlIHRhZyBcIi8+XCJcbiAgICAgICAgcmVzdWx0aW5nX3N0cmluZyArPSB0aGlzLl9pbnB1dC5uZXh0KCk7XG4gICAgICB9XG4gICAgICB0b2tlbiA9IHRoaXMuX2NyZWF0ZV90b2tlbihUT0tFTi5UQUdfQ0xPU0UsIHJlc3VsdGluZ19zdHJpbmcpO1xuICAgIH0gZWxzZSBpZiAob3Blbl90b2tlbi50ZXh0WzBdID09PSAneycgJiYgYyA9PT0gJ30nICYmIHRoaXMuX2lucHV0LnBlZWsoMSkgPT09ICd9Jykge1xuICAgICAgdGhpcy5faW5wdXQubmV4dCgpO1xuICAgICAgdGhpcy5faW5wdXQubmV4dCgpO1xuICAgICAgdG9rZW4gPSB0aGlzLl9jcmVhdGVfdG9rZW4oVE9LRU4uVEFHX0NMT1NFLCAnfX0nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdG9rZW47XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9yZWFkX2F0dHJpYnV0ZSA9IGZ1bmN0aW9uKGMsIHByZXZpb3VzX3Rva2VuLCBvcGVuX3Rva2VuKSB7XG4gIHZhciB0b2tlbiA9IG51bGw7XG4gIHZhciByZXN1bHRpbmdfc3RyaW5nID0gJyc7XG4gIGlmIChvcGVuX3Rva2VuICYmIG9wZW5fdG9rZW4udGV4dFswXSA9PT0gJzwnKSB7XG5cbiAgICBpZiAoYyA9PT0gJz0nKSB7XG4gICAgICB0b2tlbiA9IHRoaXMuX2NyZWF0ZV90b2tlbihUT0tFTi5FUVVBTFMsIHRoaXMuX2lucHV0Lm5leHQoKSk7XG4gICAgfSBlbHNlIGlmIChjID09PSAnXCInIHx8IGMgPT09IFwiJ1wiKSB7XG4gICAgICB2YXIgY29udGVudCA9IHRoaXMuX2lucHV0Lm5leHQoKTtcbiAgICAgIGlmIChjID09PSAnXCInKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gdGhpcy5fX3BhdHRlcm5zLmRvdWJsZV9xdW90ZS5yZWFkKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250ZW50ICs9IHRoaXMuX19wYXR0ZXJucy5zaW5nbGVfcXVvdGUucmVhZCgpO1xuICAgICAgfVxuICAgICAgdG9rZW4gPSB0aGlzLl9jcmVhdGVfdG9rZW4oVE9LRU4uVkFMVUUsIGNvbnRlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHRpbmdfc3RyaW5nID0gdGhpcy5fX3BhdHRlcm5zLmF0dHJpYnV0ZS5yZWFkKCk7XG5cbiAgICAgIGlmIChyZXN1bHRpbmdfc3RyaW5nKSB7XG4gICAgICAgIGlmIChwcmV2aW91c190b2tlbi50eXBlID09PSBUT0tFTi5FUVVBTFMpIHtcbiAgICAgICAgICB0b2tlbiA9IHRoaXMuX2NyZWF0ZV90b2tlbihUT0tFTi5WQUxVRSwgcmVzdWx0aW5nX3N0cmluZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdG9rZW4gPSB0aGlzLl9jcmVhdGVfdG9rZW4oVE9LRU4uQVRUUklCVVRFLCByZXN1bHRpbmdfc3RyaW5nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdG9rZW47XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9pc19jb250ZW50X3VuZm9ybWF0dGVkID0gZnVuY3Rpb24odGFnX25hbWUpIHtcbiAgLy8gdm9pZF9lbGVtZW50cyBoYXZlIG5vIGNvbnRlbnQgYW5kIHNvIGNhbm5vdCBoYXZlIHVuZm9ybWF0dGVkIGNvbnRlbnRcbiAgLy8gc2NyaXB0IGFuZCBzdHlsZSB0YWdzIHNob3VsZCBhbHdheXMgYmUgcmVhZCBhcyB1bmZvcm1hdHRlZCBjb250ZW50XG4gIC8vIGZpbmFsbHkgY29udGVudF91bmZvcm1hdHRlZCBhbmQgdW5mb3JtYXR0ZWQgZWxlbWVudCBjb250ZW50cyBhcmUgdW5mb3JtYXR0ZWRcbiAgcmV0dXJuIHRoaXMuX29wdGlvbnMudm9pZF9lbGVtZW50cy5pbmRleE9mKHRhZ19uYW1lKSA9PT0gLTEgJiZcbiAgICAodGhpcy5fb3B0aW9ucy5jb250ZW50X3VuZm9ybWF0dGVkLmluZGV4T2YodGFnX25hbWUpICE9PSAtMSB8fFxuICAgICAgdGhpcy5fb3B0aW9ucy51bmZvcm1hdHRlZC5pbmRleE9mKHRhZ19uYW1lKSAhPT0gLTEpO1xufTtcblxuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9yZWFkX3Jhd19jb250ZW50ID0gZnVuY3Rpb24oYywgcHJldmlvdXNfdG9rZW4sIG9wZW5fdG9rZW4pIHsgLy8ganNoaW50IHVudXNlZDpmYWxzZVxuICB2YXIgcmVzdWx0aW5nX3N0cmluZyA9ICcnO1xuICBpZiAob3Blbl90b2tlbiAmJiBvcGVuX3Rva2VuLnRleHRbMF0gPT09ICd7Jykge1xuICAgIHJlc3VsdGluZ19zdHJpbmcgPSB0aGlzLl9fcGF0dGVybnMuaGFuZGxlYmFyc19yYXdfY2xvc2UucmVhZCgpO1xuICB9IGVsc2UgaWYgKHByZXZpb3VzX3Rva2VuLnR5cGUgPT09IFRPS0VOLlRBR19DTE9TRSAmJlxuICAgIHByZXZpb3VzX3Rva2VuLm9wZW5lZC50ZXh0WzBdID09PSAnPCcgJiYgcHJldmlvdXNfdG9rZW4udGV4dFswXSAhPT0gJy8nKSB7XG4gICAgLy8gXl4gZW1wdHkgdGFnIGhhcyBubyBjb250ZW50IFxuICAgIHZhciB0YWdfbmFtZSA9IHByZXZpb3VzX3Rva2VuLm9wZW5lZC50ZXh0LnN1YnN0cigxKS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmICh0YWdfbmFtZSA9PT0gJ3NjcmlwdCcgfHwgdGFnX25hbWUgPT09ICdzdHlsZScpIHtcbiAgICAgIC8vIFNjcmlwdCBhbmQgc3R5bGUgdGFncyBhcmUgYWxsb3dlZCB0byBoYXZlIGNvbW1lbnRzIHdyYXBwaW5nIHRoZWlyIGNvbnRlbnRcbiAgICAgIC8vIG9yIGp1c3QgaGF2ZSByZWd1bGFyIGNvbnRlbnQuXG4gICAgICB2YXIgdG9rZW4gPSB0aGlzLl9yZWFkX2NvbW1lbnRfb3JfY2RhdGEoYyk7XG4gICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgdG9rZW4udHlwZSA9IFRPS0VOLlRFWFQ7XG4gICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgIH1cbiAgICAgIHJlc3VsdGluZ19zdHJpbmcgPSB0aGlzLl9pbnB1dC5yZWFkVW50aWwobmV3IFJlZ0V4cCgnPC8nICsgdGFnX25hbWUgKyAnW1xcXFxuXFxcXHJcXFxcdCBdKj8+JywgJ2lnJykpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5faXNfY29udGVudF91bmZvcm1hdHRlZCh0YWdfbmFtZSkpIHtcblxuICAgICAgcmVzdWx0aW5nX3N0cmluZyA9IHRoaXMuX2lucHV0LnJlYWRVbnRpbChuZXcgUmVnRXhwKCc8LycgKyB0YWdfbmFtZSArICdbXFxcXG5cXFxcclxcXFx0IF0qPz4nLCAnaWcnKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHJlc3VsdGluZ19zdHJpbmcpIHtcbiAgICByZXR1cm4gdGhpcy5fY3JlYXRlX3Rva2VuKFRPS0VOLlRFWFQsIHJlc3VsdGluZ19zdHJpbmcpO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9yZWFkX2NvbnRlbnRfd29yZCA9IGZ1bmN0aW9uKGMpIHtcbiAgdmFyIHJlc3VsdGluZ19zdHJpbmcgPSAnJztcbiAgaWYgKHRoaXMuX29wdGlvbnMudW5mb3JtYXR0ZWRfY29udGVudF9kZWxpbWl0ZXIpIHtcbiAgICBpZiAoYyA9PT0gdGhpcy5fb3B0aW9ucy51bmZvcm1hdHRlZF9jb250ZW50X2RlbGltaXRlclswXSkge1xuICAgICAgcmVzdWx0aW5nX3N0cmluZyA9IHRoaXMuX19wYXR0ZXJucy51bmZvcm1hdHRlZF9jb250ZW50X2RlbGltaXRlci5yZWFkKCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFyZXN1bHRpbmdfc3RyaW5nKSB7XG4gICAgcmVzdWx0aW5nX3N0cmluZyA9IHRoaXMuX19wYXR0ZXJucy53b3JkLnJlYWQoKTtcbiAgfVxuICBpZiAocmVzdWx0aW5nX3N0cmluZykge1xuICAgIHJldHVybiB0aGlzLl9jcmVhdGVfdG9rZW4oVE9LRU4uVEVYVCwgcmVzdWx0aW5nX3N0cmluZyk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzLlRva2VuaXplciA9IFRva2VuaXplcjtcbm1vZHVsZS5leHBvcnRzLlRPS0VOID0gVE9LRU47XG5cblxuLyoqKi8gfSlcbi8qKioqKiovIF0pO1xudmFyIHN0eWxlX2h0bWwgPSBsZWdhY3lfYmVhdXRpZnlfaHRtbDtcbi8qIEZvb3RlciAqL1xuaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG4gICAgLy8gQWRkIHN1cHBvcnQgZm9yIEFNRCAoIGh0dHBzOi8vZ2l0aHViLmNvbS9hbWRqcy9hbWRqcy1hcGkvd2lraS9BTUQjZGVmaW5lYW1kLXByb3BlcnR5LSApXG4gICAgZGVmaW5lKFtcInJlcXVpcmVcIiwgXCIuL2JlYXV0aWZ5XCIsIFwiLi9iZWF1dGlmeS1jc3NcIl0sIGZ1bmN0aW9uKHJlcXVpcmVhbWQpIHtcbiAgICAgICAgdmFyIGpzX2JlYXV0aWZ5ID0gcmVxdWlyZWFtZChcIi4vYmVhdXRpZnlcIik7XG4gICAgICAgIHZhciBjc3NfYmVhdXRpZnkgPSByZXF1aXJlYW1kKFwiLi9iZWF1dGlmeS1jc3NcIik7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGh0bWxfYmVhdXRpZnk6IGZ1bmN0aW9uKGh0bWxfc291cmNlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0eWxlX2h0bWwoaHRtbF9zb3VyY2UsIG9wdGlvbnMsIGpzX2JlYXV0aWZ5LmpzX2JlYXV0aWZ5LCBjc3NfYmVhdXRpZnkuY3NzX2JlYXV0aWZ5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9KTtcbn0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAvLyBBZGQgc3VwcG9ydCBmb3IgQ29tbW9uSlMuIEp1c3QgcHV0IHRoaXMgZmlsZSBzb21ld2hlcmUgb24geW91ciByZXF1aXJlLnBhdGhzXG4gICAgLy8gYW5kIHlvdSB3aWxsIGJlIGFibGUgdG8gYHZhciBodG1sX2JlYXV0aWZ5ID0gcmVxdWlyZShcImJlYXV0aWZ5XCIpLmh0bWxfYmVhdXRpZnlgLlxuICAgIHZhciBqc19iZWF1dGlmeSA9IHJlcXVpcmUoJy4vYmVhdXRpZnkuanMnKTtcbiAgICB2YXIgY3NzX2JlYXV0aWZ5ID0gcmVxdWlyZSgnLi9iZWF1dGlmeS1jc3MuanMnKTtcblxuICAgIGV4cG9ydHMuaHRtbF9iZWF1dGlmeSA9IGZ1bmN0aW9uKGh0bWxfc291cmNlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBzdHlsZV9odG1sKGh0bWxfc291cmNlLCBvcHRpb25zLCBqc19iZWF1dGlmeS5qc19iZWF1dGlmeSwgY3NzX2JlYXV0aWZ5LmNzc19iZWF1dGlmeSk7XG4gICAgfTtcbn0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIC8vIElmIHdlJ3JlIHJ1bm5pbmcgYSB3ZWIgcGFnZSBhbmQgZG9uJ3QgaGF2ZSBlaXRoZXIgb2YgdGhlIGFib3ZlLCBhZGQgb3VyIG9uZSBnbG9iYWxcbiAgICB3aW5kb3cuaHRtbF9iZWF1dGlmeSA9IGZ1bmN0aW9uKGh0bWxfc291cmNlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBzdHlsZV9odG1sKGh0bWxfc291cmNlLCBvcHRpb25zLCB3aW5kb3cuanNfYmVhdXRpZnksIHdpbmRvdy5jc3NfYmVhdXRpZnkpO1xuICAgIH07XG59IGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAvLyBJZiB3ZSBkb24ndCBldmVuIGhhdmUgd2luZG93LCB0cnkgZ2xvYmFsLlxuICAgIGdsb2JhbC5odG1sX2JlYXV0aWZ5ID0gZnVuY3Rpb24oaHRtbF9zb3VyY2UsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHN0eWxlX2h0bWwoaHRtbF9zb3VyY2UsIG9wdGlvbnMsIGdsb2JhbC5qc19iZWF1dGlmeSwgZ2xvYmFsLmNzc19iZWF1dGlmeSk7XG4gICAgfTtcbn1cblxufSgpKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/js-beautify/js/lib/beautify-html.js\n");

/***/ }),

/***/ "./node_modules/js-beautify/js/lib/beautify.js":
/*!*****************************************************!*\
  !*** ./node_modules/js-beautify/js/lib/beautify.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* AUTO-GENERATED. DO NOT MODIFY. */\n/*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n\n JS Beautifier\n---------------\n\n\n  Written by Einar Lielmanis, <einar@beautifier.io>\n      https://beautifier.io/\n\n  Originally converted to javascript by Vital, <vital76@gmail.com>\n  \"End braces on own line\" added by Chris J. Shull, <chrisjshull@gmail.com>\n  Parsing improvements for brace-less statements by Liam Newman <bitwiseman@beautifier.io>\n\n\n  Usage:\n    js_beautify(js_source_text);\n    js_beautify(js_source_text, options);\n\n  The options are:\n    indent_size (default 4)          - indentation size,\n    indent_char (default space)      - character to indent with,\n    preserve_newlines (default true) - whether existing line breaks should be preserved,\n    max_preserve_newlines (default unlimited) - maximum number of line breaks to be preserved in one chunk,\n\n    jslint_happy (default false) - if true, then jslint-stricter mode is enforced.\n\n            jslint_happy        !jslint_happy\n            ---------------------------------\n            function ()         function()\n\n            switch () {         switch() {\n            case 1:               case 1:\n              break;                break;\n            }                   }\n\n    space_after_anon_function (default false) - should the space before an anonymous function's parens be added, \"function()\" vs \"function ()\",\n          NOTE: This option is overriden by jslint_happy (i.e. if jslint_happy is true, space_after_anon_function is true by design)\n\n    brace_style (default \"collapse\") - \"collapse\" | \"expand\" | \"end-expand\" | \"none\" | any of the former + \",preserve-inline\"\n            put braces on the same line as control statements (default), or put braces on own line (Allman / ANSI style), or just put end braces on own line, or attempt to keep them where they are.\n            preserve-inline will try to preserve inline blocks of curly braces\n\n    space_before_conditional (default true) - should the space before conditional statement be added, \"if(true)\" vs \"if (true)\",\n\n    unescape_strings (default false) - should printable characters in strings encoded in \\xNN notation be unescaped, \"example\" vs \"\\x65\\x78\\x61\\x6d\\x70\\x6c\\x65\"\n\n    wrap_line_length (default unlimited) - lines should wrap at next opportunity after this number of characters.\n          NOTE: This is not a hard limit. Lines will continue until a point where a newline would\n                be preserved if it were present.\n\n    end_with_newline (default false)  - end output with a newline\n\n\n    e.g\n\n    js_beautify(js_source_text, {\n      'indent_size': 1,\n      'indent_char': '\\t'\n    });\n\n*/\n\n(function() {\n\n/* GENERATED_BUILD_OUTPUT */\nvar legacy_beautify_js =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*jshint node:true */\n/*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/\n\n\n\nvar Beautifier = __webpack_require__(1).Beautifier,\n  Options = __webpack_require__(5).Options;\n\nfunction js_beautify(js_source_text, options) {\n  var beautifier = new Beautifier(js_source_text, options);\n  return beautifier.beautify();\n}\n\nmodule.exports = js_beautify;\nmodule.exports.defaultOptions = function() {\n  return new Options();\n};\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*jshint node:true */\n/*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/\n\n\n\nvar Output = __webpack_require__(2).Output;\nvar Token = __webpack_require__(3).Token;\nvar acorn = __webpack_require__(4);\nvar Options = __webpack_require__(5).Options;\nvar Tokenizer = __webpack_require__(7).Tokenizer;\nvar line_starters = __webpack_require__(7).line_starters;\nvar positionable_operators = __webpack_require__(7).positionable_operators;\nvar TOKEN = __webpack_require__(7).TOKEN;\n\n\nfunction in_array(what, arr) {\n  return arr.indexOf(what) !== -1;\n}\n\nfunction ltrim(s) {\n  return s.replace(/^\\s+/g, '');\n}\n\nfunction generateMapFromStrings(list) {\n  var result = {};\n  for (var x = 0; x < list.length; x++) {\n    // make the mapped names underscored instead of dash\n    result[list[x].replace(/-/g, '_')] = list[x];\n  }\n  return result;\n}\n\nfunction reserved_word(token, word) {\n  return token && token.type === TOKEN.RESERVED && token.text === word;\n}\n\nfunction reserved_array(token, words) {\n  return token && token.type === TOKEN.RESERVED && in_array(token.text, words);\n}\n// Unsure of what they mean, but they work. Worth cleaning up in future.\nvar special_words = ['case', 'return', 'do', 'if', 'throw', 'else', 'await', 'break', 'continue', 'async'];\n\nvar validPositionValues = ['before-newline', 'after-newline', 'preserve-newline'];\n\n// Generate map from array\nvar OPERATOR_POSITION = generateMapFromStrings(validPositionValues);\n\nvar OPERATOR_POSITION_BEFORE_OR_PRESERVE = [OPERATOR_POSITION.before_newline, OPERATOR_POSITION.preserve_newline];\n\nvar MODE = {\n  BlockStatement: 'BlockStatement', // 'BLOCK'\n  Statement: 'Statement', // 'STATEMENT'\n  ObjectLiteral: 'ObjectLiteral', // 'OBJECT',\n  ArrayLiteral: 'ArrayLiteral', //'[EXPRESSION]',\n  ForInitializer: 'ForInitializer', //'(FOR-EXPRESSION)',\n  Conditional: 'Conditional', //'(COND-EXPRESSION)',\n  Expression: 'Expression' //'(EXPRESSION)'\n};\n\nfunction remove_redundant_indentation(output, frame) {\n  // This implementation is effective but has some issues:\n  //     - can cause line wrap to happen too soon due to indent removal\n  //           after wrap points are calculated\n  // These issues are minor compared to ugly indentation.\n\n  if (frame.multiline_frame ||\n    frame.mode === MODE.ForInitializer ||\n    frame.mode === MODE.Conditional) {\n    return;\n  }\n\n  // remove one indent from each line inside this section\n  output.remove_indent(frame.start_line_index);\n}\n\n// we could use just string.split, but\n// IE doesn't like returning empty strings\nfunction split_linebreaks(s) {\n  //return s.split(/\\x0d\\x0a|\\x0a/);\n\n  s = s.replace(acorn.allLineBreaks, '\\n');\n  var out = [],\n    idx = s.indexOf(\"\\n\");\n  while (idx !== -1) {\n    out.push(s.substring(0, idx));\n    s = s.substring(idx + 1);\n    idx = s.indexOf(\"\\n\");\n  }\n  if (s.length) {\n    out.push(s);\n  }\n  return out;\n}\n\nfunction is_array(mode) {\n  return mode === MODE.ArrayLiteral;\n}\n\nfunction is_expression(mode) {\n  return in_array(mode, [MODE.Expression, MODE.ForInitializer, MODE.Conditional]);\n}\n\nfunction all_lines_start_with(lines, c) {\n  for (var i = 0; i < lines.length; i++) {\n    var line = lines[i].trim();\n    if (line.charAt(0) !== c) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction each_line_matches_indent(lines, indent) {\n  var i = 0,\n    len = lines.length,\n    line;\n  for (; i < len; i++) {\n    line = lines[i];\n    // allow empty lines to pass through\n    if (line && line.indexOf(indent) !== 0) {\n      return false;\n    }\n  }\n  return true;\n}\n\n\nfunction Beautifier(source_text, options) {\n  options = options || {};\n  this._source_text = source_text || '';\n\n  this._output = null;\n  this._tokens = null;\n  this._last_last_text = null;\n  this._flags = null;\n  this._previous_flags = null;\n\n  this._flag_store = null;\n  this._options = new Options(options);\n}\n\nBeautifier.prototype.create_flags = function(flags_base, mode) {\n  var next_indent_level = 0;\n  if (flags_base) {\n    next_indent_level = flags_base.indentation_level;\n    if (!this._output.just_added_newline() &&\n      flags_base.line_indent_level > next_indent_level) {\n      next_indent_level = flags_base.line_indent_level;\n    }\n  }\n\n  var next_flags = {\n    mode: mode,\n    parent: flags_base,\n    last_token: flags_base ? flags_base.last_token : new Token(TOKEN.START_BLOCK, ''), // last token text\n    last_word: flags_base ? flags_base.last_word : '', // last TOKEN.WORD passed\n    declaration_statement: false,\n    declaration_assignment: false,\n    multiline_frame: false,\n    inline_frame: false,\n    if_block: false,\n    else_block: false,\n    do_block: false,\n    do_while: false,\n    import_block: false,\n    in_case_statement: false, // switch(..){ INSIDE HERE }\n    in_case: false, // we're on the exact line with \"case 0:\"\n    case_body: false, // the indented case-action block\n    indentation_level: next_indent_level,\n    alignment: 0,\n    line_indent_level: flags_base ? flags_base.line_indent_level : next_indent_level,\n    start_line_index: this._output.get_line_number(),\n    ternary_depth: 0\n  };\n  return next_flags;\n};\n\nBeautifier.prototype._reset = function(source_text) {\n  var baseIndentString = source_text.match(/^[\\t ]*/)[0];\n\n  this._last_last_text = ''; // pre-last token text\n  this._output = new Output(this._options, baseIndentString);\n\n  // If testing the ignore directive, start with output disable set to true\n  this._output.raw = this._options.test_output_raw;\n\n\n  // Stack of parsing/formatting states, including MODE.\n  // We tokenize, parse, and output in an almost purely a forward-only stream of token input\n  // and formatted output.  This makes the beautifier less accurate than full parsers\n  // but also far more tolerant of syntax errors.\n  //\n  // For example, the default mode is MODE.BlockStatement. If we see a '{' we push a new frame of type\n  // MODE.BlockStatement on the the stack, even though it could be object literal.  If we later\n  // encounter a \":\", we'll switch to to MODE.ObjectLiteral.  If we then see a \";\",\n  // most full parsers would die, but the beautifier gracefully falls back to\n  // MODE.BlockStatement and continues on.\n  this._flag_store = [];\n  this.set_mode(MODE.BlockStatement);\n  var tokenizer = new Tokenizer(source_text, this._options);\n  this._tokens = tokenizer.tokenize();\n  return source_text;\n};\n\nBeautifier.prototype.beautify = function() {\n  // if disabled, return the input unchanged.\n  if (this._options.disabled) {\n    return this._source_text;\n  }\n\n  var sweet_code;\n  var source_text = this._reset(this._source_text);\n\n  var eol = this._options.eol;\n  if (this._options.eol === 'auto') {\n    eol = '\\n';\n    if (source_text && acorn.lineBreak.test(source_text || '')) {\n      eol = source_text.match(acorn.lineBreak)[0];\n    }\n  }\n\n  var current_token = this._tokens.next();\n  while (current_token) {\n    this.handle_token(current_token);\n\n    this._last_last_text = this._flags.last_token.text;\n    this._flags.last_token = current_token;\n\n    current_token = this._tokens.next();\n  }\n\n  sweet_code = this._output.get_code(eol);\n\n  return sweet_code;\n};\n\nBeautifier.prototype.handle_token = function(current_token, preserve_statement_flags) {\n  if (current_token.type === TOKEN.START_EXPR) {\n    this.handle_start_expr(current_token);\n  } else if (current_token.type === TOKEN.END_EXPR) {\n    this.handle_end_expr(current_token);\n  } else if (current_token.type === TOKEN.START_BLOCK) {\n    this.handle_start_block(current_token);\n  } else if (current_token.type === TOKEN.END_BLOCK) {\n    this.handle_end_block(current_token);\n  } else if (current_token.type === TOKEN.WORD) {\n    this.handle_word(current_token);\n  } else if (current_token.type === TOKEN.RESERVED) {\n    this.handle_word(current_token);\n  } else if (current_token.type === TOKEN.SEMICOLON) {\n    this.handle_semicolon(current_token);\n  } else if (current_token.type === TOKEN.STRING) {\n    this.handle_string(current_token);\n  } else if (current_token.type === TOKEN.EQUALS) {\n    this.handle_equals(current_token);\n  } else if (current_token.type === TOKEN.OPERATOR) {\n    this.handle_operator(current_token);\n  } else if (current_token.type === TOKEN.COMMA) {\n    this.handle_comma(current_token);\n  } else if (current_token.type === TOKEN.BLOCK_COMMENT) {\n    this.handle_block_comment(current_token, preserve_statement_flags);\n  } else if (current_token.type === TOKEN.COMMENT) {\n    this.handle_comment(current_token, preserve_statement_flags);\n  } else if (current_token.type === TOKEN.DOT) {\n    this.handle_dot(current_token);\n  } else if (current_token.type === TOKEN.EOF) {\n    this.handle_eof(current_token);\n  } else if (current_token.type === TOKEN.UNKNOWN) {\n    this.handle_unknown(current_token, preserve_statement_flags);\n  } else {\n    this.handle_unknown(current_token, preserve_statement_flags);\n  }\n};\n\nBeautifier.prototype.handle_whitespace_and_comments = function(current_token, preserve_statement_flags) {\n  var newlines = current_token.newlines;\n  var keep_whitespace = this._options.keep_array_indentation && is_array(this._flags.mode);\n\n  if (current_token.comments_before) {\n    var comment_token = current_token.comments_before.next();\n    while (comment_token) {\n      // The cleanest handling of inline comments is to treat them as though they aren't there.\n      // Just continue formatting and the behavior should be logical.\n      // Also ignore unknown tokens.  Again, this should result in better behavior.\n      this.handle_whitespace_and_comments(comment_token, preserve_statement_flags);\n      this.handle_token(comment_token, preserve_statement_flags);\n      comment_token = current_token.comments_before.next();\n    }\n  }\n\n  if (keep_whitespace) {\n    for (var i = 0; i < newlines; i += 1) {\n      this.print_newline(i > 0, preserve_statement_flags);\n    }\n  } else {\n    if (this._options.max_preserve_newlines && newlines > this._options.max_preserve_newlines) {\n      newlines = this._options.max_preserve_newlines;\n    }\n\n    if (this._options.preserve_newlines) {\n      if (newlines > 1) {\n        this.print_newline(false, preserve_statement_flags);\n        for (var j = 1; j < newlines; j += 1) {\n          this.print_newline(true, preserve_statement_flags);\n        }\n      }\n    }\n  }\n\n};\n\nvar newline_restricted_tokens = ['async', 'break', 'continue', 'return', 'throw', 'yield'];\n\nBeautifier.prototype.allow_wrap_or_preserved_newline = function(current_token, force_linewrap) {\n  force_linewrap = (force_linewrap === undefined) ? false : force_linewrap;\n\n  // Never wrap the first token on a line\n  if (this._output.just_added_newline()) {\n    return;\n  }\n\n  var shouldPreserveOrForce = (this._options.preserve_newlines && current_token.newlines) || force_linewrap;\n  var operatorLogicApplies = in_array(this._flags.last_token.text, positionable_operators) ||\n    in_array(current_token.text, positionable_operators);\n\n  if (operatorLogicApplies) {\n    var shouldPrintOperatorNewline = (\n        in_array(this._flags.last_token.text, positionable_operators) &&\n        in_array(this._options.operator_position, OPERATOR_POSITION_BEFORE_OR_PRESERVE)\n      ) ||\n      in_array(current_token.text, positionable_operators);\n    shouldPreserveOrForce = shouldPreserveOrForce && shouldPrintOperatorNewline;\n  }\n\n  if (shouldPreserveOrForce) {\n    this.print_newline(false, true);\n  } else if (this._options.wrap_line_length) {\n    if (reserved_array(this._flags.last_token, newline_restricted_tokens)) {\n      // These tokens should never have a newline inserted\n      // between them and the following expression.\n      return;\n    }\n    this._output.set_wrap_point();\n  }\n};\n\nBeautifier.prototype.print_newline = function(force_newline, preserve_statement_flags) {\n  if (!preserve_statement_flags) {\n    if (this._flags.last_token.text !== ';' && this._flags.last_token.text !== ',' && this._flags.last_token.text !== '=' && (this._flags.last_token.type !== TOKEN.OPERATOR || this._flags.last_token.text === '--' || this._flags.last_token.text === '++')) {\n      var next_token = this._tokens.peek();\n      while (this._flags.mode === MODE.Statement &&\n        !(this._flags.if_block && reserved_word(next_token, 'else')) &&\n        !this._flags.do_block) {\n        this.restore_mode();\n      }\n    }\n  }\n\n  if (this._output.add_new_line(force_newline)) {\n    this._flags.multiline_frame = true;\n  }\n};\n\nBeautifier.prototype.print_token_line_indentation = function(current_token) {\n  if (this._output.just_added_newline()) {\n    if (this._options.keep_array_indentation &&\n      current_token.newlines &&\n      (current_token.text === '[' || is_array(this._flags.mode))) {\n      this._output.current_line.set_indent(-1);\n      this._output.current_line.push(current_token.whitespace_before);\n      this._output.space_before_token = false;\n    } else if (this._output.set_indent(this._flags.indentation_level, this._flags.alignment)) {\n      this._flags.line_indent_level = this._flags.indentation_level;\n    }\n  }\n};\n\nBeautifier.prototype.print_token = function(current_token) {\n  if (this._output.raw) {\n    this._output.add_raw_token(current_token);\n    return;\n  }\n\n  if (this._options.comma_first && current_token.previous && current_token.previous.type === TOKEN.COMMA &&\n    this._output.just_added_newline()) {\n    if (this._output.previous_line.last() === ',') {\n      var popped = this._output.previous_line.pop();\n      // if the comma was already at the start of the line,\n      // pull back onto that line and reprint the indentation\n      if (this._output.previous_line.is_empty()) {\n        this._output.previous_line.push(popped);\n        this._output.trim(true);\n        this._output.current_line.pop();\n        this._output.trim();\n      }\n\n      // add the comma in front of the next token\n      this.print_token_line_indentation(current_token);\n      this._output.add_token(',');\n      this._output.space_before_token = true;\n    }\n  }\n\n  this.print_token_line_indentation(current_token);\n  this._output.non_breaking_space = true;\n  this._output.add_token(current_token.text);\n  if (this._output.previous_token_wrapped) {\n    this._flags.multiline_frame = true;\n  }\n};\n\nBeautifier.prototype.indent = function() {\n  this._flags.indentation_level += 1;\n  this._output.set_indent(this._flags.indentation_level, this._flags.alignment);\n};\n\nBeautifier.prototype.deindent = function() {\n  if (this._flags.indentation_level > 0 &&\n    ((!this._flags.parent) || this._flags.indentation_level > this._flags.parent.indentation_level)) {\n    this._flags.indentation_level -= 1;\n    this._output.set_indent(this._flags.indentation_level, this._flags.alignment);\n  }\n};\n\nBeautifier.prototype.set_mode = function(mode) {\n  if (this._flags) {\n    this._flag_store.push(this._flags);\n    this._previous_flags = this._flags;\n  } else {\n    this._previous_flags = this.create_flags(null, mode);\n  }\n\n  this._flags = this.create_flags(this._previous_flags, mode);\n  this._output.set_indent(this._flags.indentation_level, this._flags.alignment);\n};\n\n\nBeautifier.prototype.restore_mode = function() {\n  if (this._flag_store.length > 0) {\n    this._previous_flags = this._flags;\n    this._flags = this._flag_store.pop();\n    if (this._previous_flags.mode === MODE.Statement) {\n      remove_redundant_indentation(this._output, this._previous_flags);\n    }\n    this._output.set_indent(this._flags.indentation_level, this._flags.alignment);\n  }\n};\n\nBeautifier.prototype.start_of_object_property = function() {\n  return this._flags.parent.mode === MODE.ObjectLiteral && this._flags.mode === MODE.Statement && (\n    (this._flags.last_token.text === ':' && this._flags.ternary_depth === 0) || (reserved_array(this._flags.last_token, ['get', 'set'])));\n};\n\nBeautifier.prototype.start_of_statement = function(current_token) {\n  var start = false;\n  start = start || reserved_array(this._flags.last_token, ['var', 'let', 'const']) && current_token.type === TOKEN.WORD;\n  start = start || reserved_word(this._flags.last_token, 'do');\n  start = start || (!(this._flags.parent.mode === MODE.ObjectLiteral && this._flags.mode === MODE.Statement)) && reserved_array(this._flags.last_token, newline_restricted_tokens) && !current_token.newlines;\n  start = start || reserved_word(this._flags.last_token, 'else') &&\n    !(reserved_word(current_token, 'if') && !current_token.comments_before);\n  start = start || (this._flags.last_token.type === TOKEN.END_EXPR && (this._previous_flags.mode === MODE.ForInitializer || this._previous_flags.mode === MODE.Conditional));\n  start = start || (this._flags.last_token.type === TOKEN.WORD && this._flags.mode === MODE.BlockStatement &&\n    !this._flags.in_case &&\n    !(current_token.text === '--' || current_token.text === '++') &&\n    this._last_last_text !== 'function' &&\n    current_token.type !== TOKEN.WORD && current_token.type !== TOKEN.RESERVED);\n  start = start || (this._flags.mode === MODE.ObjectLiteral && (\n    (this._flags.last_token.text === ':' && this._flags.ternary_depth === 0) || reserved_array(this._flags.last_token, ['get', 'set'])));\n\n  if (start) {\n    this.set_mode(MODE.Statement);\n    this.indent();\n\n    this.handle_whitespace_and_comments(current_token, true);\n\n    // Issue #276:\n    // If starting a new statement with [if, for, while, do], push to a new line.\n    // if (a) if (b) if(c) d(); else e(); else f();\n    if (!this.start_of_object_property()) {\n      this.allow_wrap_or_preserved_newline(current_token,\n        reserved_array(current_token, ['do', 'for', 'if', 'while']));\n    }\n    return true;\n  }\n  return false;\n};\n\nBeautifier.prototype.handle_start_expr = function(current_token) {\n  // The conditional starts the statement if appropriate.\n  if (!this.start_of_statement(current_token)) {\n    this.handle_whitespace_and_comments(current_token);\n  }\n\n  var next_mode = MODE.Expression;\n  if (current_token.text === '[') {\n\n    if (this._flags.last_token.type === TOKEN.WORD || this._flags.last_token.text === ')') {\n      // this is array index specifier, break immediately\n      // a[x], fn()[x]\n      if (reserved_array(this._flags.last_token, line_starters)) {\n        this._output.space_before_token = true;\n      }\n      this.print_token(current_token);\n      this.set_mode(next_mode);\n      this.indent();\n      if (this._options.space_in_paren) {\n        this._output.space_before_token = true;\n      }\n      return;\n    }\n\n    next_mode = MODE.ArrayLiteral;\n    if (is_array(this._flags.mode)) {\n      if (this._flags.last_token.text === '[' ||\n        (this._flags.last_token.text === ',' && (this._last_last_text === ']' || this._last_last_text === '}'))) {\n        // ], [ goes to new line\n        // }, [ goes to new line\n        if (!this._options.keep_array_indentation) {\n          this.print_newline();\n        }\n      }\n    }\n\n    if (!in_array(this._flags.last_token.type, [TOKEN.START_EXPR, TOKEN.END_EXPR, TOKEN.WORD, TOKEN.OPERATOR])) {\n      this._output.space_before_token = true;\n    }\n  } else {\n    if (this._flags.last_token.type === TOKEN.RESERVED) {\n      if (this._flags.last_token.text === 'for') {\n        this._output.space_before_token = this._options.space_before_conditional;\n        next_mode = MODE.ForInitializer;\n      } else if (in_array(this._flags.last_token.text, ['if', 'while'])) {\n        this._output.space_before_token = this._options.space_before_conditional;\n        next_mode = MODE.Conditional;\n      } else if (in_array(this._flags.last_word, ['await', 'async'])) {\n        // Should be a space between await and an IIFE, or async and an arrow function\n        this._output.space_before_token = true;\n      } else if (this._flags.last_token.text === 'import' && current_token.whitespace_before === '') {\n        this._output.space_before_token = false;\n      } else if (in_array(this._flags.last_token.text, line_starters) || this._flags.last_token.text === 'catch') {\n        this._output.space_before_token = true;\n      }\n    } else if (this._flags.last_token.type === TOKEN.EQUALS || this._flags.last_token.type === TOKEN.OPERATOR) {\n      // Support of this kind of newline preservation.\n      // a = (b &&\n      //     (c || d));\n      if (!this.start_of_object_property()) {\n        this.allow_wrap_or_preserved_newline(current_token);\n      }\n    } else if (this._flags.last_token.type === TOKEN.WORD) {\n      this._output.space_before_token = false;\n\n      // function name() vs function name ()\n      // function* name() vs function* name ()\n      // async name() vs async name ()\n      // In ES6, you can also define the method properties of an object\n      // var obj = {a: function() {}}\n      // It can be abbreviated\n      // var obj = {a() {}}\n      // var obj = { a() {}} vs var obj = { a () {}}\n      // var obj = { * a() {}} vs var obj = { * a () {}}\n      var peek_back_two = this._tokens.peek(-3);\n      if (this._options.space_after_named_function && peek_back_two) {\n        // peek starts at next character so -1 is current token\n        var peek_back_three = this._tokens.peek(-4);\n        if (reserved_array(peek_back_two, ['async', 'function']) ||\n          (peek_back_two.text === '*' && reserved_array(peek_back_three, ['async', 'function']))) {\n          this._output.space_before_token = true;\n        } else if (this._flags.mode === MODE.ObjectLiteral) {\n          if ((peek_back_two.text === '{' || peek_back_two.text === ',') ||\n            (peek_back_two.text === '*' && (peek_back_three.text === '{' || peek_back_three.text === ','))) {\n            this._output.space_before_token = true;\n          }\n        }\n      }\n    } else {\n      // Support preserving wrapped arrow function expressions\n      // a.b('c',\n      //     () => d.e\n      // )\n      this.allow_wrap_or_preserved_newline(current_token);\n    }\n\n    // function() vs function ()\n    // yield*() vs yield* ()\n    // function*() vs function* ()\n    if ((this._flags.last_token.type === TOKEN.RESERVED && (this._flags.last_word === 'function' || this._flags.last_word === 'typeof')) ||\n      (this._flags.last_token.text === '*' &&\n        (in_array(this._last_last_text, ['function', 'yield']) ||\n          (this._flags.mode === MODE.ObjectLiteral && in_array(this._last_last_text, ['{', ',']))))) {\n      this._output.space_before_token = this._options.space_after_anon_function;\n    }\n  }\n\n  if (this._flags.last_token.text === ';' || this._flags.last_token.type === TOKEN.START_BLOCK) {\n    this.print_newline();\n  } else if (this._flags.last_token.type === TOKEN.END_EXPR || this._flags.last_token.type === TOKEN.START_EXPR || this._flags.last_token.type === TOKEN.END_BLOCK || this._flags.last_token.text === '.' || this._flags.last_token.type === TOKEN.COMMA) {\n    // do nothing on (( and )( and ][ and ]( and .(\n    // TODO: Consider whether forcing this is required.  Review failing tests when removed.\n    this.allow_wrap_or_preserved_newline(current_token, current_token.newlines);\n  }\n\n  this.print_token(current_token);\n  this.set_mode(next_mode);\n  if (this._options.space_in_paren) {\n    this._output.space_before_token = true;\n  }\n\n  // In all cases, if we newline while inside an expression it should be indented.\n  this.indent();\n};\n\nBeautifier.prototype.handle_end_expr = function(current_token) {\n  // statements inside expressions are not valid syntax, but...\n  // statements must all be closed when their container closes\n  while (this._flags.mode === MODE.Statement) {\n    this.restore_mode();\n  }\n\n  this.handle_whitespace_and_comments(current_token);\n\n  if (this._flags.multiline_frame) {\n    this.allow_wrap_or_preserved_newline(current_token,\n      current_token.text === ']' && is_array(this._flags.mode) && !this._options.keep_array_indentation);\n  }\n\n  if (this._options.space_in_paren) {\n    if (this._flags.last_token.type === TOKEN.START_EXPR && !this._options.space_in_empty_paren) {\n      // () [] no inner space in empty parens like these, ever, ref #320\n      this._output.trim();\n      this._output.space_before_token = false;\n    } else {\n      this._output.space_before_token = true;\n    }\n  }\n  this.deindent();\n  this.print_token(current_token);\n  this.restore_mode();\n\n  remove_redundant_indentation(this._output, this._previous_flags);\n\n  // do {} while () // no statement required after\n  if (this._flags.do_while && this._previous_flags.mode === MODE.Conditional) {\n    this._previous_flags.mode = MODE.Expression;\n    this._flags.do_block = false;\n    this._flags.do_while = false;\n\n  }\n};\n\nBeautifier.prototype.handle_start_block = function(current_token) {\n  this.handle_whitespace_and_comments(current_token);\n\n  // Check if this is should be treated as a ObjectLiteral\n  var next_token = this._tokens.peek();\n  var second_token = this._tokens.peek(1);\n  if (this._flags.last_word === 'switch' && this._flags.last_token.type === TOKEN.END_EXPR) {\n    this.set_mode(MODE.BlockStatement);\n    this._flags.in_case_statement = true;\n  } else if (this._flags.case_body) {\n    this.set_mode(MODE.BlockStatement);\n  } else if (second_token && (\n      (in_array(second_token.text, [':', ',']) && in_array(next_token.type, [TOKEN.STRING, TOKEN.WORD, TOKEN.RESERVED])) ||\n      (in_array(next_token.text, ['get', 'set', '...']) && in_array(second_token.type, [TOKEN.WORD, TOKEN.RESERVED]))\n    )) {\n    // We don't support TypeScript,but we didn't break it for a very long time.\n    // We'll try to keep not breaking it.\n    if (!in_array(this._last_last_text, ['class', 'interface'])) {\n      this.set_mode(MODE.ObjectLiteral);\n    } else {\n      this.set_mode(MODE.BlockStatement);\n    }\n  } else if (this._flags.last_token.type === TOKEN.OPERATOR && this._flags.last_token.text === '=>') {\n    // arrow function: (param1, paramN) => { statements }\n    this.set_mode(MODE.BlockStatement);\n  } else if (in_array(this._flags.last_token.type, [TOKEN.EQUALS, TOKEN.START_EXPR, TOKEN.COMMA, TOKEN.OPERATOR]) ||\n    reserved_array(this._flags.last_token, ['return', 'throw', 'import', 'default'])\n  ) {\n    // Detecting shorthand function syntax is difficult by scanning forward,\n    //     so check the surrounding context.\n    // If the block is being returned, imported, export default, passed as arg,\n    //     assigned with = or assigned in a nested object, treat as an ObjectLiteral.\n    this.set_mode(MODE.ObjectLiteral);\n  } else {\n    this.set_mode(MODE.BlockStatement);\n  }\n\n  var empty_braces = !next_token.comments_before && next_token.text === '}';\n  var empty_anonymous_function = empty_braces && this._flags.last_word === 'function' &&\n    this._flags.last_token.type === TOKEN.END_EXPR;\n\n  if (this._options.brace_preserve_inline) // check for inline, set inline_frame if so\n  {\n    // search forward for a newline wanted inside this block\n    var index = 0;\n    var check_token = null;\n    this._flags.inline_frame = true;\n    do {\n      index += 1;\n      check_token = this._tokens.peek(index - 1);\n      if (check_token.newlines) {\n        this._flags.inline_frame = false;\n        break;\n      }\n    } while (check_token.type !== TOKEN.EOF &&\n      !(check_token.type === TOKEN.END_BLOCK && check_token.opened === current_token));\n  }\n\n  if ((this._options.brace_style === \"expand\" ||\n      (this._options.brace_style === \"none\" && current_token.newlines)) &&\n    !this._flags.inline_frame) {\n    if (this._flags.last_token.type !== TOKEN.OPERATOR &&\n      (empty_anonymous_function ||\n        this._flags.last_token.type === TOKEN.EQUALS ||\n        (reserved_array(this._flags.last_token, special_words) && this._flags.last_token.text !== 'else'))) {\n      this._output.space_before_token = true;\n    } else {\n      this.print_newline(false, true);\n    }\n  } else { // collapse || inline_frame\n    if (is_array(this._previous_flags.mode) && (this._flags.last_token.type === TOKEN.START_EXPR || this._flags.last_token.type === TOKEN.COMMA)) {\n      if (this._flags.last_token.type === TOKEN.COMMA || this._options.space_in_paren) {\n        this._output.space_before_token = true;\n      }\n\n      if (this._flags.last_token.type === TOKEN.COMMA || (this._flags.last_token.type === TOKEN.START_EXPR && this._flags.inline_frame)) {\n        this.allow_wrap_or_preserved_newline(current_token);\n        this._previous_flags.multiline_frame = this._previous_flags.multiline_frame || this._flags.multiline_frame;\n        this._flags.multiline_frame = false;\n      }\n    }\n    if (this._flags.last_token.type !== TOKEN.OPERATOR && this._flags.last_token.type !== TOKEN.START_EXPR) {\n      if (this._flags.last_token.type === TOKEN.START_BLOCK && !this._flags.inline_frame) {\n        this.print_newline();\n      } else {\n        this._output.space_before_token = true;\n      }\n    }\n  }\n  this.print_token(current_token);\n  this.indent();\n\n  // Except for specific cases, open braces are followed by a new line.\n  if (!empty_braces && !(this._options.brace_preserve_inline && this._flags.inline_frame)) {\n    this.print_newline();\n  }\n};\n\nBeautifier.prototype.handle_end_block = function(current_token) {\n  // statements must all be closed when their container closes\n  this.handle_whitespace_and_comments(current_token);\n\n  while (this._flags.mode === MODE.Statement) {\n    this.restore_mode();\n  }\n\n  var empty_braces = this._flags.last_token.type === TOKEN.START_BLOCK;\n\n  if (this._flags.inline_frame && !empty_braces) { // try inline_frame (only set if this._options.braces-preserve-inline) first\n    this._output.space_before_token = true;\n  } else if (this._options.brace_style === \"expand\") {\n    if (!empty_braces) {\n      this.print_newline();\n    }\n  } else {\n    // skip {}\n    if (!empty_braces) {\n      if (is_array(this._flags.mode) && this._options.keep_array_indentation) {\n        // we REALLY need a newline here, but newliner would skip that\n        this._options.keep_array_indentation = false;\n        this.print_newline();\n        this._options.keep_array_indentation = true;\n\n      } else {\n        this.print_newline();\n      }\n    }\n  }\n  this.restore_mode();\n  this.print_token(current_token);\n};\n\nBeautifier.prototype.handle_word = function(current_token) {\n  if (current_token.type === TOKEN.RESERVED) {\n    if (in_array(current_token.text, ['set', 'get']) && this._flags.mode !== MODE.ObjectLiteral) {\n      current_token.type = TOKEN.WORD;\n    } else if (current_token.text === 'import' && this._tokens.peek().text === '(') {\n      current_token.type = TOKEN.WORD;\n    } else if (in_array(current_token.text, ['as', 'from']) && !this._flags.import_block) {\n      current_token.type = TOKEN.WORD;\n    } else if (this._flags.mode === MODE.ObjectLiteral) {\n      var next_token = this._tokens.peek();\n      if (next_token.text === ':') {\n        current_token.type = TOKEN.WORD;\n      }\n    }\n  }\n\n  if (this.start_of_statement(current_token)) {\n    // The conditional starts the statement if appropriate.\n    if (reserved_array(this._flags.last_token, ['var', 'let', 'const']) && current_token.type === TOKEN.WORD) {\n      this._flags.declaration_statement = true;\n    }\n  } else if (current_token.newlines && !is_expression(this._flags.mode) &&\n    (this._flags.last_token.type !== TOKEN.OPERATOR || (this._flags.last_token.text === '--' || this._flags.last_token.text === '++')) &&\n    this._flags.last_token.type !== TOKEN.EQUALS &&\n    (this._options.preserve_newlines || !reserved_array(this._flags.last_token, ['var', 'let', 'const', 'set', 'get']))) {\n    this.handle_whitespace_and_comments(current_token);\n    this.print_newline();\n  } else {\n    this.handle_whitespace_and_comments(current_token);\n  }\n\n  if (this._flags.do_block && !this._flags.do_while) {\n    if (reserved_word(current_token, 'while')) {\n      // do {} ## while ()\n      this._output.space_before_token = true;\n      this.print_token(current_token);\n      this._output.space_before_token = true;\n      this._flags.do_while = true;\n      return;\n    } else {\n      // do {} should always have while as the next word.\n      // if we don't see the expected while, recover\n      this.print_newline();\n      this._flags.do_block = false;\n    }\n  }\n\n  // if may be followed by else, or not\n  // Bare/inline ifs are tricky\n  // Need to unwind the modes correctly: if (a) if (b) c(); else d(); else e();\n  if (this._flags.if_block) {\n    if (!this._flags.else_block && reserved_word(current_token, 'else')) {\n      this._flags.else_block = true;\n    } else {\n      while (this._flags.mode === MODE.Statement) {\n        this.restore_mode();\n      }\n      this._flags.if_block = false;\n      this._flags.else_block = false;\n    }\n  }\n\n  if (this._flags.in_case_statement && reserved_array(current_token, ['case', 'default'])) {\n    this.print_newline();\n    if (this._flags.last_token.type !== TOKEN.END_BLOCK && (this._flags.case_body || this._options.jslint_happy)) {\n      // switch cases following one another\n      this.deindent();\n    }\n    this._flags.case_body = false;\n\n    this.print_token(current_token);\n    this._flags.in_case = true;\n    return;\n  }\n\n  if (this._flags.last_token.type === TOKEN.COMMA || this._flags.last_token.type === TOKEN.START_EXPR || this._flags.last_token.type === TOKEN.EQUALS || this._flags.last_token.type === TOKEN.OPERATOR) {\n    if (!this.start_of_object_property()) {\n      this.allow_wrap_or_preserved_newline(current_token);\n    }\n  }\n\n  if (reserved_word(current_token, 'function')) {\n    if (in_array(this._flags.last_token.text, ['}', ';']) ||\n      (this._output.just_added_newline() && !(in_array(this._flags.last_token.text, ['(', '[', '{', ':', '=', ',']) || this._flags.last_token.type === TOKEN.OPERATOR))) {\n      // make sure there is a nice clean space of at least one blank line\n      // before a new function definition\n      if (!this._output.just_added_blankline() && !current_token.comments_before) {\n        this.print_newline();\n        this.print_newline(true);\n      }\n    }\n    if (this._flags.last_token.type === TOKEN.RESERVED || this._flags.last_token.type === TOKEN.WORD) {\n      if (reserved_array(this._flags.last_token, ['get', 'set', 'new', 'export']) ||\n        reserved_array(this._flags.last_token, newline_restricted_tokens)) {\n        this._output.space_before_token = true;\n      } else if (reserved_word(this._flags.last_token, 'default') && this._last_last_text === 'export') {\n        this._output.space_before_token = true;\n      } else if (this._flags.last_token.text === 'declare') {\n        // accomodates Typescript declare function formatting\n        this._output.space_before_token = true;\n      } else {\n        this.print_newline();\n      }\n    } else if (this._flags.last_token.type === TOKEN.OPERATOR || this._flags.last_token.text === '=') {\n      // foo = function\n      this._output.space_before_token = true;\n    } else if (!this._flags.multiline_frame && (is_expression(this._flags.mode) || is_array(this._flags.mode))) {\n      // (function\n    } else {\n      this.print_newline();\n    }\n\n    this.print_token(current_token);\n    this._flags.last_word = current_token.text;\n    return;\n  }\n\n  var prefix = 'NONE';\n\n  if (this._flags.last_token.type === TOKEN.END_BLOCK) {\n\n    if (this._previous_flags.inline_frame) {\n      prefix = 'SPACE';\n    } else if (!reserved_array(current_token, ['else', 'catch', 'finally', 'from'])) {\n      prefix = 'NEWLINE';\n    } else {\n      if (this._options.brace_style === \"expand\" ||\n        this._options.brace_style === \"end-expand\" ||\n        (this._options.brace_style === \"none\" && current_token.newlines)) {\n        prefix = 'NEWLINE';\n      } else {\n        prefix = 'SPACE';\n        this._output.space_before_token = true;\n      }\n    }\n  } else if (this._flags.last_token.type === TOKEN.SEMICOLON && this._flags.mode === MODE.BlockStatement) {\n    // TODO: Should this be for STATEMENT as well?\n    prefix = 'NEWLINE';\n  } else if (this._flags.last_token.type === TOKEN.SEMICOLON && is_expression(this._flags.mode)) {\n    prefix = 'SPACE';\n  } else if (this._flags.last_token.type === TOKEN.STRING) {\n    prefix = 'NEWLINE';\n  } else if (this._flags.last_token.type === TOKEN.RESERVED || this._flags.last_token.type === TOKEN.WORD ||\n    (this._flags.last_token.text === '*' &&\n      (in_array(this._last_last_text, ['function', 'yield']) ||\n        (this._flags.mode === MODE.ObjectLiteral && in_array(this._last_last_text, ['{', ',']))))) {\n    prefix = 'SPACE';\n  } else if (this._flags.last_token.type === TOKEN.START_BLOCK) {\n    if (this._flags.inline_frame) {\n      prefix = 'SPACE';\n    } else {\n      prefix = 'NEWLINE';\n    }\n  } else if (this._flags.last_token.type === TOKEN.END_EXPR) {\n    this._output.space_before_token = true;\n    prefix = 'NEWLINE';\n  }\n\n  if (reserved_array(current_token, line_starters) && this._flags.last_token.text !== ')') {\n    if (this._flags.inline_frame || this._flags.last_token.text === 'else' || this._flags.last_token.text === 'export') {\n      prefix = 'SPACE';\n    } else {\n      prefix = 'NEWLINE';\n    }\n\n  }\n\n  if (reserved_array(current_token, ['else', 'catch', 'finally'])) {\n    if ((!(this._flags.last_token.type === TOKEN.END_BLOCK && this._previous_flags.mode === MODE.BlockStatement) ||\n        this._options.brace_style === \"expand\" ||\n        this._options.brace_style === \"end-expand\" ||\n        (this._options.brace_style === \"none\" && current_token.newlines)) &&\n      !this._flags.inline_frame) {\n      this.print_newline();\n    } else {\n      this._output.trim(true);\n      var line = this._output.current_line;\n      // If we trimmed and there's something other than a close block before us\n      // put a newline back in.  Handles '} // comment' scenario.\n      if (line.last() !== '}') {\n        this.print_newline();\n      }\n      this._output.space_before_token = true;\n    }\n  } else if (prefix === 'NEWLINE') {\n    if (reserved_array(this._flags.last_token, special_words)) {\n      // no newline between 'return nnn'\n      this._output.space_before_token = true;\n    } else if (this._flags.last_token.text === 'declare' && reserved_array(current_token, ['var', 'let', 'const'])) {\n      // accomodates Typescript declare formatting\n      this._output.space_before_token = true;\n    } else if (this._flags.last_token.type !== TOKEN.END_EXPR) {\n      if ((this._flags.last_token.type !== TOKEN.START_EXPR || !reserved_array(current_token, ['var', 'let', 'const'])) && this._flags.last_token.text !== ':') {\n        // no need to force newline on 'var': for (var x = 0...)\n        if (reserved_word(current_token, 'if') && reserved_word(current_token.previous, 'else')) {\n          // no newline for } else if {\n          this._output.space_before_token = true;\n        } else {\n          this.print_newline();\n        }\n      }\n    } else if (reserved_array(current_token, line_starters) && this._flags.last_token.text !== ')') {\n      this.print_newline();\n    }\n  } else if (this._flags.multiline_frame && is_array(this._flags.mode) && this._flags.last_token.text === ',' && this._last_last_text === '}') {\n    this.print_newline(); // }, in lists get a newline treatment\n  } else if (prefix === 'SPACE') {\n    this._output.space_before_token = true;\n  }\n  if (current_token.previous && (current_token.previous.type === TOKEN.WORD || current_token.previous.type === TOKEN.RESERVED)) {\n    this._output.space_before_token = true;\n  }\n  this.print_token(current_token);\n  this._flags.last_word = current_token.text;\n\n  if (current_token.type === TOKEN.RESERVED) {\n    if (current_token.text === 'do') {\n      this._flags.do_block = true;\n    } else if (current_token.text === 'if') {\n      this._flags.if_block = true;\n    } else if (current_token.text === 'import') {\n      this._flags.import_block = true;\n    } else if (this._flags.import_block && reserved_word(current_token, 'from')) {\n      this._flags.import_block = false;\n    }\n  }\n};\n\nBeautifier.prototype.handle_semicolon = function(current_token) {\n  if (this.start_of_statement(current_token)) {\n    // The conditional starts the statement if appropriate.\n    // Semicolon can be the start (and end) of a statement\n    this._output.space_before_token = false;\n  } else {\n    this.handle_whitespace_and_comments(current_token);\n  }\n\n  var next_token = this._tokens.peek();\n  while (this._flags.mode === MODE.Statement &&\n    !(this._flags.if_block && reserved_word(next_token, 'else')) &&\n    !this._flags.do_block) {\n    this.restore_mode();\n  }\n\n  // hacky but effective for the moment\n  if (this._flags.import_block) {\n    this._flags.import_block = false;\n  }\n  this.print_token(current_token);\n};\n\nBeautifier.prototype.handle_string = function(current_token) {\n  if (this.start_of_statement(current_token)) {\n    // The conditional starts the statement if appropriate.\n    // One difference - strings want at least a space before\n    this._output.space_before_token = true;\n  } else {\n    this.handle_whitespace_and_comments(current_token);\n    if (this._flags.last_token.type === TOKEN.RESERVED || this._flags.last_token.type === TOKEN.WORD || this._flags.inline_frame) {\n      this._output.space_before_token = true;\n    } else if (this._flags.last_token.type === TOKEN.COMMA || this._flags.last_token.type === TOKEN.START_EXPR || this._flags.last_token.type === TOKEN.EQUALS || this._flags.last_token.type === TOKEN.OPERATOR) {\n      if (!this.start_of_object_property()) {\n        this.allow_wrap_or_preserved_newline(current_token);\n      }\n    } else {\n      this.print_newline();\n    }\n  }\n  this.print_token(current_token);\n};\n\nBeautifier.prototype.handle_equals = function(current_token) {\n  if (this.start_of_statement(current_token)) {\n    // The conditional starts the statement if appropriate.\n  } else {\n    this.handle_whitespace_and_comments(current_token);\n  }\n\n  if (this._flags.declaration_statement) {\n    // just got an '=' in a var-line, different formatting/line-breaking, etc will now be done\n    this._flags.declaration_assignment = true;\n  }\n  this._output.space_before_token = true;\n  this.print_token(current_token);\n  this._output.space_before_token = true;\n};\n\nBeautifier.prototype.handle_comma = function(current_token) {\n  this.handle_whitespace_and_comments(current_token, true);\n\n  this.print_token(current_token);\n  this._output.space_before_token = true;\n  if (this._flags.declaration_statement) {\n    if (is_expression(this._flags.parent.mode)) {\n      // do not break on comma, for(var a = 1, b = 2)\n      this._flags.declaration_assignment = false;\n    }\n\n    if (this._flags.declaration_assignment) {\n      this._flags.declaration_assignment = false;\n      this.print_newline(false, true);\n    } else if (this._options.comma_first) {\n      // for comma-first, we want to allow a newline before the comma\n      // to turn into a newline after the comma, which we will fixup later\n      this.allow_wrap_or_preserved_newline(current_token);\n    }\n  } else if (this._flags.mode === MODE.ObjectLiteral ||\n    (this._flags.mode === MODE.Statement && this._flags.parent.mode === MODE.ObjectLiteral)) {\n    if (this._flags.mode === MODE.Statement) {\n      this.restore_mode();\n    }\n\n    if (!this._flags.inline_frame) {\n      this.print_newline();\n    }\n  } else if (this._options.comma_first) {\n    // EXPR or DO_BLOCK\n    // for comma-first, we want to allow a newline before the comma\n    // to turn into a newline after the comma, which we will fixup later\n    this.allow_wrap_or_preserved_newline(current_token);\n  }\n};\n\nBeautifier.prototype.handle_operator = function(current_token) {\n  var isGeneratorAsterisk = current_token.text === '*' &&\n    (reserved_array(this._flags.last_token, ['function', 'yield']) ||\n      (in_array(this._flags.last_token.type, [TOKEN.START_BLOCK, TOKEN.COMMA, TOKEN.END_BLOCK, TOKEN.SEMICOLON]))\n    );\n  var isUnary = in_array(current_token.text, ['-', '+']) && (\n    in_array(this._flags.last_token.type, [TOKEN.START_BLOCK, TOKEN.START_EXPR, TOKEN.EQUALS, TOKEN.OPERATOR]) ||\n    in_array(this._flags.last_token.text, line_starters) ||\n    this._flags.last_token.text === ','\n  );\n\n  if (this.start_of_statement(current_token)) {\n    // The conditional starts the statement if appropriate.\n  } else {\n    var preserve_statement_flags = !isGeneratorAsterisk;\n    this.handle_whitespace_and_comments(current_token, preserve_statement_flags);\n  }\n\n  if (reserved_array(this._flags.last_token, special_words)) {\n    // \"return\" had a special handling in TK_WORD. Now we need to return the favor\n    this._output.space_before_token = true;\n    this.print_token(current_token);\n    return;\n  }\n\n  // hack for actionscript's import .*;\n  if (current_token.text === '*' && this._flags.last_token.type === TOKEN.DOT) {\n    this.print_token(current_token);\n    return;\n  }\n\n  if (current_token.text === '::') {\n    // no spaces around exotic namespacing syntax operator\n    this.print_token(current_token);\n    return;\n  }\n\n  // Allow line wrapping between operators when operator_position is\n  //   set to before or preserve\n  if (this._flags.last_token.type === TOKEN.OPERATOR && in_array(this._options.operator_position, OPERATOR_POSITION_BEFORE_OR_PRESERVE)) {\n    this.allow_wrap_or_preserved_newline(current_token);\n  }\n\n  if (current_token.text === ':' && this._flags.in_case) {\n    this.print_token(current_token);\n\n    this._flags.in_case = false;\n    this._flags.case_body = true;\n    if (this._tokens.peek().type !== TOKEN.START_BLOCK) {\n      this.indent();\n      this.print_newline();\n    } else {\n      this._output.space_before_token = true;\n    }\n    return;\n  }\n\n  var space_before = true;\n  var space_after = true;\n  var in_ternary = false;\n  if (current_token.text === ':') {\n    if (this._flags.ternary_depth === 0) {\n      // Colon is invalid javascript outside of ternary and object, but do our best to guess what was meant.\n      space_before = false;\n    } else {\n      this._flags.ternary_depth -= 1;\n      in_ternary = true;\n    }\n  } else if (current_token.text === '?') {\n    this._flags.ternary_depth += 1;\n  }\n\n  // let's handle the operator_position option prior to any conflicting logic\n  if (!isUnary && !isGeneratorAsterisk && this._options.preserve_newlines && in_array(current_token.text, positionable_operators)) {\n    var isColon = current_token.text === ':';\n    var isTernaryColon = (isColon && in_ternary);\n    var isOtherColon = (isColon && !in_ternary);\n\n    switch (this._options.operator_position) {\n      case OPERATOR_POSITION.before_newline:\n        // if the current token is : and it's not a ternary statement then we set space_before to false\n        this._output.space_before_token = !isOtherColon;\n\n        this.print_token(current_token);\n\n        if (!isColon || isTernaryColon) {\n          this.allow_wrap_or_preserved_newline(current_token);\n        }\n\n        this._output.space_before_token = true;\n        return;\n\n      case OPERATOR_POSITION.after_newline:\n        // if the current token is anything but colon, or (via deduction) it's a colon and in a ternary statement,\n        //   then print a newline.\n\n        this._output.space_before_token = true;\n\n        if (!isColon || isTernaryColon) {\n          if (this._tokens.peek().newlines) {\n            this.print_newline(false, true);\n          } else {\n            this.allow_wrap_or_preserved_newline(current_token);\n          }\n        } else {\n          this._output.space_before_token = false;\n        }\n\n        this.print_token(current_token);\n\n        this._output.space_before_token = true;\n        return;\n\n      case OPERATOR_POSITION.preserve_newline:\n        if (!isOtherColon) {\n          this.allow_wrap_or_preserved_newline(current_token);\n        }\n\n        // if we just added a newline, or the current token is : and it's not a ternary statement,\n        //   then we set space_before to false\n        space_before = !(this._output.just_added_newline() || isOtherColon);\n\n        this._output.space_before_token = space_before;\n        this.print_token(current_token);\n        this._output.space_before_token = true;\n        return;\n    }\n  }\n\n  if (isGeneratorAsterisk) {\n    this.allow_wrap_or_preserved_newline(current_token);\n    space_before = false;\n    var next_token = this._tokens.peek();\n    space_after = next_token && in_array(next_token.type, [TOKEN.WORD, TOKEN.RESERVED]);\n  } else if (current_token.text === '...') {\n    this.allow_wrap_or_preserved_newline(current_token);\n    space_before = this._flags.last_token.type === TOKEN.START_BLOCK;\n    space_after = false;\n  } else if (in_array(current_token.text, ['--', '++', '!', '~']) || isUnary) {\n    // unary operators (and binary +/- pretending to be unary) special cases\n    if (this._flags.last_token.type === TOKEN.COMMA || this._flags.last_token.type === TOKEN.START_EXPR) {\n      this.allow_wrap_or_preserved_newline(current_token);\n    }\n\n    space_before = false;\n    space_after = false;\n\n    // http://www.ecma-international.org/ecma-262/5.1/#sec-7.9.1\n    // if there is a newline between -- or ++ and anything else we should preserve it.\n    if (current_token.newlines && (current_token.text === '--' || current_token.text === '++')) {\n      this.print_newline(false, true);\n    }\n\n    if (this._flags.last_token.text === ';' && is_expression(this._flags.mode)) {\n      // for (;; ++i)\n      //        ^^^\n      space_before = true;\n    }\n\n    if (this._flags.last_token.type === TOKEN.RESERVED) {\n      space_before = true;\n    } else if (this._flags.last_token.type === TOKEN.END_EXPR) {\n      space_before = !(this._flags.last_token.text === ']' && (current_token.text === '--' || current_token.text === '++'));\n    } else if (this._flags.last_token.type === TOKEN.OPERATOR) {\n      // a++ + ++b;\n      // a - -b\n      space_before = in_array(current_token.text, ['--', '-', '++', '+']) && in_array(this._flags.last_token.text, ['--', '-', '++', '+']);\n      // + and - are not unary when preceeded by -- or ++ operator\n      // a-- + b\n      // a * +b\n      // a - -b\n      if (in_array(current_token.text, ['+', '-']) && in_array(this._flags.last_token.text, ['--', '++'])) {\n        space_after = true;\n      }\n    }\n\n\n    if (((this._flags.mode === MODE.BlockStatement && !this._flags.inline_frame) || this._flags.mode === MODE.Statement) &&\n      (this._flags.last_token.text === '{' || this._flags.last_token.text === ';')) {\n      // { foo; --i }\n      // foo(); --bar;\n      this.print_newline();\n    }\n  }\n\n  this._output.space_before_token = this._output.space_before_token || space_before;\n  this.print_token(current_token);\n  this._output.space_before_token = space_after;\n};\n\nBeautifier.prototype.handle_block_comment = function(current_token, preserve_statement_flags) {\n  if (this._output.raw) {\n    this._output.add_raw_token(current_token);\n    if (current_token.directives && current_token.directives.preserve === 'end') {\n      // If we're testing the raw output behavior, do not allow a directive to turn it off.\n      this._output.raw = this._options.test_output_raw;\n    }\n    return;\n  }\n\n  if (current_token.directives) {\n    this.print_newline(false, preserve_statement_flags);\n    this.print_token(current_token);\n    if (current_token.directives.preserve === 'start') {\n      this._output.raw = true;\n    }\n    this.print_newline(false, true);\n    return;\n  }\n\n  // inline block\n  if (!acorn.newline.test(current_token.text) && !current_token.newlines) {\n    this._output.space_before_token = true;\n    this.print_token(current_token);\n    this._output.space_before_token = true;\n    return;\n  } else {\n    this.print_block_commment(current_token, preserve_statement_flags);\n  }\n};\n\nBeautifier.prototype.print_block_commment = function(current_token, preserve_statement_flags) {\n  var lines = split_linebreaks(current_token.text);\n  var j; // iterator for this case\n  var javadoc = false;\n  var starless = false;\n  var lastIndent = current_token.whitespace_before;\n  var lastIndentLength = lastIndent.length;\n\n  // block comment starts with a new line\n  this.print_newline(false, preserve_statement_flags);\n\n  // first line always indented\n  this.print_token_line_indentation(current_token);\n  this._output.add_token(lines[0]);\n  this.print_newline(false, preserve_statement_flags);\n\n\n  if (lines.length > 1) {\n    lines = lines.slice(1);\n    javadoc = all_lines_start_with(lines, '*');\n    starless = each_line_matches_indent(lines, lastIndent);\n\n    if (javadoc) {\n      this._flags.alignment = 1;\n    }\n\n    for (j = 0; j < lines.length; j++) {\n      if (javadoc) {\n        // javadoc: reformat and re-indent\n        this.print_token_line_indentation(current_token);\n        this._output.add_token(ltrim(lines[j]));\n      } else if (starless && lines[j]) {\n        // starless: re-indent non-empty content, avoiding trim\n        this.print_token_line_indentation(current_token);\n        this._output.add_token(lines[j].substring(lastIndentLength));\n      } else {\n        // normal comments output raw\n        this._output.current_line.set_indent(-1);\n        this._output.add_token(lines[j]);\n      }\n\n      // for comments on their own line or  more than one line, make sure there's a new line after\n      this.print_newline(false, preserve_statement_flags);\n    }\n\n    this._flags.alignment = 0;\n  }\n};\n\n\nBeautifier.prototype.handle_comment = function(current_token, preserve_statement_flags) {\n  if (current_token.newlines) {\n    this.print_newline(false, preserve_statement_flags);\n  } else {\n    this._output.trim(true);\n  }\n\n  this._output.space_before_token = true;\n  this.print_token(current_token);\n  this.print_newline(false, preserve_statement_flags);\n};\n\nBeautifier.prototype.handle_dot = function(current_token) {\n  if (this.start_of_statement(current_token)) {\n    // The conditional starts the statement if appropriate.\n  } else {\n    this.handle_whitespace_and_comments(current_token, true);\n  }\n\n  if (reserved_array(this._flags.last_token, special_words)) {\n    this._output.space_before_token = false;\n  } else {\n    // allow preserved newlines before dots in general\n    // force newlines on dots after close paren when break_chained - for bar().baz()\n    this.allow_wrap_or_preserved_newline(current_token,\n      this._flags.last_token.text === ')' && this._options.break_chained_methods);\n  }\n\n  // Only unindent chained method dot if this dot starts a new line.\n  // Otherwise the automatic extra indentation removal will handle the over indent\n  if (this._options.unindent_chained_methods && this._output.just_added_newline()) {\n    this.deindent();\n  }\n\n  this.print_token(current_token);\n};\n\nBeautifier.prototype.handle_unknown = function(current_token, preserve_statement_flags) {\n  this.print_token(current_token);\n\n  if (current_token.text[current_token.text.length - 1] === '\\n') {\n    this.print_newline(false, preserve_statement_flags);\n  }\n};\n\nBeautifier.prototype.handle_eof = function(current_token) {\n  // Unwind any open statements\n  while (this._flags.mode === MODE.Statement) {\n    this.restore_mode();\n  }\n  this.handle_whitespace_and_comments(current_token);\n};\n\nmodule.exports.Beautifier = Beautifier;\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*jshint node:true */\n/*\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/\n\n\n\nfunction OutputLine(parent) {\n  this.__parent = parent;\n  this.__character_count = 0;\n  // use indent_count as a marker for this.__lines that have preserved indentation\n  this.__indent_count = -1;\n  this.__alignment_count = 0;\n  this.__wrap_point_index = 0;\n  this.__wrap_point_character_count = 0;\n  this.__wrap_point_indent_count = -1;\n  this.__wrap_point_alignment_count = 0;\n\n  this.__items = [];\n}\n\nOutputLine.prototype.clone_empty = function() {\n  var line = new OutputLine(this.__parent);\n  line.set_indent(this.__indent_count, this.__alignment_count);\n  return line;\n};\n\nOutputLine.prototype.item = function(index) {\n  if (index < 0) {\n    return this.__items[this.__items.length + index];\n  } else {\n    return this.__items[index];\n  }\n};\n\nOutputLine.prototype.has_match = function(pattern) {\n  for (var lastCheckedOutput = this.__items.length - 1; lastCheckedOutput >= 0; lastCheckedOutput--) {\n    if (this.__items[lastCheckedOutput].match(pattern)) {\n      return true;\n    }\n  }\n  return false;\n};\n\nOutputLine.prototype.set_indent = function(indent, alignment) {\n  if (this.is_empty()) {\n    this.__indent_count = indent || 0;\n    this.__alignment_count = alignment || 0;\n    this.__character_count = this.__parent.get_indent_size(this.__indent_count, this.__alignment_count);\n  }\n};\n\nOutputLine.prototype._set_wrap_point = function() {\n  if (this.__parent.wrap_line_length) {\n    this.__wrap_point_index = this.__items.length;\n    this.__wrap_point_character_count = this.__character_count;\n    this.__wrap_point_indent_count = this.__parent.next_line.__indent_count;\n    this.__wrap_point_alignment_count = this.__parent.next_line.__alignment_count;\n  }\n};\n\nOutputLine.prototype._should_wrap = function() {\n  return this.__wrap_point_index &&\n    this.__character_count > this.__parent.wrap_line_length &&\n    this.__wrap_point_character_count > this.__parent.next_line.__character_count;\n};\n\nOutputLine.prototype._allow_wrap = function() {\n  if (this._should_wrap()) {\n    this.__parent.add_new_line();\n    var next = this.__parent.current_line;\n    next.set_indent(this.__wrap_point_indent_count, this.__wrap_point_alignment_count);\n    next.__items = this.__items.slice(this.__wrap_point_index);\n    this.__items = this.__items.slice(0, this.__wrap_point_index);\n\n    next.__character_count += this.__character_count - this.__wrap_point_character_count;\n    this.__character_count = this.__wrap_point_character_count;\n\n    if (next.__items[0] === \" \") {\n      next.__items.splice(0, 1);\n      next.__character_count -= 1;\n    }\n    return true;\n  }\n  return false;\n};\n\nOutputLine.prototype.is_empty = function() {\n  return this.__items.length === 0;\n};\n\nOutputLine.prototype.last = function() {\n  if (!this.is_empty()) {\n    return this.__items[this.__items.length - 1];\n  } else {\n    return null;\n  }\n};\n\nOutputLine.prototype.push = function(item) {\n  this.__items.push(item);\n  var last_newline_index = item.lastIndexOf('\\n');\n  if (last_newline_index !== -1) {\n    this.__character_count = item.length - last_newline_index;\n  } else {\n    this.__character_count += item.length;\n  }\n};\n\nOutputLine.prototype.pop = function() {\n  var item = null;\n  if (!this.is_empty()) {\n    item = this.__items.pop();\n    this.__character_count -= item.length;\n  }\n  return item;\n};\n\n\nOutputLine.prototype._remove_indent = function() {\n  if (this.__indent_count > 0) {\n    this.__indent_count -= 1;\n    this.__character_count -= this.__parent.indent_size;\n  }\n};\n\nOutputLine.prototype._remove_wrap_indent = function() {\n  if (this.__wrap_point_indent_count > 0) {\n    this.__wrap_point_indent_count -= 1;\n  }\n};\nOutputLine.prototype.trim = function() {\n  while (this.last() === ' ') {\n    this.__items.pop();\n    this.__character_count -= 1;\n  }\n};\n\nOutputLine.prototype.toString = function() {\n  var result = '';\n  if (this.is_empty()) {\n    if (this.__parent.indent_empty_lines) {\n      result = this.__parent.get_indent_string(this.__indent_count);\n    }\n  } else {\n    result = this.__parent.get_indent_string(this.__indent_count, this.__alignment_count);\n    result += this.__items.join('');\n  }\n  return result;\n};\n\nfunction IndentStringCache(options, baseIndentString) {\n  this.__cache = [''];\n  this.__indent_size = options.indent_size;\n  this.__indent_string = options.indent_char;\n  if (!options.indent_with_tabs) {\n    this.__indent_string = new Array(options.indent_size + 1).join(options.indent_char);\n  }\n\n  // Set to null to continue support for auto detection of base indent\n  baseIndentString = baseIndentString || '';\n  if (options.indent_level > 0) {\n    baseIndentString = new Array(options.indent_level + 1).join(this.__indent_string);\n  }\n\n  this.__base_string = baseIndentString;\n  this.__base_string_length = baseIndentString.length;\n}\n\nIndentStringCache.prototype.get_indent_size = function(indent, column) {\n  var result = this.__base_string_length;\n  column = column || 0;\n  if (indent < 0) {\n    result = 0;\n  }\n  result += indent * this.__indent_size;\n  result += column;\n  return result;\n};\n\nIndentStringCache.prototype.get_indent_string = function(indent_level, column) {\n  var result = this.__base_string;\n  column = column || 0;\n  if (indent_level < 0) {\n    indent_level = 0;\n    result = '';\n  }\n  column += indent_level * this.__indent_size;\n  this.__ensure_cache(column);\n  result += this.__cache[column];\n  return result;\n};\n\nIndentStringCache.prototype.__ensure_cache = function(column) {\n  while (column >= this.__cache.length) {\n    this.__add_column();\n  }\n};\n\nIndentStringCache.prototype.__add_column = function() {\n  var column = this.__cache.length;\n  var indent = 0;\n  var result = '';\n  if (this.__indent_size && column >= this.__indent_size) {\n    indent = Math.floor(column / this.__indent_size);\n    column -= indent * this.__indent_size;\n    result = new Array(indent + 1).join(this.__indent_string);\n  }\n  if (column) {\n    result += new Array(column + 1).join(' ');\n  }\n\n  this.__cache.push(result);\n};\n\nfunction Output(options, baseIndentString) {\n  this.__indent_cache = new IndentStringCache(options, baseIndentString);\n  this.raw = false;\n  this._end_with_newline = options.end_with_newline;\n  this.indent_size = options.indent_size;\n  this.wrap_line_length = options.wrap_line_length;\n  this.indent_empty_lines = options.indent_empty_lines;\n  this.__lines = [];\n  this.previous_line = null;\n  this.current_line = null;\n  this.next_line = new OutputLine(this);\n  this.space_before_token = false;\n  this.non_breaking_space = false;\n  this.previous_token_wrapped = false;\n  // initialize\n  this.__add_outputline();\n}\n\nOutput.prototype.__add_outputline = function() {\n  this.previous_line = this.current_line;\n  this.current_line = this.next_line.clone_empty();\n  this.__lines.push(this.current_line);\n};\n\nOutput.prototype.get_line_number = function() {\n  return this.__lines.length;\n};\n\nOutput.prototype.get_indent_string = function(indent, column) {\n  return this.__indent_cache.get_indent_string(indent, column);\n};\n\nOutput.prototype.get_indent_size = function(indent, column) {\n  return this.__indent_cache.get_indent_size(indent, column);\n};\n\nOutput.prototype.is_empty = function() {\n  return !this.previous_line && this.current_line.is_empty();\n};\n\nOutput.prototype.add_new_line = function(force_newline) {\n  // never newline at the start of file\n  // otherwise, newline only if we didn't just add one or we're forced\n  if (this.is_empty() ||\n    (!force_newline && this.just_added_newline())) {\n    return false;\n  }\n\n  // if raw output is enabled, don't print additional newlines,\n  // but still return True as though you had\n  if (!this.raw) {\n    this.__add_outputline();\n  }\n  return true;\n};\n\nOutput.prototype.get_code = function(eol) {\n  this.trim(true);\n\n  // handle some edge cases where the last tokens\n  // has text that ends with newline(s)\n  var last_item = this.current_line.pop();\n  if (last_item) {\n    if (last_item[last_item.length - 1] === '\\n') {\n      last_item = last_item.replace(/\\n+$/g, '');\n    }\n    this.current_line.push(last_item);\n  }\n\n  if (this._end_with_newline) {\n    this.__add_outputline();\n  }\n\n  var sweet_code = this.__lines.join('\\n');\n\n  if (eol !== '\\n') {\n    sweet_code = sweet_code.replace(/[\\n]/g, eol);\n  }\n  return sweet_code;\n};\n\nOutput.prototype.set_wrap_point = function() {\n  this.current_line._set_wrap_point();\n};\n\nOutput.prototype.set_indent = function(indent, alignment) {\n  indent = indent || 0;\n  alignment = alignment || 0;\n\n  // Next line stores alignment values\n  this.next_line.set_indent(indent, alignment);\n\n  // Never indent your first output indent at the start of the file\n  if (this.__lines.length > 1) {\n    this.current_line.set_indent(indent, alignment);\n    return true;\n  }\n\n  this.current_line.set_indent();\n  return false;\n};\n\nOutput.prototype.add_raw_token = function(token) {\n  for (var x = 0; x < token.newlines; x++) {\n    this.__add_outputline();\n  }\n  this.current_line.set_indent(-1);\n  this.current_line.push(token.whitespace_before);\n  this.current_line.push(token.text);\n  this.space_before_token = false;\n  this.non_breaking_space = false;\n  this.previous_token_wrapped = false;\n};\n\nOutput.prototype.add_token = function(printable_token) {\n  this.__add_space_before_token();\n  this.current_line.push(printable_token);\n  this.space_before_token = false;\n  this.non_breaking_space = false;\n  this.previous_token_wrapped = this.current_line._allow_wrap();\n};\n\nOutput.prototype.__add_space_before_token = function() {\n  if (this.space_before_token && !this.just_added_newline()) {\n    if (!this.non_breaking_space) {\n      this.set_wrap_point();\n    }\n    this.current_line.push(' ');\n  }\n};\n\nOutput.prototype.remove_indent = function(index) {\n  var output_length = this.__lines.length;\n  while (index < output_length) {\n    this.__lines[index]._remove_indent();\n    index++;\n  }\n  this.current_line._remove_wrap_indent();\n};\n\nOutput.prototype.trim = function(eat_newlines) {\n  eat_newlines = (eat_newlines === undefined) ? false : eat_newlines;\n\n  this.current_line.trim();\n\n  while (eat_newlines && this.__lines.length > 1 &&\n    this.current_line.is_empty()) {\n    this.__lines.pop();\n    this.current_line = this.__lines[this.__lines.length - 1];\n    this.current_line.trim();\n  }\n\n  this.previous_line = this.__lines.length > 1 ?\n    this.__lines[this.__lines.length - 2] : null;\n};\n\nOutput.prototype.just_added_newline = function() {\n  return this.current_line.is_empty();\n};\n\nOutput.prototype.just_added_blankline = function() {\n  return this.is_empty() ||\n    (this.current_line.is_empty() && this.previous_line.is_empty());\n};\n\nOutput.prototype.ensure_empty_line_above = function(starts_with, ends_with) {\n  var index = this.__lines.length - 2;\n  while (index >= 0) {\n    var potentialEmptyLine = this.__lines[index];\n    if (potentialEmptyLine.is_empty()) {\n      break;\n    } else if (potentialEmptyLine.item(0).indexOf(starts_with) !== 0 &&\n      potentialEmptyLine.item(-1) !== ends_with) {\n      this.__lines.splice(index + 1, 0, new OutputLine(this));\n      this.previous_line = this.__lines[this.__lines.length - 2];\n      break;\n    }\n    index--;\n  }\n};\n\nmodule.exports.Output = Output;\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*jshint node:true */\n/*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/\n\n\n\nfunction Token(type, text, newlines, whitespace_before) {\n  this.type = type;\n  this.text = text;\n\n  // comments_before are\n  // comments that have a new line before them\n  // and may or may not have a newline after\n  // this is a set of comments before\n  this.comments_before = null; /* inline comment*/\n\n\n  // this.comments_after =  new TokenStream(); // no new line before and newline after\n  this.newlines = newlines || 0;\n  this.whitespace_before = whitespace_before || '';\n  this.parent = null;\n  this.next = null;\n  this.previous = null;\n  this.opened = null;\n  this.closed = null;\n  this.directives = null;\n}\n\n\nmodule.exports.Token = Token;\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* jshint node: true, curly: false */\n// Parts of this section of code is taken from acorn.\n//\n// Acorn was written by Marijn Haverbeke and released under an MIT\n// license. The Unicode regexps (for identifiers and whitespace) were\n// taken from [Esprima](http://esprima.org) by Ariya Hidayat.\n//\n// Git repositories for Acorn are available at\n//\n//     http://marijnhaverbeke.nl/git/acorn\n//     https://github.com/marijnh/acorn.git\n\n// ## Character categories\n\n\n\n\n// acorn used char codes to squeeze the last bit of performance out\n// Beautifier is okay without that, so we're using regex\n// permit # (23), $ (36), and @ (64). @ is used in ES7 decorators.\n// 65 through 91 are uppercase letters.\n// permit _ (95).\n// 97 through 123 are lowercase letters.\nvar baseASCIIidentifierStartChars = \"\\\\x23\\\\x24\\\\x40\\\\x41-\\\\x5a\\\\x5f\\\\x61-\\\\x7a\";\n\n// inside an identifier @ is not allowed but 0-9 are.\nvar baseASCIIidentifierChars = \"\\\\x24\\\\x30-\\\\x39\\\\x41-\\\\x5a\\\\x5f\\\\x61-\\\\x7a\";\n\n// Big ugly regular expressions that match characters in the\n// whitespace, identifier, and identifier-start categories. These\n// are only applied when a character is found to actually have a\n// code point above 128.\nvar nonASCIIidentifierStartChars = \"\\\\xaa\\\\xb5\\\\xba\\\\xc0-\\\\xd6\\\\xd8-\\\\xf6\\\\xf8-\\\\u02c1\\\\u02c6-\\\\u02d1\\\\u02e0-\\\\u02e4\\\\u02ec\\\\u02ee\\\\u0370-\\\\u0374\\\\u0376\\\\u0377\\\\u037a-\\\\u037d\\\\u0386\\\\u0388-\\\\u038a\\\\u038c\\\\u038e-\\\\u03a1\\\\u03a3-\\\\u03f5\\\\u03f7-\\\\u0481\\\\u048a-\\\\u0527\\\\u0531-\\\\u0556\\\\u0559\\\\u0561-\\\\u0587\\\\u05d0-\\\\u05ea\\\\u05f0-\\\\u05f2\\\\u0620-\\\\u064a\\\\u066e\\\\u066f\\\\u0671-\\\\u06d3\\\\u06d5\\\\u06e5\\\\u06e6\\\\u06ee\\\\u06ef\\\\u06fa-\\\\u06fc\\\\u06ff\\\\u0710\\\\u0712-\\\\u072f\\\\u074d-\\\\u07a5\\\\u07b1\\\\u07ca-\\\\u07ea\\\\u07f4\\\\u07f5\\\\u07fa\\\\u0800-\\\\u0815\\\\u081a\\\\u0824\\\\u0828\\\\u0840-\\\\u0858\\\\u08a0\\\\u08a2-\\\\u08ac\\\\u0904-\\\\u0939\\\\u093d\\\\u0950\\\\u0958-\\\\u0961\\\\u0971-\\\\u0977\\\\u0979-\\\\u097f\\\\u0985-\\\\u098c\\\\u098f\\\\u0990\\\\u0993-\\\\u09a8\\\\u09aa-\\\\u09b0\\\\u09b2\\\\u09b6-\\\\u09b9\\\\u09bd\\\\u09ce\\\\u09dc\\\\u09dd\\\\u09df-\\\\u09e1\\\\u09f0\\\\u09f1\\\\u0a05-\\\\u0a0a\\\\u0a0f\\\\u0a10\\\\u0a13-\\\\u0a28\\\\u0a2a-\\\\u0a30\\\\u0a32\\\\u0a33\\\\u0a35\\\\u0a36\\\\u0a38\\\\u0a39\\\\u0a59-\\\\u0a5c\\\\u0a5e\\\\u0a72-\\\\u0a74\\\\u0a85-\\\\u0a8d\\\\u0a8f-\\\\u0a91\\\\u0a93-\\\\u0aa8\\\\u0aaa-\\\\u0ab0\\\\u0ab2\\\\u0ab3\\\\u0ab5-\\\\u0ab9\\\\u0abd\\\\u0ad0\\\\u0ae0\\\\u0ae1\\\\u0b05-\\\\u0b0c\\\\u0b0f\\\\u0b10\\\\u0b13-\\\\u0b28\\\\u0b2a-\\\\u0b30\\\\u0b32\\\\u0b33\\\\u0b35-\\\\u0b39\\\\u0b3d\\\\u0b5c\\\\u0b5d\\\\u0b5f-\\\\u0b61\\\\u0b71\\\\u0b83\\\\u0b85-\\\\u0b8a\\\\u0b8e-\\\\u0b90\\\\u0b92-\\\\u0b95\\\\u0b99\\\\u0b9a\\\\u0b9c\\\\u0b9e\\\\u0b9f\\\\u0ba3\\\\u0ba4\\\\u0ba8-\\\\u0baa\\\\u0bae-\\\\u0bb9\\\\u0bd0\\\\u0c05-\\\\u0c0c\\\\u0c0e-\\\\u0c10\\\\u0c12-\\\\u0c28\\\\u0c2a-\\\\u0c33\\\\u0c35-\\\\u0c39\\\\u0c3d\\\\u0c58\\\\u0c59\\\\u0c60\\\\u0c61\\\\u0c85-\\\\u0c8c\\\\u0c8e-\\\\u0c90\\\\u0c92-\\\\u0ca8\\\\u0caa-\\\\u0cb3\\\\u0cb5-\\\\u0cb9\\\\u0cbd\\\\u0cde\\\\u0ce0\\\\u0ce1\\\\u0cf1\\\\u0cf2\\\\u0d05-\\\\u0d0c\\\\u0d0e-\\\\u0d10\\\\u0d12-\\\\u0d3a\\\\u0d3d\\\\u0d4e\\\\u0d60\\\\u0d61\\\\u0d7a-\\\\u0d7f\\\\u0d85-\\\\u0d96\\\\u0d9a-\\\\u0db1\\\\u0db3-\\\\u0dbb\\\\u0dbd\\\\u0dc0-\\\\u0dc6\\\\u0e01-\\\\u0e30\\\\u0e32\\\\u0e33\\\\u0e40-\\\\u0e46\\\\u0e81\\\\u0e82\\\\u0e84\\\\u0e87\\\\u0e88\\\\u0e8a\\\\u0e8d\\\\u0e94-\\\\u0e97\\\\u0e99-\\\\u0e9f\\\\u0ea1-\\\\u0ea3\\\\u0ea5\\\\u0ea7\\\\u0eaa\\\\u0eab\\\\u0ead-\\\\u0eb0\\\\u0eb2\\\\u0eb3\\\\u0ebd\\\\u0ec0-\\\\u0ec4\\\\u0ec6\\\\u0edc-\\\\u0edf\\\\u0f00\\\\u0f40-\\\\u0f47\\\\u0f49-\\\\u0f6c\\\\u0f88-\\\\u0f8c\\\\u1000-\\\\u102a\\\\u103f\\\\u1050-\\\\u1055\\\\u105a-\\\\u105d\\\\u1061\\\\u1065\\\\u1066\\\\u106e-\\\\u1070\\\\u1075-\\\\u1081\\\\u108e\\\\u10a0-\\\\u10c5\\\\u10c7\\\\u10cd\\\\u10d0-\\\\u10fa\\\\u10fc-\\\\u1248\\\\u124a-\\\\u124d\\\\u1250-\\\\u1256\\\\u1258\\\\u125a-\\\\u125d\\\\u1260-\\\\u1288\\\\u128a-\\\\u128d\\\\u1290-\\\\u12b0\\\\u12b2-\\\\u12b5\\\\u12b8-\\\\u12be\\\\u12c0\\\\u12c2-\\\\u12c5\\\\u12c8-\\\\u12d6\\\\u12d8-\\\\u1310\\\\u1312-\\\\u1315\\\\u1318-\\\\u135a\\\\u1380-\\\\u138f\\\\u13a0-\\\\u13f4\\\\u1401-\\\\u166c\\\\u166f-\\\\u167f\\\\u1681-\\\\u169a\\\\u16a0-\\\\u16ea\\\\u16ee-\\\\u16f0\\\\u1700-\\\\u170c\\\\u170e-\\\\u1711\\\\u1720-\\\\u1731\\\\u1740-\\\\u1751\\\\u1760-\\\\u176c\\\\u176e-\\\\u1770\\\\u1780-\\\\u17b3\\\\u17d7\\\\u17dc\\\\u1820-\\\\u1877\\\\u1880-\\\\u18a8\\\\u18aa\\\\u18b0-\\\\u18f5\\\\u1900-\\\\u191c\\\\u1950-\\\\u196d\\\\u1970-\\\\u1974\\\\u1980-\\\\u19ab\\\\u19c1-\\\\u19c7\\\\u1a00-\\\\u1a16\\\\u1a20-\\\\u1a54\\\\u1aa7\\\\u1b05-\\\\u1b33\\\\u1b45-\\\\u1b4b\\\\u1b83-\\\\u1ba0\\\\u1bae\\\\u1baf\\\\u1bba-\\\\u1be5\\\\u1c00-\\\\u1c23\\\\u1c4d-\\\\u1c4f\\\\u1c5a-\\\\u1c7d\\\\u1ce9-\\\\u1cec\\\\u1cee-\\\\u1cf1\\\\u1cf5\\\\u1cf6\\\\u1d00-\\\\u1dbf\\\\u1e00-\\\\u1f15\\\\u1f18-\\\\u1f1d\\\\u1f20-\\\\u1f45\\\\u1f48-\\\\u1f4d\\\\u1f50-\\\\u1f57\\\\u1f59\\\\u1f5b\\\\u1f5d\\\\u1f5f-\\\\u1f7d\\\\u1f80-\\\\u1fb4\\\\u1fb6-\\\\u1fbc\\\\u1fbe\\\\u1fc2-\\\\u1fc4\\\\u1fc6-\\\\u1fcc\\\\u1fd0-\\\\u1fd3\\\\u1fd6-\\\\u1fdb\\\\u1fe0-\\\\u1fec\\\\u1ff2-\\\\u1ff4\\\\u1ff6-\\\\u1ffc\\\\u2071\\\\u207f\\\\u2090-\\\\u209c\\\\u2102\\\\u2107\\\\u210a-\\\\u2113\\\\u2115\\\\u2119-\\\\u211d\\\\u2124\\\\u2126\\\\u2128\\\\u212a-\\\\u212d\\\\u212f-\\\\u2139\\\\u213c-\\\\u213f\\\\u2145-\\\\u2149\\\\u214e\\\\u2160-\\\\u2188\\\\u2c00-\\\\u2c2e\\\\u2c30-\\\\u2c5e\\\\u2c60-\\\\u2ce4\\\\u2ceb-\\\\u2cee\\\\u2cf2\\\\u2cf3\\\\u2d00-\\\\u2d25\\\\u2d27\\\\u2d2d\\\\u2d30-\\\\u2d67\\\\u2d6f\\\\u2d80-\\\\u2d96\\\\u2da0-\\\\u2da6\\\\u2da8-\\\\u2dae\\\\u2db0-\\\\u2db6\\\\u2db8-\\\\u2dbe\\\\u2dc0-\\\\u2dc6\\\\u2dc8-\\\\u2dce\\\\u2dd0-\\\\u2dd6\\\\u2dd8-\\\\u2dde\\\\u2e2f\\\\u3005-\\\\u3007\\\\u3021-\\\\u3029\\\\u3031-\\\\u3035\\\\u3038-\\\\u303c\\\\u3041-\\\\u3096\\\\u309d-\\\\u309f\\\\u30a1-\\\\u30fa\\\\u30fc-\\\\u30ff\\\\u3105-\\\\u312d\\\\u3131-\\\\u318e\\\\u31a0-\\\\u31ba\\\\u31f0-\\\\u31ff\\\\u3400-\\\\u4db5\\\\u4e00-\\\\u9fcc\\\\ua000-\\\\ua48c\\\\ua4d0-\\\\ua4fd\\\\ua500-\\\\ua60c\\\\ua610-\\\\ua61f\\\\ua62a\\\\ua62b\\\\ua640-\\\\ua66e\\\\ua67f-\\\\ua697\\\\ua6a0-\\\\ua6ef\\\\ua717-\\\\ua71f\\\\ua722-\\\\ua788\\\\ua78b-\\\\ua78e\\\\ua790-\\\\ua793\\\\ua7a0-\\\\ua7aa\\\\ua7f8-\\\\ua801\\\\ua803-\\\\ua805\\\\ua807-\\\\ua80a\\\\ua80c-\\\\ua822\\\\ua840-\\\\ua873\\\\ua882-\\\\ua8b3\\\\ua8f2-\\\\ua8f7\\\\ua8fb\\\\ua90a-\\\\ua925\\\\ua930-\\\\ua946\\\\ua960-\\\\ua97c\\\\ua984-\\\\ua9b2\\\\ua9cf\\\\uaa00-\\\\uaa28\\\\uaa40-\\\\uaa42\\\\uaa44-\\\\uaa4b\\\\uaa60-\\\\uaa76\\\\uaa7a\\\\uaa80-\\\\uaaaf\\\\uaab1\\\\uaab5\\\\uaab6\\\\uaab9-\\\\uaabd\\\\uaac0\\\\uaac2\\\\uaadb-\\\\uaadd\\\\uaae0-\\\\uaaea\\\\uaaf2-\\\\uaaf4\\\\uab01-\\\\uab06\\\\uab09-\\\\uab0e\\\\uab11-\\\\uab16\\\\uab20-\\\\uab26\\\\uab28-\\\\uab2e\\\\uabc0-\\\\uabe2\\\\uac00-\\\\ud7a3\\\\ud7b0-\\\\ud7c6\\\\ud7cb-\\\\ud7fb\\\\uf900-\\\\ufa6d\\\\ufa70-\\\\ufad9\\\\ufb00-\\\\ufb06\\\\ufb13-\\\\ufb17\\\\ufb1d\\\\ufb1f-\\\\ufb28\\\\ufb2a-\\\\ufb36\\\\ufb38-\\\\ufb3c\\\\ufb3e\\\\ufb40\\\\ufb41\\\\ufb43\\\\ufb44\\\\ufb46-\\\\ufbb1\\\\ufbd3-\\\\ufd3d\\\\ufd50-\\\\ufd8f\\\\ufd92-\\\\ufdc7\\\\ufdf0-\\\\ufdfb\\\\ufe70-\\\\ufe74\\\\ufe76-\\\\ufefc\\\\uff21-\\\\uff3a\\\\uff41-\\\\uff5a\\\\uff66-\\\\uffbe\\\\uffc2-\\\\uffc7\\\\uffca-\\\\uffcf\\\\uffd2-\\\\uffd7\\\\uffda-\\\\uffdc\";\nvar nonASCIIidentifierChars = \"\\\\u0300-\\\\u036f\\\\u0483-\\\\u0487\\\\u0591-\\\\u05bd\\\\u05bf\\\\u05c1\\\\u05c2\\\\u05c4\\\\u05c5\\\\u05c7\\\\u0610-\\\\u061a\\\\u0620-\\\\u0649\\\\u0672-\\\\u06d3\\\\u06e7-\\\\u06e8\\\\u06fb-\\\\u06fc\\\\u0730-\\\\u074a\\\\u0800-\\\\u0814\\\\u081b-\\\\u0823\\\\u0825-\\\\u0827\\\\u0829-\\\\u082d\\\\u0840-\\\\u0857\\\\u08e4-\\\\u08fe\\\\u0900-\\\\u0903\\\\u093a-\\\\u093c\\\\u093e-\\\\u094f\\\\u0951-\\\\u0957\\\\u0962-\\\\u0963\\\\u0966-\\\\u096f\\\\u0981-\\\\u0983\\\\u09bc\\\\u09be-\\\\u09c4\\\\u09c7\\\\u09c8\\\\u09d7\\\\u09df-\\\\u09e0\\\\u0a01-\\\\u0a03\\\\u0a3c\\\\u0a3e-\\\\u0a42\\\\u0a47\\\\u0a48\\\\u0a4b-\\\\u0a4d\\\\u0a51\\\\u0a66-\\\\u0a71\\\\u0a75\\\\u0a81-\\\\u0a83\\\\u0abc\\\\u0abe-\\\\u0ac5\\\\u0ac7-\\\\u0ac9\\\\u0acb-\\\\u0acd\\\\u0ae2-\\\\u0ae3\\\\u0ae6-\\\\u0aef\\\\u0b01-\\\\u0b03\\\\u0b3c\\\\u0b3e-\\\\u0b44\\\\u0b47\\\\u0b48\\\\u0b4b-\\\\u0b4d\\\\u0b56\\\\u0b57\\\\u0b5f-\\\\u0b60\\\\u0b66-\\\\u0b6f\\\\u0b82\\\\u0bbe-\\\\u0bc2\\\\u0bc6-\\\\u0bc8\\\\u0bca-\\\\u0bcd\\\\u0bd7\\\\u0be6-\\\\u0bef\\\\u0c01-\\\\u0c03\\\\u0c46-\\\\u0c48\\\\u0c4a-\\\\u0c4d\\\\u0c55\\\\u0c56\\\\u0c62-\\\\u0c63\\\\u0c66-\\\\u0c6f\\\\u0c82\\\\u0c83\\\\u0cbc\\\\u0cbe-\\\\u0cc4\\\\u0cc6-\\\\u0cc8\\\\u0cca-\\\\u0ccd\\\\u0cd5\\\\u0cd6\\\\u0ce2-\\\\u0ce3\\\\u0ce6-\\\\u0cef\\\\u0d02\\\\u0d03\\\\u0d46-\\\\u0d48\\\\u0d57\\\\u0d62-\\\\u0d63\\\\u0d66-\\\\u0d6f\\\\u0d82\\\\u0d83\\\\u0dca\\\\u0dcf-\\\\u0dd4\\\\u0dd6\\\\u0dd8-\\\\u0ddf\\\\u0df2\\\\u0df3\\\\u0e34-\\\\u0e3a\\\\u0e40-\\\\u0e45\\\\u0e50-\\\\u0e59\\\\u0eb4-\\\\u0eb9\\\\u0ec8-\\\\u0ecd\\\\u0ed0-\\\\u0ed9\\\\u0f18\\\\u0f19\\\\u0f20-\\\\u0f29\\\\u0f35\\\\u0f37\\\\u0f39\\\\u0f41-\\\\u0f47\\\\u0f71-\\\\u0f84\\\\u0f86-\\\\u0f87\\\\u0f8d-\\\\u0f97\\\\u0f99-\\\\u0fbc\\\\u0fc6\\\\u1000-\\\\u1029\\\\u1040-\\\\u1049\\\\u1067-\\\\u106d\\\\u1071-\\\\u1074\\\\u1082-\\\\u108d\\\\u108f-\\\\u109d\\\\u135d-\\\\u135f\\\\u170e-\\\\u1710\\\\u1720-\\\\u1730\\\\u1740-\\\\u1750\\\\u1772\\\\u1773\\\\u1780-\\\\u17b2\\\\u17dd\\\\u17e0-\\\\u17e9\\\\u180b-\\\\u180d\\\\u1810-\\\\u1819\\\\u1920-\\\\u192b\\\\u1930-\\\\u193b\\\\u1951-\\\\u196d\\\\u19b0-\\\\u19c0\\\\u19c8-\\\\u19c9\\\\u19d0-\\\\u19d9\\\\u1a00-\\\\u1a15\\\\u1a20-\\\\u1a53\\\\u1a60-\\\\u1a7c\\\\u1a7f-\\\\u1a89\\\\u1a90-\\\\u1a99\\\\u1b46-\\\\u1b4b\\\\u1b50-\\\\u1b59\\\\u1b6b-\\\\u1b73\\\\u1bb0-\\\\u1bb9\\\\u1be6-\\\\u1bf3\\\\u1c00-\\\\u1c22\\\\u1c40-\\\\u1c49\\\\u1c5b-\\\\u1c7d\\\\u1cd0-\\\\u1cd2\\\\u1d00-\\\\u1dbe\\\\u1e01-\\\\u1f15\\\\u200c\\\\u200d\\\\u203f\\\\u2040\\\\u2054\\\\u20d0-\\\\u20dc\\\\u20e1\\\\u20e5-\\\\u20f0\\\\u2d81-\\\\u2d96\\\\u2de0-\\\\u2dff\\\\u3021-\\\\u3028\\\\u3099\\\\u309a\\\\ua640-\\\\ua66d\\\\ua674-\\\\ua67d\\\\ua69f\\\\ua6f0-\\\\ua6f1\\\\ua7f8-\\\\ua800\\\\ua806\\\\ua80b\\\\ua823-\\\\ua827\\\\ua880-\\\\ua881\\\\ua8b4-\\\\ua8c4\\\\ua8d0-\\\\ua8d9\\\\ua8f3-\\\\ua8f7\\\\ua900-\\\\ua909\\\\ua926-\\\\ua92d\\\\ua930-\\\\ua945\\\\ua980-\\\\ua983\\\\ua9b3-\\\\ua9c0\\\\uaa00-\\\\uaa27\\\\uaa40-\\\\uaa41\\\\uaa4c-\\\\uaa4d\\\\uaa50-\\\\uaa59\\\\uaa7b\\\\uaae0-\\\\uaae9\\\\uaaf2-\\\\uaaf3\\\\uabc0-\\\\uabe1\\\\uabec\\\\uabed\\\\uabf0-\\\\uabf9\\\\ufb20-\\\\ufb28\\\\ufe00-\\\\ufe0f\\\\ufe20-\\\\ufe26\\\\ufe33\\\\ufe34\\\\ufe4d-\\\\ufe4f\\\\uff10-\\\\uff19\\\\uff3f\";\n//var nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\");\n//var nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\");\n\nvar identifierStart = \"(?:\\\\\\\\u[0-9a-fA-F]{4}|[\" + baseASCIIidentifierStartChars + nonASCIIidentifierStartChars + \"])\";\nvar identifierChars = \"(?:\\\\\\\\u[0-9a-fA-F]{4}|[\" + baseASCIIidentifierChars + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"])*\";\n\nexports.identifier = new RegExp(identifierStart + identifierChars, 'g');\nexports.identifierStart = new RegExp(identifierStart);\nexports.identifierMatch = new RegExp(\"(?:\\\\\\\\u[0-9a-fA-F]{4}|[\" + baseASCIIidentifierChars + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"])+\");\n\nvar nonASCIIwhitespace = /[\\u1680\\u180e\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]/; // jshint ignore:line\n\n// Whether a single character denotes a newline.\n\nexports.newline = /[\\n\\r\\u2028\\u2029]/;\n\n// Matches a whole line break (where CRLF is considered a single\n// line break). Used to count lines.\n\n// in javascript, these two differ\n// in python they are the same, different methods are called on them\nexports.lineBreak = new RegExp('\\r\\n|' + exports.newline.source);\nexports.allLineBreaks = new RegExp(exports.lineBreak.source, 'g');\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*jshint node:true */\n/*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/\n\n\n\nvar BaseOptions = __webpack_require__(6).Options;\n\nvar validPositionValues = ['before-newline', 'after-newline', 'preserve-newline'];\n\nfunction Options(options) {\n  BaseOptions.call(this, options, 'js');\n\n  // compatibility, re\n  var raw_brace_style = this.raw_options.brace_style || null;\n  if (raw_brace_style === \"expand-strict\") { //graceful handling of deprecated option\n    this.raw_options.brace_style = \"expand\";\n  } else if (raw_brace_style === \"collapse-preserve-inline\") { //graceful handling of deprecated option\n    this.raw_options.brace_style = \"collapse,preserve-inline\";\n  } else if (this.raw_options.braces_on_own_line !== undefined) { //graceful handling of deprecated option\n    this.raw_options.brace_style = this.raw_options.braces_on_own_line ? \"expand\" : \"collapse\";\n    // } else if (!raw_brace_style) { //Nothing exists to set it\n    //   raw_brace_style = \"collapse\";\n  }\n\n  //preserve-inline in delimited string will trigger brace_preserve_inline, everything\n  //else is considered a brace_style and the last one only will have an effect\n\n  var brace_style_split = this._get_selection_list('brace_style', ['collapse', 'expand', 'end-expand', 'none', 'preserve-inline']);\n\n  this.brace_preserve_inline = false; //Defaults in case one or other was not specified in meta-option\n  this.brace_style = \"collapse\";\n\n  for (var bs = 0; bs < brace_style_split.length; bs++) {\n    if (brace_style_split[bs] === \"preserve-inline\") {\n      this.brace_preserve_inline = true;\n    } else {\n      this.brace_style = brace_style_split[bs];\n    }\n  }\n\n  this.unindent_chained_methods = this._get_boolean('unindent_chained_methods');\n  this.break_chained_methods = this._get_boolean('break_chained_methods');\n  this.space_in_paren = this._get_boolean('space_in_paren');\n  this.space_in_empty_paren = this._get_boolean('space_in_empty_paren');\n  this.jslint_happy = this._get_boolean('jslint_happy');\n  this.space_after_anon_function = this._get_boolean('space_after_anon_function');\n  this.space_after_named_function = this._get_boolean('space_after_named_function');\n  this.keep_array_indentation = this._get_boolean('keep_array_indentation');\n  this.space_before_conditional = this._get_boolean('space_before_conditional', true);\n  this.unescape_strings = this._get_boolean('unescape_strings');\n  this.e4x = this._get_boolean('e4x');\n  this.comma_first = this._get_boolean('comma_first');\n  this.operator_position = this._get_selection('operator_position', validPositionValues);\n\n  // For testing of beautify preserve:start directive\n  this.test_output_raw = this._get_boolean('test_output_raw');\n\n  // force this._options.space_after_anon_function to true if this._options.jslint_happy\n  if (this.jslint_happy) {\n    this.space_after_anon_function = true;\n  }\n\n}\nOptions.prototype = new BaseOptions();\n\n\n\nmodule.exports.Options = Options;\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*jshint node:true */\n/*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/\n\n\n\nfunction Options(options, merge_child_field) {\n  this.raw_options = _mergeOpts(options, merge_child_field);\n\n  // Support passing the source text back with no change\n  this.disabled = this._get_boolean('disabled');\n\n  this.eol = this._get_characters('eol', 'auto');\n  this.end_with_newline = this._get_boolean('end_with_newline');\n  this.indent_size = this._get_number('indent_size', 4);\n  this.indent_char = this._get_characters('indent_char', ' ');\n  this.indent_level = this._get_number('indent_level');\n\n  this.preserve_newlines = this._get_boolean('preserve_newlines', true);\n  this.max_preserve_newlines = this._get_number('max_preserve_newlines', 32786);\n  if (!this.preserve_newlines) {\n    this.max_preserve_newlines = 0;\n  }\n\n  this.indent_with_tabs = this._get_boolean('indent_with_tabs', this.indent_char === '\\t');\n  if (this.indent_with_tabs) {\n    this.indent_char = '\\t';\n\n    // indent_size behavior changed after 1.8.6\n    // It used to be that indent_size would be\n    // set to 1 for indent_with_tabs. That is no longer needed and\n    // actually doesn't make sense - why not use spaces? Further,\n    // that might produce unexpected behavior - tabs being used\n    // for single-column alignment. So, when indent_with_tabs is true\n    // and indent_size is 1, reset indent_size to 4.\n    if (this.indent_size === 1) {\n      this.indent_size = 4;\n    }\n  }\n\n  // Backwards compat with 1.3.x\n  this.wrap_line_length = this._get_number('wrap_line_length', this._get_number('max_char'));\n\n  this.indent_empty_lines = this._get_boolean('indent_empty_lines');\n\n  // valid templating languages ['django', 'erb', 'handlebars', 'php']\n  // For now, 'auto' = all off for javascript, all on for html (and inline javascript).\n  // other values ignored\n  this.templating = this._get_selection_list('templating', ['auto', 'none', 'django', 'erb', 'handlebars', 'php'], ['auto']);\n}\n\nOptions.prototype._get_array = function(name, default_value) {\n  var option_value = this.raw_options[name];\n  var result = default_value || [];\n  if (typeof option_value === 'object') {\n    if (option_value !== null && typeof option_value.concat === 'function') {\n      result = option_value.concat();\n    }\n  } else if (typeof option_value === 'string') {\n    result = option_value.split(/[^a-zA-Z0-9_\\/\\-]+/);\n  }\n  return result;\n};\n\nOptions.prototype._get_boolean = function(name, default_value) {\n  var option_value = this.raw_options[name];\n  var result = option_value === undefined ? !!default_value : !!option_value;\n  return result;\n};\n\nOptions.prototype._get_characters = function(name, default_value) {\n  var option_value = this.raw_options[name];\n  var result = default_value || '';\n  if (typeof option_value === 'string') {\n    result = option_value.replace(/\\\\r/, '\\r').replace(/\\\\n/, '\\n').replace(/\\\\t/, '\\t');\n  }\n  return result;\n};\n\nOptions.prototype._get_number = function(name, default_value) {\n  var option_value = this.raw_options[name];\n  default_value = parseInt(default_value, 10);\n  if (isNaN(default_value)) {\n    default_value = 0;\n  }\n  var result = parseInt(option_value, 10);\n  if (isNaN(result)) {\n    result = default_value;\n  }\n  return result;\n};\n\nOptions.prototype._get_selection = function(name, selection_list, default_value) {\n  var result = this._get_selection_list(name, selection_list, default_value);\n  if (result.length !== 1) {\n    throw new Error(\n      \"Invalid Option Value: The option '\" + name + \"' can only be one of the following values:\\n\" +\n      selection_list + \"\\nYou passed in: '\" + this.raw_options[name] + \"'\");\n  }\n\n  return result[0];\n};\n\n\nOptions.prototype._get_selection_list = function(name, selection_list, default_value) {\n  if (!selection_list || selection_list.length === 0) {\n    throw new Error(\"Selection list cannot be empty.\");\n  }\n\n  default_value = default_value || [selection_list[0]];\n  if (!this._is_valid_selection(default_value, selection_list)) {\n    throw new Error(\"Invalid Default Value!\");\n  }\n\n  var result = this._get_array(name, default_value);\n  if (!this._is_valid_selection(result, selection_list)) {\n    throw new Error(\n      \"Invalid Option Value: The option '\" + name + \"' can contain only the following values:\\n\" +\n      selection_list + \"\\nYou passed in: '\" + this.raw_options[name] + \"'\");\n  }\n\n  return result;\n};\n\nOptions.prototype._is_valid_selection = function(result, selection_list) {\n  return result.length && selection_list.length &&\n    !result.some(function(item) { return selection_list.indexOf(item) === -1; });\n};\n\n\n// merges child options up with the parent options object\n// Example: obj = {a: 1, b: {a: 2}}\n//          mergeOpts(obj, 'b')\n//\n//          Returns: {a: 2}\nfunction _mergeOpts(allOptions, childFieldName) {\n  var finalOpts = {};\n  allOptions = _normalizeOpts(allOptions);\n  var name;\n\n  for (name in allOptions) {\n    if (name !== childFieldName) {\n      finalOpts[name] = allOptions[name];\n    }\n  }\n\n  //merge in the per type settings for the childFieldName\n  if (childFieldName && allOptions[childFieldName]) {\n    for (name in allOptions[childFieldName]) {\n      finalOpts[name] = allOptions[childFieldName][name];\n    }\n  }\n  return finalOpts;\n}\n\nfunction _normalizeOpts(options) {\n  var convertedOpts = {};\n  var key;\n\n  for (key in options) {\n    var newKey = key.replace(/-/g, \"_\");\n    convertedOpts[newKey] = options[key];\n  }\n  return convertedOpts;\n}\n\nmodule.exports.Options = Options;\nmodule.exports.normalizeOpts = _normalizeOpts;\nmodule.exports.mergeOpts = _mergeOpts;\n\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*jshint node:true */\n/*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/\n\n\n\nvar InputScanner = __webpack_require__(8).InputScanner;\nvar BaseTokenizer = __webpack_require__(9).Tokenizer;\nvar BASETOKEN = __webpack_require__(9).TOKEN;\nvar Directives = __webpack_require__(13).Directives;\nvar acorn = __webpack_require__(4);\nvar Pattern = __webpack_require__(12).Pattern;\nvar TemplatablePattern = __webpack_require__(14).TemplatablePattern;\n\n\nfunction in_array(what, arr) {\n  return arr.indexOf(what) !== -1;\n}\n\n\nvar TOKEN = {\n  START_EXPR: 'TK_START_EXPR',\n  END_EXPR: 'TK_END_EXPR',\n  START_BLOCK: 'TK_START_BLOCK',\n  END_BLOCK: 'TK_END_BLOCK',\n  WORD: 'TK_WORD',\n  RESERVED: 'TK_RESERVED',\n  SEMICOLON: 'TK_SEMICOLON',\n  STRING: 'TK_STRING',\n  EQUALS: 'TK_EQUALS',\n  OPERATOR: 'TK_OPERATOR',\n  COMMA: 'TK_COMMA',\n  BLOCK_COMMENT: 'TK_BLOCK_COMMENT',\n  COMMENT: 'TK_COMMENT',\n  DOT: 'TK_DOT',\n  UNKNOWN: 'TK_UNKNOWN',\n  START: BASETOKEN.START,\n  RAW: BASETOKEN.RAW,\n  EOF: BASETOKEN.EOF\n};\n\n\nvar directives_core = new Directives(/\\/\\*/, /\\*\\//);\n\nvar number_pattern = /0[xX][0123456789abcdefABCDEF]*|0[oO][01234567]*|0[bB][01]*|\\d+n|(?:\\.\\d+|\\d+\\.?\\d*)(?:[eE][+-]?\\d+)?/;\n\nvar digit = /[0-9]/;\n\n// Dot \".\" must be distinguished from \"...\" and decimal\nvar dot_pattern = /[^\\d\\.]/;\n\nvar positionable_operators = (\n  \">>> === !== \" +\n  \"<< && >= ** != == <= >> || ?? |> \" +\n  \"< / - + > : & % ? ^ | *\").split(' ');\n\n// IMPORTANT: this must be sorted longest to shortest or tokenizing many not work.\n// Also, you must update possitionable operators separately from punct\nvar punct =\n  \">>>= \" +\n  \"... >>= <<= === >>> !== **= \" +\n  \"=> ^= :: /= << <= == && -= >= >> != -- += ** || ?? ++ %= &= *= |= |> \" +\n  \"= ! ? > < : / ^ - + * & % ~ |\";\n\npunct = punct.replace(/[-[\\]{}()*+?.,\\\\^$|#]/g, \"\\\\$&\");\n// ?. but not if followed by a number \npunct = '\\\\?\\\\.(?!\\\\d) ' + punct;\npunct = punct.replace(/ /g, '|');\n\nvar punct_pattern = new RegExp(punct);\n\n// words which should always start on new line.\nvar line_starters = 'continue,try,throw,return,var,let,const,if,switch,case,default,for,while,break,function,import,export'.split(',');\nvar reserved_words = line_starters.concat(['do', 'in', 'of', 'else', 'get', 'set', 'new', 'catch', 'finally', 'typeof', 'yield', 'async', 'await', 'from', 'as']);\nvar reserved_word_pattern = new RegExp('^(?:' + reserved_words.join('|') + ')$');\n\n// var template_pattern = /(?:(?:<\\?php|<\\?=)[\\s\\S]*?\\?>)|(?:<%[\\s\\S]*?%>)/g;\n\nvar in_html_comment;\n\nvar Tokenizer = function(input_string, options) {\n  BaseTokenizer.call(this, input_string, options);\n\n  this._patterns.whitespace = this._patterns.whitespace.matching(\n    /\\u00A0\\u1680\\u180e\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff/.source,\n    /\\u2028\\u2029/.source);\n\n  var pattern_reader = new Pattern(this._input);\n  var templatable = new TemplatablePattern(this._input)\n    .read_options(this._options);\n\n  this.__patterns = {\n    template: templatable,\n    identifier: templatable.starting_with(acorn.identifier).matching(acorn.identifierMatch),\n    number: pattern_reader.matching(number_pattern),\n    punct: pattern_reader.matching(punct_pattern),\n    // comment ends just before nearest linefeed or end of file\n    comment: pattern_reader.starting_with(/\\/\\//).until(/[\\n\\r\\u2028\\u2029]/),\n    //  /* ... */ comment ends with nearest */ or end of file\n    block_comment: pattern_reader.starting_with(/\\/\\*/).until_after(/\\*\\//),\n    html_comment_start: pattern_reader.matching(/<!--/),\n    html_comment_end: pattern_reader.matching(/-->/),\n    include: pattern_reader.starting_with(/#include/).until_after(acorn.lineBreak),\n    shebang: pattern_reader.starting_with(/#!/).until_after(acorn.lineBreak),\n    xml: pattern_reader.matching(/[\\s\\S]*?<(\\/?)([-a-zA-Z:0-9_.]+|{[\\s\\S]+?}|!\\[CDATA\\[[\\s\\S]*?\\]\\])(\\s+{[\\s\\S]+?}|\\s+[-a-zA-Z:0-9_.]+|\\s+[-a-zA-Z:0-9_.]+\\s*=\\s*('[^']*'|\"[^\"]*\"|{[\\s\\S]+?}))*\\s*(\\/?)\\s*>/),\n    single_quote: templatable.until(/['\\\\\\n\\r\\u2028\\u2029]/),\n    double_quote: templatable.until(/[\"\\\\\\n\\r\\u2028\\u2029]/),\n    template_text: templatable.until(/[`\\\\$]/),\n    template_expression: templatable.until(/[`}\\\\]/)\n  };\n\n};\nTokenizer.prototype = new BaseTokenizer();\n\nTokenizer.prototype._is_comment = function(current_token) {\n  return current_token.type === TOKEN.COMMENT || current_token.type === TOKEN.BLOCK_COMMENT || current_token.type === TOKEN.UNKNOWN;\n};\n\nTokenizer.prototype._is_opening = function(current_token) {\n  return current_token.type === TOKEN.START_BLOCK || current_token.type === TOKEN.START_EXPR;\n};\n\nTokenizer.prototype._is_closing = function(current_token, open_token) {\n  return (current_token.type === TOKEN.END_BLOCK || current_token.type === TOKEN.END_EXPR) &&\n    (open_token && (\n      (current_token.text === ']' && open_token.text === '[') ||\n      (current_token.text === ')' && open_token.text === '(') ||\n      (current_token.text === '}' && open_token.text === '{')));\n};\n\nTokenizer.prototype._reset = function() {\n  in_html_comment = false;\n};\n\nTokenizer.prototype._get_next_token = function(previous_token, open_token) { // jshint unused:false\n  var token = null;\n  this._readWhitespace();\n  var c = this._input.peek();\n\n  if (c === null) {\n    return this._create_token(TOKEN.EOF, '');\n  }\n\n  token = token || this._read_non_javascript(c);\n  token = token || this._read_string(c);\n  token = token || this._read_word(previous_token);\n  token = token || this._read_singles(c);\n  token = token || this._read_comment(c);\n  token = token || this._read_regexp(c, previous_token);\n  token = token || this._read_xml(c, previous_token);\n  token = token || this._read_punctuation();\n  token = token || this._create_token(TOKEN.UNKNOWN, this._input.next());\n\n  return token;\n};\n\nTokenizer.prototype._read_word = function(previous_token) {\n  var resulting_string;\n  resulting_string = this.__patterns.identifier.read();\n  if (resulting_string !== '') {\n    resulting_string = resulting_string.replace(acorn.allLineBreaks, '\\n');\n    if (!(previous_token.type === TOKEN.DOT ||\n        (previous_token.type === TOKEN.RESERVED && (previous_token.text === 'set' || previous_token.text === 'get'))) &&\n      reserved_word_pattern.test(resulting_string)) {\n      if (resulting_string === 'in' || resulting_string === 'of') { // hack for 'in' and 'of' operators\n        return this._create_token(TOKEN.OPERATOR, resulting_string);\n      }\n      return this._create_token(TOKEN.RESERVED, resulting_string);\n    }\n    return this._create_token(TOKEN.WORD, resulting_string);\n  }\n\n  resulting_string = this.__patterns.number.read();\n  if (resulting_string !== '') {\n    return this._create_token(TOKEN.WORD, resulting_string);\n  }\n};\n\nTokenizer.prototype._read_singles = function(c) {\n  var token = null;\n  if (c === '(' || c === '[') {\n    token = this._create_token(TOKEN.START_EXPR, c);\n  } else if (c === ')' || c === ']') {\n    token = this._create_token(TOKEN.END_EXPR, c);\n  } else if (c === '{') {\n    token = this._create_token(TOKEN.START_BLOCK, c);\n  } else if (c === '}') {\n    token = this._create_token(TOKEN.END_BLOCK, c);\n  } else if (c === ';') {\n    token = this._create_token(TOKEN.SEMICOLON, c);\n  } else if (c === '.' && dot_pattern.test(this._input.peek(1))) {\n    token = this._create_token(TOKEN.DOT, c);\n  } else if (c === ',') {\n    token = this._create_token(TOKEN.COMMA, c);\n  }\n\n  if (token) {\n    this._input.next();\n  }\n  return token;\n};\n\nTokenizer.prototype._read_punctuation = function() {\n  var resulting_string = this.__patterns.punct.read();\n\n  if (resulting_string !== '') {\n    if (resulting_string === '=') {\n      return this._create_token(TOKEN.EQUALS, resulting_string);\n    } else if (resulting_string === '?.') {\n      return this._create_token(TOKEN.DOT, resulting_string);\n    } else {\n      return this._create_token(TOKEN.OPERATOR, resulting_string);\n    }\n  }\n};\n\nTokenizer.prototype._read_non_javascript = function(c) {\n  var resulting_string = '';\n\n  if (c === '#') {\n    if (this._is_first_token()) {\n      resulting_string = this.__patterns.shebang.read();\n\n      if (resulting_string) {\n        return this._create_token(TOKEN.UNKNOWN, resulting_string.trim() + '\\n');\n      }\n    }\n\n    // handles extendscript #includes\n    resulting_string = this.__patterns.include.read();\n\n    if (resulting_string) {\n      return this._create_token(TOKEN.UNKNOWN, resulting_string.trim() + '\\n');\n    }\n\n    c = this._input.next();\n\n    // Spidermonkey-specific sharp variables for circular references. Considered obsolete.\n    var sharp = '#';\n    if (this._input.hasNext() && this._input.testChar(digit)) {\n      do {\n        c = this._input.next();\n        sharp += c;\n      } while (this._input.hasNext() && c !== '#' && c !== '=');\n      if (c === '#') {\n        //\n      } else if (this._input.peek() === '[' && this._input.peek(1) === ']') {\n        sharp += '[]';\n        this._input.next();\n        this._input.next();\n      } else if (this._input.peek() === '{' && this._input.peek(1) === '}') {\n        sharp += '{}';\n        this._input.next();\n        this._input.next();\n      }\n      return this._create_token(TOKEN.WORD, sharp);\n    }\n\n    this._input.back();\n\n  } else if (c === '<' && this._is_first_token()) {\n    resulting_string = this.__patterns.html_comment_start.read();\n    if (resulting_string) {\n      while (this._input.hasNext() && !this._input.testChar(acorn.newline)) {\n        resulting_string += this._input.next();\n      }\n      in_html_comment = true;\n      return this._create_token(TOKEN.COMMENT, resulting_string);\n    }\n  } else if (in_html_comment && c === '-') {\n    resulting_string = this.__patterns.html_comment_end.read();\n    if (resulting_string) {\n      in_html_comment = false;\n      return this._create_token(TOKEN.COMMENT, resulting_string);\n    }\n  }\n\n  return null;\n};\n\nTokenizer.prototype._read_comment = function(c) {\n  var token = null;\n  if (c === '/') {\n    var comment = '';\n    if (this._input.peek(1) === '*') {\n      // peek for comment /* ... */\n      comment = this.__patterns.block_comment.read();\n      var directives = directives_core.get_directives(comment);\n      if (directives && directives.ignore === 'start') {\n        comment += directives_core.readIgnored(this._input);\n      }\n      comment = comment.replace(acorn.allLineBreaks, '\\n');\n      token = this._create_token(TOKEN.BLOCK_COMMENT, comment);\n      token.directives = directives;\n    } else if (this._input.peek(1) === '/') {\n      // peek for comment // ...\n      comment = this.__patterns.comment.read();\n      token = this._create_token(TOKEN.COMMENT, comment);\n    }\n  }\n  return token;\n};\n\nTokenizer.prototype._read_string = function(c) {\n  if (c === '`' || c === \"'\" || c === '\"') {\n    var resulting_string = this._input.next();\n    this.has_char_escapes = false;\n\n    if (c === '`') {\n      resulting_string += this._read_string_recursive('`', true, '${');\n    } else {\n      resulting_string += this._read_string_recursive(c);\n    }\n\n    if (this.has_char_escapes && this._options.unescape_strings) {\n      resulting_string = unescape_string(resulting_string);\n    }\n\n    if (this._input.peek() === c) {\n      resulting_string += this._input.next();\n    }\n\n    resulting_string = resulting_string.replace(acorn.allLineBreaks, '\\n');\n\n    return this._create_token(TOKEN.STRING, resulting_string);\n  }\n\n  return null;\n};\n\nTokenizer.prototype._allow_regexp_or_xml = function(previous_token) {\n  // regex and xml can only appear in specific locations during parsing\n  return (previous_token.type === TOKEN.RESERVED && in_array(previous_token.text, ['return', 'case', 'throw', 'else', 'do', 'typeof', 'yield'])) ||\n    (previous_token.type === TOKEN.END_EXPR && previous_token.text === ')' &&\n      previous_token.opened.previous.type === TOKEN.RESERVED && in_array(previous_token.opened.previous.text, ['if', 'while', 'for'])) ||\n    (in_array(previous_token.type, [TOKEN.COMMENT, TOKEN.START_EXPR, TOKEN.START_BLOCK, TOKEN.START,\n      TOKEN.END_BLOCK, TOKEN.OPERATOR, TOKEN.EQUALS, TOKEN.EOF, TOKEN.SEMICOLON, TOKEN.COMMA\n    ]));\n};\n\nTokenizer.prototype._read_regexp = function(c, previous_token) {\n\n  if (c === '/' && this._allow_regexp_or_xml(previous_token)) {\n    // handle regexp\n    //\n    var resulting_string = this._input.next();\n    var esc = false;\n\n    var in_char_class = false;\n    while (this._input.hasNext() &&\n      ((esc || in_char_class || this._input.peek() !== c) &&\n        !this._input.testChar(acorn.newline))) {\n      resulting_string += this._input.peek();\n      if (!esc) {\n        esc = this._input.peek() === '\\\\';\n        if (this._input.peek() === '[') {\n          in_char_class = true;\n        } else if (this._input.peek() === ']') {\n          in_char_class = false;\n        }\n      } else {\n        esc = false;\n      }\n      this._input.next();\n    }\n\n    if (this._input.peek() === c) {\n      resulting_string += this._input.next();\n\n      // regexps may have modifiers /regexp/MOD , so fetch those, too\n      // Only [gim] are valid, but if the user puts in garbage, do what we can to take it.\n      resulting_string += this._input.read(acorn.identifier);\n    }\n    return this._create_token(TOKEN.STRING, resulting_string);\n  }\n  return null;\n};\n\nTokenizer.prototype._read_xml = function(c, previous_token) {\n\n  if (this._options.e4x && c === \"<\" && this._allow_regexp_or_xml(previous_token)) {\n    var xmlStr = '';\n    var match = this.__patterns.xml.read_match();\n    // handle e4x xml literals\n    //\n    if (match) {\n      // Trim root tag to attempt to\n      var rootTag = match[2].replace(/^{\\s+/, '{').replace(/\\s+}$/, '}');\n      var isCurlyRoot = rootTag.indexOf('{') === 0;\n      var depth = 0;\n      while (match) {\n        var isEndTag = !!match[1];\n        var tagName = match[2];\n        var isSingletonTag = (!!match[match.length - 1]) || (tagName.slice(0, 8) === \"![CDATA[\");\n        if (!isSingletonTag &&\n          (tagName === rootTag || (isCurlyRoot && tagName.replace(/^{\\s+/, '{').replace(/\\s+}$/, '}')))) {\n          if (isEndTag) {\n            --depth;\n          } else {\n            ++depth;\n          }\n        }\n        xmlStr += match[0];\n        if (depth <= 0) {\n          break;\n        }\n        match = this.__patterns.xml.read_match();\n      }\n      // if we didn't close correctly, keep unformatted.\n      if (!match) {\n        xmlStr += this._input.match(/[\\s\\S]*/g)[0];\n      }\n      xmlStr = xmlStr.replace(acorn.allLineBreaks, '\\n');\n      return this._create_token(TOKEN.STRING, xmlStr);\n    }\n  }\n\n  return null;\n};\n\nfunction unescape_string(s) {\n  // You think that a regex would work for this\n  // return s.replace(/\\\\x([0-9a-f]{2})/gi, function(match, val) {\n  //         return String.fromCharCode(parseInt(val, 16));\n  //     })\n  // However, dealing with '\\xff', '\\\\xff', '\\\\\\xff' makes this more fun.\n  var out = '',\n    escaped = 0;\n\n  var input_scan = new InputScanner(s);\n  var matched = null;\n\n  while (input_scan.hasNext()) {\n    // Keep any whitespace, non-slash characters\n    // also keep slash pairs.\n    matched = input_scan.match(/([\\s]|[^\\\\]|\\\\\\\\)+/g);\n\n    if (matched) {\n      out += matched[0];\n    }\n\n    if (input_scan.peek() === '\\\\') {\n      input_scan.next();\n      if (input_scan.peek() === 'x') {\n        matched = input_scan.match(/x([0-9A-Fa-f]{2})/g);\n      } else if (input_scan.peek() === 'u') {\n        matched = input_scan.match(/u([0-9A-Fa-f]{4})/g);\n      } else {\n        out += '\\\\';\n        if (input_scan.hasNext()) {\n          out += input_scan.next();\n        }\n        continue;\n      }\n\n      // If there's some error decoding, return the original string\n      if (!matched) {\n        return s;\n      }\n\n      escaped = parseInt(matched[1], 16);\n\n      if (escaped > 0x7e && escaped <= 0xff && matched[0].indexOf('x') === 0) {\n        // we bail out on \\x7f..\\xff,\n        // leaving whole string escaped,\n        // as it's probably completely binary\n        return s;\n      } else if (escaped >= 0x00 && escaped < 0x20) {\n        // leave 0x00...0x1f escaped\n        out += '\\\\' + matched[0];\n        continue;\n      } else if (escaped === 0x22 || escaped === 0x27 || escaped === 0x5c) {\n        // single-quote, apostrophe, backslash - escape these\n        out += '\\\\' + String.fromCharCode(escaped);\n      } else {\n        out += String.fromCharCode(escaped);\n      }\n    }\n  }\n\n  return out;\n}\n\n// handle string\n//\nTokenizer.prototype._read_string_recursive = function(delimiter, allow_unescaped_newlines, start_sub) {\n  var current_char;\n  var pattern;\n  if (delimiter === '\\'') {\n    pattern = this.__patterns.single_quote;\n  } else if (delimiter === '\"') {\n    pattern = this.__patterns.double_quote;\n  } else if (delimiter === '`') {\n    pattern = this.__patterns.template_text;\n  } else if (delimiter === '}') {\n    pattern = this.__patterns.template_expression;\n  }\n\n  var resulting_string = pattern.read();\n  var next = '';\n  while (this._input.hasNext()) {\n    next = this._input.next();\n    if (next === delimiter ||\n      (!allow_unescaped_newlines && acorn.newline.test(next))) {\n      this._input.back();\n      break;\n    } else if (next === '\\\\' && this._input.hasNext()) {\n      current_char = this._input.peek();\n\n      if (current_char === 'x' || current_char === 'u') {\n        this.has_char_escapes = true;\n      } else if (current_char === '\\r' && this._input.peek(1) === '\\n') {\n        this._input.next();\n      }\n      next += this._input.next();\n    } else if (start_sub) {\n      if (start_sub === '${' && next === '$' && this._input.peek() === '{') {\n        next += this._input.next();\n      }\n\n      if (start_sub === next) {\n        if (delimiter === '`') {\n          next += this._read_string_recursive('}', allow_unescaped_newlines, '`');\n        } else {\n          next += this._read_string_recursive('`', allow_unescaped_newlines, '${');\n        }\n        if (this._input.hasNext()) {\n          next += this._input.next();\n        }\n      }\n    }\n    next += pattern.read();\n    resulting_string += next;\n  }\n\n  return resulting_string;\n};\n\nmodule.exports.Tokenizer = Tokenizer;\nmodule.exports.TOKEN = TOKEN;\nmodule.exports.positionable_operators = positionable_operators.slice();\nmodule.exports.line_starters = line_starters.slice();\n\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*jshint node:true */\n/*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/\n\n\n\nvar regexp_has_sticky = RegExp.prototype.hasOwnProperty('sticky');\n\nfunction InputScanner(input_string) {\n  this.__input = input_string || '';\n  this.__input_length = this.__input.length;\n  this.__position = 0;\n}\n\nInputScanner.prototype.restart = function() {\n  this.__position = 0;\n};\n\nInputScanner.prototype.back = function() {\n  if (this.__position > 0) {\n    this.__position -= 1;\n  }\n};\n\nInputScanner.prototype.hasNext = function() {\n  return this.__position < this.__input_length;\n};\n\nInputScanner.prototype.next = function() {\n  var val = null;\n  if (this.hasNext()) {\n    val = this.__input.charAt(this.__position);\n    this.__position += 1;\n  }\n  return val;\n};\n\nInputScanner.prototype.peek = function(index) {\n  var val = null;\n  index = index || 0;\n  index += this.__position;\n  if (index >= 0 && index < this.__input_length) {\n    val = this.__input.charAt(index);\n  }\n  return val;\n};\n\n// This is a JavaScript only helper function (not in python)\n// Javascript doesn't have a match method\n// and not all implementation support \"sticky\" flag.\n// If they do not support sticky then both this.match() and this.test() method\n// must get the match and check the index of the match.\n// If sticky is supported and set, this method will use it.\n// Otherwise it will check that global is set, and fall back to the slower method.\nInputScanner.prototype.__match = function(pattern, index) {\n  pattern.lastIndex = index;\n  var pattern_match = pattern.exec(this.__input);\n\n  if (pattern_match && !(regexp_has_sticky && pattern.sticky)) {\n    if (pattern_match.index !== index) {\n      pattern_match = null;\n    }\n  }\n\n  return pattern_match;\n};\n\nInputScanner.prototype.test = function(pattern, index) {\n  index = index || 0;\n  index += this.__position;\n\n  if (index >= 0 && index < this.__input_length) {\n    return !!this.__match(pattern, index);\n  } else {\n    return false;\n  }\n};\n\nInputScanner.prototype.testChar = function(pattern, index) {\n  // test one character regex match\n  var val = this.peek(index);\n  pattern.lastIndex = 0;\n  return val !== null && pattern.test(val);\n};\n\nInputScanner.prototype.match = function(pattern) {\n  var pattern_match = this.__match(pattern, this.__position);\n  if (pattern_match) {\n    this.__position += pattern_match[0].length;\n  } else {\n    pattern_match = null;\n  }\n  return pattern_match;\n};\n\nInputScanner.prototype.read = function(starting_pattern, until_pattern, until_after) {\n  var val = '';\n  var match;\n  if (starting_pattern) {\n    match = this.match(starting_pattern);\n    if (match) {\n      val += match[0];\n    }\n  }\n  if (until_pattern && (match || !starting_pattern)) {\n    val += this.readUntil(until_pattern, until_after);\n  }\n  return val;\n};\n\nInputScanner.prototype.readUntil = function(pattern, until_after) {\n  var val = '';\n  var match_index = this.__position;\n  pattern.lastIndex = this.__position;\n  var pattern_match = pattern.exec(this.__input);\n  if (pattern_match) {\n    match_index = pattern_match.index;\n    if (until_after) {\n      match_index += pattern_match[0].length;\n    }\n  } else {\n    match_index = this.__input_length;\n  }\n\n  val = this.__input.substring(this.__position, match_index);\n  this.__position = match_index;\n  return val;\n};\n\nInputScanner.prototype.readUntilAfter = function(pattern) {\n  return this.readUntil(pattern, true);\n};\n\nInputScanner.prototype.get_regexp = function(pattern, match_from) {\n  var result = null;\n  var flags = 'g';\n  if (match_from && regexp_has_sticky) {\n    flags = 'y';\n  }\n  // strings are converted to regexp\n  if (typeof pattern === \"string\" && pattern !== '') {\n    // result = new RegExp(pattern.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&'), flags);\n    result = new RegExp(pattern, flags);\n  } else if (pattern) {\n    result = new RegExp(pattern.source, flags);\n  }\n  return result;\n};\n\nInputScanner.prototype.get_literal_regexp = function(literal_string) {\n  return RegExp(literal_string.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&'));\n};\n\n/* css beautifier legacy helpers */\nInputScanner.prototype.peekUntilAfter = function(pattern) {\n  var start = this.__position;\n  var val = this.readUntilAfter(pattern);\n  this.__position = start;\n  return val;\n};\n\nInputScanner.prototype.lookBack = function(testVal) {\n  var start = this.__position - 1;\n  return start >= testVal.length && this.__input.substring(start - testVal.length, start)\n    .toLowerCase() === testVal;\n};\n\nmodule.exports.InputScanner = InputScanner;\n\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*jshint node:true */\n/*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/\n\n\n\nvar InputScanner = __webpack_require__(8).InputScanner;\nvar Token = __webpack_require__(3).Token;\nvar TokenStream = __webpack_require__(10).TokenStream;\nvar WhitespacePattern = __webpack_require__(11).WhitespacePattern;\n\nvar TOKEN = {\n  START: 'TK_START',\n  RAW: 'TK_RAW',\n  EOF: 'TK_EOF'\n};\n\nvar Tokenizer = function(input_string, options) {\n  this._input = new InputScanner(input_string);\n  this._options = options || {};\n  this.__tokens = null;\n\n  this._patterns = {};\n  this._patterns.whitespace = new WhitespacePattern(this._input);\n};\n\nTokenizer.prototype.tokenize = function() {\n  this._input.restart();\n  this.__tokens = new TokenStream();\n\n  this._reset();\n\n  var current;\n  var previous = new Token(TOKEN.START, '');\n  var open_token = null;\n  var open_stack = [];\n  var comments = new TokenStream();\n\n  while (previous.type !== TOKEN.EOF) {\n    current = this._get_next_token(previous, open_token);\n    while (this._is_comment(current)) {\n      comments.add(current);\n      current = this._get_next_token(previous, open_token);\n    }\n\n    if (!comments.isEmpty()) {\n      current.comments_before = comments;\n      comments = new TokenStream();\n    }\n\n    current.parent = open_token;\n\n    if (this._is_opening(current)) {\n      open_stack.push(open_token);\n      open_token = current;\n    } else if (open_token && this._is_closing(current, open_token)) {\n      current.opened = open_token;\n      open_token.closed = current;\n      open_token = open_stack.pop();\n      current.parent = open_token;\n    }\n\n    current.previous = previous;\n    previous.next = current;\n\n    this.__tokens.add(current);\n    previous = current;\n  }\n\n  return this.__tokens;\n};\n\n\nTokenizer.prototype._is_first_token = function() {\n  return this.__tokens.isEmpty();\n};\n\nTokenizer.prototype._reset = function() {};\n\nTokenizer.prototype._get_next_token = function(previous_token, open_token) { // jshint unused:false\n  this._readWhitespace();\n  var resulting_string = this._input.read(/.+/g);\n  if (resulting_string) {\n    return this._create_token(TOKEN.RAW, resulting_string);\n  } else {\n    return this._create_token(TOKEN.EOF, '');\n  }\n};\n\nTokenizer.prototype._is_comment = function(current_token) { // jshint unused:false\n  return false;\n};\n\nTokenizer.prototype._is_opening = function(current_token) { // jshint unused:false\n  return false;\n};\n\nTokenizer.prototype._is_closing = function(current_token, open_token) { // jshint unused:false\n  return false;\n};\n\nTokenizer.prototype._create_token = function(type, text) {\n  var token = new Token(type, text,\n    this._patterns.whitespace.newline_count,\n    this._patterns.whitespace.whitespace_before_token);\n  return token;\n};\n\nTokenizer.prototype._readWhitespace = function() {\n  return this._patterns.whitespace.read();\n};\n\n\n\nmodule.exports.Tokenizer = Tokenizer;\nmodule.exports.TOKEN = TOKEN;\n\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*jshint node:true */\n/*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/\n\n\n\nfunction TokenStream(parent_token) {\n  // private\n  this.__tokens = [];\n  this.__tokens_length = this.__tokens.length;\n  this.__position = 0;\n  this.__parent_token = parent_token;\n}\n\nTokenStream.prototype.restart = function() {\n  this.__position = 0;\n};\n\nTokenStream.prototype.isEmpty = function() {\n  return this.__tokens_length === 0;\n};\n\nTokenStream.prototype.hasNext = function() {\n  return this.__position < this.__tokens_length;\n};\n\nTokenStream.prototype.next = function() {\n  var val = null;\n  if (this.hasNext()) {\n    val = this.__tokens[this.__position];\n    this.__position += 1;\n  }\n  return val;\n};\n\nTokenStream.prototype.peek = function(index) {\n  var val = null;\n  index = index || 0;\n  index += this.__position;\n  if (index >= 0 && index < this.__tokens_length) {\n    val = this.__tokens[index];\n  }\n  return val;\n};\n\nTokenStream.prototype.add = function(token) {\n  if (this.__parent_token) {\n    token.parent = this.__parent_token;\n  }\n  this.__tokens.push(token);\n  this.__tokens_length += 1;\n};\n\nmodule.exports.TokenStream = TokenStream;\n\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*jshint node:true */\n/*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/\n\n\n\nvar Pattern = __webpack_require__(12).Pattern;\n\nfunction WhitespacePattern(input_scanner, parent) {\n  Pattern.call(this, input_scanner, parent);\n  if (parent) {\n    this._line_regexp = this._input.get_regexp(parent._line_regexp);\n  } else {\n    this.__set_whitespace_patterns('', '');\n  }\n\n  this.newline_count = 0;\n  this.whitespace_before_token = '';\n}\nWhitespacePattern.prototype = new Pattern();\n\nWhitespacePattern.prototype.__set_whitespace_patterns = function(whitespace_chars, newline_chars) {\n  whitespace_chars += '\\\\t ';\n  newline_chars += '\\\\n\\\\r';\n\n  this._match_pattern = this._input.get_regexp(\n    '[' + whitespace_chars + newline_chars + ']+', true);\n  this._newline_regexp = this._input.get_regexp(\n    '\\\\r\\\\n|[' + newline_chars + ']');\n};\n\nWhitespacePattern.prototype.read = function() {\n  this.newline_count = 0;\n  this.whitespace_before_token = '';\n\n  var resulting_string = this._input.read(this._match_pattern);\n  if (resulting_string === ' ') {\n    this.whitespace_before_token = ' ';\n  } else if (resulting_string) {\n    var matches = this.__split(this._newline_regexp, resulting_string);\n    this.newline_count = matches.length - 1;\n    this.whitespace_before_token = matches[this.newline_count];\n  }\n\n  return resulting_string;\n};\n\nWhitespacePattern.prototype.matching = function(whitespace_chars, newline_chars) {\n  var result = this._create();\n  result.__set_whitespace_patterns(whitespace_chars, newline_chars);\n  result._update();\n  return result;\n};\n\nWhitespacePattern.prototype._create = function() {\n  return new WhitespacePattern(this._input, this);\n};\n\nWhitespacePattern.prototype.__split = function(regexp, input_string) {\n  regexp.lastIndex = 0;\n  var start_index = 0;\n  var result = [];\n  var next_match = regexp.exec(input_string);\n  while (next_match) {\n    result.push(input_string.substring(start_index, next_match.index));\n    start_index = next_match.index + next_match[0].length;\n    next_match = regexp.exec(input_string);\n  }\n\n  if (start_index < input_string.length) {\n    result.push(input_string.substring(start_index, input_string.length));\n  } else {\n    result.push('');\n  }\n\n  return result;\n};\n\n\n\nmodule.exports.WhitespacePattern = WhitespacePattern;\n\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*jshint node:true */\n/*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/\n\n\n\nfunction Pattern(input_scanner, parent) {\n  this._input = input_scanner;\n  this._starting_pattern = null;\n  this._match_pattern = null;\n  this._until_pattern = null;\n  this._until_after = false;\n\n  if (parent) {\n    this._starting_pattern = this._input.get_regexp(parent._starting_pattern, true);\n    this._match_pattern = this._input.get_regexp(parent._match_pattern, true);\n    this._until_pattern = this._input.get_regexp(parent._until_pattern);\n    this._until_after = parent._until_after;\n  }\n}\n\nPattern.prototype.read = function() {\n  var result = this._input.read(this._starting_pattern);\n  if (!this._starting_pattern || result) {\n    result += this._input.read(this._match_pattern, this._until_pattern, this._until_after);\n  }\n  return result;\n};\n\nPattern.prototype.read_match = function() {\n  return this._input.match(this._match_pattern);\n};\n\nPattern.prototype.until_after = function(pattern) {\n  var result = this._create();\n  result._until_after = true;\n  result._until_pattern = this._input.get_regexp(pattern);\n  result._update();\n  return result;\n};\n\nPattern.prototype.until = function(pattern) {\n  var result = this._create();\n  result._until_after = false;\n  result._until_pattern = this._input.get_regexp(pattern);\n  result._update();\n  return result;\n};\n\nPattern.prototype.starting_with = function(pattern) {\n  var result = this._create();\n  result._starting_pattern = this._input.get_regexp(pattern, true);\n  result._update();\n  return result;\n};\n\nPattern.prototype.matching = function(pattern) {\n  var result = this._create();\n  result._match_pattern = this._input.get_regexp(pattern, true);\n  result._update();\n  return result;\n};\n\nPattern.prototype._create = function() {\n  return new Pattern(this._input, this);\n};\n\nPattern.prototype._update = function() {};\n\nmodule.exports.Pattern = Pattern;\n\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*jshint node:true */\n/*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/\n\n\n\nfunction Directives(start_block_pattern, end_block_pattern) {\n  start_block_pattern = typeof start_block_pattern === 'string' ? start_block_pattern : start_block_pattern.source;\n  end_block_pattern = typeof end_block_pattern === 'string' ? end_block_pattern : end_block_pattern.source;\n  this.__directives_block_pattern = new RegExp(start_block_pattern + / beautify( \\w+[:]\\w+)+ /.source + end_block_pattern, 'g');\n  this.__directive_pattern = / (\\w+)[:](\\w+)/g;\n\n  this.__directives_end_ignore_pattern = new RegExp(start_block_pattern + /\\sbeautify\\signore:end\\s/.source + end_block_pattern, 'g');\n}\n\nDirectives.prototype.get_directives = function(text) {\n  if (!text.match(this.__directives_block_pattern)) {\n    return null;\n  }\n\n  var directives = {};\n  this.__directive_pattern.lastIndex = 0;\n  var directive_match = this.__directive_pattern.exec(text);\n\n  while (directive_match) {\n    directives[directive_match[1]] = directive_match[2];\n    directive_match = this.__directive_pattern.exec(text);\n  }\n\n  return directives;\n};\n\nDirectives.prototype.readIgnored = function(input) {\n  return input.readUntilAfter(this.__directives_end_ignore_pattern);\n};\n\n\nmodule.exports.Directives = Directives;\n\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*jshint node:true */\n/*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/\n\n\n\nvar Pattern = __webpack_require__(12).Pattern;\n\n\nvar template_names = {\n  django: false,\n  erb: false,\n  handlebars: false,\n  php: false\n};\n\n// This lets templates appear anywhere we would do a readUntil\n// The cost is higher but it is pay to play.\nfunction TemplatablePattern(input_scanner, parent) {\n  Pattern.call(this, input_scanner, parent);\n  this.__template_pattern = null;\n  this._disabled = Object.assign({}, template_names);\n  this._excluded = Object.assign({}, template_names);\n\n  if (parent) {\n    this.__template_pattern = this._input.get_regexp(parent.__template_pattern);\n    this._excluded = Object.assign(this._excluded, parent._excluded);\n    this._disabled = Object.assign(this._disabled, parent._disabled);\n  }\n  var pattern = new Pattern(input_scanner);\n  this.__patterns = {\n    handlebars_comment: pattern.starting_with(/{{!--/).until_after(/--}}/),\n    handlebars_unescaped: pattern.starting_with(/{{{/).until_after(/}}}/),\n    handlebars: pattern.starting_with(/{{/).until_after(/}}/),\n    php: pattern.starting_with(/<\\?(?:[=]|php)/).until_after(/\\?>/),\n    erb: pattern.starting_with(/<%[^%]/).until_after(/[^%]%>/),\n    // django coflicts with handlebars a bit.\n    django: pattern.starting_with(/{%/).until_after(/%}/),\n    django_value: pattern.starting_with(/{{/).until_after(/}}/),\n    django_comment: pattern.starting_with(/{#/).until_after(/#}/)\n  };\n}\nTemplatablePattern.prototype = new Pattern();\n\nTemplatablePattern.prototype._create = function() {\n  return new TemplatablePattern(this._input, this);\n};\n\nTemplatablePattern.prototype._update = function() {\n  this.__set_templated_pattern();\n};\n\nTemplatablePattern.prototype.disable = function(language) {\n  var result = this._create();\n  result._disabled[language] = true;\n  result._update();\n  return result;\n};\n\nTemplatablePattern.prototype.read_options = function(options) {\n  var result = this._create();\n  for (var language in template_names) {\n    result._disabled[language] = options.templating.indexOf(language) === -1;\n  }\n  result._update();\n  return result;\n};\n\nTemplatablePattern.prototype.exclude = function(language) {\n  var result = this._create();\n  result._excluded[language] = true;\n  result._update();\n  return result;\n};\n\nTemplatablePattern.prototype.read = function() {\n  var result = '';\n  if (this._match_pattern) {\n    result = this._input.read(this._starting_pattern);\n  } else {\n    result = this._input.read(this._starting_pattern, this.__template_pattern);\n  }\n  var next = this._read_template();\n  while (next) {\n    if (this._match_pattern) {\n      next += this._input.read(this._match_pattern);\n    } else {\n      next += this._input.readUntil(this.__template_pattern);\n    }\n    result += next;\n    next = this._read_template();\n  }\n\n  if (this._until_after) {\n    result += this._input.readUntilAfter(this._until_pattern);\n  }\n  return result;\n};\n\nTemplatablePattern.prototype.__set_templated_pattern = function() {\n  var items = [];\n\n  if (!this._disabled.php) {\n    items.push(this.__patterns.php._starting_pattern.source);\n  }\n  if (!this._disabled.handlebars) {\n    items.push(this.__patterns.handlebars._starting_pattern.source);\n  }\n  if (!this._disabled.erb) {\n    items.push(this.__patterns.erb._starting_pattern.source);\n  }\n  if (!this._disabled.django) {\n    items.push(this.__patterns.django._starting_pattern.source);\n    items.push(this.__patterns.django_value._starting_pattern.source);\n    items.push(this.__patterns.django_comment._starting_pattern.source);\n  }\n\n  if (this._until_pattern) {\n    items.push(this._until_pattern.source);\n  }\n  this.__template_pattern = this._input.get_regexp('(?:' + items.join('|') + ')');\n};\n\nTemplatablePattern.prototype._read_template = function() {\n  var resulting_string = '';\n  var c = this._input.peek();\n  if (c === '<') {\n    var peek1 = this._input.peek(1);\n    //if we're in a comment, do something special\n    // We treat all comments as literals, even more than preformatted tags\n    // we just look for the appropriate close tag\n    if (!this._disabled.php && !this._excluded.php && peek1 === '?') {\n      resulting_string = resulting_string ||\n        this.__patterns.php.read();\n    }\n    if (!this._disabled.erb && !this._excluded.erb && peek1 === '%') {\n      resulting_string = resulting_string ||\n        this.__patterns.erb.read();\n    }\n  } else if (c === '{') {\n    if (!this._disabled.handlebars && !this._excluded.handlebars) {\n      resulting_string = resulting_string ||\n        this.__patterns.handlebars_comment.read();\n      resulting_string = resulting_string ||\n        this.__patterns.handlebars_unescaped.read();\n      resulting_string = resulting_string ||\n        this.__patterns.handlebars.read();\n    }\n    if (!this._disabled.django) {\n      // django coflicts with handlebars a bit.\n      if (!this._excluded.django && !this._excluded.handlebars) {\n        resulting_string = resulting_string ||\n          this.__patterns.django_value.read();\n      }\n      if (!this._excluded.django) {\n        resulting_string = resulting_string ||\n          this.__patterns.django_comment.read();\n        resulting_string = resulting_string ||\n          this.__patterns.django.read();\n      }\n    }\n  }\n  return resulting_string;\n};\n\n\nmodule.exports.TemplatablePattern = TemplatablePattern;\n\n\n/***/ })\n/******/ ]);\nvar js_beautify = legacy_beautify_js;\n/* Footer */\nif (true) {\n    // Add support for AMD ( https://github.com/amdjs/amdjs-api/wiki/AMD#defineamd-property- )\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n        return { js_beautify: js_beautify };\n    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n} else {}\n\n}());\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanMtYmVhdXRpZnkvanMvbGliL2JlYXV0aWZ5LmpzP2U5NDMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUI7QUFDdkI7QUFDQSxvQkFBb0I7QUFDcEIsYUFBYTs7QUFFYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxnQ0FBZ0M7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLGtCQUFrQjtBQUNsRjtBQUNBLHlEQUF5RCxjQUFjO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGlDQUFpQztBQUNsRix3SEFBd0gsbUJBQW1CLEVBQUU7QUFDN0k7QUFDQTtBQUNB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Q0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGNBQWM7QUFDakM7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGNBQWM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLCtCQUErQixVQUFVO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEdBQTRHO0FBQzVHO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLG9CQUFvQjtBQUNwQixvQkFBb0IsUUFBUSxlQUFlO0FBQzNDLG9CQUFvQixVQUFVLGVBQWU7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsd0NBQXdDO0FBQ3hDLHVFQUF1RTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0ZBQXdGO0FBQ3hGO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBd0M7QUFDeEM7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsNENBQTRDO0FBQzVDO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUEsMEVBQTBFO0FBQzFFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHLE9BQU87QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxrREFBa0Q7QUFDbEQ7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyREFBMkQsVUFBVTtBQUNyRTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlEQUFpRCxLQUFLO0FBQ3RELGlHQUFpRztBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxzRkFBc0Y7QUFDdEY7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0MsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUcseUlBQXlJO0FBQzVJLHlCQUF5QixLQUFLO0FBQzlCLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBDQUEwQztBQUMxQyxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSx5Q0FBeUMsdUNBQXVDO0FBQ2hGLFVBQVUsS0FBSztBQUNmLGVBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGVBQWUsa0JBQWtCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1REFBdUQsd0JBQXdCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLG9CQUFvQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qjs7O0FBRzlCLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJDQUEyQyxFQUFFO0FBQzdDLDJDQUEyQyxFQUFFOztBQUU3QztBQUNBO0FBQ0EsMERBQTBELEVBQUU7O0FBRTVELCtFQUErRTs7QUFFL0U7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0EsR0FBRywyREFBMkQ7QUFDOUQ7QUFDQSxHQUFHLDhEQUE4RDtBQUNqRTtBQUNBLFFBQVEsNkJBQTZCO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxxQ0FBcUM7QUFDckM7O0FBRUEsa0JBQWtCLCtCQUErQjtBQUNqRDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7QUFJQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUNBQWlDLDRDQUE0QyxFQUFFO0FBQy9FOzs7QUFHQTtBQUNBLG1CQUFtQixVQUFVO0FBQzdCO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDREQUE0RDtBQUM1RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLDRFQUE0RTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUEsMkRBQTJEO0FBQzNEO0FBQ0E7O0FBRUEsMkRBQTJEO0FBQzNEO0FBQ0E7O0FBRUEsdUVBQXVFO0FBQ3ZFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOzs7O0FBSUE7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsbUNBQW1DOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCx1QkFBdUI7QUFDeEUsb0RBQW9ELG1CQUFtQjtBQUN2RSx5Q0FBeUMsa0JBQWtCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxtQkFBbUI7QUFDdkQsMkNBQTJDLGtCQUFrQjtBQUM3RCw0Q0FBNEMsbUJBQW1CO0FBQy9EO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxrQkFBa0I7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLElBQUksSUFBMEM7QUFDOUM7QUFDQSxJQUFJLGlDQUFPLEVBQUUsbUNBQUU7QUFDZixnQkFBZ0I7QUFDaEIsS0FBSztBQUFBLG9HQUFDO0FBQ04sQ0FBQyxNQUFNLEVBVU47O0FBRUQsQ0FBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9qcy1iZWF1dGlmeS9qcy9saWIvYmVhdXRpZnkuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBBVVRPLUdFTkVSQVRFRC4gRE8gTk9UIE1PRElGWS4gKi9cbi8qXG5cbiAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiAgQ29weXJpZ2h0IChjKSAyMDA3LTIwMTggRWluYXIgTGllbG1hbmlzLCBMaWFtIE5ld21hbiwgYW5kIGNvbnRyaWJ1dG9ycy5cblxuICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gIFNPRlRXQVJFLlxuXG4gSlMgQmVhdXRpZmllclxuLS0tLS0tLS0tLS0tLS0tXG5cblxuICBXcml0dGVuIGJ5IEVpbmFyIExpZWxtYW5pcywgPGVpbmFyQGJlYXV0aWZpZXIuaW8+XG4gICAgICBodHRwczovL2JlYXV0aWZpZXIuaW8vXG5cbiAgT3JpZ2luYWxseSBjb252ZXJ0ZWQgdG8gamF2YXNjcmlwdCBieSBWaXRhbCwgPHZpdGFsNzZAZ21haWwuY29tPlxuICBcIkVuZCBicmFjZXMgb24gb3duIGxpbmVcIiBhZGRlZCBieSBDaHJpcyBKLiBTaHVsbCwgPGNocmlzanNodWxsQGdtYWlsLmNvbT5cbiAgUGFyc2luZyBpbXByb3ZlbWVudHMgZm9yIGJyYWNlLWxlc3Mgc3RhdGVtZW50cyBieSBMaWFtIE5ld21hbiA8Yml0d2lzZW1hbkBiZWF1dGlmaWVyLmlvPlxuXG5cbiAgVXNhZ2U6XG4gICAganNfYmVhdXRpZnkoanNfc291cmNlX3RleHQpO1xuICAgIGpzX2JlYXV0aWZ5KGpzX3NvdXJjZV90ZXh0LCBvcHRpb25zKTtcblxuICBUaGUgb3B0aW9ucyBhcmU6XG4gICAgaW5kZW50X3NpemUgKGRlZmF1bHQgNCkgICAgICAgICAgLSBpbmRlbnRhdGlvbiBzaXplLFxuICAgIGluZGVudF9jaGFyIChkZWZhdWx0IHNwYWNlKSAgICAgIC0gY2hhcmFjdGVyIHRvIGluZGVudCB3aXRoLFxuICAgIHByZXNlcnZlX25ld2xpbmVzIChkZWZhdWx0IHRydWUpIC0gd2hldGhlciBleGlzdGluZyBsaW5lIGJyZWFrcyBzaG91bGQgYmUgcHJlc2VydmVkLFxuICAgIG1heF9wcmVzZXJ2ZV9uZXdsaW5lcyAoZGVmYXVsdCB1bmxpbWl0ZWQpIC0gbWF4aW11bSBudW1iZXIgb2YgbGluZSBicmVha3MgdG8gYmUgcHJlc2VydmVkIGluIG9uZSBjaHVuayxcblxuICAgIGpzbGludF9oYXBweSAoZGVmYXVsdCBmYWxzZSkgLSBpZiB0cnVlLCB0aGVuIGpzbGludC1zdHJpY3RlciBtb2RlIGlzIGVuZm9yY2VkLlxuXG4gICAgICAgICAgICBqc2xpbnRfaGFwcHkgICAgICAgICFqc2xpbnRfaGFwcHlcbiAgICAgICAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgZnVuY3Rpb24gKCkgICAgICAgICBmdW5jdGlvbigpXG5cbiAgICAgICAgICAgIHN3aXRjaCAoKSB7ICAgICAgICAgc3dpdGNoKCkge1xuICAgICAgICAgICAgY2FzZSAxOiAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgYnJlYWs7ICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSAgICAgICAgICAgICAgICAgICB9XG5cbiAgICBzcGFjZV9hZnRlcl9hbm9uX2Z1bmN0aW9uIChkZWZhdWx0IGZhbHNlKSAtIHNob3VsZCB0aGUgc3BhY2UgYmVmb3JlIGFuIGFub255bW91cyBmdW5jdGlvbidzIHBhcmVucyBiZSBhZGRlZCwgXCJmdW5jdGlvbigpXCIgdnMgXCJmdW5jdGlvbiAoKVwiLFxuICAgICAgICAgIE5PVEU6IFRoaXMgb3B0aW9uIGlzIG92ZXJyaWRlbiBieSBqc2xpbnRfaGFwcHkgKGkuZS4gaWYganNsaW50X2hhcHB5IGlzIHRydWUsIHNwYWNlX2FmdGVyX2Fub25fZnVuY3Rpb24gaXMgdHJ1ZSBieSBkZXNpZ24pXG5cbiAgICBicmFjZV9zdHlsZSAoZGVmYXVsdCBcImNvbGxhcHNlXCIpIC0gXCJjb2xsYXBzZVwiIHwgXCJleHBhbmRcIiB8IFwiZW5kLWV4cGFuZFwiIHwgXCJub25lXCIgfCBhbnkgb2YgdGhlIGZvcm1lciArIFwiLHByZXNlcnZlLWlubGluZVwiXG4gICAgICAgICAgICBwdXQgYnJhY2VzIG9uIHRoZSBzYW1lIGxpbmUgYXMgY29udHJvbCBzdGF0ZW1lbnRzIChkZWZhdWx0KSwgb3IgcHV0IGJyYWNlcyBvbiBvd24gbGluZSAoQWxsbWFuIC8gQU5TSSBzdHlsZSksIG9yIGp1c3QgcHV0IGVuZCBicmFjZXMgb24gb3duIGxpbmUsIG9yIGF0dGVtcHQgdG8ga2VlcCB0aGVtIHdoZXJlIHRoZXkgYXJlLlxuICAgICAgICAgICAgcHJlc2VydmUtaW5saW5lIHdpbGwgdHJ5IHRvIHByZXNlcnZlIGlubGluZSBibG9ja3Mgb2YgY3VybHkgYnJhY2VzXG5cbiAgICBzcGFjZV9iZWZvcmVfY29uZGl0aW9uYWwgKGRlZmF1bHQgdHJ1ZSkgLSBzaG91bGQgdGhlIHNwYWNlIGJlZm9yZSBjb25kaXRpb25hbCBzdGF0ZW1lbnQgYmUgYWRkZWQsIFwiaWYodHJ1ZSlcIiB2cyBcImlmICh0cnVlKVwiLFxuXG4gICAgdW5lc2NhcGVfc3RyaW5ncyAoZGVmYXVsdCBmYWxzZSkgLSBzaG91bGQgcHJpbnRhYmxlIGNoYXJhY3RlcnMgaW4gc3RyaW5ncyBlbmNvZGVkIGluIFxceE5OIG5vdGF0aW9uIGJlIHVuZXNjYXBlZCwgXCJleGFtcGxlXCIgdnMgXCJcXHg2NVxceDc4XFx4NjFcXHg2ZFxceDcwXFx4NmNcXHg2NVwiXG5cbiAgICB3cmFwX2xpbmVfbGVuZ3RoIChkZWZhdWx0IHVubGltaXRlZCkgLSBsaW5lcyBzaG91bGQgd3JhcCBhdCBuZXh0IG9wcG9ydHVuaXR5IGFmdGVyIHRoaXMgbnVtYmVyIG9mIGNoYXJhY3RlcnMuXG4gICAgICAgICAgTk9URTogVGhpcyBpcyBub3QgYSBoYXJkIGxpbWl0LiBMaW5lcyB3aWxsIGNvbnRpbnVlIHVudGlsIGEgcG9pbnQgd2hlcmUgYSBuZXdsaW5lIHdvdWxkXG4gICAgICAgICAgICAgICAgYmUgcHJlc2VydmVkIGlmIGl0IHdlcmUgcHJlc2VudC5cblxuICAgIGVuZF93aXRoX25ld2xpbmUgKGRlZmF1bHQgZmFsc2UpICAtIGVuZCBvdXRwdXQgd2l0aCBhIG5ld2xpbmVcblxuXG4gICAgZS5nXG5cbiAgICBqc19iZWF1dGlmeShqc19zb3VyY2VfdGV4dCwge1xuICAgICAgJ2luZGVudF9zaXplJzogMSxcbiAgICAgICdpbmRlbnRfY2hhcic6ICdcXHQnXG4gICAgfSk7XG5cbiovXG5cbihmdW5jdGlvbigpIHtcblxuLyogR0VORVJBVEVEX0JVSUxEX09VVFBVVCAqL1xudmFyIGxlZ2FjeV9iZWF1dGlmeV9qcyA9XG4vKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdGk6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bDogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuLyoqKioqKi8gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuLyoqKioqKi8gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3Rcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4vKioqKioqLyBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuLyoqKioqKi8gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3Rcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4vKioqKioqLyBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbi8qKioqKiovIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4vKioqKioqLyBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gbnM7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbi8qKioqKiovIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gZ2V0dGVyO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDApO1xuLyoqKioqKi8gfSlcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAoW1xuLyogMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qanNoaW50IG5vZGU6dHJ1ZSAqL1xuLypcblxuICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxOCBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgU09GVFdBUkUuXG4qL1xuXG5cblxudmFyIEJlYXV0aWZpZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpLkJlYXV0aWZpZXIsXG4gIE9wdGlvbnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpLk9wdGlvbnM7XG5cbmZ1bmN0aW9uIGpzX2JlYXV0aWZ5KGpzX3NvdXJjZV90ZXh0LCBvcHRpb25zKSB7XG4gIHZhciBiZWF1dGlmaWVyID0gbmV3IEJlYXV0aWZpZXIoanNfc291cmNlX3RleHQsIG9wdGlvbnMpO1xuICByZXR1cm4gYmVhdXRpZmllci5iZWF1dGlmeSgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGpzX2JlYXV0aWZ5O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdE9wdGlvbnMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBPcHRpb25zKCk7XG59O1xuXG5cbi8qKiovIH0pLFxuLyogMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qanNoaW50IG5vZGU6dHJ1ZSAqL1xuLypcblxuICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxOCBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgU09GVFdBUkUuXG4qL1xuXG5cblxudmFyIE91dHB1dCA9IF9fd2VicGFja19yZXF1aXJlX18oMikuT3V0cHV0O1xudmFyIFRva2VuID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKS5Ub2tlbjtcbnZhciBhY29ybiA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG52YXIgT3B0aW9ucyA9IF9fd2VicGFja19yZXF1aXJlX18oNSkuT3B0aW9ucztcbnZhciBUb2tlbml6ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpLlRva2VuaXplcjtcbnZhciBsaW5lX3N0YXJ0ZXJzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KS5saW5lX3N0YXJ0ZXJzO1xudmFyIHBvc2l0aW9uYWJsZV9vcGVyYXRvcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpLnBvc2l0aW9uYWJsZV9vcGVyYXRvcnM7XG52YXIgVE9LRU4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpLlRPS0VOO1xuXG5cbmZ1bmN0aW9uIGluX2FycmF5KHdoYXQsIGFycikge1xuICByZXR1cm4gYXJyLmluZGV4T2Yod2hhdCkgIT09IC0xO1xufVxuXG5mdW5jdGlvbiBsdHJpbShzKSB7XG4gIHJldHVybiBzLnJlcGxhY2UoL15cXHMrL2csICcnKTtcbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVNYXBGcm9tU3RyaW5ncyhsaXN0KSB7XG4gIHZhciByZXN1bHQgPSB7fTtcbiAgZm9yICh2YXIgeCA9IDA7IHggPCBsaXN0Lmxlbmd0aDsgeCsrKSB7XG4gICAgLy8gbWFrZSB0aGUgbWFwcGVkIG5hbWVzIHVuZGVyc2NvcmVkIGluc3RlYWQgb2YgZGFzaFxuICAgIHJlc3VsdFtsaXN0W3hdLnJlcGxhY2UoLy0vZywgJ18nKV0gPSBsaXN0W3hdO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHJlc2VydmVkX3dvcmQodG9rZW4sIHdvcmQpIHtcbiAgcmV0dXJuIHRva2VuICYmIHRva2VuLnR5cGUgPT09IFRPS0VOLlJFU0VSVkVEICYmIHRva2VuLnRleHQgPT09IHdvcmQ7XG59XG5cbmZ1bmN0aW9uIHJlc2VydmVkX2FycmF5KHRva2VuLCB3b3Jkcykge1xuICByZXR1cm4gdG9rZW4gJiYgdG9rZW4udHlwZSA9PT0gVE9LRU4uUkVTRVJWRUQgJiYgaW5fYXJyYXkodG9rZW4udGV4dCwgd29yZHMpO1xufVxuLy8gVW5zdXJlIG9mIHdoYXQgdGhleSBtZWFuLCBidXQgdGhleSB3b3JrLiBXb3J0aCBjbGVhbmluZyB1cCBpbiBmdXR1cmUuXG52YXIgc3BlY2lhbF93b3JkcyA9IFsnY2FzZScsICdyZXR1cm4nLCAnZG8nLCAnaWYnLCAndGhyb3cnLCAnZWxzZScsICdhd2FpdCcsICdicmVhaycsICdjb250aW51ZScsICdhc3luYyddO1xuXG52YXIgdmFsaWRQb3NpdGlvblZhbHVlcyA9IFsnYmVmb3JlLW5ld2xpbmUnLCAnYWZ0ZXItbmV3bGluZScsICdwcmVzZXJ2ZS1uZXdsaW5lJ107XG5cbi8vIEdlbmVyYXRlIG1hcCBmcm9tIGFycmF5XG52YXIgT1BFUkFUT1JfUE9TSVRJT04gPSBnZW5lcmF0ZU1hcEZyb21TdHJpbmdzKHZhbGlkUG9zaXRpb25WYWx1ZXMpO1xuXG52YXIgT1BFUkFUT1JfUE9TSVRJT05fQkVGT1JFX09SX1BSRVNFUlZFID0gW09QRVJBVE9SX1BPU0lUSU9OLmJlZm9yZV9uZXdsaW5lLCBPUEVSQVRPUl9QT1NJVElPTi5wcmVzZXJ2ZV9uZXdsaW5lXTtcblxudmFyIE1PREUgPSB7XG4gIEJsb2NrU3RhdGVtZW50OiAnQmxvY2tTdGF0ZW1lbnQnLCAvLyAnQkxPQ0snXG4gIFN0YXRlbWVudDogJ1N0YXRlbWVudCcsIC8vICdTVEFURU1FTlQnXG4gIE9iamVjdExpdGVyYWw6ICdPYmplY3RMaXRlcmFsJywgLy8gJ09CSkVDVCcsXG4gIEFycmF5TGl0ZXJhbDogJ0FycmF5TGl0ZXJhbCcsIC8vJ1tFWFBSRVNTSU9OXScsXG4gIEZvckluaXRpYWxpemVyOiAnRm9ySW5pdGlhbGl6ZXInLCAvLycoRk9SLUVYUFJFU1NJT04pJyxcbiAgQ29uZGl0aW9uYWw6ICdDb25kaXRpb25hbCcsIC8vJyhDT05ELUVYUFJFU1NJT04pJyxcbiAgRXhwcmVzc2lvbjogJ0V4cHJlc3Npb24nIC8vJyhFWFBSRVNTSU9OKSdcbn07XG5cbmZ1bmN0aW9uIHJlbW92ZV9yZWR1bmRhbnRfaW5kZW50YXRpb24ob3V0cHV0LCBmcmFtZSkge1xuICAvLyBUaGlzIGltcGxlbWVudGF0aW9uIGlzIGVmZmVjdGl2ZSBidXQgaGFzIHNvbWUgaXNzdWVzOlxuICAvLyAgICAgLSBjYW4gY2F1c2UgbGluZSB3cmFwIHRvIGhhcHBlbiB0b28gc29vbiBkdWUgdG8gaW5kZW50IHJlbW92YWxcbiAgLy8gICAgICAgICAgIGFmdGVyIHdyYXAgcG9pbnRzIGFyZSBjYWxjdWxhdGVkXG4gIC8vIFRoZXNlIGlzc3VlcyBhcmUgbWlub3IgY29tcGFyZWQgdG8gdWdseSBpbmRlbnRhdGlvbi5cblxuICBpZiAoZnJhbWUubXVsdGlsaW5lX2ZyYW1lIHx8XG4gICAgZnJhbWUubW9kZSA9PT0gTU9ERS5Gb3JJbml0aWFsaXplciB8fFxuICAgIGZyYW1lLm1vZGUgPT09IE1PREUuQ29uZGl0aW9uYWwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyByZW1vdmUgb25lIGluZGVudCBmcm9tIGVhY2ggbGluZSBpbnNpZGUgdGhpcyBzZWN0aW9uXG4gIG91dHB1dC5yZW1vdmVfaW5kZW50KGZyYW1lLnN0YXJ0X2xpbmVfaW5kZXgpO1xufVxuXG4vLyB3ZSBjb3VsZCB1c2UganVzdCBzdHJpbmcuc3BsaXQsIGJ1dFxuLy8gSUUgZG9lc24ndCBsaWtlIHJldHVybmluZyBlbXB0eSBzdHJpbmdzXG5mdW5jdGlvbiBzcGxpdF9saW5lYnJlYWtzKHMpIHtcbiAgLy9yZXR1cm4gcy5zcGxpdCgvXFx4MGRcXHgwYXxcXHgwYS8pO1xuXG4gIHMgPSBzLnJlcGxhY2UoYWNvcm4uYWxsTGluZUJyZWFrcywgJ1xcbicpO1xuICB2YXIgb3V0ID0gW10sXG4gICAgaWR4ID0gcy5pbmRleE9mKFwiXFxuXCIpO1xuICB3aGlsZSAoaWR4ICE9PSAtMSkge1xuICAgIG91dC5wdXNoKHMuc3Vic3RyaW5nKDAsIGlkeCkpO1xuICAgIHMgPSBzLnN1YnN0cmluZyhpZHggKyAxKTtcbiAgICBpZHggPSBzLmluZGV4T2YoXCJcXG5cIik7XG4gIH1cbiAgaWYgKHMubGVuZ3RoKSB7XG4gICAgb3V0LnB1c2gocyk7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cblxuZnVuY3Rpb24gaXNfYXJyYXkobW9kZSkge1xuICByZXR1cm4gbW9kZSA9PT0gTU9ERS5BcnJheUxpdGVyYWw7XG59XG5cbmZ1bmN0aW9uIGlzX2V4cHJlc3Npb24obW9kZSkge1xuICByZXR1cm4gaW5fYXJyYXkobW9kZSwgW01PREUuRXhwcmVzc2lvbiwgTU9ERS5Gb3JJbml0aWFsaXplciwgTU9ERS5Db25kaXRpb25hbF0pO1xufVxuXG5mdW5jdGlvbiBhbGxfbGluZXNfc3RhcnRfd2l0aChsaW5lcywgYykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGxpbmUgPSBsaW5lc1tpXS50cmltKCk7XG4gICAgaWYgKGxpbmUuY2hhckF0KDApICE9PSBjKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBlYWNoX2xpbmVfbWF0Y2hlc19pbmRlbnQobGluZXMsIGluZGVudCkge1xuICB2YXIgaSA9IDAsXG4gICAgbGVuID0gbGluZXMubGVuZ3RoLFxuICAgIGxpbmU7XG4gIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBsaW5lID0gbGluZXNbaV07XG4gICAgLy8gYWxsb3cgZW1wdHkgbGluZXMgdG8gcGFzcyB0aHJvdWdoXG4gICAgaWYgKGxpbmUgJiYgbGluZS5pbmRleE9mKGluZGVudCkgIT09IDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cblxuZnVuY3Rpb24gQmVhdXRpZmllcihzb3VyY2VfdGV4dCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdGhpcy5fc291cmNlX3RleHQgPSBzb3VyY2VfdGV4dCB8fCAnJztcblxuICB0aGlzLl9vdXRwdXQgPSBudWxsO1xuICB0aGlzLl90b2tlbnMgPSBudWxsO1xuICB0aGlzLl9sYXN0X2xhc3RfdGV4dCA9IG51bGw7XG4gIHRoaXMuX2ZsYWdzID0gbnVsbDtcbiAgdGhpcy5fcHJldmlvdXNfZmxhZ3MgPSBudWxsO1xuXG4gIHRoaXMuX2ZsYWdfc3RvcmUgPSBudWxsO1xuICB0aGlzLl9vcHRpb25zID0gbmV3IE9wdGlvbnMob3B0aW9ucyk7XG59XG5cbkJlYXV0aWZpZXIucHJvdG90eXBlLmNyZWF0ZV9mbGFncyA9IGZ1bmN0aW9uKGZsYWdzX2Jhc2UsIG1vZGUpIHtcbiAgdmFyIG5leHRfaW5kZW50X2xldmVsID0gMDtcbiAgaWYgKGZsYWdzX2Jhc2UpIHtcbiAgICBuZXh0X2luZGVudF9sZXZlbCA9IGZsYWdzX2Jhc2UuaW5kZW50YXRpb25fbGV2ZWw7XG4gICAgaWYgKCF0aGlzLl9vdXRwdXQuanVzdF9hZGRlZF9uZXdsaW5lKCkgJiZcbiAgICAgIGZsYWdzX2Jhc2UubGluZV9pbmRlbnRfbGV2ZWwgPiBuZXh0X2luZGVudF9sZXZlbCkge1xuICAgICAgbmV4dF9pbmRlbnRfbGV2ZWwgPSBmbGFnc19iYXNlLmxpbmVfaW5kZW50X2xldmVsO1xuICAgIH1cbiAgfVxuXG4gIHZhciBuZXh0X2ZsYWdzID0ge1xuICAgIG1vZGU6IG1vZGUsXG4gICAgcGFyZW50OiBmbGFnc19iYXNlLFxuICAgIGxhc3RfdG9rZW46IGZsYWdzX2Jhc2UgPyBmbGFnc19iYXNlLmxhc3RfdG9rZW4gOiBuZXcgVG9rZW4oVE9LRU4uU1RBUlRfQkxPQ0ssICcnKSwgLy8gbGFzdCB0b2tlbiB0ZXh0XG4gICAgbGFzdF93b3JkOiBmbGFnc19iYXNlID8gZmxhZ3NfYmFzZS5sYXN0X3dvcmQgOiAnJywgLy8gbGFzdCBUT0tFTi5XT1JEIHBhc3NlZFxuICAgIGRlY2xhcmF0aW9uX3N0YXRlbWVudDogZmFsc2UsXG4gICAgZGVjbGFyYXRpb25fYXNzaWdubWVudDogZmFsc2UsXG4gICAgbXVsdGlsaW5lX2ZyYW1lOiBmYWxzZSxcbiAgICBpbmxpbmVfZnJhbWU6IGZhbHNlLFxuICAgIGlmX2Jsb2NrOiBmYWxzZSxcbiAgICBlbHNlX2Jsb2NrOiBmYWxzZSxcbiAgICBkb19ibG9jazogZmFsc2UsXG4gICAgZG9fd2hpbGU6IGZhbHNlLFxuICAgIGltcG9ydF9ibG9jazogZmFsc2UsXG4gICAgaW5fY2FzZV9zdGF0ZW1lbnQ6IGZhbHNlLCAvLyBzd2l0Y2goLi4peyBJTlNJREUgSEVSRSB9XG4gICAgaW5fY2FzZTogZmFsc2UsIC8vIHdlJ3JlIG9uIHRoZSBleGFjdCBsaW5lIHdpdGggXCJjYXNlIDA6XCJcbiAgICBjYXNlX2JvZHk6IGZhbHNlLCAvLyB0aGUgaW5kZW50ZWQgY2FzZS1hY3Rpb24gYmxvY2tcbiAgICBpbmRlbnRhdGlvbl9sZXZlbDogbmV4dF9pbmRlbnRfbGV2ZWwsXG4gICAgYWxpZ25tZW50OiAwLFxuICAgIGxpbmVfaW5kZW50X2xldmVsOiBmbGFnc19iYXNlID8gZmxhZ3NfYmFzZS5saW5lX2luZGVudF9sZXZlbCA6IG5leHRfaW5kZW50X2xldmVsLFxuICAgIHN0YXJ0X2xpbmVfaW5kZXg6IHRoaXMuX291dHB1dC5nZXRfbGluZV9udW1iZXIoKSxcbiAgICB0ZXJuYXJ5X2RlcHRoOiAwXG4gIH07XG4gIHJldHVybiBuZXh0X2ZsYWdzO1xufTtcblxuQmVhdXRpZmllci5wcm90b3R5cGUuX3Jlc2V0ID0gZnVuY3Rpb24oc291cmNlX3RleHQpIHtcbiAgdmFyIGJhc2VJbmRlbnRTdHJpbmcgPSBzb3VyY2VfdGV4dC5tYXRjaCgvXltcXHQgXSovKVswXTtcblxuICB0aGlzLl9sYXN0X2xhc3RfdGV4dCA9ICcnOyAvLyBwcmUtbGFzdCB0b2tlbiB0ZXh0XG4gIHRoaXMuX291dHB1dCA9IG5ldyBPdXRwdXQodGhpcy5fb3B0aW9ucywgYmFzZUluZGVudFN0cmluZyk7XG5cbiAgLy8gSWYgdGVzdGluZyB0aGUgaWdub3JlIGRpcmVjdGl2ZSwgc3RhcnQgd2l0aCBvdXRwdXQgZGlzYWJsZSBzZXQgdG8gdHJ1ZVxuICB0aGlzLl9vdXRwdXQucmF3ID0gdGhpcy5fb3B0aW9ucy50ZXN0X291dHB1dF9yYXc7XG5cblxuICAvLyBTdGFjayBvZiBwYXJzaW5nL2Zvcm1hdHRpbmcgc3RhdGVzLCBpbmNsdWRpbmcgTU9ERS5cbiAgLy8gV2UgdG9rZW5pemUsIHBhcnNlLCBhbmQgb3V0cHV0IGluIGFuIGFsbW9zdCBwdXJlbHkgYSBmb3J3YXJkLW9ubHkgc3RyZWFtIG9mIHRva2VuIGlucHV0XG4gIC8vIGFuZCBmb3JtYXR0ZWQgb3V0cHV0LiAgVGhpcyBtYWtlcyB0aGUgYmVhdXRpZmllciBsZXNzIGFjY3VyYXRlIHRoYW4gZnVsbCBwYXJzZXJzXG4gIC8vIGJ1dCBhbHNvIGZhciBtb3JlIHRvbGVyYW50IG9mIHN5bnRheCBlcnJvcnMuXG4gIC8vXG4gIC8vIEZvciBleGFtcGxlLCB0aGUgZGVmYXVsdCBtb2RlIGlzIE1PREUuQmxvY2tTdGF0ZW1lbnQuIElmIHdlIHNlZSBhICd7JyB3ZSBwdXNoIGEgbmV3IGZyYW1lIG9mIHR5cGVcbiAgLy8gTU9ERS5CbG9ja1N0YXRlbWVudCBvbiB0aGUgdGhlIHN0YWNrLCBldmVuIHRob3VnaCBpdCBjb3VsZCBiZSBvYmplY3QgbGl0ZXJhbC4gIElmIHdlIGxhdGVyXG4gIC8vIGVuY291bnRlciBhIFwiOlwiLCB3ZSdsbCBzd2l0Y2ggdG8gdG8gTU9ERS5PYmplY3RMaXRlcmFsLiAgSWYgd2UgdGhlbiBzZWUgYSBcIjtcIixcbiAgLy8gbW9zdCBmdWxsIHBhcnNlcnMgd291bGQgZGllLCBidXQgdGhlIGJlYXV0aWZpZXIgZ3JhY2VmdWxseSBmYWxscyBiYWNrIHRvXG4gIC8vIE1PREUuQmxvY2tTdGF0ZW1lbnQgYW5kIGNvbnRpbnVlcyBvbi5cbiAgdGhpcy5fZmxhZ19zdG9yZSA9IFtdO1xuICB0aGlzLnNldF9tb2RlKE1PREUuQmxvY2tTdGF0ZW1lbnQpO1xuICB2YXIgdG9rZW5pemVyID0gbmV3IFRva2VuaXplcihzb3VyY2VfdGV4dCwgdGhpcy5fb3B0aW9ucyk7XG4gIHRoaXMuX3Rva2VucyA9IHRva2VuaXplci50b2tlbml6ZSgpO1xuICByZXR1cm4gc291cmNlX3RleHQ7XG59O1xuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5iZWF1dGlmeSA9IGZ1bmN0aW9uKCkge1xuICAvLyBpZiBkaXNhYmxlZCwgcmV0dXJuIHRoZSBpbnB1dCB1bmNoYW5nZWQuXG4gIGlmICh0aGlzLl9vcHRpb25zLmRpc2FibGVkKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NvdXJjZV90ZXh0O1xuICB9XG5cbiAgdmFyIHN3ZWV0X2NvZGU7XG4gIHZhciBzb3VyY2VfdGV4dCA9IHRoaXMuX3Jlc2V0KHRoaXMuX3NvdXJjZV90ZXh0KTtcblxuICB2YXIgZW9sID0gdGhpcy5fb3B0aW9ucy5lb2w7XG4gIGlmICh0aGlzLl9vcHRpb25zLmVvbCA9PT0gJ2F1dG8nKSB7XG4gICAgZW9sID0gJ1xcbic7XG4gICAgaWYgKHNvdXJjZV90ZXh0ICYmIGFjb3JuLmxpbmVCcmVhay50ZXN0KHNvdXJjZV90ZXh0IHx8ICcnKSkge1xuICAgICAgZW9sID0gc291cmNlX3RleHQubWF0Y2goYWNvcm4ubGluZUJyZWFrKVswXTtcbiAgICB9XG4gIH1cblxuICB2YXIgY3VycmVudF90b2tlbiA9IHRoaXMuX3Rva2Vucy5uZXh0KCk7XG4gIHdoaWxlIChjdXJyZW50X3Rva2VuKSB7XG4gICAgdGhpcy5oYW5kbGVfdG9rZW4oY3VycmVudF90b2tlbik7XG5cbiAgICB0aGlzLl9sYXN0X2xhc3RfdGV4dCA9IHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udGV4dDtcbiAgICB0aGlzLl9mbGFncy5sYXN0X3Rva2VuID0gY3VycmVudF90b2tlbjtcblxuICAgIGN1cnJlbnRfdG9rZW4gPSB0aGlzLl90b2tlbnMubmV4dCgpO1xuICB9XG5cbiAgc3dlZXRfY29kZSA9IHRoaXMuX291dHB1dC5nZXRfY29kZShlb2wpO1xuXG4gIHJldHVybiBzd2VldF9jb2RlO1xufTtcblxuQmVhdXRpZmllci5wcm90b3R5cGUuaGFuZGxlX3Rva2VuID0gZnVuY3Rpb24oY3VycmVudF90b2tlbiwgcHJlc2VydmVfc3RhdGVtZW50X2ZsYWdzKSB7XG4gIGlmIChjdXJyZW50X3Rva2VuLnR5cGUgPT09IFRPS0VOLlNUQVJUX0VYUFIpIHtcbiAgICB0aGlzLmhhbmRsZV9zdGFydF9leHByKGN1cnJlbnRfdG9rZW4pO1xuICB9IGVsc2UgaWYgKGN1cnJlbnRfdG9rZW4udHlwZSA9PT0gVE9LRU4uRU5EX0VYUFIpIHtcbiAgICB0aGlzLmhhbmRsZV9lbmRfZXhwcihjdXJyZW50X3Rva2VuKTtcbiAgfSBlbHNlIGlmIChjdXJyZW50X3Rva2VuLnR5cGUgPT09IFRPS0VOLlNUQVJUX0JMT0NLKSB7XG4gICAgdGhpcy5oYW5kbGVfc3RhcnRfYmxvY2soY3VycmVudF90b2tlbik7XG4gIH0gZWxzZSBpZiAoY3VycmVudF90b2tlbi50eXBlID09PSBUT0tFTi5FTkRfQkxPQ0spIHtcbiAgICB0aGlzLmhhbmRsZV9lbmRfYmxvY2soY3VycmVudF90b2tlbik7XG4gIH0gZWxzZSBpZiAoY3VycmVudF90b2tlbi50eXBlID09PSBUT0tFTi5XT1JEKSB7XG4gICAgdGhpcy5oYW5kbGVfd29yZChjdXJyZW50X3Rva2VuKTtcbiAgfSBlbHNlIGlmIChjdXJyZW50X3Rva2VuLnR5cGUgPT09IFRPS0VOLlJFU0VSVkVEKSB7XG4gICAgdGhpcy5oYW5kbGVfd29yZChjdXJyZW50X3Rva2VuKTtcbiAgfSBlbHNlIGlmIChjdXJyZW50X3Rva2VuLnR5cGUgPT09IFRPS0VOLlNFTUlDT0xPTikge1xuICAgIHRoaXMuaGFuZGxlX3NlbWljb2xvbihjdXJyZW50X3Rva2VuKTtcbiAgfSBlbHNlIGlmIChjdXJyZW50X3Rva2VuLnR5cGUgPT09IFRPS0VOLlNUUklORykge1xuICAgIHRoaXMuaGFuZGxlX3N0cmluZyhjdXJyZW50X3Rva2VuKTtcbiAgfSBlbHNlIGlmIChjdXJyZW50X3Rva2VuLnR5cGUgPT09IFRPS0VOLkVRVUFMUykge1xuICAgIHRoaXMuaGFuZGxlX2VxdWFscyhjdXJyZW50X3Rva2VuKTtcbiAgfSBlbHNlIGlmIChjdXJyZW50X3Rva2VuLnR5cGUgPT09IFRPS0VOLk9QRVJBVE9SKSB7XG4gICAgdGhpcy5oYW5kbGVfb3BlcmF0b3IoY3VycmVudF90b2tlbik7XG4gIH0gZWxzZSBpZiAoY3VycmVudF90b2tlbi50eXBlID09PSBUT0tFTi5DT01NQSkge1xuICAgIHRoaXMuaGFuZGxlX2NvbW1hKGN1cnJlbnRfdG9rZW4pO1xuICB9IGVsc2UgaWYgKGN1cnJlbnRfdG9rZW4udHlwZSA9PT0gVE9LRU4uQkxPQ0tfQ09NTUVOVCkge1xuICAgIHRoaXMuaGFuZGxlX2Jsb2NrX2NvbW1lbnQoY3VycmVudF90b2tlbiwgcHJlc2VydmVfc3RhdGVtZW50X2ZsYWdzKTtcbiAgfSBlbHNlIGlmIChjdXJyZW50X3Rva2VuLnR5cGUgPT09IFRPS0VOLkNPTU1FTlQpIHtcbiAgICB0aGlzLmhhbmRsZV9jb21tZW50KGN1cnJlbnRfdG9rZW4sIHByZXNlcnZlX3N0YXRlbWVudF9mbGFncyk7XG4gIH0gZWxzZSBpZiAoY3VycmVudF90b2tlbi50eXBlID09PSBUT0tFTi5ET1QpIHtcbiAgICB0aGlzLmhhbmRsZV9kb3QoY3VycmVudF90b2tlbik7XG4gIH0gZWxzZSBpZiAoY3VycmVudF90b2tlbi50eXBlID09PSBUT0tFTi5FT0YpIHtcbiAgICB0aGlzLmhhbmRsZV9lb2YoY3VycmVudF90b2tlbik7XG4gIH0gZWxzZSBpZiAoY3VycmVudF90b2tlbi50eXBlID09PSBUT0tFTi5VTktOT1dOKSB7XG4gICAgdGhpcy5oYW5kbGVfdW5rbm93bihjdXJyZW50X3Rva2VuLCBwcmVzZXJ2ZV9zdGF0ZW1lbnRfZmxhZ3MpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuaGFuZGxlX3Vua25vd24oY3VycmVudF90b2tlbiwgcHJlc2VydmVfc3RhdGVtZW50X2ZsYWdzKTtcbiAgfVxufTtcblxuQmVhdXRpZmllci5wcm90b3R5cGUuaGFuZGxlX3doaXRlc3BhY2VfYW5kX2NvbW1lbnRzID0gZnVuY3Rpb24oY3VycmVudF90b2tlbiwgcHJlc2VydmVfc3RhdGVtZW50X2ZsYWdzKSB7XG4gIHZhciBuZXdsaW5lcyA9IGN1cnJlbnRfdG9rZW4ubmV3bGluZXM7XG4gIHZhciBrZWVwX3doaXRlc3BhY2UgPSB0aGlzLl9vcHRpb25zLmtlZXBfYXJyYXlfaW5kZW50YXRpb24gJiYgaXNfYXJyYXkodGhpcy5fZmxhZ3MubW9kZSk7XG5cbiAgaWYgKGN1cnJlbnRfdG9rZW4uY29tbWVudHNfYmVmb3JlKSB7XG4gICAgdmFyIGNvbW1lbnRfdG9rZW4gPSBjdXJyZW50X3Rva2VuLmNvbW1lbnRzX2JlZm9yZS5uZXh0KCk7XG4gICAgd2hpbGUgKGNvbW1lbnRfdG9rZW4pIHtcbiAgICAgIC8vIFRoZSBjbGVhbmVzdCBoYW5kbGluZyBvZiBpbmxpbmUgY29tbWVudHMgaXMgdG8gdHJlYXQgdGhlbSBhcyB0aG91Z2ggdGhleSBhcmVuJ3QgdGhlcmUuXG4gICAgICAvLyBKdXN0IGNvbnRpbnVlIGZvcm1hdHRpbmcgYW5kIHRoZSBiZWhhdmlvciBzaG91bGQgYmUgbG9naWNhbC5cbiAgICAgIC8vIEFsc28gaWdub3JlIHVua25vd24gdG9rZW5zLiAgQWdhaW4sIHRoaXMgc2hvdWxkIHJlc3VsdCBpbiBiZXR0ZXIgYmVoYXZpb3IuXG4gICAgICB0aGlzLmhhbmRsZV93aGl0ZXNwYWNlX2FuZF9jb21tZW50cyhjb21tZW50X3Rva2VuLCBwcmVzZXJ2ZV9zdGF0ZW1lbnRfZmxhZ3MpO1xuICAgICAgdGhpcy5oYW5kbGVfdG9rZW4oY29tbWVudF90b2tlbiwgcHJlc2VydmVfc3RhdGVtZW50X2ZsYWdzKTtcbiAgICAgIGNvbW1lbnRfdG9rZW4gPSBjdXJyZW50X3Rva2VuLmNvbW1lbnRzX2JlZm9yZS5uZXh0KCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGtlZXBfd2hpdGVzcGFjZSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3bGluZXM7IGkgKz0gMSkge1xuICAgICAgdGhpcy5wcmludF9uZXdsaW5lKGkgPiAwLCBwcmVzZXJ2ZV9zdGF0ZW1lbnRfZmxhZ3MpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAodGhpcy5fb3B0aW9ucy5tYXhfcHJlc2VydmVfbmV3bGluZXMgJiYgbmV3bGluZXMgPiB0aGlzLl9vcHRpb25zLm1heF9wcmVzZXJ2ZV9uZXdsaW5lcykge1xuICAgICAgbmV3bGluZXMgPSB0aGlzLl9vcHRpb25zLm1heF9wcmVzZXJ2ZV9uZXdsaW5lcztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fb3B0aW9ucy5wcmVzZXJ2ZV9uZXdsaW5lcykge1xuICAgICAgaWYgKG5ld2xpbmVzID4gMSkge1xuICAgICAgICB0aGlzLnByaW50X25ld2xpbmUoZmFsc2UsIHByZXNlcnZlX3N0YXRlbWVudF9mbGFncyk7XG4gICAgICAgIGZvciAodmFyIGogPSAxOyBqIDwgbmV3bGluZXM7IGogKz0gMSkge1xuICAgICAgICAgIHRoaXMucHJpbnRfbmV3bGluZSh0cnVlLCBwcmVzZXJ2ZV9zdGF0ZW1lbnRfZmxhZ3MpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbn07XG5cbnZhciBuZXdsaW5lX3Jlc3RyaWN0ZWRfdG9rZW5zID0gWydhc3luYycsICdicmVhaycsICdjb250aW51ZScsICdyZXR1cm4nLCAndGhyb3cnLCAneWllbGQnXTtcblxuQmVhdXRpZmllci5wcm90b3R5cGUuYWxsb3dfd3JhcF9vcl9wcmVzZXJ2ZWRfbmV3bGluZSA9IGZ1bmN0aW9uKGN1cnJlbnRfdG9rZW4sIGZvcmNlX2xpbmV3cmFwKSB7XG4gIGZvcmNlX2xpbmV3cmFwID0gKGZvcmNlX2xpbmV3cmFwID09PSB1bmRlZmluZWQpID8gZmFsc2UgOiBmb3JjZV9saW5ld3JhcDtcblxuICAvLyBOZXZlciB3cmFwIHRoZSBmaXJzdCB0b2tlbiBvbiBhIGxpbmVcbiAgaWYgKHRoaXMuX291dHB1dC5qdXN0X2FkZGVkX25ld2xpbmUoKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBzaG91bGRQcmVzZXJ2ZU9yRm9yY2UgPSAodGhpcy5fb3B0aW9ucy5wcmVzZXJ2ZV9uZXdsaW5lcyAmJiBjdXJyZW50X3Rva2VuLm5ld2xpbmVzKSB8fCBmb3JjZV9saW5ld3JhcDtcbiAgdmFyIG9wZXJhdG9yTG9naWNBcHBsaWVzID0gaW5fYXJyYXkodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0LCBwb3NpdGlvbmFibGVfb3BlcmF0b3JzKSB8fFxuICAgIGluX2FycmF5KGN1cnJlbnRfdG9rZW4udGV4dCwgcG9zaXRpb25hYmxlX29wZXJhdG9ycyk7XG5cbiAgaWYgKG9wZXJhdG9yTG9naWNBcHBsaWVzKSB7XG4gICAgdmFyIHNob3VsZFByaW50T3BlcmF0b3JOZXdsaW5lID0gKFxuICAgICAgICBpbl9hcnJheSh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQsIHBvc2l0aW9uYWJsZV9vcGVyYXRvcnMpICYmXG4gICAgICAgIGluX2FycmF5KHRoaXMuX29wdGlvbnMub3BlcmF0b3JfcG9zaXRpb24sIE9QRVJBVE9SX1BPU0lUSU9OX0JFRk9SRV9PUl9QUkVTRVJWRSlcbiAgICAgICkgfHxcbiAgICAgIGluX2FycmF5KGN1cnJlbnRfdG9rZW4udGV4dCwgcG9zaXRpb25hYmxlX29wZXJhdG9ycyk7XG4gICAgc2hvdWxkUHJlc2VydmVPckZvcmNlID0gc2hvdWxkUHJlc2VydmVPckZvcmNlICYmIHNob3VsZFByaW50T3BlcmF0b3JOZXdsaW5lO1xuICB9XG5cbiAgaWYgKHNob3VsZFByZXNlcnZlT3JGb3JjZSkge1xuICAgIHRoaXMucHJpbnRfbmV3bGluZShmYWxzZSwgdHJ1ZSk7XG4gIH0gZWxzZSBpZiAodGhpcy5fb3B0aW9ucy53cmFwX2xpbmVfbGVuZ3RoKSB7XG4gICAgaWYgKHJlc2VydmVkX2FycmF5KHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4sIG5ld2xpbmVfcmVzdHJpY3RlZF90b2tlbnMpKSB7XG4gICAgICAvLyBUaGVzZSB0b2tlbnMgc2hvdWxkIG5ldmVyIGhhdmUgYSBuZXdsaW5lIGluc2VydGVkXG4gICAgICAvLyBiZXR3ZWVuIHRoZW0gYW5kIHRoZSBmb2xsb3dpbmcgZXhwcmVzc2lvbi5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fb3V0cHV0LnNldF93cmFwX3BvaW50KCk7XG4gIH1cbn07XG5cbkJlYXV0aWZpZXIucHJvdG90eXBlLnByaW50X25ld2xpbmUgPSBmdW5jdGlvbihmb3JjZV9uZXdsaW5lLCBwcmVzZXJ2ZV9zdGF0ZW1lbnRfZmxhZ3MpIHtcbiAgaWYgKCFwcmVzZXJ2ZV9zdGF0ZW1lbnRfZmxhZ3MpIHtcbiAgICBpZiAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0ICE9PSAnOycgJiYgdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0ICE9PSAnLCcgJiYgdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0ICE9PSAnPScgJiYgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSAhPT0gVE9LRU4uT1BFUkFUT1IgfHwgdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0ID09PSAnLS0nIHx8IHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udGV4dCA9PT0gJysrJykpIHtcbiAgICAgIHZhciBuZXh0X3Rva2VuID0gdGhpcy5fdG9rZW5zLnBlZWsoKTtcbiAgICAgIHdoaWxlICh0aGlzLl9mbGFncy5tb2RlID09PSBNT0RFLlN0YXRlbWVudCAmJlxuICAgICAgICAhKHRoaXMuX2ZsYWdzLmlmX2Jsb2NrICYmIHJlc2VydmVkX3dvcmQobmV4dF90b2tlbiwgJ2Vsc2UnKSkgJiZcbiAgICAgICAgIXRoaXMuX2ZsYWdzLmRvX2Jsb2NrKSB7XG4gICAgICAgIHRoaXMucmVzdG9yZV9tb2RlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMuX291dHB1dC5hZGRfbmV3X2xpbmUoZm9yY2VfbmV3bGluZSkpIHtcbiAgICB0aGlzLl9mbGFncy5tdWx0aWxpbmVfZnJhbWUgPSB0cnVlO1xuICB9XG59O1xuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5wcmludF90b2tlbl9saW5lX2luZGVudGF0aW9uID0gZnVuY3Rpb24oY3VycmVudF90b2tlbikge1xuICBpZiAodGhpcy5fb3V0cHV0Lmp1c3RfYWRkZWRfbmV3bGluZSgpKSB7XG4gICAgaWYgKHRoaXMuX29wdGlvbnMua2VlcF9hcnJheV9pbmRlbnRhdGlvbiAmJlxuICAgICAgY3VycmVudF90b2tlbi5uZXdsaW5lcyAmJlxuICAgICAgKGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJ1snIHx8IGlzX2FycmF5KHRoaXMuX2ZsYWdzLm1vZGUpKSkge1xuICAgICAgdGhpcy5fb3V0cHV0LmN1cnJlbnRfbGluZS5zZXRfaW5kZW50KC0xKTtcbiAgICAgIHRoaXMuX291dHB1dC5jdXJyZW50X2xpbmUucHVzaChjdXJyZW50X3Rva2VuLndoaXRlc3BhY2VfYmVmb3JlKTtcbiAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX291dHB1dC5zZXRfaW5kZW50KHRoaXMuX2ZsYWdzLmluZGVudGF0aW9uX2xldmVsLCB0aGlzLl9mbGFncy5hbGlnbm1lbnQpKSB7XG4gICAgICB0aGlzLl9mbGFncy5saW5lX2luZGVudF9sZXZlbCA9IHRoaXMuX2ZsYWdzLmluZGVudGF0aW9uX2xldmVsO1xuICAgIH1cbiAgfVxufTtcblxuQmVhdXRpZmllci5wcm90b3R5cGUucHJpbnRfdG9rZW4gPSBmdW5jdGlvbihjdXJyZW50X3Rva2VuKSB7XG4gIGlmICh0aGlzLl9vdXRwdXQucmF3KSB7XG4gICAgdGhpcy5fb3V0cHV0LmFkZF9yYXdfdG9rZW4oY3VycmVudF90b2tlbik7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHRoaXMuX29wdGlvbnMuY29tbWFfZmlyc3QgJiYgY3VycmVudF90b2tlbi5wcmV2aW91cyAmJiBjdXJyZW50X3Rva2VuLnByZXZpb3VzLnR5cGUgPT09IFRPS0VOLkNPTU1BICYmXG4gICAgdGhpcy5fb3V0cHV0Lmp1c3RfYWRkZWRfbmV3bGluZSgpKSB7XG4gICAgaWYgKHRoaXMuX291dHB1dC5wcmV2aW91c19saW5lLmxhc3QoKSA9PT0gJywnKSB7XG4gICAgICB2YXIgcG9wcGVkID0gdGhpcy5fb3V0cHV0LnByZXZpb3VzX2xpbmUucG9wKCk7XG4gICAgICAvLyBpZiB0aGUgY29tbWEgd2FzIGFscmVhZHkgYXQgdGhlIHN0YXJ0IG9mIHRoZSBsaW5lLFxuICAgICAgLy8gcHVsbCBiYWNrIG9udG8gdGhhdCBsaW5lIGFuZCByZXByaW50IHRoZSBpbmRlbnRhdGlvblxuICAgICAgaWYgKHRoaXMuX291dHB1dC5wcmV2aW91c19saW5lLmlzX2VtcHR5KCkpIHtcbiAgICAgICAgdGhpcy5fb3V0cHV0LnByZXZpb3VzX2xpbmUucHVzaChwb3BwZWQpO1xuICAgICAgICB0aGlzLl9vdXRwdXQudHJpbSh0cnVlKTtcbiAgICAgICAgdGhpcy5fb3V0cHV0LmN1cnJlbnRfbGluZS5wb3AoKTtcbiAgICAgICAgdGhpcy5fb3V0cHV0LnRyaW0oKTtcbiAgICAgIH1cblxuICAgICAgLy8gYWRkIHRoZSBjb21tYSBpbiBmcm9udCBvZiB0aGUgbmV4dCB0b2tlblxuICAgICAgdGhpcy5wcmludF90b2tlbl9saW5lX2luZGVudGF0aW9uKGN1cnJlbnRfdG9rZW4pO1xuICAgICAgdGhpcy5fb3V0cHV0LmFkZF90b2tlbignLCcpO1xuICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5wcmludF90b2tlbl9saW5lX2luZGVudGF0aW9uKGN1cnJlbnRfdG9rZW4pO1xuICB0aGlzLl9vdXRwdXQubm9uX2JyZWFraW5nX3NwYWNlID0gdHJ1ZTtcbiAgdGhpcy5fb3V0cHV0LmFkZF90b2tlbihjdXJyZW50X3Rva2VuLnRleHQpO1xuICBpZiAodGhpcy5fb3V0cHV0LnByZXZpb3VzX3Rva2VuX3dyYXBwZWQpIHtcbiAgICB0aGlzLl9mbGFncy5tdWx0aWxpbmVfZnJhbWUgPSB0cnVlO1xuICB9XG59O1xuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5pbmRlbnQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fZmxhZ3MuaW5kZW50YXRpb25fbGV2ZWwgKz0gMTtcbiAgdGhpcy5fb3V0cHV0LnNldF9pbmRlbnQodGhpcy5fZmxhZ3MuaW5kZW50YXRpb25fbGV2ZWwsIHRoaXMuX2ZsYWdzLmFsaWdubWVudCk7XG59O1xuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5kZWluZGVudCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5fZmxhZ3MuaW5kZW50YXRpb25fbGV2ZWwgPiAwICYmXG4gICAgKCghdGhpcy5fZmxhZ3MucGFyZW50KSB8fCB0aGlzLl9mbGFncy5pbmRlbnRhdGlvbl9sZXZlbCA+IHRoaXMuX2ZsYWdzLnBhcmVudC5pbmRlbnRhdGlvbl9sZXZlbCkpIHtcbiAgICB0aGlzLl9mbGFncy5pbmRlbnRhdGlvbl9sZXZlbCAtPSAxO1xuICAgIHRoaXMuX291dHB1dC5zZXRfaW5kZW50KHRoaXMuX2ZsYWdzLmluZGVudGF0aW9uX2xldmVsLCB0aGlzLl9mbGFncy5hbGlnbm1lbnQpO1xuICB9XG59O1xuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5zZXRfbW9kZSA9IGZ1bmN0aW9uKG1vZGUpIHtcbiAgaWYgKHRoaXMuX2ZsYWdzKSB7XG4gICAgdGhpcy5fZmxhZ19zdG9yZS5wdXNoKHRoaXMuX2ZsYWdzKTtcbiAgICB0aGlzLl9wcmV2aW91c19mbGFncyA9IHRoaXMuX2ZsYWdzO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX3ByZXZpb3VzX2ZsYWdzID0gdGhpcy5jcmVhdGVfZmxhZ3MobnVsbCwgbW9kZSk7XG4gIH1cblxuICB0aGlzLl9mbGFncyA9IHRoaXMuY3JlYXRlX2ZsYWdzKHRoaXMuX3ByZXZpb3VzX2ZsYWdzLCBtb2RlKTtcbiAgdGhpcy5fb3V0cHV0LnNldF9pbmRlbnQodGhpcy5fZmxhZ3MuaW5kZW50YXRpb25fbGV2ZWwsIHRoaXMuX2ZsYWdzLmFsaWdubWVudCk7XG59O1xuXG5cbkJlYXV0aWZpZXIucHJvdG90eXBlLnJlc3RvcmVfbW9kZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5fZmxhZ19zdG9yZS5sZW5ndGggPiAwKSB7XG4gICAgdGhpcy5fcHJldmlvdXNfZmxhZ3MgPSB0aGlzLl9mbGFncztcbiAgICB0aGlzLl9mbGFncyA9IHRoaXMuX2ZsYWdfc3RvcmUucG9wKCk7XG4gICAgaWYgKHRoaXMuX3ByZXZpb3VzX2ZsYWdzLm1vZGUgPT09IE1PREUuU3RhdGVtZW50KSB7XG4gICAgICByZW1vdmVfcmVkdW5kYW50X2luZGVudGF0aW9uKHRoaXMuX291dHB1dCwgdGhpcy5fcHJldmlvdXNfZmxhZ3MpO1xuICAgIH1cbiAgICB0aGlzLl9vdXRwdXQuc2V0X2luZGVudCh0aGlzLl9mbGFncy5pbmRlbnRhdGlvbl9sZXZlbCwgdGhpcy5fZmxhZ3MuYWxpZ25tZW50KTtcbiAgfVxufTtcblxuQmVhdXRpZmllci5wcm90b3R5cGUuc3RhcnRfb2Zfb2JqZWN0X3Byb3BlcnR5ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9mbGFncy5wYXJlbnQubW9kZSA9PT0gTU9ERS5PYmplY3RMaXRlcmFsICYmIHRoaXMuX2ZsYWdzLm1vZGUgPT09IE1PREUuU3RhdGVtZW50ICYmIChcbiAgICAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0ID09PSAnOicgJiYgdGhpcy5fZmxhZ3MudGVybmFyeV9kZXB0aCA9PT0gMCkgfHwgKHJlc2VydmVkX2FycmF5KHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4sIFsnZ2V0JywgJ3NldCddKSkpO1xufTtcblxuQmVhdXRpZmllci5wcm90b3R5cGUuc3RhcnRfb2Zfc3RhdGVtZW50ID0gZnVuY3Rpb24oY3VycmVudF90b2tlbikge1xuICB2YXIgc3RhcnQgPSBmYWxzZTtcbiAgc3RhcnQgPSBzdGFydCB8fCByZXNlcnZlZF9hcnJheSh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLCBbJ3ZhcicsICdsZXQnLCAnY29uc3QnXSkgJiYgY3VycmVudF90b2tlbi50eXBlID09PSBUT0tFTi5XT1JEO1xuICBzdGFydCA9IHN0YXJ0IHx8IHJlc2VydmVkX3dvcmQodGhpcy5fZmxhZ3MubGFzdF90b2tlbiwgJ2RvJyk7XG4gIHN0YXJ0ID0gc3RhcnQgfHwgKCEodGhpcy5fZmxhZ3MucGFyZW50Lm1vZGUgPT09IE1PREUuT2JqZWN0TGl0ZXJhbCAmJiB0aGlzLl9mbGFncy5tb2RlID09PSBNT0RFLlN0YXRlbWVudCkpICYmIHJlc2VydmVkX2FycmF5KHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4sIG5ld2xpbmVfcmVzdHJpY3RlZF90b2tlbnMpICYmICFjdXJyZW50X3Rva2VuLm5ld2xpbmVzO1xuICBzdGFydCA9IHN0YXJ0IHx8IHJlc2VydmVkX3dvcmQodGhpcy5fZmxhZ3MubGFzdF90b2tlbiwgJ2Vsc2UnKSAmJlxuICAgICEocmVzZXJ2ZWRfd29yZChjdXJyZW50X3Rva2VuLCAnaWYnKSAmJiAhY3VycmVudF90b2tlbi5jb21tZW50c19iZWZvcmUpO1xuICBzdGFydCA9IHN0YXJ0IHx8ICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLkVORF9FWFBSICYmICh0aGlzLl9wcmV2aW91c19mbGFncy5tb2RlID09PSBNT0RFLkZvckluaXRpYWxpemVyIHx8IHRoaXMuX3ByZXZpb3VzX2ZsYWdzLm1vZGUgPT09IE1PREUuQ29uZGl0aW9uYWwpKTtcbiAgc3RhcnQgPSBzdGFydCB8fCAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5XT1JEICYmIHRoaXMuX2ZsYWdzLm1vZGUgPT09IE1PREUuQmxvY2tTdGF0ZW1lbnQgJiZcbiAgICAhdGhpcy5fZmxhZ3MuaW5fY2FzZSAmJlxuICAgICEoY3VycmVudF90b2tlbi50ZXh0ID09PSAnLS0nIHx8IGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJysrJykgJiZcbiAgICB0aGlzLl9sYXN0X2xhc3RfdGV4dCAhPT0gJ2Z1bmN0aW9uJyAmJlxuICAgIGN1cnJlbnRfdG9rZW4udHlwZSAhPT0gVE9LRU4uV09SRCAmJiBjdXJyZW50X3Rva2VuLnR5cGUgIT09IFRPS0VOLlJFU0VSVkVEKTtcbiAgc3RhcnQgPSBzdGFydCB8fCAodGhpcy5fZmxhZ3MubW9kZSA9PT0gTU9ERS5PYmplY3RMaXRlcmFsICYmIChcbiAgICAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0ID09PSAnOicgJiYgdGhpcy5fZmxhZ3MudGVybmFyeV9kZXB0aCA9PT0gMCkgfHwgcmVzZXJ2ZWRfYXJyYXkodGhpcy5fZmxhZ3MubGFzdF90b2tlbiwgWydnZXQnLCAnc2V0J10pKSk7XG5cbiAgaWYgKHN0YXJ0KSB7XG4gICAgdGhpcy5zZXRfbW9kZShNT0RFLlN0YXRlbWVudCk7XG4gICAgdGhpcy5pbmRlbnQoKTtcblxuICAgIHRoaXMuaGFuZGxlX3doaXRlc3BhY2VfYW5kX2NvbW1lbnRzKGN1cnJlbnRfdG9rZW4sIHRydWUpO1xuXG4gICAgLy8gSXNzdWUgIzI3NjpcbiAgICAvLyBJZiBzdGFydGluZyBhIG5ldyBzdGF0ZW1lbnQgd2l0aCBbaWYsIGZvciwgd2hpbGUsIGRvXSwgcHVzaCB0byBhIG5ldyBsaW5lLlxuICAgIC8vIGlmIChhKSBpZiAoYikgaWYoYykgZCgpOyBlbHNlIGUoKTsgZWxzZSBmKCk7XG4gICAgaWYgKCF0aGlzLnN0YXJ0X29mX29iamVjdF9wcm9wZXJ0eSgpKSB7XG4gICAgICB0aGlzLmFsbG93X3dyYXBfb3JfcHJlc2VydmVkX25ld2xpbmUoY3VycmVudF90b2tlbixcbiAgICAgICAgcmVzZXJ2ZWRfYXJyYXkoY3VycmVudF90b2tlbiwgWydkbycsICdmb3InLCAnaWYnLCAnd2hpbGUnXSkpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5oYW5kbGVfc3RhcnRfZXhwciA9IGZ1bmN0aW9uKGN1cnJlbnRfdG9rZW4pIHtcbiAgLy8gVGhlIGNvbmRpdGlvbmFsIHN0YXJ0cyB0aGUgc3RhdGVtZW50IGlmIGFwcHJvcHJpYXRlLlxuICBpZiAoIXRoaXMuc3RhcnRfb2Zfc3RhdGVtZW50KGN1cnJlbnRfdG9rZW4pKSB7XG4gICAgdGhpcy5oYW5kbGVfd2hpdGVzcGFjZV9hbmRfY29tbWVudHMoY3VycmVudF90b2tlbik7XG4gIH1cblxuICB2YXIgbmV4dF9tb2RlID0gTU9ERS5FeHByZXNzaW9uO1xuICBpZiAoY3VycmVudF90b2tlbi50ZXh0ID09PSAnWycpIHtcblxuICAgIGlmICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLldPUkQgfHwgdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0ID09PSAnKScpIHtcbiAgICAgIC8vIHRoaXMgaXMgYXJyYXkgaW5kZXggc3BlY2lmaWVyLCBicmVhayBpbW1lZGlhdGVseVxuICAgICAgLy8gYVt4XSwgZm4oKVt4XVxuICAgICAgaWYgKHJlc2VydmVkX2FycmF5KHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4sIGxpbmVfc3RhcnRlcnMpKSB7XG4gICAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgfVxuICAgICAgdGhpcy5wcmludF90b2tlbihjdXJyZW50X3Rva2VuKTtcbiAgICAgIHRoaXMuc2V0X21vZGUobmV4dF9tb2RlKTtcbiAgICAgIHRoaXMuaW5kZW50KCk7XG4gICAgICBpZiAodGhpcy5fb3B0aW9ucy5zcGFjZV9pbl9wYXJlbikge1xuICAgICAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBuZXh0X21vZGUgPSBNT0RFLkFycmF5TGl0ZXJhbDtcbiAgICBpZiAoaXNfYXJyYXkodGhpcy5fZmxhZ3MubW9kZSkpIHtcbiAgICAgIGlmICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQgPT09ICdbJyB8fFxuICAgICAgICAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0ID09PSAnLCcgJiYgKHRoaXMuX2xhc3RfbGFzdF90ZXh0ID09PSAnXScgfHwgdGhpcy5fbGFzdF9sYXN0X3RleHQgPT09ICd9JykpKSB7XG4gICAgICAgIC8vIF0sIFsgZ29lcyB0byBuZXcgbGluZVxuICAgICAgICAvLyB9LCBbIGdvZXMgdG8gbmV3IGxpbmVcbiAgICAgICAgaWYgKCF0aGlzLl9vcHRpb25zLmtlZXBfYXJyYXlfaW5kZW50YXRpb24pIHtcbiAgICAgICAgICB0aGlzLnByaW50X25ld2xpbmUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghaW5fYXJyYXkodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlLCBbVE9LRU4uU1RBUlRfRVhQUiwgVE9LRU4uRU5EX0VYUFIsIFRPS0VOLldPUkQsIFRPS0VOLk9QRVJBVE9SXSkpIHtcbiAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5SRVNFUlZFRCkge1xuICAgICAgaWYgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udGV4dCA9PT0gJ2ZvcicpIHtcbiAgICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRoaXMuX29wdGlvbnMuc3BhY2VfYmVmb3JlX2NvbmRpdGlvbmFsO1xuICAgICAgICBuZXh0X21vZGUgPSBNT0RFLkZvckluaXRpYWxpemVyO1xuICAgICAgfSBlbHNlIGlmIChpbl9hcnJheSh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQsIFsnaWYnLCAnd2hpbGUnXSkpIHtcbiAgICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRoaXMuX29wdGlvbnMuc3BhY2VfYmVmb3JlX2NvbmRpdGlvbmFsO1xuICAgICAgICBuZXh0X21vZGUgPSBNT0RFLkNvbmRpdGlvbmFsO1xuICAgICAgfSBlbHNlIGlmIChpbl9hcnJheSh0aGlzLl9mbGFncy5sYXN0X3dvcmQsIFsnYXdhaXQnLCAnYXN5bmMnXSkpIHtcbiAgICAgICAgLy8gU2hvdWxkIGJlIGEgc3BhY2UgYmV0d2VlbiBhd2FpdCBhbmQgYW4gSUlGRSwgb3IgYXN5bmMgYW5kIGFuIGFycm93IGZ1bmN0aW9uXG4gICAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQgPT09ICdpbXBvcnQnICYmIGN1cnJlbnRfdG9rZW4ud2hpdGVzcGFjZV9iZWZvcmUgPT09ICcnKSB7XG4gICAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoaW5fYXJyYXkodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0LCBsaW5lX3N0YXJ0ZXJzKSB8fCB0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQgPT09ICdjYXRjaCcpIHtcbiAgICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLkVRVUFMUyB8fCB0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLk9QRVJBVE9SKSB7XG4gICAgICAvLyBTdXBwb3J0IG9mIHRoaXMga2luZCBvZiBuZXdsaW5lIHByZXNlcnZhdGlvbi5cbiAgICAgIC8vIGEgPSAoYiAmJlxuICAgICAgLy8gICAgIChjIHx8IGQpKTtcbiAgICAgIGlmICghdGhpcy5zdGFydF9vZl9vYmplY3RfcHJvcGVydHkoKSkge1xuICAgICAgICB0aGlzLmFsbG93X3dyYXBfb3JfcHJlc2VydmVkX25ld2xpbmUoY3VycmVudF90b2tlbik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLldPUkQpIHtcbiAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSBmYWxzZTtcblxuICAgICAgLy8gZnVuY3Rpb24gbmFtZSgpIHZzIGZ1bmN0aW9uIG5hbWUgKClcbiAgICAgIC8vIGZ1bmN0aW9uKiBuYW1lKCkgdnMgZnVuY3Rpb24qIG5hbWUgKClcbiAgICAgIC8vIGFzeW5jIG5hbWUoKSB2cyBhc3luYyBuYW1lICgpXG4gICAgICAvLyBJbiBFUzYsIHlvdSBjYW4gYWxzbyBkZWZpbmUgdGhlIG1ldGhvZCBwcm9wZXJ0aWVzIG9mIGFuIG9iamVjdFxuICAgICAgLy8gdmFyIG9iaiA9IHthOiBmdW5jdGlvbigpIHt9fVxuICAgICAgLy8gSXQgY2FuIGJlIGFiYnJldmlhdGVkXG4gICAgICAvLyB2YXIgb2JqID0ge2EoKSB7fX1cbiAgICAgIC8vIHZhciBvYmogPSB7IGEoKSB7fX0gdnMgdmFyIG9iaiA9IHsgYSAoKSB7fX1cbiAgICAgIC8vIHZhciBvYmogPSB7ICogYSgpIHt9fSB2cyB2YXIgb2JqID0geyAqIGEgKCkge319XG4gICAgICB2YXIgcGVla19iYWNrX3R3byA9IHRoaXMuX3Rva2Vucy5wZWVrKC0zKTtcbiAgICAgIGlmICh0aGlzLl9vcHRpb25zLnNwYWNlX2FmdGVyX25hbWVkX2Z1bmN0aW9uICYmIHBlZWtfYmFja190d28pIHtcbiAgICAgICAgLy8gcGVlayBzdGFydHMgYXQgbmV4dCBjaGFyYWN0ZXIgc28gLTEgaXMgY3VycmVudCB0b2tlblxuICAgICAgICB2YXIgcGVla19iYWNrX3RocmVlID0gdGhpcy5fdG9rZW5zLnBlZWsoLTQpO1xuICAgICAgICBpZiAocmVzZXJ2ZWRfYXJyYXkocGVla19iYWNrX3R3bywgWydhc3luYycsICdmdW5jdGlvbiddKSB8fFxuICAgICAgICAgIChwZWVrX2JhY2tfdHdvLnRleHQgPT09ICcqJyAmJiByZXNlcnZlZF9hcnJheShwZWVrX2JhY2tfdGhyZWUsIFsnYXN5bmMnLCAnZnVuY3Rpb24nXSkpKSB7XG4gICAgICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fZmxhZ3MubW9kZSA9PT0gTU9ERS5PYmplY3RMaXRlcmFsKSB7XG4gICAgICAgICAgaWYgKChwZWVrX2JhY2tfdHdvLnRleHQgPT09ICd7JyB8fCBwZWVrX2JhY2tfdHdvLnRleHQgPT09ICcsJykgfHxcbiAgICAgICAgICAgIChwZWVrX2JhY2tfdHdvLnRleHQgPT09ICcqJyAmJiAocGVla19iYWNrX3RocmVlLnRleHQgPT09ICd7JyB8fCBwZWVrX2JhY2tfdGhyZWUudGV4dCA9PT0gJywnKSkpIHtcbiAgICAgICAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTdXBwb3J0IHByZXNlcnZpbmcgd3JhcHBlZCBhcnJvdyBmdW5jdGlvbiBleHByZXNzaW9uc1xuICAgICAgLy8gYS5iKCdjJyxcbiAgICAgIC8vICAgICAoKSA9PiBkLmVcbiAgICAgIC8vIClcbiAgICAgIHRoaXMuYWxsb3dfd3JhcF9vcl9wcmVzZXJ2ZWRfbmV3bGluZShjdXJyZW50X3Rva2VuKTtcbiAgICB9XG5cbiAgICAvLyBmdW5jdGlvbigpIHZzIGZ1bmN0aW9uICgpXG4gICAgLy8geWllbGQqKCkgdnMgeWllbGQqICgpXG4gICAgLy8gZnVuY3Rpb24qKCkgdnMgZnVuY3Rpb24qICgpXG4gICAgaWYgKCh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLlJFU0VSVkVEICYmICh0aGlzLl9mbGFncy5sYXN0X3dvcmQgPT09ICdmdW5jdGlvbicgfHwgdGhpcy5fZmxhZ3MubGFzdF93b3JkID09PSAndHlwZW9mJykpIHx8XG4gICAgICAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0ID09PSAnKicgJiZcbiAgICAgICAgKGluX2FycmF5KHRoaXMuX2xhc3RfbGFzdF90ZXh0LCBbJ2Z1bmN0aW9uJywgJ3lpZWxkJ10pIHx8XG4gICAgICAgICAgKHRoaXMuX2ZsYWdzLm1vZGUgPT09IE1PREUuT2JqZWN0TGl0ZXJhbCAmJiBpbl9hcnJheSh0aGlzLl9sYXN0X2xhc3RfdGV4dCwgWyd7JywgJywnXSkpKSkpIHtcbiAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0aGlzLl9vcHRpb25zLnNwYWNlX2FmdGVyX2Fub25fZnVuY3Rpb247XG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udGV4dCA9PT0gJzsnIHx8IHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uU1RBUlRfQkxPQ0spIHtcbiAgICB0aGlzLnByaW50X25ld2xpbmUoKTtcbiAgfSBlbHNlIGlmICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLkVORF9FWFBSIHx8IHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uU1RBUlRfRVhQUiB8fCB0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLkVORF9CTE9DSyB8fCB0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQgPT09ICcuJyB8fCB0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLkNPTU1BKSB7XG4gICAgLy8gZG8gbm90aGluZyBvbiAoKCBhbmQgKSggYW5kIF1bIGFuZCBdKCBhbmQgLihcbiAgICAvLyBUT0RPOiBDb25zaWRlciB3aGV0aGVyIGZvcmNpbmcgdGhpcyBpcyByZXF1aXJlZC4gIFJldmlldyBmYWlsaW5nIHRlc3RzIHdoZW4gcmVtb3ZlZC5cbiAgICB0aGlzLmFsbG93X3dyYXBfb3JfcHJlc2VydmVkX25ld2xpbmUoY3VycmVudF90b2tlbiwgY3VycmVudF90b2tlbi5uZXdsaW5lcyk7XG4gIH1cblxuICB0aGlzLnByaW50X3Rva2VuKGN1cnJlbnRfdG9rZW4pO1xuICB0aGlzLnNldF9tb2RlKG5leHRfbW9kZSk7XG4gIGlmICh0aGlzLl9vcHRpb25zLnNwYWNlX2luX3BhcmVuKSB7XG4gICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gIH1cblxuICAvLyBJbiBhbGwgY2FzZXMsIGlmIHdlIG5ld2xpbmUgd2hpbGUgaW5zaWRlIGFuIGV4cHJlc3Npb24gaXQgc2hvdWxkIGJlIGluZGVudGVkLlxuICB0aGlzLmluZGVudCgpO1xufTtcblxuQmVhdXRpZmllci5wcm90b3R5cGUuaGFuZGxlX2VuZF9leHByID0gZnVuY3Rpb24oY3VycmVudF90b2tlbikge1xuICAvLyBzdGF0ZW1lbnRzIGluc2lkZSBleHByZXNzaW9ucyBhcmUgbm90IHZhbGlkIHN5bnRheCwgYnV0Li4uXG4gIC8vIHN0YXRlbWVudHMgbXVzdCBhbGwgYmUgY2xvc2VkIHdoZW4gdGhlaXIgY29udGFpbmVyIGNsb3Nlc1xuICB3aGlsZSAodGhpcy5fZmxhZ3MubW9kZSA9PT0gTU9ERS5TdGF0ZW1lbnQpIHtcbiAgICB0aGlzLnJlc3RvcmVfbW9kZSgpO1xuICB9XG5cbiAgdGhpcy5oYW5kbGVfd2hpdGVzcGFjZV9hbmRfY29tbWVudHMoY3VycmVudF90b2tlbik7XG5cbiAgaWYgKHRoaXMuX2ZsYWdzLm11bHRpbGluZV9mcmFtZSkge1xuICAgIHRoaXMuYWxsb3dfd3JhcF9vcl9wcmVzZXJ2ZWRfbmV3bGluZShjdXJyZW50X3Rva2VuLFxuICAgICAgY3VycmVudF90b2tlbi50ZXh0ID09PSAnXScgJiYgaXNfYXJyYXkodGhpcy5fZmxhZ3MubW9kZSkgJiYgIXRoaXMuX29wdGlvbnMua2VlcF9hcnJheV9pbmRlbnRhdGlvbik7XG4gIH1cblxuICBpZiAodGhpcy5fb3B0aW9ucy5zcGFjZV9pbl9wYXJlbikge1xuICAgIGlmICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLlNUQVJUX0VYUFIgJiYgIXRoaXMuX29wdGlvbnMuc3BhY2VfaW5fZW1wdHlfcGFyZW4pIHtcbiAgICAgIC8vICgpIFtdIG5vIGlubmVyIHNwYWNlIGluIGVtcHR5IHBhcmVucyBsaWtlIHRoZXNlLCBldmVyLCByZWYgIzMyMFxuICAgICAgdGhpcy5fb3V0cHV0LnRyaW0oKTtcbiAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgfVxuICB9XG4gIHRoaXMuZGVpbmRlbnQoKTtcbiAgdGhpcy5wcmludF90b2tlbihjdXJyZW50X3Rva2VuKTtcbiAgdGhpcy5yZXN0b3JlX21vZGUoKTtcblxuICByZW1vdmVfcmVkdW5kYW50X2luZGVudGF0aW9uKHRoaXMuX291dHB1dCwgdGhpcy5fcHJldmlvdXNfZmxhZ3MpO1xuXG4gIC8vIGRvIHt9IHdoaWxlICgpIC8vIG5vIHN0YXRlbWVudCByZXF1aXJlZCBhZnRlclxuICBpZiAodGhpcy5fZmxhZ3MuZG9fd2hpbGUgJiYgdGhpcy5fcHJldmlvdXNfZmxhZ3MubW9kZSA9PT0gTU9ERS5Db25kaXRpb25hbCkge1xuICAgIHRoaXMuX3ByZXZpb3VzX2ZsYWdzLm1vZGUgPSBNT0RFLkV4cHJlc3Npb247XG4gICAgdGhpcy5fZmxhZ3MuZG9fYmxvY2sgPSBmYWxzZTtcbiAgICB0aGlzLl9mbGFncy5kb193aGlsZSA9IGZhbHNlO1xuXG4gIH1cbn07XG5cbkJlYXV0aWZpZXIucHJvdG90eXBlLmhhbmRsZV9zdGFydF9ibG9jayA9IGZ1bmN0aW9uKGN1cnJlbnRfdG9rZW4pIHtcbiAgdGhpcy5oYW5kbGVfd2hpdGVzcGFjZV9hbmRfY29tbWVudHMoY3VycmVudF90b2tlbik7XG5cbiAgLy8gQ2hlY2sgaWYgdGhpcyBpcyBzaG91bGQgYmUgdHJlYXRlZCBhcyBhIE9iamVjdExpdGVyYWxcbiAgdmFyIG5leHRfdG9rZW4gPSB0aGlzLl90b2tlbnMucGVlaygpO1xuICB2YXIgc2Vjb25kX3Rva2VuID0gdGhpcy5fdG9rZW5zLnBlZWsoMSk7XG4gIGlmICh0aGlzLl9mbGFncy5sYXN0X3dvcmQgPT09ICdzd2l0Y2gnICYmIHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uRU5EX0VYUFIpIHtcbiAgICB0aGlzLnNldF9tb2RlKE1PREUuQmxvY2tTdGF0ZW1lbnQpO1xuICAgIHRoaXMuX2ZsYWdzLmluX2Nhc2Vfc3RhdGVtZW50ID0gdHJ1ZTtcbiAgfSBlbHNlIGlmICh0aGlzLl9mbGFncy5jYXNlX2JvZHkpIHtcbiAgICB0aGlzLnNldF9tb2RlKE1PREUuQmxvY2tTdGF0ZW1lbnQpO1xuICB9IGVsc2UgaWYgKHNlY29uZF90b2tlbiAmJiAoXG4gICAgICAoaW5fYXJyYXkoc2Vjb25kX3Rva2VuLnRleHQsIFsnOicsICcsJ10pICYmIGluX2FycmF5KG5leHRfdG9rZW4udHlwZSwgW1RPS0VOLlNUUklORywgVE9LRU4uV09SRCwgVE9LRU4uUkVTRVJWRURdKSkgfHxcbiAgICAgIChpbl9hcnJheShuZXh0X3Rva2VuLnRleHQsIFsnZ2V0JywgJ3NldCcsICcuLi4nXSkgJiYgaW5fYXJyYXkoc2Vjb25kX3Rva2VuLnR5cGUsIFtUT0tFTi5XT1JELCBUT0tFTi5SRVNFUlZFRF0pKVxuICAgICkpIHtcbiAgICAvLyBXZSBkb24ndCBzdXBwb3J0IFR5cGVTY3JpcHQsYnV0IHdlIGRpZG4ndCBicmVhayBpdCBmb3IgYSB2ZXJ5IGxvbmcgdGltZS5cbiAgICAvLyBXZSdsbCB0cnkgdG8ga2VlcCBub3QgYnJlYWtpbmcgaXQuXG4gICAgaWYgKCFpbl9hcnJheSh0aGlzLl9sYXN0X2xhc3RfdGV4dCwgWydjbGFzcycsICdpbnRlcmZhY2UnXSkpIHtcbiAgICAgIHRoaXMuc2V0X21vZGUoTU9ERS5PYmplY3RMaXRlcmFsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRfbW9kZShNT0RFLkJsb2NrU3RhdGVtZW50KTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5PUEVSQVRPUiAmJiB0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQgPT09ICc9PicpIHtcbiAgICAvLyBhcnJvdyBmdW5jdGlvbjogKHBhcmFtMSwgcGFyYW1OKSA9PiB7IHN0YXRlbWVudHMgfVxuICAgIHRoaXMuc2V0X21vZGUoTU9ERS5CbG9ja1N0YXRlbWVudCk7XG4gIH0gZWxzZSBpZiAoaW5fYXJyYXkodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlLCBbVE9LRU4uRVFVQUxTLCBUT0tFTi5TVEFSVF9FWFBSLCBUT0tFTi5DT01NQSwgVE9LRU4uT1BFUkFUT1JdKSB8fFxuICAgIHJlc2VydmVkX2FycmF5KHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4sIFsncmV0dXJuJywgJ3Rocm93JywgJ2ltcG9ydCcsICdkZWZhdWx0J10pXG4gICkge1xuICAgIC8vIERldGVjdGluZyBzaG9ydGhhbmQgZnVuY3Rpb24gc3ludGF4IGlzIGRpZmZpY3VsdCBieSBzY2FubmluZyBmb3J3YXJkLFxuICAgIC8vICAgICBzbyBjaGVjayB0aGUgc3Vycm91bmRpbmcgY29udGV4dC5cbiAgICAvLyBJZiB0aGUgYmxvY2sgaXMgYmVpbmcgcmV0dXJuZWQsIGltcG9ydGVkLCBleHBvcnQgZGVmYXVsdCwgcGFzc2VkIGFzIGFyZyxcbiAgICAvLyAgICAgYXNzaWduZWQgd2l0aCA9IG9yIGFzc2lnbmVkIGluIGEgbmVzdGVkIG9iamVjdCwgdHJlYXQgYXMgYW4gT2JqZWN0TGl0ZXJhbC5cbiAgICB0aGlzLnNldF9tb2RlKE1PREUuT2JqZWN0TGl0ZXJhbCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5zZXRfbW9kZShNT0RFLkJsb2NrU3RhdGVtZW50KTtcbiAgfVxuXG4gIHZhciBlbXB0eV9icmFjZXMgPSAhbmV4dF90b2tlbi5jb21tZW50c19iZWZvcmUgJiYgbmV4dF90b2tlbi50ZXh0ID09PSAnfSc7XG4gIHZhciBlbXB0eV9hbm9ueW1vdXNfZnVuY3Rpb24gPSBlbXB0eV9icmFjZXMgJiYgdGhpcy5fZmxhZ3MubGFzdF93b3JkID09PSAnZnVuY3Rpb24nICYmXG4gICAgdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5FTkRfRVhQUjtcblxuICBpZiAodGhpcy5fb3B0aW9ucy5icmFjZV9wcmVzZXJ2ZV9pbmxpbmUpIC8vIGNoZWNrIGZvciBpbmxpbmUsIHNldCBpbmxpbmVfZnJhbWUgaWYgc29cbiAge1xuICAgIC8vIHNlYXJjaCBmb3J3YXJkIGZvciBhIG5ld2xpbmUgd2FudGVkIGluc2lkZSB0aGlzIGJsb2NrXG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgY2hlY2tfdG9rZW4gPSBudWxsO1xuICAgIHRoaXMuX2ZsYWdzLmlubGluZV9mcmFtZSA9IHRydWU7XG4gICAgZG8ge1xuICAgICAgaW5kZXggKz0gMTtcbiAgICAgIGNoZWNrX3Rva2VuID0gdGhpcy5fdG9rZW5zLnBlZWsoaW5kZXggLSAxKTtcbiAgICAgIGlmIChjaGVja190b2tlbi5uZXdsaW5lcykge1xuICAgICAgICB0aGlzLl9mbGFncy5pbmxpbmVfZnJhbWUgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSB3aGlsZSAoY2hlY2tfdG9rZW4udHlwZSAhPT0gVE9LRU4uRU9GICYmXG4gICAgICAhKGNoZWNrX3Rva2VuLnR5cGUgPT09IFRPS0VOLkVORF9CTE9DSyAmJiBjaGVja190b2tlbi5vcGVuZWQgPT09IGN1cnJlbnRfdG9rZW4pKTtcbiAgfVxuXG4gIGlmICgodGhpcy5fb3B0aW9ucy5icmFjZV9zdHlsZSA9PT0gXCJleHBhbmRcIiB8fFxuICAgICAgKHRoaXMuX29wdGlvbnMuYnJhY2Vfc3R5bGUgPT09IFwibm9uZVwiICYmIGN1cnJlbnRfdG9rZW4ubmV3bGluZXMpKSAmJlxuICAgICF0aGlzLl9mbGFncy5pbmxpbmVfZnJhbWUpIHtcbiAgICBpZiAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlICE9PSBUT0tFTi5PUEVSQVRPUiAmJlxuICAgICAgKGVtcHR5X2Fub255bW91c19mdW5jdGlvbiB8fFxuICAgICAgICB0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLkVRVUFMUyB8fFxuICAgICAgICAocmVzZXJ2ZWRfYXJyYXkodGhpcy5fZmxhZ3MubGFzdF90b2tlbiwgc3BlY2lhbF93b3JkcykgJiYgdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0ICE9PSAnZWxzZScpKSkge1xuICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucHJpbnRfbmV3bGluZShmYWxzZSwgdHJ1ZSk7XG4gICAgfVxuICB9IGVsc2UgeyAvLyBjb2xsYXBzZSB8fCBpbmxpbmVfZnJhbWVcbiAgICBpZiAoaXNfYXJyYXkodGhpcy5fcHJldmlvdXNfZmxhZ3MubW9kZSkgJiYgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uU1RBUlRfRVhQUiB8fCB0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLkNPTU1BKSkge1xuICAgICAgaWYgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uQ09NTUEgfHwgdGhpcy5fb3B0aW9ucy5zcGFjZV9pbl9wYXJlbikge1xuICAgICAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uQ09NTUEgfHwgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uU1RBUlRfRVhQUiAmJiB0aGlzLl9mbGFncy5pbmxpbmVfZnJhbWUpKSB7XG4gICAgICAgIHRoaXMuYWxsb3dfd3JhcF9vcl9wcmVzZXJ2ZWRfbmV3bGluZShjdXJyZW50X3Rva2VuKTtcbiAgICAgICAgdGhpcy5fcHJldmlvdXNfZmxhZ3MubXVsdGlsaW5lX2ZyYW1lID0gdGhpcy5fcHJldmlvdXNfZmxhZ3MubXVsdGlsaW5lX2ZyYW1lIHx8IHRoaXMuX2ZsYWdzLm11bHRpbGluZV9mcmFtZTtcbiAgICAgICAgdGhpcy5fZmxhZ3MubXVsdGlsaW5lX2ZyYW1lID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgIT09IFRPS0VOLk9QRVJBVE9SICYmIHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSAhPT0gVE9LRU4uU1RBUlRfRVhQUikge1xuICAgICAgaWYgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uU1RBUlRfQkxPQ0sgJiYgIXRoaXMuX2ZsYWdzLmlubGluZV9mcmFtZSkge1xuICAgICAgICB0aGlzLnByaW50X25ld2xpbmUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB0aGlzLnByaW50X3Rva2VuKGN1cnJlbnRfdG9rZW4pO1xuICB0aGlzLmluZGVudCgpO1xuXG4gIC8vIEV4Y2VwdCBmb3Igc3BlY2lmaWMgY2FzZXMsIG9wZW4gYnJhY2VzIGFyZSBmb2xsb3dlZCBieSBhIG5ldyBsaW5lLlxuICBpZiAoIWVtcHR5X2JyYWNlcyAmJiAhKHRoaXMuX29wdGlvbnMuYnJhY2VfcHJlc2VydmVfaW5saW5lICYmIHRoaXMuX2ZsYWdzLmlubGluZV9mcmFtZSkpIHtcbiAgICB0aGlzLnByaW50X25ld2xpbmUoKTtcbiAgfVxufTtcblxuQmVhdXRpZmllci5wcm90b3R5cGUuaGFuZGxlX2VuZF9ibG9jayA9IGZ1bmN0aW9uKGN1cnJlbnRfdG9rZW4pIHtcbiAgLy8gc3RhdGVtZW50cyBtdXN0IGFsbCBiZSBjbG9zZWQgd2hlbiB0aGVpciBjb250YWluZXIgY2xvc2VzXG4gIHRoaXMuaGFuZGxlX3doaXRlc3BhY2VfYW5kX2NvbW1lbnRzKGN1cnJlbnRfdG9rZW4pO1xuXG4gIHdoaWxlICh0aGlzLl9mbGFncy5tb2RlID09PSBNT0RFLlN0YXRlbWVudCkge1xuICAgIHRoaXMucmVzdG9yZV9tb2RlKCk7XG4gIH1cblxuICB2YXIgZW1wdHlfYnJhY2VzID0gdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5TVEFSVF9CTE9DSztcblxuICBpZiAodGhpcy5fZmxhZ3MuaW5saW5lX2ZyYW1lICYmICFlbXB0eV9icmFjZXMpIHsgLy8gdHJ5IGlubGluZV9mcmFtZSAob25seSBzZXQgaWYgdGhpcy5fb3B0aW9ucy5icmFjZXMtcHJlc2VydmUtaW5saW5lKSBmaXJzdFxuICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICB9IGVsc2UgaWYgKHRoaXMuX29wdGlvbnMuYnJhY2Vfc3R5bGUgPT09IFwiZXhwYW5kXCIpIHtcbiAgICBpZiAoIWVtcHR5X2JyYWNlcykge1xuICAgICAgdGhpcy5wcmludF9uZXdsaW5lKCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIHNraXAge31cbiAgICBpZiAoIWVtcHR5X2JyYWNlcykge1xuICAgICAgaWYgKGlzX2FycmF5KHRoaXMuX2ZsYWdzLm1vZGUpICYmIHRoaXMuX29wdGlvbnMua2VlcF9hcnJheV9pbmRlbnRhdGlvbikge1xuICAgICAgICAvLyB3ZSBSRUFMTFkgbmVlZCBhIG5ld2xpbmUgaGVyZSwgYnV0IG5ld2xpbmVyIHdvdWxkIHNraXAgdGhhdFxuICAgICAgICB0aGlzLl9vcHRpb25zLmtlZXBfYXJyYXlfaW5kZW50YXRpb24gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wcmludF9uZXdsaW5lKCk7XG4gICAgICAgIHRoaXMuX29wdGlvbnMua2VlcF9hcnJheV9pbmRlbnRhdGlvbiA9IHRydWU7XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucHJpbnRfbmV3bGluZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB0aGlzLnJlc3RvcmVfbW9kZSgpO1xuICB0aGlzLnByaW50X3Rva2VuKGN1cnJlbnRfdG9rZW4pO1xufTtcblxuQmVhdXRpZmllci5wcm90b3R5cGUuaGFuZGxlX3dvcmQgPSBmdW5jdGlvbihjdXJyZW50X3Rva2VuKSB7XG4gIGlmIChjdXJyZW50X3Rva2VuLnR5cGUgPT09IFRPS0VOLlJFU0VSVkVEKSB7XG4gICAgaWYgKGluX2FycmF5KGN1cnJlbnRfdG9rZW4udGV4dCwgWydzZXQnLCAnZ2V0J10pICYmIHRoaXMuX2ZsYWdzLm1vZGUgIT09IE1PREUuT2JqZWN0TGl0ZXJhbCkge1xuICAgICAgY3VycmVudF90b2tlbi50eXBlID0gVE9LRU4uV09SRDtcbiAgICB9IGVsc2UgaWYgKGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJ2ltcG9ydCcgJiYgdGhpcy5fdG9rZW5zLnBlZWsoKS50ZXh0ID09PSAnKCcpIHtcbiAgICAgIGN1cnJlbnRfdG9rZW4udHlwZSA9IFRPS0VOLldPUkQ7XG4gICAgfSBlbHNlIGlmIChpbl9hcnJheShjdXJyZW50X3Rva2VuLnRleHQsIFsnYXMnLCAnZnJvbSddKSAmJiAhdGhpcy5fZmxhZ3MuaW1wb3J0X2Jsb2NrKSB7XG4gICAgICBjdXJyZW50X3Rva2VuLnR5cGUgPSBUT0tFTi5XT1JEO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fZmxhZ3MubW9kZSA9PT0gTU9ERS5PYmplY3RMaXRlcmFsKSB7XG4gICAgICB2YXIgbmV4dF90b2tlbiA9IHRoaXMuX3Rva2Vucy5wZWVrKCk7XG4gICAgICBpZiAobmV4dF90b2tlbi50ZXh0ID09PSAnOicpIHtcbiAgICAgICAgY3VycmVudF90b2tlbi50eXBlID0gVE9LRU4uV09SRDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy5zdGFydF9vZl9zdGF0ZW1lbnQoY3VycmVudF90b2tlbikpIHtcbiAgICAvLyBUaGUgY29uZGl0aW9uYWwgc3RhcnRzIHRoZSBzdGF0ZW1lbnQgaWYgYXBwcm9wcmlhdGUuXG4gICAgaWYgKHJlc2VydmVkX2FycmF5KHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4sIFsndmFyJywgJ2xldCcsICdjb25zdCddKSAmJiBjdXJyZW50X3Rva2VuLnR5cGUgPT09IFRPS0VOLldPUkQpIHtcbiAgICAgIHRoaXMuX2ZsYWdzLmRlY2xhcmF0aW9uX3N0YXRlbWVudCA9IHRydWU7XG4gICAgfVxuICB9IGVsc2UgaWYgKGN1cnJlbnRfdG9rZW4ubmV3bGluZXMgJiYgIWlzX2V4cHJlc3Npb24odGhpcy5fZmxhZ3MubW9kZSkgJiZcbiAgICAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlICE9PSBUT0tFTi5PUEVSQVRPUiB8fCAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0ID09PSAnLS0nIHx8IHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udGV4dCA9PT0gJysrJykpICYmXG4gICAgdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlICE9PSBUT0tFTi5FUVVBTFMgJiZcbiAgICAodGhpcy5fb3B0aW9ucy5wcmVzZXJ2ZV9uZXdsaW5lcyB8fCAhcmVzZXJ2ZWRfYXJyYXkodGhpcy5fZmxhZ3MubGFzdF90b2tlbiwgWyd2YXInLCAnbGV0JywgJ2NvbnN0JywgJ3NldCcsICdnZXQnXSkpKSB7XG4gICAgdGhpcy5oYW5kbGVfd2hpdGVzcGFjZV9hbmRfY29tbWVudHMoY3VycmVudF90b2tlbik7XG4gICAgdGhpcy5wcmludF9uZXdsaW5lKCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5oYW5kbGVfd2hpdGVzcGFjZV9hbmRfY29tbWVudHMoY3VycmVudF90b2tlbik7XG4gIH1cblxuICBpZiAodGhpcy5fZmxhZ3MuZG9fYmxvY2sgJiYgIXRoaXMuX2ZsYWdzLmRvX3doaWxlKSB7XG4gICAgaWYgKHJlc2VydmVkX3dvcmQoY3VycmVudF90b2tlbiwgJ3doaWxlJykpIHtcbiAgICAgIC8vIGRvIHt9ICMjIHdoaWxlICgpXG4gICAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgIHRoaXMucHJpbnRfdG9rZW4oY3VycmVudF90b2tlbik7XG4gICAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgIHRoaXMuX2ZsYWdzLmRvX3doaWxlID0gdHJ1ZTtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZG8ge30gc2hvdWxkIGFsd2F5cyBoYXZlIHdoaWxlIGFzIHRoZSBuZXh0IHdvcmQuXG4gICAgICAvLyBpZiB3ZSBkb24ndCBzZWUgdGhlIGV4cGVjdGVkIHdoaWxlLCByZWNvdmVyXG4gICAgICB0aGlzLnByaW50X25ld2xpbmUoKTtcbiAgICAgIHRoaXMuX2ZsYWdzLmRvX2Jsb2NrID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgbWF5IGJlIGZvbGxvd2VkIGJ5IGVsc2UsIG9yIG5vdFxuICAvLyBCYXJlL2lubGluZSBpZnMgYXJlIHRyaWNreVxuICAvLyBOZWVkIHRvIHVud2luZCB0aGUgbW9kZXMgY29ycmVjdGx5OiBpZiAoYSkgaWYgKGIpIGMoKTsgZWxzZSBkKCk7IGVsc2UgZSgpO1xuICBpZiAodGhpcy5fZmxhZ3MuaWZfYmxvY2spIHtcbiAgICBpZiAoIXRoaXMuX2ZsYWdzLmVsc2VfYmxvY2sgJiYgcmVzZXJ2ZWRfd29yZChjdXJyZW50X3Rva2VuLCAnZWxzZScpKSB7XG4gICAgICB0aGlzLl9mbGFncy5lbHNlX2Jsb2NrID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2hpbGUgKHRoaXMuX2ZsYWdzLm1vZGUgPT09IE1PREUuU3RhdGVtZW50KSB7XG4gICAgICAgIHRoaXMucmVzdG9yZV9tb2RlKCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9mbGFncy5pZl9ibG9jayA9IGZhbHNlO1xuICAgICAgdGhpcy5fZmxhZ3MuZWxzZV9ibG9jayA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0aGlzLl9mbGFncy5pbl9jYXNlX3N0YXRlbWVudCAmJiByZXNlcnZlZF9hcnJheShjdXJyZW50X3Rva2VuLCBbJ2Nhc2UnLCAnZGVmYXVsdCddKSkge1xuICAgIHRoaXMucHJpbnRfbmV3bGluZSgpO1xuICAgIGlmICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgIT09IFRPS0VOLkVORF9CTE9DSyAmJiAodGhpcy5fZmxhZ3MuY2FzZV9ib2R5IHx8IHRoaXMuX29wdGlvbnMuanNsaW50X2hhcHB5KSkge1xuICAgICAgLy8gc3dpdGNoIGNhc2VzIGZvbGxvd2luZyBvbmUgYW5vdGhlclxuICAgICAgdGhpcy5kZWluZGVudCgpO1xuICAgIH1cbiAgICB0aGlzLl9mbGFncy5jYXNlX2JvZHkgPSBmYWxzZTtcblxuICAgIHRoaXMucHJpbnRfdG9rZW4oY3VycmVudF90b2tlbik7XG4gICAgdGhpcy5fZmxhZ3MuaW5fY2FzZSA9IHRydWU7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uQ09NTUEgfHwgdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5TVEFSVF9FWFBSIHx8IHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uRVFVQUxTIHx8IHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uT1BFUkFUT1IpIHtcbiAgICBpZiAoIXRoaXMuc3RhcnRfb2Zfb2JqZWN0X3Byb3BlcnR5KCkpIHtcbiAgICAgIHRoaXMuYWxsb3dfd3JhcF9vcl9wcmVzZXJ2ZWRfbmV3bGluZShjdXJyZW50X3Rva2VuKTtcbiAgICB9XG4gIH1cblxuICBpZiAocmVzZXJ2ZWRfd29yZChjdXJyZW50X3Rva2VuLCAnZnVuY3Rpb24nKSkge1xuICAgIGlmIChpbl9hcnJheSh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQsIFsnfScsICc7J10pIHx8XG4gICAgICAodGhpcy5fb3V0cHV0Lmp1c3RfYWRkZWRfbmV3bGluZSgpICYmICEoaW5fYXJyYXkodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0LCBbJygnLCAnWycsICd7JywgJzonLCAnPScsICcsJ10pIHx8IHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uT1BFUkFUT1IpKSkge1xuICAgICAgLy8gbWFrZSBzdXJlIHRoZXJlIGlzIGEgbmljZSBjbGVhbiBzcGFjZSBvZiBhdCBsZWFzdCBvbmUgYmxhbmsgbGluZVxuICAgICAgLy8gYmVmb3JlIGEgbmV3IGZ1bmN0aW9uIGRlZmluaXRpb25cbiAgICAgIGlmICghdGhpcy5fb3V0cHV0Lmp1c3RfYWRkZWRfYmxhbmtsaW5lKCkgJiYgIWN1cnJlbnRfdG9rZW4uY29tbWVudHNfYmVmb3JlKSB7XG4gICAgICAgIHRoaXMucHJpbnRfbmV3bGluZSgpO1xuICAgICAgICB0aGlzLnByaW50X25ld2xpbmUodHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLlJFU0VSVkVEIHx8IHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uV09SRCkge1xuICAgICAgaWYgKHJlc2VydmVkX2FycmF5KHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4sIFsnZ2V0JywgJ3NldCcsICduZXcnLCAnZXhwb3J0J10pIHx8XG4gICAgICAgIHJlc2VydmVkX2FycmF5KHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4sIG5ld2xpbmVfcmVzdHJpY3RlZF90b2tlbnMpKSB7XG4gICAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChyZXNlcnZlZF93b3JkKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4sICdkZWZhdWx0JykgJiYgdGhpcy5fbGFzdF9sYXN0X3RleHQgPT09ICdleHBvcnQnKSB7XG4gICAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQgPT09ICdkZWNsYXJlJykge1xuICAgICAgICAvLyBhY2NvbW9kYXRlcyBUeXBlc2NyaXB0IGRlY2xhcmUgZnVuY3Rpb24gZm9ybWF0dGluZ1xuICAgICAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucHJpbnRfbmV3bGluZSgpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5PUEVSQVRPUiB8fCB0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQgPT09ICc9Jykge1xuICAgICAgLy8gZm9vID0gZnVuY3Rpb25cbiAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoIXRoaXMuX2ZsYWdzLm11bHRpbGluZV9mcmFtZSAmJiAoaXNfZXhwcmVzc2lvbih0aGlzLl9mbGFncy5tb2RlKSB8fCBpc19hcnJheSh0aGlzLl9mbGFncy5tb2RlKSkpIHtcbiAgICAgIC8vIChmdW5jdGlvblxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnByaW50X25ld2xpbmUoKTtcbiAgICB9XG5cbiAgICB0aGlzLnByaW50X3Rva2VuKGN1cnJlbnRfdG9rZW4pO1xuICAgIHRoaXMuX2ZsYWdzLmxhc3Rfd29yZCA9IGN1cnJlbnRfdG9rZW4udGV4dDtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcHJlZml4ID0gJ05PTkUnO1xuXG4gIGlmICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLkVORF9CTE9DSykge1xuXG4gICAgaWYgKHRoaXMuX3ByZXZpb3VzX2ZsYWdzLmlubGluZV9mcmFtZSkge1xuICAgICAgcHJlZml4ID0gJ1NQQUNFJztcbiAgICB9IGVsc2UgaWYgKCFyZXNlcnZlZF9hcnJheShjdXJyZW50X3Rva2VuLCBbJ2Vsc2UnLCAnY2F0Y2gnLCAnZmluYWxseScsICdmcm9tJ10pKSB7XG4gICAgICBwcmVmaXggPSAnTkVXTElORSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLl9vcHRpb25zLmJyYWNlX3N0eWxlID09PSBcImV4cGFuZFwiIHx8XG4gICAgICAgIHRoaXMuX29wdGlvbnMuYnJhY2Vfc3R5bGUgPT09IFwiZW5kLWV4cGFuZFwiIHx8XG4gICAgICAgICh0aGlzLl9vcHRpb25zLmJyYWNlX3N0eWxlID09PSBcIm5vbmVcIiAmJiBjdXJyZW50X3Rva2VuLm5ld2xpbmVzKSkge1xuICAgICAgICBwcmVmaXggPSAnTkVXTElORSc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcmVmaXggPSAnU1BBQ0UnO1xuICAgICAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5TRU1JQ09MT04gJiYgdGhpcy5fZmxhZ3MubW9kZSA9PT0gTU9ERS5CbG9ja1N0YXRlbWVudCkge1xuICAgIC8vIFRPRE86IFNob3VsZCB0aGlzIGJlIGZvciBTVEFURU1FTlQgYXMgd2VsbD9cbiAgICBwcmVmaXggPSAnTkVXTElORSc7XG4gIH0gZWxzZSBpZiAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5TRU1JQ09MT04gJiYgaXNfZXhwcmVzc2lvbih0aGlzLl9mbGFncy5tb2RlKSkge1xuICAgIHByZWZpeCA9ICdTUEFDRSc7XG4gIH0gZWxzZSBpZiAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5TVFJJTkcpIHtcbiAgICBwcmVmaXggPSAnTkVXTElORSc7XG4gIH0gZWxzZSBpZiAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5SRVNFUlZFRCB8fCB0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLldPUkQgfHxcbiAgICAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0ID09PSAnKicgJiZcbiAgICAgIChpbl9hcnJheSh0aGlzLl9sYXN0X2xhc3RfdGV4dCwgWydmdW5jdGlvbicsICd5aWVsZCddKSB8fFxuICAgICAgICAodGhpcy5fZmxhZ3MubW9kZSA9PT0gTU9ERS5PYmplY3RMaXRlcmFsICYmIGluX2FycmF5KHRoaXMuX2xhc3RfbGFzdF90ZXh0LCBbJ3snLCAnLCddKSkpKSkge1xuICAgIHByZWZpeCA9ICdTUEFDRSc7XG4gIH0gZWxzZSBpZiAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5TVEFSVF9CTE9DSykge1xuICAgIGlmICh0aGlzLl9mbGFncy5pbmxpbmVfZnJhbWUpIHtcbiAgICAgIHByZWZpeCA9ICdTUEFDRSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByZWZpeCA9ICdORVdMSU5FJztcbiAgICB9XG4gIH0gZWxzZSBpZiAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5FTkRfRVhQUikge1xuICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgIHByZWZpeCA9ICdORVdMSU5FJztcbiAgfVxuXG4gIGlmIChyZXNlcnZlZF9hcnJheShjdXJyZW50X3Rva2VuLCBsaW5lX3N0YXJ0ZXJzKSAmJiB0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQgIT09ICcpJykge1xuICAgIGlmICh0aGlzLl9mbGFncy5pbmxpbmVfZnJhbWUgfHwgdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0ID09PSAnZWxzZScgfHwgdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0ID09PSAnZXhwb3J0Jykge1xuICAgICAgcHJlZml4ID0gJ1NQQUNFJztcbiAgICB9IGVsc2Uge1xuICAgICAgcHJlZml4ID0gJ05FV0xJTkUnO1xuICAgIH1cblxuICB9XG5cbiAgaWYgKHJlc2VydmVkX2FycmF5KGN1cnJlbnRfdG9rZW4sIFsnZWxzZScsICdjYXRjaCcsICdmaW5hbGx5J10pKSB7XG4gICAgaWYgKCghKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uRU5EX0JMT0NLICYmIHRoaXMuX3ByZXZpb3VzX2ZsYWdzLm1vZGUgPT09IE1PREUuQmxvY2tTdGF0ZW1lbnQpIHx8XG4gICAgICAgIHRoaXMuX29wdGlvbnMuYnJhY2Vfc3R5bGUgPT09IFwiZXhwYW5kXCIgfHxcbiAgICAgICAgdGhpcy5fb3B0aW9ucy5icmFjZV9zdHlsZSA9PT0gXCJlbmQtZXhwYW5kXCIgfHxcbiAgICAgICAgKHRoaXMuX29wdGlvbnMuYnJhY2Vfc3R5bGUgPT09IFwibm9uZVwiICYmIGN1cnJlbnRfdG9rZW4ubmV3bGluZXMpKSAmJlxuICAgICAgIXRoaXMuX2ZsYWdzLmlubGluZV9mcmFtZSkge1xuICAgICAgdGhpcy5wcmludF9uZXdsaW5lKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX291dHB1dC50cmltKHRydWUpO1xuICAgICAgdmFyIGxpbmUgPSB0aGlzLl9vdXRwdXQuY3VycmVudF9saW5lO1xuICAgICAgLy8gSWYgd2UgdHJpbW1lZCBhbmQgdGhlcmUncyBzb21ldGhpbmcgb3RoZXIgdGhhbiBhIGNsb3NlIGJsb2NrIGJlZm9yZSB1c1xuICAgICAgLy8gcHV0IGEgbmV3bGluZSBiYWNrIGluLiAgSGFuZGxlcyAnfSAvLyBjb21tZW50JyBzY2VuYXJpby5cbiAgICAgIGlmIChsaW5lLmxhc3QoKSAhPT0gJ30nKSB7XG4gICAgICAgIHRoaXMucHJpbnRfbmV3bGluZSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgfVxuICB9IGVsc2UgaWYgKHByZWZpeCA9PT0gJ05FV0xJTkUnKSB7XG4gICAgaWYgKHJlc2VydmVkX2FycmF5KHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4sIHNwZWNpYWxfd29yZHMpKSB7XG4gICAgICAvLyBubyBuZXdsaW5lIGJldHdlZW4gJ3JldHVybiBubm4nXG4gICAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udGV4dCA9PT0gJ2RlY2xhcmUnICYmIHJlc2VydmVkX2FycmF5KGN1cnJlbnRfdG9rZW4sIFsndmFyJywgJ2xldCcsICdjb25zdCddKSkge1xuICAgICAgLy8gYWNjb21vZGF0ZXMgVHlwZXNjcmlwdCBkZWNsYXJlIGZvcm1hdHRpbmdcbiAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlICE9PSBUT0tFTi5FTkRfRVhQUikge1xuICAgICAgaWYgKCh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgIT09IFRPS0VOLlNUQVJUX0VYUFIgfHwgIXJlc2VydmVkX2FycmF5KGN1cnJlbnRfdG9rZW4sIFsndmFyJywgJ2xldCcsICdjb25zdCddKSkgJiYgdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0ICE9PSAnOicpIHtcbiAgICAgICAgLy8gbm8gbmVlZCB0byBmb3JjZSBuZXdsaW5lIG9uICd2YXInOiBmb3IgKHZhciB4ID0gMC4uLilcbiAgICAgICAgaWYgKHJlc2VydmVkX3dvcmQoY3VycmVudF90b2tlbiwgJ2lmJykgJiYgcmVzZXJ2ZWRfd29yZChjdXJyZW50X3Rva2VuLnByZXZpb3VzLCAnZWxzZScpKSB7XG4gICAgICAgICAgLy8gbm8gbmV3bGluZSBmb3IgfSBlbHNlIGlmIHtcbiAgICAgICAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnByaW50X25ld2xpbmUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocmVzZXJ2ZWRfYXJyYXkoY3VycmVudF90b2tlbiwgbGluZV9zdGFydGVycykgJiYgdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0ICE9PSAnKScpIHtcbiAgICAgIHRoaXMucHJpbnRfbmV3bGluZSgpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0aGlzLl9mbGFncy5tdWx0aWxpbmVfZnJhbWUgJiYgaXNfYXJyYXkodGhpcy5fZmxhZ3MubW9kZSkgJiYgdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0ID09PSAnLCcgJiYgdGhpcy5fbGFzdF9sYXN0X3RleHQgPT09ICd9Jykge1xuICAgIHRoaXMucHJpbnRfbmV3bGluZSgpOyAvLyB9LCBpbiBsaXN0cyBnZXQgYSBuZXdsaW5lIHRyZWF0bWVudFxuICB9IGVsc2UgaWYgKHByZWZpeCA9PT0gJ1NQQUNFJykge1xuICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICB9XG4gIGlmIChjdXJyZW50X3Rva2VuLnByZXZpb3VzICYmIChjdXJyZW50X3Rva2VuLnByZXZpb3VzLnR5cGUgPT09IFRPS0VOLldPUkQgfHwgY3VycmVudF90b2tlbi5wcmV2aW91cy50eXBlID09PSBUT0tFTi5SRVNFUlZFRCkpIHtcbiAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgfVxuICB0aGlzLnByaW50X3Rva2VuKGN1cnJlbnRfdG9rZW4pO1xuICB0aGlzLl9mbGFncy5sYXN0X3dvcmQgPSBjdXJyZW50X3Rva2VuLnRleHQ7XG5cbiAgaWYgKGN1cnJlbnRfdG9rZW4udHlwZSA9PT0gVE9LRU4uUkVTRVJWRUQpIHtcbiAgICBpZiAoY3VycmVudF90b2tlbi50ZXh0ID09PSAnZG8nKSB7XG4gICAgICB0aGlzLl9mbGFncy5kb19ibG9jayA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChjdXJyZW50X3Rva2VuLnRleHQgPT09ICdpZicpIHtcbiAgICAgIHRoaXMuX2ZsYWdzLmlmX2Jsb2NrID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJ2ltcG9ydCcpIHtcbiAgICAgIHRoaXMuX2ZsYWdzLmltcG9ydF9ibG9jayA9IHRydWU7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9mbGFncy5pbXBvcnRfYmxvY2sgJiYgcmVzZXJ2ZWRfd29yZChjdXJyZW50X3Rva2VuLCAnZnJvbScpKSB7XG4gICAgICB0aGlzLl9mbGFncy5pbXBvcnRfYmxvY2sgPSBmYWxzZTtcbiAgICB9XG4gIH1cbn07XG5cbkJlYXV0aWZpZXIucHJvdG90eXBlLmhhbmRsZV9zZW1pY29sb24gPSBmdW5jdGlvbihjdXJyZW50X3Rva2VuKSB7XG4gIGlmICh0aGlzLnN0YXJ0X29mX3N0YXRlbWVudChjdXJyZW50X3Rva2VuKSkge1xuICAgIC8vIFRoZSBjb25kaXRpb25hbCBzdGFydHMgdGhlIHN0YXRlbWVudCBpZiBhcHByb3ByaWF0ZS5cbiAgICAvLyBTZW1pY29sb24gY2FuIGJlIHRoZSBzdGFydCAoYW5kIGVuZCkgb2YgYSBzdGF0ZW1lbnRcbiAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5oYW5kbGVfd2hpdGVzcGFjZV9hbmRfY29tbWVudHMoY3VycmVudF90b2tlbik7XG4gIH1cblxuICB2YXIgbmV4dF90b2tlbiA9IHRoaXMuX3Rva2Vucy5wZWVrKCk7XG4gIHdoaWxlICh0aGlzLl9mbGFncy5tb2RlID09PSBNT0RFLlN0YXRlbWVudCAmJlxuICAgICEodGhpcy5fZmxhZ3MuaWZfYmxvY2sgJiYgcmVzZXJ2ZWRfd29yZChuZXh0X3Rva2VuLCAnZWxzZScpKSAmJlxuICAgICF0aGlzLl9mbGFncy5kb19ibG9jaykge1xuICAgIHRoaXMucmVzdG9yZV9tb2RlKCk7XG4gIH1cblxuICAvLyBoYWNreSBidXQgZWZmZWN0aXZlIGZvciB0aGUgbW9tZW50XG4gIGlmICh0aGlzLl9mbGFncy5pbXBvcnRfYmxvY2spIHtcbiAgICB0aGlzLl9mbGFncy5pbXBvcnRfYmxvY2sgPSBmYWxzZTtcbiAgfVxuICB0aGlzLnByaW50X3Rva2VuKGN1cnJlbnRfdG9rZW4pO1xufTtcblxuQmVhdXRpZmllci5wcm90b3R5cGUuaGFuZGxlX3N0cmluZyA9IGZ1bmN0aW9uKGN1cnJlbnRfdG9rZW4pIHtcbiAgaWYgKHRoaXMuc3RhcnRfb2Zfc3RhdGVtZW50KGN1cnJlbnRfdG9rZW4pKSB7XG4gICAgLy8gVGhlIGNvbmRpdGlvbmFsIHN0YXJ0cyB0aGUgc3RhdGVtZW50IGlmIGFwcHJvcHJpYXRlLlxuICAgIC8vIE9uZSBkaWZmZXJlbmNlIC0gc3RyaW5ncyB3YW50IGF0IGxlYXN0IGEgc3BhY2UgYmVmb3JlXG4gICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5oYW5kbGVfd2hpdGVzcGFjZV9hbmRfY29tbWVudHMoY3VycmVudF90b2tlbik7XG4gICAgaWYgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uUkVTRVJWRUQgfHwgdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5XT1JEIHx8IHRoaXMuX2ZsYWdzLmlubGluZV9mcmFtZSkge1xuICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLkNPTU1BIHx8IHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uU1RBUlRfRVhQUiB8fCB0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLkVRVUFMUyB8fCB0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLk9QRVJBVE9SKSB7XG4gICAgICBpZiAoIXRoaXMuc3RhcnRfb2Zfb2JqZWN0X3Byb3BlcnR5KCkpIHtcbiAgICAgICAgdGhpcy5hbGxvd193cmFwX29yX3ByZXNlcnZlZF9uZXdsaW5lKGN1cnJlbnRfdG9rZW4pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnByaW50X25ld2xpbmUoKTtcbiAgICB9XG4gIH1cbiAgdGhpcy5wcmludF90b2tlbihjdXJyZW50X3Rva2VuKTtcbn07XG5cbkJlYXV0aWZpZXIucHJvdG90eXBlLmhhbmRsZV9lcXVhbHMgPSBmdW5jdGlvbihjdXJyZW50X3Rva2VuKSB7XG4gIGlmICh0aGlzLnN0YXJ0X29mX3N0YXRlbWVudChjdXJyZW50X3Rva2VuKSkge1xuICAgIC8vIFRoZSBjb25kaXRpb25hbCBzdGFydHMgdGhlIHN0YXRlbWVudCBpZiBhcHByb3ByaWF0ZS5cbiAgfSBlbHNlIHtcbiAgICB0aGlzLmhhbmRsZV93aGl0ZXNwYWNlX2FuZF9jb21tZW50cyhjdXJyZW50X3Rva2VuKTtcbiAgfVxuXG4gIGlmICh0aGlzLl9mbGFncy5kZWNsYXJhdGlvbl9zdGF0ZW1lbnQpIHtcbiAgICAvLyBqdXN0IGdvdCBhbiAnPScgaW4gYSB2YXItbGluZSwgZGlmZmVyZW50IGZvcm1hdHRpbmcvbGluZS1icmVha2luZywgZXRjIHdpbGwgbm93IGJlIGRvbmVcbiAgICB0aGlzLl9mbGFncy5kZWNsYXJhdGlvbl9hc3NpZ25tZW50ID0gdHJ1ZTtcbiAgfVxuICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgdGhpcy5wcmludF90b2tlbihjdXJyZW50X3Rva2VuKTtcbiAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG59O1xuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5oYW5kbGVfY29tbWEgPSBmdW5jdGlvbihjdXJyZW50X3Rva2VuKSB7XG4gIHRoaXMuaGFuZGxlX3doaXRlc3BhY2VfYW5kX2NvbW1lbnRzKGN1cnJlbnRfdG9rZW4sIHRydWUpO1xuXG4gIHRoaXMucHJpbnRfdG9rZW4oY3VycmVudF90b2tlbik7XG4gIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICBpZiAodGhpcy5fZmxhZ3MuZGVjbGFyYXRpb25fc3RhdGVtZW50KSB7XG4gICAgaWYgKGlzX2V4cHJlc3Npb24odGhpcy5fZmxhZ3MucGFyZW50Lm1vZGUpKSB7XG4gICAgICAvLyBkbyBub3QgYnJlYWsgb24gY29tbWEsIGZvcih2YXIgYSA9IDEsIGIgPSAyKVxuICAgICAgdGhpcy5fZmxhZ3MuZGVjbGFyYXRpb25fYXNzaWdubWVudCA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9mbGFncy5kZWNsYXJhdGlvbl9hc3NpZ25tZW50KSB7XG4gICAgICB0aGlzLl9mbGFncy5kZWNsYXJhdGlvbl9hc3NpZ25tZW50ID0gZmFsc2U7XG4gICAgICB0aGlzLnByaW50X25ld2xpbmUoZmFsc2UsIHRydWUpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fb3B0aW9ucy5jb21tYV9maXJzdCkge1xuICAgICAgLy8gZm9yIGNvbW1hLWZpcnN0LCB3ZSB3YW50IHRvIGFsbG93IGEgbmV3bGluZSBiZWZvcmUgdGhlIGNvbW1hXG4gICAgICAvLyB0byB0dXJuIGludG8gYSBuZXdsaW5lIGFmdGVyIHRoZSBjb21tYSwgd2hpY2ggd2Ugd2lsbCBmaXh1cCBsYXRlclxuICAgICAgdGhpcy5hbGxvd193cmFwX29yX3ByZXNlcnZlZF9uZXdsaW5lKGN1cnJlbnRfdG9rZW4pO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0aGlzLl9mbGFncy5tb2RlID09PSBNT0RFLk9iamVjdExpdGVyYWwgfHxcbiAgICAodGhpcy5fZmxhZ3MubW9kZSA9PT0gTU9ERS5TdGF0ZW1lbnQgJiYgdGhpcy5fZmxhZ3MucGFyZW50Lm1vZGUgPT09IE1PREUuT2JqZWN0TGl0ZXJhbCkpIHtcbiAgICBpZiAodGhpcy5fZmxhZ3MubW9kZSA9PT0gTU9ERS5TdGF0ZW1lbnQpIHtcbiAgICAgIHRoaXMucmVzdG9yZV9tb2RlKCk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9mbGFncy5pbmxpbmVfZnJhbWUpIHtcbiAgICAgIHRoaXMucHJpbnRfbmV3bGluZSgpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0aGlzLl9vcHRpb25zLmNvbW1hX2ZpcnN0KSB7XG4gICAgLy8gRVhQUiBvciBET19CTE9DS1xuICAgIC8vIGZvciBjb21tYS1maXJzdCwgd2Ugd2FudCB0byBhbGxvdyBhIG5ld2xpbmUgYmVmb3JlIHRoZSBjb21tYVxuICAgIC8vIHRvIHR1cm4gaW50byBhIG5ld2xpbmUgYWZ0ZXIgdGhlIGNvbW1hLCB3aGljaCB3ZSB3aWxsIGZpeHVwIGxhdGVyXG4gICAgdGhpcy5hbGxvd193cmFwX29yX3ByZXNlcnZlZF9uZXdsaW5lKGN1cnJlbnRfdG9rZW4pO1xuICB9XG59O1xuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5oYW5kbGVfb3BlcmF0b3IgPSBmdW5jdGlvbihjdXJyZW50X3Rva2VuKSB7XG4gIHZhciBpc0dlbmVyYXRvckFzdGVyaXNrID0gY3VycmVudF90b2tlbi50ZXh0ID09PSAnKicgJiZcbiAgICAocmVzZXJ2ZWRfYXJyYXkodGhpcy5fZmxhZ3MubGFzdF90b2tlbiwgWydmdW5jdGlvbicsICd5aWVsZCddKSB8fFxuICAgICAgKGluX2FycmF5KHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSwgW1RPS0VOLlNUQVJUX0JMT0NLLCBUT0tFTi5DT01NQSwgVE9LRU4uRU5EX0JMT0NLLCBUT0tFTi5TRU1JQ09MT05dKSlcbiAgICApO1xuICB2YXIgaXNVbmFyeSA9IGluX2FycmF5KGN1cnJlbnRfdG9rZW4udGV4dCwgWyctJywgJysnXSkgJiYgKFxuICAgIGluX2FycmF5KHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSwgW1RPS0VOLlNUQVJUX0JMT0NLLCBUT0tFTi5TVEFSVF9FWFBSLCBUT0tFTi5FUVVBTFMsIFRPS0VOLk9QRVJBVE9SXSkgfHxcbiAgICBpbl9hcnJheSh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQsIGxpbmVfc3RhcnRlcnMpIHx8XG4gICAgdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0ID09PSAnLCdcbiAgKTtcblxuICBpZiAodGhpcy5zdGFydF9vZl9zdGF0ZW1lbnQoY3VycmVudF90b2tlbikpIHtcbiAgICAvLyBUaGUgY29uZGl0aW9uYWwgc3RhcnRzIHRoZSBzdGF0ZW1lbnQgaWYgYXBwcm9wcmlhdGUuXG4gIH0gZWxzZSB7XG4gICAgdmFyIHByZXNlcnZlX3N0YXRlbWVudF9mbGFncyA9ICFpc0dlbmVyYXRvckFzdGVyaXNrO1xuICAgIHRoaXMuaGFuZGxlX3doaXRlc3BhY2VfYW5kX2NvbW1lbnRzKGN1cnJlbnRfdG9rZW4sIHByZXNlcnZlX3N0YXRlbWVudF9mbGFncyk7XG4gIH1cblxuICBpZiAocmVzZXJ2ZWRfYXJyYXkodGhpcy5fZmxhZ3MubGFzdF90b2tlbiwgc3BlY2lhbF93b3JkcykpIHtcbiAgICAvLyBcInJldHVyblwiIGhhZCBhIHNwZWNpYWwgaGFuZGxpbmcgaW4gVEtfV09SRC4gTm93IHdlIG5lZWQgdG8gcmV0dXJuIHRoZSBmYXZvclxuICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgIHRoaXMucHJpbnRfdG9rZW4oY3VycmVudF90b2tlbik7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gaGFjayBmb3IgYWN0aW9uc2NyaXB0J3MgaW1wb3J0IC4qO1xuICBpZiAoY3VycmVudF90b2tlbi50ZXh0ID09PSAnKicgJiYgdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5ET1QpIHtcbiAgICB0aGlzLnByaW50X3Rva2VuKGN1cnJlbnRfdG9rZW4pO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChjdXJyZW50X3Rva2VuLnRleHQgPT09ICc6OicpIHtcbiAgICAvLyBubyBzcGFjZXMgYXJvdW5kIGV4b3RpYyBuYW1lc3BhY2luZyBzeW50YXggb3BlcmF0b3JcbiAgICB0aGlzLnByaW50X3Rva2VuKGN1cnJlbnRfdG9rZW4pO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEFsbG93IGxpbmUgd3JhcHBpbmcgYmV0d2VlbiBvcGVyYXRvcnMgd2hlbiBvcGVyYXRvcl9wb3NpdGlvbiBpc1xuICAvLyAgIHNldCB0byBiZWZvcmUgb3IgcHJlc2VydmVcbiAgaWYgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uT1BFUkFUT1IgJiYgaW5fYXJyYXkodGhpcy5fb3B0aW9ucy5vcGVyYXRvcl9wb3NpdGlvbiwgT1BFUkFUT1JfUE9TSVRJT05fQkVGT1JFX09SX1BSRVNFUlZFKSkge1xuICAgIHRoaXMuYWxsb3dfd3JhcF9vcl9wcmVzZXJ2ZWRfbmV3bGluZShjdXJyZW50X3Rva2VuKTtcbiAgfVxuXG4gIGlmIChjdXJyZW50X3Rva2VuLnRleHQgPT09ICc6JyAmJiB0aGlzLl9mbGFncy5pbl9jYXNlKSB7XG4gICAgdGhpcy5wcmludF90b2tlbihjdXJyZW50X3Rva2VuKTtcblxuICAgIHRoaXMuX2ZsYWdzLmluX2Nhc2UgPSBmYWxzZTtcbiAgICB0aGlzLl9mbGFncy5jYXNlX2JvZHkgPSB0cnVlO1xuICAgIGlmICh0aGlzLl90b2tlbnMucGVlaygpLnR5cGUgIT09IFRPS0VOLlNUQVJUX0JMT0NLKSB7XG4gICAgICB0aGlzLmluZGVudCgpO1xuICAgICAgdGhpcy5wcmludF9uZXdsaW5lKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgc3BhY2VfYmVmb3JlID0gdHJ1ZTtcbiAgdmFyIHNwYWNlX2FmdGVyID0gdHJ1ZTtcbiAgdmFyIGluX3Rlcm5hcnkgPSBmYWxzZTtcbiAgaWYgKGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJzonKSB7XG4gICAgaWYgKHRoaXMuX2ZsYWdzLnRlcm5hcnlfZGVwdGggPT09IDApIHtcbiAgICAgIC8vIENvbG9uIGlzIGludmFsaWQgamF2YXNjcmlwdCBvdXRzaWRlIG9mIHRlcm5hcnkgYW5kIG9iamVjdCwgYnV0IGRvIG91ciBiZXN0IHRvIGd1ZXNzIHdoYXQgd2FzIG1lYW50LlxuICAgICAgc3BhY2VfYmVmb3JlID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2ZsYWdzLnRlcm5hcnlfZGVwdGggLT0gMTtcbiAgICAgIGluX3Rlcm5hcnkgPSB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChjdXJyZW50X3Rva2VuLnRleHQgPT09ICc/Jykge1xuICAgIHRoaXMuX2ZsYWdzLnRlcm5hcnlfZGVwdGggKz0gMTtcbiAgfVxuXG4gIC8vIGxldCdzIGhhbmRsZSB0aGUgb3BlcmF0b3JfcG9zaXRpb24gb3B0aW9uIHByaW9yIHRvIGFueSBjb25mbGljdGluZyBsb2dpY1xuICBpZiAoIWlzVW5hcnkgJiYgIWlzR2VuZXJhdG9yQXN0ZXJpc2sgJiYgdGhpcy5fb3B0aW9ucy5wcmVzZXJ2ZV9uZXdsaW5lcyAmJiBpbl9hcnJheShjdXJyZW50X3Rva2VuLnRleHQsIHBvc2l0aW9uYWJsZV9vcGVyYXRvcnMpKSB7XG4gICAgdmFyIGlzQ29sb24gPSBjdXJyZW50X3Rva2VuLnRleHQgPT09ICc6JztcbiAgICB2YXIgaXNUZXJuYXJ5Q29sb24gPSAoaXNDb2xvbiAmJiBpbl90ZXJuYXJ5KTtcbiAgICB2YXIgaXNPdGhlckNvbG9uID0gKGlzQ29sb24gJiYgIWluX3Rlcm5hcnkpO1xuXG4gICAgc3dpdGNoICh0aGlzLl9vcHRpb25zLm9wZXJhdG9yX3Bvc2l0aW9uKSB7XG4gICAgICBjYXNlIE9QRVJBVE9SX1BPU0lUSU9OLmJlZm9yZV9uZXdsaW5lOlxuICAgICAgICAvLyBpZiB0aGUgY3VycmVudCB0b2tlbiBpcyA6IGFuZCBpdCdzIG5vdCBhIHRlcm5hcnkgc3RhdGVtZW50IHRoZW4gd2Ugc2V0IHNwYWNlX2JlZm9yZSB0byBmYWxzZVxuICAgICAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gIWlzT3RoZXJDb2xvbjtcblxuICAgICAgICB0aGlzLnByaW50X3Rva2VuKGN1cnJlbnRfdG9rZW4pO1xuXG4gICAgICAgIGlmICghaXNDb2xvbiB8fCBpc1Rlcm5hcnlDb2xvbikge1xuICAgICAgICAgIHRoaXMuYWxsb3dfd3JhcF9vcl9wcmVzZXJ2ZWRfbmV3bGluZShjdXJyZW50X3Rva2VuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgICByZXR1cm47XG5cbiAgICAgIGNhc2UgT1BFUkFUT1JfUE9TSVRJT04uYWZ0ZXJfbmV3bGluZTpcbiAgICAgICAgLy8gaWYgdGhlIGN1cnJlbnQgdG9rZW4gaXMgYW55dGhpbmcgYnV0IGNvbG9uLCBvciAodmlhIGRlZHVjdGlvbikgaXQncyBhIGNvbG9uIGFuZCBpbiBhIHRlcm5hcnkgc3RhdGVtZW50LFxuICAgICAgICAvLyAgIHRoZW4gcHJpbnQgYSBuZXdsaW5lLlxuXG4gICAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuXG4gICAgICAgIGlmICghaXNDb2xvbiB8fCBpc1Rlcm5hcnlDb2xvbikge1xuICAgICAgICAgIGlmICh0aGlzLl90b2tlbnMucGVlaygpLm5ld2xpbmVzKSB7XG4gICAgICAgICAgICB0aGlzLnByaW50X25ld2xpbmUoZmFsc2UsIHRydWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmFsbG93X3dyYXBfb3JfcHJlc2VydmVkX25ld2xpbmUoY3VycmVudF90b2tlbik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucHJpbnRfdG9rZW4oY3VycmVudF90b2tlbik7XG5cbiAgICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICAgIHJldHVybjtcblxuICAgICAgY2FzZSBPUEVSQVRPUl9QT1NJVElPTi5wcmVzZXJ2ZV9uZXdsaW5lOlxuICAgICAgICBpZiAoIWlzT3RoZXJDb2xvbikge1xuICAgICAgICAgIHRoaXMuYWxsb3dfd3JhcF9vcl9wcmVzZXJ2ZWRfbmV3bGluZShjdXJyZW50X3Rva2VuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHdlIGp1c3QgYWRkZWQgYSBuZXdsaW5lLCBvciB0aGUgY3VycmVudCB0b2tlbiBpcyA6IGFuZCBpdCdzIG5vdCBhIHRlcm5hcnkgc3RhdGVtZW50LFxuICAgICAgICAvLyAgIHRoZW4gd2Ugc2V0IHNwYWNlX2JlZm9yZSB0byBmYWxzZVxuICAgICAgICBzcGFjZV9iZWZvcmUgPSAhKHRoaXMuX291dHB1dC5qdXN0X2FkZGVkX25ld2xpbmUoKSB8fCBpc090aGVyQ29sb24pO1xuXG4gICAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSBzcGFjZV9iZWZvcmU7XG4gICAgICAgIHRoaXMucHJpbnRfdG9rZW4oY3VycmVudF90b2tlbik7XG4gICAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgaWYgKGlzR2VuZXJhdG9yQXN0ZXJpc2spIHtcbiAgICB0aGlzLmFsbG93X3dyYXBfb3JfcHJlc2VydmVkX25ld2xpbmUoY3VycmVudF90b2tlbik7XG4gICAgc3BhY2VfYmVmb3JlID0gZmFsc2U7XG4gICAgdmFyIG5leHRfdG9rZW4gPSB0aGlzLl90b2tlbnMucGVlaygpO1xuICAgIHNwYWNlX2FmdGVyID0gbmV4dF90b2tlbiAmJiBpbl9hcnJheShuZXh0X3Rva2VuLnR5cGUsIFtUT0tFTi5XT1JELCBUT0tFTi5SRVNFUlZFRF0pO1xuICB9IGVsc2UgaWYgKGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJy4uLicpIHtcbiAgICB0aGlzLmFsbG93X3dyYXBfb3JfcHJlc2VydmVkX25ld2xpbmUoY3VycmVudF90b2tlbik7XG4gICAgc3BhY2VfYmVmb3JlID0gdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5TVEFSVF9CTE9DSztcbiAgICBzcGFjZV9hZnRlciA9IGZhbHNlO1xuICB9IGVsc2UgaWYgKGluX2FycmF5KGN1cnJlbnRfdG9rZW4udGV4dCwgWyctLScsICcrKycsICchJywgJ34nXSkgfHwgaXNVbmFyeSkge1xuICAgIC8vIHVuYXJ5IG9wZXJhdG9ycyAoYW5kIGJpbmFyeSArLy0gcHJldGVuZGluZyB0byBiZSB1bmFyeSkgc3BlY2lhbCBjYXNlc1xuICAgIGlmICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLkNPTU1BIHx8IHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uU1RBUlRfRVhQUikge1xuICAgICAgdGhpcy5hbGxvd193cmFwX29yX3ByZXNlcnZlZF9uZXdsaW5lKGN1cnJlbnRfdG9rZW4pO1xuICAgIH1cblxuICAgIHNwYWNlX2JlZm9yZSA9IGZhbHNlO1xuICAgIHNwYWNlX2FmdGVyID0gZmFsc2U7XG5cbiAgICAvLyBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNS4xLyNzZWMtNy45LjFcbiAgICAvLyBpZiB0aGVyZSBpcyBhIG5ld2xpbmUgYmV0d2VlbiAtLSBvciArKyBhbmQgYW55dGhpbmcgZWxzZSB3ZSBzaG91bGQgcHJlc2VydmUgaXQuXG4gICAgaWYgKGN1cnJlbnRfdG9rZW4ubmV3bGluZXMgJiYgKGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJy0tJyB8fCBjdXJyZW50X3Rva2VuLnRleHQgPT09ICcrKycpKSB7XG4gICAgICB0aGlzLnByaW50X25ld2xpbmUoZmFsc2UsIHRydWUpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQgPT09ICc7JyAmJiBpc19leHByZXNzaW9uKHRoaXMuX2ZsYWdzLm1vZGUpKSB7XG4gICAgICAvLyBmb3IgKDs7ICsraSlcbiAgICAgIC8vICAgICAgICBeXl5cbiAgICAgIHNwYWNlX2JlZm9yZSA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uUkVTRVJWRUQpIHtcbiAgICAgIHNwYWNlX2JlZm9yZSA9IHRydWU7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLkVORF9FWFBSKSB7XG4gICAgICBzcGFjZV9iZWZvcmUgPSAhKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udGV4dCA9PT0gJ10nICYmIChjdXJyZW50X3Rva2VuLnRleHQgPT09ICctLScgfHwgY3VycmVudF90b2tlbi50ZXh0ID09PSAnKysnKSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLk9QRVJBVE9SKSB7XG4gICAgICAvLyBhKysgKyArK2I7XG4gICAgICAvLyBhIC0gLWJcbiAgICAgIHNwYWNlX2JlZm9yZSA9IGluX2FycmF5KGN1cnJlbnRfdG9rZW4udGV4dCwgWyctLScsICctJywgJysrJywgJysnXSkgJiYgaW5fYXJyYXkodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0LCBbJy0tJywgJy0nLCAnKysnLCAnKyddKTtcbiAgICAgIC8vICsgYW5kIC0gYXJlIG5vdCB1bmFyeSB3aGVuIHByZWNlZWRlZCBieSAtLSBvciArKyBvcGVyYXRvclxuICAgICAgLy8gYS0tICsgYlxuICAgICAgLy8gYSAqICtiXG4gICAgICAvLyBhIC0gLWJcbiAgICAgIGlmIChpbl9hcnJheShjdXJyZW50X3Rva2VuLnRleHQsIFsnKycsICctJ10pICYmIGluX2FycmF5KHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udGV4dCwgWyctLScsICcrKyddKSkge1xuICAgICAgICBzcGFjZV9hZnRlciA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG5cbiAgICBpZiAoKCh0aGlzLl9mbGFncy5tb2RlID09PSBNT0RFLkJsb2NrU3RhdGVtZW50ICYmICF0aGlzLl9mbGFncy5pbmxpbmVfZnJhbWUpIHx8IHRoaXMuX2ZsYWdzLm1vZGUgPT09IE1PREUuU3RhdGVtZW50KSAmJlxuICAgICAgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udGV4dCA9PT0gJ3snIHx8IHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udGV4dCA9PT0gJzsnKSkge1xuICAgICAgLy8geyBmb287IC0taSB9XG4gICAgICAvLyBmb28oKTsgLS1iYXI7XG4gICAgICB0aGlzLnByaW50X25ld2xpbmUoKTtcbiAgICB9XG4gIH1cblxuICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiB8fCBzcGFjZV9iZWZvcmU7XG4gIHRoaXMucHJpbnRfdG9rZW4oY3VycmVudF90b2tlbik7XG4gIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSBzcGFjZV9hZnRlcjtcbn07XG5cbkJlYXV0aWZpZXIucHJvdG90eXBlLmhhbmRsZV9ibG9ja19jb21tZW50ID0gZnVuY3Rpb24oY3VycmVudF90b2tlbiwgcHJlc2VydmVfc3RhdGVtZW50X2ZsYWdzKSB7XG4gIGlmICh0aGlzLl9vdXRwdXQucmF3KSB7XG4gICAgdGhpcy5fb3V0cHV0LmFkZF9yYXdfdG9rZW4oY3VycmVudF90b2tlbik7XG4gICAgaWYgKGN1cnJlbnRfdG9rZW4uZGlyZWN0aXZlcyAmJiBjdXJyZW50X3Rva2VuLmRpcmVjdGl2ZXMucHJlc2VydmUgPT09ICdlbmQnKSB7XG4gICAgICAvLyBJZiB3ZSdyZSB0ZXN0aW5nIHRoZSByYXcgb3V0cHV0IGJlaGF2aW9yLCBkbyBub3QgYWxsb3cgYSBkaXJlY3RpdmUgdG8gdHVybiBpdCBvZmYuXG4gICAgICB0aGlzLl9vdXRwdXQucmF3ID0gdGhpcy5fb3B0aW9ucy50ZXN0X291dHB1dF9yYXc7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChjdXJyZW50X3Rva2VuLmRpcmVjdGl2ZXMpIHtcbiAgICB0aGlzLnByaW50X25ld2xpbmUoZmFsc2UsIHByZXNlcnZlX3N0YXRlbWVudF9mbGFncyk7XG4gICAgdGhpcy5wcmludF90b2tlbihjdXJyZW50X3Rva2VuKTtcbiAgICBpZiAoY3VycmVudF90b2tlbi5kaXJlY3RpdmVzLnByZXNlcnZlID09PSAnc3RhcnQnKSB7XG4gICAgICB0aGlzLl9vdXRwdXQucmF3ID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5wcmludF9uZXdsaW5lKGZhbHNlLCB0cnVlKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBpbmxpbmUgYmxvY2tcbiAgaWYgKCFhY29ybi5uZXdsaW5lLnRlc3QoY3VycmVudF90b2tlbi50ZXh0KSAmJiAhY3VycmVudF90b2tlbi5uZXdsaW5lcykge1xuICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgIHRoaXMucHJpbnRfdG9rZW4oY3VycmVudF90b2tlbik7XG4gICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgcmV0dXJuO1xuICB9IGVsc2Uge1xuICAgIHRoaXMucHJpbnRfYmxvY2tfY29tbW1lbnQoY3VycmVudF90b2tlbiwgcHJlc2VydmVfc3RhdGVtZW50X2ZsYWdzKTtcbiAgfVxufTtcblxuQmVhdXRpZmllci5wcm90b3R5cGUucHJpbnRfYmxvY2tfY29tbW1lbnQgPSBmdW5jdGlvbihjdXJyZW50X3Rva2VuLCBwcmVzZXJ2ZV9zdGF0ZW1lbnRfZmxhZ3MpIHtcbiAgdmFyIGxpbmVzID0gc3BsaXRfbGluZWJyZWFrcyhjdXJyZW50X3Rva2VuLnRleHQpO1xuICB2YXIgajsgLy8gaXRlcmF0b3IgZm9yIHRoaXMgY2FzZVxuICB2YXIgamF2YWRvYyA9IGZhbHNlO1xuICB2YXIgc3Rhcmxlc3MgPSBmYWxzZTtcbiAgdmFyIGxhc3RJbmRlbnQgPSBjdXJyZW50X3Rva2VuLndoaXRlc3BhY2VfYmVmb3JlO1xuICB2YXIgbGFzdEluZGVudExlbmd0aCA9IGxhc3RJbmRlbnQubGVuZ3RoO1xuXG4gIC8vIGJsb2NrIGNvbW1lbnQgc3RhcnRzIHdpdGggYSBuZXcgbGluZVxuICB0aGlzLnByaW50X25ld2xpbmUoZmFsc2UsIHByZXNlcnZlX3N0YXRlbWVudF9mbGFncyk7XG5cbiAgLy8gZmlyc3QgbGluZSBhbHdheXMgaW5kZW50ZWRcbiAgdGhpcy5wcmludF90b2tlbl9saW5lX2luZGVudGF0aW9uKGN1cnJlbnRfdG9rZW4pO1xuICB0aGlzLl9vdXRwdXQuYWRkX3Rva2VuKGxpbmVzWzBdKTtcbiAgdGhpcy5wcmludF9uZXdsaW5lKGZhbHNlLCBwcmVzZXJ2ZV9zdGF0ZW1lbnRfZmxhZ3MpO1xuXG5cbiAgaWYgKGxpbmVzLmxlbmd0aCA+IDEpIHtcbiAgICBsaW5lcyA9IGxpbmVzLnNsaWNlKDEpO1xuICAgIGphdmFkb2MgPSBhbGxfbGluZXNfc3RhcnRfd2l0aChsaW5lcywgJyonKTtcbiAgICBzdGFybGVzcyA9IGVhY2hfbGluZV9tYXRjaGVzX2luZGVudChsaW5lcywgbGFzdEluZGVudCk7XG5cbiAgICBpZiAoamF2YWRvYykge1xuICAgICAgdGhpcy5fZmxhZ3MuYWxpZ25tZW50ID0gMTtcbiAgICB9XG5cbiAgICBmb3IgKGogPSAwOyBqIDwgbGluZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgIGlmIChqYXZhZG9jKSB7XG4gICAgICAgIC8vIGphdmFkb2M6IHJlZm9ybWF0IGFuZCByZS1pbmRlbnRcbiAgICAgICAgdGhpcy5wcmludF90b2tlbl9saW5lX2luZGVudGF0aW9uKGN1cnJlbnRfdG9rZW4pO1xuICAgICAgICB0aGlzLl9vdXRwdXQuYWRkX3Rva2VuKGx0cmltKGxpbmVzW2pdKSk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXJsZXNzICYmIGxpbmVzW2pdKSB7XG4gICAgICAgIC8vIHN0YXJsZXNzOiByZS1pbmRlbnQgbm9uLWVtcHR5IGNvbnRlbnQsIGF2b2lkaW5nIHRyaW1cbiAgICAgICAgdGhpcy5wcmludF90b2tlbl9saW5lX2luZGVudGF0aW9uKGN1cnJlbnRfdG9rZW4pO1xuICAgICAgICB0aGlzLl9vdXRwdXQuYWRkX3Rva2VuKGxpbmVzW2pdLnN1YnN0cmluZyhsYXN0SW5kZW50TGVuZ3RoKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBub3JtYWwgY29tbWVudHMgb3V0cHV0IHJhd1xuICAgICAgICB0aGlzLl9vdXRwdXQuY3VycmVudF9saW5lLnNldF9pbmRlbnQoLTEpO1xuICAgICAgICB0aGlzLl9vdXRwdXQuYWRkX3Rva2VuKGxpbmVzW2pdKTtcbiAgICAgIH1cblxuICAgICAgLy8gZm9yIGNvbW1lbnRzIG9uIHRoZWlyIG93biBsaW5lIG9yICBtb3JlIHRoYW4gb25lIGxpbmUsIG1ha2Ugc3VyZSB0aGVyZSdzIGEgbmV3IGxpbmUgYWZ0ZXJcbiAgICAgIHRoaXMucHJpbnRfbmV3bGluZShmYWxzZSwgcHJlc2VydmVfc3RhdGVtZW50X2ZsYWdzKTtcbiAgICB9XG5cbiAgICB0aGlzLl9mbGFncy5hbGlnbm1lbnQgPSAwO1xuICB9XG59O1xuXG5cbkJlYXV0aWZpZXIucHJvdG90eXBlLmhhbmRsZV9jb21tZW50ID0gZnVuY3Rpb24oY3VycmVudF90b2tlbiwgcHJlc2VydmVfc3RhdGVtZW50X2ZsYWdzKSB7XG4gIGlmIChjdXJyZW50X3Rva2VuLm5ld2xpbmVzKSB7XG4gICAgdGhpcy5wcmludF9uZXdsaW5lKGZhbHNlLCBwcmVzZXJ2ZV9zdGF0ZW1lbnRfZmxhZ3MpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX291dHB1dC50cmltKHRydWUpO1xuICB9XG5cbiAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gIHRoaXMucHJpbnRfdG9rZW4oY3VycmVudF90b2tlbik7XG4gIHRoaXMucHJpbnRfbmV3bGluZShmYWxzZSwgcHJlc2VydmVfc3RhdGVtZW50X2ZsYWdzKTtcbn07XG5cbkJlYXV0aWZpZXIucHJvdG90eXBlLmhhbmRsZV9kb3QgPSBmdW5jdGlvbihjdXJyZW50X3Rva2VuKSB7XG4gIGlmICh0aGlzLnN0YXJ0X29mX3N0YXRlbWVudChjdXJyZW50X3Rva2VuKSkge1xuICAgIC8vIFRoZSBjb25kaXRpb25hbCBzdGFydHMgdGhlIHN0YXRlbWVudCBpZiBhcHByb3ByaWF0ZS5cbiAgfSBlbHNlIHtcbiAgICB0aGlzLmhhbmRsZV93aGl0ZXNwYWNlX2FuZF9jb21tZW50cyhjdXJyZW50X3Rva2VuLCB0cnVlKTtcbiAgfVxuXG4gIGlmIChyZXNlcnZlZF9hcnJheSh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLCBzcGVjaWFsX3dvcmRzKSkge1xuICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBhbGxvdyBwcmVzZXJ2ZWQgbmV3bGluZXMgYmVmb3JlIGRvdHMgaW4gZ2VuZXJhbFxuICAgIC8vIGZvcmNlIG5ld2xpbmVzIG9uIGRvdHMgYWZ0ZXIgY2xvc2UgcGFyZW4gd2hlbiBicmVha19jaGFpbmVkIC0gZm9yIGJhcigpLmJheigpXG4gICAgdGhpcy5hbGxvd193cmFwX29yX3ByZXNlcnZlZF9uZXdsaW5lKGN1cnJlbnRfdG9rZW4sXG4gICAgICB0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQgPT09ICcpJyAmJiB0aGlzLl9vcHRpb25zLmJyZWFrX2NoYWluZWRfbWV0aG9kcyk7XG4gIH1cblxuICAvLyBPbmx5IHVuaW5kZW50IGNoYWluZWQgbWV0aG9kIGRvdCBpZiB0aGlzIGRvdCBzdGFydHMgYSBuZXcgbGluZS5cbiAgLy8gT3RoZXJ3aXNlIHRoZSBhdXRvbWF0aWMgZXh0cmEgaW5kZW50YXRpb24gcmVtb3ZhbCB3aWxsIGhhbmRsZSB0aGUgb3ZlciBpbmRlbnRcbiAgaWYgKHRoaXMuX29wdGlvbnMudW5pbmRlbnRfY2hhaW5lZF9tZXRob2RzICYmIHRoaXMuX291dHB1dC5qdXN0X2FkZGVkX25ld2xpbmUoKSkge1xuICAgIHRoaXMuZGVpbmRlbnQoKTtcbiAgfVxuXG4gIHRoaXMucHJpbnRfdG9rZW4oY3VycmVudF90b2tlbik7XG59O1xuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5oYW5kbGVfdW5rbm93biA9IGZ1bmN0aW9uKGN1cnJlbnRfdG9rZW4sIHByZXNlcnZlX3N0YXRlbWVudF9mbGFncykge1xuICB0aGlzLnByaW50X3Rva2VuKGN1cnJlbnRfdG9rZW4pO1xuXG4gIGlmIChjdXJyZW50X3Rva2VuLnRleHRbY3VycmVudF90b2tlbi50ZXh0Lmxlbmd0aCAtIDFdID09PSAnXFxuJykge1xuICAgIHRoaXMucHJpbnRfbmV3bGluZShmYWxzZSwgcHJlc2VydmVfc3RhdGVtZW50X2ZsYWdzKTtcbiAgfVxufTtcblxuQmVhdXRpZmllci5wcm90b3R5cGUuaGFuZGxlX2VvZiA9IGZ1bmN0aW9uKGN1cnJlbnRfdG9rZW4pIHtcbiAgLy8gVW53aW5kIGFueSBvcGVuIHN0YXRlbWVudHNcbiAgd2hpbGUgKHRoaXMuX2ZsYWdzLm1vZGUgPT09IE1PREUuU3RhdGVtZW50KSB7XG4gICAgdGhpcy5yZXN0b3JlX21vZGUoKTtcbiAgfVxuICB0aGlzLmhhbmRsZV93aGl0ZXNwYWNlX2FuZF9jb21tZW50cyhjdXJyZW50X3Rva2VuKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzLkJlYXV0aWZpZXIgPSBCZWF1dGlmaWVyO1xuXG5cbi8qKiovIH0pLFxuLyogMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qanNoaW50IG5vZGU6dHJ1ZSAqL1xuLypcbiAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiAgQ29weXJpZ2h0IChjKSAyMDA3LTIwMTggRWluYXIgTGllbG1hbmlzLCBMaWFtIE5ld21hbiwgYW5kIGNvbnRyaWJ1dG9ycy5cblxuICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gIFNPRlRXQVJFLlxuKi9cblxuXG5cbmZ1bmN0aW9uIE91dHB1dExpbmUocGFyZW50KSB7XG4gIHRoaXMuX19wYXJlbnQgPSBwYXJlbnQ7XG4gIHRoaXMuX19jaGFyYWN0ZXJfY291bnQgPSAwO1xuICAvLyB1c2UgaW5kZW50X2NvdW50IGFzIGEgbWFya2VyIGZvciB0aGlzLl9fbGluZXMgdGhhdCBoYXZlIHByZXNlcnZlZCBpbmRlbnRhdGlvblxuICB0aGlzLl9faW5kZW50X2NvdW50ID0gLTE7XG4gIHRoaXMuX19hbGlnbm1lbnRfY291bnQgPSAwO1xuICB0aGlzLl9fd3JhcF9wb2ludF9pbmRleCA9IDA7XG4gIHRoaXMuX193cmFwX3BvaW50X2NoYXJhY3Rlcl9jb3VudCA9IDA7XG4gIHRoaXMuX193cmFwX3BvaW50X2luZGVudF9jb3VudCA9IC0xO1xuICB0aGlzLl9fd3JhcF9wb2ludF9hbGlnbm1lbnRfY291bnQgPSAwO1xuXG4gIHRoaXMuX19pdGVtcyA9IFtdO1xufVxuXG5PdXRwdXRMaW5lLnByb3RvdHlwZS5jbG9uZV9lbXB0eSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbGluZSA9IG5ldyBPdXRwdXRMaW5lKHRoaXMuX19wYXJlbnQpO1xuICBsaW5lLnNldF9pbmRlbnQodGhpcy5fX2luZGVudF9jb3VudCwgdGhpcy5fX2FsaWdubWVudF9jb3VudCk7XG4gIHJldHVybiBsaW5lO1xufTtcblxuT3V0cHV0TGluZS5wcm90b3R5cGUuaXRlbSA9IGZ1bmN0aW9uKGluZGV4KSB7XG4gIGlmIChpbmRleCA8IDApIHtcbiAgICByZXR1cm4gdGhpcy5fX2l0ZW1zW3RoaXMuX19pdGVtcy5sZW5ndGggKyBpbmRleF07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRoaXMuX19pdGVtc1tpbmRleF07XG4gIH1cbn07XG5cbk91dHB1dExpbmUucHJvdG90eXBlLmhhc19tYXRjaCA9IGZ1bmN0aW9uKHBhdHRlcm4pIHtcbiAgZm9yICh2YXIgbGFzdENoZWNrZWRPdXRwdXQgPSB0aGlzLl9faXRlbXMubGVuZ3RoIC0gMTsgbGFzdENoZWNrZWRPdXRwdXQgPj0gMDsgbGFzdENoZWNrZWRPdXRwdXQtLSkge1xuICAgIGlmICh0aGlzLl9faXRlbXNbbGFzdENoZWNrZWRPdXRwdXRdLm1hdGNoKHBhdHRlcm4pKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuT3V0cHV0TGluZS5wcm90b3R5cGUuc2V0X2luZGVudCA9IGZ1bmN0aW9uKGluZGVudCwgYWxpZ25tZW50KSB7XG4gIGlmICh0aGlzLmlzX2VtcHR5KCkpIHtcbiAgICB0aGlzLl9faW5kZW50X2NvdW50ID0gaW5kZW50IHx8IDA7XG4gICAgdGhpcy5fX2FsaWdubWVudF9jb3VudCA9IGFsaWdubWVudCB8fCAwO1xuICAgIHRoaXMuX19jaGFyYWN0ZXJfY291bnQgPSB0aGlzLl9fcGFyZW50LmdldF9pbmRlbnRfc2l6ZSh0aGlzLl9faW5kZW50X2NvdW50LCB0aGlzLl9fYWxpZ25tZW50X2NvdW50KTtcbiAgfVxufTtcblxuT3V0cHV0TGluZS5wcm90b3R5cGUuX3NldF93cmFwX3BvaW50ID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLl9fcGFyZW50LndyYXBfbGluZV9sZW5ndGgpIHtcbiAgICB0aGlzLl9fd3JhcF9wb2ludF9pbmRleCA9IHRoaXMuX19pdGVtcy5sZW5ndGg7XG4gICAgdGhpcy5fX3dyYXBfcG9pbnRfY2hhcmFjdGVyX2NvdW50ID0gdGhpcy5fX2NoYXJhY3Rlcl9jb3VudDtcbiAgICB0aGlzLl9fd3JhcF9wb2ludF9pbmRlbnRfY291bnQgPSB0aGlzLl9fcGFyZW50Lm5leHRfbGluZS5fX2luZGVudF9jb3VudDtcbiAgICB0aGlzLl9fd3JhcF9wb2ludF9hbGlnbm1lbnRfY291bnQgPSB0aGlzLl9fcGFyZW50Lm5leHRfbGluZS5fX2FsaWdubWVudF9jb3VudDtcbiAgfVxufTtcblxuT3V0cHV0TGluZS5wcm90b3R5cGUuX3Nob3VsZF93cmFwID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9fd3JhcF9wb2ludF9pbmRleCAmJlxuICAgIHRoaXMuX19jaGFyYWN0ZXJfY291bnQgPiB0aGlzLl9fcGFyZW50LndyYXBfbGluZV9sZW5ndGggJiZcbiAgICB0aGlzLl9fd3JhcF9wb2ludF9jaGFyYWN0ZXJfY291bnQgPiB0aGlzLl9fcGFyZW50Lm5leHRfbGluZS5fX2NoYXJhY3Rlcl9jb3VudDtcbn07XG5cbk91dHB1dExpbmUucHJvdG90eXBlLl9hbGxvd193cmFwID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLl9zaG91bGRfd3JhcCgpKSB7XG4gICAgdGhpcy5fX3BhcmVudC5hZGRfbmV3X2xpbmUoKTtcbiAgICB2YXIgbmV4dCA9IHRoaXMuX19wYXJlbnQuY3VycmVudF9saW5lO1xuICAgIG5leHQuc2V0X2luZGVudCh0aGlzLl9fd3JhcF9wb2ludF9pbmRlbnRfY291bnQsIHRoaXMuX193cmFwX3BvaW50X2FsaWdubWVudF9jb3VudCk7XG4gICAgbmV4dC5fX2l0ZW1zID0gdGhpcy5fX2l0ZW1zLnNsaWNlKHRoaXMuX193cmFwX3BvaW50X2luZGV4KTtcbiAgICB0aGlzLl9faXRlbXMgPSB0aGlzLl9faXRlbXMuc2xpY2UoMCwgdGhpcy5fX3dyYXBfcG9pbnRfaW5kZXgpO1xuXG4gICAgbmV4dC5fX2NoYXJhY3Rlcl9jb3VudCArPSB0aGlzLl9fY2hhcmFjdGVyX2NvdW50IC0gdGhpcy5fX3dyYXBfcG9pbnRfY2hhcmFjdGVyX2NvdW50O1xuICAgIHRoaXMuX19jaGFyYWN0ZXJfY291bnQgPSB0aGlzLl9fd3JhcF9wb2ludF9jaGFyYWN0ZXJfY291bnQ7XG5cbiAgICBpZiAobmV4dC5fX2l0ZW1zWzBdID09PSBcIiBcIikge1xuICAgICAgbmV4dC5fX2l0ZW1zLnNwbGljZSgwLCAxKTtcbiAgICAgIG5leHQuX19jaGFyYWN0ZXJfY291bnQgLT0gMTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuT3V0cHV0TGluZS5wcm90b3R5cGUuaXNfZW1wdHkgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX19pdGVtcy5sZW5ndGggPT09IDA7XG59O1xuXG5PdXRwdXRMaW5lLnByb3RvdHlwZS5sYXN0ID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5pc19lbXB0eSgpKSB7XG4gICAgcmV0dXJuIHRoaXMuX19pdGVtc1t0aGlzLl9faXRlbXMubGVuZ3RoIC0gMV07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn07XG5cbk91dHB1dExpbmUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbihpdGVtKSB7XG4gIHRoaXMuX19pdGVtcy5wdXNoKGl0ZW0pO1xuICB2YXIgbGFzdF9uZXdsaW5lX2luZGV4ID0gaXRlbS5sYXN0SW5kZXhPZignXFxuJyk7XG4gIGlmIChsYXN0X25ld2xpbmVfaW5kZXggIT09IC0xKSB7XG4gICAgdGhpcy5fX2NoYXJhY3Rlcl9jb3VudCA9IGl0ZW0ubGVuZ3RoIC0gbGFzdF9uZXdsaW5lX2luZGV4O1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX19jaGFyYWN0ZXJfY291bnQgKz0gaXRlbS5sZW5ndGg7XG4gIH1cbn07XG5cbk91dHB1dExpbmUucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaXRlbSA9IG51bGw7XG4gIGlmICghdGhpcy5pc19lbXB0eSgpKSB7XG4gICAgaXRlbSA9IHRoaXMuX19pdGVtcy5wb3AoKTtcbiAgICB0aGlzLl9fY2hhcmFjdGVyX2NvdW50IC09IGl0ZW0ubGVuZ3RoO1xuICB9XG4gIHJldHVybiBpdGVtO1xufTtcblxuXG5PdXRwdXRMaW5lLnByb3RvdHlwZS5fcmVtb3ZlX2luZGVudCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5fX2luZGVudF9jb3VudCA+IDApIHtcbiAgICB0aGlzLl9faW5kZW50X2NvdW50IC09IDE7XG4gICAgdGhpcy5fX2NoYXJhY3Rlcl9jb3VudCAtPSB0aGlzLl9fcGFyZW50LmluZGVudF9zaXplO1xuICB9XG59O1xuXG5PdXRwdXRMaW5lLnByb3RvdHlwZS5fcmVtb3ZlX3dyYXBfaW5kZW50ID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLl9fd3JhcF9wb2ludF9pbmRlbnRfY291bnQgPiAwKSB7XG4gICAgdGhpcy5fX3dyYXBfcG9pbnRfaW5kZW50X2NvdW50IC09IDE7XG4gIH1cbn07XG5PdXRwdXRMaW5lLnByb3RvdHlwZS50cmltID0gZnVuY3Rpb24oKSB7XG4gIHdoaWxlICh0aGlzLmxhc3QoKSA9PT0gJyAnKSB7XG4gICAgdGhpcy5fX2l0ZW1zLnBvcCgpO1xuICAgIHRoaXMuX19jaGFyYWN0ZXJfY291bnQgLT0gMTtcbiAgfVxufTtcblxuT3V0cHV0TGluZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJlc3VsdCA9ICcnO1xuICBpZiAodGhpcy5pc19lbXB0eSgpKSB7XG4gICAgaWYgKHRoaXMuX19wYXJlbnQuaW5kZW50X2VtcHR5X2xpbmVzKSB7XG4gICAgICByZXN1bHQgPSB0aGlzLl9fcGFyZW50LmdldF9pbmRlbnRfc3RyaW5nKHRoaXMuX19pbmRlbnRfY291bnQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgPSB0aGlzLl9fcGFyZW50LmdldF9pbmRlbnRfc3RyaW5nKHRoaXMuX19pbmRlbnRfY291bnQsIHRoaXMuX19hbGlnbm1lbnRfY291bnQpO1xuICAgIHJlc3VsdCArPSB0aGlzLl9faXRlbXMuam9pbignJyk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmZ1bmN0aW9uIEluZGVudFN0cmluZ0NhY2hlKG9wdGlvbnMsIGJhc2VJbmRlbnRTdHJpbmcpIHtcbiAgdGhpcy5fX2NhY2hlID0gWycnXTtcbiAgdGhpcy5fX2luZGVudF9zaXplID0gb3B0aW9ucy5pbmRlbnRfc2l6ZTtcbiAgdGhpcy5fX2luZGVudF9zdHJpbmcgPSBvcHRpb25zLmluZGVudF9jaGFyO1xuICBpZiAoIW9wdGlvbnMuaW5kZW50X3dpdGhfdGFicykge1xuICAgIHRoaXMuX19pbmRlbnRfc3RyaW5nID0gbmV3IEFycmF5KG9wdGlvbnMuaW5kZW50X3NpemUgKyAxKS5qb2luKG9wdGlvbnMuaW5kZW50X2NoYXIpO1xuICB9XG5cbiAgLy8gU2V0IHRvIG51bGwgdG8gY29udGludWUgc3VwcG9ydCBmb3IgYXV0byBkZXRlY3Rpb24gb2YgYmFzZSBpbmRlbnRcbiAgYmFzZUluZGVudFN0cmluZyA9IGJhc2VJbmRlbnRTdHJpbmcgfHwgJyc7XG4gIGlmIChvcHRpb25zLmluZGVudF9sZXZlbCA+IDApIHtcbiAgICBiYXNlSW5kZW50U3RyaW5nID0gbmV3IEFycmF5KG9wdGlvbnMuaW5kZW50X2xldmVsICsgMSkuam9pbih0aGlzLl9faW5kZW50X3N0cmluZyk7XG4gIH1cblxuICB0aGlzLl9fYmFzZV9zdHJpbmcgPSBiYXNlSW5kZW50U3RyaW5nO1xuICB0aGlzLl9fYmFzZV9zdHJpbmdfbGVuZ3RoID0gYmFzZUluZGVudFN0cmluZy5sZW5ndGg7XG59XG5cbkluZGVudFN0cmluZ0NhY2hlLnByb3RvdHlwZS5nZXRfaW5kZW50X3NpemUgPSBmdW5jdGlvbihpbmRlbnQsIGNvbHVtbikge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5fX2Jhc2Vfc3RyaW5nX2xlbmd0aDtcbiAgY29sdW1uID0gY29sdW1uIHx8IDA7XG4gIGlmIChpbmRlbnQgPCAwKSB7XG4gICAgcmVzdWx0ID0gMDtcbiAgfVxuICByZXN1bHQgKz0gaW5kZW50ICogdGhpcy5fX2luZGVudF9zaXplO1xuICByZXN1bHQgKz0gY29sdW1uO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuSW5kZW50U3RyaW5nQ2FjaGUucHJvdG90eXBlLmdldF9pbmRlbnRfc3RyaW5nID0gZnVuY3Rpb24oaW5kZW50X2xldmVsLCBjb2x1bW4pIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMuX19iYXNlX3N0cmluZztcbiAgY29sdW1uID0gY29sdW1uIHx8IDA7XG4gIGlmIChpbmRlbnRfbGV2ZWwgPCAwKSB7XG4gICAgaW5kZW50X2xldmVsID0gMDtcbiAgICByZXN1bHQgPSAnJztcbiAgfVxuICBjb2x1bW4gKz0gaW5kZW50X2xldmVsICogdGhpcy5fX2luZGVudF9zaXplO1xuICB0aGlzLl9fZW5zdXJlX2NhY2hlKGNvbHVtbik7XG4gIHJlc3VsdCArPSB0aGlzLl9fY2FjaGVbY29sdW1uXTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbkluZGVudFN0cmluZ0NhY2hlLnByb3RvdHlwZS5fX2Vuc3VyZV9jYWNoZSA9IGZ1bmN0aW9uKGNvbHVtbikge1xuICB3aGlsZSAoY29sdW1uID49IHRoaXMuX19jYWNoZS5sZW5ndGgpIHtcbiAgICB0aGlzLl9fYWRkX2NvbHVtbigpO1xuICB9XG59O1xuXG5JbmRlbnRTdHJpbmdDYWNoZS5wcm90b3R5cGUuX19hZGRfY29sdW1uID0gZnVuY3Rpb24oKSB7XG4gIHZhciBjb2x1bW4gPSB0aGlzLl9fY2FjaGUubGVuZ3RoO1xuICB2YXIgaW5kZW50ID0gMDtcbiAgdmFyIHJlc3VsdCA9ICcnO1xuICBpZiAodGhpcy5fX2luZGVudF9zaXplICYmIGNvbHVtbiA+PSB0aGlzLl9faW5kZW50X3NpemUpIHtcbiAgICBpbmRlbnQgPSBNYXRoLmZsb29yKGNvbHVtbiAvIHRoaXMuX19pbmRlbnRfc2l6ZSk7XG4gICAgY29sdW1uIC09IGluZGVudCAqIHRoaXMuX19pbmRlbnRfc2l6ZTtcbiAgICByZXN1bHQgPSBuZXcgQXJyYXkoaW5kZW50ICsgMSkuam9pbih0aGlzLl9faW5kZW50X3N0cmluZyk7XG4gIH1cbiAgaWYgKGNvbHVtbikge1xuICAgIHJlc3VsdCArPSBuZXcgQXJyYXkoY29sdW1uICsgMSkuam9pbignICcpO1xuICB9XG5cbiAgdGhpcy5fX2NhY2hlLnB1c2gocmVzdWx0KTtcbn07XG5cbmZ1bmN0aW9uIE91dHB1dChvcHRpb25zLCBiYXNlSW5kZW50U3RyaW5nKSB7XG4gIHRoaXMuX19pbmRlbnRfY2FjaGUgPSBuZXcgSW5kZW50U3RyaW5nQ2FjaGUob3B0aW9ucywgYmFzZUluZGVudFN0cmluZyk7XG4gIHRoaXMucmF3ID0gZmFsc2U7XG4gIHRoaXMuX2VuZF93aXRoX25ld2xpbmUgPSBvcHRpb25zLmVuZF93aXRoX25ld2xpbmU7XG4gIHRoaXMuaW5kZW50X3NpemUgPSBvcHRpb25zLmluZGVudF9zaXplO1xuICB0aGlzLndyYXBfbGluZV9sZW5ndGggPSBvcHRpb25zLndyYXBfbGluZV9sZW5ndGg7XG4gIHRoaXMuaW5kZW50X2VtcHR5X2xpbmVzID0gb3B0aW9ucy5pbmRlbnRfZW1wdHlfbGluZXM7XG4gIHRoaXMuX19saW5lcyA9IFtdO1xuICB0aGlzLnByZXZpb3VzX2xpbmUgPSBudWxsO1xuICB0aGlzLmN1cnJlbnRfbGluZSA9IG51bGw7XG4gIHRoaXMubmV4dF9saW5lID0gbmV3IE91dHB1dExpbmUodGhpcyk7XG4gIHRoaXMuc3BhY2VfYmVmb3JlX3Rva2VuID0gZmFsc2U7XG4gIHRoaXMubm9uX2JyZWFraW5nX3NwYWNlID0gZmFsc2U7XG4gIHRoaXMucHJldmlvdXNfdG9rZW5fd3JhcHBlZCA9IGZhbHNlO1xuICAvLyBpbml0aWFsaXplXG4gIHRoaXMuX19hZGRfb3V0cHV0bGluZSgpO1xufVxuXG5PdXRwdXQucHJvdG90eXBlLl9fYWRkX291dHB1dGxpbmUgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5wcmV2aW91c19saW5lID0gdGhpcy5jdXJyZW50X2xpbmU7XG4gIHRoaXMuY3VycmVudF9saW5lID0gdGhpcy5uZXh0X2xpbmUuY2xvbmVfZW1wdHkoKTtcbiAgdGhpcy5fX2xpbmVzLnB1c2godGhpcy5jdXJyZW50X2xpbmUpO1xufTtcblxuT3V0cHV0LnByb3RvdHlwZS5nZXRfbGluZV9udW1iZXIgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX19saW5lcy5sZW5ndGg7XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLmdldF9pbmRlbnRfc3RyaW5nID0gZnVuY3Rpb24oaW5kZW50LCBjb2x1bW4pIHtcbiAgcmV0dXJuIHRoaXMuX19pbmRlbnRfY2FjaGUuZ2V0X2luZGVudF9zdHJpbmcoaW5kZW50LCBjb2x1bW4pO1xufTtcblxuT3V0cHV0LnByb3RvdHlwZS5nZXRfaW5kZW50X3NpemUgPSBmdW5jdGlvbihpbmRlbnQsIGNvbHVtbikge1xuICByZXR1cm4gdGhpcy5fX2luZGVudF9jYWNoZS5nZXRfaW5kZW50X3NpemUoaW5kZW50LCBjb2x1bW4pO1xufTtcblxuT3V0cHV0LnByb3RvdHlwZS5pc19lbXB0eSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gIXRoaXMucHJldmlvdXNfbGluZSAmJiB0aGlzLmN1cnJlbnRfbGluZS5pc19lbXB0eSgpO1xufTtcblxuT3V0cHV0LnByb3RvdHlwZS5hZGRfbmV3X2xpbmUgPSBmdW5jdGlvbihmb3JjZV9uZXdsaW5lKSB7XG4gIC8vIG5ldmVyIG5ld2xpbmUgYXQgdGhlIHN0YXJ0IG9mIGZpbGVcbiAgLy8gb3RoZXJ3aXNlLCBuZXdsaW5lIG9ubHkgaWYgd2UgZGlkbid0IGp1c3QgYWRkIG9uZSBvciB3ZSdyZSBmb3JjZWRcbiAgaWYgKHRoaXMuaXNfZW1wdHkoKSB8fFxuICAgICghZm9yY2VfbmV3bGluZSAmJiB0aGlzLmp1c3RfYWRkZWRfbmV3bGluZSgpKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIGlmIHJhdyBvdXRwdXQgaXMgZW5hYmxlZCwgZG9uJ3QgcHJpbnQgYWRkaXRpb25hbCBuZXdsaW5lcyxcbiAgLy8gYnV0IHN0aWxsIHJldHVybiBUcnVlIGFzIHRob3VnaCB5b3UgaGFkXG4gIGlmICghdGhpcy5yYXcpIHtcbiAgICB0aGlzLl9fYWRkX291dHB1dGxpbmUoKTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbk91dHB1dC5wcm90b3R5cGUuZ2V0X2NvZGUgPSBmdW5jdGlvbihlb2wpIHtcbiAgdGhpcy50cmltKHRydWUpO1xuXG4gIC8vIGhhbmRsZSBzb21lIGVkZ2UgY2FzZXMgd2hlcmUgdGhlIGxhc3QgdG9rZW5zXG4gIC8vIGhhcyB0ZXh0IHRoYXQgZW5kcyB3aXRoIG5ld2xpbmUocylcbiAgdmFyIGxhc3RfaXRlbSA9IHRoaXMuY3VycmVudF9saW5lLnBvcCgpO1xuICBpZiAobGFzdF9pdGVtKSB7XG4gICAgaWYgKGxhc3RfaXRlbVtsYXN0X2l0ZW0ubGVuZ3RoIC0gMV0gPT09ICdcXG4nKSB7XG4gICAgICBsYXN0X2l0ZW0gPSBsYXN0X2l0ZW0ucmVwbGFjZSgvXFxuKyQvZywgJycpO1xuICAgIH1cbiAgICB0aGlzLmN1cnJlbnRfbGluZS5wdXNoKGxhc3RfaXRlbSk7XG4gIH1cblxuICBpZiAodGhpcy5fZW5kX3dpdGhfbmV3bGluZSkge1xuICAgIHRoaXMuX19hZGRfb3V0cHV0bGluZSgpO1xuICB9XG5cbiAgdmFyIHN3ZWV0X2NvZGUgPSB0aGlzLl9fbGluZXMuam9pbignXFxuJyk7XG5cbiAgaWYgKGVvbCAhPT0gJ1xcbicpIHtcbiAgICBzd2VldF9jb2RlID0gc3dlZXRfY29kZS5yZXBsYWNlKC9bXFxuXS9nLCBlb2wpO1xuICB9XG4gIHJldHVybiBzd2VldF9jb2RlO1xufTtcblxuT3V0cHV0LnByb3RvdHlwZS5zZXRfd3JhcF9wb2ludCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmN1cnJlbnRfbGluZS5fc2V0X3dyYXBfcG9pbnQoKTtcbn07XG5cbk91dHB1dC5wcm90b3R5cGUuc2V0X2luZGVudCA9IGZ1bmN0aW9uKGluZGVudCwgYWxpZ25tZW50KSB7XG4gIGluZGVudCA9IGluZGVudCB8fCAwO1xuICBhbGlnbm1lbnQgPSBhbGlnbm1lbnQgfHwgMDtcblxuICAvLyBOZXh0IGxpbmUgc3RvcmVzIGFsaWdubWVudCB2YWx1ZXNcbiAgdGhpcy5uZXh0X2xpbmUuc2V0X2luZGVudChpbmRlbnQsIGFsaWdubWVudCk7XG5cbiAgLy8gTmV2ZXIgaW5kZW50IHlvdXIgZmlyc3Qgb3V0cHV0IGluZGVudCBhdCB0aGUgc3RhcnQgb2YgdGhlIGZpbGVcbiAgaWYgKHRoaXMuX19saW5lcy5sZW5ndGggPiAxKSB7XG4gICAgdGhpcy5jdXJyZW50X2xpbmUuc2V0X2luZGVudChpbmRlbnQsIGFsaWdubWVudCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICB0aGlzLmN1cnJlbnRfbGluZS5zZXRfaW5kZW50KCk7XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbk91dHB1dC5wcm90b3R5cGUuYWRkX3Jhd190b2tlbiA9IGZ1bmN0aW9uKHRva2VuKSB7XG4gIGZvciAodmFyIHggPSAwOyB4IDwgdG9rZW4ubmV3bGluZXM7IHgrKykge1xuICAgIHRoaXMuX19hZGRfb3V0cHV0bGluZSgpO1xuICB9XG4gIHRoaXMuY3VycmVudF9saW5lLnNldF9pbmRlbnQoLTEpO1xuICB0aGlzLmN1cnJlbnRfbGluZS5wdXNoKHRva2VuLndoaXRlc3BhY2VfYmVmb3JlKTtcbiAgdGhpcy5jdXJyZW50X2xpbmUucHVzaCh0b2tlbi50ZXh0KTtcbiAgdGhpcy5zcGFjZV9iZWZvcmVfdG9rZW4gPSBmYWxzZTtcbiAgdGhpcy5ub25fYnJlYWtpbmdfc3BhY2UgPSBmYWxzZTtcbiAgdGhpcy5wcmV2aW91c190b2tlbl93cmFwcGVkID0gZmFsc2U7XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLmFkZF90b2tlbiA9IGZ1bmN0aW9uKHByaW50YWJsZV90b2tlbikge1xuICB0aGlzLl9fYWRkX3NwYWNlX2JlZm9yZV90b2tlbigpO1xuICB0aGlzLmN1cnJlbnRfbGluZS5wdXNoKHByaW50YWJsZV90b2tlbik7XG4gIHRoaXMuc3BhY2VfYmVmb3JlX3Rva2VuID0gZmFsc2U7XG4gIHRoaXMubm9uX2JyZWFraW5nX3NwYWNlID0gZmFsc2U7XG4gIHRoaXMucHJldmlvdXNfdG9rZW5fd3JhcHBlZCA9IHRoaXMuY3VycmVudF9saW5lLl9hbGxvd193cmFwKCk7XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLl9fYWRkX3NwYWNlX2JlZm9yZV90b2tlbiA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5zcGFjZV9iZWZvcmVfdG9rZW4gJiYgIXRoaXMuanVzdF9hZGRlZF9uZXdsaW5lKCkpIHtcbiAgICBpZiAoIXRoaXMubm9uX2JyZWFraW5nX3NwYWNlKSB7XG4gICAgICB0aGlzLnNldF93cmFwX3BvaW50KCk7XG4gICAgfVxuICAgIHRoaXMuY3VycmVudF9saW5lLnB1c2goJyAnKTtcbiAgfVxufTtcblxuT3V0cHV0LnByb3RvdHlwZS5yZW1vdmVfaW5kZW50ID0gZnVuY3Rpb24oaW5kZXgpIHtcbiAgdmFyIG91dHB1dF9sZW5ndGggPSB0aGlzLl9fbGluZXMubGVuZ3RoO1xuICB3aGlsZSAoaW5kZXggPCBvdXRwdXRfbGVuZ3RoKSB7XG4gICAgdGhpcy5fX2xpbmVzW2luZGV4XS5fcmVtb3ZlX2luZGVudCgpO1xuICAgIGluZGV4Kys7XG4gIH1cbiAgdGhpcy5jdXJyZW50X2xpbmUuX3JlbW92ZV93cmFwX2luZGVudCgpO1xufTtcblxuT3V0cHV0LnByb3RvdHlwZS50cmltID0gZnVuY3Rpb24oZWF0X25ld2xpbmVzKSB7XG4gIGVhdF9uZXdsaW5lcyA9IChlYXRfbmV3bGluZXMgPT09IHVuZGVmaW5lZCkgPyBmYWxzZSA6IGVhdF9uZXdsaW5lcztcblxuICB0aGlzLmN1cnJlbnRfbGluZS50cmltKCk7XG5cbiAgd2hpbGUgKGVhdF9uZXdsaW5lcyAmJiB0aGlzLl9fbGluZXMubGVuZ3RoID4gMSAmJlxuICAgIHRoaXMuY3VycmVudF9saW5lLmlzX2VtcHR5KCkpIHtcbiAgICB0aGlzLl9fbGluZXMucG9wKCk7XG4gICAgdGhpcy5jdXJyZW50X2xpbmUgPSB0aGlzLl9fbGluZXNbdGhpcy5fX2xpbmVzLmxlbmd0aCAtIDFdO1xuICAgIHRoaXMuY3VycmVudF9saW5lLnRyaW0oKTtcbiAgfVxuXG4gIHRoaXMucHJldmlvdXNfbGluZSA9IHRoaXMuX19saW5lcy5sZW5ndGggPiAxID9cbiAgICB0aGlzLl9fbGluZXNbdGhpcy5fX2xpbmVzLmxlbmd0aCAtIDJdIDogbnVsbDtcbn07XG5cbk91dHB1dC5wcm90b3R5cGUuanVzdF9hZGRlZF9uZXdsaW5lID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmN1cnJlbnRfbGluZS5pc19lbXB0eSgpO1xufTtcblxuT3V0cHV0LnByb3RvdHlwZS5qdXN0X2FkZGVkX2JsYW5rbGluZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5pc19lbXB0eSgpIHx8XG4gICAgKHRoaXMuY3VycmVudF9saW5lLmlzX2VtcHR5KCkgJiYgdGhpcy5wcmV2aW91c19saW5lLmlzX2VtcHR5KCkpO1xufTtcblxuT3V0cHV0LnByb3RvdHlwZS5lbnN1cmVfZW1wdHlfbGluZV9hYm92ZSA9IGZ1bmN0aW9uKHN0YXJ0c193aXRoLCBlbmRzX3dpdGgpIHtcbiAgdmFyIGluZGV4ID0gdGhpcy5fX2xpbmVzLmxlbmd0aCAtIDI7XG4gIHdoaWxlIChpbmRleCA+PSAwKSB7XG4gICAgdmFyIHBvdGVudGlhbEVtcHR5TGluZSA9IHRoaXMuX19saW5lc1tpbmRleF07XG4gICAgaWYgKHBvdGVudGlhbEVtcHR5TGluZS5pc19lbXB0eSgpKSB7XG4gICAgICBicmVhaztcbiAgICB9IGVsc2UgaWYgKHBvdGVudGlhbEVtcHR5TGluZS5pdGVtKDApLmluZGV4T2Yoc3RhcnRzX3dpdGgpICE9PSAwICYmXG4gICAgICBwb3RlbnRpYWxFbXB0eUxpbmUuaXRlbSgtMSkgIT09IGVuZHNfd2l0aCkge1xuICAgICAgdGhpcy5fX2xpbmVzLnNwbGljZShpbmRleCArIDEsIDAsIG5ldyBPdXRwdXRMaW5lKHRoaXMpKTtcbiAgICAgIHRoaXMucHJldmlvdXNfbGluZSA9IHRoaXMuX19saW5lc1t0aGlzLl9fbGluZXMubGVuZ3RoIC0gMl07XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaW5kZXgtLTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMuT3V0cHV0ID0gT3V0cHV0O1xuXG5cbi8qKiovIH0pLFxuLyogMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qanNoaW50IG5vZGU6dHJ1ZSAqL1xuLypcblxuICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxOCBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgU09GVFdBUkUuXG4qL1xuXG5cblxuZnVuY3Rpb24gVG9rZW4odHlwZSwgdGV4dCwgbmV3bGluZXMsIHdoaXRlc3BhY2VfYmVmb3JlKSB7XG4gIHRoaXMudHlwZSA9IHR5cGU7XG4gIHRoaXMudGV4dCA9IHRleHQ7XG5cbiAgLy8gY29tbWVudHNfYmVmb3JlIGFyZVxuICAvLyBjb21tZW50cyB0aGF0IGhhdmUgYSBuZXcgbGluZSBiZWZvcmUgdGhlbVxuICAvLyBhbmQgbWF5IG9yIG1heSBub3QgaGF2ZSBhIG5ld2xpbmUgYWZ0ZXJcbiAgLy8gdGhpcyBpcyBhIHNldCBvZiBjb21tZW50cyBiZWZvcmVcbiAgdGhpcy5jb21tZW50c19iZWZvcmUgPSBudWxsOyAvKiBpbmxpbmUgY29tbWVudCovXG5cblxuICAvLyB0aGlzLmNvbW1lbnRzX2FmdGVyID0gIG5ldyBUb2tlblN0cmVhbSgpOyAvLyBubyBuZXcgbGluZSBiZWZvcmUgYW5kIG5ld2xpbmUgYWZ0ZXJcbiAgdGhpcy5uZXdsaW5lcyA9IG5ld2xpbmVzIHx8IDA7XG4gIHRoaXMud2hpdGVzcGFjZV9iZWZvcmUgPSB3aGl0ZXNwYWNlX2JlZm9yZSB8fCAnJztcbiAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICB0aGlzLm5leHQgPSBudWxsO1xuICB0aGlzLnByZXZpb3VzID0gbnVsbDtcbiAgdGhpcy5vcGVuZWQgPSBudWxsO1xuICB0aGlzLmNsb3NlZCA9IG51bGw7XG4gIHRoaXMuZGlyZWN0aXZlcyA9IG51bGw7XG59XG5cblxubW9kdWxlLmV4cG9ydHMuVG9rZW4gPSBUb2tlbjtcblxuXG4vKioqLyB9KSxcbi8qIDQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBqc2hpbnQgbm9kZTogdHJ1ZSwgY3VybHk6IGZhbHNlICovXG4vLyBQYXJ0cyBvZiB0aGlzIHNlY3Rpb24gb2YgY29kZSBpcyB0YWtlbiBmcm9tIGFjb3JuLlxuLy9cbi8vIEFjb3JuIHdhcyB3cml0dGVuIGJ5IE1hcmlqbiBIYXZlcmJla2UgYW5kIHJlbGVhc2VkIHVuZGVyIGFuIE1JVFxuLy8gbGljZW5zZS4gVGhlIFVuaWNvZGUgcmVnZXhwcyAoZm9yIGlkZW50aWZpZXJzIGFuZCB3aGl0ZXNwYWNlKSB3ZXJlXG4vLyB0YWtlbiBmcm9tIFtFc3ByaW1hXShodHRwOi8vZXNwcmltYS5vcmcpIGJ5IEFyaXlhIEhpZGF5YXQuXG4vL1xuLy8gR2l0IHJlcG9zaXRvcmllcyBmb3IgQWNvcm4gYXJlIGF2YWlsYWJsZSBhdFxuLy9cbi8vICAgICBodHRwOi8vbWFyaWpuaGF2ZXJiZWtlLm5sL2dpdC9hY29yblxuLy8gICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJpam5oL2Fjb3JuLmdpdFxuXG4vLyAjIyBDaGFyYWN0ZXIgY2F0ZWdvcmllc1xuXG5cblxuXG4vLyBhY29ybiB1c2VkIGNoYXIgY29kZXMgdG8gc3F1ZWV6ZSB0aGUgbGFzdCBiaXQgb2YgcGVyZm9ybWFuY2Ugb3V0XG4vLyBCZWF1dGlmaWVyIGlzIG9rYXkgd2l0aG91dCB0aGF0LCBzbyB3ZSdyZSB1c2luZyByZWdleFxuLy8gcGVybWl0ICMgKDIzKSwgJCAoMzYpLCBhbmQgQCAoNjQpLiBAIGlzIHVzZWQgaW4gRVM3IGRlY29yYXRvcnMuXG4vLyA2NSB0aHJvdWdoIDkxIGFyZSB1cHBlcmNhc2UgbGV0dGVycy5cbi8vIHBlcm1pdCBfICg5NSkuXG4vLyA5NyB0aHJvdWdoIDEyMyBhcmUgbG93ZXJjYXNlIGxldHRlcnMuXG52YXIgYmFzZUFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMgPSBcIlxcXFx4MjNcXFxceDI0XFxcXHg0MFxcXFx4NDEtXFxcXHg1YVxcXFx4NWZcXFxceDYxLVxcXFx4N2FcIjtcblxuLy8gaW5zaWRlIGFuIGlkZW50aWZpZXIgQCBpcyBub3QgYWxsb3dlZCBidXQgMC05IGFyZS5cbnZhciBiYXNlQVNDSUlpZGVudGlmaWVyQ2hhcnMgPSBcIlxcXFx4MjRcXFxceDMwLVxcXFx4MzlcXFxceDQxLVxcXFx4NWFcXFxceDVmXFxcXHg2MS1cXFxceDdhXCI7XG5cbi8vIEJpZyB1Z2x5IHJlZ3VsYXIgZXhwcmVzc2lvbnMgdGhhdCBtYXRjaCBjaGFyYWN0ZXJzIGluIHRoZVxuLy8gd2hpdGVzcGFjZSwgaWRlbnRpZmllciwgYW5kIGlkZW50aWZpZXItc3RhcnQgY2F0ZWdvcmllcy4gVGhlc2Vcbi8vIGFyZSBvbmx5IGFwcGxpZWQgd2hlbiBhIGNoYXJhY3RlciBpcyBmb3VuZCB0byBhY3R1YWxseSBoYXZlIGFcbi8vIGNvZGUgcG9pbnQgYWJvdmUgMTI4LlxudmFyIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMgPSBcIlxcXFx4YWFcXFxceGI1XFxcXHhiYVxcXFx4YzAtXFxcXHhkNlxcXFx4ZDgtXFxcXHhmNlxcXFx4ZjgtXFxcXHUwMmMxXFxcXHUwMmM2LVxcXFx1MDJkMVxcXFx1MDJlMC1cXFxcdTAyZTRcXFxcdTAyZWNcXFxcdTAyZWVcXFxcdTAzNzAtXFxcXHUwMzc0XFxcXHUwMzc2XFxcXHUwMzc3XFxcXHUwMzdhLVxcXFx1MDM3ZFxcXFx1MDM4NlxcXFx1MDM4OC1cXFxcdTAzOGFcXFxcdTAzOGNcXFxcdTAzOGUtXFxcXHUwM2ExXFxcXHUwM2EzLVxcXFx1MDNmNVxcXFx1MDNmNy1cXFxcdTA0ODFcXFxcdTA0OGEtXFxcXHUwNTI3XFxcXHUwNTMxLVxcXFx1MDU1NlxcXFx1MDU1OVxcXFx1MDU2MS1cXFxcdTA1ODdcXFxcdTA1ZDAtXFxcXHUwNWVhXFxcXHUwNWYwLVxcXFx1MDVmMlxcXFx1MDYyMC1cXFxcdTA2NGFcXFxcdTA2NmVcXFxcdTA2NmZcXFxcdTA2NzEtXFxcXHUwNmQzXFxcXHUwNmQ1XFxcXHUwNmU1XFxcXHUwNmU2XFxcXHUwNmVlXFxcXHUwNmVmXFxcXHUwNmZhLVxcXFx1MDZmY1xcXFx1MDZmZlxcXFx1MDcxMFxcXFx1MDcxMi1cXFxcdTA3MmZcXFxcdTA3NGQtXFxcXHUwN2E1XFxcXHUwN2IxXFxcXHUwN2NhLVxcXFx1MDdlYVxcXFx1MDdmNFxcXFx1MDdmNVxcXFx1MDdmYVxcXFx1MDgwMC1cXFxcdTA4MTVcXFxcdTA4MWFcXFxcdTA4MjRcXFxcdTA4MjhcXFxcdTA4NDAtXFxcXHUwODU4XFxcXHUwOGEwXFxcXHUwOGEyLVxcXFx1MDhhY1xcXFx1MDkwNC1cXFxcdTA5MzlcXFxcdTA5M2RcXFxcdTA5NTBcXFxcdTA5NTgtXFxcXHUwOTYxXFxcXHUwOTcxLVxcXFx1MDk3N1xcXFx1MDk3OS1cXFxcdTA5N2ZcXFxcdTA5ODUtXFxcXHUwOThjXFxcXHUwOThmXFxcXHUwOTkwXFxcXHUwOTkzLVxcXFx1MDlhOFxcXFx1MDlhYS1cXFxcdTA5YjBcXFxcdTA5YjJcXFxcdTA5YjYtXFxcXHUwOWI5XFxcXHUwOWJkXFxcXHUwOWNlXFxcXHUwOWRjXFxcXHUwOWRkXFxcXHUwOWRmLVxcXFx1MDllMVxcXFx1MDlmMFxcXFx1MDlmMVxcXFx1MGEwNS1cXFxcdTBhMGFcXFxcdTBhMGZcXFxcdTBhMTBcXFxcdTBhMTMtXFxcXHUwYTI4XFxcXHUwYTJhLVxcXFx1MGEzMFxcXFx1MGEzMlxcXFx1MGEzM1xcXFx1MGEzNVxcXFx1MGEzNlxcXFx1MGEzOFxcXFx1MGEzOVxcXFx1MGE1OS1cXFxcdTBhNWNcXFxcdTBhNWVcXFxcdTBhNzItXFxcXHUwYTc0XFxcXHUwYTg1LVxcXFx1MGE4ZFxcXFx1MGE4Zi1cXFxcdTBhOTFcXFxcdTBhOTMtXFxcXHUwYWE4XFxcXHUwYWFhLVxcXFx1MGFiMFxcXFx1MGFiMlxcXFx1MGFiM1xcXFx1MGFiNS1cXFxcdTBhYjlcXFxcdTBhYmRcXFxcdTBhZDBcXFxcdTBhZTBcXFxcdTBhZTFcXFxcdTBiMDUtXFxcXHUwYjBjXFxcXHUwYjBmXFxcXHUwYjEwXFxcXHUwYjEzLVxcXFx1MGIyOFxcXFx1MGIyYS1cXFxcdTBiMzBcXFxcdTBiMzJcXFxcdTBiMzNcXFxcdTBiMzUtXFxcXHUwYjM5XFxcXHUwYjNkXFxcXHUwYjVjXFxcXHUwYjVkXFxcXHUwYjVmLVxcXFx1MGI2MVxcXFx1MGI3MVxcXFx1MGI4M1xcXFx1MGI4NS1cXFxcdTBiOGFcXFxcdTBiOGUtXFxcXHUwYjkwXFxcXHUwYjkyLVxcXFx1MGI5NVxcXFx1MGI5OVxcXFx1MGI5YVxcXFx1MGI5Y1xcXFx1MGI5ZVxcXFx1MGI5ZlxcXFx1MGJhM1xcXFx1MGJhNFxcXFx1MGJhOC1cXFxcdTBiYWFcXFxcdTBiYWUtXFxcXHUwYmI5XFxcXHUwYmQwXFxcXHUwYzA1LVxcXFx1MGMwY1xcXFx1MGMwZS1cXFxcdTBjMTBcXFxcdTBjMTItXFxcXHUwYzI4XFxcXHUwYzJhLVxcXFx1MGMzM1xcXFx1MGMzNS1cXFxcdTBjMzlcXFxcdTBjM2RcXFxcdTBjNThcXFxcdTBjNTlcXFxcdTBjNjBcXFxcdTBjNjFcXFxcdTBjODUtXFxcXHUwYzhjXFxcXHUwYzhlLVxcXFx1MGM5MFxcXFx1MGM5Mi1cXFxcdTBjYThcXFxcdTBjYWEtXFxcXHUwY2IzXFxcXHUwY2I1LVxcXFx1MGNiOVxcXFx1MGNiZFxcXFx1MGNkZVxcXFx1MGNlMFxcXFx1MGNlMVxcXFx1MGNmMVxcXFx1MGNmMlxcXFx1MGQwNS1cXFxcdTBkMGNcXFxcdTBkMGUtXFxcXHUwZDEwXFxcXHUwZDEyLVxcXFx1MGQzYVxcXFx1MGQzZFxcXFx1MGQ0ZVxcXFx1MGQ2MFxcXFx1MGQ2MVxcXFx1MGQ3YS1cXFxcdTBkN2ZcXFxcdTBkODUtXFxcXHUwZDk2XFxcXHUwZDlhLVxcXFx1MGRiMVxcXFx1MGRiMy1cXFxcdTBkYmJcXFxcdTBkYmRcXFxcdTBkYzAtXFxcXHUwZGM2XFxcXHUwZTAxLVxcXFx1MGUzMFxcXFx1MGUzMlxcXFx1MGUzM1xcXFx1MGU0MC1cXFxcdTBlNDZcXFxcdTBlODFcXFxcdTBlODJcXFxcdTBlODRcXFxcdTBlODdcXFxcdTBlODhcXFxcdTBlOGFcXFxcdTBlOGRcXFxcdTBlOTQtXFxcXHUwZTk3XFxcXHUwZTk5LVxcXFx1MGU5ZlxcXFx1MGVhMS1cXFxcdTBlYTNcXFxcdTBlYTVcXFxcdTBlYTdcXFxcdTBlYWFcXFxcdTBlYWJcXFxcdTBlYWQtXFxcXHUwZWIwXFxcXHUwZWIyXFxcXHUwZWIzXFxcXHUwZWJkXFxcXHUwZWMwLVxcXFx1MGVjNFxcXFx1MGVjNlxcXFx1MGVkYy1cXFxcdTBlZGZcXFxcdTBmMDBcXFxcdTBmNDAtXFxcXHUwZjQ3XFxcXHUwZjQ5LVxcXFx1MGY2Y1xcXFx1MGY4OC1cXFxcdTBmOGNcXFxcdTEwMDAtXFxcXHUxMDJhXFxcXHUxMDNmXFxcXHUxMDUwLVxcXFx1MTA1NVxcXFx1MTA1YS1cXFxcdTEwNWRcXFxcdTEwNjFcXFxcdTEwNjVcXFxcdTEwNjZcXFxcdTEwNmUtXFxcXHUxMDcwXFxcXHUxMDc1LVxcXFx1MTA4MVxcXFx1MTA4ZVxcXFx1MTBhMC1cXFxcdTEwYzVcXFxcdTEwYzdcXFxcdTEwY2RcXFxcdTEwZDAtXFxcXHUxMGZhXFxcXHUxMGZjLVxcXFx1MTI0OFxcXFx1MTI0YS1cXFxcdTEyNGRcXFxcdTEyNTAtXFxcXHUxMjU2XFxcXHUxMjU4XFxcXHUxMjVhLVxcXFx1MTI1ZFxcXFx1MTI2MC1cXFxcdTEyODhcXFxcdTEyOGEtXFxcXHUxMjhkXFxcXHUxMjkwLVxcXFx1MTJiMFxcXFx1MTJiMi1cXFxcdTEyYjVcXFxcdTEyYjgtXFxcXHUxMmJlXFxcXHUxMmMwXFxcXHUxMmMyLVxcXFx1MTJjNVxcXFx1MTJjOC1cXFxcdTEyZDZcXFxcdTEyZDgtXFxcXHUxMzEwXFxcXHUxMzEyLVxcXFx1MTMxNVxcXFx1MTMxOC1cXFxcdTEzNWFcXFxcdTEzODAtXFxcXHUxMzhmXFxcXHUxM2EwLVxcXFx1MTNmNFxcXFx1MTQwMS1cXFxcdTE2NmNcXFxcdTE2NmYtXFxcXHUxNjdmXFxcXHUxNjgxLVxcXFx1MTY5YVxcXFx1MTZhMC1cXFxcdTE2ZWFcXFxcdTE2ZWUtXFxcXHUxNmYwXFxcXHUxNzAwLVxcXFx1MTcwY1xcXFx1MTcwZS1cXFxcdTE3MTFcXFxcdTE3MjAtXFxcXHUxNzMxXFxcXHUxNzQwLVxcXFx1MTc1MVxcXFx1MTc2MC1cXFxcdTE3NmNcXFxcdTE3NmUtXFxcXHUxNzcwXFxcXHUxNzgwLVxcXFx1MTdiM1xcXFx1MTdkN1xcXFx1MTdkY1xcXFx1MTgyMC1cXFxcdTE4NzdcXFxcdTE4ODAtXFxcXHUxOGE4XFxcXHUxOGFhXFxcXHUxOGIwLVxcXFx1MThmNVxcXFx1MTkwMC1cXFxcdTE5MWNcXFxcdTE5NTAtXFxcXHUxOTZkXFxcXHUxOTcwLVxcXFx1MTk3NFxcXFx1MTk4MC1cXFxcdTE5YWJcXFxcdTE5YzEtXFxcXHUxOWM3XFxcXHUxYTAwLVxcXFx1MWExNlxcXFx1MWEyMC1cXFxcdTFhNTRcXFxcdTFhYTdcXFxcdTFiMDUtXFxcXHUxYjMzXFxcXHUxYjQ1LVxcXFx1MWI0YlxcXFx1MWI4My1cXFxcdTFiYTBcXFxcdTFiYWVcXFxcdTFiYWZcXFxcdTFiYmEtXFxcXHUxYmU1XFxcXHUxYzAwLVxcXFx1MWMyM1xcXFx1MWM0ZC1cXFxcdTFjNGZcXFxcdTFjNWEtXFxcXHUxYzdkXFxcXHUxY2U5LVxcXFx1MWNlY1xcXFx1MWNlZS1cXFxcdTFjZjFcXFxcdTFjZjVcXFxcdTFjZjZcXFxcdTFkMDAtXFxcXHUxZGJmXFxcXHUxZTAwLVxcXFx1MWYxNVxcXFx1MWYxOC1cXFxcdTFmMWRcXFxcdTFmMjAtXFxcXHUxZjQ1XFxcXHUxZjQ4LVxcXFx1MWY0ZFxcXFx1MWY1MC1cXFxcdTFmNTdcXFxcdTFmNTlcXFxcdTFmNWJcXFxcdTFmNWRcXFxcdTFmNWYtXFxcXHUxZjdkXFxcXHUxZjgwLVxcXFx1MWZiNFxcXFx1MWZiNi1cXFxcdTFmYmNcXFxcdTFmYmVcXFxcdTFmYzItXFxcXHUxZmM0XFxcXHUxZmM2LVxcXFx1MWZjY1xcXFx1MWZkMC1cXFxcdTFmZDNcXFxcdTFmZDYtXFxcXHUxZmRiXFxcXHUxZmUwLVxcXFx1MWZlY1xcXFx1MWZmMi1cXFxcdTFmZjRcXFxcdTFmZjYtXFxcXHUxZmZjXFxcXHUyMDcxXFxcXHUyMDdmXFxcXHUyMDkwLVxcXFx1MjA5Y1xcXFx1MjEwMlxcXFx1MjEwN1xcXFx1MjEwYS1cXFxcdTIxMTNcXFxcdTIxMTVcXFxcdTIxMTktXFxcXHUyMTFkXFxcXHUyMTI0XFxcXHUyMTI2XFxcXHUyMTI4XFxcXHUyMTJhLVxcXFx1MjEyZFxcXFx1MjEyZi1cXFxcdTIxMzlcXFxcdTIxM2MtXFxcXHUyMTNmXFxcXHUyMTQ1LVxcXFx1MjE0OVxcXFx1MjE0ZVxcXFx1MjE2MC1cXFxcdTIxODhcXFxcdTJjMDAtXFxcXHUyYzJlXFxcXHUyYzMwLVxcXFx1MmM1ZVxcXFx1MmM2MC1cXFxcdTJjZTRcXFxcdTJjZWItXFxcXHUyY2VlXFxcXHUyY2YyXFxcXHUyY2YzXFxcXHUyZDAwLVxcXFx1MmQyNVxcXFx1MmQyN1xcXFx1MmQyZFxcXFx1MmQzMC1cXFxcdTJkNjdcXFxcdTJkNmZcXFxcdTJkODAtXFxcXHUyZDk2XFxcXHUyZGEwLVxcXFx1MmRhNlxcXFx1MmRhOC1cXFxcdTJkYWVcXFxcdTJkYjAtXFxcXHUyZGI2XFxcXHUyZGI4LVxcXFx1MmRiZVxcXFx1MmRjMC1cXFxcdTJkYzZcXFxcdTJkYzgtXFxcXHUyZGNlXFxcXHUyZGQwLVxcXFx1MmRkNlxcXFx1MmRkOC1cXFxcdTJkZGVcXFxcdTJlMmZcXFxcdTMwMDUtXFxcXHUzMDA3XFxcXHUzMDIxLVxcXFx1MzAyOVxcXFx1MzAzMS1cXFxcdTMwMzVcXFxcdTMwMzgtXFxcXHUzMDNjXFxcXHUzMDQxLVxcXFx1MzA5NlxcXFx1MzA5ZC1cXFxcdTMwOWZcXFxcdTMwYTEtXFxcXHUzMGZhXFxcXHUzMGZjLVxcXFx1MzBmZlxcXFx1MzEwNS1cXFxcdTMxMmRcXFxcdTMxMzEtXFxcXHUzMThlXFxcXHUzMWEwLVxcXFx1MzFiYVxcXFx1MzFmMC1cXFxcdTMxZmZcXFxcdTM0MDAtXFxcXHU0ZGI1XFxcXHU0ZTAwLVxcXFx1OWZjY1xcXFx1YTAwMC1cXFxcdWE0OGNcXFxcdWE0ZDAtXFxcXHVhNGZkXFxcXHVhNTAwLVxcXFx1YTYwY1xcXFx1YTYxMC1cXFxcdWE2MWZcXFxcdWE2MmFcXFxcdWE2MmJcXFxcdWE2NDAtXFxcXHVhNjZlXFxcXHVhNjdmLVxcXFx1YTY5N1xcXFx1YTZhMC1cXFxcdWE2ZWZcXFxcdWE3MTctXFxcXHVhNzFmXFxcXHVhNzIyLVxcXFx1YTc4OFxcXFx1YTc4Yi1cXFxcdWE3OGVcXFxcdWE3OTAtXFxcXHVhNzkzXFxcXHVhN2EwLVxcXFx1YTdhYVxcXFx1YTdmOC1cXFxcdWE4MDFcXFxcdWE4MDMtXFxcXHVhODA1XFxcXHVhODA3LVxcXFx1YTgwYVxcXFx1YTgwYy1cXFxcdWE4MjJcXFxcdWE4NDAtXFxcXHVhODczXFxcXHVhODgyLVxcXFx1YThiM1xcXFx1YThmMi1cXFxcdWE4ZjdcXFxcdWE4ZmJcXFxcdWE5MGEtXFxcXHVhOTI1XFxcXHVhOTMwLVxcXFx1YTk0NlxcXFx1YTk2MC1cXFxcdWE5N2NcXFxcdWE5ODQtXFxcXHVhOWIyXFxcXHVhOWNmXFxcXHVhYTAwLVxcXFx1YWEyOFxcXFx1YWE0MC1cXFxcdWFhNDJcXFxcdWFhNDQtXFxcXHVhYTRiXFxcXHVhYTYwLVxcXFx1YWE3NlxcXFx1YWE3YVxcXFx1YWE4MC1cXFxcdWFhYWZcXFxcdWFhYjFcXFxcdWFhYjVcXFxcdWFhYjZcXFxcdWFhYjktXFxcXHVhYWJkXFxcXHVhYWMwXFxcXHVhYWMyXFxcXHVhYWRiLVxcXFx1YWFkZFxcXFx1YWFlMC1cXFxcdWFhZWFcXFxcdWFhZjItXFxcXHVhYWY0XFxcXHVhYjAxLVxcXFx1YWIwNlxcXFx1YWIwOS1cXFxcdWFiMGVcXFxcdWFiMTEtXFxcXHVhYjE2XFxcXHVhYjIwLVxcXFx1YWIyNlxcXFx1YWIyOC1cXFxcdWFiMmVcXFxcdWFiYzAtXFxcXHVhYmUyXFxcXHVhYzAwLVxcXFx1ZDdhM1xcXFx1ZDdiMC1cXFxcdWQ3YzZcXFxcdWQ3Y2ItXFxcXHVkN2ZiXFxcXHVmOTAwLVxcXFx1ZmE2ZFxcXFx1ZmE3MC1cXFxcdWZhZDlcXFxcdWZiMDAtXFxcXHVmYjA2XFxcXHVmYjEzLVxcXFx1ZmIxN1xcXFx1ZmIxZFxcXFx1ZmIxZi1cXFxcdWZiMjhcXFxcdWZiMmEtXFxcXHVmYjM2XFxcXHVmYjM4LVxcXFx1ZmIzY1xcXFx1ZmIzZVxcXFx1ZmI0MFxcXFx1ZmI0MVxcXFx1ZmI0M1xcXFx1ZmI0NFxcXFx1ZmI0Ni1cXFxcdWZiYjFcXFxcdWZiZDMtXFxcXHVmZDNkXFxcXHVmZDUwLVxcXFx1ZmQ4ZlxcXFx1ZmQ5Mi1cXFxcdWZkYzdcXFxcdWZkZjAtXFxcXHVmZGZiXFxcXHVmZTcwLVxcXFx1ZmU3NFxcXFx1ZmU3Ni1cXFxcdWZlZmNcXFxcdWZmMjEtXFxcXHVmZjNhXFxcXHVmZjQxLVxcXFx1ZmY1YVxcXFx1ZmY2Ni1cXFxcdWZmYmVcXFxcdWZmYzItXFxcXHVmZmM3XFxcXHVmZmNhLVxcXFx1ZmZjZlxcXFx1ZmZkMi1cXFxcdWZmZDdcXFxcdWZmZGEtXFxcXHVmZmRjXCI7XG52YXIgbm9uQVNDSUlpZGVudGlmaWVyQ2hhcnMgPSBcIlxcXFx1MDMwMC1cXFxcdTAzNmZcXFxcdTA0ODMtXFxcXHUwNDg3XFxcXHUwNTkxLVxcXFx1MDViZFxcXFx1MDViZlxcXFx1MDVjMVxcXFx1MDVjMlxcXFx1MDVjNFxcXFx1MDVjNVxcXFx1MDVjN1xcXFx1MDYxMC1cXFxcdTA2MWFcXFxcdTA2MjAtXFxcXHUwNjQ5XFxcXHUwNjcyLVxcXFx1MDZkM1xcXFx1MDZlNy1cXFxcdTA2ZThcXFxcdTA2ZmItXFxcXHUwNmZjXFxcXHUwNzMwLVxcXFx1MDc0YVxcXFx1MDgwMC1cXFxcdTA4MTRcXFxcdTA4MWItXFxcXHUwODIzXFxcXHUwODI1LVxcXFx1MDgyN1xcXFx1MDgyOS1cXFxcdTA4MmRcXFxcdTA4NDAtXFxcXHUwODU3XFxcXHUwOGU0LVxcXFx1MDhmZVxcXFx1MDkwMC1cXFxcdTA5MDNcXFxcdTA5M2EtXFxcXHUwOTNjXFxcXHUwOTNlLVxcXFx1MDk0ZlxcXFx1MDk1MS1cXFxcdTA5NTdcXFxcdTA5NjItXFxcXHUwOTYzXFxcXHUwOTY2LVxcXFx1MDk2ZlxcXFx1MDk4MS1cXFxcdTA5ODNcXFxcdTA5YmNcXFxcdTA5YmUtXFxcXHUwOWM0XFxcXHUwOWM3XFxcXHUwOWM4XFxcXHUwOWQ3XFxcXHUwOWRmLVxcXFx1MDllMFxcXFx1MGEwMS1cXFxcdTBhMDNcXFxcdTBhM2NcXFxcdTBhM2UtXFxcXHUwYTQyXFxcXHUwYTQ3XFxcXHUwYTQ4XFxcXHUwYTRiLVxcXFx1MGE0ZFxcXFx1MGE1MVxcXFx1MGE2Ni1cXFxcdTBhNzFcXFxcdTBhNzVcXFxcdTBhODEtXFxcXHUwYTgzXFxcXHUwYWJjXFxcXHUwYWJlLVxcXFx1MGFjNVxcXFx1MGFjNy1cXFxcdTBhYzlcXFxcdTBhY2ItXFxcXHUwYWNkXFxcXHUwYWUyLVxcXFx1MGFlM1xcXFx1MGFlNi1cXFxcdTBhZWZcXFxcdTBiMDEtXFxcXHUwYjAzXFxcXHUwYjNjXFxcXHUwYjNlLVxcXFx1MGI0NFxcXFx1MGI0N1xcXFx1MGI0OFxcXFx1MGI0Yi1cXFxcdTBiNGRcXFxcdTBiNTZcXFxcdTBiNTdcXFxcdTBiNWYtXFxcXHUwYjYwXFxcXHUwYjY2LVxcXFx1MGI2ZlxcXFx1MGI4MlxcXFx1MGJiZS1cXFxcdTBiYzJcXFxcdTBiYzYtXFxcXHUwYmM4XFxcXHUwYmNhLVxcXFx1MGJjZFxcXFx1MGJkN1xcXFx1MGJlNi1cXFxcdTBiZWZcXFxcdTBjMDEtXFxcXHUwYzAzXFxcXHUwYzQ2LVxcXFx1MGM0OFxcXFx1MGM0YS1cXFxcdTBjNGRcXFxcdTBjNTVcXFxcdTBjNTZcXFxcdTBjNjItXFxcXHUwYzYzXFxcXHUwYzY2LVxcXFx1MGM2ZlxcXFx1MGM4MlxcXFx1MGM4M1xcXFx1MGNiY1xcXFx1MGNiZS1cXFxcdTBjYzRcXFxcdTBjYzYtXFxcXHUwY2M4XFxcXHUwY2NhLVxcXFx1MGNjZFxcXFx1MGNkNVxcXFx1MGNkNlxcXFx1MGNlMi1cXFxcdTBjZTNcXFxcdTBjZTYtXFxcXHUwY2VmXFxcXHUwZDAyXFxcXHUwZDAzXFxcXHUwZDQ2LVxcXFx1MGQ0OFxcXFx1MGQ1N1xcXFx1MGQ2Mi1cXFxcdTBkNjNcXFxcdTBkNjYtXFxcXHUwZDZmXFxcXHUwZDgyXFxcXHUwZDgzXFxcXHUwZGNhXFxcXHUwZGNmLVxcXFx1MGRkNFxcXFx1MGRkNlxcXFx1MGRkOC1cXFxcdTBkZGZcXFxcdTBkZjJcXFxcdTBkZjNcXFxcdTBlMzQtXFxcXHUwZTNhXFxcXHUwZTQwLVxcXFx1MGU0NVxcXFx1MGU1MC1cXFxcdTBlNTlcXFxcdTBlYjQtXFxcXHUwZWI5XFxcXHUwZWM4LVxcXFx1MGVjZFxcXFx1MGVkMC1cXFxcdTBlZDlcXFxcdTBmMThcXFxcdTBmMTlcXFxcdTBmMjAtXFxcXHUwZjI5XFxcXHUwZjM1XFxcXHUwZjM3XFxcXHUwZjM5XFxcXHUwZjQxLVxcXFx1MGY0N1xcXFx1MGY3MS1cXFxcdTBmODRcXFxcdTBmODYtXFxcXHUwZjg3XFxcXHUwZjhkLVxcXFx1MGY5N1xcXFx1MGY5OS1cXFxcdTBmYmNcXFxcdTBmYzZcXFxcdTEwMDAtXFxcXHUxMDI5XFxcXHUxMDQwLVxcXFx1MTA0OVxcXFx1MTA2Ny1cXFxcdTEwNmRcXFxcdTEwNzEtXFxcXHUxMDc0XFxcXHUxMDgyLVxcXFx1MTA4ZFxcXFx1MTA4Zi1cXFxcdTEwOWRcXFxcdTEzNWQtXFxcXHUxMzVmXFxcXHUxNzBlLVxcXFx1MTcxMFxcXFx1MTcyMC1cXFxcdTE3MzBcXFxcdTE3NDAtXFxcXHUxNzUwXFxcXHUxNzcyXFxcXHUxNzczXFxcXHUxNzgwLVxcXFx1MTdiMlxcXFx1MTdkZFxcXFx1MTdlMC1cXFxcdTE3ZTlcXFxcdTE4MGItXFxcXHUxODBkXFxcXHUxODEwLVxcXFx1MTgxOVxcXFx1MTkyMC1cXFxcdTE5MmJcXFxcdTE5MzAtXFxcXHUxOTNiXFxcXHUxOTUxLVxcXFx1MTk2ZFxcXFx1MTliMC1cXFxcdTE5YzBcXFxcdTE5YzgtXFxcXHUxOWM5XFxcXHUxOWQwLVxcXFx1MTlkOVxcXFx1MWEwMC1cXFxcdTFhMTVcXFxcdTFhMjAtXFxcXHUxYTUzXFxcXHUxYTYwLVxcXFx1MWE3Y1xcXFx1MWE3Zi1cXFxcdTFhODlcXFxcdTFhOTAtXFxcXHUxYTk5XFxcXHUxYjQ2LVxcXFx1MWI0YlxcXFx1MWI1MC1cXFxcdTFiNTlcXFxcdTFiNmItXFxcXHUxYjczXFxcXHUxYmIwLVxcXFx1MWJiOVxcXFx1MWJlNi1cXFxcdTFiZjNcXFxcdTFjMDAtXFxcXHUxYzIyXFxcXHUxYzQwLVxcXFx1MWM0OVxcXFx1MWM1Yi1cXFxcdTFjN2RcXFxcdTFjZDAtXFxcXHUxY2QyXFxcXHUxZDAwLVxcXFx1MWRiZVxcXFx1MWUwMS1cXFxcdTFmMTVcXFxcdTIwMGNcXFxcdTIwMGRcXFxcdTIwM2ZcXFxcdTIwNDBcXFxcdTIwNTRcXFxcdTIwZDAtXFxcXHUyMGRjXFxcXHUyMGUxXFxcXHUyMGU1LVxcXFx1MjBmMFxcXFx1MmQ4MS1cXFxcdTJkOTZcXFxcdTJkZTAtXFxcXHUyZGZmXFxcXHUzMDIxLVxcXFx1MzAyOFxcXFx1MzA5OVxcXFx1MzA5YVxcXFx1YTY0MC1cXFxcdWE2NmRcXFxcdWE2NzQtXFxcXHVhNjdkXFxcXHVhNjlmXFxcXHVhNmYwLVxcXFx1YTZmMVxcXFx1YTdmOC1cXFxcdWE4MDBcXFxcdWE4MDZcXFxcdWE4MGJcXFxcdWE4MjMtXFxcXHVhODI3XFxcXHVhODgwLVxcXFx1YTg4MVxcXFx1YThiNC1cXFxcdWE4YzRcXFxcdWE4ZDAtXFxcXHVhOGQ5XFxcXHVhOGYzLVxcXFx1YThmN1xcXFx1YTkwMC1cXFxcdWE5MDlcXFxcdWE5MjYtXFxcXHVhOTJkXFxcXHVhOTMwLVxcXFx1YTk0NVxcXFx1YTk4MC1cXFxcdWE5ODNcXFxcdWE5YjMtXFxcXHVhOWMwXFxcXHVhYTAwLVxcXFx1YWEyN1xcXFx1YWE0MC1cXFxcdWFhNDFcXFxcdWFhNGMtXFxcXHVhYTRkXFxcXHVhYTUwLVxcXFx1YWE1OVxcXFx1YWE3YlxcXFx1YWFlMC1cXFxcdWFhZTlcXFxcdWFhZjItXFxcXHVhYWYzXFxcXHVhYmMwLVxcXFx1YWJlMVxcXFx1YWJlY1xcXFx1YWJlZFxcXFx1YWJmMC1cXFxcdWFiZjlcXFxcdWZiMjAtXFxcXHVmYjI4XFxcXHVmZTAwLVxcXFx1ZmUwZlxcXFx1ZmUyMC1cXFxcdWZlMjZcXFxcdWZlMzNcXFxcdWZlMzRcXFxcdWZlNGQtXFxcXHVmZTRmXFxcXHVmZjEwLVxcXFx1ZmYxOVxcXFx1ZmYzZlwiO1xuLy92YXIgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnQgPSBuZXcgUmVnRXhwKFwiW1wiICsgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyArIFwiXVwiKTtcbi8vdmFyIG5vbkFTQ0lJaWRlbnRpZmllciA9IG5ldyBSZWdFeHAoXCJbXCIgKyBub25BU0NJSWlkZW50aWZpZXJTdGFydENoYXJzICsgbm9uQVNDSUlpZGVudGlmaWVyQ2hhcnMgKyBcIl1cIik7XG5cbnZhciBpZGVudGlmaWVyU3RhcnQgPSBcIig/OlxcXFxcXFxcdVswLTlhLWZBLUZdezR9fFtcIiArIGJhc2VBU0NJSWlkZW50aWZpZXJTdGFydENoYXJzICsgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyArIFwiXSlcIjtcbnZhciBpZGVudGlmaWVyQ2hhcnMgPSBcIig/OlxcXFxcXFxcdVswLTlhLWZBLUZdezR9fFtcIiArIGJhc2VBU0NJSWlkZW50aWZpZXJDaGFycyArIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMgKyBub25BU0NJSWlkZW50aWZpZXJDaGFycyArIFwiXSkqXCI7XG5cbmV4cG9ydHMuaWRlbnRpZmllciA9IG5ldyBSZWdFeHAoaWRlbnRpZmllclN0YXJ0ICsgaWRlbnRpZmllckNoYXJzLCAnZycpO1xuZXhwb3J0cy5pZGVudGlmaWVyU3RhcnQgPSBuZXcgUmVnRXhwKGlkZW50aWZpZXJTdGFydCk7XG5leHBvcnRzLmlkZW50aWZpZXJNYXRjaCA9IG5ldyBSZWdFeHAoXCIoPzpcXFxcXFxcXHVbMC05YS1mQS1GXXs0fXxbXCIgKyBiYXNlQVNDSUlpZGVudGlmaWVyQ2hhcnMgKyBub25BU0NJSWlkZW50aWZpZXJTdGFydENoYXJzICsgbm9uQVNDSUlpZGVudGlmaWVyQ2hhcnMgKyBcIl0pK1wiKTtcblxudmFyIG5vbkFTQ0lJd2hpdGVzcGFjZSA9IC9bXFx1MTY4MFxcdTE4MGVcXHUyMDAwLVxcdTIwMGFcXHUyMDJmXFx1MjA1ZlxcdTMwMDBcXHVmZWZmXS87IC8vIGpzaGludCBpZ25vcmU6bGluZVxuXG4vLyBXaGV0aGVyIGEgc2luZ2xlIGNoYXJhY3RlciBkZW5vdGVzIGEgbmV3bGluZS5cblxuZXhwb3J0cy5uZXdsaW5lID0gL1tcXG5cXHJcXHUyMDI4XFx1MjAyOV0vO1xuXG4vLyBNYXRjaGVzIGEgd2hvbGUgbGluZSBicmVhayAod2hlcmUgQ1JMRiBpcyBjb25zaWRlcmVkIGEgc2luZ2xlXG4vLyBsaW5lIGJyZWFrKS4gVXNlZCB0byBjb3VudCBsaW5lcy5cblxuLy8gaW4gamF2YXNjcmlwdCwgdGhlc2UgdHdvIGRpZmZlclxuLy8gaW4gcHl0aG9uIHRoZXkgYXJlIHRoZSBzYW1lLCBkaWZmZXJlbnQgbWV0aG9kcyBhcmUgY2FsbGVkIG9uIHRoZW1cbmV4cG9ydHMubGluZUJyZWFrID0gbmV3IFJlZ0V4cCgnXFxyXFxufCcgKyBleHBvcnRzLm5ld2xpbmUuc291cmNlKTtcbmV4cG9ydHMuYWxsTGluZUJyZWFrcyA9IG5ldyBSZWdFeHAoZXhwb3J0cy5saW5lQnJlYWsuc291cmNlLCAnZycpO1xuXG5cbi8qKiovIH0pLFxuLyogNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qanNoaW50IG5vZGU6dHJ1ZSAqL1xuLypcblxuICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxOCBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgU09GVFdBUkUuXG4qL1xuXG5cblxudmFyIEJhc2VPcHRpb25zID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KS5PcHRpb25zO1xuXG52YXIgdmFsaWRQb3NpdGlvblZhbHVlcyA9IFsnYmVmb3JlLW5ld2xpbmUnLCAnYWZ0ZXItbmV3bGluZScsICdwcmVzZXJ2ZS1uZXdsaW5lJ107XG5cbmZ1bmN0aW9uIE9wdGlvbnMob3B0aW9ucykge1xuICBCYXNlT3B0aW9ucy5jYWxsKHRoaXMsIG9wdGlvbnMsICdqcycpO1xuXG4gIC8vIGNvbXBhdGliaWxpdHksIHJlXG4gIHZhciByYXdfYnJhY2Vfc3R5bGUgPSB0aGlzLnJhd19vcHRpb25zLmJyYWNlX3N0eWxlIHx8IG51bGw7XG4gIGlmIChyYXdfYnJhY2Vfc3R5bGUgPT09IFwiZXhwYW5kLXN0cmljdFwiKSB7IC8vZ3JhY2VmdWwgaGFuZGxpbmcgb2YgZGVwcmVjYXRlZCBvcHRpb25cbiAgICB0aGlzLnJhd19vcHRpb25zLmJyYWNlX3N0eWxlID0gXCJleHBhbmRcIjtcbiAgfSBlbHNlIGlmIChyYXdfYnJhY2Vfc3R5bGUgPT09IFwiY29sbGFwc2UtcHJlc2VydmUtaW5saW5lXCIpIHsgLy9ncmFjZWZ1bCBoYW5kbGluZyBvZiBkZXByZWNhdGVkIG9wdGlvblxuICAgIHRoaXMucmF3X29wdGlvbnMuYnJhY2Vfc3R5bGUgPSBcImNvbGxhcHNlLHByZXNlcnZlLWlubGluZVwiO1xuICB9IGVsc2UgaWYgKHRoaXMucmF3X29wdGlvbnMuYnJhY2VzX29uX293bl9saW5lICE9PSB1bmRlZmluZWQpIHsgLy9ncmFjZWZ1bCBoYW5kbGluZyBvZiBkZXByZWNhdGVkIG9wdGlvblxuICAgIHRoaXMucmF3X29wdGlvbnMuYnJhY2Vfc3R5bGUgPSB0aGlzLnJhd19vcHRpb25zLmJyYWNlc19vbl9vd25fbGluZSA/IFwiZXhwYW5kXCIgOiBcImNvbGxhcHNlXCI7XG4gICAgLy8gfSBlbHNlIGlmICghcmF3X2JyYWNlX3N0eWxlKSB7IC8vTm90aGluZyBleGlzdHMgdG8gc2V0IGl0XG4gICAgLy8gICByYXdfYnJhY2Vfc3R5bGUgPSBcImNvbGxhcHNlXCI7XG4gIH1cblxuICAvL3ByZXNlcnZlLWlubGluZSBpbiBkZWxpbWl0ZWQgc3RyaW5nIHdpbGwgdHJpZ2dlciBicmFjZV9wcmVzZXJ2ZV9pbmxpbmUsIGV2ZXJ5dGhpbmdcbiAgLy9lbHNlIGlzIGNvbnNpZGVyZWQgYSBicmFjZV9zdHlsZSBhbmQgdGhlIGxhc3Qgb25lIG9ubHkgd2lsbCBoYXZlIGFuIGVmZmVjdFxuXG4gIHZhciBicmFjZV9zdHlsZV9zcGxpdCA9IHRoaXMuX2dldF9zZWxlY3Rpb25fbGlzdCgnYnJhY2Vfc3R5bGUnLCBbJ2NvbGxhcHNlJywgJ2V4cGFuZCcsICdlbmQtZXhwYW5kJywgJ25vbmUnLCAncHJlc2VydmUtaW5saW5lJ10pO1xuXG4gIHRoaXMuYnJhY2VfcHJlc2VydmVfaW5saW5lID0gZmFsc2U7IC8vRGVmYXVsdHMgaW4gY2FzZSBvbmUgb3Igb3RoZXIgd2FzIG5vdCBzcGVjaWZpZWQgaW4gbWV0YS1vcHRpb25cbiAgdGhpcy5icmFjZV9zdHlsZSA9IFwiY29sbGFwc2VcIjtcblxuICBmb3IgKHZhciBicyA9IDA7IGJzIDwgYnJhY2Vfc3R5bGVfc3BsaXQubGVuZ3RoOyBicysrKSB7XG4gICAgaWYgKGJyYWNlX3N0eWxlX3NwbGl0W2JzXSA9PT0gXCJwcmVzZXJ2ZS1pbmxpbmVcIikge1xuICAgICAgdGhpcy5icmFjZV9wcmVzZXJ2ZV9pbmxpbmUgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmJyYWNlX3N0eWxlID0gYnJhY2Vfc3R5bGVfc3BsaXRbYnNdO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMudW5pbmRlbnRfY2hhaW5lZF9tZXRob2RzID0gdGhpcy5fZ2V0X2Jvb2xlYW4oJ3VuaW5kZW50X2NoYWluZWRfbWV0aG9kcycpO1xuICB0aGlzLmJyZWFrX2NoYWluZWRfbWV0aG9kcyA9IHRoaXMuX2dldF9ib29sZWFuKCdicmVha19jaGFpbmVkX21ldGhvZHMnKTtcbiAgdGhpcy5zcGFjZV9pbl9wYXJlbiA9IHRoaXMuX2dldF9ib29sZWFuKCdzcGFjZV9pbl9wYXJlbicpO1xuICB0aGlzLnNwYWNlX2luX2VtcHR5X3BhcmVuID0gdGhpcy5fZ2V0X2Jvb2xlYW4oJ3NwYWNlX2luX2VtcHR5X3BhcmVuJyk7XG4gIHRoaXMuanNsaW50X2hhcHB5ID0gdGhpcy5fZ2V0X2Jvb2xlYW4oJ2pzbGludF9oYXBweScpO1xuICB0aGlzLnNwYWNlX2FmdGVyX2Fub25fZnVuY3Rpb24gPSB0aGlzLl9nZXRfYm9vbGVhbignc3BhY2VfYWZ0ZXJfYW5vbl9mdW5jdGlvbicpO1xuICB0aGlzLnNwYWNlX2FmdGVyX25hbWVkX2Z1bmN0aW9uID0gdGhpcy5fZ2V0X2Jvb2xlYW4oJ3NwYWNlX2FmdGVyX25hbWVkX2Z1bmN0aW9uJyk7XG4gIHRoaXMua2VlcF9hcnJheV9pbmRlbnRhdGlvbiA9IHRoaXMuX2dldF9ib29sZWFuKCdrZWVwX2FycmF5X2luZGVudGF0aW9uJyk7XG4gIHRoaXMuc3BhY2VfYmVmb3JlX2NvbmRpdGlvbmFsID0gdGhpcy5fZ2V0X2Jvb2xlYW4oJ3NwYWNlX2JlZm9yZV9jb25kaXRpb25hbCcsIHRydWUpO1xuICB0aGlzLnVuZXNjYXBlX3N0cmluZ3MgPSB0aGlzLl9nZXRfYm9vbGVhbigndW5lc2NhcGVfc3RyaW5ncycpO1xuICB0aGlzLmU0eCA9IHRoaXMuX2dldF9ib29sZWFuKCdlNHgnKTtcbiAgdGhpcy5jb21tYV9maXJzdCA9IHRoaXMuX2dldF9ib29sZWFuKCdjb21tYV9maXJzdCcpO1xuICB0aGlzLm9wZXJhdG9yX3Bvc2l0aW9uID0gdGhpcy5fZ2V0X3NlbGVjdGlvbignb3BlcmF0b3JfcG9zaXRpb24nLCB2YWxpZFBvc2l0aW9uVmFsdWVzKTtcblxuICAvLyBGb3IgdGVzdGluZyBvZiBiZWF1dGlmeSBwcmVzZXJ2ZTpzdGFydCBkaXJlY3RpdmVcbiAgdGhpcy50ZXN0X291dHB1dF9yYXcgPSB0aGlzLl9nZXRfYm9vbGVhbigndGVzdF9vdXRwdXRfcmF3Jyk7XG5cbiAgLy8gZm9yY2UgdGhpcy5fb3B0aW9ucy5zcGFjZV9hZnRlcl9hbm9uX2Z1bmN0aW9uIHRvIHRydWUgaWYgdGhpcy5fb3B0aW9ucy5qc2xpbnRfaGFwcHlcbiAgaWYgKHRoaXMuanNsaW50X2hhcHB5KSB7XG4gICAgdGhpcy5zcGFjZV9hZnRlcl9hbm9uX2Z1bmN0aW9uID0gdHJ1ZTtcbiAgfVxuXG59XG5PcHRpb25zLnByb3RvdHlwZSA9IG5ldyBCYXNlT3B0aW9ucygpO1xuXG5cblxubW9kdWxlLmV4cG9ydHMuT3B0aW9ucyA9IE9wdGlvbnM7XG5cblxuLyoqKi8gfSksXG4vKiA2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLypqc2hpbnQgbm9kZTp0cnVlICovXG4vKlxuXG4gIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4gIENvcHlyaWdodCAoYykgMjAwNy0yMDE4IEVpbmFyIExpZWxtYW5pcywgTGlhbSBOZXdtYW4sIGFuZCBjb250cmlidXRvcnMuXG5cbiAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICBTT0ZUV0FSRS5cbiovXG5cblxuXG5mdW5jdGlvbiBPcHRpb25zKG9wdGlvbnMsIG1lcmdlX2NoaWxkX2ZpZWxkKSB7XG4gIHRoaXMucmF3X29wdGlvbnMgPSBfbWVyZ2VPcHRzKG9wdGlvbnMsIG1lcmdlX2NoaWxkX2ZpZWxkKTtcblxuICAvLyBTdXBwb3J0IHBhc3NpbmcgdGhlIHNvdXJjZSB0ZXh0IGJhY2sgd2l0aCBubyBjaGFuZ2VcbiAgdGhpcy5kaXNhYmxlZCA9IHRoaXMuX2dldF9ib29sZWFuKCdkaXNhYmxlZCcpO1xuXG4gIHRoaXMuZW9sID0gdGhpcy5fZ2V0X2NoYXJhY3RlcnMoJ2VvbCcsICdhdXRvJyk7XG4gIHRoaXMuZW5kX3dpdGhfbmV3bGluZSA9IHRoaXMuX2dldF9ib29sZWFuKCdlbmRfd2l0aF9uZXdsaW5lJyk7XG4gIHRoaXMuaW5kZW50X3NpemUgPSB0aGlzLl9nZXRfbnVtYmVyKCdpbmRlbnRfc2l6ZScsIDQpO1xuICB0aGlzLmluZGVudF9jaGFyID0gdGhpcy5fZ2V0X2NoYXJhY3RlcnMoJ2luZGVudF9jaGFyJywgJyAnKTtcbiAgdGhpcy5pbmRlbnRfbGV2ZWwgPSB0aGlzLl9nZXRfbnVtYmVyKCdpbmRlbnRfbGV2ZWwnKTtcblxuICB0aGlzLnByZXNlcnZlX25ld2xpbmVzID0gdGhpcy5fZ2V0X2Jvb2xlYW4oJ3ByZXNlcnZlX25ld2xpbmVzJywgdHJ1ZSk7XG4gIHRoaXMubWF4X3ByZXNlcnZlX25ld2xpbmVzID0gdGhpcy5fZ2V0X251bWJlcignbWF4X3ByZXNlcnZlX25ld2xpbmVzJywgMzI3ODYpO1xuICBpZiAoIXRoaXMucHJlc2VydmVfbmV3bGluZXMpIHtcbiAgICB0aGlzLm1heF9wcmVzZXJ2ZV9uZXdsaW5lcyA9IDA7XG4gIH1cblxuICB0aGlzLmluZGVudF93aXRoX3RhYnMgPSB0aGlzLl9nZXRfYm9vbGVhbignaW5kZW50X3dpdGhfdGFicycsIHRoaXMuaW5kZW50X2NoYXIgPT09ICdcXHQnKTtcbiAgaWYgKHRoaXMuaW5kZW50X3dpdGhfdGFicykge1xuICAgIHRoaXMuaW5kZW50X2NoYXIgPSAnXFx0JztcblxuICAgIC8vIGluZGVudF9zaXplIGJlaGF2aW9yIGNoYW5nZWQgYWZ0ZXIgMS44LjZcbiAgICAvLyBJdCB1c2VkIHRvIGJlIHRoYXQgaW5kZW50X3NpemUgd291bGQgYmVcbiAgICAvLyBzZXQgdG8gMSBmb3IgaW5kZW50X3dpdGhfdGFicy4gVGhhdCBpcyBubyBsb25nZXIgbmVlZGVkIGFuZFxuICAgIC8vIGFjdHVhbGx5IGRvZXNuJ3QgbWFrZSBzZW5zZSAtIHdoeSBub3QgdXNlIHNwYWNlcz8gRnVydGhlcixcbiAgICAvLyB0aGF0IG1pZ2h0IHByb2R1Y2UgdW5leHBlY3RlZCBiZWhhdmlvciAtIHRhYnMgYmVpbmcgdXNlZFxuICAgIC8vIGZvciBzaW5nbGUtY29sdW1uIGFsaWdubWVudC4gU28sIHdoZW4gaW5kZW50X3dpdGhfdGFicyBpcyB0cnVlXG4gICAgLy8gYW5kIGluZGVudF9zaXplIGlzIDEsIHJlc2V0IGluZGVudF9zaXplIHRvIDQuXG4gICAgaWYgKHRoaXMuaW5kZW50X3NpemUgPT09IDEpIHtcbiAgICAgIHRoaXMuaW5kZW50X3NpemUgPSA0O1xuICAgIH1cbiAgfVxuXG4gIC8vIEJhY2t3YXJkcyBjb21wYXQgd2l0aCAxLjMueFxuICB0aGlzLndyYXBfbGluZV9sZW5ndGggPSB0aGlzLl9nZXRfbnVtYmVyKCd3cmFwX2xpbmVfbGVuZ3RoJywgdGhpcy5fZ2V0X251bWJlcignbWF4X2NoYXInKSk7XG5cbiAgdGhpcy5pbmRlbnRfZW1wdHlfbGluZXMgPSB0aGlzLl9nZXRfYm9vbGVhbignaW5kZW50X2VtcHR5X2xpbmVzJyk7XG5cbiAgLy8gdmFsaWQgdGVtcGxhdGluZyBsYW5ndWFnZXMgWydkamFuZ28nLCAnZXJiJywgJ2hhbmRsZWJhcnMnLCAncGhwJ11cbiAgLy8gRm9yIG5vdywgJ2F1dG8nID0gYWxsIG9mZiBmb3IgamF2YXNjcmlwdCwgYWxsIG9uIGZvciBodG1sIChhbmQgaW5saW5lIGphdmFzY3JpcHQpLlxuICAvLyBvdGhlciB2YWx1ZXMgaWdub3JlZFxuICB0aGlzLnRlbXBsYXRpbmcgPSB0aGlzLl9nZXRfc2VsZWN0aW9uX2xpc3QoJ3RlbXBsYXRpbmcnLCBbJ2F1dG8nLCAnbm9uZScsICdkamFuZ28nLCAnZXJiJywgJ2hhbmRsZWJhcnMnLCAncGhwJ10sIFsnYXV0byddKTtcbn1cblxuT3B0aW9ucy5wcm90b3R5cGUuX2dldF9hcnJheSA9IGZ1bmN0aW9uKG5hbWUsIGRlZmF1bHRfdmFsdWUpIHtcbiAgdmFyIG9wdGlvbl92YWx1ZSA9IHRoaXMucmF3X29wdGlvbnNbbmFtZV07XG4gIHZhciByZXN1bHQgPSBkZWZhdWx0X3ZhbHVlIHx8IFtdO1xuICBpZiAodHlwZW9mIG9wdGlvbl92YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICBpZiAob3B0aW9uX3ZhbHVlICE9PSBudWxsICYmIHR5cGVvZiBvcHRpb25fdmFsdWUuY29uY2F0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXN1bHQgPSBvcHRpb25fdmFsdWUuY29uY2F0KCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25fdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmVzdWx0ID0gb3B0aW9uX3ZhbHVlLnNwbGl0KC9bXmEtekEtWjAtOV9cXC9cXC1dKy8pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5PcHRpb25zLnByb3RvdHlwZS5fZ2V0X2Jvb2xlYW4gPSBmdW5jdGlvbihuYW1lLCBkZWZhdWx0X3ZhbHVlKSB7XG4gIHZhciBvcHRpb25fdmFsdWUgPSB0aGlzLnJhd19vcHRpb25zW25hbWVdO1xuICB2YXIgcmVzdWx0ID0gb3B0aW9uX3ZhbHVlID09PSB1bmRlZmluZWQgPyAhIWRlZmF1bHRfdmFsdWUgOiAhIW9wdGlvbl92YWx1ZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbk9wdGlvbnMucHJvdG90eXBlLl9nZXRfY2hhcmFjdGVycyA9IGZ1bmN0aW9uKG5hbWUsIGRlZmF1bHRfdmFsdWUpIHtcbiAgdmFyIG9wdGlvbl92YWx1ZSA9IHRoaXMucmF3X29wdGlvbnNbbmFtZV07XG4gIHZhciByZXN1bHQgPSBkZWZhdWx0X3ZhbHVlIHx8ICcnO1xuICBpZiAodHlwZW9mIG9wdGlvbl92YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXN1bHQgPSBvcHRpb25fdmFsdWUucmVwbGFjZSgvXFxcXHIvLCAnXFxyJykucmVwbGFjZSgvXFxcXG4vLCAnXFxuJykucmVwbGFjZSgvXFxcXHQvLCAnXFx0Jyk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbk9wdGlvbnMucHJvdG90eXBlLl9nZXRfbnVtYmVyID0gZnVuY3Rpb24obmFtZSwgZGVmYXVsdF92YWx1ZSkge1xuICB2YXIgb3B0aW9uX3ZhbHVlID0gdGhpcy5yYXdfb3B0aW9uc1tuYW1lXTtcbiAgZGVmYXVsdF92YWx1ZSA9IHBhcnNlSW50KGRlZmF1bHRfdmFsdWUsIDEwKTtcbiAgaWYgKGlzTmFOKGRlZmF1bHRfdmFsdWUpKSB7XG4gICAgZGVmYXVsdF92YWx1ZSA9IDA7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IHBhcnNlSW50KG9wdGlvbl92YWx1ZSwgMTApO1xuICBpZiAoaXNOYU4ocmVzdWx0KSkge1xuICAgIHJlc3VsdCA9IGRlZmF1bHRfdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbk9wdGlvbnMucHJvdG90eXBlLl9nZXRfc2VsZWN0aW9uID0gZnVuY3Rpb24obmFtZSwgc2VsZWN0aW9uX2xpc3QsIGRlZmF1bHRfdmFsdWUpIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMuX2dldF9zZWxlY3Rpb25fbGlzdChuYW1lLCBzZWxlY3Rpb25fbGlzdCwgZGVmYXVsdF92YWx1ZSk7XG4gIGlmIChyZXN1bHQubGVuZ3RoICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJJbnZhbGlkIE9wdGlvbiBWYWx1ZTogVGhlIG9wdGlvbiAnXCIgKyBuYW1lICsgXCInIGNhbiBvbmx5IGJlIG9uZSBvZiB0aGUgZm9sbG93aW5nIHZhbHVlczpcXG5cIiArXG4gICAgICBzZWxlY3Rpb25fbGlzdCArIFwiXFxuWW91IHBhc3NlZCBpbjogJ1wiICsgdGhpcy5yYXdfb3B0aW9uc1tuYW1lXSArIFwiJ1wiKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHRbMF07XG59O1xuXG5cbk9wdGlvbnMucHJvdG90eXBlLl9nZXRfc2VsZWN0aW9uX2xpc3QgPSBmdW5jdGlvbihuYW1lLCBzZWxlY3Rpb25fbGlzdCwgZGVmYXVsdF92YWx1ZSkge1xuICBpZiAoIXNlbGVjdGlvbl9saXN0IHx8IHNlbGVjdGlvbl9saXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlNlbGVjdGlvbiBsaXN0IGNhbm5vdCBiZSBlbXB0eS5cIik7XG4gIH1cblxuICBkZWZhdWx0X3ZhbHVlID0gZGVmYXVsdF92YWx1ZSB8fCBbc2VsZWN0aW9uX2xpc3RbMF1dO1xuICBpZiAoIXRoaXMuX2lzX3ZhbGlkX3NlbGVjdGlvbihkZWZhdWx0X3ZhbHVlLCBzZWxlY3Rpb25fbGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIERlZmF1bHQgVmFsdWUhXCIpO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IHRoaXMuX2dldF9hcnJheShuYW1lLCBkZWZhdWx0X3ZhbHVlKTtcbiAgaWYgKCF0aGlzLl9pc192YWxpZF9zZWxlY3Rpb24ocmVzdWx0LCBzZWxlY3Rpb25fbGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIkludmFsaWQgT3B0aW9uIFZhbHVlOiBUaGUgb3B0aW9uICdcIiArIG5hbWUgKyBcIicgY2FuIGNvbnRhaW4gb25seSB0aGUgZm9sbG93aW5nIHZhbHVlczpcXG5cIiArXG4gICAgICBzZWxlY3Rpb25fbGlzdCArIFwiXFxuWW91IHBhc3NlZCBpbjogJ1wiICsgdGhpcy5yYXdfb3B0aW9uc1tuYW1lXSArIFwiJ1wiKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5PcHRpb25zLnByb3RvdHlwZS5faXNfdmFsaWRfc2VsZWN0aW9uID0gZnVuY3Rpb24ocmVzdWx0LCBzZWxlY3Rpb25fbGlzdCkge1xuICByZXR1cm4gcmVzdWx0Lmxlbmd0aCAmJiBzZWxlY3Rpb25fbGlzdC5sZW5ndGggJiZcbiAgICAhcmVzdWx0LnNvbWUoZnVuY3Rpb24oaXRlbSkgeyByZXR1cm4gc2VsZWN0aW9uX2xpc3QuaW5kZXhPZihpdGVtKSA9PT0gLTE7IH0pO1xufTtcblxuXG4vLyBtZXJnZXMgY2hpbGQgb3B0aW9ucyB1cCB3aXRoIHRoZSBwYXJlbnQgb3B0aW9ucyBvYmplY3Rcbi8vIEV4YW1wbGU6IG9iaiA9IHthOiAxLCBiOiB7YTogMn19XG4vLyAgICAgICAgICBtZXJnZU9wdHMob2JqLCAnYicpXG4vL1xuLy8gICAgICAgICAgUmV0dXJuczoge2E6IDJ9XG5mdW5jdGlvbiBfbWVyZ2VPcHRzKGFsbE9wdGlvbnMsIGNoaWxkRmllbGROYW1lKSB7XG4gIHZhciBmaW5hbE9wdHMgPSB7fTtcbiAgYWxsT3B0aW9ucyA9IF9ub3JtYWxpemVPcHRzKGFsbE9wdGlvbnMpO1xuICB2YXIgbmFtZTtcblxuICBmb3IgKG5hbWUgaW4gYWxsT3B0aW9ucykge1xuICAgIGlmIChuYW1lICE9PSBjaGlsZEZpZWxkTmFtZSkge1xuICAgICAgZmluYWxPcHRzW25hbWVdID0gYWxsT3B0aW9uc1tuYW1lXTtcbiAgICB9XG4gIH1cblxuICAvL21lcmdlIGluIHRoZSBwZXIgdHlwZSBzZXR0aW5ncyBmb3IgdGhlIGNoaWxkRmllbGROYW1lXG4gIGlmIChjaGlsZEZpZWxkTmFtZSAmJiBhbGxPcHRpb25zW2NoaWxkRmllbGROYW1lXSkge1xuICAgIGZvciAobmFtZSBpbiBhbGxPcHRpb25zW2NoaWxkRmllbGROYW1lXSkge1xuICAgICAgZmluYWxPcHRzW25hbWVdID0gYWxsT3B0aW9uc1tjaGlsZEZpZWxkTmFtZV1bbmFtZV07XG4gICAgfVxuICB9XG4gIHJldHVybiBmaW5hbE9wdHM7XG59XG5cbmZ1bmN0aW9uIF9ub3JtYWxpemVPcHRzKG9wdGlvbnMpIHtcbiAgdmFyIGNvbnZlcnRlZE9wdHMgPSB7fTtcbiAgdmFyIGtleTtcblxuICBmb3IgKGtleSBpbiBvcHRpb25zKSB7XG4gICAgdmFyIG5ld0tleSA9IGtleS5yZXBsYWNlKC8tL2csIFwiX1wiKTtcbiAgICBjb252ZXJ0ZWRPcHRzW25ld0tleV0gPSBvcHRpb25zW2tleV07XG4gIH1cbiAgcmV0dXJuIGNvbnZlcnRlZE9wdHM7XG59XG5cbm1vZHVsZS5leHBvcnRzLk9wdGlvbnMgPSBPcHRpb25zO1xubW9kdWxlLmV4cG9ydHMubm9ybWFsaXplT3B0cyA9IF9ub3JtYWxpemVPcHRzO1xubW9kdWxlLmV4cG9ydHMubWVyZ2VPcHRzID0gX21lcmdlT3B0cztcblxuXG4vKioqLyB9KSxcbi8qIDcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKmpzaGludCBub2RlOnRydWUgKi9cbi8qXG5cbiAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiAgQ29weXJpZ2h0IChjKSAyMDA3LTIwMTggRWluYXIgTGllbG1hbmlzLCBMaWFtIE5ld21hbiwgYW5kIGNvbnRyaWJ1dG9ycy5cblxuICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gIFNPRlRXQVJFLlxuKi9cblxuXG5cbnZhciBJbnB1dFNjYW5uZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpLklucHV0U2Nhbm5lcjtcbnZhciBCYXNlVG9rZW5pemVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KS5Ub2tlbml6ZXI7XG52YXIgQkFTRVRPS0VOID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KS5UT0tFTjtcbnZhciBEaXJlY3RpdmVzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMykuRGlyZWN0aXZlcztcbnZhciBhY29ybiA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG52YXIgUGF0dGVybiA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpLlBhdHRlcm47XG52YXIgVGVtcGxhdGFibGVQYXR0ZXJuID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCkuVGVtcGxhdGFibGVQYXR0ZXJuO1xuXG5cbmZ1bmN0aW9uIGluX2FycmF5KHdoYXQsIGFycikge1xuICByZXR1cm4gYXJyLmluZGV4T2Yod2hhdCkgIT09IC0xO1xufVxuXG5cbnZhciBUT0tFTiA9IHtcbiAgU1RBUlRfRVhQUjogJ1RLX1NUQVJUX0VYUFInLFxuICBFTkRfRVhQUjogJ1RLX0VORF9FWFBSJyxcbiAgU1RBUlRfQkxPQ0s6ICdUS19TVEFSVF9CTE9DSycsXG4gIEVORF9CTE9DSzogJ1RLX0VORF9CTE9DSycsXG4gIFdPUkQ6ICdUS19XT1JEJyxcbiAgUkVTRVJWRUQ6ICdUS19SRVNFUlZFRCcsXG4gIFNFTUlDT0xPTjogJ1RLX1NFTUlDT0xPTicsXG4gIFNUUklORzogJ1RLX1NUUklORycsXG4gIEVRVUFMUzogJ1RLX0VRVUFMUycsXG4gIE9QRVJBVE9SOiAnVEtfT1BFUkFUT1InLFxuICBDT01NQTogJ1RLX0NPTU1BJyxcbiAgQkxPQ0tfQ09NTUVOVDogJ1RLX0JMT0NLX0NPTU1FTlQnLFxuICBDT01NRU5UOiAnVEtfQ09NTUVOVCcsXG4gIERPVDogJ1RLX0RPVCcsXG4gIFVOS05PV046ICdUS19VTktOT1dOJyxcbiAgU1RBUlQ6IEJBU0VUT0tFTi5TVEFSVCxcbiAgUkFXOiBCQVNFVE9LRU4uUkFXLFxuICBFT0Y6IEJBU0VUT0tFTi5FT0Zcbn07XG5cblxudmFyIGRpcmVjdGl2ZXNfY29yZSA9IG5ldyBEaXJlY3RpdmVzKC9cXC9cXCovLCAvXFwqXFwvLyk7XG5cbnZhciBudW1iZXJfcGF0dGVybiA9IC8wW3hYXVswMTIzNDU2Nzg5YWJjZGVmQUJDREVGXSp8MFtvT11bMDEyMzQ1NjddKnwwW2JCXVswMV0qfFxcZCtufCg/OlxcLlxcZCt8XFxkK1xcLj9cXGQqKSg/OltlRV1bKy1dP1xcZCspPy87XG5cbnZhciBkaWdpdCA9IC9bMC05XS87XG5cbi8vIERvdCBcIi5cIiBtdXN0IGJlIGRpc3Rpbmd1aXNoZWQgZnJvbSBcIi4uLlwiIGFuZCBkZWNpbWFsXG52YXIgZG90X3BhdHRlcm4gPSAvW15cXGRcXC5dLztcblxudmFyIHBvc2l0aW9uYWJsZV9vcGVyYXRvcnMgPSAoXG4gIFwiPj4+ID09PSAhPT0gXCIgK1xuICBcIjw8ICYmID49ICoqICE9ID09IDw9ID4+IHx8ID8/IHw+IFwiICtcbiAgXCI8IC8gLSArID4gOiAmICUgPyBeIHwgKlwiKS5zcGxpdCgnICcpO1xuXG4vLyBJTVBPUlRBTlQ6IHRoaXMgbXVzdCBiZSBzb3J0ZWQgbG9uZ2VzdCB0byBzaG9ydGVzdCBvciB0b2tlbml6aW5nIG1hbnkgbm90IHdvcmsuXG4vLyBBbHNvLCB5b3UgbXVzdCB1cGRhdGUgcG9zc2l0aW9uYWJsZSBvcGVyYXRvcnMgc2VwYXJhdGVseSBmcm9tIHB1bmN0XG52YXIgcHVuY3QgPVxuICBcIj4+Pj0gXCIgK1xuICBcIi4uLiA+Pj0gPDw9ID09PSA+Pj4gIT09ICoqPSBcIiArXG4gIFwiPT4gXj0gOjogLz0gPDwgPD0gPT0gJiYgLT0gPj0gPj4gIT0gLS0gKz0gKiogfHwgPz8gKysgJT0gJj0gKj0gfD0gfD4gXCIgK1xuICBcIj0gISA/ID4gPCA6IC8gXiAtICsgKiAmICUgfiB8XCI7XG5cbnB1bmN0ID0gcHVuY3QucmVwbGFjZSgvWy1bXFxde30oKSorPy4sXFxcXF4kfCNdL2csIFwiXFxcXCQmXCIpO1xuLy8gPy4gYnV0IG5vdCBpZiBmb2xsb3dlZCBieSBhIG51bWJlciBcbnB1bmN0ID0gJ1xcXFw/XFxcXC4oPyFcXFxcZCkgJyArIHB1bmN0O1xucHVuY3QgPSBwdW5jdC5yZXBsYWNlKC8gL2csICd8Jyk7XG5cbnZhciBwdW5jdF9wYXR0ZXJuID0gbmV3IFJlZ0V4cChwdW5jdCk7XG5cbi8vIHdvcmRzIHdoaWNoIHNob3VsZCBhbHdheXMgc3RhcnQgb24gbmV3IGxpbmUuXG52YXIgbGluZV9zdGFydGVycyA9ICdjb250aW51ZSx0cnksdGhyb3cscmV0dXJuLHZhcixsZXQsY29uc3QsaWYsc3dpdGNoLGNhc2UsZGVmYXVsdCxmb3Isd2hpbGUsYnJlYWssZnVuY3Rpb24saW1wb3J0LGV4cG9ydCcuc3BsaXQoJywnKTtcbnZhciByZXNlcnZlZF93b3JkcyA9IGxpbmVfc3RhcnRlcnMuY29uY2F0KFsnZG8nLCAnaW4nLCAnb2YnLCAnZWxzZScsICdnZXQnLCAnc2V0JywgJ25ldycsICdjYXRjaCcsICdmaW5hbGx5JywgJ3R5cGVvZicsICd5aWVsZCcsICdhc3luYycsICdhd2FpdCcsICdmcm9tJywgJ2FzJ10pO1xudmFyIHJlc2VydmVkX3dvcmRfcGF0dGVybiA9IG5ldyBSZWdFeHAoJ14oPzonICsgcmVzZXJ2ZWRfd29yZHMuam9pbignfCcpICsgJykkJyk7XG5cbi8vIHZhciB0ZW1wbGF0ZV9wYXR0ZXJuID0gLyg/Oig/OjxcXD9waHB8PFxcPz0pW1xcc1xcU10qP1xcPz4pfCg/OjwlW1xcc1xcU10qPyU+KS9nO1xuXG52YXIgaW5faHRtbF9jb21tZW50O1xuXG52YXIgVG9rZW5pemVyID0gZnVuY3Rpb24oaW5wdXRfc3RyaW5nLCBvcHRpb25zKSB7XG4gIEJhc2VUb2tlbml6ZXIuY2FsbCh0aGlzLCBpbnB1dF9zdHJpbmcsIG9wdGlvbnMpO1xuXG4gIHRoaXMuX3BhdHRlcm5zLndoaXRlc3BhY2UgPSB0aGlzLl9wYXR0ZXJucy53aGl0ZXNwYWNlLm1hdGNoaW5nKFxuICAgIC9cXHUwMEEwXFx1MTY4MFxcdTE4MGVcXHUyMDAwLVxcdTIwMGFcXHUyMDJmXFx1MjA1ZlxcdTMwMDBcXHVmZWZmLy5zb3VyY2UsXG4gICAgL1xcdTIwMjhcXHUyMDI5Ly5zb3VyY2UpO1xuXG4gIHZhciBwYXR0ZXJuX3JlYWRlciA9IG5ldyBQYXR0ZXJuKHRoaXMuX2lucHV0KTtcbiAgdmFyIHRlbXBsYXRhYmxlID0gbmV3IFRlbXBsYXRhYmxlUGF0dGVybih0aGlzLl9pbnB1dClcbiAgICAucmVhZF9vcHRpb25zKHRoaXMuX29wdGlvbnMpO1xuXG4gIHRoaXMuX19wYXR0ZXJucyA9IHtcbiAgICB0ZW1wbGF0ZTogdGVtcGxhdGFibGUsXG4gICAgaWRlbnRpZmllcjogdGVtcGxhdGFibGUuc3RhcnRpbmdfd2l0aChhY29ybi5pZGVudGlmaWVyKS5tYXRjaGluZyhhY29ybi5pZGVudGlmaWVyTWF0Y2gpLFxuICAgIG51bWJlcjogcGF0dGVybl9yZWFkZXIubWF0Y2hpbmcobnVtYmVyX3BhdHRlcm4pLFxuICAgIHB1bmN0OiBwYXR0ZXJuX3JlYWRlci5tYXRjaGluZyhwdW5jdF9wYXR0ZXJuKSxcbiAgICAvLyBjb21tZW50IGVuZHMganVzdCBiZWZvcmUgbmVhcmVzdCBsaW5lZmVlZCBvciBlbmQgb2YgZmlsZVxuICAgIGNvbW1lbnQ6IHBhdHRlcm5fcmVhZGVyLnN0YXJ0aW5nX3dpdGgoL1xcL1xcLy8pLnVudGlsKC9bXFxuXFxyXFx1MjAyOFxcdTIwMjldLyksXG4gICAgLy8gIC8qIC4uLiAqLyBjb21tZW50IGVuZHMgd2l0aCBuZWFyZXN0ICovIG9yIGVuZCBvZiBmaWxlXG4gICAgYmxvY2tfY29tbWVudDogcGF0dGVybl9yZWFkZXIuc3RhcnRpbmdfd2l0aCgvXFwvXFwqLykudW50aWxfYWZ0ZXIoL1xcKlxcLy8pLFxuICAgIGh0bWxfY29tbWVudF9zdGFydDogcGF0dGVybl9yZWFkZXIubWF0Y2hpbmcoLzwhLS0vKSxcbiAgICBodG1sX2NvbW1lbnRfZW5kOiBwYXR0ZXJuX3JlYWRlci5tYXRjaGluZygvLS0+LyksXG4gICAgaW5jbHVkZTogcGF0dGVybl9yZWFkZXIuc3RhcnRpbmdfd2l0aCgvI2luY2x1ZGUvKS51bnRpbF9hZnRlcihhY29ybi5saW5lQnJlYWspLFxuICAgIHNoZWJhbmc6IHBhdHRlcm5fcmVhZGVyLnN0YXJ0aW5nX3dpdGgoLyMhLykudW50aWxfYWZ0ZXIoYWNvcm4ubGluZUJyZWFrKSxcbiAgICB4bWw6IHBhdHRlcm5fcmVhZGVyLm1hdGNoaW5nKC9bXFxzXFxTXSo/PChcXC8/KShbLWEtekEtWjowLTlfLl0rfHtbXFxzXFxTXSs/fXwhXFxbQ0RBVEFcXFtbXFxzXFxTXSo/XFxdXFxdKShcXHMre1tcXHNcXFNdKz99fFxccytbLWEtekEtWjowLTlfLl0rfFxccytbLWEtekEtWjowLTlfLl0rXFxzKj1cXHMqKCdbXiddKid8XCJbXlwiXSpcInx7W1xcc1xcU10rP30pKSpcXHMqKFxcLz8pXFxzKj4vKSxcbiAgICBzaW5nbGVfcXVvdGU6IHRlbXBsYXRhYmxlLnVudGlsKC9bJ1xcXFxcXG5cXHJcXHUyMDI4XFx1MjAyOV0vKSxcbiAgICBkb3VibGVfcXVvdGU6IHRlbXBsYXRhYmxlLnVudGlsKC9bXCJcXFxcXFxuXFxyXFx1MjAyOFxcdTIwMjldLyksXG4gICAgdGVtcGxhdGVfdGV4dDogdGVtcGxhdGFibGUudW50aWwoL1tgXFxcXCRdLyksXG4gICAgdGVtcGxhdGVfZXhwcmVzc2lvbjogdGVtcGxhdGFibGUudW50aWwoL1tgfVxcXFxdLylcbiAgfTtcblxufTtcblRva2VuaXplci5wcm90b3R5cGUgPSBuZXcgQmFzZVRva2VuaXplcigpO1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9pc19jb21tZW50ID0gZnVuY3Rpb24oY3VycmVudF90b2tlbikge1xuICByZXR1cm4gY3VycmVudF90b2tlbi50eXBlID09PSBUT0tFTi5DT01NRU5UIHx8IGN1cnJlbnRfdG9rZW4udHlwZSA9PT0gVE9LRU4uQkxPQ0tfQ09NTUVOVCB8fCBjdXJyZW50X3Rva2VuLnR5cGUgPT09IFRPS0VOLlVOS05PV047XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9pc19vcGVuaW5nID0gZnVuY3Rpb24oY3VycmVudF90b2tlbikge1xuICByZXR1cm4gY3VycmVudF90b2tlbi50eXBlID09PSBUT0tFTi5TVEFSVF9CTE9DSyB8fCBjdXJyZW50X3Rva2VuLnR5cGUgPT09IFRPS0VOLlNUQVJUX0VYUFI7XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9pc19jbG9zaW5nID0gZnVuY3Rpb24oY3VycmVudF90b2tlbiwgb3Blbl90b2tlbikge1xuICByZXR1cm4gKGN1cnJlbnRfdG9rZW4udHlwZSA9PT0gVE9LRU4uRU5EX0JMT0NLIHx8IGN1cnJlbnRfdG9rZW4udHlwZSA9PT0gVE9LRU4uRU5EX0VYUFIpICYmXG4gICAgKG9wZW5fdG9rZW4gJiYgKFxuICAgICAgKGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJ10nICYmIG9wZW5fdG9rZW4udGV4dCA9PT0gJ1snKSB8fFxuICAgICAgKGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJyknICYmIG9wZW5fdG9rZW4udGV4dCA9PT0gJygnKSB8fFxuICAgICAgKGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJ30nICYmIG9wZW5fdG9rZW4udGV4dCA9PT0gJ3snKSkpO1xufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5fcmVzZXQgPSBmdW5jdGlvbigpIHtcbiAgaW5faHRtbF9jb21tZW50ID0gZmFsc2U7XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9nZXRfbmV4dF90b2tlbiA9IGZ1bmN0aW9uKHByZXZpb3VzX3Rva2VuLCBvcGVuX3Rva2VuKSB7IC8vIGpzaGludCB1bnVzZWQ6ZmFsc2VcbiAgdmFyIHRva2VuID0gbnVsbDtcbiAgdGhpcy5fcmVhZFdoaXRlc3BhY2UoKTtcbiAgdmFyIGMgPSB0aGlzLl9pbnB1dC5wZWVrKCk7XG5cbiAgaWYgKGMgPT09IG51bGwpIHtcbiAgICByZXR1cm4gdGhpcy5fY3JlYXRlX3Rva2VuKFRPS0VOLkVPRiwgJycpO1xuICB9XG5cbiAgdG9rZW4gPSB0b2tlbiB8fCB0aGlzLl9yZWFkX25vbl9qYXZhc2NyaXB0KGMpO1xuICB0b2tlbiA9IHRva2VuIHx8IHRoaXMuX3JlYWRfc3RyaW5nKGMpO1xuICB0b2tlbiA9IHRva2VuIHx8IHRoaXMuX3JlYWRfd29yZChwcmV2aW91c190b2tlbik7XG4gIHRva2VuID0gdG9rZW4gfHwgdGhpcy5fcmVhZF9zaW5nbGVzKGMpO1xuICB0b2tlbiA9IHRva2VuIHx8IHRoaXMuX3JlYWRfY29tbWVudChjKTtcbiAgdG9rZW4gPSB0b2tlbiB8fCB0aGlzLl9yZWFkX3JlZ2V4cChjLCBwcmV2aW91c190b2tlbik7XG4gIHRva2VuID0gdG9rZW4gfHwgdGhpcy5fcmVhZF94bWwoYywgcHJldmlvdXNfdG9rZW4pO1xuICB0b2tlbiA9IHRva2VuIHx8IHRoaXMuX3JlYWRfcHVuY3R1YXRpb24oKTtcbiAgdG9rZW4gPSB0b2tlbiB8fCB0aGlzLl9jcmVhdGVfdG9rZW4oVE9LRU4uVU5LTk9XTiwgdGhpcy5faW5wdXQubmV4dCgpKTtcblxuICByZXR1cm4gdG9rZW47XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9yZWFkX3dvcmQgPSBmdW5jdGlvbihwcmV2aW91c190b2tlbikge1xuICB2YXIgcmVzdWx0aW5nX3N0cmluZztcbiAgcmVzdWx0aW5nX3N0cmluZyA9IHRoaXMuX19wYXR0ZXJucy5pZGVudGlmaWVyLnJlYWQoKTtcbiAgaWYgKHJlc3VsdGluZ19zdHJpbmcgIT09ICcnKSB7XG4gICAgcmVzdWx0aW5nX3N0cmluZyA9IHJlc3VsdGluZ19zdHJpbmcucmVwbGFjZShhY29ybi5hbGxMaW5lQnJlYWtzLCAnXFxuJyk7XG4gICAgaWYgKCEocHJldmlvdXNfdG9rZW4udHlwZSA9PT0gVE9LRU4uRE9UIHx8XG4gICAgICAgIChwcmV2aW91c190b2tlbi50eXBlID09PSBUT0tFTi5SRVNFUlZFRCAmJiAocHJldmlvdXNfdG9rZW4udGV4dCA9PT0gJ3NldCcgfHwgcHJldmlvdXNfdG9rZW4udGV4dCA9PT0gJ2dldCcpKSkgJiZcbiAgICAgIHJlc2VydmVkX3dvcmRfcGF0dGVybi50ZXN0KHJlc3VsdGluZ19zdHJpbmcpKSB7XG4gICAgICBpZiAocmVzdWx0aW5nX3N0cmluZyA9PT0gJ2luJyB8fCByZXN1bHRpbmdfc3RyaW5nID09PSAnb2YnKSB7IC8vIGhhY2sgZm9yICdpbicgYW5kICdvZicgb3BlcmF0b3JzXG4gICAgICAgIHJldHVybiB0aGlzLl9jcmVhdGVfdG9rZW4oVE9LRU4uT1BFUkFUT1IsIHJlc3VsdGluZ19zdHJpbmcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX2NyZWF0ZV90b2tlbihUT0tFTi5SRVNFUlZFRCwgcmVzdWx0aW5nX3N0cmluZyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jcmVhdGVfdG9rZW4oVE9LRU4uV09SRCwgcmVzdWx0aW5nX3N0cmluZyk7XG4gIH1cblxuICByZXN1bHRpbmdfc3RyaW5nID0gdGhpcy5fX3BhdHRlcm5zLm51bWJlci5yZWFkKCk7XG4gIGlmIChyZXN1bHRpbmdfc3RyaW5nICE9PSAnJykge1xuICAgIHJldHVybiB0aGlzLl9jcmVhdGVfdG9rZW4oVE9LRU4uV09SRCwgcmVzdWx0aW5nX3N0cmluZyk7XG4gIH1cbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX3JlYWRfc2luZ2xlcyA9IGZ1bmN0aW9uKGMpIHtcbiAgdmFyIHRva2VuID0gbnVsbDtcbiAgaWYgKGMgPT09ICcoJyB8fCBjID09PSAnWycpIHtcbiAgICB0b2tlbiA9IHRoaXMuX2NyZWF0ZV90b2tlbihUT0tFTi5TVEFSVF9FWFBSLCBjKTtcbiAgfSBlbHNlIGlmIChjID09PSAnKScgfHwgYyA9PT0gJ10nKSB7XG4gICAgdG9rZW4gPSB0aGlzLl9jcmVhdGVfdG9rZW4oVE9LRU4uRU5EX0VYUFIsIGMpO1xuICB9IGVsc2UgaWYgKGMgPT09ICd7Jykge1xuICAgIHRva2VuID0gdGhpcy5fY3JlYXRlX3Rva2VuKFRPS0VOLlNUQVJUX0JMT0NLLCBjKTtcbiAgfSBlbHNlIGlmIChjID09PSAnfScpIHtcbiAgICB0b2tlbiA9IHRoaXMuX2NyZWF0ZV90b2tlbihUT0tFTi5FTkRfQkxPQ0ssIGMpO1xuICB9IGVsc2UgaWYgKGMgPT09ICc7Jykge1xuICAgIHRva2VuID0gdGhpcy5fY3JlYXRlX3Rva2VuKFRPS0VOLlNFTUlDT0xPTiwgYyk7XG4gIH0gZWxzZSBpZiAoYyA9PT0gJy4nICYmIGRvdF9wYXR0ZXJuLnRlc3QodGhpcy5faW5wdXQucGVlaygxKSkpIHtcbiAgICB0b2tlbiA9IHRoaXMuX2NyZWF0ZV90b2tlbihUT0tFTi5ET1QsIGMpO1xuICB9IGVsc2UgaWYgKGMgPT09ICcsJykge1xuICAgIHRva2VuID0gdGhpcy5fY3JlYXRlX3Rva2VuKFRPS0VOLkNPTU1BLCBjKTtcbiAgfVxuXG4gIGlmICh0b2tlbikge1xuICAgIHRoaXMuX2lucHV0Lm5leHQoKTtcbiAgfVxuICByZXR1cm4gdG9rZW47XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9yZWFkX3B1bmN0dWF0aW9uID0gZnVuY3Rpb24oKSB7XG4gIHZhciByZXN1bHRpbmdfc3RyaW5nID0gdGhpcy5fX3BhdHRlcm5zLnB1bmN0LnJlYWQoKTtcblxuICBpZiAocmVzdWx0aW5nX3N0cmluZyAhPT0gJycpIHtcbiAgICBpZiAocmVzdWx0aW5nX3N0cmluZyA9PT0gJz0nKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY3JlYXRlX3Rva2VuKFRPS0VOLkVRVUFMUywgcmVzdWx0aW5nX3N0cmluZyk7XG4gICAgfSBlbHNlIGlmIChyZXN1bHRpbmdfc3RyaW5nID09PSAnPy4nKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY3JlYXRlX3Rva2VuKFRPS0VOLkRPVCwgcmVzdWx0aW5nX3N0cmluZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9jcmVhdGVfdG9rZW4oVE9LRU4uT1BFUkFUT1IsIHJlc3VsdGluZ19zdHJpbmcpO1xuICAgIH1cbiAgfVxufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5fcmVhZF9ub25famF2YXNjcmlwdCA9IGZ1bmN0aW9uKGMpIHtcbiAgdmFyIHJlc3VsdGluZ19zdHJpbmcgPSAnJztcblxuICBpZiAoYyA9PT0gJyMnKSB7XG4gICAgaWYgKHRoaXMuX2lzX2ZpcnN0X3Rva2VuKCkpIHtcbiAgICAgIHJlc3VsdGluZ19zdHJpbmcgPSB0aGlzLl9fcGF0dGVybnMuc2hlYmFuZy5yZWFkKCk7XG5cbiAgICAgIGlmIChyZXN1bHRpbmdfc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jcmVhdGVfdG9rZW4oVE9LRU4uVU5LTk9XTiwgcmVzdWx0aW5nX3N0cmluZy50cmltKCkgKyAnXFxuJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gaGFuZGxlcyBleHRlbmRzY3JpcHQgI2luY2x1ZGVzXG4gICAgcmVzdWx0aW5nX3N0cmluZyA9IHRoaXMuX19wYXR0ZXJucy5pbmNsdWRlLnJlYWQoKTtcblxuICAgIGlmIChyZXN1bHRpbmdfc3RyaW5nKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY3JlYXRlX3Rva2VuKFRPS0VOLlVOS05PV04sIHJlc3VsdGluZ19zdHJpbmcudHJpbSgpICsgJ1xcbicpO1xuICAgIH1cblxuICAgIGMgPSB0aGlzLl9pbnB1dC5uZXh0KCk7XG5cbiAgICAvLyBTcGlkZXJtb25rZXktc3BlY2lmaWMgc2hhcnAgdmFyaWFibGVzIGZvciBjaXJjdWxhciByZWZlcmVuY2VzLiBDb25zaWRlcmVkIG9ic29sZXRlLlxuICAgIHZhciBzaGFycCA9ICcjJztcbiAgICBpZiAodGhpcy5faW5wdXQuaGFzTmV4dCgpICYmIHRoaXMuX2lucHV0LnRlc3RDaGFyKGRpZ2l0KSkge1xuICAgICAgZG8ge1xuICAgICAgICBjID0gdGhpcy5faW5wdXQubmV4dCgpO1xuICAgICAgICBzaGFycCArPSBjO1xuICAgICAgfSB3aGlsZSAodGhpcy5faW5wdXQuaGFzTmV4dCgpICYmIGMgIT09ICcjJyAmJiBjICE9PSAnPScpO1xuICAgICAgaWYgKGMgPT09ICcjJykge1xuICAgICAgICAvL1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl9pbnB1dC5wZWVrKCkgPT09ICdbJyAmJiB0aGlzLl9pbnB1dC5wZWVrKDEpID09PSAnXScpIHtcbiAgICAgICAgc2hhcnAgKz0gJ1tdJztcbiAgICAgICAgdGhpcy5faW5wdXQubmV4dCgpO1xuICAgICAgICB0aGlzLl9pbnB1dC5uZXh0KCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2lucHV0LnBlZWsoKSA9PT0gJ3snICYmIHRoaXMuX2lucHV0LnBlZWsoMSkgPT09ICd9Jykge1xuICAgICAgICBzaGFycCArPSAne30nO1xuICAgICAgICB0aGlzLl9pbnB1dC5uZXh0KCk7XG4gICAgICAgIHRoaXMuX2lucHV0Lm5leHQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9jcmVhdGVfdG9rZW4oVE9LRU4uV09SRCwgc2hhcnApO1xuICAgIH1cblxuICAgIHRoaXMuX2lucHV0LmJhY2soKTtcblxuICB9IGVsc2UgaWYgKGMgPT09ICc8JyAmJiB0aGlzLl9pc19maXJzdF90b2tlbigpKSB7XG4gICAgcmVzdWx0aW5nX3N0cmluZyA9IHRoaXMuX19wYXR0ZXJucy5odG1sX2NvbW1lbnRfc3RhcnQucmVhZCgpO1xuICAgIGlmIChyZXN1bHRpbmdfc3RyaW5nKSB7XG4gICAgICB3aGlsZSAodGhpcy5faW5wdXQuaGFzTmV4dCgpICYmICF0aGlzLl9pbnB1dC50ZXN0Q2hhcihhY29ybi5uZXdsaW5lKSkge1xuICAgICAgICByZXN1bHRpbmdfc3RyaW5nICs9IHRoaXMuX2lucHV0Lm5leHQoKTtcbiAgICAgIH1cbiAgICAgIGluX2h0bWxfY29tbWVudCA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcy5fY3JlYXRlX3Rva2VuKFRPS0VOLkNPTU1FTlQsIHJlc3VsdGluZ19zdHJpbmcpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpbl9odG1sX2NvbW1lbnQgJiYgYyA9PT0gJy0nKSB7XG4gICAgcmVzdWx0aW5nX3N0cmluZyA9IHRoaXMuX19wYXR0ZXJucy5odG1sX2NvbW1lbnRfZW5kLnJlYWQoKTtcbiAgICBpZiAocmVzdWx0aW5nX3N0cmluZykge1xuICAgICAgaW5faHRtbF9jb21tZW50ID0gZmFsc2U7XG4gICAgICByZXR1cm4gdGhpcy5fY3JlYXRlX3Rva2VuKFRPS0VOLkNPTU1FTlQsIHJlc3VsdGluZ19zdHJpbmcpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5fcmVhZF9jb21tZW50ID0gZnVuY3Rpb24oYykge1xuICB2YXIgdG9rZW4gPSBudWxsO1xuICBpZiAoYyA9PT0gJy8nKSB7XG4gICAgdmFyIGNvbW1lbnQgPSAnJztcbiAgICBpZiAodGhpcy5faW5wdXQucGVlaygxKSA9PT0gJyonKSB7XG4gICAgICAvLyBwZWVrIGZvciBjb21tZW50IC8qIC4uLiAqL1xuICAgICAgY29tbWVudCA9IHRoaXMuX19wYXR0ZXJucy5ibG9ja19jb21tZW50LnJlYWQoKTtcbiAgICAgIHZhciBkaXJlY3RpdmVzID0gZGlyZWN0aXZlc19jb3JlLmdldF9kaXJlY3RpdmVzKGNvbW1lbnQpO1xuICAgICAgaWYgKGRpcmVjdGl2ZXMgJiYgZGlyZWN0aXZlcy5pZ25vcmUgPT09ICdzdGFydCcpIHtcbiAgICAgICAgY29tbWVudCArPSBkaXJlY3RpdmVzX2NvcmUucmVhZElnbm9yZWQodGhpcy5faW5wdXQpO1xuICAgICAgfVxuICAgICAgY29tbWVudCA9IGNvbW1lbnQucmVwbGFjZShhY29ybi5hbGxMaW5lQnJlYWtzLCAnXFxuJyk7XG4gICAgICB0b2tlbiA9IHRoaXMuX2NyZWF0ZV90b2tlbihUT0tFTi5CTE9DS19DT01NRU5ULCBjb21tZW50KTtcbiAgICAgIHRva2VuLmRpcmVjdGl2ZXMgPSBkaXJlY3RpdmVzO1xuICAgIH0gZWxzZSBpZiAodGhpcy5faW5wdXQucGVlaygxKSA9PT0gJy8nKSB7XG4gICAgICAvLyBwZWVrIGZvciBjb21tZW50IC8vIC4uLlxuICAgICAgY29tbWVudCA9IHRoaXMuX19wYXR0ZXJucy5jb21tZW50LnJlYWQoKTtcbiAgICAgIHRva2VuID0gdGhpcy5fY3JlYXRlX3Rva2VuKFRPS0VOLkNPTU1FTlQsIGNvbW1lbnQpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdG9rZW47XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9yZWFkX3N0cmluZyA9IGZ1bmN0aW9uKGMpIHtcbiAgaWYgKGMgPT09ICdgJyB8fCBjID09PSBcIidcIiB8fCBjID09PSAnXCInKSB7XG4gICAgdmFyIHJlc3VsdGluZ19zdHJpbmcgPSB0aGlzLl9pbnB1dC5uZXh0KCk7XG4gICAgdGhpcy5oYXNfY2hhcl9lc2NhcGVzID0gZmFsc2U7XG5cbiAgICBpZiAoYyA9PT0gJ2AnKSB7XG4gICAgICByZXN1bHRpbmdfc3RyaW5nICs9IHRoaXMuX3JlYWRfc3RyaW5nX3JlY3Vyc2l2ZSgnYCcsIHRydWUsICckeycpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHRpbmdfc3RyaW5nICs9IHRoaXMuX3JlYWRfc3RyaW5nX3JlY3Vyc2l2ZShjKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5oYXNfY2hhcl9lc2NhcGVzICYmIHRoaXMuX29wdGlvbnMudW5lc2NhcGVfc3RyaW5ncykge1xuICAgICAgcmVzdWx0aW5nX3N0cmluZyA9IHVuZXNjYXBlX3N0cmluZyhyZXN1bHRpbmdfc3RyaW5nKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5faW5wdXQucGVlaygpID09PSBjKSB7XG4gICAgICByZXN1bHRpbmdfc3RyaW5nICs9IHRoaXMuX2lucHV0Lm5leHQoKTtcbiAgICB9XG5cbiAgICByZXN1bHRpbmdfc3RyaW5nID0gcmVzdWx0aW5nX3N0cmluZy5yZXBsYWNlKGFjb3JuLmFsbExpbmVCcmVha3MsICdcXG4nKTtcblxuICAgIHJldHVybiB0aGlzLl9jcmVhdGVfdG9rZW4oVE9LRU4uU1RSSU5HLCByZXN1bHRpbmdfc3RyaW5nKTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5fYWxsb3dfcmVnZXhwX29yX3htbCA9IGZ1bmN0aW9uKHByZXZpb3VzX3Rva2VuKSB7XG4gIC8vIHJlZ2V4IGFuZCB4bWwgY2FuIG9ubHkgYXBwZWFyIGluIHNwZWNpZmljIGxvY2F0aW9ucyBkdXJpbmcgcGFyc2luZ1xuICByZXR1cm4gKHByZXZpb3VzX3Rva2VuLnR5cGUgPT09IFRPS0VOLlJFU0VSVkVEICYmIGluX2FycmF5KHByZXZpb3VzX3Rva2VuLnRleHQsIFsncmV0dXJuJywgJ2Nhc2UnLCAndGhyb3cnLCAnZWxzZScsICdkbycsICd0eXBlb2YnLCAneWllbGQnXSkpIHx8XG4gICAgKHByZXZpb3VzX3Rva2VuLnR5cGUgPT09IFRPS0VOLkVORF9FWFBSICYmIHByZXZpb3VzX3Rva2VuLnRleHQgPT09ICcpJyAmJlxuICAgICAgcHJldmlvdXNfdG9rZW4ub3BlbmVkLnByZXZpb3VzLnR5cGUgPT09IFRPS0VOLlJFU0VSVkVEICYmIGluX2FycmF5KHByZXZpb3VzX3Rva2VuLm9wZW5lZC5wcmV2aW91cy50ZXh0LCBbJ2lmJywgJ3doaWxlJywgJ2ZvciddKSkgfHxcbiAgICAoaW5fYXJyYXkocHJldmlvdXNfdG9rZW4udHlwZSwgW1RPS0VOLkNPTU1FTlQsIFRPS0VOLlNUQVJUX0VYUFIsIFRPS0VOLlNUQVJUX0JMT0NLLCBUT0tFTi5TVEFSVCxcbiAgICAgIFRPS0VOLkVORF9CTE9DSywgVE9LRU4uT1BFUkFUT1IsIFRPS0VOLkVRVUFMUywgVE9LRU4uRU9GLCBUT0tFTi5TRU1JQ09MT04sIFRPS0VOLkNPTU1BXG4gICAgXSkpO1xufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5fcmVhZF9yZWdleHAgPSBmdW5jdGlvbihjLCBwcmV2aW91c190b2tlbikge1xuXG4gIGlmIChjID09PSAnLycgJiYgdGhpcy5fYWxsb3dfcmVnZXhwX29yX3htbChwcmV2aW91c190b2tlbikpIHtcbiAgICAvLyBoYW5kbGUgcmVnZXhwXG4gICAgLy9cbiAgICB2YXIgcmVzdWx0aW5nX3N0cmluZyA9IHRoaXMuX2lucHV0Lm5leHQoKTtcbiAgICB2YXIgZXNjID0gZmFsc2U7XG5cbiAgICB2YXIgaW5fY2hhcl9jbGFzcyA9IGZhbHNlO1xuICAgIHdoaWxlICh0aGlzLl9pbnB1dC5oYXNOZXh0KCkgJiZcbiAgICAgICgoZXNjIHx8IGluX2NoYXJfY2xhc3MgfHwgdGhpcy5faW5wdXQucGVlaygpICE9PSBjKSAmJlxuICAgICAgICAhdGhpcy5faW5wdXQudGVzdENoYXIoYWNvcm4ubmV3bGluZSkpKSB7XG4gICAgICByZXN1bHRpbmdfc3RyaW5nICs9IHRoaXMuX2lucHV0LnBlZWsoKTtcbiAgICAgIGlmICghZXNjKSB7XG4gICAgICAgIGVzYyA9IHRoaXMuX2lucHV0LnBlZWsoKSA9PT0gJ1xcXFwnO1xuICAgICAgICBpZiAodGhpcy5faW5wdXQucGVlaygpID09PSAnWycpIHtcbiAgICAgICAgICBpbl9jaGFyX2NsYXNzID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9pbnB1dC5wZWVrKCkgPT09ICddJykge1xuICAgICAgICAgIGluX2NoYXJfY2xhc3MgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXNjID0gZmFsc2U7XG4gICAgICB9XG4gICAgICB0aGlzLl9pbnB1dC5uZXh0KCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2lucHV0LnBlZWsoKSA9PT0gYykge1xuICAgICAgcmVzdWx0aW5nX3N0cmluZyArPSB0aGlzLl9pbnB1dC5uZXh0KCk7XG5cbiAgICAgIC8vIHJlZ2V4cHMgbWF5IGhhdmUgbW9kaWZpZXJzIC9yZWdleHAvTU9EICwgc28gZmV0Y2ggdGhvc2UsIHRvb1xuICAgICAgLy8gT25seSBbZ2ltXSBhcmUgdmFsaWQsIGJ1dCBpZiB0aGUgdXNlciBwdXRzIGluIGdhcmJhZ2UsIGRvIHdoYXQgd2UgY2FuIHRvIHRha2UgaXQuXG4gICAgICByZXN1bHRpbmdfc3RyaW5nICs9IHRoaXMuX2lucHV0LnJlYWQoYWNvcm4uaWRlbnRpZmllcik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jcmVhdGVfdG9rZW4oVE9LRU4uU1RSSU5HLCByZXN1bHRpbmdfc3RyaW5nKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX3JlYWRfeG1sID0gZnVuY3Rpb24oYywgcHJldmlvdXNfdG9rZW4pIHtcblxuICBpZiAodGhpcy5fb3B0aW9ucy5lNHggJiYgYyA9PT0gXCI8XCIgJiYgdGhpcy5fYWxsb3dfcmVnZXhwX29yX3htbChwcmV2aW91c190b2tlbikpIHtcbiAgICB2YXIgeG1sU3RyID0gJyc7XG4gICAgdmFyIG1hdGNoID0gdGhpcy5fX3BhdHRlcm5zLnhtbC5yZWFkX21hdGNoKCk7XG4gICAgLy8gaGFuZGxlIGU0eCB4bWwgbGl0ZXJhbHNcbiAgICAvL1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgLy8gVHJpbSByb290IHRhZyB0byBhdHRlbXB0IHRvXG4gICAgICB2YXIgcm9vdFRhZyA9IG1hdGNoWzJdLnJlcGxhY2UoL157XFxzKy8sICd7JykucmVwbGFjZSgvXFxzK30kLywgJ30nKTtcbiAgICAgIHZhciBpc0N1cmx5Um9vdCA9IHJvb3RUYWcuaW5kZXhPZigneycpID09PSAwO1xuICAgICAgdmFyIGRlcHRoID0gMDtcbiAgICAgIHdoaWxlIChtYXRjaCkge1xuICAgICAgICB2YXIgaXNFbmRUYWcgPSAhIW1hdGNoWzFdO1xuICAgICAgICB2YXIgdGFnTmFtZSA9IG1hdGNoWzJdO1xuICAgICAgICB2YXIgaXNTaW5nbGV0b25UYWcgPSAoISFtYXRjaFttYXRjaC5sZW5ndGggLSAxXSkgfHwgKHRhZ05hbWUuc2xpY2UoMCwgOCkgPT09IFwiIVtDREFUQVtcIik7XG4gICAgICAgIGlmICghaXNTaW5nbGV0b25UYWcgJiZcbiAgICAgICAgICAodGFnTmFtZSA9PT0gcm9vdFRhZyB8fCAoaXNDdXJseVJvb3QgJiYgdGFnTmFtZS5yZXBsYWNlKC9ee1xccysvLCAneycpLnJlcGxhY2UoL1xccyt9JC8sICd9JykpKSkge1xuICAgICAgICAgIGlmIChpc0VuZFRhZykge1xuICAgICAgICAgICAgLS1kZXB0aDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgKytkZXB0aDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgeG1sU3RyICs9IG1hdGNoWzBdO1xuICAgICAgICBpZiAoZGVwdGggPD0gMCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIG1hdGNoID0gdGhpcy5fX3BhdHRlcm5zLnhtbC5yZWFkX21hdGNoKCk7XG4gICAgICB9XG4gICAgICAvLyBpZiB3ZSBkaWRuJ3QgY2xvc2UgY29ycmVjdGx5LCBrZWVwIHVuZm9ybWF0dGVkLlxuICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICB4bWxTdHIgKz0gdGhpcy5faW5wdXQubWF0Y2goL1tcXHNcXFNdKi9nKVswXTtcbiAgICAgIH1cbiAgICAgIHhtbFN0ciA9IHhtbFN0ci5yZXBsYWNlKGFjb3JuLmFsbExpbmVCcmVha3MsICdcXG4nKTtcbiAgICAgIHJldHVybiB0aGlzLl9jcmVhdGVfdG9rZW4oVE9LRU4uU1RSSU5HLCB4bWxTdHIpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufTtcblxuZnVuY3Rpb24gdW5lc2NhcGVfc3RyaW5nKHMpIHtcbiAgLy8gWW91IHRoaW5rIHRoYXQgYSByZWdleCB3b3VsZCB3b3JrIGZvciB0aGlzXG4gIC8vIHJldHVybiBzLnJlcGxhY2UoL1xcXFx4KFswLTlhLWZdezJ9KS9naSwgZnVuY3Rpb24obWF0Y2gsIHZhbCkge1xuICAvLyAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KHZhbCwgMTYpKTtcbiAgLy8gICAgIH0pXG4gIC8vIEhvd2V2ZXIsIGRlYWxpbmcgd2l0aCAnXFx4ZmYnLCAnXFxcXHhmZicsICdcXFxcXFx4ZmYnIG1ha2VzIHRoaXMgbW9yZSBmdW4uXG4gIHZhciBvdXQgPSAnJyxcbiAgICBlc2NhcGVkID0gMDtcblxuICB2YXIgaW5wdXRfc2NhbiA9IG5ldyBJbnB1dFNjYW5uZXIocyk7XG4gIHZhciBtYXRjaGVkID0gbnVsbDtcblxuICB3aGlsZSAoaW5wdXRfc2Nhbi5oYXNOZXh0KCkpIHtcbiAgICAvLyBLZWVwIGFueSB3aGl0ZXNwYWNlLCBub24tc2xhc2ggY2hhcmFjdGVyc1xuICAgIC8vIGFsc28ga2VlcCBzbGFzaCBwYWlycy5cbiAgICBtYXRjaGVkID0gaW5wdXRfc2Nhbi5tYXRjaCgvKFtcXHNdfFteXFxcXF18XFxcXFxcXFwpKy9nKTtcblxuICAgIGlmIChtYXRjaGVkKSB7XG4gICAgICBvdXQgKz0gbWF0Y2hlZFswXTtcbiAgICB9XG5cbiAgICBpZiAoaW5wdXRfc2Nhbi5wZWVrKCkgPT09ICdcXFxcJykge1xuICAgICAgaW5wdXRfc2Nhbi5uZXh0KCk7XG4gICAgICBpZiAoaW5wdXRfc2Nhbi5wZWVrKCkgPT09ICd4Jykge1xuICAgICAgICBtYXRjaGVkID0gaW5wdXRfc2Nhbi5tYXRjaCgveChbMC05QS1GYS1mXXsyfSkvZyk7XG4gICAgICB9IGVsc2UgaWYgKGlucHV0X3NjYW4ucGVlaygpID09PSAndScpIHtcbiAgICAgICAgbWF0Y2hlZCA9IGlucHV0X3NjYW4ubWF0Y2goL3UoWzAtOUEtRmEtZl17NH0pL2cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0ICs9ICdcXFxcJztcbiAgICAgICAgaWYgKGlucHV0X3NjYW4uaGFzTmV4dCgpKSB7XG4gICAgICAgICAgb3V0ICs9IGlucHV0X3NjYW4ubmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiB0aGVyZSdzIHNvbWUgZXJyb3IgZGVjb2RpbmcsIHJldHVybiB0aGUgb3JpZ2luYWwgc3RyaW5nXG4gICAgICBpZiAoIW1hdGNoZWQpIHtcbiAgICAgICAgcmV0dXJuIHM7XG4gICAgICB9XG5cbiAgICAgIGVzY2FwZWQgPSBwYXJzZUludChtYXRjaGVkWzFdLCAxNik7XG5cbiAgICAgIGlmIChlc2NhcGVkID4gMHg3ZSAmJiBlc2NhcGVkIDw9IDB4ZmYgJiYgbWF0Y2hlZFswXS5pbmRleE9mKCd4JykgPT09IDApIHtcbiAgICAgICAgLy8gd2UgYmFpbCBvdXQgb24gXFx4N2YuLlxceGZmLFxuICAgICAgICAvLyBsZWF2aW5nIHdob2xlIHN0cmluZyBlc2NhcGVkLFxuICAgICAgICAvLyBhcyBpdCdzIHByb2JhYmx5IGNvbXBsZXRlbHkgYmluYXJ5XG4gICAgICAgIHJldHVybiBzO1xuICAgICAgfSBlbHNlIGlmIChlc2NhcGVkID49IDB4MDAgJiYgZXNjYXBlZCA8IDB4MjApIHtcbiAgICAgICAgLy8gbGVhdmUgMHgwMC4uLjB4MWYgZXNjYXBlZFxuICAgICAgICBvdXQgKz0gJ1xcXFwnICsgbWF0Y2hlZFswXTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2UgaWYgKGVzY2FwZWQgPT09IDB4MjIgfHwgZXNjYXBlZCA9PT0gMHgyNyB8fCBlc2NhcGVkID09PSAweDVjKSB7XG4gICAgICAgIC8vIHNpbmdsZS1xdW90ZSwgYXBvc3Ryb3BoZSwgYmFja3NsYXNoIC0gZXNjYXBlIHRoZXNlXG4gICAgICAgIG91dCArPSAnXFxcXCcgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGVzY2FwZWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoZXNjYXBlZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG91dDtcbn1cblxuLy8gaGFuZGxlIHN0cmluZ1xuLy9cblRva2VuaXplci5wcm90b3R5cGUuX3JlYWRfc3RyaW5nX3JlY3Vyc2l2ZSA9IGZ1bmN0aW9uKGRlbGltaXRlciwgYWxsb3dfdW5lc2NhcGVkX25ld2xpbmVzLCBzdGFydF9zdWIpIHtcbiAgdmFyIGN1cnJlbnRfY2hhcjtcbiAgdmFyIHBhdHRlcm47XG4gIGlmIChkZWxpbWl0ZXIgPT09ICdcXCcnKSB7XG4gICAgcGF0dGVybiA9IHRoaXMuX19wYXR0ZXJucy5zaW5nbGVfcXVvdGU7XG4gIH0gZWxzZSBpZiAoZGVsaW1pdGVyID09PSAnXCInKSB7XG4gICAgcGF0dGVybiA9IHRoaXMuX19wYXR0ZXJucy5kb3VibGVfcXVvdGU7XG4gIH0gZWxzZSBpZiAoZGVsaW1pdGVyID09PSAnYCcpIHtcbiAgICBwYXR0ZXJuID0gdGhpcy5fX3BhdHRlcm5zLnRlbXBsYXRlX3RleHQ7XG4gIH0gZWxzZSBpZiAoZGVsaW1pdGVyID09PSAnfScpIHtcbiAgICBwYXR0ZXJuID0gdGhpcy5fX3BhdHRlcm5zLnRlbXBsYXRlX2V4cHJlc3Npb247XG4gIH1cblxuICB2YXIgcmVzdWx0aW5nX3N0cmluZyA9IHBhdHRlcm4ucmVhZCgpO1xuICB2YXIgbmV4dCA9ICcnO1xuICB3aGlsZSAodGhpcy5faW5wdXQuaGFzTmV4dCgpKSB7XG4gICAgbmV4dCA9IHRoaXMuX2lucHV0Lm5leHQoKTtcbiAgICBpZiAobmV4dCA9PT0gZGVsaW1pdGVyIHx8XG4gICAgICAoIWFsbG93X3VuZXNjYXBlZF9uZXdsaW5lcyAmJiBhY29ybi5uZXdsaW5lLnRlc3QobmV4dCkpKSB7XG4gICAgICB0aGlzLl9pbnB1dC5iYWNrKCk7XG4gICAgICBicmVhaztcbiAgICB9IGVsc2UgaWYgKG5leHQgPT09ICdcXFxcJyAmJiB0aGlzLl9pbnB1dC5oYXNOZXh0KCkpIHtcbiAgICAgIGN1cnJlbnRfY2hhciA9IHRoaXMuX2lucHV0LnBlZWsoKTtcblxuICAgICAgaWYgKGN1cnJlbnRfY2hhciA9PT0gJ3gnIHx8IGN1cnJlbnRfY2hhciA9PT0gJ3UnKSB7XG4gICAgICAgIHRoaXMuaGFzX2NoYXJfZXNjYXBlcyA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGN1cnJlbnRfY2hhciA9PT0gJ1xccicgJiYgdGhpcy5faW5wdXQucGVlaygxKSA9PT0gJ1xcbicpIHtcbiAgICAgICAgdGhpcy5faW5wdXQubmV4dCgpO1xuICAgICAgfVxuICAgICAgbmV4dCArPSB0aGlzLl9pbnB1dC5uZXh0KCk7XG4gICAgfSBlbHNlIGlmIChzdGFydF9zdWIpIHtcbiAgICAgIGlmIChzdGFydF9zdWIgPT09ICckeycgJiYgbmV4dCA9PT0gJyQnICYmIHRoaXMuX2lucHV0LnBlZWsoKSA9PT0gJ3snKSB7XG4gICAgICAgIG5leHQgKz0gdGhpcy5faW5wdXQubmV4dCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhcnRfc3ViID09PSBuZXh0KSB7XG4gICAgICAgIGlmIChkZWxpbWl0ZXIgPT09ICdgJykge1xuICAgICAgICAgIG5leHQgKz0gdGhpcy5fcmVhZF9zdHJpbmdfcmVjdXJzaXZlKCd9JywgYWxsb3dfdW5lc2NhcGVkX25ld2xpbmVzLCAnYCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5leHQgKz0gdGhpcy5fcmVhZF9zdHJpbmdfcmVjdXJzaXZlKCdgJywgYWxsb3dfdW5lc2NhcGVkX25ld2xpbmVzLCAnJHsnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5faW5wdXQuaGFzTmV4dCgpKSB7XG4gICAgICAgICAgbmV4dCArPSB0aGlzLl9pbnB1dC5uZXh0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgbmV4dCArPSBwYXR0ZXJuLnJlYWQoKTtcbiAgICByZXN1bHRpbmdfc3RyaW5nICs9IG5leHQ7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0aW5nX3N0cmluZztcbn07XG5cbm1vZHVsZS5leHBvcnRzLlRva2VuaXplciA9IFRva2VuaXplcjtcbm1vZHVsZS5leHBvcnRzLlRPS0VOID0gVE9LRU47XG5tb2R1bGUuZXhwb3J0cy5wb3NpdGlvbmFibGVfb3BlcmF0b3JzID0gcG9zaXRpb25hYmxlX29wZXJhdG9ycy5zbGljZSgpO1xubW9kdWxlLmV4cG9ydHMubGluZV9zdGFydGVycyA9IGxpbmVfc3RhcnRlcnMuc2xpY2UoKTtcblxuXG4vKioqLyB9KSxcbi8qIDggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKmpzaGludCBub2RlOnRydWUgKi9cbi8qXG5cbiAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiAgQ29weXJpZ2h0IChjKSAyMDA3LTIwMTggRWluYXIgTGllbG1hbmlzLCBMaWFtIE5ld21hbiwgYW5kIGNvbnRyaWJ1dG9ycy5cblxuICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gIFNPRlRXQVJFLlxuKi9cblxuXG5cbnZhciByZWdleHBfaGFzX3N0aWNreSA9IFJlZ0V4cC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkoJ3N0aWNreScpO1xuXG5mdW5jdGlvbiBJbnB1dFNjYW5uZXIoaW5wdXRfc3RyaW5nKSB7XG4gIHRoaXMuX19pbnB1dCA9IGlucHV0X3N0cmluZyB8fCAnJztcbiAgdGhpcy5fX2lucHV0X2xlbmd0aCA9IHRoaXMuX19pbnB1dC5sZW5ndGg7XG4gIHRoaXMuX19wb3NpdGlvbiA9IDA7XG59XG5cbklucHV0U2Nhbm5lci5wcm90b3R5cGUucmVzdGFydCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9fcG9zaXRpb24gPSAwO1xufTtcblxuSW5wdXRTY2FubmVyLnByb3RvdHlwZS5iYWNrID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLl9fcG9zaXRpb24gPiAwKSB7XG4gICAgdGhpcy5fX3Bvc2l0aW9uIC09IDE7XG4gIH1cbn07XG5cbklucHV0U2Nhbm5lci5wcm90b3R5cGUuaGFzTmV4dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fX3Bvc2l0aW9uIDwgdGhpcy5fX2lucHV0X2xlbmd0aDtcbn07XG5cbklucHV0U2Nhbm5lci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgdmFsID0gbnVsbDtcbiAgaWYgKHRoaXMuaGFzTmV4dCgpKSB7XG4gICAgdmFsID0gdGhpcy5fX2lucHV0LmNoYXJBdCh0aGlzLl9fcG9zaXRpb24pO1xuICAgIHRoaXMuX19wb3NpdGlvbiArPSAxO1xuICB9XG4gIHJldHVybiB2YWw7XG59O1xuXG5JbnB1dFNjYW5uZXIucHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbihpbmRleCkge1xuICB2YXIgdmFsID0gbnVsbDtcbiAgaW5kZXggPSBpbmRleCB8fCAwO1xuICBpbmRleCArPSB0aGlzLl9fcG9zaXRpb247XG4gIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgdGhpcy5fX2lucHV0X2xlbmd0aCkge1xuICAgIHZhbCA9IHRoaXMuX19pbnB1dC5jaGFyQXQoaW5kZXgpO1xuICB9XG4gIHJldHVybiB2YWw7XG59O1xuXG4vLyBUaGlzIGlzIGEgSmF2YVNjcmlwdCBvbmx5IGhlbHBlciBmdW5jdGlvbiAobm90IGluIHB5dGhvbilcbi8vIEphdmFzY3JpcHQgZG9lc24ndCBoYXZlIGEgbWF0Y2ggbWV0aG9kXG4vLyBhbmQgbm90IGFsbCBpbXBsZW1lbnRhdGlvbiBzdXBwb3J0IFwic3RpY2t5XCIgZmxhZy5cbi8vIElmIHRoZXkgZG8gbm90IHN1cHBvcnQgc3RpY2t5IHRoZW4gYm90aCB0aGlzLm1hdGNoKCkgYW5kIHRoaXMudGVzdCgpIG1ldGhvZFxuLy8gbXVzdCBnZXQgdGhlIG1hdGNoIGFuZCBjaGVjayB0aGUgaW5kZXggb2YgdGhlIG1hdGNoLlxuLy8gSWYgc3RpY2t5IGlzIHN1cHBvcnRlZCBhbmQgc2V0LCB0aGlzIG1ldGhvZCB3aWxsIHVzZSBpdC5cbi8vIE90aGVyd2lzZSBpdCB3aWxsIGNoZWNrIHRoYXQgZ2xvYmFsIGlzIHNldCwgYW5kIGZhbGwgYmFjayB0byB0aGUgc2xvd2VyIG1ldGhvZC5cbklucHV0U2Nhbm5lci5wcm90b3R5cGUuX19tYXRjaCA9IGZ1bmN0aW9uKHBhdHRlcm4sIGluZGV4KSB7XG4gIHBhdHRlcm4ubGFzdEluZGV4ID0gaW5kZXg7XG4gIHZhciBwYXR0ZXJuX21hdGNoID0gcGF0dGVybi5leGVjKHRoaXMuX19pbnB1dCk7XG5cbiAgaWYgKHBhdHRlcm5fbWF0Y2ggJiYgIShyZWdleHBfaGFzX3N0aWNreSAmJiBwYXR0ZXJuLnN0aWNreSkpIHtcbiAgICBpZiAocGF0dGVybl9tYXRjaC5pbmRleCAhPT0gaW5kZXgpIHtcbiAgICAgIHBhdHRlcm5fbWF0Y2ggPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYXR0ZXJuX21hdGNoO1xufTtcblxuSW5wdXRTY2FubmVyLnByb3RvdHlwZS50ZXN0ID0gZnVuY3Rpb24ocGF0dGVybiwgaW5kZXgpIHtcbiAgaW5kZXggPSBpbmRleCB8fCAwO1xuICBpbmRleCArPSB0aGlzLl9fcG9zaXRpb247XG5cbiAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPCB0aGlzLl9faW5wdXRfbGVuZ3RoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fX21hdGNoKHBhdHRlcm4sIGluZGV4KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbklucHV0U2Nhbm5lci5wcm90b3R5cGUudGVzdENoYXIgPSBmdW5jdGlvbihwYXR0ZXJuLCBpbmRleCkge1xuICAvLyB0ZXN0IG9uZSBjaGFyYWN0ZXIgcmVnZXggbWF0Y2hcbiAgdmFyIHZhbCA9IHRoaXMucGVlayhpbmRleCk7XG4gIHBhdHRlcm4ubGFzdEluZGV4ID0gMDtcbiAgcmV0dXJuIHZhbCAhPT0gbnVsbCAmJiBwYXR0ZXJuLnRlc3QodmFsKTtcbn07XG5cbklucHV0U2Nhbm5lci5wcm90b3R5cGUubWF0Y2ggPSBmdW5jdGlvbihwYXR0ZXJuKSB7XG4gIHZhciBwYXR0ZXJuX21hdGNoID0gdGhpcy5fX21hdGNoKHBhdHRlcm4sIHRoaXMuX19wb3NpdGlvbik7XG4gIGlmIChwYXR0ZXJuX21hdGNoKSB7XG4gICAgdGhpcy5fX3Bvc2l0aW9uICs9IHBhdHRlcm5fbWF0Y2hbMF0ubGVuZ3RoO1xuICB9IGVsc2Uge1xuICAgIHBhdHRlcm5fbWF0Y2ggPSBudWxsO1xuICB9XG4gIHJldHVybiBwYXR0ZXJuX21hdGNoO1xufTtcblxuSW5wdXRTY2FubmVyLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24oc3RhcnRpbmdfcGF0dGVybiwgdW50aWxfcGF0dGVybiwgdW50aWxfYWZ0ZXIpIHtcbiAgdmFyIHZhbCA9ICcnO1xuICB2YXIgbWF0Y2g7XG4gIGlmIChzdGFydGluZ19wYXR0ZXJuKSB7XG4gICAgbWF0Y2ggPSB0aGlzLm1hdGNoKHN0YXJ0aW5nX3BhdHRlcm4pO1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgdmFsICs9IG1hdGNoWzBdO1xuICAgIH1cbiAgfVxuICBpZiAodW50aWxfcGF0dGVybiAmJiAobWF0Y2ggfHwgIXN0YXJ0aW5nX3BhdHRlcm4pKSB7XG4gICAgdmFsICs9IHRoaXMucmVhZFVudGlsKHVudGlsX3BhdHRlcm4sIHVudGlsX2FmdGVyKTtcbiAgfVxuICByZXR1cm4gdmFsO1xufTtcblxuSW5wdXRTY2FubmVyLnByb3RvdHlwZS5yZWFkVW50aWwgPSBmdW5jdGlvbihwYXR0ZXJuLCB1bnRpbF9hZnRlcikge1xuICB2YXIgdmFsID0gJyc7XG4gIHZhciBtYXRjaF9pbmRleCA9IHRoaXMuX19wb3NpdGlvbjtcbiAgcGF0dGVybi5sYXN0SW5kZXggPSB0aGlzLl9fcG9zaXRpb247XG4gIHZhciBwYXR0ZXJuX21hdGNoID0gcGF0dGVybi5leGVjKHRoaXMuX19pbnB1dCk7XG4gIGlmIChwYXR0ZXJuX21hdGNoKSB7XG4gICAgbWF0Y2hfaW5kZXggPSBwYXR0ZXJuX21hdGNoLmluZGV4O1xuICAgIGlmICh1bnRpbF9hZnRlcikge1xuICAgICAgbWF0Y2hfaW5kZXggKz0gcGF0dGVybl9tYXRjaFswXS5sZW5ndGg7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG1hdGNoX2luZGV4ID0gdGhpcy5fX2lucHV0X2xlbmd0aDtcbiAgfVxuXG4gIHZhbCA9IHRoaXMuX19pbnB1dC5zdWJzdHJpbmcodGhpcy5fX3Bvc2l0aW9uLCBtYXRjaF9pbmRleCk7XG4gIHRoaXMuX19wb3NpdGlvbiA9IG1hdGNoX2luZGV4O1xuICByZXR1cm4gdmFsO1xufTtcblxuSW5wdXRTY2FubmVyLnByb3RvdHlwZS5yZWFkVW50aWxBZnRlciA9IGZ1bmN0aW9uKHBhdHRlcm4pIHtcbiAgcmV0dXJuIHRoaXMucmVhZFVudGlsKHBhdHRlcm4sIHRydWUpO1xufTtcblxuSW5wdXRTY2FubmVyLnByb3RvdHlwZS5nZXRfcmVnZXhwID0gZnVuY3Rpb24ocGF0dGVybiwgbWF0Y2hfZnJvbSkge1xuICB2YXIgcmVzdWx0ID0gbnVsbDtcbiAgdmFyIGZsYWdzID0gJ2cnO1xuICBpZiAobWF0Y2hfZnJvbSAmJiByZWdleHBfaGFzX3N0aWNreSkge1xuICAgIGZsYWdzID0gJ3knO1xuICB9XG4gIC8vIHN0cmluZ3MgYXJlIGNvbnZlcnRlZCB0byByZWdleHBcbiAgaWYgKHR5cGVvZiBwYXR0ZXJuID09PSBcInN0cmluZ1wiICYmIHBhdHRlcm4gIT09ICcnKSB7XG4gICAgLy8gcmVzdWx0ID0gbmV3IFJlZ0V4cChwYXR0ZXJuLnJlcGxhY2UoL1stXFwvXFxcXF4kKis/LigpfFtcXF17fV0vZywgJ1xcXFwkJicpLCBmbGFncyk7XG4gICAgcmVzdWx0ID0gbmV3IFJlZ0V4cChwYXR0ZXJuLCBmbGFncyk7XG4gIH0gZWxzZSBpZiAocGF0dGVybikge1xuICAgIHJlc3VsdCA9IG5ldyBSZWdFeHAocGF0dGVybi5zb3VyY2UsIGZsYWdzKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuSW5wdXRTY2FubmVyLnByb3RvdHlwZS5nZXRfbGl0ZXJhbF9yZWdleHAgPSBmdW5jdGlvbihsaXRlcmFsX3N0cmluZykge1xuICByZXR1cm4gUmVnRXhwKGxpdGVyYWxfc3RyaW5nLnJlcGxhY2UoL1stXFwvXFxcXF4kKis/LigpfFtcXF17fV0vZywgJ1xcXFwkJicpKTtcbn07XG5cbi8qIGNzcyBiZWF1dGlmaWVyIGxlZ2FjeSBoZWxwZXJzICovXG5JbnB1dFNjYW5uZXIucHJvdG90eXBlLnBlZWtVbnRpbEFmdGVyID0gZnVuY3Rpb24ocGF0dGVybikge1xuICB2YXIgc3RhcnQgPSB0aGlzLl9fcG9zaXRpb247XG4gIHZhciB2YWwgPSB0aGlzLnJlYWRVbnRpbEFmdGVyKHBhdHRlcm4pO1xuICB0aGlzLl9fcG9zaXRpb24gPSBzdGFydDtcbiAgcmV0dXJuIHZhbDtcbn07XG5cbklucHV0U2Nhbm5lci5wcm90b3R5cGUubG9va0JhY2sgPSBmdW5jdGlvbih0ZXN0VmFsKSB7XG4gIHZhciBzdGFydCA9IHRoaXMuX19wb3NpdGlvbiAtIDE7XG4gIHJldHVybiBzdGFydCA+PSB0ZXN0VmFsLmxlbmd0aCAmJiB0aGlzLl9faW5wdXQuc3Vic3RyaW5nKHN0YXJ0IC0gdGVzdFZhbC5sZW5ndGgsIHN0YXJ0KVxuICAgIC50b0xvd2VyQ2FzZSgpID09PSB0ZXN0VmFsO1xufTtcblxubW9kdWxlLmV4cG9ydHMuSW5wdXRTY2FubmVyID0gSW5wdXRTY2FubmVyO1xuXG5cbi8qKiovIH0pLFxuLyogOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qanNoaW50IG5vZGU6dHJ1ZSAqL1xuLypcblxuICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxOCBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgU09GVFdBUkUuXG4qL1xuXG5cblxudmFyIElucHV0U2Nhbm5lciA9IF9fd2VicGFja19yZXF1aXJlX18oOCkuSW5wdXRTY2FubmVyO1xudmFyIFRva2VuID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKS5Ub2tlbjtcbnZhciBUb2tlblN0cmVhbSA9IF9fd2VicGFja19yZXF1aXJlX18oMTApLlRva2VuU3RyZWFtO1xudmFyIFdoaXRlc3BhY2VQYXR0ZXJuID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSkuV2hpdGVzcGFjZVBhdHRlcm47XG5cbnZhciBUT0tFTiA9IHtcbiAgU1RBUlQ6ICdUS19TVEFSVCcsXG4gIFJBVzogJ1RLX1JBVycsXG4gIEVPRjogJ1RLX0VPRidcbn07XG5cbnZhciBUb2tlbml6ZXIgPSBmdW5jdGlvbihpbnB1dF9zdHJpbmcsIG9wdGlvbnMpIHtcbiAgdGhpcy5faW5wdXQgPSBuZXcgSW5wdXRTY2FubmVyKGlucHV0X3N0cmluZyk7XG4gIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB0aGlzLl9fdG9rZW5zID0gbnVsbDtcblxuICB0aGlzLl9wYXR0ZXJucyA9IHt9O1xuICB0aGlzLl9wYXR0ZXJucy53aGl0ZXNwYWNlID0gbmV3IFdoaXRlc3BhY2VQYXR0ZXJuKHRoaXMuX2lucHV0KTtcbn07XG5cblRva2VuaXplci5wcm90b3R5cGUudG9rZW5pemUgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5faW5wdXQucmVzdGFydCgpO1xuICB0aGlzLl9fdG9rZW5zID0gbmV3IFRva2VuU3RyZWFtKCk7XG5cbiAgdGhpcy5fcmVzZXQoKTtcblxuICB2YXIgY3VycmVudDtcbiAgdmFyIHByZXZpb3VzID0gbmV3IFRva2VuKFRPS0VOLlNUQVJULCAnJyk7XG4gIHZhciBvcGVuX3Rva2VuID0gbnVsbDtcbiAgdmFyIG9wZW5fc3RhY2sgPSBbXTtcbiAgdmFyIGNvbW1lbnRzID0gbmV3IFRva2VuU3RyZWFtKCk7XG5cbiAgd2hpbGUgKHByZXZpb3VzLnR5cGUgIT09IFRPS0VOLkVPRikge1xuICAgIGN1cnJlbnQgPSB0aGlzLl9nZXRfbmV4dF90b2tlbihwcmV2aW91cywgb3Blbl90b2tlbik7XG4gICAgd2hpbGUgKHRoaXMuX2lzX2NvbW1lbnQoY3VycmVudCkpIHtcbiAgICAgIGNvbW1lbnRzLmFkZChjdXJyZW50KTtcbiAgICAgIGN1cnJlbnQgPSB0aGlzLl9nZXRfbmV4dF90b2tlbihwcmV2aW91cywgb3Blbl90b2tlbik7XG4gICAgfVxuXG4gICAgaWYgKCFjb21tZW50cy5pc0VtcHR5KCkpIHtcbiAgICAgIGN1cnJlbnQuY29tbWVudHNfYmVmb3JlID0gY29tbWVudHM7XG4gICAgICBjb21tZW50cyA9IG5ldyBUb2tlblN0cmVhbSgpO1xuICAgIH1cblxuICAgIGN1cnJlbnQucGFyZW50ID0gb3Blbl90b2tlbjtcblxuICAgIGlmICh0aGlzLl9pc19vcGVuaW5nKGN1cnJlbnQpKSB7XG4gICAgICBvcGVuX3N0YWNrLnB1c2gob3Blbl90b2tlbik7XG4gICAgICBvcGVuX3Rva2VuID0gY3VycmVudDtcbiAgICB9IGVsc2UgaWYgKG9wZW5fdG9rZW4gJiYgdGhpcy5faXNfY2xvc2luZyhjdXJyZW50LCBvcGVuX3Rva2VuKSkge1xuICAgICAgY3VycmVudC5vcGVuZWQgPSBvcGVuX3Rva2VuO1xuICAgICAgb3Blbl90b2tlbi5jbG9zZWQgPSBjdXJyZW50O1xuICAgICAgb3Blbl90b2tlbiA9IG9wZW5fc3RhY2sucG9wKCk7XG4gICAgICBjdXJyZW50LnBhcmVudCA9IG9wZW5fdG9rZW47XG4gICAgfVxuXG4gICAgY3VycmVudC5wcmV2aW91cyA9IHByZXZpb3VzO1xuICAgIHByZXZpb3VzLm5leHQgPSBjdXJyZW50O1xuXG4gICAgdGhpcy5fX3Rva2Vucy5hZGQoY3VycmVudCk7XG4gICAgcHJldmlvdXMgPSBjdXJyZW50O1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuX190b2tlbnM7XG59O1xuXG5cblRva2VuaXplci5wcm90b3R5cGUuX2lzX2ZpcnN0X3Rva2VuID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9fdG9rZW5zLmlzRW1wdHkoKTtcbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX3Jlc2V0ID0gZnVuY3Rpb24oKSB7fTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5fZ2V0X25leHRfdG9rZW4gPSBmdW5jdGlvbihwcmV2aW91c190b2tlbiwgb3Blbl90b2tlbikgeyAvLyBqc2hpbnQgdW51c2VkOmZhbHNlXG4gIHRoaXMuX3JlYWRXaGl0ZXNwYWNlKCk7XG4gIHZhciByZXN1bHRpbmdfc3RyaW5nID0gdGhpcy5faW5wdXQucmVhZCgvLisvZyk7XG4gIGlmIChyZXN1bHRpbmdfc3RyaW5nKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NyZWF0ZV90b2tlbihUT0tFTi5SQVcsIHJlc3VsdGluZ19zdHJpbmcpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0aGlzLl9jcmVhdGVfdG9rZW4oVE9LRU4uRU9GLCAnJyk7XG4gIH1cbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX2lzX2NvbW1lbnQgPSBmdW5jdGlvbihjdXJyZW50X3Rva2VuKSB7IC8vIGpzaGludCB1bnVzZWQ6ZmFsc2VcbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5faXNfb3BlbmluZyA9IGZ1bmN0aW9uKGN1cnJlbnRfdG9rZW4pIHsgLy8ganNoaW50IHVudXNlZDpmYWxzZVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9pc19jbG9zaW5nID0gZnVuY3Rpb24oY3VycmVudF90b2tlbiwgb3Blbl90b2tlbikgeyAvLyBqc2hpbnQgdW51c2VkOmZhbHNlXG4gIHJldHVybiBmYWxzZTtcbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX2NyZWF0ZV90b2tlbiA9IGZ1bmN0aW9uKHR5cGUsIHRleHQpIHtcbiAgdmFyIHRva2VuID0gbmV3IFRva2VuKHR5cGUsIHRleHQsXG4gICAgdGhpcy5fcGF0dGVybnMud2hpdGVzcGFjZS5uZXdsaW5lX2NvdW50LFxuICAgIHRoaXMuX3BhdHRlcm5zLndoaXRlc3BhY2Uud2hpdGVzcGFjZV9iZWZvcmVfdG9rZW4pO1xuICByZXR1cm4gdG9rZW47XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9yZWFkV2hpdGVzcGFjZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fcGF0dGVybnMud2hpdGVzcGFjZS5yZWFkKCk7XG59O1xuXG5cblxubW9kdWxlLmV4cG9ydHMuVG9rZW5pemVyID0gVG9rZW5pemVyO1xubW9kdWxlLmV4cG9ydHMuVE9LRU4gPSBUT0tFTjtcblxuXG4vKioqLyB9KSxcbi8qIDEwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLypqc2hpbnQgbm9kZTp0cnVlICovXG4vKlxuXG4gIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4gIENvcHlyaWdodCAoYykgMjAwNy0yMDE4IEVpbmFyIExpZWxtYW5pcywgTGlhbSBOZXdtYW4sIGFuZCBjb250cmlidXRvcnMuXG5cbiAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICBTT0ZUV0FSRS5cbiovXG5cblxuXG5mdW5jdGlvbiBUb2tlblN0cmVhbShwYXJlbnRfdG9rZW4pIHtcbiAgLy8gcHJpdmF0ZVxuICB0aGlzLl9fdG9rZW5zID0gW107XG4gIHRoaXMuX190b2tlbnNfbGVuZ3RoID0gdGhpcy5fX3Rva2Vucy5sZW5ndGg7XG4gIHRoaXMuX19wb3NpdGlvbiA9IDA7XG4gIHRoaXMuX19wYXJlbnRfdG9rZW4gPSBwYXJlbnRfdG9rZW47XG59XG5cblRva2VuU3RyZWFtLnByb3RvdHlwZS5yZXN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX19wb3NpdGlvbiA9IDA7XG59O1xuXG5Ub2tlblN0cmVhbS5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fX3Rva2Vuc19sZW5ndGggPT09IDA7XG59O1xuXG5Ub2tlblN0cmVhbS5wcm90b3R5cGUuaGFzTmV4dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fX3Bvc2l0aW9uIDwgdGhpcy5fX3Rva2Vuc19sZW5ndGg7XG59O1xuXG5Ub2tlblN0cmVhbS5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgdmFsID0gbnVsbDtcbiAgaWYgKHRoaXMuaGFzTmV4dCgpKSB7XG4gICAgdmFsID0gdGhpcy5fX3Rva2Vuc1t0aGlzLl9fcG9zaXRpb25dO1xuICAgIHRoaXMuX19wb3NpdGlvbiArPSAxO1xuICB9XG4gIHJldHVybiB2YWw7XG59O1xuXG5Ub2tlblN0cmVhbS5wcm90b3R5cGUucGVlayA9IGZ1bmN0aW9uKGluZGV4KSB7XG4gIHZhciB2YWwgPSBudWxsO1xuICBpbmRleCA9IGluZGV4IHx8IDA7XG4gIGluZGV4ICs9IHRoaXMuX19wb3NpdGlvbjtcbiAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPCB0aGlzLl9fdG9rZW5zX2xlbmd0aCkge1xuICAgIHZhbCA9IHRoaXMuX190b2tlbnNbaW5kZXhdO1xuICB9XG4gIHJldHVybiB2YWw7XG59O1xuXG5Ub2tlblN0cmVhbS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24odG9rZW4pIHtcbiAgaWYgKHRoaXMuX19wYXJlbnRfdG9rZW4pIHtcbiAgICB0b2tlbi5wYXJlbnQgPSB0aGlzLl9fcGFyZW50X3Rva2VuO1xuICB9XG4gIHRoaXMuX190b2tlbnMucHVzaCh0b2tlbik7XG4gIHRoaXMuX190b2tlbnNfbGVuZ3RoICs9IDE7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5Ub2tlblN0cmVhbSA9IFRva2VuU3RyZWFtO1xuXG5cbi8qKiovIH0pLFxuLyogMTEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKmpzaGludCBub2RlOnRydWUgKi9cbi8qXG5cbiAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiAgQ29weXJpZ2h0IChjKSAyMDA3LTIwMTggRWluYXIgTGllbG1hbmlzLCBMaWFtIE5ld21hbiwgYW5kIGNvbnRyaWJ1dG9ycy5cblxuICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gIFNPRlRXQVJFLlxuKi9cblxuXG5cbnZhciBQYXR0ZXJuID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMikuUGF0dGVybjtcblxuZnVuY3Rpb24gV2hpdGVzcGFjZVBhdHRlcm4oaW5wdXRfc2Nhbm5lciwgcGFyZW50KSB7XG4gIFBhdHRlcm4uY2FsbCh0aGlzLCBpbnB1dF9zY2FubmVyLCBwYXJlbnQpO1xuICBpZiAocGFyZW50KSB7XG4gICAgdGhpcy5fbGluZV9yZWdleHAgPSB0aGlzLl9pbnB1dC5nZXRfcmVnZXhwKHBhcmVudC5fbGluZV9yZWdleHApO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX19zZXRfd2hpdGVzcGFjZV9wYXR0ZXJucygnJywgJycpO1xuICB9XG5cbiAgdGhpcy5uZXdsaW5lX2NvdW50ID0gMDtcbiAgdGhpcy53aGl0ZXNwYWNlX2JlZm9yZV90b2tlbiA9ICcnO1xufVxuV2hpdGVzcGFjZVBhdHRlcm4ucHJvdG90eXBlID0gbmV3IFBhdHRlcm4oKTtcblxuV2hpdGVzcGFjZVBhdHRlcm4ucHJvdG90eXBlLl9fc2V0X3doaXRlc3BhY2VfcGF0dGVybnMgPSBmdW5jdGlvbih3aGl0ZXNwYWNlX2NoYXJzLCBuZXdsaW5lX2NoYXJzKSB7XG4gIHdoaXRlc3BhY2VfY2hhcnMgKz0gJ1xcXFx0ICc7XG4gIG5ld2xpbmVfY2hhcnMgKz0gJ1xcXFxuXFxcXHInO1xuXG4gIHRoaXMuX21hdGNoX3BhdHRlcm4gPSB0aGlzLl9pbnB1dC5nZXRfcmVnZXhwKFxuICAgICdbJyArIHdoaXRlc3BhY2VfY2hhcnMgKyBuZXdsaW5lX2NoYXJzICsgJ10rJywgdHJ1ZSk7XG4gIHRoaXMuX25ld2xpbmVfcmVnZXhwID0gdGhpcy5faW5wdXQuZ2V0X3JlZ2V4cChcbiAgICAnXFxcXHJcXFxcbnxbJyArIG5ld2xpbmVfY2hhcnMgKyAnXScpO1xufTtcblxuV2hpdGVzcGFjZVBhdHRlcm4ucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5uZXdsaW5lX2NvdW50ID0gMDtcbiAgdGhpcy53aGl0ZXNwYWNlX2JlZm9yZV90b2tlbiA9ICcnO1xuXG4gIHZhciByZXN1bHRpbmdfc3RyaW5nID0gdGhpcy5faW5wdXQucmVhZCh0aGlzLl9tYXRjaF9wYXR0ZXJuKTtcbiAgaWYgKHJlc3VsdGluZ19zdHJpbmcgPT09ICcgJykge1xuICAgIHRoaXMud2hpdGVzcGFjZV9iZWZvcmVfdG9rZW4gPSAnICc7XG4gIH0gZWxzZSBpZiAocmVzdWx0aW5nX3N0cmluZykge1xuICAgIHZhciBtYXRjaGVzID0gdGhpcy5fX3NwbGl0KHRoaXMuX25ld2xpbmVfcmVnZXhwLCByZXN1bHRpbmdfc3RyaW5nKTtcbiAgICB0aGlzLm5ld2xpbmVfY291bnQgPSBtYXRjaGVzLmxlbmd0aCAtIDE7XG4gICAgdGhpcy53aGl0ZXNwYWNlX2JlZm9yZV90b2tlbiA9IG1hdGNoZXNbdGhpcy5uZXdsaW5lX2NvdW50XTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHRpbmdfc3RyaW5nO1xufTtcblxuV2hpdGVzcGFjZVBhdHRlcm4ucHJvdG90eXBlLm1hdGNoaW5nID0gZnVuY3Rpb24od2hpdGVzcGFjZV9jaGFycywgbmV3bGluZV9jaGFycykge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5fY3JlYXRlKCk7XG4gIHJlc3VsdC5fX3NldF93aGl0ZXNwYWNlX3BhdHRlcm5zKHdoaXRlc3BhY2VfY2hhcnMsIG5ld2xpbmVfY2hhcnMpO1xuICByZXN1bHQuX3VwZGF0ZSgpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuV2hpdGVzcGFjZVBhdHRlcm4ucHJvdG90eXBlLl9jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBXaGl0ZXNwYWNlUGF0dGVybih0aGlzLl9pbnB1dCwgdGhpcyk7XG59O1xuXG5XaGl0ZXNwYWNlUGF0dGVybi5wcm90b3R5cGUuX19zcGxpdCA9IGZ1bmN0aW9uKHJlZ2V4cCwgaW5wdXRfc3RyaW5nKSB7XG4gIHJlZ2V4cC5sYXN0SW5kZXggPSAwO1xuICB2YXIgc3RhcnRfaW5kZXggPSAwO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBuZXh0X21hdGNoID0gcmVnZXhwLmV4ZWMoaW5wdXRfc3RyaW5nKTtcbiAgd2hpbGUgKG5leHRfbWF0Y2gpIHtcbiAgICByZXN1bHQucHVzaChpbnB1dF9zdHJpbmcuc3Vic3RyaW5nKHN0YXJ0X2luZGV4LCBuZXh0X21hdGNoLmluZGV4KSk7XG4gICAgc3RhcnRfaW5kZXggPSBuZXh0X21hdGNoLmluZGV4ICsgbmV4dF9tYXRjaFswXS5sZW5ndGg7XG4gICAgbmV4dF9tYXRjaCA9IHJlZ2V4cC5leGVjKGlucHV0X3N0cmluZyk7XG4gIH1cblxuICBpZiAoc3RhcnRfaW5kZXggPCBpbnB1dF9zdHJpbmcubGVuZ3RoKSB7XG4gICAgcmVzdWx0LnB1c2goaW5wdXRfc3RyaW5nLnN1YnN0cmluZyhzdGFydF9pbmRleCwgaW5wdXRfc3RyaW5nLmxlbmd0aCkpO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdC5wdXNoKCcnKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cblxubW9kdWxlLmV4cG9ydHMuV2hpdGVzcGFjZVBhdHRlcm4gPSBXaGl0ZXNwYWNlUGF0dGVybjtcblxuXG4vKioqLyB9KSxcbi8qIDEyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLypqc2hpbnQgbm9kZTp0cnVlICovXG4vKlxuXG4gIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4gIENvcHlyaWdodCAoYykgMjAwNy0yMDE4IEVpbmFyIExpZWxtYW5pcywgTGlhbSBOZXdtYW4sIGFuZCBjb250cmlidXRvcnMuXG5cbiAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICBTT0ZUV0FSRS5cbiovXG5cblxuXG5mdW5jdGlvbiBQYXR0ZXJuKGlucHV0X3NjYW5uZXIsIHBhcmVudCkge1xuICB0aGlzLl9pbnB1dCA9IGlucHV0X3NjYW5uZXI7XG4gIHRoaXMuX3N0YXJ0aW5nX3BhdHRlcm4gPSBudWxsO1xuICB0aGlzLl9tYXRjaF9wYXR0ZXJuID0gbnVsbDtcbiAgdGhpcy5fdW50aWxfcGF0dGVybiA9IG51bGw7XG4gIHRoaXMuX3VudGlsX2FmdGVyID0gZmFsc2U7XG5cbiAgaWYgKHBhcmVudCkge1xuICAgIHRoaXMuX3N0YXJ0aW5nX3BhdHRlcm4gPSB0aGlzLl9pbnB1dC5nZXRfcmVnZXhwKHBhcmVudC5fc3RhcnRpbmdfcGF0dGVybiwgdHJ1ZSk7XG4gICAgdGhpcy5fbWF0Y2hfcGF0dGVybiA9IHRoaXMuX2lucHV0LmdldF9yZWdleHAocGFyZW50Ll9tYXRjaF9wYXR0ZXJuLCB0cnVlKTtcbiAgICB0aGlzLl91bnRpbF9wYXR0ZXJuID0gdGhpcy5faW5wdXQuZ2V0X3JlZ2V4cChwYXJlbnQuX3VudGlsX3BhdHRlcm4pO1xuICAgIHRoaXMuX3VudGlsX2FmdGVyID0gcGFyZW50Ll91bnRpbF9hZnRlcjtcbiAgfVxufVxuXG5QYXR0ZXJuLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24oKSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLl9pbnB1dC5yZWFkKHRoaXMuX3N0YXJ0aW5nX3BhdHRlcm4pO1xuICBpZiAoIXRoaXMuX3N0YXJ0aW5nX3BhdHRlcm4gfHwgcmVzdWx0KSB7XG4gICAgcmVzdWx0ICs9IHRoaXMuX2lucHV0LnJlYWQodGhpcy5fbWF0Y2hfcGF0dGVybiwgdGhpcy5fdW50aWxfcGF0dGVybiwgdGhpcy5fdW50aWxfYWZ0ZXIpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5QYXR0ZXJuLnByb3RvdHlwZS5yZWFkX21hdGNoID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9pbnB1dC5tYXRjaCh0aGlzLl9tYXRjaF9wYXR0ZXJuKTtcbn07XG5cblBhdHRlcm4ucHJvdG90eXBlLnVudGlsX2FmdGVyID0gZnVuY3Rpb24ocGF0dGVybikge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5fY3JlYXRlKCk7XG4gIHJlc3VsdC5fdW50aWxfYWZ0ZXIgPSB0cnVlO1xuICByZXN1bHQuX3VudGlsX3BhdHRlcm4gPSB0aGlzLl9pbnB1dC5nZXRfcmVnZXhwKHBhdHRlcm4pO1xuICByZXN1bHQuX3VwZGF0ZSgpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuUGF0dGVybi5wcm90b3R5cGUudW50aWwgPSBmdW5jdGlvbihwYXR0ZXJuKSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLl9jcmVhdGUoKTtcbiAgcmVzdWx0Ll91bnRpbF9hZnRlciA9IGZhbHNlO1xuICByZXN1bHQuX3VudGlsX3BhdHRlcm4gPSB0aGlzLl9pbnB1dC5nZXRfcmVnZXhwKHBhdHRlcm4pO1xuICByZXN1bHQuX3VwZGF0ZSgpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuUGF0dGVybi5wcm90b3R5cGUuc3RhcnRpbmdfd2l0aCA9IGZ1bmN0aW9uKHBhdHRlcm4pIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMuX2NyZWF0ZSgpO1xuICByZXN1bHQuX3N0YXJ0aW5nX3BhdHRlcm4gPSB0aGlzLl9pbnB1dC5nZXRfcmVnZXhwKHBhdHRlcm4sIHRydWUpO1xuICByZXN1bHQuX3VwZGF0ZSgpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuUGF0dGVybi5wcm90b3R5cGUubWF0Y2hpbmcgPSBmdW5jdGlvbihwYXR0ZXJuKSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLl9jcmVhdGUoKTtcbiAgcmVzdWx0Ll9tYXRjaF9wYXR0ZXJuID0gdGhpcy5faW5wdXQuZ2V0X3JlZ2V4cChwYXR0ZXJuLCB0cnVlKTtcbiAgcmVzdWx0Ll91cGRhdGUoKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblBhdHRlcm4ucHJvdG90eXBlLl9jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBQYXR0ZXJuKHRoaXMuX2lucHV0LCB0aGlzKTtcbn07XG5cblBhdHRlcm4ucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbigpIHt9O1xuXG5tb2R1bGUuZXhwb3J0cy5QYXR0ZXJuID0gUGF0dGVybjtcblxuXG4vKioqLyB9KSxcbi8qIDEzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLypqc2hpbnQgbm9kZTp0cnVlICovXG4vKlxuXG4gIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4gIENvcHlyaWdodCAoYykgMjAwNy0yMDE4IEVpbmFyIExpZWxtYW5pcywgTGlhbSBOZXdtYW4sIGFuZCBjb250cmlidXRvcnMuXG5cbiAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICBTT0ZUV0FSRS5cbiovXG5cblxuXG5mdW5jdGlvbiBEaXJlY3RpdmVzKHN0YXJ0X2Jsb2NrX3BhdHRlcm4sIGVuZF9ibG9ja19wYXR0ZXJuKSB7XG4gIHN0YXJ0X2Jsb2NrX3BhdHRlcm4gPSB0eXBlb2Ygc3RhcnRfYmxvY2tfcGF0dGVybiA9PT0gJ3N0cmluZycgPyBzdGFydF9ibG9ja19wYXR0ZXJuIDogc3RhcnRfYmxvY2tfcGF0dGVybi5zb3VyY2U7XG4gIGVuZF9ibG9ja19wYXR0ZXJuID0gdHlwZW9mIGVuZF9ibG9ja19wYXR0ZXJuID09PSAnc3RyaW5nJyA/IGVuZF9ibG9ja19wYXR0ZXJuIDogZW5kX2Jsb2NrX3BhdHRlcm4uc291cmNlO1xuICB0aGlzLl9fZGlyZWN0aXZlc19ibG9ja19wYXR0ZXJuID0gbmV3IFJlZ0V4cChzdGFydF9ibG9ja19wYXR0ZXJuICsgLyBiZWF1dGlmeSggXFx3K1s6XVxcdyspKyAvLnNvdXJjZSArIGVuZF9ibG9ja19wYXR0ZXJuLCAnZycpO1xuICB0aGlzLl9fZGlyZWN0aXZlX3BhdHRlcm4gPSAvIChcXHcrKVs6XShcXHcrKS9nO1xuXG4gIHRoaXMuX19kaXJlY3RpdmVzX2VuZF9pZ25vcmVfcGF0dGVybiA9IG5ldyBSZWdFeHAoc3RhcnRfYmxvY2tfcGF0dGVybiArIC9cXHNiZWF1dGlmeVxcc2lnbm9yZTplbmRcXHMvLnNvdXJjZSArIGVuZF9ibG9ja19wYXR0ZXJuLCAnZycpO1xufVxuXG5EaXJlY3RpdmVzLnByb3RvdHlwZS5nZXRfZGlyZWN0aXZlcyA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgaWYgKCF0ZXh0Lm1hdGNoKHRoaXMuX19kaXJlY3RpdmVzX2Jsb2NrX3BhdHRlcm4pKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgZGlyZWN0aXZlcyA9IHt9O1xuICB0aGlzLl9fZGlyZWN0aXZlX3BhdHRlcm4ubGFzdEluZGV4ID0gMDtcbiAgdmFyIGRpcmVjdGl2ZV9tYXRjaCA9IHRoaXMuX19kaXJlY3RpdmVfcGF0dGVybi5leGVjKHRleHQpO1xuXG4gIHdoaWxlIChkaXJlY3RpdmVfbWF0Y2gpIHtcbiAgICBkaXJlY3RpdmVzW2RpcmVjdGl2ZV9tYXRjaFsxXV0gPSBkaXJlY3RpdmVfbWF0Y2hbMl07XG4gICAgZGlyZWN0aXZlX21hdGNoID0gdGhpcy5fX2RpcmVjdGl2ZV9wYXR0ZXJuLmV4ZWModGV4dCk7XG4gIH1cblxuICByZXR1cm4gZGlyZWN0aXZlcztcbn07XG5cbkRpcmVjdGl2ZXMucHJvdG90eXBlLnJlYWRJZ25vcmVkID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgcmV0dXJuIGlucHV0LnJlYWRVbnRpbEFmdGVyKHRoaXMuX19kaXJlY3RpdmVzX2VuZF9pZ25vcmVfcGF0dGVybik7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzLkRpcmVjdGl2ZXMgPSBEaXJlY3RpdmVzO1xuXG5cbi8qKiovIH0pLFxuLyogMTQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKmpzaGludCBub2RlOnRydWUgKi9cbi8qXG5cbiAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiAgQ29weXJpZ2h0IChjKSAyMDA3LTIwMTggRWluYXIgTGllbG1hbmlzLCBMaWFtIE5ld21hbiwgYW5kIGNvbnRyaWJ1dG9ycy5cblxuICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gIFNPRlRXQVJFLlxuKi9cblxuXG5cbnZhciBQYXR0ZXJuID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMikuUGF0dGVybjtcblxuXG52YXIgdGVtcGxhdGVfbmFtZXMgPSB7XG4gIGRqYW5nbzogZmFsc2UsXG4gIGVyYjogZmFsc2UsXG4gIGhhbmRsZWJhcnM6IGZhbHNlLFxuICBwaHA6IGZhbHNlXG59O1xuXG4vLyBUaGlzIGxldHMgdGVtcGxhdGVzIGFwcGVhciBhbnl3aGVyZSB3ZSB3b3VsZCBkbyBhIHJlYWRVbnRpbFxuLy8gVGhlIGNvc3QgaXMgaGlnaGVyIGJ1dCBpdCBpcyBwYXkgdG8gcGxheS5cbmZ1bmN0aW9uIFRlbXBsYXRhYmxlUGF0dGVybihpbnB1dF9zY2FubmVyLCBwYXJlbnQpIHtcbiAgUGF0dGVybi5jYWxsKHRoaXMsIGlucHV0X3NjYW5uZXIsIHBhcmVudCk7XG4gIHRoaXMuX190ZW1wbGF0ZV9wYXR0ZXJuID0gbnVsbDtcbiAgdGhpcy5fZGlzYWJsZWQgPSBPYmplY3QuYXNzaWduKHt9LCB0ZW1wbGF0ZV9uYW1lcyk7XG4gIHRoaXMuX2V4Y2x1ZGVkID0gT2JqZWN0LmFzc2lnbih7fSwgdGVtcGxhdGVfbmFtZXMpO1xuXG4gIGlmIChwYXJlbnQpIHtcbiAgICB0aGlzLl9fdGVtcGxhdGVfcGF0dGVybiA9IHRoaXMuX2lucHV0LmdldF9yZWdleHAocGFyZW50Ll9fdGVtcGxhdGVfcGF0dGVybik7XG4gICAgdGhpcy5fZXhjbHVkZWQgPSBPYmplY3QuYXNzaWduKHRoaXMuX2V4Y2x1ZGVkLCBwYXJlbnQuX2V4Y2x1ZGVkKTtcbiAgICB0aGlzLl9kaXNhYmxlZCA9IE9iamVjdC5hc3NpZ24odGhpcy5fZGlzYWJsZWQsIHBhcmVudC5fZGlzYWJsZWQpO1xuICB9XG4gIHZhciBwYXR0ZXJuID0gbmV3IFBhdHRlcm4oaW5wdXRfc2Nhbm5lcik7XG4gIHRoaXMuX19wYXR0ZXJucyA9IHtcbiAgICBoYW5kbGViYXJzX2NvbW1lbnQ6IHBhdHRlcm4uc3RhcnRpbmdfd2l0aCgve3shLS0vKS51bnRpbF9hZnRlcigvLS19fS8pLFxuICAgIGhhbmRsZWJhcnNfdW5lc2NhcGVkOiBwYXR0ZXJuLnN0YXJ0aW5nX3dpdGgoL3t7ey8pLnVudGlsX2FmdGVyKC99fX0vKSxcbiAgICBoYW5kbGViYXJzOiBwYXR0ZXJuLnN0YXJ0aW5nX3dpdGgoL3t7LykudW50aWxfYWZ0ZXIoL319LyksXG4gICAgcGhwOiBwYXR0ZXJuLnN0YXJ0aW5nX3dpdGgoLzxcXD8oPzpbPV18cGhwKS8pLnVudGlsX2FmdGVyKC9cXD8+LyksXG4gICAgZXJiOiBwYXR0ZXJuLnN0YXJ0aW5nX3dpdGgoLzwlW14lXS8pLnVudGlsX2FmdGVyKC9bXiVdJT4vKSxcbiAgICAvLyBkamFuZ28gY29mbGljdHMgd2l0aCBoYW5kbGViYXJzIGEgYml0LlxuICAgIGRqYW5nbzogcGF0dGVybi5zdGFydGluZ193aXRoKC97JS8pLnVudGlsX2FmdGVyKC8lfS8pLFxuICAgIGRqYW5nb192YWx1ZTogcGF0dGVybi5zdGFydGluZ193aXRoKC97ey8pLnVudGlsX2FmdGVyKC99fS8pLFxuICAgIGRqYW5nb19jb21tZW50OiBwYXR0ZXJuLnN0YXJ0aW5nX3dpdGgoL3sjLykudW50aWxfYWZ0ZXIoLyN9LylcbiAgfTtcbn1cblRlbXBsYXRhYmxlUGF0dGVybi5wcm90b3R5cGUgPSBuZXcgUGF0dGVybigpO1xuXG5UZW1wbGF0YWJsZVBhdHRlcm4ucHJvdG90eXBlLl9jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUZW1wbGF0YWJsZVBhdHRlcm4odGhpcy5faW5wdXQsIHRoaXMpO1xufTtcblxuVGVtcGxhdGFibGVQYXR0ZXJuLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX19zZXRfdGVtcGxhdGVkX3BhdHRlcm4oKTtcbn07XG5cblRlbXBsYXRhYmxlUGF0dGVybi5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uKGxhbmd1YWdlKSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLl9jcmVhdGUoKTtcbiAgcmVzdWx0Ll9kaXNhYmxlZFtsYW5ndWFnZV0gPSB0cnVlO1xuICByZXN1bHQuX3VwZGF0ZSgpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuVGVtcGxhdGFibGVQYXR0ZXJuLnByb3RvdHlwZS5yZWFkX29wdGlvbnMgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLl9jcmVhdGUoKTtcbiAgZm9yICh2YXIgbGFuZ3VhZ2UgaW4gdGVtcGxhdGVfbmFtZXMpIHtcbiAgICByZXN1bHQuX2Rpc2FibGVkW2xhbmd1YWdlXSA9IG9wdGlvbnMudGVtcGxhdGluZy5pbmRleE9mKGxhbmd1YWdlKSA9PT0gLTE7XG4gIH1cbiAgcmVzdWx0Ll91cGRhdGUoKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblRlbXBsYXRhYmxlUGF0dGVybi5wcm90b3R5cGUuZXhjbHVkZSA9IGZ1bmN0aW9uKGxhbmd1YWdlKSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLl9jcmVhdGUoKTtcbiAgcmVzdWx0Ll9leGNsdWRlZFtsYW5ndWFnZV0gPSB0cnVlO1xuICByZXN1bHQuX3VwZGF0ZSgpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuVGVtcGxhdGFibGVQYXR0ZXJuLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24oKSB7XG4gIHZhciByZXN1bHQgPSAnJztcbiAgaWYgKHRoaXMuX21hdGNoX3BhdHRlcm4pIHtcbiAgICByZXN1bHQgPSB0aGlzLl9pbnB1dC5yZWFkKHRoaXMuX3N0YXJ0aW5nX3BhdHRlcm4pO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdCA9IHRoaXMuX2lucHV0LnJlYWQodGhpcy5fc3RhcnRpbmdfcGF0dGVybiwgdGhpcy5fX3RlbXBsYXRlX3BhdHRlcm4pO1xuICB9XG4gIHZhciBuZXh0ID0gdGhpcy5fcmVhZF90ZW1wbGF0ZSgpO1xuICB3aGlsZSAobmV4dCkge1xuICAgIGlmICh0aGlzLl9tYXRjaF9wYXR0ZXJuKSB7XG4gICAgICBuZXh0ICs9IHRoaXMuX2lucHV0LnJlYWQodGhpcy5fbWF0Y2hfcGF0dGVybik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHQgKz0gdGhpcy5faW5wdXQucmVhZFVudGlsKHRoaXMuX190ZW1wbGF0ZV9wYXR0ZXJuKTtcbiAgICB9XG4gICAgcmVzdWx0ICs9IG5leHQ7XG4gICAgbmV4dCA9IHRoaXMuX3JlYWRfdGVtcGxhdGUoKTtcbiAgfVxuXG4gIGlmICh0aGlzLl91bnRpbF9hZnRlcikge1xuICAgIHJlc3VsdCArPSB0aGlzLl9pbnB1dC5yZWFkVW50aWxBZnRlcih0aGlzLl91bnRpbF9wYXR0ZXJuKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuVGVtcGxhdGFibGVQYXR0ZXJuLnByb3RvdHlwZS5fX3NldF90ZW1wbGF0ZWRfcGF0dGVybiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaXRlbXMgPSBbXTtcblxuICBpZiAoIXRoaXMuX2Rpc2FibGVkLnBocCkge1xuICAgIGl0ZW1zLnB1c2godGhpcy5fX3BhdHRlcm5zLnBocC5fc3RhcnRpbmdfcGF0dGVybi5zb3VyY2UpO1xuICB9XG4gIGlmICghdGhpcy5fZGlzYWJsZWQuaGFuZGxlYmFycykge1xuICAgIGl0ZW1zLnB1c2godGhpcy5fX3BhdHRlcm5zLmhhbmRsZWJhcnMuX3N0YXJ0aW5nX3BhdHRlcm4uc291cmNlKTtcbiAgfVxuICBpZiAoIXRoaXMuX2Rpc2FibGVkLmVyYikge1xuICAgIGl0ZW1zLnB1c2godGhpcy5fX3BhdHRlcm5zLmVyYi5fc3RhcnRpbmdfcGF0dGVybi5zb3VyY2UpO1xuICB9XG4gIGlmICghdGhpcy5fZGlzYWJsZWQuZGphbmdvKSB7XG4gICAgaXRlbXMucHVzaCh0aGlzLl9fcGF0dGVybnMuZGphbmdvLl9zdGFydGluZ19wYXR0ZXJuLnNvdXJjZSk7XG4gICAgaXRlbXMucHVzaCh0aGlzLl9fcGF0dGVybnMuZGphbmdvX3ZhbHVlLl9zdGFydGluZ19wYXR0ZXJuLnNvdXJjZSk7XG4gICAgaXRlbXMucHVzaCh0aGlzLl9fcGF0dGVybnMuZGphbmdvX2NvbW1lbnQuX3N0YXJ0aW5nX3BhdHRlcm4uc291cmNlKTtcbiAgfVxuXG4gIGlmICh0aGlzLl91bnRpbF9wYXR0ZXJuKSB7XG4gICAgaXRlbXMucHVzaCh0aGlzLl91bnRpbF9wYXR0ZXJuLnNvdXJjZSk7XG4gIH1cbiAgdGhpcy5fX3RlbXBsYXRlX3BhdHRlcm4gPSB0aGlzLl9pbnB1dC5nZXRfcmVnZXhwKCcoPzonICsgaXRlbXMuam9pbignfCcpICsgJyknKTtcbn07XG5cblRlbXBsYXRhYmxlUGF0dGVybi5wcm90b3R5cGUuX3JlYWRfdGVtcGxhdGUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJlc3VsdGluZ19zdHJpbmcgPSAnJztcbiAgdmFyIGMgPSB0aGlzLl9pbnB1dC5wZWVrKCk7XG4gIGlmIChjID09PSAnPCcpIHtcbiAgICB2YXIgcGVlazEgPSB0aGlzLl9pbnB1dC5wZWVrKDEpO1xuICAgIC8vaWYgd2UncmUgaW4gYSBjb21tZW50LCBkbyBzb21ldGhpbmcgc3BlY2lhbFxuICAgIC8vIFdlIHRyZWF0IGFsbCBjb21tZW50cyBhcyBsaXRlcmFscywgZXZlbiBtb3JlIHRoYW4gcHJlZm9ybWF0dGVkIHRhZ3NcbiAgICAvLyB3ZSBqdXN0IGxvb2sgZm9yIHRoZSBhcHByb3ByaWF0ZSBjbG9zZSB0YWdcbiAgICBpZiAoIXRoaXMuX2Rpc2FibGVkLnBocCAmJiAhdGhpcy5fZXhjbHVkZWQucGhwICYmIHBlZWsxID09PSAnPycpIHtcbiAgICAgIHJlc3VsdGluZ19zdHJpbmcgPSByZXN1bHRpbmdfc3RyaW5nIHx8XG4gICAgICAgIHRoaXMuX19wYXR0ZXJucy5waHAucmVhZCgpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX2Rpc2FibGVkLmVyYiAmJiAhdGhpcy5fZXhjbHVkZWQuZXJiICYmIHBlZWsxID09PSAnJScpIHtcbiAgICAgIHJlc3VsdGluZ19zdHJpbmcgPSByZXN1bHRpbmdfc3RyaW5nIHx8XG4gICAgICAgIHRoaXMuX19wYXR0ZXJucy5lcmIucmVhZCgpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChjID09PSAneycpIHtcbiAgICBpZiAoIXRoaXMuX2Rpc2FibGVkLmhhbmRsZWJhcnMgJiYgIXRoaXMuX2V4Y2x1ZGVkLmhhbmRsZWJhcnMpIHtcbiAgICAgIHJlc3VsdGluZ19zdHJpbmcgPSByZXN1bHRpbmdfc3RyaW5nIHx8XG4gICAgICAgIHRoaXMuX19wYXR0ZXJucy5oYW5kbGViYXJzX2NvbW1lbnQucmVhZCgpO1xuICAgICAgcmVzdWx0aW5nX3N0cmluZyA9IHJlc3VsdGluZ19zdHJpbmcgfHxcbiAgICAgICAgdGhpcy5fX3BhdHRlcm5zLmhhbmRsZWJhcnNfdW5lc2NhcGVkLnJlYWQoKTtcbiAgICAgIHJlc3VsdGluZ19zdHJpbmcgPSByZXN1bHRpbmdfc3RyaW5nIHx8XG4gICAgICAgIHRoaXMuX19wYXR0ZXJucy5oYW5kbGViYXJzLnJlYWQoKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl9kaXNhYmxlZC5kamFuZ28pIHtcbiAgICAgIC8vIGRqYW5nbyBjb2ZsaWN0cyB3aXRoIGhhbmRsZWJhcnMgYSBiaXQuXG4gICAgICBpZiAoIXRoaXMuX2V4Y2x1ZGVkLmRqYW5nbyAmJiAhdGhpcy5fZXhjbHVkZWQuaGFuZGxlYmFycykge1xuICAgICAgICByZXN1bHRpbmdfc3RyaW5nID0gcmVzdWx0aW5nX3N0cmluZyB8fFxuICAgICAgICAgIHRoaXMuX19wYXR0ZXJucy5kamFuZ29fdmFsdWUucmVhZCgpO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLl9leGNsdWRlZC5kamFuZ28pIHtcbiAgICAgICAgcmVzdWx0aW5nX3N0cmluZyA9IHJlc3VsdGluZ19zdHJpbmcgfHxcbiAgICAgICAgICB0aGlzLl9fcGF0dGVybnMuZGphbmdvX2NvbW1lbnQucmVhZCgpO1xuICAgICAgICByZXN1bHRpbmdfc3RyaW5nID0gcmVzdWx0aW5nX3N0cmluZyB8fFxuICAgICAgICAgIHRoaXMuX19wYXR0ZXJucy5kamFuZ28ucmVhZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0aW5nX3N0cmluZztcbn07XG5cblxubW9kdWxlLmV4cG9ydHMuVGVtcGxhdGFibGVQYXR0ZXJuID0gVGVtcGxhdGFibGVQYXR0ZXJuO1xuXG5cbi8qKiovIH0pXG4vKioqKioqLyBdKTtcbnZhciBqc19iZWF1dGlmeSA9IGxlZ2FjeV9iZWF1dGlmeV9qcztcbi8qIEZvb3RlciAqL1xuaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG4gICAgLy8gQWRkIHN1cHBvcnQgZm9yIEFNRCAoIGh0dHBzOi8vZ2l0aHViLmNvbS9hbWRqcy9hbWRqcy1hcGkvd2lraS9BTUQjZGVmaW5lYW1kLXByb3BlcnR5LSApXG4gICAgZGVmaW5lKFtdLCBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHsganNfYmVhdXRpZnk6IGpzX2JlYXV0aWZ5IH07XG4gICAgfSk7XG59IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgLy8gQWRkIHN1cHBvcnQgZm9yIENvbW1vbkpTLiBKdXN0IHB1dCB0aGlzIGZpbGUgc29tZXdoZXJlIG9uIHlvdXIgcmVxdWlyZS5wYXRoc1xuICAgIC8vIGFuZCB5b3Ugd2lsbCBiZSBhYmxlIHRvIGB2YXIganNfYmVhdXRpZnkgPSByZXF1aXJlKFwiYmVhdXRpZnlcIikuanNfYmVhdXRpZnlgLlxuICAgIGV4cG9ydHMuanNfYmVhdXRpZnkgPSBqc19iZWF1dGlmeTtcbn0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIC8vIElmIHdlJ3JlIHJ1bm5pbmcgYSB3ZWIgcGFnZSBhbmQgZG9uJ3QgaGF2ZSBlaXRoZXIgb2YgdGhlIGFib3ZlLCBhZGQgb3VyIG9uZSBnbG9iYWxcbiAgICB3aW5kb3cuanNfYmVhdXRpZnkgPSBqc19iZWF1dGlmeTtcbn0gZWxzZSBpZiAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIC8vIElmIHdlIGRvbid0IGV2ZW4gaGF2ZSB3aW5kb3csIHRyeSBnbG9iYWwuXG4gICAgZ2xvYmFsLmpzX2JlYXV0aWZ5ID0ganNfYmVhdXRpZnk7XG59XG5cbn0oKSk7XG5cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/js-beautify/js/lib/beautify.js\n");

/***/ }),

/***/ "./node_modules/style-loader/lib/addStyles.js":
/*!****************************************************!*\
  !*** ./node_modules/style-loader/lib/addStyles.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\nvar stylesInDom = {};\n\nvar\tmemoize = function (fn) {\n\tvar memo;\n\n\treturn function () {\n\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\treturn memo;\n\t};\n};\n\nvar isOldIE = memoize(function () {\n\t// Test for IE <= 9 as proposed by Browserhacks\n\t// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n\t// Tests for existence of standard globals is to allow style-loader\n\t// to operate correctly into non-standard environments\n\t// @see https://github.com/webpack-contrib/style-loader/issues/177\n\treturn window && document && document.all && !window.atob;\n});\n\nvar getTarget = function (target, parent) {\n  if (parent){\n    return parent.querySelector(target);\n  }\n  return document.querySelector(target);\n};\n\nvar getElement = (function (fn) {\n\tvar memo = {};\n\n\treturn function(target, parent) {\n                // If passing function in options, then use it for resolve \"head\" element.\n                // Useful for Shadow Root style i.e\n                // {\n                //   insertInto: function () { return document.querySelector(\"#foo\").shadowRoot }\n                // }\n                if (typeof target === 'function') {\n                        return target();\n                }\n                if (typeof memo[target] === \"undefined\") {\n\t\t\tvar styleTarget = getTarget.call(this, target, parent);\n\t\t\t// Special case to return head of iframe instead of iframe itself\n\t\t\tif (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n\t\t\t\ttry {\n\t\t\t\t\t// This will throw an exception if access to iframe is blocked\n\t\t\t\t\t// due to cross-origin restrictions\n\t\t\t\t\tstyleTarget = styleTarget.contentDocument.head;\n\t\t\t\t} catch(e) {\n\t\t\t\t\tstyleTarget = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemo[target] = styleTarget;\n\t\t}\n\t\treturn memo[target]\n\t};\n})();\n\nvar singleton = null;\nvar\tsingletonCounter = 0;\nvar\tstylesInsertedAtTop = [];\n\nvar\tfixUrls = __webpack_require__(/*! ./urls */ \"./node_modules/style-loader/lib/urls.js\");\n\nmodule.exports = function(list, options) {\n\tif (typeof DEBUG !== \"undefined\" && DEBUG) {\n\t\tif (typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t}\n\n\toptions = options || {};\n\n\toptions.attrs = typeof options.attrs === \"object\" ? options.attrs : {};\n\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (!options.singleton && typeof options.singleton !== \"boolean\") options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the <head> element\n        if (!options.insertInto) options.insertInto = \"head\";\n\n\t// By default, add <style> tags to the bottom of the target\n\tif (!options.insertAt) options.insertAt = \"bottom\";\n\n\tvar styles = listToStyles(list, options);\n\n\taddStylesToDom(styles, options);\n\n\treturn function update (newList) {\n\t\tvar mayRemove = [];\n\n\t\tfor (var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList, options);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\n\t\tfor (var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();\n\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n};\n\nfunction addStylesToDom (styles, options) {\n\tfor (var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles (list, options) {\n\tvar styles = [];\n\tvar newStyles = {};\n\n\tfor (var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = options.base ? item[0] + options.base : item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\n\t\tif(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse newStyles[id].parts.push(part);\n\t}\n\n\treturn styles;\n}\n\nfunction insertStyleElement (options, style) {\n\tvar target = getElement(options.insertInto)\n\n\tif (!target) {\n\t\tthrow new Error(\"Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.\");\n\t}\n\n\tvar lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];\n\n\tif (options.insertAt === \"top\") {\n\t\tif (!lastStyleElementInsertedAtTop) {\n\t\t\ttarget.insertBefore(style, target.firstChild);\n\t\t} else if (lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\ttarget.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\ttarget.appendChild(style);\n\t\t}\n\t\tstylesInsertedAtTop.push(style);\n\t} else if (options.insertAt === \"bottom\") {\n\t\ttarget.appendChild(style);\n\t} else if (typeof options.insertAt === \"object\" && options.insertAt.before) {\n\t\tvar nextSibling = getElement(options.insertAt.before, target);\n\t\ttarget.insertBefore(style, nextSibling);\n\t} else {\n\t\tthrow new Error(\"[Style Loader]\\n\\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\\n Must be 'top', 'bottom', or Object.\\n (https://github.com/webpack-contrib/style-loader#insertat)\\n\");\n\t}\n}\n\nfunction removeStyleElement (style) {\n\tif (style.parentNode === null) return false;\n\tstyle.parentNode.removeChild(style);\n\n\tvar idx = stylesInsertedAtTop.indexOf(style);\n\tif(idx >= 0) {\n\t\tstylesInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement (options) {\n\tvar style = document.createElement(\"style\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\n\tif(options.attrs.nonce === undefined) {\n\t\tvar nonce = getNonce();\n\t\tif (nonce) {\n\t\t\toptions.attrs.nonce = nonce;\n\t\t}\n\t}\n\n\taddAttrs(style, options.attrs);\n\tinsertStyleElement(options, style);\n\n\treturn style;\n}\n\nfunction createLinkElement (options) {\n\tvar link = document.createElement(\"link\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\toptions.attrs.rel = \"stylesheet\";\n\n\taddAttrs(link, options.attrs);\n\tinsertStyleElement(options, link);\n\n\treturn link;\n}\n\nfunction addAttrs (el, attrs) {\n\tObject.keys(attrs).forEach(function (key) {\n\t\tel.setAttribute(key, attrs[key]);\n\t});\n}\n\nfunction getNonce() {\n\tif (false) {}\n\n\treturn __webpack_require__.nc;\n}\n\nfunction addStyle (obj, options) {\n\tvar style, update, remove, result;\n\n\t// If a transform function was defined, run it on the css\n\tif (options.transform && obj.css) {\n\t    result = typeof options.transform === 'function'\n\t\t ? options.transform(obj.css) \n\t\t : options.transform.default(obj.css);\n\n\t    if (result) {\n\t    \t// If transform returns a value, use that instead of the original css.\n\t    \t// This allows running runtime transformations on the css.\n\t    \tobj.css = result;\n\t    } else {\n\t    \t// If the transform function returns a falsy value, don't add this css.\n\t    \t// This allows conditional loading of css\n\t    \treturn function() {\n\t    \t\t// noop\n\t    \t};\n\t    }\n\t}\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\n\t\tstyle = singleton || (singleton = createStyleElement(options));\n\n\t\tupdate = applyToSingletonTag.bind(null, style, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, style, styleIndex, true);\n\n\t} else if (\n\t\tobj.sourceMap &&\n\t\ttypeof URL === \"function\" &&\n\t\ttypeof URL.createObjectURL === \"function\" &&\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\n\t\ttypeof Blob === \"function\" &&\n\t\ttypeof btoa === \"function\"\n\t) {\n\t\tstyle = createLinkElement(options);\n\t\tupdate = updateLink.bind(null, style, options);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\n\t\t\tif(style.href) URL.revokeObjectURL(style.href);\n\t\t};\n\t} else {\n\t\tstyle = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, style);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle (newObj) {\n\t\tif (newObj) {\n\t\t\tif (\n\t\t\t\tnewObj.css === obj.css &&\n\t\t\t\tnewObj.media === obj.media &&\n\t\t\t\tnewObj.sourceMap === obj.sourceMap\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\n\t\treturn textStore.filter(Boolean).join('\\n');\n\t};\n})();\n\nfunction applyToSingletonTag (style, index, remove, obj) {\n\tvar css = remove ? \"\" : obj.css;\n\n\tif (style.styleSheet) {\n\t\tstyle.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = style.childNodes;\n\n\t\tif (childNodes[index]) style.removeChild(childNodes[index]);\n\n\t\tif (childNodes.length) {\n\t\t\tstyle.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyle.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag (style, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\n\tif(media) {\n\t\tstyle.setAttribute(\"media\", media)\n\t}\n\n\tif(style.styleSheet) {\n\t\tstyle.styleSheet.cssText = css;\n\t} else {\n\t\twhile(style.firstChild) {\n\t\t\tstyle.removeChild(style.firstChild);\n\t\t}\n\n\t\tstyle.appendChild(document.createTextNode(css));\n\t}\n}\n\nfunction updateLink (link, options, obj) {\n\tvar css = obj.css;\n\tvar sourceMap = obj.sourceMap;\n\n\t/*\n\t\tIf convertToAbsoluteUrls isn't defined, but sourcemaps are enabled\n\t\tand there is no publicPath defined then lets turn convertToAbsoluteUrls\n\t\ton by default.  Otherwise default to the convertToAbsoluteUrls option\n\t\tdirectly\n\t*/\n\tvar autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;\n\n\tif (options.convertToAbsoluteUrls || autoFixUrls) {\n\t\tcss = fixUrls(css);\n\t}\n\n\tif (sourceMap) {\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t}\n\n\tvar blob = new Blob([css], { type: \"text/css\" });\n\n\tvar oldSrc = link.href;\n\n\tlink.href = URL.createObjectURL(blob);\n\n\tif(oldSrc) URL.revokeObjectURL(oldSrc);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanM/Njg0NCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBLGNBQWMsbUJBQU8sQ0FBQyx1REFBUTs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQixtQkFBbUI7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLHNCQUFzQjtBQUN2Qzs7QUFFQTtBQUNBLG1CQUFtQiwyQkFBMkI7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsbUJBQW1CO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQkFBaUIsMkJBQTJCO0FBQzVDO0FBQ0E7O0FBRUEsUUFBUSx1QkFBdUI7QUFDL0I7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQSxpQkFBaUIsdUJBQXVCO0FBQ3hDO0FBQ0E7O0FBRUEsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYzs7QUFFZCxrREFBa0Qsc0JBQXNCO0FBQ3hFO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0EsS0FBSyxLQUF3QyxFQUFFLEVBRTdDOztBQUVGLFFBQVEsc0JBQWlCO0FBQ3pCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDs7QUFFQSw2QkFBNkIsbUJBQW1COztBQUVoRDs7QUFFQTs7QUFFQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cblxudmFyIHN0eWxlc0luRG9tID0ge307XG5cbnZhclx0bWVtb2l6ZSA9IGZ1bmN0aW9uIChmbikge1xuXHR2YXIgbWVtbztcblxuXHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0eXBlb2YgbWVtbyA9PT0gXCJ1bmRlZmluZWRcIikgbWVtbyA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIG1lbW87XG5cdH07XG59O1xuXG52YXIgaXNPbGRJRSA9IG1lbW9pemUoZnVuY3Rpb24gKCkge1xuXHQvLyBUZXN0IGZvciBJRSA8PSA5IGFzIHByb3Bvc2VkIGJ5IEJyb3dzZXJoYWNrc1xuXHQvLyBAc2VlIGh0dHA6Ly9icm93c2VyaGFja3MuY29tLyNoYWNrLWU3MWQ4NjkyZjY1MzM0MTczZmVlNzE1YzIyMmNiODA1XG5cdC8vIFRlc3RzIGZvciBleGlzdGVuY2Ugb2Ygc3RhbmRhcmQgZ2xvYmFscyBpcyB0byBhbGxvdyBzdHlsZS1sb2FkZXJcblx0Ly8gdG8gb3BlcmF0ZSBjb3JyZWN0bHkgaW50byBub24tc3RhbmRhcmQgZW52aXJvbm1lbnRzXG5cdC8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi9zdHlsZS1sb2FkZXIvaXNzdWVzLzE3N1xuXHRyZXR1cm4gd2luZG93ICYmIGRvY3VtZW50ICYmIGRvY3VtZW50LmFsbCAmJiAhd2luZG93LmF0b2I7XG59KTtcblxudmFyIGdldFRhcmdldCA9IGZ1bmN0aW9uICh0YXJnZXQsIHBhcmVudCkge1xuICBpZiAocGFyZW50KXtcbiAgICByZXR1cm4gcGFyZW50LnF1ZXJ5U2VsZWN0b3IodGFyZ2V0KTtcbiAgfVxuICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpO1xufTtcblxudmFyIGdldEVsZW1lbnQgPSAoZnVuY3Rpb24gKGZuKSB7XG5cdHZhciBtZW1vID0ge307XG5cblx0cmV0dXJuIGZ1bmN0aW9uKHRhcmdldCwgcGFyZW50KSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgcGFzc2luZyBmdW5jdGlvbiBpbiBvcHRpb25zLCB0aGVuIHVzZSBpdCBmb3IgcmVzb2x2ZSBcImhlYWRcIiBlbGVtZW50LlxuICAgICAgICAgICAgICAgIC8vIFVzZWZ1bCBmb3IgU2hhZG93IFJvb3Qgc3R5bGUgaS5lXG4gICAgICAgICAgICAgICAgLy8ge1xuICAgICAgICAgICAgICAgIC8vICAgaW5zZXJ0SW50bzogZnVuY3Rpb24gKCkgeyByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNmb29cIikuc2hhZG93Um9vdCB9XG4gICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbWVtb1t0YXJnZXRdID09PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0XHR2YXIgc3R5bGVUYXJnZXQgPSBnZXRUYXJnZXQuY2FsbCh0aGlzLCB0YXJnZXQsIHBhcmVudCk7XG5cdFx0XHQvLyBTcGVjaWFsIGNhc2UgdG8gcmV0dXJuIGhlYWQgb2YgaWZyYW1lIGluc3RlYWQgb2YgaWZyYW1lIGl0c2VsZlxuXHRcdFx0aWYgKHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCAmJiBzdHlsZVRhcmdldCBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCkge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdC8vIFRoaXMgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24gaWYgYWNjZXNzIHRvIGlmcmFtZSBpcyBibG9ja2VkXG5cdFx0XHRcdFx0Ly8gZHVlIHRvIGNyb3NzLW9yaWdpbiByZXN0cmljdGlvbnNcblx0XHRcdFx0XHRzdHlsZVRhcmdldCA9IHN0eWxlVGFyZ2V0LmNvbnRlbnREb2N1bWVudC5oZWFkO1xuXHRcdFx0XHR9IGNhdGNoKGUpIHtcblx0XHRcdFx0XHRzdHlsZVRhcmdldCA9IG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdG1lbW9bdGFyZ2V0XSA9IHN0eWxlVGFyZ2V0O1xuXHRcdH1cblx0XHRyZXR1cm4gbWVtb1t0YXJnZXRdXG5cdH07XG59KSgpO1xuXG52YXIgc2luZ2xldG9uID0gbnVsbDtcbnZhclx0c2luZ2xldG9uQ291bnRlciA9IDA7XG52YXJcdHN0eWxlc0luc2VydGVkQXRUb3AgPSBbXTtcblxudmFyXHRmaXhVcmxzID0gcmVxdWlyZShcIi4vdXJsc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihsaXN0LCBvcHRpb25zKSB7XG5cdGlmICh0eXBlb2YgREVCVUcgIT09IFwidW5kZWZpbmVkXCIgJiYgREVCVUcpIHtcblx0XHRpZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcIm9iamVjdFwiKSB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc3R5bGUtbG9hZGVyIGNhbm5vdCBiZSB1c2VkIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRcIik7XG5cdH1cblxuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRvcHRpb25zLmF0dHJzID0gdHlwZW9mIG9wdGlvbnMuYXR0cnMgPT09IFwib2JqZWN0XCIgPyBvcHRpb25zLmF0dHJzIDoge307XG5cblx0Ly8gRm9yY2Ugc2luZ2xlLXRhZyBzb2x1dGlvbiBvbiBJRTYtOSwgd2hpY2ggaGFzIGEgaGFyZCBsaW1pdCBvbiB0aGUgIyBvZiA8c3R5bGU+XG5cdC8vIHRhZ3MgaXQgd2lsbCBhbGxvdyBvbiBhIHBhZ2Vcblx0aWYgKCFvcHRpb25zLnNpbmdsZXRvbiAmJiB0eXBlb2Ygb3B0aW9ucy5zaW5nbGV0b24gIT09IFwiYm9vbGVhblwiKSBvcHRpb25zLnNpbmdsZXRvbiA9IGlzT2xkSUUoKTtcblxuXHQvLyBCeSBkZWZhdWx0LCBhZGQgPHN0eWxlPiB0YWdzIHRvIHRoZSA8aGVhZD4gZWxlbWVudFxuICAgICAgICBpZiAoIW9wdGlvbnMuaW5zZXJ0SW50bykgb3B0aW9ucy5pbnNlcnRJbnRvID0gXCJoZWFkXCI7XG5cblx0Ly8gQnkgZGVmYXVsdCwgYWRkIDxzdHlsZT4gdGFncyB0byB0aGUgYm90dG9tIG9mIHRoZSB0YXJnZXRcblx0aWYgKCFvcHRpb25zLmluc2VydEF0KSBvcHRpb25zLmluc2VydEF0ID0gXCJib3R0b21cIjtcblxuXHR2YXIgc3R5bGVzID0gbGlzdFRvU3R5bGVzKGxpc3QsIG9wdGlvbnMpO1xuXG5cdGFkZFN0eWxlc1RvRG9tKHN0eWxlcywgb3B0aW9ucyk7XG5cblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZSAobmV3TGlzdCkge1xuXHRcdHZhciBtYXlSZW1vdmUgPSBbXTtcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IHN0eWxlc1tpXTtcblx0XHRcdHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xuXG5cdFx0XHRkb21TdHlsZS5yZWZzLS07XG5cdFx0XHRtYXlSZW1vdmUucHVzaChkb21TdHlsZSk7XG5cdFx0fVxuXG5cdFx0aWYobmV3TGlzdCkge1xuXHRcdFx0dmFyIG5ld1N0eWxlcyA9IGxpc3RUb1N0eWxlcyhuZXdMaXN0LCBvcHRpb25zKTtcblx0XHRcdGFkZFN0eWxlc1RvRG9tKG5ld1N0eWxlcywgb3B0aW9ucyk7XG5cdFx0fVxuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBtYXlSZW1vdmUubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBkb21TdHlsZSA9IG1heVJlbW92ZVtpXTtcblxuXHRcdFx0aWYoZG9tU3R5bGUucmVmcyA9PT0gMCkge1xuXHRcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSBkb21TdHlsZS5wYXJ0c1tqXSgpO1xuXG5cdFx0XHRcdGRlbGV0ZSBzdHlsZXNJbkRvbVtkb21TdHlsZS5pZF07XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufTtcblxuZnVuY3Rpb24gYWRkU3R5bGVzVG9Eb20gKHN0eWxlcywgb3B0aW9ucykge1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xuXHRcdHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xuXG5cdFx0aWYoZG9tU3R5bGUpIHtcblx0XHRcdGRvbVN0eWxlLnJlZnMrKztcblxuXHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGRvbVN0eWxlLnBhcnRzW2pdKGl0ZW0ucGFydHNbal0pO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IoOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRkb21TdHlsZS5wYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIHBhcnRzID0gW107XG5cblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdHBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xuXHRcdFx0fVxuXG5cdFx0XHRzdHlsZXNJbkRvbVtpdGVtLmlkXSA9IHtpZDogaXRlbS5pZCwgcmVmczogMSwgcGFydHM6IHBhcnRzfTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gbGlzdFRvU3R5bGVzIChsaXN0LCBvcHRpb25zKSB7XG5cdHZhciBzdHlsZXMgPSBbXTtcblx0dmFyIG5ld1N0eWxlcyA9IHt9O1xuXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBpdGVtID0gbGlzdFtpXTtcblx0XHR2YXIgaWQgPSBvcHRpb25zLmJhc2UgPyBpdGVtWzBdICsgb3B0aW9ucy5iYXNlIDogaXRlbVswXTtcblx0XHR2YXIgY3NzID0gaXRlbVsxXTtcblx0XHR2YXIgbWVkaWEgPSBpdGVtWzJdO1xuXHRcdHZhciBzb3VyY2VNYXAgPSBpdGVtWzNdO1xuXHRcdHZhciBwYXJ0ID0ge2NzczogY3NzLCBtZWRpYTogbWVkaWEsIHNvdXJjZU1hcDogc291cmNlTWFwfTtcblxuXHRcdGlmKCFuZXdTdHlsZXNbaWRdKSBzdHlsZXMucHVzaChuZXdTdHlsZXNbaWRdID0ge2lkOiBpZCwgcGFydHM6IFtwYXJ0XX0pO1xuXHRcdGVsc2UgbmV3U3R5bGVzW2lkXS5wYXJ0cy5wdXNoKHBhcnQpO1xuXHR9XG5cblx0cmV0dXJuIHN0eWxlcztcbn1cblxuZnVuY3Rpb24gaW5zZXJ0U3R5bGVFbGVtZW50IChvcHRpb25zLCBzdHlsZSkge1xuXHR2YXIgdGFyZ2V0ID0gZ2V0RWxlbWVudChvcHRpb25zLmluc2VydEludG8pXG5cblx0aWYgKCF0YXJnZXQpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBmaW5kIGEgc3R5bGUgdGFyZ2V0LiBUaGlzIHByb2JhYmx5IG1lYW5zIHRoYXQgdGhlIHZhbHVlIGZvciB0aGUgJ2luc2VydEludG8nIHBhcmFtZXRlciBpcyBpbnZhbGlkLlwiKTtcblx0fVxuXG5cdHZhciBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCA9IHN0eWxlc0luc2VydGVkQXRUb3Bbc3R5bGVzSW5zZXJ0ZWRBdFRvcC5sZW5ndGggLSAxXTtcblxuXHRpZiAob3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJ0b3BcIikge1xuXHRcdGlmICghbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3ApIHtcblx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoc3R5bGUsIHRhcmdldC5maXJzdENoaWxkKTtcblx0XHR9IGVsc2UgaWYgKGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wLm5leHRTaWJsaW5nKSB7XG5cdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlLCBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRhcmdldC5hcHBlbmRDaGlsZChzdHlsZSk7XG5cdFx0fVxuXHRcdHN0eWxlc0luc2VydGVkQXRUb3AucHVzaChzdHlsZSk7XG5cdH0gZWxzZSBpZiAob3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJib3R0b21cIikge1xuXHRcdHRhcmdldC5hcHBlbmRDaGlsZChzdHlsZSk7XG5cdH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwib2JqZWN0XCIgJiYgb3B0aW9ucy5pbnNlcnRBdC5iZWZvcmUpIHtcblx0XHR2YXIgbmV4dFNpYmxpbmcgPSBnZXRFbGVtZW50KG9wdGlvbnMuaW5zZXJ0QXQuYmVmb3JlLCB0YXJnZXQpO1xuXHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoc3R5bGUsIG5leHRTaWJsaW5nKTtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJbU3R5bGUgTG9hZGVyXVxcblxcbiBJbnZhbGlkIHZhbHVlIGZvciBwYXJhbWV0ZXIgJ2luc2VydEF0JyAoJ29wdGlvbnMuaW5zZXJ0QXQnKSBmb3VuZC5cXG4gTXVzdCBiZSAndG9wJywgJ2JvdHRvbScsIG9yIE9iamVjdC5cXG4gKGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrLWNvbnRyaWIvc3R5bGUtbG9hZGVyI2luc2VydGF0KVxcblwiKTtcblx0fVxufVxuXG5mdW5jdGlvbiByZW1vdmVTdHlsZUVsZW1lbnQgKHN0eWxlKSB7XG5cdGlmIChzdHlsZS5wYXJlbnROb2RlID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cdHN0eWxlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGUpO1xuXG5cdHZhciBpZHggPSBzdHlsZXNJbnNlcnRlZEF0VG9wLmluZGV4T2Yoc3R5bGUpO1xuXHRpZihpZHggPj0gMCkge1xuXHRcdHN0eWxlc0luc2VydGVkQXRUb3Auc3BsaWNlKGlkeCwgMSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlU3R5bGVFbGVtZW50IChvcHRpb25zKSB7XG5cdHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcblxuXHRpZihvcHRpb25zLmF0dHJzLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuXHRcdG9wdGlvbnMuYXR0cnMudHlwZSA9IFwidGV4dC9jc3NcIjtcblx0fVxuXG5cdGlmKG9wdGlvbnMuYXR0cnMubm9uY2UgPT09IHVuZGVmaW5lZCkge1xuXHRcdHZhciBub25jZSA9IGdldE5vbmNlKCk7XG5cdFx0aWYgKG5vbmNlKSB7XG5cdFx0XHRvcHRpb25zLmF0dHJzLm5vbmNlID0gbm9uY2U7XG5cdFx0fVxuXHR9XG5cblx0YWRkQXR0cnMoc3R5bGUsIG9wdGlvbnMuYXR0cnMpO1xuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgc3R5bGUpO1xuXG5cdHJldHVybiBzdHlsZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTGlua0VsZW1lbnQgKG9wdGlvbnMpIHtcblx0dmFyIGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiKTtcblxuXHRpZihvcHRpb25zLmF0dHJzLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuXHRcdG9wdGlvbnMuYXR0cnMudHlwZSA9IFwidGV4dC9jc3NcIjtcblx0fVxuXHRvcHRpb25zLmF0dHJzLnJlbCA9IFwic3R5bGVzaGVldFwiO1xuXG5cdGFkZEF0dHJzKGxpbmssIG9wdGlvbnMuYXR0cnMpO1xuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgbGluayk7XG5cblx0cmV0dXJuIGxpbms7XG59XG5cbmZ1bmN0aW9uIGFkZEF0dHJzIChlbCwgYXR0cnMpIHtcblx0T2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHRcdGVsLnNldEF0dHJpYnV0ZShrZXksIGF0dHJzW2tleV0pO1xuXHR9KTtcbn1cblxuZnVuY3Rpb24gZ2V0Tm9uY2UoKSB7XG5cdGlmICh0eXBlb2YgX193ZWJwYWNrX25vbmNlX18gPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHRyZXR1cm4gX193ZWJwYWNrX25vbmNlX187XG59XG5cbmZ1bmN0aW9uIGFkZFN0eWxlIChvYmosIG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlLCB1cGRhdGUsIHJlbW92ZSwgcmVzdWx0O1xuXG5cdC8vIElmIGEgdHJhbnNmb3JtIGZ1bmN0aW9uIHdhcyBkZWZpbmVkLCBydW4gaXQgb24gdGhlIGNzc1xuXHRpZiAob3B0aW9ucy50cmFuc2Zvcm0gJiYgb2JqLmNzcykge1xuXHQgICAgcmVzdWx0ID0gdHlwZW9mIG9wdGlvbnMudHJhbnNmb3JtID09PSAnZnVuY3Rpb24nXG5cdFx0ID8gb3B0aW9ucy50cmFuc2Zvcm0ob2JqLmNzcykgXG5cdFx0IDogb3B0aW9ucy50cmFuc2Zvcm0uZGVmYXVsdChvYmouY3NzKTtcblxuXHQgICAgaWYgKHJlc3VsdCkge1xuXHQgICAgXHQvLyBJZiB0cmFuc2Zvcm0gcmV0dXJucyBhIHZhbHVlLCB1c2UgdGhhdCBpbnN0ZWFkIG9mIHRoZSBvcmlnaW5hbCBjc3MuXG5cdCAgICBcdC8vIFRoaXMgYWxsb3dzIHJ1bm5pbmcgcnVudGltZSB0cmFuc2Zvcm1hdGlvbnMgb24gdGhlIGNzcy5cblx0ICAgIFx0b2JqLmNzcyA9IHJlc3VsdDtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICBcdC8vIElmIHRoZSB0cmFuc2Zvcm0gZnVuY3Rpb24gcmV0dXJucyBhIGZhbHN5IHZhbHVlLCBkb24ndCBhZGQgdGhpcyBjc3MuXG5cdCAgICBcdC8vIFRoaXMgYWxsb3dzIGNvbmRpdGlvbmFsIGxvYWRpbmcgb2YgY3NzXG5cdCAgICBcdHJldHVybiBmdW5jdGlvbigpIHtcblx0ICAgIFx0XHQvLyBub29wXG5cdCAgICBcdH07XG5cdCAgICB9XG5cdH1cblxuXHRpZiAob3B0aW9ucy5zaW5nbGV0b24pIHtcblx0XHR2YXIgc3R5bGVJbmRleCA9IHNpbmdsZXRvbkNvdW50ZXIrKztcblxuXHRcdHN0eWxlID0gc2luZ2xldG9uIHx8IChzaW5nbGV0b24gPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucykpO1xuXG5cdFx0dXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCBmYWxzZSk7XG5cdFx0cmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCB0cnVlKTtcblxuXHR9IGVsc2UgaWYgKFxuXHRcdG9iai5zb3VyY2VNYXAgJiZcblx0XHR0eXBlb2YgVVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgVVJMLmNyZWF0ZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIFVSTC5yZXZva2VPYmplY3RVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBCbG9iID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgYnRvYSA9PT0gXCJmdW5jdGlvblwiXG5cdCkge1xuXHRcdHN0eWxlID0gY3JlYXRlTGlua0VsZW1lbnQob3B0aW9ucyk7XG5cdFx0dXBkYXRlID0gdXBkYXRlTGluay5iaW5kKG51bGwsIHN0eWxlLCBvcHRpb25zKTtcblx0XHRyZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuXG5cdFx0XHRpZihzdHlsZS5ocmVmKSBVUkwucmV2b2tlT2JqZWN0VVJMKHN0eWxlLmhyZWYpO1xuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0c3R5bGUgPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucyk7XG5cdFx0dXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlKTtcblx0XHRyZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuXHRcdH07XG5cdH1cblxuXHR1cGRhdGUob2JqKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlU3R5bGUgKG5ld09iaikge1xuXHRcdGlmIChuZXdPYmopIHtcblx0XHRcdGlmIChcblx0XHRcdFx0bmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJlxuXHRcdFx0XHRuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJlxuXHRcdFx0XHRuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwXG5cdFx0XHQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR1cGRhdGUob2JqID0gbmV3T2JqKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmVtb3ZlKCk7XG5cdFx0fVxuXHR9O1xufVxuXG52YXIgcmVwbGFjZVRleHQgPSAoZnVuY3Rpb24gKCkge1xuXHR2YXIgdGV4dFN0b3JlID0gW107XG5cblx0cmV0dXJuIGZ1bmN0aW9uIChpbmRleCwgcmVwbGFjZW1lbnQpIHtcblx0XHR0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnQ7XG5cblx0XHRyZXR1cm4gdGV4dFN0b3JlLmZpbHRlcihCb29sZWFuKS5qb2luKCdcXG4nKTtcblx0fTtcbn0pKCk7XG5cbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcgKHN0eWxlLCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcblx0dmFyIGNzcyA9IHJlbW92ZSA/IFwiXCIgOiBvYmouY3NzO1xuXG5cdGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcyk7XG5cdH0gZWxzZSB7XG5cdFx0dmFyIGNzc05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpO1xuXHRcdHZhciBjaGlsZE5vZGVzID0gc3R5bGUuY2hpbGROb2RlcztcblxuXHRcdGlmIChjaGlsZE5vZGVzW2luZGV4XSkgc3R5bGUucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO1xuXG5cdFx0aWYgKGNoaWxkTm9kZXMubGVuZ3RoKSB7XG5cdFx0XHRzdHlsZS5pbnNlcnRCZWZvcmUoY3NzTm9kZSwgY2hpbGROb2Rlc1tpbmRleF0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzdHlsZS5hcHBlbmRDaGlsZChjc3NOb2RlKTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gYXBwbHlUb1RhZyAoc3R5bGUsIG9iaikge1xuXHR2YXIgY3NzID0gb2JqLmNzcztcblx0dmFyIG1lZGlhID0gb2JqLm1lZGlhO1xuXG5cdGlmKG1lZGlhKSB7XG5cdFx0c3R5bGUuc2V0QXR0cmlidXRlKFwibWVkaWFcIiwgbWVkaWEpXG5cdH1cblxuXHRpZihzdHlsZS5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuXHR9IGVsc2Uge1xuXHRcdHdoaWxlKHN0eWxlLmZpcnN0Q2hpbGQpIHtcblx0XHRcdHN0eWxlLnJlbW92ZUNoaWxkKHN0eWxlLmZpcnN0Q2hpbGQpO1xuXHRcdH1cblxuXHRcdHN0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUxpbmsgKGxpbmssIG9wdGlvbnMsIG9iaikge1xuXHR2YXIgY3NzID0gb2JqLmNzcztcblx0dmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XG5cblx0Lypcblx0XHRJZiBjb252ZXJ0VG9BYnNvbHV0ZVVybHMgaXNuJ3QgZGVmaW5lZCwgYnV0IHNvdXJjZW1hcHMgYXJlIGVuYWJsZWRcblx0XHRhbmQgdGhlcmUgaXMgbm8gcHVibGljUGF0aCBkZWZpbmVkIHRoZW4gbGV0cyB0dXJuIGNvbnZlcnRUb0Fic29sdXRlVXJsc1xuXHRcdG9uIGJ5IGRlZmF1bHQuICBPdGhlcndpc2UgZGVmYXVsdCB0byB0aGUgY29udmVydFRvQWJzb2x1dGVVcmxzIG9wdGlvblxuXHRcdGRpcmVjdGx5XG5cdCovXG5cdHZhciBhdXRvRml4VXJscyA9IG9wdGlvbnMuY29udmVydFRvQWJzb2x1dGVVcmxzID09PSB1bmRlZmluZWQgJiYgc291cmNlTWFwO1xuXG5cdGlmIChvcHRpb25zLmNvbnZlcnRUb0Fic29sdXRlVXJscyB8fCBhdXRvRml4VXJscykge1xuXHRcdGNzcyA9IGZpeFVybHMoY3NzKTtcblx0fVxuXG5cdGlmIChzb3VyY2VNYXApIHtcblx0XHQvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yNjYwMzg3NVxuXHRcdGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIgKyBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpICsgXCIgKi9cIjtcblx0fVxuXG5cdHZhciBibG9iID0gbmV3IEJsb2IoW2Nzc10sIHsgdHlwZTogXCJ0ZXh0L2Nzc1wiIH0pO1xuXG5cdHZhciBvbGRTcmMgPSBsaW5rLmhyZWY7XG5cblx0bGluay5ocmVmID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcblxuXHRpZihvbGRTcmMpIFVSTC5yZXZva2VPYmplY3RVUkwob2xkU3JjKTtcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/style-loader/lib/addStyles.js\n");

/***/ }),

/***/ "./node_modules/style-loader/lib/urls.js":
/*!***********************************************!*\
  !*** ./node_modules/style-loader/lib/urls.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\n/**\n * When source maps are enabled, `style-loader` uses a link element with a data-uri to\n * embed the css on the page. This breaks all relative urls because now they are relative to a\n * bundle instead of the current page.\n *\n * One solution is to only use full urls, but that may be impossible.\n *\n * Instead, this function \"fixes\" the relative urls to be absolute according to the current page location.\n *\n * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.\n *\n */\n\nmodule.exports = function (css) {\n  // get current location\n  var location = typeof window !== \"undefined\" && window.location;\n\n  if (!location) {\n    throw new Error(\"fixUrls requires window.location\");\n  }\n\n\t// blank or null?\n\tif (!css || typeof css !== \"string\") {\n\t  return css;\n  }\n\n  var baseUrl = location.protocol + \"//\" + location.host;\n  var currentDir = baseUrl + location.pathname.replace(/\\/[^\\/]*$/, \"/\");\n\n\t// convert each url(...)\n\t/*\n\tThis regular expression is just a way to recursively match brackets within\n\ta string.\n\n\t /url\\s*\\(  = Match on the word \"url\" with any whitespace after it and then a parens\n\t   (  = Start a capturing group\n\t     (?:  = Start a non-capturing group\n\t         [^)(]  = Match anything that isn't a parentheses\n\t         |  = OR\n\t         \\(  = Match a start parentheses\n\t             (?:  = Start another non-capturing groups\n\t                 [^)(]+  = Match anything that isn't a parentheses\n\t                 |  = OR\n\t                 \\(  = Match a start parentheses\n\t                     [^)(]*  = Match anything that isn't a parentheses\n\t                 \\)  = Match a end parentheses\n\t             )  = End Group\n              *\\) = Match anything and then a close parens\n          )  = Close non-capturing group\n          *  = Match anything\n       )  = Close capturing group\n\t \\)  = Match a close parens\n\n\t /gi  = Get all matches, not the first.  Be case insensitive.\n\t */\n\tvar fixedCss = css.replace(/url\\s*\\(((?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)\\)/gi, function(fullMatch, origUrl) {\n\t\t// strip quotes (if they exist)\n\t\tvar unquotedOrigUrl = origUrl\n\t\t\t.trim()\n\t\t\t.replace(/^\"(.*)\"$/, function(o, $1){ return $1; })\n\t\t\t.replace(/^'(.*)'$/, function(o, $1){ return $1; });\n\n\t\t// already a full url? no change\n\t\tif (/^(#|data:|http:\\/\\/|https:\\/\\/|file:\\/\\/\\/|\\s*$)/i.test(unquotedOrigUrl)) {\n\t\t  return fullMatch;\n\t\t}\n\n\t\t// convert the url to a full url\n\t\tvar newUrl;\n\n\t\tif (unquotedOrigUrl.indexOf(\"//\") === 0) {\n\t\t  \t//TODO: should we add protocol?\n\t\t\tnewUrl = unquotedOrigUrl;\n\t\t} else if (unquotedOrigUrl.indexOf(\"/\") === 0) {\n\t\t\t// path should be relative to the base url\n\t\t\tnewUrl = baseUrl + unquotedOrigUrl; // already starts with '/'\n\t\t} else {\n\t\t\t// path should be relative to current directory\n\t\t\tnewUrl = currentDir + unquotedOrigUrl.replace(/^\\.\\//, \"\"); // Strip leading './'\n\t\t}\n\n\t\t// send back the fixed url(...)\n\t\treturn \"url(\" + JSON.stringify(newUrl) + \")\";\n\t});\n\n\t// send back the fixed css\n\treturn fixedCss;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi91cmxzLmpzP2Y2ZDMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxXQUFXLEVBQUU7QUFDckQsd0NBQXdDLFdBQVcsRUFBRTs7QUFFckQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxzQ0FBc0M7QUFDdEMsR0FBRztBQUNIO0FBQ0EsOERBQThEO0FBQzlEOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL3VybHMuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qKlxuICogV2hlbiBzb3VyY2UgbWFwcyBhcmUgZW5hYmxlZCwgYHN0eWxlLWxvYWRlcmAgdXNlcyBhIGxpbmsgZWxlbWVudCB3aXRoIGEgZGF0YS11cmkgdG9cbiAqIGVtYmVkIHRoZSBjc3Mgb24gdGhlIHBhZ2UuIFRoaXMgYnJlYWtzIGFsbCByZWxhdGl2ZSB1cmxzIGJlY2F1c2Ugbm93IHRoZXkgYXJlIHJlbGF0aXZlIHRvIGFcbiAqIGJ1bmRsZSBpbnN0ZWFkIG9mIHRoZSBjdXJyZW50IHBhZ2UuXG4gKlxuICogT25lIHNvbHV0aW9uIGlzIHRvIG9ubHkgdXNlIGZ1bGwgdXJscywgYnV0IHRoYXQgbWF5IGJlIGltcG9zc2libGUuXG4gKlxuICogSW5zdGVhZCwgdGhpcyBmdW5jdGlvbiBcImZpeGVzXCIgdGhlIHJlbGF0aXZlIHVybHMgdG8gYmUgYWJzb2x1dGUgYWNjb3JkaW5nIHRvIHRoZSBjdXJyZW50IHBhZ2UgbG9jYXRpb24uXG4gKlxuICogQSBydWRpbWVudGFyeSB0ZXN0IHN1aXRlIGlzIGxvY2F0ZWQgYXQgYHRlc3QvZml4VXJscy5qc2AgYW5kIGNhbiBiZSBydW4gdmlhIHRoZSBgbnBtIHRlc3RgIGNvbW1hbmQuXG4gKlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNzcykge1xuICAvLyBnZXQgY3VycmVudCBsb2NhdGlvblxuICB2YXIgbG9jYXRpb24gPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5sb2NhdGlvbjtcblxuICBpZiAoIWxvY2F0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZml4VXJscyByZXF1aXJlcyB3aW5kb3cubG9jYXRpb25cIik7XG4gIH1cblxuXHQvLyBibGFuayBvciBudWxsP1xuXHRpZiAoIWNzcyB8fCB0eXBlb2YgY3NzICE9PSBcInN0cmluZ1wiKSB7XG5cdCAgcmV0dXJuIGNzcztcbiAgfVxuXG4gIHZhciBiYXNlVXJsID0gbG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKyBsb2NhdGlvbi5ob3N0O1xuICB2YXIgY3VycmVudERpciA9IGJhc2VVcmwgKyBsb2NhdGlvbi5wYXRobmFtZS5yZXBsYWNlKC9cXC9bXlxcL10qJC8sIFwiL1wiKTtcblxuXHQvLyBjb252ZXJ0IGVhY2ggdXJsKC4uLilcblx0Lypcblx0VGhpcyByZWd1bGFyIGV4cHJlc3Npb24gaXMganVzdCBhIHdheSB0byByZWN1cnNpdmVseSBtYXRjaCBicmFja2V0cyB3aXRoaW5cblx0YSBzdHJpbmcuXG5cblx0IC91cmxcXHMqXFwoICA9IE1hdGNoIG9uIHRoZSB3b3JkIFwidXJsXCIgd2l0aCBhbnkgd2hpdGVzcGFjZSBhZnRlciBpdCBhbmQgdGhlbiBhIHBhcmVuc1xuXHQgICAoICA9IFN0YXJ0IGEgY2FwdHVyaW5nIGdyb3VwXG5cdCAgICAgKD86ICA9IFN0YXJ0IGEgbm9uLWNhcHR1cmluZyBncm91cFxuXHQgICAgICAgICBbXikoXSAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgfCAgPSBPUlxuXHQgICAgICAgICBcXCggID0gTWF0Y2ggYSBzdGFydCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgKD86ICA9IFN0YXJ0IGFub3RoZXIgbm9uLWNhcHR1cmluZyBncm91cHNcblx0ICAgICAgICAgICAgICAgICBbXikoXSsgID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgfCAgPSBPUlxuXHQgICAgICAgICAgICAgICAgIFxcKCAgPSBNYXRjaCBhIHN0YXJ0IHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgICAgIFteKShdKiAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICAgICBcXCkgID0gTWF0Y2ggYSBlbmQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICkgID0gRW5kIEdyb3VwXG4gICAgICAgICAgICAgICpcXCkgPSBNYXRjaCBhbnl0aGluZyBhbmQgdGhlbiBhIGNsb3NlIHBhcmVuc1xuICAgICAgICAgICkgID0gQ2xvc2Ugbm9uLWNhcHR1cmluZyBncm91cFxuICAgICAgICAgICogID0gTWF0Y2ggYW55dGhpbmdcbiAgICAgICApICA9IENsb3NlIGNhcHR1cmluZyBncm91cFxuXHQgXFwpICA9IE1hdGNoIGEgY2xvc2UgcGFyZW5zXG5cblx0IC9naSAgPSBHZXQgYWxsIG1hdGNoZXMsIG5vdCB0aGUgZmlyc3QuICBCZSBjYXNlIGluc2Vuc2l0aXZlLlxuXHQgKi9cblx0dmFyIGZpeGVkQ3NzID0gY3NzLnJlcGxhY2UoL3VybFxccypcXCgoKD86W14pKF18XFwoKD86W14pKF0rfFxcKFteKShdKlxcKSkqXFwpKSopXFwpL2dpLCBmdW5jdGlvbihmdWxsTWF0Y2gsIG9yaWdVcmwpIHtcblx0XHQvLyBzdHJpcCBxdW90ZXMgKGlmIHRoZXkgZXhpc3QpXG5cdFx0dmFyIHVucXVvdGVkT3JpZ1VybCA9IG9yaWdVcmxcblx0XHRcdC50cmltKClcblx0XHRcdC5yZXBsYWNlKC9eXCIoLiopXCIkLywgZnVuY3Rpb24obywgJDEpeyByZXR1cm4gJDE7IH0pXG5cdFx0XHQucmVwbGFjZSgvXicoLiopJyQvLCBmdW5jdGlvbihvLCAkMSl7IHJldHVybiAkMTsgfSk7XG5cblx0XHQvLyBhbHJlYWR5IGEgZnVsbCB1cmw/IG5vIGNoYW5nZVxuXHRcdGlmICgvXigjfGRhdGE6fGh0dHA6XFwvXFwvfGh0dHBzOlxcL1xcL3xmaWxlOlxcL1xcL1xcL3xcXHMqJCkvaS50ZXN0KHVucXVvdGVkT3JpZ1VybCkpIHtcblx0XHQgIHJldHVybiBmdWxsTWF0Y2g7XG5cdFx0fVxuXG5cdFx0Ly8gY29udmVydCB0aGUgdXJsIHRvIGEgZnVsbCB1cmxcblx0XHR2YXIgbmV3VXJsO1xuXG5cdFx0aWYgKHVucXVvdGVkT3JpZ1VybC5pbmRleE9mKFwiLy9cIikgPT09IDApIHtcblx0XHQgIFx0Ly9UT0RPOiBzaG91bGQgd2UgYWRkIHByb3RvY29sP1xuXHRcdFx0bmV3VXJsID0gdW5xdW90ZWRPcmlnVXJsO1xuXHRcdH0gZWxzZSBpZiAodW5xdW90ZWRPcmlnVXJsLmluZGV4T2YoXCIvXCIpID09PSAwKSB7XG5cdFx0XHQvLyBwYXRoIHNob3VsZCBiZSByZWxhdGl2ZSB0byB0aGUgYmFzZSB1cmxcblx0XHRcdG5ld1VybCA9IGJhc2VVcmwgKyB1bnF1b3RlZE9yaWdVcmw7IC8vIGFscmVhZHkgc3RhcnRzIHdpdGggJy8nXG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIHBhdGggc2hvdWxkIGJlIHJlbGF0aXZlIHRvIGN1cnJlbnQgZGlyZWN0b3J5XG5cdFx0XHRuZXdVcmwgPSBjdXJyZW50RGlyICsgdW5xdW90ZWRPcmlnVXJsLnJlcGxhY2UoL15cXC5cXC8vLCBcIlwiKTsgLy8gU3RyaXAgbGVhZGluZyAnLi8nXG5cdFx0fVxuXG5cdFx0Ly8gc2VuZCBiYWNrIHRoZSBmaXhlZCB1cmwoLi4uKVxuXHRcdHJldHVybiBcInVybChcIiArIEpTT04uc3RyaW5naWZ5KG5ld1VybCkgKyBcIilcIjtcblx0fSk7XG5cblx0Ly8gc2VuZCBiYWNrIHRoZSBmaXhlZCBjc3Ncblx0cmV0dXJuIGZpeGVkQ3NzO1xufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/style-loader/lib/urls.js\n");

/***/ }),

/***/ "./node_modules/sweetalert2/dist/sweetalert2.all.js":
/*!**********************************************************!*\
  !*** ./node_modules/sweetalert2/dist/sweetalert2.all.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\n* sweetalert2 v9.17.2\n* Released under the MIT License.\n*/\n(function (global, factory) {\n   true ? module.exports = factory() :\n  undefined;\n}(this, function () { 'use strict';\n\n  function _typeof(obj) {\n    \"@babel/helpers - typeof\";\n\n    if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n      _typeof = function (obj) {\n        return typeof obj;\n      };\n    } else {\n      _typeof = function (obj) {\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n      };\n    }\n\n    return _typeof(obj);\n  }\n\n  function _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  }\n\n  function _defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  function _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n  }\n\n  function _extends() {\n    _extends = Object.assign || function (target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i];\n\n        for (var key in source) {\n          if (Object.prototype.hasOwnProperty.call(source, key)) {\n            target[key] = source[key];\n          }\n        }\n      }\n\n      return target;\n    };\n\n    return _extends.apply(this, arguments);\n  }\n\n  function _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n      constructor: {\n        value: subClass,\n        writable: true,\n        configurable: true\n      }\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n  }\n\n  function _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n      return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n  }\n\n  function _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n      o.__proto__ = p;\n      return o;\n    };\n\n    return _setPrototypeOf(o, p);\n  }\n\n  function _isNativeReflectConstruct() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n\n    try {\n      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  function _construct(Parent, args, Class) {\n    if (_isNativeReflectConstruct()) {\n      _construct = Reflect.construct;\n    } else {\n      _construct = function _construct(Parent, args, Class) {\n        var a = [null];\n        a.push.apply(a, args);\n        var Constructor = Function.bind.apply(Parent, a);\n        var instance = new Constructor();\n        if (Class) _setPrototypeOf(instance, Class.prototype);\n        return instance;\n      };\n    }\n\n    return _construct.apply(null, arguments);\n  }\n\n  function _assertThisInitialized(self) {\n    if (self === void 0) {\n      throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n\n    return self;\n  }\n\n  function _possibleConstructorReturn(self, call) {\n    if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n      return call;\n    }\n\n    return _assertThisInitialized(self);\n  }\n\n  function _createSuper(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n    return function _createSuperInternal() {\n      var Super = _getPrototypeOf(Derived),\n          result;\n\n      if (hasNativeReflectConstruct) {\n        var NewTarget = _getPrototypeOf(this).constructor;\n\n        result = Reflect.construct(Super, arguments, NewTarget);\n      } else {\n        result = Super.apply(this, arguments);\n      }\n\n      return _possibleConstructorReturn(this, result);\n    };\n  }\n\n  function _superPropBase(object, property) {\n    while (!Object.prototype.hasOwnProperty.call(object, property)) {\n      object = _getPrototypeOf(object);\n      if (object === null) break;\n    }\n\n    return object;\n  }\n\n  function _get(target, property, receiver) {\n    if (typeof Reflect !== \"undefined\" && Reflect.get) {\n      _get = Reflect.get;\n    } else {\n      _get = function _get(target, property, receiver) {\n        var base = _superPropBase(target, property);\n\n        if (!base) return;\n        var desc = Object.getOwnPropertyDescriptor(base, property);\n\n        if (desc.get) {\n          return desc.get.call(receiver);\n        }\n\n        return desc.value;\n      };\n    }\n\n    return _get(target, property, receiver || target);\n  }\n\n  var consolePrefix = 'SweetAlert2:';\n  /**\n   * Filter the unique values into a new array\n   * @param arr\n   */\n\n  var uniqueArray = function uniqueArray(arr) {\n    var result = [];\n\n    for (var i = 0; i < arr.length; i++) {\n      if (result.indexOf(arr[i]) === -1) {\n        result.push(arr[i]);\n      }\n    }\n\n    return result;\n  };\n  /**\n   * Capitalize the first letter of a string\n   * @param str\n   */\n\n  var capitalizeFirstLetter = function capitalizeFirstLetter(str) {\n    return str.charAt(0).toUpperCase() + str.slice(1);\n  };\n  /**\n   * Returns the array of object values (Object.values isn't supported in IE11)\n   * @param obj\n   */\n\n  var objectValues = function objectValues(obj) {\n    return Object.keys(obj).map(function (key) {\n      return obj[key];\n    });\n  };\n  /**\n   * Convert NodeList to Array\n   * @param nodeList\n   */\n\n  var toArray = function toArray(nodeList) {\n    return Array.prototype.slice.call(nodeList);\n  };\n  /**\n   * Standardise console warnings\n   * @param message\n   */\n\n  var warn = function warn(message) {\n    console.warn(\"\".concat(consolePrefix, \" \").concat(message));\n  };\n  /**\n   * Standardise console errors\n   * @param message\n   */\n\n  var error = function error(message) {\n    console.error(\"\".concat(consolePrefix, \" \").concat(message));\n  };\n  /**\n   * Private global state for `warnOnce`\n   * @type {Array}\n   * @private\n   */\n\n  var previousWarnOnceMessages = [];\n  /**\n   * Show a console warning, but only if it hasn't already been shown\n   * @param message\n   */\n\n  var warnOnce = function warnOnce(message) {\n    if (!(previousWarnOnceMessages.indexOf(message) !== -1)) {\n      previousWarnOnceMessages.push(message);\n      warn(message);\n    }\n  };\n  /**\n   * Show a one-time console warning about deprecated params/methods\n   */\n\n  var warnAboutDepreation = function warnAboutDepreation(deprecatedParam, useInstead) {\n    warnOnce(\"\\\"\".concat(deprecatedParam, \"\\\" is deprecated and will be removed in the next major release. Please use \\\"\").concat(useInstead, \"\\\" instead.\"));\n  };\n  /**\n   * If `arg` is a function, call it (with no arguments or context) and return the result.\n   * Otherwise, just pass the value through\n   * @param arg\n   */\n\n  var callIfFunction = function callIfFunction(arg) {\n    return typeof arg === 'function' ? arg() : arg;\n  };\n  var hasToPromiseFn = function hasToPromiseFn(arg) {\n    return arg && typeof arg.toPromise === 'function';\n  };\n  var asPromise = function asPromise(arg) {\n    return hasToPromiseFn(arg) ? arg.toPromise() : Promise.resolve(arg);\n  };\n  var isPromise = function isPromise(arg) {\n    return arg && Promise.resolve(arg) === arg;\n  };\n\n  var DismissReason = Object.freeze({\n    cancel: 'cancel',\n    backdrop: 'backdrop',\n    close: 'close',\n    esc: 'esc',\n    timer: 'timer'\n  });\n\n  var isJqueryElement = function isJqueryElement(elem) {\n    return _typeof(elem) === 'object' && elem.jquery;\n  };\n\n  var isElement = function isElement(elem) {\n    return elem instanceof Element || isJqueryElement(elem);\n  };\n\n  var argsToParams = function argsToParams(args) {\n    var params = {};\n\n    if (_typeof(args[0]) === 'object' && !isElement(args[0])) {\n      _extends(params, args[0]);\n    } else {\n      ['title', 'html', 'icon'].forEach(function (name, index) {\n        var arg = args[index];\n\n        if (typeof arg === 'string' || isElement(arg)) {\n          params[name] = arg;\n        } else if (arg !== undefined) {\n          error(\"Unexpected type of \".concat(name, \"! Expected \\\"string\\\" or \\\"Element\\\", got \").concat(_typeof(arg)));\n        }\n      });\n    }\n\n    return params;\n  };\n\n  var swalPrefix = 'swal2-';\n  var prefix = function prefix(items) {\n    var result = {};\n\n    for (var i in items) {\n      result[items[i]] = swalPrefix + items[i];\n    }\n\n    return result;\n  };\n  var swalClasses = prefix(['container', 'shown', 'height-auto', 'iosfix', 'popup', 'modal', 'no-backdrop', 'no-transition', 'toast', 'toast-shown', 'toast-column', 'show', 'hide', 'close', 'title', 'header', 'content', 'html-container', 'actions', 'confirm', 'cancel', 'footer', 'icon', 'icon-content', 'image', 'input', 'file', 'range', 'select', 'radio', 'checkbox', 'label', 'textarea', 'inputerror', 'validation-message', 'progress-steps', 'active-progress-step', 'progress-step', 'progress-step-line', 'loading', 'styled', 'top', 'top-start', 'top-end', 'top-left', 'top-right', 'center', 'center-start', 'center-end', 'center-left', 'center-right', 'bottom', 'bottom-start', 'bottom-end', 'bottom-left', 'bottom-right', 'grow-row', 'grow-column', 'grow-fullscreen', 'rtl', 'timer-progress-bar', 'timer-progress-bar-container', 'scrollbar-measure', 'icon-success', 'icon-warning', 'icon-info', 'icon-question', 'icon-error']);\n  var iconTypes = prefix(['success', 'warning', 'info', 'question', 'error']);\n\n  var getContainer = function getContainer() {\n    return document.body.querySelector(\".\".concat(swalClasses.container));\n  };\n  var elementBySelector = function elementBySelector(selectorString) {\n    var container = getContainer();\n    return container ? container.querySelector(selectorString) : null;\n  };\n\n  var elementByClass = function elementByClass(className) {\n    return elementBySelector(\".\".concat(className));\n  };\n\n  var getPopup = function getPopup() {\n    return elementByClass(swalClasses.popup);\n  };\n  var getIcons = function getIcons() {\n    var popup = getPopup();\n    return toArray(popup.querySelectorAll(\".\".concat(swalClasses.icon)));\n  };\n  var getIcon = function getIcon() {\n    var visibleIcon = getIcons().filter(function (icon) {\n      return isVisible(icon);\n    });\n    return visibleIcon.length ? visibleIcon[0] : null;\n  };\n  var getTitle = function getTitle() {\n    return elementByClass(swalClasses.title);\n  };\n  var getContent = function getContent() {\n    return elementByClass(swalClasses.content);\n  };\n  var getHtmlContainer = function getHtmlContainer() {\n    return elementByClass(swalClasses['html-container']);\n  };\n  var getImage = function getImage() {\n    return elementByClass(swalClasses.image);\n  };\n  var getProgressSteps = function getProgressSteps() {\n    return elementByClass(swalClasses['progress-steps']);\n  };\n  var getValidationMessage = function getValidationMessage() {\n    return elementByClass(swalClasses['validation-message']);\n  };\n  var getConfirmButton = function getConfirmButton() {\n    return elementBySelector(\".\".concat(swalClasses.actions, \" .\").concat(swalClasses.confirm));\n  };\n  var getCancelButton = function getCancelButton() {\n    return elementBySelector(\".\".concat(swalClasses.actions, \" .\").concat(swalClasses.cancel));\n  };\n  var getActions = function getActions() {\n    return elementByClass(swalClasses.actions);\n  };\n  var getHeader = function getHeader() {\n    return elementByClass(swalClasses.header);\n  };\n  var getFooter = function getFooter() {\n    return elementByClass(swalClasses.footer);\n  };\n  var getTimerProgressBar = function getTimerProgressBar() {\n    return elementByClass(swalClasses['timer-progress-bar']);\n  };\n  var getCloseButton = function getCloseButton() {\n    return elementByClass(swalClasses.close);\n  }; // https://github.com/jkup/focusable/blob/master/index.js\n\n  var focusable = \"\\n  a[href],\\n  area[href],\\n  input:not([disabled]),\\n  select:not([disabled]),\\n  textarea:not([disabled]),\\n  button:not([disabled]),\\n  iframe,\\n  object,\\n  embed,\\n  [tabindex=\\\"0\\\"],\\n  [contenteditable],\\n  audio[controls],\\n  video[controls],\\n  summary\\n\";\n  var getFocusableElements = function getFocusableElements() {\n    var focusableElementsWithTabindex = toArray(getPopup().querySelectorAll('[tabindex]:not([tabindex=\"-1\"]):not([tabindex=\"0\"])')) // sort according to tabindex\n    .sort(function (a, b) {\n      a = parseInt(a.getAttribute('tabindex'));\n      b = parseInt(b.getAttribute('tabindex'));\n\n      if (a > b) {\n        return 1;\n      } else if (a < b) {\n        return -1;\n      }\n\n      return 0;\n    });\n    var otherFocusableElements = toArray(getPopup().querySelectorAll(focusable)).filter(function (el) {\n      return el.getAttribute('tabindex') !== '-1';\n    });\n    return uniqueArray(focusableElementsWithTabindex.concat(otherFocusableElements)).filter(function (el) {\n      return isVisible(el);\n    });\n  };\n  var isModal = function isModal() {\n    return !isToast() && !document.body.classList.contains(swalClasses['no-backdrop']);\n  };\n  var isToast = function isToast() {\n    return document.body.classList.contains(swalClasses['toast-shown']);\n  };\n  var isLoading = function isLoading() {\n    return getPopup().hasAttribute('data-loading');\n  };\n\n  var states = {\n    previousBodyPadding: null\n  };\n  var setInnerHtml = function setInnerHtml(elem, html) {\n    // #1926\n    elem.textContent = '';\n\n    if (html) {\n      var parser = new DOMParser();\n      var parsed = parser.parseFromString(html, \"text/html\");\n      toArray(parsed.querySelector('head').childNodes).forEach(function (child) {\n        elem.appendChild(child);\n      });\n      toArray(parsed.querySelector('body').childNodes).forEach(function (child) {\n        elem.appendChild(child);\n      });\n    }\n  };\n  var hasClass = function hasClass(elem, className) {\n    if (!className) {\n      return false;\n    }\n\n    var classList = className.split(/\\s+/);\n\n    for (var i = 0; i < classList.length; i++) {\n      if (!elem.classList.contains(classList[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  var removeCustomClasses = function removeCustomClasses(elem, params) {\n    toArray(elem.classList).forEach(function (className) {\n      if (!(objectValues(swalClasses).indexOf(className) !== -1) && !(objectValues(iconTypes).indexOf(className) !== -1) && !(objectValues(params.showClass).indexOf(className) !== -1)) {\n        elem.classList.remove(className);\n      }\n    });\n  };\n\n  var applyCustomClass = function applyCustomClass(elem, params, className) {\n    removeCustomClasses(elem, params);\n\n    if (params.customClass && params.customClass[className]) {\n      if (typeof params.customClass[className] !== 'string' && !params.customClass[className].forEach) {\n        return warn(\"Invalid type of customClass.\".concat(className, \"! Expected string or iterable object, got \\\"\").concat(_typeof(params.customClass[className]), \"\\\"\"));\n      }\n\n      addClass(elem, params.customClass[className]);\n    }\n  };\n  function getInput(content, inputType) {\n    if (!inputType) {\n      return null;\n    }\n\n    switch (inputType) {\n      case 'select':\n      case 'textarea':\n      case 'file':\n        return getChildByClass(content, swalClasses[inputType]);\n\n      case 'checkbox':\n        return content.querySelector(\".\".concat(swalClasses.checkbox, \" input\"));\n\n      case 'radio':\n        return content.querySelector(\".\".concat(swalClasses.radio, \" input:checked\")) || content.querySelector(\".\".concat(swalClasses.radio, \" input:first-child\"));\n\n      case 'range':\n        return content.querySelector(\".\".concat(swalClasses.range, \" input\"));\n\n      default:\n        return getChildByClass(content, swalClasses.input);\n    }\n  }\n  var focusInput = function focusInput(input) {\n    input.focus(); // place cursor at end of text in text input\n\n    if (input.type !== 'file') {\n      // http://stackoverflow.com/a/2345915\n      var val = input.value;\n      input.value = '';\n      input.value = val;\n    }\n  };\n  var toggleClass = function toggleClass(target, classList, condition) {\n    if (!target || !classList) {\n      return;\n    }\n\n    if (typeof classList === 'string') {\n      classList = classList.split(/\\s+/).filter(Boolean);\n    }\n\n    classList.forEach(function (className) {\n      if (target.forEach) {\n        target.forEach(function (elem) {\n          condition ? elem.classList.add(className) : elem.classList.remove(className);\n        });\n      } else {\n        condition ? target.classList.add(className) : target.classList.remove(className);\n      }\n    });\n  };\n  var addClass = function addClass(target, classList) {\n    toggleClass(target, classList, true);\n  };\n  var removeClass = function removeClass(target, classList) {\n    toggleClass(target, classList, false);\n  };\n  var getChildByClass = function getChildByClass(elem, className) {\n    for (var i = 0; i < elem.childNodes.length; i++) {\n      if (hasClass(elem.childNodes[i], className)) {\n        return elem.childNodes[i];\n      }\n    }\n  };\n  var applyNumericalStyle = function applyNumericalStyle(elem, property, value) {\n    if (value || parseInt(value) === 0) {\n      elem.style[property] = typeof value === 'number' ? \"\".concat(value, \"px\") : value;\n    } else {\n      elem.style.removeProperty(property);\n    }\n  };\n  var show = function show(elem) {\n    var display = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'flex';\n    elem.style.opacity = '';\n    elem.style.display = display;\n  };\n  var hide = function hide(elem) {\n    elem.style.opacity = '';\n    elem.style.display = 'none';\n  };\n  var toggle = function toggle(elem, condition, display) {\n    condition ? show(elem, display) : hide(elem);\n  }; // borrowed from jquery $(elem).is(':visible') implementation\n\n  var isVisible = function isVisible(elem) {\n    return !!(elem && (elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length));\n  };\n  /* istanbul ignore next */\n\n  var isScrollable = function isScrollable(elem) {\n    return !!(elem.scrollHeight > elem.clientHeight);\n  }; // borrowed from https://stackoverflow.com/a/46352119\n\n  var hasCssAnimation = function hasCssAnimation(elem) {\n    var style = window.getComputedStyle(elem);\n    var animDuration = parseFloat(style.getPropertyValue('animation-duration') || '0');\n    var transDuration = parseFloat(style.getPropertyValue('transition-duration') || '0');\n    return animDuration > 0 || transDuration > 0;\n  };\n  var contains = function contains(haystack, needle) {\n    if (typeof haystack.contains === 'function') {\n      return haystack.contains(needle);\n    }\n  };\n  var animateTimerProgressBar = function animateTimerProgressBar(timer) {\n    var reset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    var timerProgressBar = getTimerProgressBar();\n\n    if (isVisible(timerProgressBar)) {\n      if (reset) {\n        timerProgressBar.style.transition = 'none';\n        timerProgressBar.style.width = '100%';\n      }\n\n      setTimeout(function () {\n        timerProgressBar.style.transition = \"width \".concat(timer / 1000, \"s linear\");\n        timerProgressBar.style.width = '0%';\n      }, 10);\n    }\n  };\n  var stopTimerProgressBar = function stopTimerProgressBar() {\n    var timerProgressBar = getTimerProgressBar();\n    var timerProgressBarWidth = parseInt(window.getComputedStyle(timerProgressBar).width);\n    timerProgressBar.style.removeProperty('transition');\n    timerProgressBar.style.width = '100%';\n    var timerProgressBarFullWidth = parseInt(window.getComputedStyle(timerProgressBar).width);\n    var timerProgressBarPercent = parseInt(timerProgressBarWidth / timerProgressBarFullWidth * 100);\n    timerProgressBar.style.removeProperty('transition');\n    timerProgressBar.style.width = \"\".concat(timerProgressBarPercent, \"%\");\n  };\n\n  // Detect Node env\n  var isNodeEnv = function isNodeEnv() {\n    return typeof window === 'undefined' || typeof document === 'undefined';\n  };\n\n  var sweetHTML = \"\\n <div aria-labelledby=\\\"\".concat(swalClasses.title, \"\\\" aria-describedby=\\\"\").concat(swalClasses.content, \"\\\" class=\\\"\").concat(swalClasses.popup, \"\\\" tabindex=\\\"-1\\\">\\n   <div class=\\\"\").concat(swalClasses.header, \"\\\">\\n     <ul class=\\\"\").concat(swalClasses['progress-steps'], \"\\\"></ul>\\n     <div class=\\\"\").concat(swalClasses.icon, \" \").concat(iconTypes.error, \"\\\"></div>\\n     <div class=\\\"\").concat(swalClasses.icon, \" \").concat(iconTypes.question, \"\\\"></div>\\n     <div class=\\\"\").concat(swalClasses.icon, \" \").concat(iconTypes.warning, \"\\\"></div>\\n     <div class=\\\"\").concat(swalClasses.icon, \" \").concat(iconTypes.info, \"\\\"></div>\\n     <div class=\\\"\").concat(swalClasses.icon, \" \").concat(iconTypes.success, \"\\\"></div>\\n     <img class=\\\"\").concat(swalClasses.image, \"\\\" />\\n     <h2 class=\\\"\").concat(swalClasses.title, \"\\\" id=\\\"\").concat(swalClasses.title, \"\\\"></h2>\\n     <button type=\\\"button\\\" class=\\\"\").concat(swalClasses.close, \"\\\"></button>\\n   </div>\\n   <div class=\\\"\").concat(swalClasses.content, \"\\\">\\n     <div id=\\\"\").concat(swalClasses.content, \"\\\" class=\\\"\").concat(swalClasses['html-container'], \"\\\"></div>\\n     <input class=\\\"\").concat(swalClasses.input, \"\\\" />\\n     <input type=\\\"file\\\" class=\\\"\").concat(swalClasses.file, \"\\\" />\\n     <div class=\\\"\").concat(swalClasses.range, \"\\\">\\n       <input type=\\\"range\\\" />\\n       <output></output>\\n     </div>\\n     <select class=\\\"\").concat(swalClasses.select, \"\\\"></select>\\n     <div class=\\\"\").concat(swalClasses.radio, \"\\\"></div>\\n     <label for=\\\"\").concat(swalClasses.checkbox, \"\\\" class=\\\"\").concat(swalClasses.checkbox, \"\\\">\\n       <input type=\\\"checkbox\\\" />\\n       <span class=\\\"\").concat(swalClasses.label, \"\\\"></span>\\n     </label>\\n     <textarea class=\\\"\").concat(swalClasses.textarea, \"\\\"></textarea>\\n     <div class=\\\"\").concat(swalClasses['validation-message'], \"\\\" id=\\\"\").concat(swalClasses['validation-message'], \"\\\"></div>\\n   </div>\\n   <div class=\\\"\").concat(swalClasses.actions, \"\\\">\\n     <button type=\\\"button\\\" class=\\\"\").concat(swalClasses.confirm, \"\\\">OK</button>\\n     <button type=\\\"button\\\" class=\\\"\").concat(swalClasses.cancel, \"\\\">Cancel</button>\\n   </div>\\n   <div class=\\\"\").concat(swalClasses.footer, \"\\\"></div>\\n   <div class=\\\"\").concat(swalClasses['timer-progress-bar-container'], \"\\\">\\n     <div class=\\\"\").concat(swalClasses['timer-progress-bar'], \"\\\"></div>\\n   </div>\\n </div>\\n\").replace(/(^|\\n)\\s*/g, '');\n\n  var resetOldContainer = function resetOldContainer() {\n    var oldContainer = getContainer();\n\n    if (!oldContainer) {\n      return false;\n    }\n\n    oldContainer.parentNode.removeChild(oldContainer);\n    removeClass([document.documentElement, document.body], [swalClasses['no-backdrop'], swalClasses['toast-shown'], swalClasses['has-column']]);\n    return true;\n  };\n\n  var oldInputVal; // IE11 workaround, see #1109 for details\n\n  var resetValidationMessage = function resetValidationMessage(e) {\n    if (Swal.isVisible() && oldInputVal !== e.target.value) {\n      Swal.resetValidationMessage();\n    }\n\n    oldInputVal = e.target.value;\n  };\n\n  var addInputChangeListeners = function addInputChangeListeners() {\n    var content = getContent();\n    var input = getChildByClass(content, swalClasses.input);\n    var file = getChildByClass(content, swalClasses.file);\n    var range = content.querySelector(\".\".concat(swalClasses.range, \" input\"));\n    var rangeOutput = content.querySelector(\".\".concat(swalClasses.range, \" output\"));\n    var select = getChildByClass(content, swalClasses.select);\n    var checkbox = content.querySelector(\".\".concat(swalClasses.checkbox, \" input\"));\n    var textarea = getChildByClass(content, swalClasses.textarea);\n    input.oninput = resetValidationMessage;\n    file.onchange = resetValidationMessage;\n    select.onchange = resetValidationMessage;\n    checkbox.onchange = resetValidationMessage;\n    textarea.oninput = resetValidationMessage;\n\n    range.oninput = function (e) {\n      resetValidationMessage(e);\n      rangeOutput.value = range.value;\n    };\n\n    range.onchange = function (e) {\n      resetValidationMessage(e);\n      range.nextSibling.value = range.value;\n    };\n  };\n\n  var getTarget = function getTarget(target) {\n    return typeof target === 'string' ? document.querySelector(target) : target;\n  };\n\n  var setupAccessibility = function setupAccessibility(params) {\n    var popup = getPopup();\n    popup.setAttribute('role', params.toast ? 'alert' : 'dialog');\n    popup.setAttribute('aria-live', params.toast ? 'polite' : 'assertive');\n\n    if (!params.toast) {\n      popup.setAttribute('aria-modal', 'true');\n    }\n  };\n\n  var setupRTL = function setupRTL(targetElement) {\n    if (window.getComputedStyle(targetElement).direction === 'rtl') {\n      addClass(getContainer(), swalClasses.rtl);\n    }\n  };\n  /*\n   * Add modal + backdrop to DOM\n   */\n\n\n  var init = function init(params) {\n    // Clean up the old popup container if it exists\n    var oldContainerExisted = resetOldContainer();\n    /* istanbul ignore if */\n\n    if (isNodeEnv()) {\n      error('SweetAlert2 requires document to initialize');\n      return;\n    }\n\n    var container = document.createElement('div');\n    container.className = swalClasses.container;\n\n    if (oldContainerExisted) {\n      addClass(container, swalClasses['no-transition']);\n    }\n\n    setInnerHtml(container, sweetHTML);\n    var targetElement = getTarget(params.target);\n    targetElement.appendChild(container);\n    setupAccessibility(params);\n    setupRTL(targetElement);\n    addInputChangeListeners();\n  };\n\n  var parseHtmlToContainer = function parseHtmlToContainer(param, target) {\n    // DOM element\n    if (param instanceof HTMLElement) {\n      target.appendChild(param); // Object\n    } else if (_typeof(param) === 'object') {\n      handleObject(param, target); // Plain string\n    } else if (param) {\n      setInnerHtml(target, param);\n    }\n  };\n\n  var handleObject = function handleObject(param, target) {\n    // JQuery element(s)\n    if (param.jquery) {\n      handleJqueryElem(target, param); // For other objects use their string representation\n    } else {\n      setInnerHtml(target, param.toString());\n    }\n  };\n\n  var handleJqueryElem = function handleJqueryElem(target, elem) {\n    target.textContent = '';\n\n    if (0 in elem) {\n      for (var i = 0; (i in elem); i++) {\n        target.appendChild(elem[i].cloneNode(true));\n      }\n    } else {\n      target.appendChild(elem.cloneNode(true));\n    }\n  };\n\n  var animationEndEvent = function () {\n    // Prevent run in Node env\n\n    /* istanbul ignore if */\n    if (isNodeEnv()) {\n      return false;\n    }\n\n    var testEl = document.createElement('div');\n    var transEndEventNames = {\n      WebkitAnimation: 'webkitAnimationEnd',\n      OAnimation: 'oAnimationEnd oanimationend',\n      animation: 'animationend'\n    };\n\n    for (var i in transEndEventNames) {\n      if (Object.prototype.hasOwnProperty.call(transEndEventNames, i) && typeof testEl.style[i] !== 'undefined') {\n        return transEndEventNames[i];\n      }\n    }\n\n    return false;\n  }();\n\n  // https://github.com/twbs/bootstrap/blob/master/js/src/modal.js\n\n  var measureScrollbar = function measureScrollbar() {\n    var scrollDiv = document.createElement('div');\n    scrollDiv.className = swalClasses['scrollbar-measure'];\n    document.body.appendChild(scrollDiv);\n    var scrollbarWidth = scrollDiv.getBoundingClientRect().width - scrollDiv.clientWidth;\n    document.body.removeChild(scrollDiv);\n    return scrollbarWidth;\n  };\n\n  var renderActions = function renderActions(instance, params) {\n    var actions = getActions();\n    var confirmButton = getConfirmButton();\n    var cancelButton = getCancelButton(); // Actions (buttons) wrapper\n\n    if (!params.showConfirmButton && !params.showCancelButton) {\n      hide(actions);\n    } // Custom class\n\n\n    applyCustomClass(actions, params, 'actions'); // Render confirm button\n\n    renderButton(confirmButton, 'confirm', params); // render Cancel Button\n\n    renderButton(cancelButton, 'cancel', params);\n\n    if (params.buttonsStyling) {\n      handleButtonsStyling(confirmButton, cancelButton, params);\n    } else {\n      removeClass([confirmButton, cancelButton], swalClasses.styled);\n      confirmButton.style.backgroundColor = confirmButton.style.borderLeftColor = confirmButton.style.borderRightColor = '';\n      cancelButton.style.backgroundColor = cancelButton.style.borderLeftColor = cancelButton.style.borderRightColor = '';\n    }\n\n    if (params.reverseButtons) {\n      confirmButton.parentNode.insertBefore(cancelButton, confirmButton);\n    }\n  };\n\n  function handleButtonsStyling(confirmButton, cancelButton, params) {\n    addClass([confirmButton, cancelButton], swalClasses.styled); // Buttons background colors\n\n    if (params.confirmButtonColor) {\n      confirmButton.style.backgroundColor = params.confirmButtonColor;\n    }\n\n    if (params.cancelButtonColor) {\n      cancelButton.style.backgroundColor = params.cancelButtonColor;\n    } // Loading state\n\n\n    if (!isLoading()) {\n      var confirmButtonBackgroundColor = window.getComputedStyle(confirmButton).getPropertyValue('background-color');\n      confirmButton.style.borderLeftColor = confirmButtonBackgroundColor;\n      confirmButton.style.borderRightColor = confirmButtonBackgroundColor;\n    }\n  }\n\n  function renderButton(button, buttonType, params) {\n    toggle(button, params[\"show\".concat(capitalizeFirstLetter(buttonType), \"Button\")], 'inline-block');\n    setInnerHtml(button, params[\"\".concat(buttonType, \"ButtonText\")]); // Set caption text\n\n    button.setAttribute('aria-label', params[\"\".concat(buttonType, \"ButtonAriaLabel\")]); // ARIA label\n    // Add buttons custom classes\n\n    button.className = swalClasses[buttonType];\n    applyCustomClass(button, params, \"\".concat(buttonType, \"Button\"));\n    addClass(button, params[\"\".concat(buttonType, \"ButtonClass\")]);\n  }\n\n  function handleBackdropParam(container, backdrop) {\n    if (typeof backdrop === 'string') {\n      container.style.background = backdrop;\n    } else if (!backdrop) {\n      addClass([document.documentElement, document.body], swalClasses['no-backdrop']);\n    }\n  }\n\n  function handlePositionParam(container, position) {\n    if (position in swalClasses) {\n      addClass(container, swalClasses[position]);\n    } else {\n      warn('The \"position\" parameter is not valid, defaulting to \"center\"');\n      addClass(container, swalClasses.center);\n    }\n  }\n\n  function handleGrowParam(container, grow) {\n    if (grow && typeof grow === 'string') {\n      var growClass = \"grow-\".concat(grow);\n\n      if (growClass in swalClasses) {\n        addClass(container, swalClasses[growClass]);\n      }\n    }\n  }\n\n  var renderContainer = function renderContainer(instance, params) {\n    var container = getContainer();\n\n    if (!container) {\n      return;\n    }\n\n    handleBackdropParam(container, params.backdrop);\n\n    if (!params.backdrop && params.allowOutsideClick) {\n      warn('\"allowOutsideClick\" parameter requires `backdrop` parameter to be set to `true`');\n    }\n\n    handlePositionParam(container, params.position);\n    handleGrowParam(container, params.grow); // Custom class\n\n    applyCustomClass(container, params, 'container'); // Set queue step attribute for getQueueStep() method\n\n    var queueStep = document.body.getAttribute('data-swal2-queue-step');\n\n    if (queueStep) {\n      container.setAttribute('data-queue-step', queueStep);\n      document.body.removeAttribute('data-swal2-queue-step');\n    }\n  };\n\n  /**\n   * This module containts `WeakMap`s for each effectively-\"private  property\" that a `Swal` has.\n   * For example, to set the private property \"foo\" of `this` to \"bar\", you can `privateProps.foo.set(this, 'bar')`\n   * This is the approach that Babel will probably take to implement private methods/fields\n   *   https://github.com/tc39/proposal-private-methods\n   *   https://github.com/babel/babel/pull/7555\n   * Once we have the changes from that PR in Babel, and our core class fits reasonable in *one module*\n   *   then we can use that language feature.\n   */\n  var privateProps = {\n    promise: new WeakMap(),\n    innerParams: new WeakMap(),\n    domCache: new WeakMap()\n  };\n\n  var inputTypes = ['input', 'file', 'range', 'select', 'radio', 'checkbox', 'textarea'];\n  var renderInput = function renderInput(instance, params) {\n    var content = getContent();\n    var innerParams = privateProps.innerParams.get(instance);\n    var rerender = !innerParams || params.input !== innerParams.input;\n    inputTypes.forEach(function (inputType) {\n      var inputClass = swalClasses[inputType];\n      var inputContainer = getChildByClass(content, inputClass); // set attributes\n\n      setAttributes(inputType, params.inputAttributes); // set class\n\n      inputContainer.className = inputClass;\n\n      if (rerender) {\n        hide(inputContainer);\n      }\n    });\n\n    if (params.input) {\n      if (rerender) {\n        showInput(params);\n      } // set custom class\n\n\n      setCustomClass(params);\n    }\n  };\n\n  var showInput = function showInput(params) {\n    if (!renderInputType[params.input]) {\n      return error(\"Unexpected type of input! Expected \\\"text\\\", \\\"email\\\", \\\"password\\\", \\\"number\\\", \\\"tel\\\", \\\"select\\\", \\\"radio\\\", \\\"checkbox\\\", \\\"textarea\\\", \\\"file\\\" or \\\"url\\\", got \\\"\".concat(params.input, \"\\\"\"));\n    }\n\n    var inputContainer = getInputContainer(params.input);\n    var input = renderInputType[params.input](inputContainer, params);\n    show(input); // input autofocus\n\n    setTimeout(function () {\n      focusInput(input);\n    });\n  };\n\n  var removeAttributes = function removeAttributes(input) {\n    for (var i = 0; i < input.attributes.length; i++) {\n      var attrName = input.attributes[i].name;\n\n      if (!(['type', 'value', 'style'].indexOf(attrName) !== -1)) {\n        input.removeAttribute(attrName);\n      }\n    }\n  };\n\n  var setAttributes = function setAttributes(inputType, inputAttributes) {\n    var input = getInput(getContent(), inputType);\n\n    if (!input) {\n      return;\n    }\n\n    removeAttributes(input);\n\n    for (var attr in inputAttributes) {\n      // Do not set a placeholder for <input type=\"range\">\n      // it'll crash Edge, #1298\n      if (inputType === 'range' && attr === 'placeholder') {\n        continue;\n      }\n\n      input.setAttribute(attr, inputAttributes[attr]);\n    }\n  };\n\n  var setCustomClass = function setCustomClass(params) {\n    var inputContainer = getInputContainer(params.input);\n\n    if (params.customClass) {\n      addClass(inputContainer, params.customClass.input);\n    }\n  };\n\n  var setInputPlaceholder = function setInputPlaceholder(input, params) {\n    if (!input.placeholder || params.inputPlaceholder) {\n      input.placeholder = params.inputPlaceholder;\n    }\n  };\n\n  var getInputContainer = function getInputContainer(inputType) {\n    var inputClass = swalClasses[inputType] ? swalClasses[inputType] : swalClasses.input;\n    return getChildByClass(getContent(), inputClass);\n  };\n\n  var renderInputType = {};\n\n  renderInputType.text = renderInputType.email = renderInputType.password = renderInputType.number = renderInputType.tel = renderInputType.url = function (input, params) {\n    if (typeof params.inputValue === 'string' || typeof params.inputValue === 'number') {\n      input.value = params.inputValue;\n    } else if (!isPromise(params.inputValue)) {\n      warn(\"Unexpected type of inputValue! Expected \\\"string\\\", \\\"number\\\" or \\\"Promise\\\", got \\\"\".concat(_typeof(params.inputValue), \"\\\"\"));\n    }\n\n    setInputPlaceholder(input, params);\n    input.type = params.input;\n    return input;\n  };\n\n  renderInputType.file = function (input, params) {\n    setInputPlaceholder(input, params);\n    return input;\n  };\n\n  renderInputType.range = function (range, params) {\n    var rangeInput = range.querySelector('input');\n    var rangeOutput = range.querySelector('output');\n    rangeInput.value = params.inputValue;\n    rangeInput.type = params.input;\n    rangeOutput.value = params.inputValue;\n    return range;\n  };\n\n  renderInputType.select = function (select, params) {\n    select.textContent = '';\n\n    if (params.inputPlaceholder) {\n      var placeholder = document.createElement('option');\n      setInnerHtml(placeholder, params.inputPlaceholder);\n      placeholder.value = '';\n      placeholder.disabled = true;\n      placeholder.selected = true;\n      select.appendChild(placeholder);\n    }\n\n    return select;\n  };\n\n  renderInputType.radio = function (radio) {\n    radio.textContent = '';\n    return radio;\n  };\n\n  renderInputType.checkbox = function (checkboxContainer, params) {\n    var checkbox = getInput(getContent(), 'checkbox');\n    checkbox.value = 1;\n    checkbox.id = swalClasses.checkbox;\n    checkbox.checked = Boolean(params.inputValue);\n    var label = checkboxContainer.querySelector('span');\n    setInnerHtml(label, params.inputPlaceholder);\n    return checkboxContainer;\n  };\n\n  renderInputType.textarea = function (textarea, params) {\n    textarea.value = params.inputValue;\n    setInputPlaceholder(textarea, params);\n\n    if ('MutationObserver' in window) {\n      // #1699\n      var initialPopupWidth = parseInt(window.getComputedStyle(getPopup()).width);\n      var popupPadding = parseInt(window.getComputedStyle(getPopup()).paddingLeft) + parseInt(window.getComputedStyle(getPopup()).paddingRight);\n\n      var outputsize = function outputsize() {\n        var contentWidth = textarea.offsetWidth + popupPadding;\n\n        if (contentWidth > initialPopupWidth) {\n          getPopup().style.width = \"\".concat(contentWidth, \"px\");\n        } else {\n          getPopup().style.width = null;\n        }\n      };\n\n      new MutationObserver(outputsize).observe(textarea, {\n        attributes: true,\n        attributeFilter: ['style']\n      });\n    }\n\n    return textarea;\n  };\n\n  var renderContent = function renderContent(instance, params) {\n    var content = getContent().querySelector(\"#\".concat(swalClasses.content)); // Content as HTML\n\n    if (params.html) {\n      parseHtmlToContainer(params.html, content);\n      show(content, 'block'); // Content as plain text\n    } else if (params.text) {\n      content.textContent = params.text;\n      show(content, 'block'); // No content\n    } else {\n      hide(content);\n    }\n\n    renderInput(instance, params); // Custom class\n\n    applyCustomClass(getContent(), params, 'content');\n  };\n\n  var renderFooter = function renderFooter(instance, params) {\n    var footer = getFooter();\n    toggle(footer, params.footer);\n\n    if (params.footer) {\n      parseHtmlToContainer(params.footer, footer);\n    } // Custom class\n\n\n    applyCustomClass(footer, params, 'footer');\n  };\n\n  var renderCloseButton = function renderCloseButton(instance, params) {\n    var closeButton = getCloseButton();\n    setInnerHtml(closeButton, params.closeButtonHtml); // Custom class\n\n    applyCustomClass(closeButton, params, 'closeButton');\n    toggle(closeButton, params.showCloseButton);\n    closeButton.setAttribute('aria-label', params.closeButtonAriaLabel);\n  };\n\n  var renderIcon = function renderIcon(instance, params) {\n    var innerParams = privateProps.innerParams.get(instance); // if the give icon already rendered, apply the custom class without re-rendering the icon\n\n    if (innerParams && params.icon === innerParams.icon && getIcon()) {\n      applyCustomClass(getIcon(), params, 'icon');\n      return;\n    }\n\n    hideAllIcons();\n\n    if (!params.icon) {\n      return;\n    }\n\n    if (Object.keys(iconTypes).indexOf(params.icon) !== -1) {\n      var icon = elementBySelector(\".\".concat(swalClasses.icon, \".\").concat(iconTypes[params.icon]));\n      show(icon); // Custom or default content\n\n      setContent(icon, params);\n      adjustSuccessIconBackgoundColor(); // Custom class\n\n      applyCustomClass(icon, params, 'icon'); // Animate icon\n\n      addClass(icon, params.showClass.icon);\n    } else {\n      error(\"Unknown icon! Expected \\\"success\\\", \\\"error\\\", \\\"warning\\\", \\\"info\\\" or \\\"question\\\", got \\\"\".concat(params.icon, \"\\\"\"));\n    }\n  };\n\n  var hideAllIcons = function hideAllIcons() {\n    var icons = getIcons();\n\n    for (var i = 0; i < icons.length; i++) {\n      hide(icons[i]);\n    }\n  }; // Adjust success icon background color to match the popup background color\n\n\n  var adjustSuccessIconBackgoundColor = function adjustSuccessIconBackgoundColor() {\n    var popup = getPopup();\n    var popupBackgroundColor = window.getComputedStyle(popup).getPropertyValue('background-color');\n    var successIconParts = popup.querySelectorAll('[class^=swal2-success-circular-line], .swal2-success-fix');\n\n    for (var i = 0; i < successIconParts.length; i++) {\n      successIconParts[i].style.backgroundColor = popupBackgroundColor;\n    }\n  };\n\n  var setContent = function setContent(icon, params) {\n    icon.textContent = '';\n\n    if (params.iconHtml) {\n      setInnerHtml(icon, iconContent(params.iconHtml));\n    } else if (params.icon === 'success') {\n      setInnerHtml(icon, \"\\n      <div class=\\\"swal2-success-circular-line-left\\\"></div>\\n      <span class=\\\"swal2-success-line-tip\\\"></span> <span class=\\\"swal2-success-line-long\\\"></span>\\n      <div class=\\\"swal2-success-ring\\\"></div> <div class=\\\"swal2-success-fix\\\"></div>\\n      <div class=\\\"swal2-success-circular-line-right\\\"></div>\\n    \");\n    } else if (params.icon === 'error') {\n      setInnerHtml(icon, \"\\n      <span class=\\\"swal2-x-mark\\\">\\n        <span class=\\\"swal2-x-mark-line-left\\\"></span>\\n        <span class=\\\"swal2-x-mark-line-right\\\"></span>\\n      </span>\\n    \");\n    } else {\n      var defaultIconHtml = {\n        question: '?',\n        warning: '!',\n        info: 'i'\n      };\n      setInnerHtml(icon, iconContent(defaultIconHtml[params.icon]));\n    }\n  };\n\n  var iconContent = function iconContent(content) {\n    return \"<div class=\\\"\".concat(swalClasses['icon-content'], \"\\\">\").concat(content, \"</div>\");\n  };\n\n  var renderImage = function renderImage(instance, params) {\n    var image = getImage();\n\n    if (!params.imageUrl) {\n      return hide(image);\n    }\n\n    show(image, ''); // Src, alt\n\n    image.setAttribute('src', params.imageUrl);\n    image.setAttribute('alt', params.imageAlt); // Width, height\n\n    applyNumericalStyle(image, 'width', params.imageWidth);\n    applyNumericalStyle(image, 'height', params.imageHeight); // Class\n\n    image.className = swalClasses.image;\n    applyCustomClass(image, params, 'image');\n  };\n\n  var currentSteps = [];\n  /*\n   * Global function for chaining sweetAlert popups\n   */\n\n  var queue = function queue(steps) {\n    var Swal = this;\n    currentSteps = steps;\n\n    var resetAndResolve = function resetAndResolve(resolve, value) {\n      currentSteps = [];\n      resolve(value);\n    };\n\n    var queueResult = [];\n    return new Promise(function (resolve) {\n      (function step(i, callback) {\n        if (i < currentSteps.length) {\n          document.body.setAttribute('data-swal2-queue-step', i);\n          Swal.fire(currentSteps[i]).then(function (result) {\n            if (typeof result.value !== 'undefined') {\n              queueResult.push(result.value);\n              step(i + 1, callback);\n            } else {\n              resetAndResolve(resolve, {\n                dismiss: result.dismiss\n              });\n            }\n          });\n        } else {\n          resetAndResolve(resolve, {\n            value: queueResult\n          });\n        }\n      })(0);\n    });\n  };\n  /*\n   * Global function for getting the index of current popup in queue\n   */\n\n  var getQueueStep = function getQueueStep() {\n    return getContainer() && getContainer().getAttribute('data-queue-step');\n  };\n  /*\n   * Global function for inserting a popup to the queue\n   */\n\n  var insertQueueStep = function insertQueueStep(step, index) {\n    if (index && index < currentSteps.length) {\n      return currentSteps.splice(index, 0, step);\n    }\n\n    return currentSteps.push(step);\n  };\n  /*\n   * Global function for deleting a popup from the queue\n   */\n\n  var deleteQueueStep = function deleteQueueStep(index) {\n    if (typeof currentSteps[index] !== 'undefined') {\n      currentSteps.splice(index, 1);\n    }\n  };\n\n  var createStepElement = function createStepElement(step) {\n    var stepEl = document.createElement('li');\n    addClass(stepEl, swalClasses['progress-step']);\n    setInnerHtml(stepEl, step);\n    return stepEl;\n  };\n\n  var createLineElement = function createLineElement(params) {\n    var lineEl = document.createElement('li');\n    addClass(lineEl, swalClasses['progress-step-line']);\n\n    if (params.progressStepsDistance) {\n      lineEl.style.width = params.progressStepsDistance;\n    }\n\n    return lineEl;\n  };\n\n  var renderProgressSteps = function renderProgressSteps(instance, params) {\n    var progressStepsContainer = getProgressSteps();\n\n    if (!params.progressSteps || params.progressSteps.length === 0) {\n      return hide(progressStepsContainer);\n    }\n\n    show(progressStepsContainer);\n    progressStepsContainer.textContent = '';\n    var currentProgressStep = parseInt(params.currentProgressStep === undefined ? getQueueStep() : params.currentProgressStep);\n\n    if (currentProgressStep >= params.progressSteps.length) {\n      warn('Invalid currentProgressStep parameter, it should be less than progressSteps.length ' + '(currentProgressStep like JS arrays starts from 0)');\n    }\n\n    params.progressSteps.forEach(function (step, index) {\n      var stepEl = createStepElement(step);\n      progressStepsContainer.appendChild(stepEl);\n\n      if (index === currentProgressStep) {\n        addClass(stepEl, swalClasses['active-progress-step']);\n      }\n\n      if (index !== params.progressSteps.length - 1) {\n        var lineEl = createLineElement(params);\n        progressStepsContainer.appendChild(lineEl);\n      }\n    });\n  };\n\n  var renderTitle = function renderTitle(instance, params) {\n    var title = getTitle();\n    toggle(title, params.title || params.titleText);\n\n    if (params.title) {\n      parseHtmlToContainer(params.title, title);\n    }\n\n    if (params.titleText) {\n      title.innerText = params.titleText;\n    } // Custom class\n\n\n    applyCustomClass(title, params, 'title');\n  };\n\n  var renderHeader = function renderHeader(instance, params) {\n    var header = getHeader(); // Custom class\n\n    applyCustomClass(header, params, 'header'); // Progress steps\n\n    renderProgressSteps(instance, params); // Icon\n\n    renderIcon(instance, params); // Image\n\n    renderImage(instance, params); // Title\n\n    renderTitle(instance, params); // Close button\n\n    renderCloseButton(instance, params);\n  };\n\n  var renderPopup = function renderPopup(instance, params) {\n    var popup = getPopup(); // Width\n\n    applyNumericalStyle(popup, 'width', params.width); // Padding\n\n    applyNumericalStyle(popup, 'padding', params.padding); // Background\n\n    if (params.background) {\n      popup.style.background = params.background;\n    } // Classes\n\n\n    addClasses(popup, params);\n  };\n\n  var addClasses = function addClasses(popup, params) {\n    // Default Class + showClass when updating Swal.update({})\n    popup.className = \"\".concat(swalClasses.popup, \" \").concat(isVisible(popup) ? params.showClass.popup : '');\n\n    if (params.toast) {\n      addClass([document.documentElement, document.body], swalClasses['toast-shown']);\n      addClass(popup, swalClasses.toast);\n    } else {\n      addClass(popup, swalClasses.modal);\n    } // Custom class\n\n\n    applyCustomClass(popup, params, 'popup');\n\n    if (typeof params.customClass === 'string') {\n      addClass(popup, params.customClass);\n    } // Icon class (#1842)\n\n\n    if (params.icon) {\n      addClass(popup, swalClasses[\"icon-\".concat(params.icon)]);\n    }\n  };\n\n  var render = function render(instance, params) {\n    renderPopup(instance, params);\n    renderContainer(instance, params);\n    renderHeader(instance, params);\n    renderContent(instance, params);\n    renderActions(instance, params);\n    renderFooter(instance, params);\n\n    if (typeof params.onRender === 'function') {\n      params.onRender(getPopup());\n    }\n  };\n\n  /*\n   * Global function to determine if SweetAlert2 popup is shown\n   */\n\n  var isVisible$1 = function isVisible$$1() {\n    return isVisible(getPopup());\n  };\n  /*\n   * Global function to click 'Confirm' button\n   */\n\n  var clickConfirm = function clickConfirm() {\n    return getConfirmButton() && getConfirmButton().click();\n  };\n  /*\n   * Global function to click 'Cancel' button\n   */\n\n  var clickCancel = function clickCancel() {\n    return getCancelButton() && getCancelButton().click();\n  };\n\n  function fire() {\n    var Swal = this;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _construct(Swal, args);\n  }\n\n  /**\n   * Returns an extended version of `Swal` containing `params` as defaults.\n   * Useful for reusing Swal configuration.\n   *\n   * For example:\n   *\n   * Before:\n   * const textPromptOptions = { input: 'text', showCancelButton: true }\n   * const {value: firstName} = await Swal.fire({ ...textPromptOptions, title: 'What is your first name?' })\n   * const {value: lastName} = await Swal.fire({ ...textPromptOptions, title: 'What is your last name?' })\n   *\n   * After:\n   * const TextPrompt = Swal.mixin({ input: 'text', showCancelButton: true })\n   * const {value: firstName} = await TextPrompt('What is your first name?')\n   * const {value: lastName} = await TextPrompt('What is your last name?')\n   *\n   * @param mixinParams\n   */\n  function mixin(mixinParams) {\n    var MixinSwal = /*#__PURE__*/function (_this) {\n      _inherits(MixinSwal, _this);\n\n      var _super = _createSuper(MixinSwal);\n\n      function MixinSwal() {\n        _classCallCheck(this, MixinSwal);\n\n        return _super.apply(this, arguments);\n      }\n\n      _createClass(MixinSwal, [{\n        key: \"_main\",\n        value: function _main(params) {\n          return _get(_getPrototypeOf(MixinSwal.prototype), \"_main\", this).call(this, _extends({}, mixinParams, params));\n        }\n      }]);\n\n      return MixinSwal;\n    }(this);\n\n    return MixinSwal;\n  }\n\n  /**\n   * Show spinner instead of Confirm button\n   */\n\n  var showLoading = function showLoading() {\n    var popup = getPopup();\n\n    if (!popup) {\n      Swal.fire();\n    }\n\n    popup = getPopup();\n    var actions = getActions();\n    var confirmButton = getConfirmButton();\n    show(actions);\n    show(confirmButton, 'inline-block');\n    addClass([popup, actions], swalClasses.loading);\n    confirmButton.disabled = true;\n    popup.setAttribute('data-loading', true);\n    popup.setAttribute('aria-busy', true);\n    popup.focus();\n  };\n\n  var RESTORE_FOCUS_TIMEOUT = 100;\n\n  var globalState = {};\n\n  var focusPreviousActiveElement = function focusPreviousActiveElement() {\n    if (globalState.previousActiveElement && globalState.previousActiveElement.focus) {\n      globalState.previousActiveElement.focus();\n      globalState.previousActiveElement = null;\n    } else if (document.body) {\n      document.body.focus();\n    }\n  }; // Restore previous active (focused) element\n\n\n  var restoreActiveElement = function restoreActiveElement() {\n    return new Promise(function (resolve) {\n      var x = window.scrollX;\n      var y = window.scrollY;\n      globalState.restoreFocusTimeout = setTimeout(function () {\n        focusPreviousActiveElement();\n        resolve();\n      }, RESTORE_FOCUS_TIMEOUT); // issues/900\n\n      /* istanbul ignore if */\n\n      if (typeof x !== 'undefined' && typeof y !== 'undefined') {\n        // IE doesn't have scrollX/scrollY support\n        window.scrollTo(x, y);\n      }\n    });\n  };\n\n  /**\n   * If `timer` parameter is set, returns number of milliseconds of timer remained.\n   * Otherwise, returns undefined.\n   */\n\n  var getTimerLeft = function getTimerLeft() {\n    return globalState.timeout && globalState.timeout.getTimerLeft();\n  };\n  /**\n   * Stop timer. Returns number of milliseconds of timer remained.\n   * If `timer` parameter isn't set, returns undefined.\n   */\n\n  var stopTimer = function stopTimer() {\n    if (globalState.timeout) {\n      stopTimerProgressBar();\n      return globalState.timeout.stop();\n    }\n  };\n  /**\n   * Resume timer. Returns number of milliseconds of timer remained.\n   * If `timer` parameter isn't set, returns undefined.\n   */\n\n  var resumeTimer = function resumeTimer() {\n    if (globalState.timeout) {\n      var remaining = globalState.timeout.start();\n      animateTimerProgressBar(remaining);\n      return remaining;\n    }\n  };\n  /**\n   * Resume timer. Returns number of milliseconds of timer remained.\n   * If `timer` parameter isn't set, returns undefined.\n   */\n\n  var toggleTimer = function toggleTimer() {\n    var timer = globalState.timeout;\n    return timer && (timer.running ? stopTimer() : resumeTimer());\n  };\n  /**\n   * Increase timer. Returns number of milliseconds of an updated timer.\n   * If `timer` parameter isn't set, returns undefined.\n   */\n\n  var increaseTimer = function increaseTimer(n) {\n    if (globalState.timeout) {\n      var remaining = globalState.timeout.increase(n);\n      animateTimerProgressBar(remaining, true);\n      return remaining;\n    }\n  };\n  /**\n   * Check if timer is running. Returns true if timer is running\n   * or false if timer is paused or stopped.\n   * If `timer` parameter isn't set, returns undefined\n   */\n\n  var isTimerRunning = function isTimerRunning() {\n    return globalState.timeout && globalState.timeout.isRunning();\n  };\n\n  var defaultParams = {\n    title: '',\n    titleText: '',\n    text: '',\n    html: '',\n    footer: '',\n    icon: undefined,\n    iconHtml: undefined,\n    toast: false,\n    animation: true,\n    showClass: {\n      popup: 'swal2-show',\n      backdrop: 'swal2-backdrop-show',\n      icon: 'swal2-icon-show'\n    },\n    hideClass: {\n      popup: 'swal2-hide',\n      backdrop: 'swal2-backdrop-hide',\n      icon: 'swal2-icon-hide'\n    },\n    customClass: undefined,\n    target: 'body',\n    backdrop: true,\n    heightAuto: true,\n    allowOutsideClick: true,\n    allowEscapeKey: true,\n    allowEnterKey: true,\n    stopKeydownPropagation: true,\n    keydownListenerCapture: false,\n    showConfirmButton: true,\n    showCancelButton: false,\n    preConfirm: undefined,\n    confirmButtonText: 'OK',\n    confirmButtonAriaLabel: '',\n    confirmButtonColor: undefined,\n    cancelButtonText: 'Cancel',\n    cancelButtonAriaLabel: '',\n    cancelButtonColor: undefined,\n    buttonsStyling: true,\n    reverseButtons: false,\n    focusConfirm: true,\n    focusCancel: false,\n    showCloseButton: false,\n    closeButtonHtml: '&times;',\n    closeButtonAriaLabel: 'Close this dialog',\n    showLoaderOnConfirm: false,\n    imageUrl: undefined,\n    imageWidth: undefined,\n    imageHeight: undefined,\n    imageAlt: '',\n    timer: undefined,\n    timerProgressBar: false,\n    width: undefined,\n    padding: undefined,\n    background: undefined,\n    input: undefined,\n    inputPlaceholder: '',\n    inputValue: '',\n    inputOptions: {},\n    inputAutoTrim: true,\n    inputAttributes: {},\n    inputValidator: undefined,\n    validationMessage: undefined,\n    grow: false,\n    position: 'center',\n    progressSteps: [],\n    currentProgressStep: undefined,\n    progressStepsDistance: undefined,\n    onBeforeOpen: undefined,\n    onOpen: undefined,\n    onRender: undefined,\n    onClose: undefined,\n    onAfterClose: undefined,\n    onDestroy: undefined,\n    scrollbarPadding: true\n  };\n  var updatableParams = ['allowEscapeKey', 'allowOutsideClick', 'buttonsStyling', 'cancelButtonAriaLabel', 'cancelButtonColor', 'cancelButtonText', 'closeButtonAriaLabel', 'closeButtonHtml', 'confirmButtonAriaLabel', 'confirmButtonColor', 'confirmButtonText', 'currentProgressStep', 'customClass', 'footer', 'hideClass', 'html', 'icon', 'imageAlt', 'imageHeight', 'imageUrl', 'imageWidth', 'onAfterClose', 'onClose', 'onDestroy', 'progressSteps', 'reverseButtons', 'showCancelButton', 'showCloseButton', 'showConfirmButton', 'text', 'title', 'titleText'];\n  var deprecatedParams = {\n    animation: 'showClass\" and \"hideClass'\n  };\n  var toastIncompatibleParams = ['allowOutsideClick', 'allowEnterKey', 'backdrop', 'focusConfirm', 'focusCancel', 'heightAuto', 'keydownListenerCapture'];\n  /**\n   * Is valid parameter\n   * @param {String} paramName\n   */\n\n  var isValidParameter = function isValidParameter(paramName) {\n    return Object.prototype.hasOwnProperty.call(defaultParams, paramName);\n  };\n  /**\n   * Is valid parameter for Swal.update() method\n   * @param {String} paramName\n   */\n\n  var isUpdatableParameter = function isUpdatableParameter(paramName) {\n    return updatableParams.indexOf(paramName) !== -1;\n  };\n  /**\n   * Is deprecated parameter\n   * @param {String} paramName\n   */\n\n  var isDeprecatedParameter = function isDeprecatedParameter(paramName) {\n    return deprecatedParams[paramName];\n  };\n\n  var checkIfParamIsValid = function checkIfParamIsValid(param) {\n    if (!isValidParameter(param)) {\n      warn(\"Unknown parameter \\\"\".concat(param, \"\\\"\"));\n    }\n  };\n\n  var checkIfToastParamIsValid = function checkIfToastParamIsValid(param) {\n    if (toastIncompatibleParams.indexOf(param) !== -1) {\n      warn(\"The parameter \\\"\".concat(param, \"\\\" is incompatible with toasts\"));\n    }\n  };\n\n  var checkIfParamIsDeprecated = function checkIfParamIsDeprecated(param) {\n    if (isDeprecatedParameter(param)) {\n      warnAboutDepreation(param, isDeprecatedParameter(param));\n    }\n  };\n  /**\n   * Show relevant warnings for given params\n   *\n   * @param params\n   */\n\n\n  var showWarningsForParams = function showWarningsForParams(params) {\n    for (var param in params) {\n      checkIfParamIsValid(param);\n\n      if (params.toast) {\n        checkIfToastParamIsValid(param);\n      }\n\n      checkIfParamIsDeprecated(param);\n    }\n  };\n\n\n\n  var staticMethods = /*#__PURE__*/Object.freeze({\n    isValidParameter: isValidParameter,\n    isUpdatableParameter: isUpdatableParameter,\n    isDeprecatedParameter: isDeprecatedParameter,\n    argsToParams: argsToParams,\n    isVisible: isVisible$1,\n    clickConfirm: clickConfirm,\n    clickCancel: clickCancel,\n    getContainer: getContainer,\n    getPopup: getPopup,\n    getTitle: getTitle,\n    getContent: getContent,\n    getHtmlContainer: getHtmlContainer,\n    getImage: getImage,\n    getIcon: getIcon,\n    getIcons: getIcons,\n    getCloseButton: getCloseButton,\n    getActions: getActions,\n    getConfirmButton: getConfirmButton,\n    getCancelButton: getCancelButton,\n    getHeader: getHeader,\n    getFooter: getFooter,\n    getTimerProgressBar: getTimerProgressBar,\n    getFocusableElements: getFocusableElements,\n    getValidationMessage: getValidationMessage,\n    isLoading: isLoading,\n    fire: fire,\n    mixin: mixin,\n    queue: queue,\n    getQueueStep: getQueueStep,\n    insertQueueStep: insertQueueStep,\n    deleteQueueStep: deleteQueueStep,\n    showLoading: showLoading,\n    enableLoading: showLoading,\n    getTimerLeft: getTimerLeft,\n    stopTimer: stopTimer,\n    resumeTimer: resumeTimer,\n    toggleTimer: toggleTimer,\n    increaseTimer: increaseTimer,\n    isTimerRunning: isTimerRunning\n  });\n\n  /**\n   * Enables buttons and hide loader.\n   */\n\n  function hideLoading() {\n    // do nothing if popup is closed\n    var innerParams = privateProps.innerParams.get(this);\n\n    if (!innerParams) {\n      return;\n    }\n\n    var domCache = privateProps.domCache.get(this);\n\n    if (!innerParams.showConfirmButton) {\n      hide(domCache.confirmButton);\n\n      if (!innerParams.showCancelButton) {\n        hide(domCache.actions);\n      }\n    }\n\n    removeClass([domCache.popup, domCache.actions], swalClasses.loading);\n    domCache.popup.removeAttribute('aria-busy');\n    domCache.popup.removeAttribute('data-loading');\n    domCache.confirmButton.disabled = false;\n    domCache.cancelButton.disabled = false;\n  }\n\n  function getInput$1(instance) {\n    var innerParams = privateProps.innerParams.get(instance || this);\n    var domCache = privateProps.domCache.get(instance || this);\n\n    if (!domCache) {\n      return null;\n    }\n\n    return getInput(domCache.content, innerParams.input);\n  }\n\n  var fixScrollbar = function fixScrollbar() {\n    // for queues, do not do this more than once\n    if (states.previousBodyPadding !== null) {\n      return;\n    } // if the body has overflow\n\n\n    if (document.body.scrollHeight > window.innerHeight) {\n      // add padding so the content doesn't shift after removal of scrollbar\n      states.previousBodyPadding = parseInt(window.getComputedStyle(document.body).getPropertyValue('padding-right'));\n      document.body.style.paddingRight = \"\".concat(states.previousBodyPadding + measureScrollbar(), \"px\");\n    }\n  };\n  var undoScrollbar = function undoScrollbar() {\n    if (states.previousBodyPadding !== null) {\n      document.body.style.paddingRight = \"\".concat(states.previousBodyPadding, \"px\");\n      states.previousBodyPadding = null;\n    }\n  };\n\n  /* istanbul ignore file */\n\n  var iOSfix = function iOSfix() {\n    var iOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream || navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1;\n\n    if (iOS && !hasClass(document.body, swalClasses.iosfix)) {\n      var offset = document.body.scrollTop;\n      document.body.style.top = \"\".concat(offset * -1, \"px\");\n      addClass(document.body, swalClasses.iosfix);\n      lockBodyScroll();\n      addBottomPaddingForTallPopups(); // #1948\n    }\n  };\n\n  var addBottomPaddingForTallPopups = function addBottomPaddingForTallPopups() {\n    var safari = !navigator.userAgent.match(/(CriOS|FxiOS|EdgiOS|YaBrowser|UCBrowser)/i);\n\n    if (safari) {\n      var bottomPanelHeight = 44;\n\n      if (getPopup().scrollHeight > window.innerHeight - bottomPanelHeight) {\n        getContainer().style.paddingBottom = \"\".concat(bottomPanelHeight, \"px\");\n      }\n    }\n  };\n\n  var lockBodyScroll = function lockBodyScroll() {\n    // #1246\n    var container = getContainer();\n    var preventTouchMove;\n\n    container.ontouchstart = function (e) {\n      preventTouchMove = shouldPreventTouchMove(e.target);\n    };\n\n    container.ontouchmove = function (e) {\n      if (preventTouchMove) {\n        e.preventDefault();\n        e.stopPropagation();\n      }\n    };\n  };\n\n  var shouldPreventTouchMove = function shouldPreventTouchMove(target) {\n    var container = getContainer();\n\n    if (target === container) {\n      return true;\n    }\n\n    if (!isScrollable(container) && target.tagName !== 'INPUT' && // #1603\n    !(isScrollable(getContent()) && // #1944\n    getContent().contains(target))) {\n      return true;\n    }\n\n    return false;\n  };\n\n  var undoIOSfix = function undoIOSfix() {\n    if (hasClass(document.body, swalClasses.iosfix)) {\n      var offset = parseInt(document.body.style.top, 10);\n      removeClass(document.body, swalClasses.iosfix);\n      document.body.style.top = '';\n      document.body.scrollTop = offset * -1;\n    }\n  };\n\n  /* istanbul ignore file */\n\n  var isIE11 = function isIE11() {\n    return !!window.MSInputMethodContext && !!document.documentMode;\n  }; // Fix IE11 centering sweetalert2/issues/933\n\n\n  var fixVerticalPositionIE = function fixVerticalPositionIE() {\n    var container = getContainer();\n    var popup = getPopup();\n    container.style.removeProperty('align-items');\n\n    if (popup.offsetTop < 0) {\n      container.style.alignItems = 'flex-start';\n    }\n  };\n\n  var IEfix = function IEfix() {\n    if (typeof window !== 'undefined' && isIE11()) {\n      fixVerticalPositionIE();\n      window.addEventListener('resize', fixVerticalPositionIE);\n    }\n  };\n  var undoIEfix = function undoIEfix() {\n    if (typeof window !== 'undefined' && isIE11()) {\n      window.removeEventListener('resize', fixVerticalPositionIE);\n    }\n  };\n\n  // Adding aria-hidden=\"true\" to elements outside of the active modal dialog ensures that\n  // elements not within the active modal dialog will not be surfaced if a user opens a screen\n  // reader’s list of elements (headings, form controls, landmarks, etc.) in the document.\n\n  var setAriaHidden = function setAriaHidden() {\n    var bodyChildren = toArray(document.body.children);\n    bodyChildren.forEach(function (el) {\n      if (el === getContainer() || contains(el, getContainer())) {\n        return;\n      }\n\n      if (el.hasAttribute('aria-hidden')) {\n        el.setAttribute('data-previous-aria-hidden', el.getAttribute('aria-hidden'));\n      }\n\n      el.setAttribute('aria-hidden', 'true');\n    });\n  };\n  var unsetAriaHidden = function unsetAriaHidden() {\n    var bodyChildren = toArray(document.body.children);\n    bodyChildren.forEach(function (el) {\n      if (el.hasAttribute('data-previous-aria-hidden')) {\n        el.setAttribute('aria-hidden', el.getAttribute('data-previous-aria-hidden'));\n        el.removeAttribute('data-previous-aria-hidden');\n      } else {\n        el.removeAttribute('aria-hidden');\n      }\n    });\n  };\n\n  /**\n   * This module containts `WeakMap`s for each effectively-\"private  property\" that a `Swal` has.\n   * For example, to set the private property \"foo\" of `this` to \"bar\", you can `privateProps.foo.set(this, 'bar')`\n   * This is the approach that Babel will probably take to implement private methods/fields\n   *   https://github.com/tc39/proposal-private-methods\n   *   https://github.com/babel/babel/pull/7555\n   * Once we have the changes from that PR in Babel, and our core class fits reasonable in *one module*\n   *   then we can use that language feature.\n   */\n  var privateMethods = {\n    swalPromiseResolve: new WeakMap()\n  };\n\n  /*\n   * Instance method to close sweetAlert\n   */\n\n  function removePopupAndResetState(instance, container, isToast$$1, onAfterClose) {\n    if (isToast$$1) {\n      triggerOnAfterCloseAndDispose(instance, onAfterClose);\n    } else {\n      restoreActiveElement().then(function () {\n        return triggerOnAfterCloseAndDispose(instance, onAfterClose);\n      });\n      globalState.keydownTarget.removeEventListener('keydown', globalState.keydownHandler, {\n        capture: globalState.keydownListenerCapture\n      });\n      globalState.keydownHandlerAdded = false;\n    }\n\n    if (container.parentNode && !document.body.getAttribute('data-swal2-queue-step')) {\n      container.parentNode.removeChild(container);\n    }\n\n    if (isModal()) {\n      undoScrollbar();\n      undoIOSfix();\n      undoIEfix();\n      unsetAriaHidden();\n    }\n\n    removeBodyClasses();\n  }\n\n  function removeBodyClasses() {\n    removeClass([document.documentElement, document.body], [swalClasses.shown, swalClasses['height-auto'], swalClasses['no-backdrop'], swalClasses['toast-shown'], swalClasses['toast-column']]);\n  }\n\n  function close(resolveValue) {\n    var popup = getPopup();\n\n    if (!popup) {\n      return;\n    }\n\n    var innerParams = privateProps.innerParams.get(this);\n\n    if (!innerParams || hasClass(popup, innerParams.hideClass.popup)) {\n      return;\n    }\n\n    var swalPromiseResolve = privateMethods.swalPromiseResolve.get(this);\n    removeClass(popup, innerParams.showClass.popup);\n    addClass(popup, innerParams.hideClass.popup);\n    var backdrop = getContainer();\n    removeClass(backdrop, innerParams.showClass.backdrop);\n    addClass(backdrop, innerParams.hideClass.backdrop);\n    handlePopupAnimation(this, popup, innerParams);\n\n    if (typeof resolveValue !== 'undefined') {\n      resolveValue.isDismissed = typeof resolveValue.dismiss !== 'undefined';\n      resolveValue.isConfirmed = typeof resolveValue.dismiss === 'undefined';\n    } else {\n      resolveValue = {\n        isDismissed: true,\n        isConfirmed: false\n      };\n    } // Resolve Swal promise\n\n\n    swalPromiseResolve(resolveValue || {});\n  }\n\n  var handlePopupAnimation = function handlePopupAnimation(instance, popup, innerParams) {\n    var container = getContainer(); // If animation is supported, animate\n\n    var animationIsSupported = animationEndEvent && hasCssAnimation(popup);\n    var onClose = innerParams.onClose,\n        onAfterClose = innerParams.onAfterClose;\n\n    if (onClose !== null && typeof onClose === 'function') {\n      onClose(popup);\n    }\n\n    if (animationIsSupported) {\n      animatePopup(instance, popup, container, onAfterClose);\n    } else {\n      // Otherwise, remove immediately\n      removePopupAndResetState(instance, container, isToast(), onAfterClose);\n    }\n  };\n\n  var animatePopup = function animatePopup(instance, popup, container, onAfterClose) {\n    globalState.swalCloseEventFinishedCallback = removePopupAndResetState.bind(null, instance, container, isToast(), onAfterClose);\n    popup.addEventListener(animationEndEvent, function (e) {\n      if (e.target === popup) {\n        globalState.swalCloseEventFinishedCallback();\n        delete globalState.swalCloseEventFinishedCallback;\n      }\n    });\n  };\n\n  var triggerOnAfterCloseAndDispose = function triggerOnAfterCloseAndDispose(instance, onAfterClose) {\n    setTimeout(function () {\n      if (typeof onAfterClose === 'function') {\n        onAfterClose();\n      }\n\n      instance._destroy();\n    });\n  };\n\n  function setButtonsDisabled(instance, buttons, disabled) {\n    var domCache = privateProps.domCache.get(instance);\n    buttons.forEach(function (button) {\n      domCache[button].disabled = disabled;\n    });\n  }\n\n  function setInputDisabled(input, disabled) {\n    if (!input) {\n      return false;\n    }\n\n    if (input.type === 'radio') {\n      var radiosContainer = input.parentNode.parentNode;\n      var radios = radiosContainer.querySelectorAll('input');\n\n      for (var i = 0; i < radios.length; i++) {\n        radios[i].disabled = disabled;\n      }\n    } else {\n      input.disabled = disabled;\n    }\n  }\n\n  function enableButtons() {\n    setButtonsDisabled(this, ['confirmButton', 'cancelButton'], false);\n  }\n  function disableButtons() {\n    setButtonsDisabled(this, ['confirmButton', 'cancelButton'], true);\n  }\n  function enableInput() {\n    return setInputDisabled(this.getInput(), false);\n  }\n  function disableInput() {\n    return setInputDisabled(this.getInput(), true);\n  }\n\n  function showValidationMessage(error) {\n    var domCache = privateProps.domCache.get(this);\n    setInnerHtml(domCache.validationMessage, error);\n    var popupComputedStyle = window.getComputedStyle(domCache.popup);\n    domCache.validationMessage.style.marginLeft = \"-\".concat(popupComputedStyle.getPropertyValue('padding-left'));\n    domCache.validationMessage.style.marginRight = \"-\".concat(popupComputedStyle.getPropertyValue('padding-right'));\n    show(domCache.validationMessage);\n    var input = this.getInput();\n\n    if (input) {\n      input.setAttribute('aria-invalid', true);\n      input.setAttribute('aria-describedBy', swalClasses['validation-message']);\n      focusInput(input);\n      addClass(input, swalClasses.inputerror);\n    }\n  } // Hide block with validation message\n\n  function resetValidationMessage$1() {\n    var domCache = privateProps.domCache.get(this);\n\n    if (domCache.validationMessage) {\n      hide(domCache.validationMessage);\n    }\n\n    var input = this.getInput();\n\n    if (input) {\n      input.removeAttribute('aria-invalid');\n      input.removeAttribute('aria-describedBy');\n      removeClass(input, swalClasses.inputerror);\n    }\n  }\n\n  function getProgressSteps$1() {\n    var domCache = privateProps.domCache.get(this);\n    return domCache.progressSteps;\n  }\n\n  var Timer = /*#__PURE__*/function () {\n    function Timer(callback, delay) {\n      _classCallCheck(this, Timer);\n\n      this.callback = callback;\n      this.remaining = delay;\n      this.running = false;\n      this.start();\n    }\n\n    _createClass(Timer, [{\n      key: \"start\",\n      value: function start() {\n        if (!this.running) {\n          this.running = true;\n          this.started = new Date();\n          this.id = setTimeout(this.callback, this.remaining);\n        }\n\n        return this.remaining;\n      }\n    }, {\n      key: \"stop\",\n      value: function stop() {\n        if (this.running) {\n          this.running = false;\n          clearTimeout(this.id);\n          this.remaining -= new Date() - this.started;\n        }\n\n        return this.remaining;\n      }\n    }, {\n      key: \"increase\",\n      value: function increase(n) {\n        var running = this.running;\n\n        if (running) {\n          this.stop();\n        }\n\n        this.remaining += n;\n\n        if (running) {\n          this.start();\n        }\n\n        return this.remaining;\n      }\n    }, {\n      key: \"getTimerLeft\",\n      value: function getTimerLeft() {\n        if (this.running) {\n          this.stop();\n          this.start();\n        }\n\n        return this.remaining;\n      }\n    }, {\n      key: \"isRunning\",\n      value: function isRunning() {\n        return this.running;\n      }\n    }]);\n\n    return Timer;\n  }();\n\n  var defaultInputValidators = {\n    email: function email(string, validationMessage) {\n      return /^[a-zA-Z0-9.+_-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z0-9-]{2,24}$/.test(string) ? Promise.resolve() : Promise.resolve(validationMessage || 'Invalid email address');\n    },\n    url: function url(string, validationMessage) {\n      // taken from https://stackoverflow.com/a/3809435 with a small change from #1306 and #2013\n      return /^https?:\\/\\/(www\\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\\.[a-z]{2,63}\\b([-a-zA-Z0-9@:%_+.~#?&/=]*)$/.test(string) ? Promise.resolve() : Promise.resolve(validationMessage || 'Invalid URL');\n    }\n  };\n\n  function setDefaultInputValidators(params) {\n    // Use default `inputValidator` for supported input types if not provided\n    if (!params.inputValidator) {\n      Object.keys(defaultInputValidators).forEach(function (key) {\n        if (params.input === key) {\n          params.inputValidator = defaultInputValidators[key];\n        }\n      });\n    }\n  }\n\n  function validateCustomTargetElement(params) {\n    // Determine if the custom target element is valid\n    if (!params.target || typeof params.target === 'string' && !document.querySelector(params.target) || typeof params.target !== 'string' && !params.target.appendChild) {\n      warn('Target parameter is not valid, defaulting to \"body\"');\n      params.target = 'body';\n    }\n  }\n  /**\n   * Set type, text and actions on popup\n   *\n   * @param params\n   * @returns {boolean}\n   */\n\n\n  function setParameters(params) {\n    setDefaultInputValidators(params); // showLoaderOnConfirm && preConfirm\n\n    if (params.showLoaderOnConfirm && !params.preConfirm) {\n      warn('showLoaderOnConfirm is set to true, but preConfirm is not defined.\\n' + 'showLoaderOnConfirm should be used together with preConfirm, see usage example:\\n' + 'https://sweetalert2.github.io/#ajax-request');\n    } // params.animation will be actually used in renderPopup.js\n    // but in case when params.animation is a function, we need to call that function\n    // before popup (re)initialization, so it'll be possible to check Swal.isVisible()\n    // inside the params.animation function\n\n\n    params.animation = callIfFunction(params.animation);\n    validateCustomTargetElement(params); // Replace newlines with <br> in title\n\n    if (typeof params.title === 'string') {\n      params.title = params.title.split('\\n').join('<br />');\n    }\n\n    init(params);\n  }\n\n  /**\n   * Open popup, add necessary classes and styles, fix scrollbar\n   *\n   * @param {Array} params\n   */\n\n  var openPopup = function openPopup(params) {\n    var container = getContainer();\n    var popup = getPopup();\n\n    if (typeof params.onBeforeOpen === 'function') {\n      params.onBeforeOpen(popup);\n    }\n\n    var bodyStyles = window.getComputedStyle(document.body);\n    var initialBodyOverflow = bodyStyles.overflowY;\n    addClasses$1(container, popup, params); // scrolling is 'hidden' until animation is done, after that 'auto'\n\n    setScrollingVisibility(container, popup);\n\n    if (isModal()) {\n      fixScrollContainer(container, params.scrollbarPadding, initialBodyOverflow);\n      setAriaHidden();\n    }\n\n    if (!isToast() && !globalState.previousActiveElement) {\n      globalState.previousActiveElement = document.activeElement;\n    }\n\n    if (typeof params.onOpen === 'function') {\n      setTimeout(function () {\n        return params.onOpen(popup);\n      });\n    }\n\n    removeClass(container, swalClasses['no-transition']);\n  };\n\n  function swalOpenAnimationFinished(event) {\n    var popup = getPopup();\n\n    if (event.target !== popup) {\n      return;\n    }\n\n    var container = getContainer();\n    popup.removeEventListener(animationEndEvent, swalOpenAnimationFinished);\n    container.style.overflowY = 'auto';\n  }\n\n  var setScrollingVisibility = function setScrollingVisibility(container, popup) {\n    if (animationEndEvent && hasCssAnimation(popup)) {\n      container.style.overflowY = 'hidden';\n      popup.addEventListener(animationEndEvent, swalOpenAnimationFinished);\n    } else {\n      container.style.overflowY = 'auto';\n    }\n  };\n\n  var fixScrollContainer = function fixScrollContainer(container, scrollbarPadding, initialBodyOverflow) {\n    iOSfix();\n    IEfix();\n\n    if (scrollbarPadding && initialBodyOverflow !== 'hidden') {\n      fixScrollbar();\n    } // sweetalert2/issues/1247\n\n\n    setTimeout(function () {\n      container.scrollTop = 0;\n    });\n  };\n\n  var addClasses$1 = function addClasses(container, popup, params) {\n    addClass(container, params.showClass.backdrop);\n    show(popup); // Animate popup right after showing it\n\n    addClass(popup, params.showClass.popup);\n    addClass([document.documentElement, document.body], swalClasses.shown);\n\n    if (params.heightAuto && params.backdrop && !params.toast) {\n      addClass([document.documentElement, document.body], swalClasses['height-auto']);\n    }\n  };\n\n  var handleInputOptionsAndValue = function handleInputOptionsAndValue(instance, params) {\n    if (params.input === 'select' || params.input === 'radio') {\n      handleInputOptions(instance, params);\n    } else if (['text', 'email', 'number', 'tel', 'textarea'].indexOf(params.input) !== -1 && (hasToPromiseFn(params.inputValue) || isPromise(params.inputValue))) {\n      handleInputValue(instance, params);\n    }\n  };\n  var getInputValue = function getInputValue(instance, innerParams) {\n    var input = instance.getInput();\n\n    if (!input) {\n      return null;\n    }\n\n    switch (innerParams.input) {\n      case 'checkbox':\n        return getCheckboxValue(input);\n\n      case 'radio':\n        return getRadioValue(input);\n\n      case 'file':\n        return getFileValue(input);\n\n      default:\n        return innerParams.inputAutoTrim ? input.value.trim() : input.value;\n    }\n  };\n\n  var getCheckboxValue = function getCheckboxValue(input) {\n    return input.checked ? 1 : 0;\n  };\n\n  var getRadioValue = function getRadioValue(input) {\n    return input.checked ? input.value : null;\n  };\n\n  var getFileValue = function getFileValue(input) {\n    return input.files.length ? input.getAttribute('multiple') !== null ? input.files : input.files[0] : null;\n  };\n\n  var handleInputOptions = function handleInputOptions(instance, params) {\n    var content = getContent();\n\n    var processInputOptions = function processInputOptions(inputOptions) {\n      return populateInputOptions[params.input](content, formatInputOptions(inputOptions), params);\n    };\n\n    if (hasToPromiseFn(params.inputOptions) || isPromise(params.inputOptions)) {\n      showLoading();\n      asPromise(params.inputOptions).then(function (inputOptions) {\n        instance.hideLoading();\n        processInputOptions(inputOptions);\n      });\n    } else if (_typeof(params.inputOptions) === 'object') {\n      processInputOptions(params.inputOptions);\n    } else {\n      error(\"Unexpected type of inputOptions! Expected object, Map or Promise, got \".concat(_typeof(params.inputOptions)));\n    }\n  };\n\n  var handleInputValue = function handleInputValue(instance, params) {\n    var input = instance.getInput();\n    hide(input);\n    asPromise(params.inputValue).then(function (inputValue) {\n      input.value = params.input === 'number' ? parseFloat(inputValue) || 0 : \"\".concat(inputValue);\n      show(input);\n      input.focus();\n      instance.hideLoading();\n    })[\"catch\"](function (err) {\n      error(\"Error in inputValue promise: \".concat(err));\n      input.value = '';\n      show(input);\n      input.focus();\n      instance.hideLoading();\n    });\n  };\n\n  var populateInputOptions = {\n    select: function select(content, inputOptions, params) {\n      var select = getChildByClass(content, swalClasses.select);\n\n      var renderOption = function renderOption(parent, optionLabel, optionValue) {\n        var option = document.createElement('option');\n        option.value = optionValue;\n        setInnerHtml(option, optionLabel);\n\n        if (params.inputValue.toString() === optionValue.toString()) {\n          option.selected = true;\n        }\n\n        parent.appendChild(option);\n      };\n\n      inputOptions.forEach(function (inputOption) {\n        var optionValue = inputOption[0];\n        var optionLabel = inputOption[1]; // <optgroup> spec:\n        // https://www.w3.org/TR/html401/interact/forms.html#h-17.6\n        // \"...all OPTGROUP elements must be specified directly within a SELECT element (i.e., groups may not be nested)...\"\n        // check whether this is a <optgroup>\n\n        if (Array.isArray(optionLabel)) {\n          // if it is an array, then it is an <optgroup>\n          var optgroup = document.createElement('optgroup');\n          optgroup.label = optionValue;\n          optgroup.disabled = false; // not configurable for now\n\n          select.appendChild(optgroup);\n          optionLabel.forEach(function (o) {\n            return renderOption(optgroup, o[1], o[0]);\n          });\n        } else {\n          // case of <option>\n          renderOption(select, optionLabel, optionValue);\n        }\n      });\n      select.focus();\n    },\n    radio: function radio(content, inputOptions, params) {\n      var radio = getChildByClass(content, swalClasses.radio);\n      inputOptions.forEach(function (inputOption) {\n        var radioValue = inputOption[0];\n        var radioLabel = inputOption[1];\n        var radioInput = document.createElement('input');\n        var radioLabelElement = document.createElement('label');\n        radioInput.type = 'radio';\n        radioInput.name = swalClasses.radio;\n        radioInput.value = radioValue;\n\n        if (params.inputValue.toString() === radioValue.toString()) {\n          radioInput.checked = true;\n        }\n\n        var label = document.createElement('span');\n        setInnerHtml(label, radioLabel);\n        label.className = swalClasses.label;\n        radioLabelElement.appendChild(radioInput);\n        radioLabelElement.appendChild(label);\n        radio.appendChild(radioLabelElement);\n      });\n      var radios = radio.querySelectorAll('input');\n\n      if (radios.length) {\n        radios[0].focus();\n      }\n    }\n  };\n  /**\n   * Converts `inputOptions` into an array of `[value, label]`s\n   * @param inputOptions\n   */\n\n  var formatInputOptions = function formatInputOptions(inputOptions) {\n    var result = [];\n\n    if (typeof Map !== 'undefined' && inputOptions instanceof Map) {\n      inputOptions.forEach(function (value, key) {\n        var valueFormatted = value;\n\n        if (_typeof(valueFormatted) === 'object') {\n          // case of <optgroup>\n          valueFormatted = formatInputOptions(valueFormatted);\n        }\n\n        result.push([key, valueFormatted]);\n      });\n    } else {\n      Object.keys(inputOptions).forEach(function (key) {\n        var valueFormatted = inputOptions[key];\n\n        if (_typeof(valueFormatted) === 'object') {\n          // case of <optgroup>\n          valueFormatted = formatInputOptions(valueFormatted);\n        }\n\n        result.push([key, valueFormatted]);\n      });\n    }\n\n    return result;\n  };\n\n  var handleConfirmButtonClick = function handleConfirmButtonClick(instance, innerParams) {\n    instance.disableButtons();\n\n    if (innerParams.input) {\n      handleConfirmWithInput(instance, innerParams);\n    } else {\n      confirm(instance, innerParams, true);\n    }\n  };\n  var handleCancelButtonClick = function handleCancelButtonClick(instance, dismissWith) {\n    instance.disableButtons();\n    dismissWith(DismissReason.cancel);\n  };\n\n  var handleConfirmWithInput = function handleConfirmWithInput(instance, innerParams) {\n    var inputValue = getInputValue(instance, innerParams);\n\n    if (innerParams.inputValidator) {\n      instance.disableInput();\n      var validationPromise = Promise.resolve().then(function () {\n        return asPromise(innerParams.inputValidator(inputValue, innerParams.validationMessage));\n      });\n      validationPromise.then(function (validationMessage) {\n        instance.enableButtons();\n        instance.enableInput();\n\n        if (validationMessage) {\n          instance.showValidationMessage(validationMessage);\n        } else {\n          confirm(instance, innerParams, inputValue);\n        }\n      });\n    } else if (!instance.getInput().checkValidity()) {\n      instance.enableButtons();\n      instance.showValidationMessage(innerParams.validationMessage);\n    } else {\n      confirm(instance, innerParams, inputValue);\n    }\n  };\n\n  var succeedWith = function succeedWith(instance, value) {\n    instance.closePopup({\n      value: value\n    });\n  };\n\n  var confirm = function confirm(instance, innerParams, value) {\n    if (innerParams.showLoaderOnConfirm) {\n      showLoading(); // TODO: make showLoading an *instance* method\n    }\n\n    if (innerParams.preConfirm) {\n      instance.resetValidationMessage();\n      var preConfirmPromise = Promise.resolve().then(function () {\n        return asPromise(innerParams.preConfirm(value, innerParams.validationMessage));\n      });\n      preConfirmPromise.then(function (preConfirmValue) {\n        if (isVisible(getValidationMessage()) || preConfirmValue === false) {\n          instance.hideLoading();\n        } else {\n          succeedWith(instance, typeof preConfirmValue === 'undefined' ? value : preConfirmValue);\n        }\n      });\n    } else {\n      succeedWith(instance, value);\n    }\n  };\n\n  var addKeydownHandler = function addKeydownHandler(instance, globalState, innerParams, dismissWith) {\n    if (globalState.keydownTarget && globalState.keydownHandlerAdded) {\n      globalState.keydownTarget.removeEventListener('keydown', globalState.keydownHandler, {\n        capture: globalState.keydownListenerCapture\n      });\n      globalState.keydownHandlerAdded = false;\n    }\n\n    if (!innerParams.toast) {\n      globalState.keydownHandler = function (e) {\n        return keydownHandler(instance, e, dismissWith);\n      };\n\n      globalState.keydownTarget = innerParams.keydownListenerCapture ? window : getPopup();\n      globalState.keydownListenerCapture = innerParams.keydownListenerCapture;\n      globalState.keydownTarget.addEventListener('keydown', globalState.keydownHandler, {\n        capture: globalState.keydownListenerCapture\n      });\n      globalState.keydownHandlerAdded = true;\n    }\n  }; // Focus handling\n\n  var setFocus = function setFocus(innerParams, index, increment) {\n    var focusableElements = getFocusableElements(); // search for visible elements and select the next possible match\n\n    for (var i = 0; i < focusableElements.length; i++) {\n      index = index + increment; // rollover to first item\n\n      if (index === focusableElements.length) {\n        index = 0; // go to last item\n      } else if (index === -1) {\n        index = focusableElements.length - 1;\n      }\n\n      return focusableElements[index].focus();\n    } // no visible focusable elements, focus the popup\n\n\n    getPopup().focus();\n  };\n  var arrowKeys = ['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', 'Left', 'Right', 'Up', 'Down' // IE11\n  ];\n  var escKeys = ['Escape', 'Esc' // IE11\n  ];\n\n  var keydownHandler = function keydownHandler(instance, e, dismissWith) {\n    var innerParams = privateProps.innerParams.get(instance);\n\n    if (innerParams.stopKeydownPropagation) {\n      e.stopPropagation();\n    } // ENTER\n\n\n    if (e.key === 'Enter') {\n      handleEnter(instance, e, innerParams); // TAB\n    } else if (e.key === 'Tab') {\n      handleTab(e, innerParams); // ARROWS - switch focus between buttons\n    } else if (arrowKeys.indexOf(e.key) !== -1) {\n      handleArrows(); // ESC\n    } else if (escKeys.indexOf(e.key) !== -1) {\n      handleEsc(e, innerParams, dismissWith);\n    }\n  };\n\n  var handleEnter = function handleEnter(instance, e, innerParams) {\n    // #720 #721\n    if (e.isComposing) {\n      return;\n    }\n\n    if (e.target && instance.getInput() && e.target.outerHTML === instance.getInput().outerHTML) {\n      if (['textarea', 'file'].indexOf(innerParams.input) !== -1) {\n        return; // do not submit\n      }\n\n      clickConfirm();\n      e.preventDefault();\n    }\n  };\n\n  var handleTab = function handleTab(e, innerParams) {\n    var targetElement = e.target;\n    var focusableElements = getFocusableElements();\n    var btnIndex = -1;\n\n    for (var i = 0; i < focusableElements.length; i++) {\n      if (targetElement === focusableElements[i]) {\n        btnIndex = i;\n        break;\n      }\n    }\n\n    if (!e.shiftKey) {\n      // Cycle to the next button\n      setFocus(innerParams, btnIndex, 1);\n    } else {\n      // Cycle to the prev button\n      setFocus(innerParams, btnIndex, -1);\n    }\n\n    e.stopPropagation();\n    e.preventDefault();\n  };\n\n  var handleArrows = function handleArrows() {\n    var confirmButton = getConfirmButton();\n    var cancelButton = getCancelButton(); // focus Cancel button if Confirm button is currently focused\n\n    if (document.activeElement === confirmButton && isVisible(cancelButton)) {\n      cancelButton.focus(); // and vice versa\n    } else if (document.activeElement === cancelButton && isVisible(confirmButton)) {\n      confirmButton.focus();\n    }\n  };\n\n  var handleEsc = function handleEsc(e, innerParams, dismissWith) {\n    if (callIfFunction(innerParams.allowEscapeKey)) {\n      e.preventDefault();\n      dismissWith(DismissReason.esc);\n    }\n  };\n\n  var handlePopupClick = function handlePopupClick(instance, domCache, dismissWith) {\n    var innerParams = privateProps.innerParams.get(instance);\n\n    if (innerParams.toast) {\n      handleToastClick(instance, domCache, dismissWith);\n    } else {\n      // Ignore click events that had mousedown on the popup but mouseup on the container\n      // This can happen when the user drags a slider\n      handleModalMousedown(domCache); // Ignore click events that had mousedown on the container but mouseup on the popup\n\n      handleContainerMousedown(domCache);\n      handleModalClick(instance, domCache, dismissWith);\n    }\n  };\n\n  var handleToastClick = function handleToastClick(instance, domCache, dismissWith) {\n    // Closing toast by internal click\n    domCache.popup.onclick = function () {\n      var innerParams = privateProps.innerParams.get(instance);\n\n      if (innerParams.showConfirmButton || innerParams.showCancelButton || innerParams.showCloseButton || innerParams.input) {\n        return;\n      }\n\n      dismissWith(DismissReason.close);\n    };\n  };\n\n  var ignoreOutsideClick = false;\n\n  var handleModalMousedown = function handleModalMousedown(domCache) {\n    domCache.popup.onmousedown = function () {\n      domCache.container.onmouseup = function (e) {\n        domCache.container.onmouseup = undefined; // We only check if the mouseup target is the container because usually it doesn't\n        // have any other direct children aside of the popup\n\n        if (e.target === domCache.container) {\n          ignoreOutsideClick = true;\n        }\n      };\n    };\n  };\n\n  var handleContainerMousedown = function handleContainerMousedown(domCache) {\n    domCache.container.onmousedown = function () {\n      domCache.popup.onmouseup = function (e) {\n        domCache.popup.onmouseup = undefined; // We also need to check if the mouseup target is a child of the popup\n\n        if (e.target === domCache.popup || domCache.popup.contains(e.target)) {\n          ignoreOutsideClick = true;\n        }\n      };\n    };\n  };\n\n  var handleModalClick = function handleModalClick(instance, domCache, dismissWith) {\n    domCache.container.onclick = function (e) {\n      var innerParams = privateProps.innerParams.get(instance);\n\n      if (ignoreOutsideClick) {\n        ignoreOutsideClick = false;\n        return;\n      }\n\n      if (e.target === domCache.container && callIfFunction(innerParams.allowOutsideClick)) {\n        dismissWith(DismissReason.backdrop);\n      }\n    };\n  };\n\n  function _main(userParams) {\n    showWarningsForParams(userParams);\n\n    if (globalState.currentInstance) {\n      globalState.currentInstance._destroy();\n    }\n\n    globalState.currentInstance = this;\n    var innerParams = prepareParams(userParams);\n    setParameters(innerParams);\n    Object.freeze(innerParams); // clear the previous timer\n\n    if (globalState.timeout) {\n      globalState.timeout.stop();\n      delete globalState.timeout;\n    } // clear the restore focus timeout\n\n\n    clearTimeout(globalState.restoreFocusTimeout);\n    var domCache = populateDomCache(this);\n    render(this, innerParams);\n    privateProps.innerParams.set(this, innerParams);\n    return swalPromise(this, domCache, innerParams);\n  }\n\n  var prepareParams = function prepareParams(userParams) {\n    var showClass = _extends({}, defaultParams.showClass, userParams.showClass);\n\n    var hideClass = _extends({}, defaultParams.hideClass, userParams.hideClass);\n\n    var params = _extends({}, defaultParams, userParams);\n\n    params.showClass = showClass;\n    params.hideClass = hideClass; // @deprecated\n\n    if (userParams.animation === false) {\n      params.showClass = {\n        popup: 'swal2-noanimation',\n        backdrop: 'swal2-noanimation'\n      };\n      params.hideClass = {};\n    }\n\n    return params;\n  };\n\n  var swalPromise = function swalPromise(instance, domCache, innerParams) {\n    return new Promise(function (resolve) {\n      // functions to handle all closings/dismissals\n      var dismissWith = function dismissWith(dismiss) {\n        instance.closePopup({\n          dismiss: dismiss\n        });\n      };\n\n      privateMethods.swalPromiseResolve.set(instance, resolve);\n\n      domCache.confirmButton.onclick = function () {\n        return handleConfirmButtonClick(instance, innerParams);\n      };\n\n      domCache.cancelButton.onclick = function () {\n        return handleCancelButtonClick(instance, dismissWith);\n      };\n\n      domCache.closeButton.onclick = function () {\n        return dismissWith(DismissReason.close);\n      };\n\n      handlePopupClick(instance, domCache, dismissWith);\n      addKeydownHandler(instance, globalState, innerParams, dismissWith);\n\n      if (innerParams.toast && (innerParams.input || innerParams.footer || innerParams.showCloseButton)) {\n        addClass(document.body, swalClasses['toast-column']);\n      } else {\n        removeClass(document.body, swalClasses['toast-column']);\n      }\n\n      handleInputOptionsAndValue(instance, innerParams);\n      openPopup(innerParams);\n      setupTimer(globalState, innerParams, dismissWith);\n      initFocus(domCache, innerParams); // Scroll container to top on open (#1247, #1946)\n\n      setTimeout(function () {\n        domCache.container.scrollTop = 0;\n      });\n    });\n  };\n\n  var populateDomCache = function populateDomCache(instance) {\n    var domCache = {\n      popup: getPopup(),\n      container: getContainer(),\n      content: getContent(),\n      actions: getActions(),\n      confirmButton: getConfirmButton(),\n      cancelButton: getCancelButton(),\n      closeButton: getCloseButton(),\n      validationMessage: getValidationMessage(),\n      progressSteps: getProgressSteps()\n    };\n    privateProps.domCache.set(instance, domCache);\n    return domCache;\n  };\n\n  var setupTimer = function setupTimer(globalState$$1, innerParams, dismissWith) {\n    var timerProgressBar = getTimerProgressBar();\n    hide(timerProgressBar);\n\n    if (innerParams.timer) {\n      globalState$$1.timeout = new Timer(function () {\n        dismissWith('timer');\n        delete globalState$$1.timeout;\n      }, innerParams.timer);\n\n      if (innerParams.timerProgressBar) {\n        show(timerProgressBar);\n        setTimeout(function () {\n          if (globalState$$1.timeout.running) {\n            // timer can be already stopped at this point\n            animateTimerProgressBar(innerParams.timer);\n          }\n        });\n      }\n    }\n  };\n\n  var initFocus = function initFocus(domCache, innerParams) {\n    if (innerParams.toast) {\n      return;\n    }\n\n    if (!callIfFunction(innerParams.allowEnterKey)) {\n      return blurActiveElement();\n    }\n\n    if (innerParams.focusCancel && isVisible(domCache.cancelButton)) {\n      return domCache.cancelButton.focus();\n    }\n\n    if (innerParams.focusConfirm && isVisible(domCache.confirmButton)) {\n      return domCache.confirmButton.focus();\n    }\n\n    setFocus(innerParams, -1, 1);\n  };\n\n  var blurActiveElement = function blurActiveElement() {\n    if (document.activeElement && typeof document.activeElement.blur === 'function') {\n      document.activeElement.blur();\n    }\n  };\n\n  /**\n   * Updates popup parameters.\n   */\n\n  function update(params) {\n    var popup = getPopup();\n    var innerParams = privateProps.innerParams.get(this);\n\n    if (!popup || hasClass(popup, innerParams.hideClass.popup)) {\n      return warn(\"You're trying to update the closed or closing popup, that won't work. Use the update() method in preConfirm parameter or show a new popup.\");\n    }\n\n    var validUpdatableParams = {}; // assign valid params from `params` to `defaults`\n\n    Object.keys(params).forEach(function (param) {\n      if (Swal.isUpdatableParameter(param)) {\n        validUpdatableParams[param] = params[param];\n      } else {\n        warn(\"Invalid parameter to update: \\\"\".concat(param, \"\\\". Updatable params are listed here: https://github.com/sweetalert2/sweetalert2/blob/master/src/utils/params.js\"));\n      }\n    });\n\n    var updatedParams = _extends({}, innerParams, validUpdatableParams);\n\n    render(this, updatedParams);\n    privateProps.innerParams.set(this, updatedParams);\n    Object.defineProperties(this, {\n      params: {\n        value: _extends({}, this.params, params),\n        writable: false,\n        enumerable: true\n      }\n    });\n  }\n\n  function _destroy() {\n    var domCache = privateProps.domCache.get(this);\n    var innerParams = privateProps.innerParams.get(this);\n\n    if (!innerParams) {\n      return; // This instance has already been destroyed\n    } // Check if there is another Swal closing\n\n\n    if (domCache.popup && globalState.swalCloseEventFinishedCallback) {\n      globalState.swalCloseEventFinishedCallback();\n      delete globalState.swalCloseEventFinishedCallback;\n    } // Check if there is a swal disposal defer timer\n\n\n    if (globalState.deferDisposalTimer) {\n      clearTimeout(globalState.deferDisposalTimer);\n      delete globalState.deferDisposalTimer;\n    }\n\n    if (typeof innerParams.onDestroy === 'function') {\n      innerParams.onDestroy();\n    }\n\n    disposeSwal(this);\n  }\n\n  var disposeSwal = function disposeSwal(instance) {\n    // Unset this.params so GC will dispose it (#1569)\n    delete instance.params; // Unset globalState props so GC will dispose globalState (#1569)\n\n    delete globalState.keydownHandler;\n    delete globalState.keydownTarget; // Unset WeakMaps so GC will be able to dispose them (#1569)\n\n    unsetWeakMaps(privateProps);\n    unsetWeakMaps(privateMethods);\n  };\n\n  var unsetWeakMaps = function unsetWeakMaps(obj) {\n    for (var i in obj) {\n      obj[i] = new WeakMap();\n    }\n  };\n\n\n\n  var instanceMethods = /*#__PURE__*/Object.freeze({\n    hideLoading: hideLoading,\n    disableLoading: hideLoading,\n    getInput: getInput$1,\n    close: close,\n    closePopup: close,\n    closeModal: close,\n    closeToast: close,\n    enableButtons: enableButtons,\n    disableButtons: disableButtons,\n    enableInput: enableInput,\n    disableInput: disableInput,\n    showValidationMessage: showValidationMessage,\n    resetValidationMessage: resetValidationMessage$1,\n    getProgressSteps: getProgressSteps$1,\n    _main: _main,\n    update: update,\n    _destroy: _destroy\n  });\n\n  var currentInstance;\n\n  var SweetAlert = /*#__PURE__*/function () {\n    function SweetAlert() {\n      _classCallCheck(this, SweetAlert);\n\n      // Prevent run in Node env\n      if (typeof window === 'undefined') {\n        return;\n      } // Check for the existence of Promise\n\n\n      if (typeof Promise === 'undefined') {\n        error('This package requires a Promise library, please include a shim to enable it in this browser (See: https://github.com/sweetalert2/sweetalert2/wiki/Migration-from-SweetAlert-to-SweetAlert2#1-ie-support)');\n      }\n\n      currentInstance = this;\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      var outerParams = Object.freeze(this.constructor.argsToParams(args));\n      Object.defineProperties(this, {\n        params: {\n          value: outerParams,\n          writable: false,\n          enumerable: true,\n          configurable: true\n        }\n      });\n\n      var promise = this._main(this.params);\n\n      privateProps.promise.set(this, promise);\n    } // `catch` cannot be the name of a module export, so we define our thenable methods here instead\n\n\n    _createClass(SweetAlert, [{\n      key: \"then\",\n      value: function then(onFulfilled) {\n        var promise = privateProps.promise.get(this);\n        return promise.then(onFulfilled);\n      }\n    }, {\n      key: \"finally\",\n      value: function _finally(onFinally) {\n        var promise = privateProps.promise.get(this);\n        return promise[\"finally\"](onFinally);\n      }\n    }]);\n\n    return SweetAlert;\n  }(); // Assign instance methods from src/instanceMethods/*.js to prototype\n\n\n  _extends(SweetAlert.prototype, instanceMethods); // Assign static methods from src/staticMethods/*.js to constructor\n\n\n  _extends(SweetAlert, staticMethods); // Proxy to instance methods to constructor, for now, for backwards compatibility\n\n\n  Object.keys(instanceMethods).forEach(function (key) {\n    SweetAlert[key] = function () {\n      if (currentInstance) {\n        var _currentInstance;\n\n        return (_currentInstance = currentInstance)[key].apply(_currentInstance, arguments);\n      }\n    };\n  });\n  SweetAlert.DismissReason = DismissReason;\n  SweetAlert.version = '9.17.2';\n\n  var Swal = SweetAlert;\n  Swal[\"default\"] = Swal;\n\n  return Swal;\n\n}));\nif (typeof this !== 'undefined' && this.Sweetalert2){  this.swal = this.sweetAlert = this.Swal = this.SweetAlert = this.Sweetalert2}\n\n\"undefined\"!=typeof document&&function(e,t){var n=e.createElement(\"style\");if(e.getElementsByTagName(\"head\")[0].appendChild(n),n.styleSheet)n.styleSheet.disabled||(n.styleSheet.cssText=t);else try{n.innerHTML=t}catch(e){n.innerText=t}}(document,\".swal2-popup.swal2-toast{flex-direction:row;align-items:center;width:auto;padding:.625em;overflow-y:hidden;background:#fff;box-shadow:0 0 .625em #d9d9d9}.swal2-popup.swal2-toast .swal2-header{flex-direction:row;padding:0}.swal2-popup.swal2-toast .swal2-title{flex-grow:1;justify-content:flex-start;margin:0 .6em;font-size:1em}.swal2-popup.swal2-toast .swal2-footer{margin:.5em 0 0;padding:.5em 0 0;font-size:.8em}.swal2-popup.swal2-toast .swal2-close{position:static;width:.8em;height:.8em;line-height:.8}.swal2-popup.swal2-toast .swal2-content{justify-content:flex-start;padding:0;font-size:1em}.swal2-popup.swal2-toast .swal2-icon{width:2em;min-width:2em;height:2em;margin:0}.swal2-popup.swal2-toast .swal2-icon .swal2-icon-content{display:flex;align-items:center;font-size:1.8em;font-weight:700}@media all and (-ms-high-contrast:none),(-ms-high-contrast:active){.swal2-popup.swal2-toast .swal2-icon .swal2-icon-content{font-size:.25em}}.swal2-popup.swal2-toast .swal2-icon.swal2-success .swal2-success-ring{width:2em;height:2em}.swal2-popup.swal2-toast .swal2-icon.swal2-error [class^=swal2-x-mark-line]{top:.875em;width:1.375em}.swal2-popup.swal2-toast .swal2-icon.swal2-error [class^=swal2-x-mark-line][class$=left]{left:.3125em}.swal2-popup.swal2-toast .swal2-icon.swal2-error [class^=swal2-x-mark-line][class$=right]{right:.3125em}.swal2-popup.swal2-toast .swal2-actions{flex-basis:auto!important;width:auto;height:auto;margin:0 .3125em}.swal2-popup.swal2-toast .swal2-styled{margin:0 .3125em;padding:.3125em .625em;font-size:1em}.swal2-popup.swal2-toast .swal2-styled:focus{box-shadow:0 0 0 1px #fff,0 0 0 3px rgba(50,100,150,.4)}.swal2-popup.swal2-toast .swal2-success{border-color:#a5dc86}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-circular-line]{position:absolute;width:1.6em;height:3em;transform:rotate(45deg);border-radius:50%}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-circular-line][class$=left]{top:-.8em;left:-.5em;transform:rotate(-45deg);transform-origin:2em 2em;border-radius:4em 0 0 4em}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-circular-line][class$=right]{top:-.25em;left:.9375em;transform-origin:0 1.5em;border-radius:0 4em 4em 0}.swal2-popup.swal2-toast .swal2-success .swal2-success-ring{width:2em;height:2em}.swal2-popup.swal2-toast .swal2-success .swal2-success-fix{top:0;left:.4375em;width:.4375em;height:2.6875em}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-line]{height:.3125em}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-line][class$=tip]{top:1.125em;left:.1875em;width:.75em}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-line][class$=long]{top:.9375em;right:.1875em;width:1.375em}.swal2-popup.swal2-toast .swal2-success.swal2-icon-show .swal2-success-line-tip{-webkit-animation:swal2-toast-animate-success-line-tip .75s;animation:swal2-toast-animate-success-line-tip .75s}.swal2-popup.swal2-toast .swal2-success.swal2-icon-show .swal2-success-line-long{-webkit-animation:swal2-toast-animate-success-line-long .75s;animation:swal2-toast-animate-success-line-long .75s}.swal2-popup.swal2-toast.swal2-show{-webkit-animation:swal2-toast-show .5s;animation:swal2-toast-show .5s}.swal2-popup.swal2-toast.swal2-hide{-webkit-animation:swal2-toast-hide .1s forwards;animation:swal2-toast-hide .1s forwards}.swal2-container{display:flex;position:fixed;z-index:1060;top:0;right:0;bottom:0;left:0;flex-direction:row;align-items:center;justify-content:center;padding:.625em;overflow-x:hidden;transition:background-color .1s;-webkit-overflow-scrolling:touch}.swal2-container.swal2-backdrop-show,.swal2-container.swal2-noanimation{background:rgba(0,0,0,.4)}.swal2-container.swal2-backdrop-hide{background:0 0!important}.swal2-container.swal2-top{align-items:flex-start}.swal2-container.swal2-top-left,.swal2-container.swal2-top-start{align-items:flex-start;justify-content:flex-start}.swal2-container.swal2-top-end,.swal2-container.swal2-top-right{align-items:flex-start;justify-content:flex-end}.swal2-container.swal2-center{align-items:center}.swal2-container.swal2-center-left,.swal2-container.swal2-center-start{align-items:center;justify-content:flex-start}.swal2-container.swal2-center-end,.swal2-container.swal2-center-right{align-items:center;justify-content:flex-end}.swal2-container.swal2-bottom{align-items:flex-end}.swal2-container.swal2-bottom-left,.swal2-container.swal2-bottom-start{align-items:flex-end;justify-content:flex-start}.swal2-container.swal2-bottom-end,.swal2-container.swal2-bottom-right{align-items:flex-end;justify-content:flex-end}.swal2-container.swal2-bottom-end>:first-child,.swal2-container.swal2-bottom-left>:first-child,.swal2-container.swal2-bottom-right>:first-child,.swal2-container.swal2-bottom-start>:first-child,.swal2-container.swal2-bottom>:first-child{margin-top:auto}.swal2-container.swal2-grow-fullscreen>.swal2-modal{display:flex!important;flex:1;align-self:stretch;justify-content:center}.swal2-container.swal2-grow-row>.swal2-modal{display:flex!important;flex:1;align-content:center;justify-content:center}.swal2-container.swal2-grow-column{flex:1;flex-direction:column}.swal2-container.swal2-grow-column.swal2-bottom,.swal2-container.swal2-grow-column.swal2-center,.swal2-container.swal2-grow-column.swal2-top{align-items:center}.swal2-container.swal2-grow-column.swal2-bottom-left,.swal2-container.swal2-grow-column.swal2-bottom-start,.swal2-container.swal2-grow-column.swal2-center-left,.swal2-container.swal2-grow-column.swal2-center-start,.swal2-container.swal2-grow-column.swal2-top-left,.swal2-container.swal2-grow-column.swal2-top-start{align-items:flex-start}.swal2-container.swal2-grow-column.swal2-bottom-end,.swal2-container.swal2-grow-column.swal2-bottom-right,.swal2-container.swal2-grow-column.swal2-center-end,.swal2-container.swal2-grow-column.swal2-center-right,.swal2-container.swal2-grow-column.swal2-top-end,.swal2-container.swal2-grow-column.swal2-top-right{align-items:flex-end}.swal2-container.swal2-grow-column>.swal2-modal{display:flex!important;flex:1;align-content:center;justify-content:center}.swal2-container.swal2-no-transition{transition:none!important}.swal2-container:not(.swal2-top):not(.swal2-top-start):not(.swal2-top-end):not(.swal2-top-left):not(.swal2-top-right):not(.swal2-center-start):not(.swal2-center-end):not(.swal2-center-left):not(.swal2-center-right):not(.swal2-bottom):not(.swal2-bottom-start):not(.swal2-bottom-end):not(.swal2-bottom-left):not(.swal2-bottom-right):not(.swal2-grow-fullscreen)>.swal2-modal{margin:auto}@media all and (-ms-high-contrast:none),(-ms-high-contrast:active){.swal2-container .swal2-modal{margin:0!important}}.swal2-popup{display:none;position:relative;box-sizing:border-box;flex-direction:column;justify-content:center;width:32em;max-width:100%;padding:1.25em;border:none;border-radius:.3125em;background:#fff;font-family:inherit;font-size:1rem}.swal2-popup:focus{outline:0}.swal2-popup.swal2-loading{overflow-y:hidden}.swal2-header{display:flex;flex-direction:column;align-items:center;padding:0 1.8em}.swal2-title{position:relative;max-width:100%;margin:0 0 .4em;padding:0;color:#595959;font-size:1.875em;font-weight:600;text-align:center;text-transform:none;word-wrap:break-word}.swal2-actions{display:flex;z-index:1;flex-wrap:wrap;align-items:center;justify-content:center;width:100%;margin:1.25em auto 0}.swal2-actions:not(.swal2-loading) .swal2-styled[disabled]{opacity:.4}.swal2-actions:not(.swal2-loading) .swal2-styled:hover{background-image:linear-gradient(rgba(0,0,0,.1),rgba(0,0,0,.1))}.swal2-actions:not(.swal2-loading) .swal2-styled:active{background-image:linear-gradient(rgba(0,0,0,.2),rgba(0,0,0,.2))}.swal2-actions.swal2-loading .swal2-styled.swal2-confirm{box-sizing:border-box;width:2.5em;height:2.5em;margin:.46875em;padding:0;-webkit-animation:swal2-rotate-loading 1.5s linear 0s infinite normal;animation:swal2-rotate-loading 1.5s linear 0s infinite normal;border:.25em solid transparent;border-radius:100%;border-color:transparent;background-color:transparent!important;color:transparent!important;cursor:default;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.swal2-actions.swal2-loading .swal2-styled.swal2-cancel{margin-right:30px;margin-left:30px}.swal2-actions.swal2-loading :not(.swal2-styled).swal2-confirm::after{content:\\\"\\\";display:inline-block;width:15px;height:15px;margin-left:5px;-webkit-animation:swal2-rotate-loading 1.5s linear 0s infinite normal;animation:swal2-rotate-loading 1.5s linear 0s infinite normal;border:3px solid #999;border-radius:50%;border-right-color:transparent;box-shadow:1px 1px 1px #fff}.swal2-styled{margin:.3125em;padding:.625em 2em;box-shadow:none;font-weight:500}.swal2-styled:not([disabled]){cursor:pointer}.swal2-styled.swal2-confirm{border:0;border-radius:.25em;background:initial;background-color:#3085d6;color:#fff;font-size:1.0625em}.swal2-styled.swal2-cancel{border:0;border-radius:.25em;background:initial;background-color:#aaa;color:#fff;font-size:1.0625em}.swal2-styled:focus{outline:0;box-shadow:0 0 0 1px #fff,0 0 0 3px rgba(50,100,150,.4)}.swal2-styled::-moz-focus-inner{border:0}.swal2-footer{justify-content:center;margin:1.25em 0 0;padding:1em 0 0;border-top:1px solid #eee;color:#545454;font-size:1em}.swal2-timer-progress-bar-container{position:absolute;right:0;bottom:0;left:0;height:.25em;overflow:hidden;border-bottom-right-radius:.3125em;border-bottom-left-radius:.3125em}.swal2-timer-progress-bar{width:100%;height:.25em;background:rgba(0,0,0,.2)}.swal2-image{max-width:100%;margin:1.25em auto}.swal2-close{position:absolute;z-index:2;top:0;right:0;align-items:center;justify-content:center;width:1.2em;height:1.2em;padding:0;overflow:hidden;transition:color .1s ease-out;border:none;border-radius:0;background:0 0;color:#ccc;font-family:serif;font-size:2.5em;line-height:1.2;cursor:pointer}.swal2-close:hover{transform:none;background:0 0;color:#f27474}.swal2-close::-moz-focus-inner{border:0}.swal2-content{z-index:1;justify-content:center;margin:0;padding:0 1.6em;color:#545454;font-size:1.125em;font-weight:400;line-height:normal;text-align:center;word-wrap:break-word}.swal2-checkbox,.swal2-file,.swal2-input,.swal2-radio,.swal2-select,.swal2-textarea{margin:1em auto}.swal2-file,.swal2-input,.swal2-textarea{box-sizing:border-box;width:100%;transition:border-color .3s,box-shadow .3s;border:1px solid #d9d9d9;border-radius:.1875em;background:inherit;box-shadow:inset 0 1px 1px rgba(0,0,0,.06);color:inherit;font-size:1.125em}.swal2-file.swal2-inputerror,.swal2-input.swal2-inputerror,.swal2-textarea.swal2-inputerror{border-color:#f27474!important;box-shadow:0 0 2px #f27474!important}.swal2-file:focus,.swal2-input:focus,.swal2-textarea:focus{border:1px solid #b4dbed;outline:0;box-shadow:0 0 3px #c4e6f5}.swal2-file::-moz-placeholder,.swal2-input::-moz-placeholder,.swal2-textarea::-moz-placeholder{color:#ccc}.swal2-file:-ms-input-placeholder,.swal2-input:-ms-input-placeholder,.swal2-textarea:-ms-input-placeholder{color:#ccc}.swal2-file::-ms-input-placeholder,.swal2-input::-ms-input-placeholder,.swal2-textarea::-ms-input-placeholder{color:#ccc}.swal2-file::placeholder,.swal2-input::placeholder,.swal2-textarea::placeholder{color:#ccc}.swal2-range{margin:1em auto;background:#fff}.swal2-range input{width:80%}.swal2-range output{width:20%;color:inherit;font-weight:600;text-align:center}.swal2-range input,.swal2-range output{height:2.625em;padding:0;font-size:1.125em;line-height:2.625em}.swal2-input{height:2.625em;padding:0 .75em}.swal2-input[type=number]{max-width:10em}.swal2-file{background:inherit;font-size:1.125em}.swal2-textarea{height:6.75em;padding:.75em}.swal2-select{min-width:50%;max-width:100%;padding:.375em .625em;background:inherit;color:inherit;font-size:1.125em}.swal2-checkbox,.swal2-radio{align-items:center;justify-content:center;background:#fff;color:inherit}.swal2-checkbox label,.swal2-radio label{margin:0 .6em;font-size:1.125em}.swal2-checkbox input,.swal2-radio input{margin:0 .4em}.swal2-validation-message{display:none;align-items:center;justify-content:center;padding:.625em;overflow:hidden;background:#f0f0f0;color:#666;font-size:1em;font-weight:300}.swal2-validation-message::before{content:\\\"!\\\";display:inline-block;width:1.5em;min-width:1.5em;height:1.5em;margin:0 .625em;border-radius:50%;background-color:#f27474;color:#fff;font-weight:600;line-height:1.5em;text-align:center}.swal2-icon{position:relative;box-sizing:content-box;justify-content:center;width:5em;height:5em;margin:1.25em auto 1.875em;border:.25em solid transparent;border-radius:50%;font-family:inherit;line-height:5em;cursor:default;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.swal2-icon .swal2-icon-content{display:flex;align-items:center;font-size:3.75em}.swal2-icon.swal2-error{border-color:#f27474;color:#f27474}.swal2-icon.swal2-error .swal2-x-mark{position:relative;flex-grow:1}.swal2-icon.swal2-error [class^=swal2-x-mark-line]{display:block;position:absolute;top:2.3125em;width:2.9375em;height:.3125em;border-radius:.125em;background-color:#f27474}.swal2-icon.swal2-error [class^=swal2-x-mark-line][class$=left]{left:1.0625em;transform:rotate(45deg)}.swal2-icon.swal2-error [class^=swal2-x-mark-line][class$=right]{right:1em;transform:rotate(-45deg)}.swal2-icon.swal2-error.swal2-icon-show{-webkit-animation:swal2-animate-error-icon .5s;animation:swal2-animate-error-icon .5s}.swal2-icon.swal2-error.swal2-icon-show .swal2-x-mark{-webkit-animation:swal2-animate-error-x-mark .5s;animation:swal2-animate-error-x-mark .5s}.swal2-icon.swal2-warning{border-color:#facea8;color:#f8bb86}.swal2-icon.swal2-info{border-color:#9de0f6;color:#3fc3ee}.swal2-icon.swal2-question{border-color:#c9dae1;color:#87adbd}.swal2-icon.swal2-success{border-color:#a5dc86;color:#a5dc86}.swal2-icon.swal2-success [class^=swal2-success-circular-line]{position:absolute;width:3.75em;height:7.5em;transform:rotate(45deg);border-radius:50%}.swal2-icon.swal2-success [class^=swal2-success-circular-line][class$=left]{top:-.4375em;left:-2.0635em;transform:rotate(-45deg);transform-origin:3.75em 3.75em;border-radius:7.5em 0 0 7.5em}.swal2-icon.swal2-success [class^=swal2-success-circular-line][class$=right]{top:-.6875em;left:1.875em;transform:rotate(-45deg);transform-origin:0 3.75em;border-radius:0 7.5em 7.5em 0}.swal2-icon.swal2-success .swal2-success-ring{position:absolute;z-index:2;top:-.25em;left:-.25em;box-sizing:content-box;width:100%;height:100%;border:.25em solid rgba(165,220,134,.3);border-radius:50%}.swal2-icon.swal2-success .swal2-success-fix{position:absolute;z-index:1;top:.5em;left:1.625em;width:.4375em;height:5.625em;transform:rotate(-45deg)}.swal2-icon.swal2-success [class^=swal2-success-line]{display:block;position:absolute;z-index:2;height:.3125em;border-radius:.125em;background-color:#a5dc86}.swal2-icon.swal2-success [class^=swal2-success-line][class$=tip]{top:2.875em;left:.8125em;width:1.5625em;transform:rotate(45deg)}.swal2-icon.swal2-success [class^=swal2-success-line][class$=long]{top:2.375em;right:.5em;width:2.9375em;transform:rotate(-45deg)}.swal2-icon.swal2-success.swal2-icon-show .swal2-success-line-tip{-webkit-animation:swal2-animate-success-line-tip .75s;animation:swal2-animate-success-line-tip .75s}.swal2-icon.swal2-success.swal2-icon-show .swal2-success-line-long{-webkit-animation:swal2-animate-success-line-long .75s;animation:swal2-animate-success-line-long .75s}.swal2-icon.swal2-success.swal2-icon-show .swal2-success-circular-line-right{-webkit-animation:swal2-rotate-success-circular-line 4.25s ease-in;animation:swal2-rotate-success-circular-line 4.25s ease-in}.swal2-progress-steps{align-items:center;margin:0 0 1.25em;padding:0;background:inherit;font-weight:600}.swal2-progress-steps li{display:inline-block;position:relative}.swal2-progress-steps .swal2-progress-step{z-index:20;width:2em;height:2em;border-radius:2em;background:#3085d6;color:#fff;line-height:2em;text-align:center}.swal2-progress-steps .swal2-progress-step.swal2-active-progress-step{background:#3085d6}.swal2-progress-steps .swal2-progress-step.swal2-active-progress-step~.swal2-progress-step{background:#add8e6;color:#fff}.swal2-progress-steps .swal2-progress-step.swal2-active-progress-step~.swal2-progress-step-line{background:#add8e6}.swal2-progress-steps .swal2-progress-step-line{z-index:10;width:2.5em;height:.4em;margin:0 -1px;background:#3085d6}[class^=swal2]{-webkit-tap-highlight-color:transparent}.swal2-show{-webkit-animation:swal2-show .3s;animation:swal2-show .3s}.swal2-hide{-webkit-animation:swal2-hide .15s forwards;animation:swal2-hide .15s forwards}.swal2-noanimation{transition:none}.swal2-scrollbar-measure{position:absolute;top:-9999px;width:50px;height:50px;overflow:scroll}.swal2-rtl .swal2-close{right:auto;left:0}.swal2-rtl .swal2-timer-progress-bar{right:0;left:auto}@supports (-ms-accelerator:true){.swal2-range input{width:100%!important}.swal2-range output{display:none}}@media all and (-ms-high-contrast:none),(-ms-high-contrast:active){.swal2-range input{width:100%!important}.swal2-range output{display:none}}@-moz-document url-prefix(){.swal2-close:focus{outline:2px solid rgba(50,100,150,.4)}}@-webkit-keyframes swal2-toast-show{0%{transform:translateY(-.625em) rotateZ(2deg)}33%{transform:translateY(0) rotateZ(-2deg)}66%{transform:translateY(.3125em) rotateZ(2deg)}100%{transform:translateY(0) rotateZ(0)}}@keyframes swal2-toast-show{0%{transform:translateY(-.625em) rotateZ(2deg)}33%{transform:translateY(0) rotateZ(-2deg)}66%{transform:translateY(.3125em) rotateZ(2deg)}100%{transform:translateY(0) rotateZ(0)}}@-webkit-keyframes swal2-toast-hide{100%{transform:rotateZ(1deg);opacity:0}}@keyframes swal2-toast-hide{100%{transform:rotateZ(1deg);opacity:0}}@-webkit-keyframes swal2-toast-animate-success-line-tip{0%{top:.5625em;left:.0625em;width:0}54%{top:.125em;left:.125em;width:0}70%{top:.625em;left:-.25em;width:1.625em}84%{top:1.0625em;left:.75em;width:.5em}100%{top:1.125em;left:.1875em;width:.75em}}@keyframes swal2-toast-animate-success-line-tip{0%{top:.5625em;left:.0625em;width:0}54%{top:.125em;left:.125em;width:0}70%{top:.625em;left:-.25em;width:1.625em}84%{top:1.0625em;left:.75em;width:.5em}100%{top:1.125em;left:.1875em;width:.75em}}@-webkit-keyframes swal2-toast-animate-success-line-long{0%{top:1.625em;right:1.375em;width:0}65%{top:1.25em;right:.9375em;width:0}84%{top:.9375em;right:0;width:1.125em}100%{top:.9375em;right:.1875em;width:1.375em}}@keyframes swal2-toast-animate-success-line-long{0%{top:1.625em;right:1.375em;width:0}65%{top:1.25em;right:.9375em;width:0}84%{top:.9375em;right:0;width:1.125em}100%{top:.9375em;right:.1875em;width:1.375em}}@-webkit-keyframes swal2-show{0%{transform:scale(.7)}45%{transform:scale(1.05)}80%{transform:scale(.95)}100%{transform:scale(1)}}@keyframes swal2-show{0%{transform:scale(.7)}45%{transform:scale(1.05)}80%{transform:scale(.95)}100%{transform:scale(1)}}@-webkit-keyframes swal2-hide{0%{transform:scale(1);opacity:1}100%{transform:scale(.5);opacity:0}}@keyframes swal2-hide{0%{transform:scale(1);opacity:1}100%{transform:scale(.5);opacity:0}}@-webkit-keyframes swal2-animate-success-line-tip{0%{top:1.1875em;left:.0625em;width:0}54%{top:1.0625em;left:.125em;width:0}70%{top:2.1875em;left:-.375em;width:3.125em}84%{top:3em;left:1.3125em;width:1.0625em}100%{top:2.8125em;left:.8125em;width:1.5625em}}@keyframes swal2-animate-success-line-tip{0%{top:1.1875em;left:.0625em;width:0}54%{top:1.0625em;left:.125em;width:0}70%{top:2.1875em;left:-.375em;width:3.125em}84%{top:3em;left:1.3125em;width:1.0625em}100%{top:2.8125em;left:.8125em;width:1.5625em}}@-webkit-keyframes swal2-animate-success-line-long{0%{top:3.375em;right:2.875em;width:0}65%{top:3.375em;right:2.875em;width:0}84%{top:2.1875em;right:0;width:3.4375em}100%{top:2.375em;right:.5em;width:2.9375em}}@keyframes swal2-animate-success-line-long{0%{top:3.375em;right:2.875em;width:0}65%{top:3.375em;right:2.875em;width:0}84%{top:2.1875em;right:0;width:3.4375em}100%{top:2.375em;right:.5em;width:2.9375em}}@-webkit-keyframes swal2-rotate-success-circular-line{0%{transform:rotate(-45deg)}5%{transform:rotate(-45deg)}12%{transform:rotate(-405deg)}100%{transform:rotate(-405deg)}}@keyframes swal2-rotate-success-circular-line{0%{transform:rotate(-45deg)}5%{transform:rotate(-45deg)}12%{transform:rotate(-405deg)}100%{transform:rotate(-405deg)}}@-webkit-keyframes swal2-animate-error-x-mark{0%{margin-top:1.625em;transform:scale(.4);opacity:0}50%{margin-top:1.625em;transform:scale(.4);opacity:0}80%{margin-top:-.375em;transform:scale(1.15)}100%{margin-top:0;transform:scale(1);opacity:1}}@keyframes swal2-animate-error-x-mark{0%{margin-top:1.625em;transform:scale(.4);opacity:0}50%{margin-top:1.625em;transform:scale(.4);opacity:0}80%{margin-top:-.375em;transform:scale(1.15)}100%{margin-top:0;transform:scale(1);opacity:1}}@-webkit-keyframes swal2-animate-error-icon{0%{transform:rotateX(100deg);opacity:0}100%{transform:rotateX(0);opacity:1}}@keyframes swal2-animate-error-icon{0%{transform:rotateX(100deg);opacity:0}100%{transform:rotateX(0);opacity:1}}@-webkit-keyframes swal2-rotate-loading{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}@keyframes swal2-rotate-loading{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}body.swal2-shown:not(.swal2-no-backdrop):not(.swal2-toast-shown){overflow:hidden}body.swal2-height-auto{height:auto!important}body.swal2-no-backdrop .swal2-container{top:auto;right:auto;bottom:auto;left:auto;max-width:calc(100% - .625em * 2);background-color:transparent!important}body.swal2-no-backdrop .swal2-container>.swal2-modal{box-shadow:0 0 10px rgba(0,0,0,.4)}body.swal2-no-backdrop .swal2-container.swal2-top{top:0;left:50%;transform:translateX(-50%)}body.swal2-no-backdrop .swal2-container.swal2-top-left,body.swal2-no-backdrop .swal2-container.swal2-top-start{top:0;left:0}body.swal2-no-backdrop .swal2-container.swal2-top-end,body.swal2-no-backdrop .swal2-container.swal2-top-right{top:0;right:0}body.swal2-no-backdrop .swal2-container.swal2-center{top:50%;left:50%;transform:translate(-50%,-50%)}body.swal2-no-backdrop .swal2-container.swal2-center-left,body.swal2-no-backdrop .swal2-container.swal2-center-start{top:50%;left:0;transform:translateY(-50%)}body.swal2-no-backdrop .swal2-container.swal2-center-end,body.swal2-no-backdrop .swal2-container.swal2-center-right{top:50%;right:0;transform:translateY(-50%)}body.swal2-no-backdrop .swal2-container.swal2-bottom{bottom:0;left:50%;transform:translateX(-50%)}body.swal2-no-backdrop .swal2-container.swal2-bottom-left,body.swal2-no-backdrop .swal2-container.swal2-bottom-start{bottom:0;left:0}body.swal2-no-backdrop .swal2-container.swal2-bottom-end,body.swal2-no-backdrop .swal2-container.swal2-bottom-right{right:0;bottom:0}@media print{body.swal2-shown:not(.swal2-no-backdrop):not(.swal2-toast-shown){overflow-y:scroll!important}body.swal2-shown:not(.swal2-no-backdrop):not(.swal2-toast-shown)>[aria-hidden=true]{display:none}body.swal2-shown:not(.swal2-no-backdrop):not(.swal2-toast-shown) .swal2-container{position:static!important}}body.swal2-toast-shown .swal2-container{background-color:transparent}body.swal2-toast-shown .swal2-container.swal2-top{top:0;right:auto;bottom:auto;left:50%;transform:translateX(-50%)}body.swal2-toast-shown .swal2-container.swal2-top-end,body.swal2-toast-shown .swal2-container.swal2-top-right{top:0;right:0;bottom:auto;left:auto}body.swal2-toast-shown .swal2-container.swal2-top-left,body.swal2-toast-shown .swal2-container.swal2-top-start{top:0;right:auto;bottom:auto;left:0}body.swal2-toast-shown .swal2-container.swal2-center-left,body.swal2-toast-shown .swal2-container.swal2-center-start{top:50%;right:auto;bottom:auto;left:0;transform:translateY(-50%)}body.swal2-toast-shown .swal2-container.swal2-center{top:50%;right:auto;bottom:auto;left:50%;transform:translate(-50%,-50%)}body.swal2-toast-shown .swal2-container.swal2-center-end,body.swal2-toast-shown .swal2-container.swal2-center-right{top:50%;right:0;bottom:auto;left:auto;transform:translateY(-50%)}body.swal2-toast-shown .swal2-container.swal2-bottom-left,body.swal2-toast-shown .swal2-container.swal2-bottom-start{top:auto;right:auto;bottom:0;left:0}body.swal2-toast-shown .swal2-container.swal2-bottom{top:auto;right:auto;bottom:0;left:50%;transform:translateX(-50%)}body.swal2-toast-shown .swal2-container.swal2-bottom-end,body.swal2-toast-shown .swal2-container.swal2-bottom-right{top:auto;right:0;bottom:0;left:auto}body.swal2-toast-column .swal2-toast{flex-direction:column;align-items:stretch}body.swal2-toast-column .swal2-toast .swal2-actions{flex:1;align-self:stretch;height:2.2em;margin-top:.3125em}body.swal2-toast-column .swal2-toast .swal2-loading{justify-content:center}body.swal2-toast-column .swal2-toast .swal2-input{height:2em;margin:.3125em auto;font-size:1em}body.swal2-toast-column .swal2-toast .swal2-validation-message{font-size:1em}\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3dlZXRhbGVydDIvZGlzdC9zd2VldGFsZXJ0Mi5hbGwuanM/M2QyMCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxLQUE0RDtBQUM5RCxFQUFFLFNBQ3lEO0FBQzNELENBQUMsb0JBQW9COztBQUVyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCLHNCQUFzQjtBQUMzQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2RUFBNkU7QUFDN0U7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQixnQkFBZ0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCOztBQUVsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDRCQUE0QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQyxLQUFLO0FBQ0wsa0NBQWtDO0FBQ2xDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixhQUFhO0FBQ2xDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUNBQXlDOztBQUV6QztBQUNBO0FBQ0EsS0FBSzs7O0FBR0wsaURBQWlEOztBQUVqRCxtREFBbUQ7O0FBRW5EOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnRUFBZ0U7O0FBRWhFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzRUFBc0U7O0FBRXRFLHdGQUF3RjtBQUN4Rjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBNEM7O0FBRTVDLHFEQUFxRDs7QUFFckQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFOztBQUVoRSx1REFBdUQ7O0FBRXZEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxtQkFBbUIsNkJBQTZCO0FBQ2hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw4RUFBOEU7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QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0wseUNBQXlDO0FBQ3pDOztBQUVBO0FBQ0EsbUNBQW1DOztBQUVuQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLG1CQUFtQjtBQUN4QztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLDZEQUE2RCxLQUFLO0FBQ2xFLEtBQUs7QUFDTDtBQUNBO0FBQ0Esd0RBQXdELE1BQU0sUUFBUSxLQUFLO0FBQzNFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmOzs7QUFHQTtBQUNBLHNDQUFzQzs7QUFFdEM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0Esd0NBQXdDOztBQUV4QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkNBQTJDOztBQUUzQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCOztBQUVoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DOztBQUVwQztBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBLG1EQUFtRDs7QUFFbkQsbUJBQW1CLDhCQUE4QjtBQUNqRCxnQ0FBZ0M7O0FBRWhDO0FBQ0Esa0JBQWtCO0FBQ2xCLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0EsNENBQTRDO0FBQzVDLEtBQUs7QUFDTCxnQ0FBZ0M7QUFDaEMsS0FBSztBQUNMLHFCQUFxQjtBQUNyQixLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsOEJBQThCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlDQUF5Qzs7QUFFekM7QUFDQSwyQkFBMkI7QUFDM0IsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7O0FBRTdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtCQUErQjs7QUFFL0IsK0JBQStCOztBQUUvQiw0QkFBNEI7O0FBRTVCO0FBQ0EsaUNBQWlDOztBQUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7O0FBRXZDO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDOztBQUVsQztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7O0FBRUwsbUNBQW1DOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQkFBMkI7O0FBRTNCO0FBQ0EscUNBQXFDOztBQUVyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87OztBQUdQO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx5RUFBeUUsYUFBYTtBQUN0RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQOztBQUVBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsR0FBRyxHQUFHOzs7QUFHTixrREFBa0Q7OztBQUdsRCxzQ0FBc0M7OztBQUd0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLENBQUM7QUFDRCxxREFBcUQ7O0FBRXJELDRDQUE0QywrQkFBK0IsaUhBQWlILFNBQVMsY0FBYyxTQUFTLGVBQWUsb0NBQW9DLG1CQUFtQixtQkFBbUIsV0FBVyxlQUFlLGtCQUFrQixnQkFBZ0IsOEJBQThCLHVDQUF1QyxtQkFBbUIsVUFBVSxzQ0FBc0MsWUFBWSwyQkFBMkIsY0FBYyxjQUFjLHVDQUF1QyxnQkFBZ0IsaUJBQWlCLGVBQWUsc0NBQXNDLGdCQUFnQixXQUFXLFlBQVksZUFBZSx3Q0FBd0MsMkJBQTJCLFVBQVUsY0FBYyxxQ0FBcUMsVUFBVSxjQUFjLFdBQVcsU0FBUyx5REFBeUQsYUFBYSxtQkFBbUIsZ0JBQWdCLGdCQUFnQixtRUFBbUUseURBQXlELGlCQUFpQix1RUFBdUUsVUFBVSxXQUFXLDRFQUE0RSxXQUFXLGNBQWMseUZBQXlGLGFBQWEsMEZBQTBGLGNBQWMsd0NBQXdDLDBCQUEwQixXQUFXLFlBQVksaUJBQWlCLHVDQUF1QyxpQkFBaUIsdUJBQXVCLGNBQWMsNkNBQTZDLHdEQUF3RCx3Q0FBd0MscUJBQXFCLDZFQUE2RSxrQkFBa0IsWUFBWSxXQUFXLHdCQUF3QixrQkFBa0IsMEZBQTBGLFVBQVUsV0FBVyx5QkFBeUIseUJBQXlCLDBCQUEwQiwyRkFBMkYsV0FBVyxhQUFhLHlCQUF5QiwwQkFBMEIsNERBQTRELFVBQVUsV0FBVywyREFBMkQsTUFBTSxhQUFhLGNBQWMsZ0JBQWdCLG9FQUFvRSxlQUFlLGdGQUFnRixZQUFZLGFBQWEsWUFBWSxpRkFBaUYsWUFBWSxjQUFjLGNBQWMsZ0ZBQWdGLDREQUE0RCxvREFBb0QsaUZBQWlGLDZEQUE2RCxxREFBcUQsb0NBQW9DLHVDQUF1QywrQkFBK0Isb0NBQW9DLGdEQUFnRCx3Q0FBd0MsaUJBQWlCLGFBQWEsZUFBZSxhQUFhLE1BQU0sUUFBUSxTQUFTLE9BQU8sbUJBQW1CLG1CQUFtQix1QkFBdUIsZUFBZSxrQkFBa0IsZ0NBQWdDLGlDQUFpQyx3RUFBd0UsMEJBQTBCLHFDQUFxQyx5QkFBeUIsMkJBQTJCLHVCQUF1QixpRUFBaUUsdUJBQXVCLDJCQUEyQixnRUFBZ0UsdUJBQXVCLHlCQUF5Qiw4QkFBOEIsbUJBQW1CLHVFQUF1RSxtQkFBbUIsMkJBQTJCLHNFQUFzRSxtQkFBbUIseUJBQXlCLDhCQUE4QixxQkFBcUIsdUVBQXVFLHFCQUFxQiwyQkFBMkIsc0VBQXNFLHFCQUFxQix5QkFBeUIsNE9BQTRPLGdCQUFnQixvREFBb0QsdUJBQXVCLE9BQU8sbUJBQW1CLHVCQUF1Qiw2Q0FBNkMsdUJBQXVCLE9BQU8scUJBQXFCLHVCQUF1QixtQ0FBbUMsT0FBTyxzQkFBc0IsNklBQTZJLG1CQUFtQiwyVEFBMlQsdUJBQXVCLHdUQUF3VCxxQkFBcUIsZ0RBQWdELHVCQUF1QixPQUFPLHFCQUFxQix1QkFBdUIscUNBQXFDLDBCQUEwQixvWEFBb1gsWUFBWSxtRUFBbUUsOEJBQThCLG9CQUFvQixhQUFhLGFBQWEsa0JBQWtCLHNCQUFzQixzQkFBc0IsdUJBQXVCLFdBQVcsZUFBZSxlQUFlLFlBQVksc0JBQXNCLGdCQUFnQixvQkFBb0IsZUFBZSxtQkFBbUIsVUFBVSwyQkFBMkIsa0JBQWtCLGNBQWMsYUFBYSxzQkFBc0IsbUJBQW1CLGdCQUFnQixhQUFhLGtCQUFrQixlQUFlLGdCQUFnQixVQUFVLGNBQWMsa0JBQWtCLGdCQUFnQixrQkFBa0Isb0JBQW9CLHFCQUFxQixlQUFlLGFBQWEsVUFBVSxlQUFlLG1CQUFtQix1QkFBdUIsV0FBVyxxQkFBcUIsMkRBQTJELFdBQVcsdURBQXVELGdFQUFnRSx3REFBd0QsZ0VBQWdFLHlEQUF5RCxzQkFBc0IsWUFBWSxhQUFhLGdCQUFnQixVQUFVLHNFQUFzRSw4REFBOEQsK0JBQStCLG1CQUFtQix5QkFBeUIsdUNBQXVDLDRCQUE0QixlQUFlLHlCQUF5QixzQkFBc0IscUJBQXFCLGlCQUFpQix3REFBd0Qsa0JBQWtCLGlCQUFpQixzRUFBc0UsYUFBYSxxQkFBcUIsV0FBVyxZQUFZLGdCQUFnQixzRUFBc0UsOERBQThELHNCQUFzQixrQkFBa0IsK0JBQStCLDRCQUE0QixjQUFjLGVBQWUsbUJBQW1CLGdCQUFnQixnQkFBZ0IsOEJBQThCLGVBQWUsNEJBQTRCLFNBQVMsb0JBQW9CLG1CQUFtQix5QkFBeUIsV0FBVyxtQkFBbUIsMkJBQTJCLFNBQVMsb0JBQW9CLG1CQUFtQixzQkFBc0IsV0FBVyxtQkFBbUIsb0JBQW9CLFVBQVUsd0RBQXdELGdDQUFnQyxTQUFTLGNBQWMsdUJBQXVCLGtCQUFrQixnQkFBZ0IsMEJBQTBCLGNBQWMsY0FBYyxvQ0FBb0Msa0JBQWtCLFFBQVEsU0FBUyxPQUFPLGFBQWEsZ0JBQWdCLG1DQUFtQyxrQ0FBa0MsMEJBQTBCLFdBQVcsYUFBYSwwQkFBMEIsYUFBYSxlQUFlLG1CQUFtQixhQUFhLGtCQUFrQixVQUFVLE1BQU0sUUFBUSxtQkFBbUIsdUJBQXVCLFlBQVksYUFBYSxVQUFVLGdCQUFnQiw4QkFBOEIsWUFBWSxnQkFBZ0IsZUFBZSxXQUFXLGtCQUFrQixnQkFBZ0IsZ0JBQWdCLGVBQWUsbUJBQW1CLGVBQWUsZUFBZSxjQUFjLCtCQUErQixTQUFTLGVBQWUsVUFBVSx1QkFBdUIsU0FBUyxnQkFBZ0IsY0FBYyxrQkFBa0IsZ0JBQWdCLG1CQUFtQixrQkFBa0IscUJBQXFCLG9GQUFvRixnQkFBZ0IseUNBQXlDLHNCQUFzQixXQUFXLDJDQUEyQyx5QkFBeUIsc0JBQXNCLG1CQUFtQiwyQ0FBMkMsY0FBYyxrQkFBa0IsNEZBQTRGLCtCQUErQixxQ0FBcUMsMkRBQTJELHlCQUF5QixVQUFVLDJCQUEyQiwrRkFBK0YsV0FBVywyR0FBMkcsV0FBVyw4R0FBOEcsV0FBVyxnRkFBZ0YsV0FBVyxhQUFhLGdCQUFnQixnQkFBZ0IsbUJBQW1CLFVBQVUsb0JBQW9CLFVBQVUsY0FBYyxnQkFBZ0Isa0JBQWtCLHVDQUF1QyxlQUFlLFVBQVUsa0JBQWtCLG9CQUFvQixhQUFhLGVBQWUsZ0JBQWdCLDBCQUEwQixlQUFlLFlBQVksbUJBQW1CLGtCQUFrQixnQkFBZ0IsY0FBYyxjQUFjLGNBQWMsY0FBYyxlQUFlLHNCQUFzQixtQkFBbUIsY0FBYyxrQkFBa0IsNkJBQTZCLG1CQUFtQix1QkFBdUIsZ0JBQWdCLGNBQWMseUNBQXlDLGNBQWMsa0JBQWtCLHlDQUF5QyxjQUFjLDBCQUEwQixhQUFhLG1CQUFtQix1QkFBdUIsZUFBZSxnQkFBZ0IsbUJBQW1CLFdBQVcsY0FBYyxnQkFBZ0Isa0NBQWtDLGNBQWMscUJBQXFCLFlBQVksZ0JBQWdCLGFBQWEsZ0JBQWdCLGtCQUFrQix5QkFBeUIsV0FBVyxnQkFBZ0Isa0JBQWtCLGtCQUFrQixZQUFZLGtCQUFrQix1QkFBdUIsdUJBQXVCLFVBQVUsV0FBVywyQkFBMkIsK0JBQStCLGtCQUFrQixvQkFBb0IsZ0JBQWdCLGVBQWUseUJBQXlCLHNCQUFzQixxQkFBcUIsaUJBQWlCLGdDQUFnQyxhQUFhLG1CQUFtQixpQkFBaUIsd0JBQXdCLHFCQUFxQixjQUFjLHNDQUFzQyxrQkFBa0IsWUFBWSxtREFBbUQsY0FBYyxrQkFBa0IsYUFBYSxlQUFlLGVBQWUscUJBQXFCLHlCQUF5QixnRUFBZ0UsY0FBYyx3QkFBd0IsaUVBQWlFLFVBQVUseUJBQXlCLHdDQUF3QywrQ0FBK0MsdUNBQXVDLHNEQUFzRCxpREFBaUQseUNBQXlDLDBCQUEwQixxQkFBcUIsY0FBYyx1QkFBdUIscUJBQXFCLGNBQWMsMkJBQTJCLHFCQUFxQixjQUFjLDBCQUEwQixxQkFBcUIsY0FBYywrREFBK0Qsa0JBQWtCLGFBQWEsYUFBYSx3QkFBd0Isa0JBQWtCLDRFQUE0RSxhQUFhLGVBQWUseUJBQXlCLCtCQUErQiw4QkFBOEIsNkVBQTZFLGFBQWEsYUFBYSx5QkFBeUIsMEJBQTBCLDhCQUE4Qiw4Q0FBOEMsa0JBQWtCLFVBQVUsV0FBVyxZQUFZLHVCQUF1QixXQUFXLFlBQVksd0NBQXdDLGtCQUFrQiw2Q0FBNkMsa0JBQWtCLFVBQVUsU0FBUyxhQUFhLGNBQWMsZUFBZSx5QkFBeUIsc0RBQXNELGNBQWMsa0JBQWtCLFVBQVUsZUFBZSxxQkFBcUIseUJBQXlCLGtFQUFrRSxZQUFZLGFBQWEsZUFBZSx3QkFBd0IsbUVBQW1FLFlBQVksV0FBVyxlQUFlLHlCQUF5QixrRUFBa0Usc0RBQXNELDhDQUE4QyxtRUFBbUUsdURBQXVELCtDQUErQyw2RUFBNkUsbUVBQW1FLDJEQUEyRCxzQkFBc0IsbUJBQW1CLGtCQUFrQixVQUFVLG1CQUFtQixnQkFBZ0IseUJBQXlCLHFCQUFxQixrQkFBa0IsMkNBQTJDLFdBQVcsVUFBVSxXQUFXLGtCQUFrQixtQkFBbUIsV0FBVyxnQkFBZ0Isa0JBQWtCLHNFQUFzRSxtQkFBbUIsMkZBQTJGLG1CQUFtQixXQUFXLGdHQUFnRyxtQkFBbUIsZ0RBQWdELFdBQVcsWUFBWSxZQUFZLGNBQWMsbUJBQW1CLGVBQWUsd0NBQXdDLFlBQVksaUNBQWlDLHlCQUF5QixZQUFZLDJDQUEyQyxtQ0FBbUMsbUJBQW1CLGdCQUFnQix5QkFBeUIsa0JBQWtCLFlBQVksV0FBVyxZQUFZLGdCQUFnQix3QkFBd0IsV0FBVyxPQUFPLHFDQUFxQyxRQUFRLFVBQVUsaUNBQWlDLG1CQUFtQixxQkFBcUIsb0JBQW9CLGNBQWMsbUVBQW1FLG1CQUFtQixxQkFBcUIsb0JBQW9CLGNBQWMsNEJBQTRCLG1CQUFtQix1Q0FBdUMsb0NBQW9DLEdBQUcsNENBQTRDLElBQUksdUNBQXVDLElBQUksNENBQTRDLEtBQUssb0NBQW9DLDRCQUE0QixHQUFHLDRDQUE0QyxJQUFJLHVDQUF1QyxJQUFJLDRDQUE0QyxLQUFLLG9DQUFvQyxvQ0FBb0MsS0FBSyx3QkFBd0IsV0FBVyw0QkFBNEIsS0FBSyx3QkFBd0IsV0FBVyx3REFBd0QsR0FBRyxZQUFZLGFBQWEsUUFBUSxJQUFJLFdBQVcsWUFBWSxRQUFRLElBQUksV0FBVyxZQUFZLGNBQWMsSUFBSSxhQUFhLFdBQVcsV0FBVyxLQUFLLFlBQVksYUFBYSxhQUFhLGdEQUFnRCxHQUFHLFlBQVksYUFBYSxRQUFRLElBQUksV0FBVyxZQUFZLFFBQVEsSUFBSSxXQUFXLFlBQVksY0FBYyxJQUFJLGFBQWEsV0FBVyxXQUFXLEtBQUssWUFBWSxhQUFhLGFBQWEseURBQXlELEdBQUcsWUFBWSxjQUFjLFFBQVEsSUFBSSxXQUFXLGNBQWMsUUFBUSxJQUFJLFlBQVksUUFBUSxjQUFjLEtBQUssWUFBWSxjQUFjLGVBQWUsaURBQWlELEdBQUcsWUFBWSxjQUFjLFFBQVEsSUFBSSxXQUFXLGNBQWMsUUFBUSxJQUFJLFlBQVksUUFBUSxjQUFjLEtBQUssWUFBWSxjQUFjLGVBQWUsOEJBQThCLEdBQUcsb0JBQW9CLElBQUksc0JBQXNCLElBQUkscUJBQXFCLEtBQUssb0JBQW9CLHNCQUFzQixHQUFHLG9CQUFvQixJQUFJLHNCQUFzQixJQUFJLHFCQUFxQixLQUFLLG9CQUFvQiw4QkFBOEIsR0FBRyxtQkFBbUIsVUFBVSxLQUFLLG9CQUFvQixXQUFXLHNCQUFzQixHQUFHLG1CQUFtQixVQUFVLEtBQUssb0JBQW9CLFdBQVcsa0RBQWtELEdBQUcsYUFBYSxhQUFhLFFBQVEsSUFBSSxhQUFhLFlBQVksUUFBUSxJQUFJLGFBQWEsYUFBYSxjQUFjLElBQUksUUFBUSxjQUFjLGVBQWUsS0FBSyxhQUFhLGFBQWEsZ0JBQWdCLDBDQUEwQyxHQUFHLGFBQWEsYUFBYSxRQUFRLElBQUksYUFBYSxZQUFZLFFBQVEsSUFBSSxhQUFhLGFBQWEsY0FBYyxJQUFJLFFBQVEsY0FBYyxlQUFlLEtBQUssYUFBYSxhQUFhLGdCQUFnQixtREFBbUQsR0FBRyxZQUFZLGNBQWMsUUFBUSxJQUFJLFlBQVksY0FBYyxRQUFRLElBQUksYUFBYSxRQUFRLGVBQWUsS0FBSyxZQUFZLFdBQVcsZ0JBQWdCLDJDQUEyQyxHQUFHLFlBQVksY0FBYyxRQUFRLElBQUksWUFBWSxjQUFjLFFBQVEsSUFBSSxhQUFhLFFBQVEsZUFBZSxLQUFLLFlBQVksV0FBVyxnQkFBZ0Isc0RBQXNELEdBQUcseUJBQXlCLEdBQUcseUJBQXlCLElBQUksMEJBQTBCLEtBQUssMkJBQTJCLDhDQUE4QyxHQUFHLHlCQUF5QixHQUFHLHlCQUF5QixJQUFJLDBCQUEwQixLQUFLLDJCQUEyQiw4Q0FBOEMsR0FBRyxtQkFBbUIsb0JBQW9CLFVBQVUsSUFBSSxtQkFBbUIsb0JBQW9CLFVBQVUsSUFBSSxtQkFBbUIsc0JBQXNCLEtBQUssYUFBYSxtQkFBbUIsV0FBVyxzQ0FBc0MsR0FBRyxtQkFBbUIsb0JBQW9CLFVBQVUsSUFBSSxtQkFBbUIsb0JBQW9CLFVBQVUsSUFBSSxtQkFBbUIsc0JBQXNCLEtBQUssYUFBYSxtQkFBbUIsV0FBVyw0Q0FBNEMsR0FBRywwQkFBMEIsVUFBVSxLQUFLLHFCQUFxQixXQUFXLG9DQUFvQyxHQUFHLDBCQUEwQixVQUFVLEtBQUsscUJBQXFCLFdBQVcsd0NBQXdDLEdBQUcsb0JBQW9CLEtBQUssMEJBQTBCLGdDQUFnQyxHQUFHLG9CQUFvQixLQUFLLDBCQUEwQixpRUFBaUUsZ0JBQWdCLHVCQUF1QixzQkFBc0Isd0NBQXdDLFNBQVMsV0FBVyxZQUFZLFVBQVUsa0NBQWtDLHVDQUF1QyxxREFBcUQsbUNBQW1DLGtEQUFrRCxNQUFNLFNBQVMsMkJBQTJCLCtHQUErRyxNQUFNLE9BQU8sOEdBQThHLE1BQU0sUUFBUSxxREFBcUQsUUFBUSxTQUFTLCtCQUErQixxSEFBcUgsUUFBUSxPQUFPLDJCQUEyQixvSEFBb0gsUUFBUSxRQUFRLDJCQUEyQixxREFBcUQsU0FBUyxTQUFTLDJCQUEyQixxSEFBcUgsU0FBUyxPQUFPLG9IQUFvSCxRQUFRLFNBQVMsYUFBYSxpRUFBaUUsNEJBQTRCLG9GQUFvRixhQUFhLGtGQUFrRiwyQkFBMkIsd0NBQXdDLDZCQUE2QixrREFBa0QsTUFBTSxXQUFXLFlBQVksU0FBUywyQkFBMkIsOEdBQThHLE1BQU0sUUFBUSxZQUFZLFVBQVUsK0dBQStHLE1BQU0sV0FBVyxZQUFZLE9BQU8scUhBQXFILFFBQVEsV0FBVyxZQUFZLE9BQU8sMkJBQTJCLHFEQUFxRCxRQUFRLFdBQVcsWUFBWSxTQUFTLCtCQUErQixvSEFBb0gsUUFBUSxRQUFRLFlBQVksVUFBVSwyQkFBMkIscUhBQXFILFNBQVMsV0FBVyxTQUFTLE9BQU8scURBQXFELFNBQVMsV0FBVyxTQUFTLFNBQVMsMkJBQTJCLG9IQUFvSCxTQUFTLFFBQVEsU0FBUyxVQUFVLHFDQUFxQyxzQkFBc0Isb0JBQW9CLG9EQUFvRCxPQUFPLG1CQUFtQixhQUFhLG1CQUFtQixvREFBb0QsdUJBQXVCLGtEQUFrRCxXQUFXLG9CQUFvQixjQUFjLCtEQUErRCxjQUFjIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3N3ZWV0YWxlcnQyL2Rpc3Qvc3dlZXRhbGVydDIuYWxsLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyohXG4qIHN3ZWV0YWxlcnQyIHY5LjE3LjJcbiogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuKi9cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcbiAgKGdsb2JhbCA9IGdsb2JhbCB8fCBzZWxmLCBnbG9iYWwuU3dlZXRhbGVydDIgPSBmYWN0b3J5KCkpO1xufSh0aGlzLCBmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuICBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICAgIGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikge1xuICAgICAgX3R5cGVvZiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBfdHlwZW9mID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIF90eXBlb2Yob2JqKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gIH1cblxuICBmdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgICBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfTtcblxuICAgIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gICAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cblxuICAgIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG4gIH1cblxuICBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICAgIH07XG4gICAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgICByZXR1cm4gbztcbiAgICB9O1xuXG4gICAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTtcblxuICAgIHRyeSB7XG4gICAgICBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFJlZmxlY3QuY29uc3RydWN0KERhdGUsIFtdLCBmdW5jdGlvbiAoKSB7fSkpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykge1xuICAgIGlmIChfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkpIHtcbiAgICAgIF9jb25zdHJ1Y3QgPSBSZWZsZWN0LmNvbnN0cnVjdDtcbiAgICB9IGVsc2Uge1xuICAgICAgX2NvbnN0cnVjdCA9IGZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykge1xuICAgICAgICB2YXIgYSA9IFtudWxsXTtcbiAgICAgICAgYS5wdXNoLmFwcGx5KGEsIGFyZ3MpO1xuICAgICAgICB2YXIgQ29uc3RydWN0b3IgPSBGdW5jdGlvbi5iaW5kLmFwcGx5KFBhcmVudCwgYSk7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IG5ldyBDb25zdHJ1Y3RvcigpO1xuICAgICAgICBpZiAoQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihpbnN0YW5jZSwgQ2xhc3MucHJvdG90eXBlKTtcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gX2NvbnN0cnVjdC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gICAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICAgIH1cblxuICAgIHJldHVybiBzZWxmO1xuICB9XG5cbiAgZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICAgIGlmIChjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgICAgcmV0dXJuIGNhbGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XG4gIH1cblxuICBmdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkge1xuICAgIHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkge1xuICAgICAgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLFxuICAgICAgICAgIHJlc3VsdDtcblxuICAgICAgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHtcbiAgICAgICAgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjtcblxuICAgICAgICByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9zdXBlclByb3BCYXNlKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgICB3aGlsZSAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkge1xuICAgICAgb2JqZWN0ID0gX2dldFByb3RvdHlwZU9mKG9iamVjdCk7XG4gICAgICBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9XG5cbiAgZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBSZWZsZWN0LmdldCkge1xuICAgICAgX2dldCA9IFJlZmxlY3QuZ2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICBfZ2V0ID0gZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikge1xuICAgICAgICB2YXIgYmFzZSA9IF9zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpO1xuXG4gICAgICAgIGlmICghYmFzZSkgcmV0dXJuO1xuICAgICAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpO1xuXG4gICAgICAgIGlmIChkZXNjLmdldCkge1xuICAgICAgICAgIHJldHVybiBkZXNjLmdldC5jYWxsKHJlY2VpdmVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkZXNjLnZhbHVlO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlciB8fCB0YXJnZXQpO1xuICB9XG5cbiAgdmFyIGNvbnNvbGVQcmVmaXggPSAnU3dlZXRBbGVydDI6JztcbiAgLyoqXG4gICAqIEZpbHRlciB0aGUgdW5pcXVlIHZhbHVlcyBpbnRvIGEgbmV3IGFycmF5XG4gICAqIEBwYXJhbSBhcnJcbiAgICovXG5cbiAgdmFyIHVuaXF1ZUFycmF5ID0gZnVuY3Rpb24gdW5pcXVlQXJyYXkoYXJyKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZXN1bHQuaW5kZXhPZihhcnJbaV0pID09PSAtMSkge1xuICAgICAgICByZXN1bHQucHVzaChhcnJbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIC8qKlxuICAgKiBDYXBpdGFsaXplIHRoZSBmaXJzdCBsZXR0ZXIgb2YgYSBzdHJpbmdcbiAgICogQHBhcmFtIHN0clxuICAgKi9cblxuICB2YXIgY2FwaXRhbGl6ZUZpcnN0TGV0dGVyID0gZnVuY3Rpb24gY2FwaXRhbGl6ZUZpcnN0TGV0dGVyKHN0cikge1xuICAgIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSk7XG4gIH07XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhcnJheSBvZiBvYmplY3QgdmFsdWVzIChPYmplY3QudmFsdWVzIGlzbid0IHN1cHBvcnRlZCBpbiBJRTExKVxuICAgKiBAcGFyYW0gb2JqXG4gICAqL1xuXG4gIHZhciBvYmplY3RWYWx1ZXMgPSBmdW5jdGlvbiBvYmplY3RWYWx1ZXMob2JqKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHJldHVybiBvYmpba2V5XTtcbiAgICB9KTtcbiAgfTtcbiAgLyoqXG4gICAqIENvbnZlcnQgTm9kZUxpc3QgdG8gQXJyYXlcbiAgICogQHBhcmFtIG5vZGVMaXN0XG4gICAqL1xuXG4gIHZhciB0b0FycmF5ID0gZnVuY3Rpb24gdG9BcnJheShub2RlTGlzdCkge1xuICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChub2RlTGlzdCk7XG4gIH07XG4gIC8qKlxuICAgKiBTdGFuZGFyZGlzZSBjb25zb2xlIHdhcm5pbmdzXG4gICAqIEBwYXJhbSBtZXNzYWdlXG4gICAqL1xuXG4gIHZhciB3YXJuID0gZnVuY3Rpb24gd2FybihtZXNzYWdlKSB7XG4gICAgY29uc29sZS53YXJuKFwiXCIuY29uY2F0KGNvbnNvbGVQcmVmaXgsIFwiIFwiKS5jb25jYXQobWVzc2FnZSkpO1xuICB9O1xuICAvKipcbiAgICogU3RhbmRhcmRpc2UgY29uc29sZSBlcnJvcnNcbiAgICogQHBhcmFtIG1lc3NhZ2VcbiAgICovXG5cbiAgdmFyIGVycm9yID0gZnVuY3Rpb24gZXJyb3IobWVzc2FnZSkge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJcIi5jb25jYXQoY29uc29sZVByZWZpeCwgXCIgXCIpLmNvbmNhdChtZXNzYWdlKSk7XG4gIH07XG4gIC8qKlxuICAgKiBQcml2YXRlIGdsb2JhbCBzdGF0ZSBmb3IgYHdhcm5PbmNlYFxuICAgKiBAdHlwZSB7QXJyYXl9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG4gIHZhciBwcmV2aW91c1dhcm5PbmNlTWVzc2FnZXMgPSBbXTtcbiAgLyoqXG4gICAqIFNob3cgYSBjb25zb2xlIHdhcm5pbmcsIGJ1dCBvbmx5IGlmIGl0IGhhc24ndCBhbHJlYWR5IGJlZW4gc2hvd25cbiAgICogQHBhcmFtIG1lc3NhZ2VcbiAgICovXG5cbiAgdmFyIHdhcm5PbmNlID0gZnVuY3Rpb24gd2Fybk9uY2UobWVzc2FnZSkge1xuICAgIGlmICghKHByZXZpb3VzV2Fybk9uY2VNZXNzYWdlcy5pbmRleE9mKG1lc3NhZ2UpICE9PSAtMSkpIHtcbiAgICAgIHByZXZpb3VzV2Fybk9uY2VNZXNzYWdlcy5wdXNoKG1lc3NhZ2UpO1xuICAgICAgd2FybihtZXNzYWdlKTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBTaG93IGEgb25lLXRpbWUgY29uc29sZSB3YXJuaW5nIGFib3V0IGRlcHJlY2F0ZWQgcGFyYW1zL21ldGhvZHNcbiAgICovXG5cbiAgdmFyIHdhcm5BYm91dERlcHJlYXRpb24gPSBmdW5jdGlvbiB3YXJuQWJvdXREZXByZWF0aW9uKGRlcHJlY2F0ZWRQYXJhbSwgdXNlSW5zdGVhZCkge1xuICAgIHdhcm5PbmNlKFwiXFxcIlwiLmNvbmNhdChkZXByZWNhdGVkUGFyYW0sIFwiXFxcIiBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgcmVsZWFzZS4gUGxlYXNlIHVzZSBcXFwiXCIpLmNvbmNhdCh1c2VJbnN0ZWFkLCBcIlxcXCIgaW5zdGVhZC5cIikpO1xuICB9O1xuICAvKipcbiAgICogSWYgYGFyZ2AgaXMgYSBmdW5jdGlvbiwgY2FsbCBpdCAod2l0aCBubyBhcmd1bWVudHMgb3IgY29udGV4dCkgYW5kIHJldHVybiB0aGUgcmVzdWx0LlxuICAgKiBPdGhlcndpc2UsIGp1c3QgcGFzcyB0aGUgdmFsdWUgdGhyb3VnaFxuICAgKiBAcGFyYW0gYXJnXG4gICAqL1xuXG4gIHZhciBjYWxsSWZGdW5jdGlvbiA9IGZ1bmN0aW9uIGNhbGxJZkZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nID8gYXJnKCkgOiBhcmc7XG4gIH07XG4gIHZhciBoYXNUb1Byb21pc2VGbiA9IGZ1bmN0aW9uIGhhc1RvUHJvbWlzZUZuKGFyZykge1xuICAgIHJldHVybiBhcmcgJiYgdHlwZW9mIGFyZy50b1Byb21pc2UgPT09ICdmdW5jdGlvbic7XG4gIH07XG4gIHZhciBhc1Byb21pc2UgPSBmdW5jdGlvbiBhc1Byb21pc2UoYXJnKSB7XG4gICAgcmV0dXJuIGhhc1RvUHJvbWlzZUZuKGFyZykgPyBhcmcudG9Qcm9taXNlKCkgOiBQcm9taXNlLnJlc29sdmUoYXJnKTtcbiAgfTtcbiAgdmFyIGlzUHJvbWlzZSA9IGZ1bmN0aW9uIGlzUHJvbWlzZShhcmcpIHtcbiAgICByZXR1cm4gYXJnICYmIFByb21pc2UucmVzb2x2ZShhcmcpID09PSBhcmc7XG4gIH07XG5cbiAgdmFyIERpc21pc3NSZWFzb24gPSBPYmplY3QuZnJlZXplKHtcbiAgICBjYW5jZWw6ICdjYW5jZWwnLFxuICAgIGJhY2tkcm9wOiAnYmFja2Ryb3AnLFxuICAgIGNsb3NlOiAnY2xvc2UnLFxuICAgIGVzYzogJ2VzYycsXG4gICAgdGltZXI6ICd0aW1lcidcbiAgfSk7XG5cbiAgdmFyIGlzSnF1ZXJ5RWxlbWVudCA9IGZ1bmN0aW9uIGlzSnF1ZXJ5RWxlbWVudChlbGVtKSB7XG4gICAgcmV0dXJuIF90eXBlb2YoZWxlbSkgPT09ICdvYmplY3QnICYmIGVsZW0uanF1ZXJ5O1xuICB9O1xuXG4gIHZhciBpc0VsZW1lbnQgPSBmdW5jdGlvbiBpc0VsZW1lbnQoZWxlbSkge1xuICAgIHJldHVybiBlbGVtIGluc3RhbmNlb2YgRWxlbWVudCB8fCBpc0pxdWVyeUVsZW1lbnQoZWxlbSk7XG4gIH07XG5cbiAgdmFyIGFyZ3NUb1BhcmFtcyA9IGZ1bmN0aW9uIGFyZ3NUb1BhcmFtcyhhcmdzKSB7XG4gICAgdmFyIHBhcmFtcyA9IHt9O1xuXG4gICAgaWYgKF90eXBlb2YoYXJnc1swXSkgPT09ICdvYmplY3QnICYmICFpc0VsZW1lbnQoYXJnc1swXSkpIHtcbiAgICAgIF9leHRlbmRzKHBhcmFtcywgYXJnc1swXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFsndGl0bGUnLCAnaHRtbCcsICdpY29uJ10uZm9yRWFjaChmdW5jdGlvbiAobmFtZSwgaW5kZXgpIHtcbiAgICAgICAgdmFyIGFyZyA9IGFyZ3NbaW5kZXhdO1xuXG4gICAgICAgIGlmICh0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fCBpc0VsZW1lbnQoYXJnKSkge1xuICAgICAgICAgIHBhcmFtc1tuYW1lXSA9IGFyZztcbiAgICAgICAgfSBlbHNlIGlmIChhcmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGVycm9yKFwiVW5leHBlY3RlZCB0eXBlIG9mIFwiLmNvbmNhdChuYW1lLCBcIiEgRXhwZWN0ZWQgXFxcInN0cmluZ1xcXCIgb3IgXFxcIkVsZW1lbnRcXFwiLCBnb3QgXCIpLmNvbmNhdChfdHlwZW9mKGFyZykpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcmFtcztcbiAgfTtcblxuICB2YXIgc3dhbFByZWZpeCA9ICdzd2FsMi0nO1xuICB2YXIgcHJlZml4ID0gZnVuY3Rpb24gcHJlZml4KGl0ZW1zKSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuXG4gICAgZm9yICh2YXIgaSBpbiBpdGVtcykge1xuICAgICAgcmVzdWx0W2l0ZW1zW2ldXSA9IHN3YWxQcmVmaXggKyBpdGVtc1tpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICB2YXIgc3dhbENsYXNzZXMgPSBwcmVmaXgoWydjb250YWluZXInLCAnc2hvd24nLCAnaGVpZ2h0LWF1dG8nLCAnaW9zZml4JywgJ3BvcHVwJywgJ21vZGFsJywgJ25vLWJhY2tkcm9wJywgJ25vLXRyYW5zaXRpb24nLCAndG9hc3QnLCAndG9hc3Qtc2hvd24nLCAndG9hc3QtY29sdW1uJywgJ3Nob3cnLCAnaGlkZScsICdjbG9zZScsICd0aXRsZScsICdoZWFkZXInLCAnY29udGVudCcsICdodG1sLWNvbnRhaW5lcicsICdhY3Rpb25zJywgJ2NvbmZpcm0nLCAnY2FuY2VsJywgJ2Zvb3RlcicsICdpY29uJywgJ2ljb24tY29udGVudCcsICdpbWFnZScsICdpbnB1dCcsICdmaWxlJywgJ3JhbmdlJywgJ3NlbGVjdCcsICdyYWRpbycsICdjaGVja2JveCcsICdsYWJlbCcsICd0ZXh0YXJlYScsICdpbnB1dGVycm9yJywgJ3ZhbGlkYXRpb24tbWVzc2FnZScsICdwcm9ncmVzcy1zdGVwcycsICdhY3RpdmUtcHJvZ3Jlc3Mtc3RlcCcsICdwcm9ncmVzcy1zdGVwJywgJ3Byb2dyZXNzLXN0ZXAtbGluZScsICdsb2FkaW5nJywgJ3N0eWxlZCcsICd0b3AnLCAndG9wLXN0YXJ0JywgJ3RvcC1lbmQnLCAndG9wLWxlZnQnLCAndG9wLXJpZ2h0JywgJ2NlbnRlcicsICdjZW50ZXItc3RhcnQnLCAnY2VudGVyLWVuZCcsICdjZW50ZXItbGVmdCcsICdjZW50ZXItcmlnaHQnLCAnYm90dG9tJywgJ2JvdHRvbS1zdGFydCcsICdib3R0b20tZW5kJywgJ2JvdHRvbS1sZWZ0JywgJ2JvdHRvbS1yaWdodCcsICdncm93LXJvdycsICdncm93LWNvbHVtbicsICdncm93LWZ1bGxzY3JlZW4nLCAncnRsJywgJ3RpbWVyLXByb2dyZXNzLWJhcicsICd0aW1lci1wcm9ncmVzcy1iYXItY29udGFpbmVyJywgJ3Njcm9sbGJhci1tZWFzdXJlJywgJ2ljb24tc3VjY2VzcycsICdpY29uLXdhcm5pbmcnLCAnaWNvbi1pbmZvJywgJ2ljb24tcXVlc3Rpb24nLCAnaWNvbi1lcnJvciddKTtcbiAgdmFyIGljb25UeXBlcyA9IHByZWZpeChbJ3N1Y2Nlc3MnLCAnd2FybmluZycsICdpbmZvJywgJ3F1ZXN0aW9uJywgJ2Vycm9yJ10pO1xuXG4gIHZhciBnZXRDb250YWluZXIgPSBmdW5jdGlvbiBnZXRDb250YWluZXIoKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmJvZHkucXVlcnlTZWxlY3RvcihcIi5cIi5jb25jYXQoc3dhbENsYXNzZXMuY29udGFpbmVyKSk7XG4gIH07XG4gIHZhciBlbGVtZW50QnlTZWxlY3RvciA9IGZ1bmN0aW9uIGVsZW1lbnRCeVNlbGVjdG9yKHNlbGVjdG9yU3RyaW5nKSB7XG4gICAgdmFyIGNvbnRhaW5lciA9IGdldENvbnRhaW5lcigpO1xuICAgIHJldHVybiBjb250YWluZXIgPyBjb250YWluZXIucXVlcnlTZWxlY3RvcihzZWxlY3RvclN0cmluZykgOiBudWxsO1xuICB9O1xuXG4gIHZhciBlbGVtZW50QnlDbGFzcyA9IGZ1bmN0aW9uIGVsZW1lbnRCeUNsYXNzKGNsYXNzTmFtZSkge1xuICAgIHJldHVybiBlbGVtZW50QnlTZWxlY3RvcihcIi5cIi5jb25jYXQoY2xhc3NOYW1lKSk7XG4gIH07XG5cbiAgdmFyIGdldFBvcHVwID0gZnVuY3Rpb24gZ2V0UG9wdXAoKSB7XG4gICAgcmV0dXJuIGVsZW1lbnRCeUNsYXNzKHN3YWxDbGFzc2VzLnBvcHVwKTtcbiAgfTtcbiAgdmFyIGdldEljb25zID0gZnVuY3Rpb24gZ2V0SWNvbnMoKSB7XG4gICAgdmFyIHBvcHVwID0gZ2V0UG9wdXAoKTtcbiAgICByZXR1cm4gdG9BcnJheShwb3B1cC5xdWVyeVNlbGVjdG9yQWxsKFwiLlwiLmNvbmNhdChzd2FsQ2xhc3Nlcy5pY29uKSkpO1xuICB9O1xuICB2YXIgZ2V0SWNvbiA9IGZ1bmN0aW9uIGdldEljb24oKSB7XG4gICAgdmFyIHZpc2libGVJY29uID0gZ2V0SWNvbnMoKS5maWx0ZXIoZnVuY3Rpb24gKGljb24pIHtcbiAgICAgIHJldHVybiBpc1Zpc2libGUoaWNvbik7XG4gICAgfSk7XG4gICAgcmV0dXJuIHZpc2libGVJY29uLmxlbmd0aCA/IHZpc2libGVJY29uWzBdIDogbnVsbDtcbiAgfTtcbiAgdmFyIGdldFRpdGxlID0gZnVuY3Rpb24gZ2V0VGl0bGUoKSB7XG4gICAgcmV0dXJuIGVsZW1lbnRCeUNsYXNzKHN3YWxDbGFzc2VzLnRpdGxlKTtcbiAgfTtcbiAgdmFyIGdldENvbnRlbnQgPSBmdW5jdGlvbiBnZXRDb250ZW50KCkge1xuICAgIHJldHVybiBlbGVtZW50QnlDbGFzcyhzd2FsQ2xhc3Nlcy5jb250ZW50KTtcbiAgfTtcbiAgdmFyIGdldEh0bWxDb250YWluZXIgPSBmdW5jdGlvbiBnZXRIdG1sQ29udGFpbmVyKCkge1xuICAgIHJldHVybiBlbGVtZW50QnlDbGFzcyhzd2FsQ2xhc3Nlc1snaHRtbC1jb250YWluZXInXSk7XG4gIH07XG4gIHZhciBnZXRJbWFnZSA9IGZ1bmN0aW9uIGdldEltYWdlKCkge1xuICAgIHJldHVybiBlbGVtZW50QnlDbGFzcyhzd2FsQ2xhc3Nlcy5pbWFnZSk7XG4gIH07XG4gIHZhciBnZXRQcm9ncmVzc1N0ZXBzID0gZnVuY3Rpb24gZ2V0UHJvZ3Jlc3NTdGVwcygpIHtcbiAgICByZXR1cm4gZWxlbWVudEJ5Q2xhc3Moc3dhbENsYXNzZXNbJ3Byb2dyZXNzLXN0ZXBzJ10pO1xuICB9O1xuICB2YXIgZ2V0VmFsaWRhdGlvbk1lc3NhZ2UgPSBmdW5jdGlvbiBnZXRWYWxpZGF0aW9uTWVzc2FnZSgpIHtcbiAgICByZXR1cm4gZWxlbWVudEJ5Q2xhc3Moc3dhbENsYXNzZXNbJ3ZhbGlkYXRpb24tbWVzc2FnZSddKTtcbiAgfTtcbiAgdmFyIGdldENvbmZpcm1CdXR0b24gPSBmdW5jdGlvbiBnZXRDb25maXJtQnV0dG9uKCkge1xuICAgIHJldHVybiBlbGVtZW50QnlTZWxlY3RvcihcIi5cIi5jb25jYXQoc3dhbENsYXNzZXMuYWN0aW9ucywgXCIgLlwiKS5jb25jYXQoc3dhbENsYXNzZXMuY29uZmlybSkpO1xuICB9O1xuICB2YXIgZ2V0Q2FuY2VsQnV0dG9uID0gZnVuY3Rpb24gZ2V0Q2FuY2VsQnV0dG9uKCkge1xuICAgIHJldHVybiBlbGVtZW50QnlTZWxlY3RvcihcIi5cIi5jb25jYXQoc3dhbENsYXNzZXMuYWN0aW9ucywgXCIgLlwiKS5jb25jYXQoc3dhbENsYXNzZXMuY2FuY2VsKSk7XG4gIH07XG4gIHZhciBnZXRBY3Rpb25zID0gZnVuY3Rpb24gZ2V0QWN0aW9ucygpIHtcbiAgICByZXR1cm4gZWxlbWVudEJ5Q2xhc3Moc3dhbENsYXNzZXMuYWN0aW9ucyk7XG4gIH07XG4gIHZhciBnZXRIZWFkZXIgPSBmdW5jdGlvbiBnZXRIZWFkZXIoKSB7XG4gICAgcmV0dXJuIGVsZW1lbnRCeUNsYXNzKHN3YWxDbGFzc2VzLmhlYWRlcik7XG4gIH07XG4gIHZhciBnZXRGb290ZXIgPSBmdW5jdGlvbiBnZXRGb290ZXIoKSB7XG4gICAgcmV0dXJuIGVsZW1lbnRCeUNsYXNzKHN3YWxDbGFzc2VzLmZvb3Rlcik7XG4gIH07XG4gIHZhciBnZXRUaW1lclByb2dyZXNzQmFyID0gZnVuY3Rpb24gZ2V0VGltZXJQcm9ncmVzc0JhcigpIHtcbiAgICByZXR1cm4gZWxlbWVudEJ5Q2xhc3Moc3dhbENsYXNzZXNbJ3RpbWVyLXByb2dyZXNzLWJhciddKTtcbiAgfTtcbiAgdmFyIGdldENsb3NlQnV0dG9uID0gZnVuY3Rpb24gZ2V0Q2xvc2VCdXR0b24oKSB7XG4gICAgcmV0dXJuIGVsZW1lbnRCeUNsYXNzKHN3YWxDbGFzc2VzLmNsb3NlKTtcbiAgfTsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2prdXAvZm9jdXNhYmxlL2Jsb2IvbWFzdGVyL2luZGV4LmpzXG5cbiAgdmFyIGZvY3VzYWJsZSA9IFwiXFxuICBhW2hyZWZdLFxcbiAgYXJlYVtocmVmXSxcXG4gIGlucHV0Om5vdChbZGlzYWJsZWRdKSxcXG4gIHNlbGVjdDpub3QoW2Rpc2FibGVkXSksXFxuICB0ZXh0YXJlYTpub3QoW2Rpc2FibGVkXSksXFxuICBidXR0b246bm90KFtkaXNhYmxlZF0pLFxcbiAgaWZyYW1lLFxcbiAgb2JqZWN0LFxcbiAgZW1iZWQsXFxuICBbdGFiaW5kZXg9XFxcIjBcXFwiXSxcXG4gIFtjb250ZW50ZWRpdGFibGVdLFxcbiAgYXVkaW9bY29udHJvbHNdLFxcbiAgdmlkZW9bY29udHJvbHNdLFxcbiAgc3VtbWFyeVxcblwiO1xuICB2YXIgZ2V0Rm9jdXNhYmxlRWxlbWVudHMgPSBmdW5jdGlvbiBnZXRGb2N1c2FibGVFbGVtZW50cygpIHtcbiAgICB2YXIgZm9jdXNhYmxlRWxlbWVudHNXaXRoVGFiaW5kZXggPSB0b0FycmF5KGdldFBvcHVwKCkucXVlcnlTZWxlY3RvckFsbCgnW3RhYmluZGV4XTpub3QoW3RhYmluZGV4PVwiLTFcIl0pOm5vdChbdGFiaW5kZXg9XCIwXCJdKScpKSAvLyBzb3J0IGFjY29yZGluZyB0byB0YWJpbmRleFxuICAgIC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICBhID0gcGFyc2VJbnQoYS5nZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JykpO1xuICAgICAgYiA9IHBhcnNlSW50KGIuZ2V0QXR0cmlidXRlKCd0YWJpbmRleCcpKTtcblxuICAgICAgaWYgKGEgPiBiKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfSBlbHNlIGlmIChhIDwgYikge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAwO1xuICAgIH0pO1xuICAgIHZhciBvdGhlckZvY3VzYWJsZUVsZW1lbnRzID0gdG9BcnJheShnZXRQb3B1cCgpLnF1ZXJ5U2VsZWN0b3JBbGwoZm9jdXNhYmxlKSkuZmlsdGVyKGZ1bmN0aW9uIChlbCkge1xuICAgICAgcmV0dXJuIGVsLmdldEF0dHJpYnV0ZSgndGFiaW5kZXgnKSAhPT0gJy0xJztcbiAgICB9KTtcbiAgICByZXR1cm4gdW5pcXVlQXJyYXkoZm9jdXNhYmxlRWxlbWVudHNXaXRoVGFiaW5kZXguY29uY2F0KG90aGVyRm9jdXNhYmxlRWxlbWVudHMpKS5maWx0ZXIoZnVuY3Rpb24gKGVsKSB7XG4gICAgICByZXR1cm4gaXNWaXNpYmxlKGVsKTtcbiAgICB9KTtcbiAgfTtcbiAgdmFyIGlzTW9kYWwgPSBmdW5jdGlvbiBpc01vZGFsKCkge1xuICAgIHJldHVybiAhaXNUb2FzdCgpICYmICFkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5jb250YWlucyhzd2FsQ2xhc3Nlc1snbm8tYmFja2Ryb3AnXSk7XG4gIH07XG4gIHZhciBpc1RvYXN0ID0gZnVuY3Rpb24gaXNUb2FzdCgpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuY29udGFpbnMoc3dhbENsYXNzZXNbJ3RvYXN0LXNob3duJ10pO1xuICB9O1xuICB2YXIgaXNMb2FkaW5nID0gZnVuY3Rpb24gaXNMb2FkaW5nKCkge1xuICAgIHJldHVybiBnZXRQb3B1cCgpLmhhc0F0dHJpYnV0ZSgnZGF0YS1sb2FkaW5nJyk7XG4gIH07XG5cbiAgdmFyIHN0YXRlcyA9IHtcbiAgICBwcmV2aW91c0JvZHlQYWRkaW5nOiBudWxsXG4gIH07XG4gIHZhciBzZXRJbm5lckh0bWwgPSBmdW5jdGlvbiBzZXRJbm5lckh0bWwoZWxlbSwgaHRtbCkge1xuICAgIC8vICMxOTI2XG4gICAgZWxlbS50ZXh0Q29udGVudCA9ICcnO1xuXG4gICAgaWYgKGh0bWwpIHtcbiAgICAgIHZhciBwYXJzZXIgPSBuZXcgRE9NUGFyc2VyKCk7XG4gICAgICB2YXIgcGFyc2VkID0gcGFyc2VyLnBhcnNlRnJvbVN0cmluZyhodG1sLCBcInRleHQvaHRtbFwiKTtcbiAgICAgIHRvQXJyYXkocGFyc2VkLnF1ZXJ5U2VsZWN0b3IoJ2hlYWQnKS5jaGlsZE5vZGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICBlbGVtLmFwcGVuZENoaWxkKGNoaWxkKTtcbiAgICAgIH0pO1xuICAgICAgdG9BcnJheShwYXJzZWQucXVlcnlTZWxlY3RvcignYm9keScpLmNoaWxkTm9kZXMpLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIGVsZW0uYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICB2YXIgaGFzQ2xhc3MgPSBmdW5jdGlvbiBoYXNDbGFzcyhlbGVtLCBjbGFzc05hbWUpIHtcbiAgICBpZiAoIWNsYXNzTmFtZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBjbGFzc0xpc3QgPSBjbGFzc05hbWUuc3BsaXQoL1xccysvKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2xhc3NMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIWVsZW0uY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTGlzdFtpXSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIHZhciByZW1vdmVDdXN0b21DbGFzc2VzID0gZnVuY3Rpb24gcmVtb3ZlQ3VzdG9tQ2xhc3NlcyhlbGVtLCBwYXJhbXMpIHtcbiAgICB0b0FycmF5KGVsZW0uY2xhc3NMaXN0KS5mb3JFYWNoKGZ1bmN0aW9uIChjbGFzc05hbWUpIHtcbiAgICAgIGlmICghKG9iamVjdFZhbHVlcyhzd2FsQ2xhc3NlcykuaW5kZXhPZihjbGFzc05hbWUpICE9PSAtMSkgJiYgIShvYmplY3RWYWx1ZXMoaWNvblR5cGVzKS5pbmRleE9mKGNsYXNzTmFtZSkgIT09IC0xKSAmJiAhKG9iamVjdFZhbHVlcyhwYXJhbXMuc2hvd0NsYXNzKS5pbmRleE9mKGNsYXNzTmFtZSkgIT09IC0xKSkge1xuICAgICAgICBlbGVtLmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICB2YXIgYXBwbHlDdXN0b21DbGFzcyA9IGZ1bmN0aW9uIGFwcGx5Q3VzdG9tQ2xhc3MoZWxlbSwgcGFyYW1zLCBjbGFzc05hbWUpIHtcbiAgICByZW1vdmVDdXN0b21DbGFzc2VzKGVsZW0sIHBhcmFtcyk7XG5cbiAgICBpZiAocGFyYW1zLmN1c3RvbUNsYXNzICYmIHBhcmFtcy5jdXN0b21DbGFzc1tjbGFzc05hbWVdKSB7XG4gICAgICBpZiAodHlwZW9mIHBhcmFtcy5jdXN0b21DbGFzc1tjbGFzc05hbWVdICE9PSAnc3RyaW5nJyAmJiAhcGFyYW1zLmN1c3RvbUNsYXNzW2NsYXNzTmFtZV0uZm9yRWFjaCkge1xuICAgICAgICByZXR1cm4gd2FybihcIkludmFsaWQgdHlwZSBvZiBjdXN0b21DbGFzcy5cIi5jb25jYXQoY2xhc3NOYW1lLCBcIiEgRXhwZWN0ZWQgc3RyaW5nIG9yIGl0ZXJhYmxlIG9iamVjdCwgZ290IFxcXCJcIikuY29uY2F0KF90eXBlb2YocGFyYW1zLmN1c3RvbUNsYXNzW2NsYXNzTmFtZV0pLCBcIlxcXCJcIikpO1xuICAgICAgfVxuXG4gICAgICBhZGRDbGFzcyhlbGVtLCBwYXJhbXMuY3VzdG9tQ2xhc3NbY2xhc3NOYW1lXSk7XG4gICAgfVxuICB9O1xuICBmdW5jdGlvbiBnZXRJbnB1dChjb250ZW50LCBpbnB1dFR5cGUpIHtcbiAgICBpZiAoIWlucHV0VHlwZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgc3dpdGNoIChpbnB1dFR5cGUpIHtcbiAgICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICBjYXNlICdmaWxlJzpcbiAgICAgICAgcmV0dXJuIGdldENoaWxkQnlDbGFzcyhjb250ZW50LCBzd2FsQ2xhc3Nlc1tpbnB1dFR5cGVdKTtcblxuICAgICAgY2FzZSAnY2hlY2tib3gnOlxuICAgICAgICByZXR1cm4gY29udGVudC5xdWVyeVNlbGVjdG9yKFwiLlwiLmNvbmNhdChzd2FsQ2xhc3Nlcy5jaGVja2JveCwgXCIgaW5wdXRcIikpO1xuXG4gICAgICBjYXNlICdyYWRpbyc6XG4gICAgICAgIHJldHVybiBjb250ZW50LnF1ZXJ5U2VsZWN0b3IoXCIuXCIuY29uY2F0KHN3YWxDbGFzc2VzLnJhZGlvLCBcIiBpbnB1dDpjaGVja2VkXCIpKSB8fCBjb250ZW50LnF1ZXJ5U2VsZWN0b3IoXCIuXCIuY29uY2F0KHN3YWxDbGFzc2VzLnJhZGlvLCBcIiBpbnB1dDpmaXJzdC1jaGlsZFwiKSk7XG5cbiAgICAgIGNhc2UgJ3JhbmdlJzpcbiAgICAgICAgcmV0dXJuIGNvbnRlbnQucXVlcnlTZWxlY3RvcihcIi5cIi5jb25jYXQoc3dhbENsYXNzZXMucmFuZ2UsIFwiIGlucHV0XCIpKTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGdldENoaWxkQnlDbGFzcyhjb250ZW50LCBzd2FsQ2xhc3Nlcy5pbnB1dCk7XG4gICAgfVxuICB9XG4gIHZhciBmb2N1c0lucHV0ID0gZnVuY3Rpb24gZm9jdXNJbnB1dChpbnB1dCkge1xuICAgIGlucHV0LmZvY3VzKCk7IC8vIHBsYWNlIGN1cnNvciBhdCBlbmQgb2YgdGV4dCBpbiB0ZXh0IGlucHV0XG5cbiAgICBpZiAoaW5wdXQudHlwZSAhPT0gJ2ZpbGUnKSB7XG4gICAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMzQ1OTE1XG4gICAgICB2YXIgdmFsID0gaW5wdXQudmFsdWU7XG4gICAgICBpbnB1dC52YWx1ZSA9ICcnO1xuICAgICAgaW5wdXQudmFsdWUgPSB2YWw7XG4gICAgfVxuICB9O1xuICB2YXIgdG9nZ2xlQ2xhc3MgPSBmdW5jdGlvbiB0b2dnbGVDbGFzcyh0YXJnZXQsIGNsYXNzTGlzdCwgY29uZGl0aW9uKSB7XG4gICAgaWYgKCF0YXJnZXQgfHwgIWNsYXNzTGlzdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY2xhc3NMaXN0ID09PSAnc3RyaW5nJykge1xuICAgICAgY2xhc3NMaXN0ID0gY2xhc3NMaXN0LnNwbGl0KC9cXHMrLykuZmlsdGVyKEJvb2xlYW4pO1xuICAgIH1cblxuICAgIGNsYXNzTGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChjbGFzc05hbWUpIHtcbiAgICAgIGlmICh0YXJnZXQuZm9yRWFjaCkge1xuICAgICAgICB0YXJnZXQuZm9yRWFjaChmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICAgIGNvbmRpdGlvbiA/IGVsZW0uY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpIDogZWxlbS5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uZGl0aW9uID8gdGFyZ2V0LmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKSA6IHRhcmdldC5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIHZhciBhZGRDbGFzcyA9IGZ1bmN0aW9uIGFkZENsYXNzKHRhcmdldCwgY2xhc3NMaXN0KSB7XG4gICAgdG9nZ2xlQ2xhc3ModGFyZ2V0LCBjbGFzc0xpc3QsIHRydWUpO1xuICB9O1xuICB2YXIgcmVtb3ZlQ2xhc3MgPSBmdW5jdGlvbiByZW1vdmVDbGFzcyh0YXJnZXQsIGNsYXNzTGlzdCkge1xuICAgIHRvZ2dsZUNsYXNzKHRhcmdldCwgY2xhc3NMaXN0LCBmYWxzZSk7XG4gIH07XG4gIHZhciBnZXRDaGlsZEJ5Q2xhc3MgPSBmdW5jdGlvbiBnZXRDaGlsZEJ5Q2xhc3MoZWxlbSwgY2xhc3NOYW1lKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVtLmNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChoYXNDbGFzcyhlbGVtLmNoaWxkTm9kZXNbaV0sIGNsYXNzTmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIGVsZW0uY2hpbGROb2Rlc1tpXTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHZhciBhcHBseU51bWVyaWNhbFN0eWxlID0gZnVuY3Rpb24gYXBwbHlOdW1lcmljYWxTdHlsZShlbGVtLCBwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgICBpZiAodmFsdWUgfHwgcGFyc2VJbnQodmFsdWUpID09PSAwKSB7XG4gICAgICBlbGVtLnN0eWxlW3Byb3BlcnR5XSA9IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgPyBcIlwiLmNvbmNhdCh2YWx1ZSwgXCJweFwiKSA6IHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtLnN0eWxlLnJlbW92ZVByb3BlcnR5KHByb3BlcnR5KTtcbiAgICB9XG4gIH07XG4gIHZhciBzaG93ID0gZnVuY3Rpb24gc2hvdyhlbGVtKSB7XG4gICAgdmFyIGRpc3BsYXkgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICdmbGV4JztcbiAgICBlbGVtLnN0eWxlLm9wYWNpdHkgPSAnJztcbiAgICBlbGVtLnN0eWxlLmRpc3BsYXkgPSBkaXNwbGF5O1xuICB9O1xuICB2YXIgaGlkZSA9IGZ1bmN0aW9uIGhpZGUoZWxlbSkge1xuICAgIGVsZW0uc3R5bGUub3BhY2l0eSA9ICcnO1xuICAgIGVsZW0uc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgfTtcbiAgdmFyIHRvZ2dsZSA9IGZ1bmN0aW9uIHRvZ2dsZShlbGVtLCBjb25kaXRpb24sIGRpc3BsYXkpIHtcbiAgICBjb25kaXRpb24gPyBzaG93KGVsZW0sIGRpc3BsYXkpIDogaGlkZShlbGVtKTtcbiAgfTsgLy8gYm9ycm93ZWQgZnJvbSBqcXVlcnkgJChlbGVtKS5pcygnOnZpc2libGUnKSBpbXBsZW1lbnRhdGlvblxuXG4gIHZhciBpc1Zpc2libGUgPSBmdW5jdGlvbiBpc1Zpc2libGUoZWxlbSkge1xuICAgIHJldHVybiAhIShlbGVtICYmIChlbGVtLm9mZnNldFdpZHRoIHx8IGVsZW0ub2Zmc2V0SGVpZ2h0IHx8IGVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGgpKTtcbiAgfTtcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblxuICB2YXIgaXNTY3JvbGxhYmxlID0gZnVuY3Rpb24gaXNTY3JvbGxhYmxlKGVsZW0pIHtcbiAgICByZXR1cm4gISEoZWxlbS5zY3JvbGxIZWlnaHQgPiBlbGVtLmNsaWVudEhlaWdodCk7XG4gIH07IC8vIGJvcnJvd2VkIGZyb20gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzQ2MzUyMTE5XG5cbiAgdmFyIGhhc0Nzc0FuaW1hdGlvbiA9IGZ1bmN0aW9uIGhhc0Nzc0FuaW1hdGlvbihlbGVtKSB7XG4gICAgdmFyIHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbSk7XG4gICAgdmFyIGFuaW1EdXJhdGlvbiA9IHBhcnNlRmxvYXQoc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgnYW5pbWF0aW9uLWR1cmF0aW9uJykgfHwgJzAnKTtcbiAgICB2YXIgdHJhbnNEdXJhdGlvbiA9IHBhcnNlRmxvYXQoc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgndHJhbnNpdGlvbi1kdXJhdGlvbicpIHx8ICcwJyk7XG4gICAgcmV0dXJuIGFuaW1EdXJhdGlvbiA+IDAgfHwgdHJhbnNEdXJhdGlvbiA+IDA7XG4gIH07XG4gIHZhciBjb250YWlucyA9IGZ1bmN0aW9uIGNvbnRhaW5zKGhheXN0YWNrLCBuZWVkbGUpIHtcbiAgICBpZiAodHlwZW9mIGhheXN0YWNrLmNvbnRhaW5zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gaGF5c3RhY2suY29udGFpbnMobmVlZGxlKTtcbiAgICB9XG4gIH07XG4gIHZhciBhbmltYXRlVGltZXJQcm9ncmVzc0JhciA9IGZ1bmN0aW9uIGFuaW1hdGVUaW1lclByb2dyZXNzQmFyKHRpbWVyKSB7XG4gICAgdmFyIHJlc2V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcbiAgICB2YXIgdGltZXJQcm9ncmVzc0JhciA9IGdldFRpbWVyUHJvZ3Jlc3NCYXIoKTtcblxuICAgIGlmIChpc1Zpc2libGUodGltZXJQcm9ncmVzc0JhcikpIHtcbiAgICAgIGlmIChyZXNldCkge1xuICAgICAgICB0aW1lclByb2dyZXNzQmFyLnN0eWxlLnRyYW5zaXRpb24gPSAnbm9uZSc7XG4gICAgICAgIHRpbWVyUHJvZ3Jlc3NCYXIuc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgICB9XG5cbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICB0aW1lclByb2dyZXNzQmFyLnN0eWxlLnRyYW5zaXRpb24gPSBcIndpZHRoIFwiLmNvbmNhdCh0aW1lciAvIDEwMDAsIFwicyBsaW5lYXJcIik7XG4gICAgICAgIHRpbWVyUHJvZ3Jlc3NCYXIuc3R5bGUud2lkdGggPSAnMCUnO1xuICAgICAgfSwgMTApO1xuICAgIH1cbiAgfTtcbiAgdmFyIHN0b3BUaW1lclByb2dyZXNzQmFyID0gZnVuY3Rpb24gc3RvcFRpbWVyUHJvZ3Jlc3NCYXIoKSB7XG4gICAgdmFyIHRpbWVyUHJvZ3Jlc3NCYXIgPSBnZXRUaW1lclByb2dyZXNzQmFyKCk7XG4gICAgdmFyIHRpbWVyUHJvZ3Jlc3NCYXJXaWR0aCA9IHBhcnNlSW50KHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRpbWVyUHJvZ3Jlc3NCYXIpLndpZHRoKTtcbiAgICB0aW1lclByb2dyZXNzQmFyLnN0eWxlLnJlbW92ZVByb3BlcnR5KCd0cmFuc2l0aW9uJyk7XG4gICAgdGltZXJQcm9ncmVzc0Jhci5zdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICB2YXIgdGltZXJQcm9ncmVzc0JhckZ1bGxXaWR0aCA9IHBhcnNlSW50KHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRpbWVyUHJvZ3Jlc3NCYXIpLndpZHRoKTtcbiAgICB2YXIgdGltZXJQcm9ncmVzc0JhclBlcmNlbnQgPSBwYXJzZUludCh0aW1lclByb2dyZXNzQmFyV2lkdGggLyB0aW1lclByb2dyZXNzQmFyRnVsbFdpZHRoICogMTAwKTtcbiAgICB0aW1lclByb2dyZXNzQmFyLnN0eWxlLnJlbW92ZVByb3BlcnR5KCd0cmFuc2l0aW9uJyk7XG4gICAgdGltZXJQcm9ncmVzc0Jhci5zdHlsZS53aWR0aCA9IFwiXCIuY29uY2F0KHRpbWVyUHJvZ3Jlc3NCYXJQZXJjZW50LCBcIiVcIik7XG4gIH07XG5cbiAgLy8gRGV0ZWN0IE5vZGUgZW52XG4gIHZhciBpc05vZGVFbnYgPSBmdW5jdGlvbiBpc05vZGVFbnYoKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCc7XG4gIH07XG5cbiAgdmFyIHN3ZWV0SFRNTCA9IFwiXFxuIDxkaXYgYXJpYS1sYWJlbGxlZGJ5PVxcXCJcIi5jb25jYXQoc3dhbENsYXNzZXMudGl0bGUsIFwiXFxcIiBhcmlhLWRlc2NyaWJlZGJ5PVxcXCJcIikuY29uY2F0KHN3YWxDbGFzc2VzLmNvbnRlbnQsIFwiXFxcIiBjbGFzcz1cXFwiXCIpLmNvbmNhdChzd2FsQ2xhc3Nlcy5wb3B1cCwgXCJcXFwiIHRhYmluZGV4PVxcXCItMVxcXCI+XFxuICAgPGRpdiBjbGFzcz1cXFwiXCIpLmNvbmNhdChzd2FsQ2xhc3Nlcy5oZWFkZXIsIFwiXFxcIj5cXG4gICAgIDx1bCBjbGFzcz1cXFwiXCIpLmNvbmNhdChzd2FsQ2xhc3Nlc1sncHJvZ3Jlc3Mtc3RlcHMnXSwgXCJcXFwiPjwvdWw+XFxuICAgICA8ZGl2IGNsYXNzPVxcXCJcIikuY29uY2F0KHN3YWxDbGFzc2VzLmljb24sIFwiIFwiKS5jb25jYXQoaWNvblR5cGVzLmVycm9yLCBcIlxcXCI+PC9kaXY+XFxuICAgICA8ZGl2IGNsYXNzPVxcXCJcIikuY29uY2F0KHN3YWxDbGFzc2VzLmljb24sIFwiIFwiKS5jb25jYXQoaWNvblR5cGVzLnF1ZXN0aW9uLCBcIlxcXCI+PC9kaXY+XFxuICAgICA8ZGl2IGNsYXNzPVxcXCJcIikuY29uY2F0KHN3YWxDbGFzc2VzLmljb24sIFwiIFwiKS5jb25jYXQoaWNvblR5cGVzLndhcm5pbmcsIFwiXFxcIj48L2Rpdj5cXG4gICAgIDxkaXYgY2xhc3M9XFxcIlwiKS5jb25jYXQoc3dhbENsYXNzZXMuaWNvbiwgXCIgXCIpLmNvbmNhdChpY29uVHlwZXMuaW5mbywgXCJcXFwiPjwvZGl2PlxcbiAgICAgPGRpdiBjbGFzcz1cXFwiXCIpLmNvbmNhdChzd2FsQ2xhc3Nlcy5pY29uLCBcIiBcIikuY29uY2F0KGljb25UeXBlcy5zdWNjZXNzLCBcIlxcXCI+PC9kaXY+XFxuICAgICA8aW1nIGNsYXNzPVxcXCJcIikuY29uY2F0KHN3YWxDbGFzc2VzLmltYWdlLCBcIlxcXCIgLz5cXG4gICAgIDxoMiBjbGFzcz1cXFwiXCIpLmNvbmNhdChzd2FsQ2xhc3Nlcy50aXRsZSwgXCJcXFwiIGlkPVxcXCJcIikuY29uY2F0KHN3YWxDbGFzc2VzLnRpdGxlLCBcIlxcXCI+PC9oMj5cXG4gICAgIDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiXCIpLmNvbmNhdChzd2FsQ2xhc3Nlcy5jbG9zZSwgXCJcXFwiPjwvYnV0dG9uPlxcbiAgIDwvZGl2PlxcbiAgIDxkaXYgY2xhc3M9XFxcIlwiKS5jb25jYXQoc3dhbENsYXNzZXMuY29udGVudCwgXCJcXFwiPlxcbiAgICAgPGRpdiBpZD1cXFwiXCIpLmNvbmNhdChzd2FsQ2xhc3Nlcy5jb250ZW50LCBcIlxcXCIgY2xhc3M9XFxcIlwiKS5jb25jYXQoc3dhbENsYXNzZXNbJ2h0bWwtY29udGFpbmVyJ10sIFwiXFxcIj48L2Rpdj5cXG4gICAgIDxpbnB1dCBjbGFzcz1cXFwiXCIpLmNvbmNhdChzd2FsQ2xhc3Nlcy5pbnB1dCwgXCJcXFwiIC8+XFxuICAgICA8aW5wdXQgdHlwZT1cXFwiZmlsZVxcXCIgY2xhc3M9XFxcIlwiKS5jb25jYXQoc3dhbENsYXNzZXMuZmlsZSwgXCJcXFwiIC8+XFxuICAgICA8ZGl2IGNsYXNzPVxcXCJcIikuY29uY2F0KHN3YWxDbGFzc2VzLnJhbmdlLCBcIlxcXCI+XFxuICAgICAgIDxpbnB1dCB0eXBlPVxcXCJyYW5nZVxcXCIgLz5cXG4gICAgICAgPG91dHB1dD48L291dHB1dD5cXG4gICAgIDwvZGl2PlxcbiAgICAgPHNlbGVjdCBjbGFzcz1cXFwiXCIpLmNvbmNhdChzd2FsQ2xhc3Nlcy5zZWxlY3QsIFwiXFxcIj48L3NlbGVjdD5cXG4gICAgIDxkaXYgY2xhc3M9XFxcIlwiKS5jb25jYXQoc3dhbENsYXNzZXMucmFkaW8sIFwiXFxcIj48L2Rpdj5cXG4gICAgIDxsYWJlbCBmb3I9XFxcIlwiKS5jb25jYXQoc3dhbENsYXNzZXMuY2hlY2tib3gsIFwiXFxcIiBjbGFzcz1cXFwiXCIpLmNvbmNhdChzd2FsQ2xhc3Nlcy5jaGVja2JveCwgXCJcXFwiPlxcbiAgICAgICA8aW5wdXQgdHlwZT1cXFwiY2hlY2tib3hcXFwiIC8+XFxuICAgICAgIDxzcGFuIGNsYXNzPVxcXCJcIikuY29uY2F0KHN3YWxDbGFzc2VzLmxhYmVsLCBcIlxcXCI+PC9zcGFuPlxcbiAgICAgPC9sYWJlbD5cXG4gICAgIDx0ZXh0YXJlYSBjbGFzcz1cXFwiXCIpLmNvbmNhdChzd2FsQ2xhc3Nlcy50ZXh0YXJlYSwgXCJcXFwiPjwvdGV4dGFyZWE+XFxuICAgICA8ZGl2IGNsYXNzPVxcXCJcIikuY29uY2F0KHN3YWxDbGFzc2VzWyd2YWxpZGF0aW9uLW1lc3NhZ2UnXSwgXCJcXFwiIGlkPVxcXCJcIikuY29uY2F0KHN3YWxDbGFzc2VzWyd2YWxpZGF0aW9uLW1lc3NhZ2UnXSwgXCJcXFwiPjwvZGl2PlxcbiAgIDwvZGl2PlxcbiAgIDxkaXYgY2xhc3M9XFxcIlwiKS5jb25jYXQoc3dhbENsYXNzZXMuYWN0aW9ucywgXCJcXFwiPlxcbiAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJcIikuY29uY2F0KHN3YWxDbGFzc2VzLmNvbmZpcm0sIFwiXFxcIj5PSzwvYnV0dG9uPlxcbiAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJcIikuY29uY2F0KHN3YWxDbGFzc2VzLmNhbmNlbCwgXCJcXFwiPkNhbmNlbDwvYnV0dG9uPlxcbiAgIDwvZGl2PlxcbiAgIDxkaXYgY2xhc3M9XFxcIlwiKS5jb25jYXQoc3dhbENsYXNzZXMuZm9vdGVyLCBcIlxcXCI+PC9kaXY+XFxuICAgPGRpdiBjbGFzcz1cXFwiXCIpLmNvbmNhdChzd2FsQ2xhc3Nlc1sndGltZXItcHJvZ3Jlc3MtYmFyLWNvbnRhaW5lciddLCBcIlxcXCI+XFxuICAgICA8ZGl2IGNsYXNzPVxcXCJcIikuY29uY2F0KHN3YWxDbGFzc2VzWyd0aW1lci1wcm9ncmVzcy1iYXInXSwgXCJcXFwiPjwvZGl2PlxcbiAgIDwvZGl2PlxcbiA8L2Rpdj5cXG5cIikucmVwbGFjZSgvKF58XFxuKVxccyovZywgJycpO1xuXG4gIHZhciByZXNldE9sZENvbnRhaW5lciA9IGZ1bmN0aW9uIHJlc2V0T2xkQ29udGFpbmVyKCkge1xuICAgIHZhciBvbGRDb250YWluZXIgPSBnZXRDb250YWluZXIoKTtcblxuICAgIGlmICghb2xkQ29udGFpbmVyKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgb2xkQ29udGFpbmVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQob2xkQ29udGFpbmVyKTtcbiAgICByZW1vdmVDbGFzcyhbZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCBkb2N1bWVudC5ib2R5XSwgW3N3YWxDbGFzc2VzWyduby1iYWNrZHJvcCddLCBzd2FsQ2xhc3Nlc1sndG9hc3Qtc2hvd24nXSwgc3dhbENsYXNzZXNbJ2hhcy1jb2x1bW4nXV0pO1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIHZhciBvbGRJbnB1dFZhbDsgLy8gSUUxMSB3b3JrYXJvdW5kLCBzZWUgIzExMDkgZm9yIGRldGFpbHNcblxuICB2YXIgcmVzZXRWYWxpZGF0aW9uTWVzc2FnZSA9IGZ1bmN0aW9uIHJlc2V0VmFsaWRhdGlvbk1lc3NhZ2UoZSkge1xuICAgIGlmIChTd2FsLmlzVmlzaWJsZSgpICYmIG9sZElucHV0VmFsICE9PSBlLnRhcmdldC52YWx1ZSkge1xuICAgICAgU3dhbC5yZXNldFZhbGlkYXRpb25NZXNzYWdlKCk7XG4gICAgfVxuXG4gICAgb2xkSW5wdXRWYWwgPSBlLnRhcmdldC52YWx1ZTtcbiAgfTtcblxuICB2YXIgYWRkSW5wdXRDaGFuZ2VMaXN0ZW5lcnMgPSBmdW5jdGlvbiBhZGRJbnB1dENoYW5nZUxpc3RlbmVycygpIHtcbiAgICB2YXIgY29udGVudCA9IGdldENvbnRlbnQoKTtcbiAgICB2YXIgaW5wdXQgPSBnZXRDaGlsZEJ5Q2xhc3MoY29udGVudCwgc3dhbENsYXNzZXMuaW5wdXQpO1xuICAgIHZhciBmaWxlID0gZ2V0Q2hpbGRCeUNsYXNzKGNvbnRlbnQsIHN3YWxDbGFzc2VzLmZpbGUpO1xuICAgIHZhciByYW5nZSA9IGNvbnRlbnQucXVlcnlTZWxlY3RvcihcIi5cIi5jb25jYXQoc3dhbENsYXNzZXMucmFuZ2UsIFwiIGlucHV0XCIpKTtcbiAgICB2YXIgcmFuZ2VPdXRwdXQgPSBjb250ZW50LnF1ZXJ5U2VsZWN0b3IoXCIuXCIuY29uY2F0KHN3YWxDbGFzc2VzLnJhbmdlLCBcIiBvdXRwdXRcIikpO1xuICAgIHZhciBzZWxlY3QgPSBnZXRDaGlsZEJ5Q2xhc3MoY29udGVudCwgc3dhbENsYXNzZXMuc2VsZWN0KTtcbiAgICB2YXIgY2hlY2tib3ggPSBjb250ZW50LnF1ZXJ5U2VsZWN0b3IoXCIuXCIuY29uY2F0KHN3YWxDbGFzc2VzLmNoZWNrYm94LCBcIiBpbnB1dFwiKSk7XG4gICAgdmFyIHRleHRhcmVhID0gZ2V0Q2hpbGRCeUNsYXNzKGNvbnRlbnQsIHN3YWxDbGFzc2VzLnRleHRhcmVhKTtcbiAgICBpbnB1dC5vbmlucHV0ID0gcmVzZXRWYWxpZGF0aW9uTWVzc2FnZTtcbiAgICBmaWxlLm9uY2hhbmdlID0gcmVzZXRWYWxpZGF0aW9uTWVzc2FnZTtcbiAgICBzZWxlY3Qub25jaGFuZ2UgPSByZXNldFZhbGlkYXRpb25NZXNzYWdlO1xuICAgIGNoZWNrYm94Lm9uY2hhbmdlID0gcmVzZXRWYWxpZGF0aW9uTWVzc2FnZTtcbiAgICB0ZXh0YXJlYS5vbmlucHV0ID0gcmVzZXRWYWxpZGF0aW9uTWVzc2FnZTtcblxuICAgIHJhbmdlLm9uaW5wdXQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgcmVzZXRWYWxpZGF0aW9uTWVzc2FnZShlKTtcbiAgICAgIHJhbmdlT3V0cHV0LnZhbHVlID0gcmFuZ2UudmFsdWU7XG4gICAgfTtcblxuICAgIHJhbmdlLm9uY2hhbmdlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHJlc2V0VmFsaWRhdGlvbk1lc3NhZ2UoZSk7XG4gICAgICByYW5nZS5uZXh0U2libGluZy52YWx1ZSA9IHJhbmdlLnZhbHVlO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIGdldFRhcmdldCA9IGZ1bmN0aW9uIGdldFRhcmdldCh0YXJnZXQpIHtcbiAgICByZXR1cm4gdHlwZW9mIHRhcmdldCA9PT0gJ3N0cmluZycgPyBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldCkgOiB0YXJnZXQ7XG4gIH07XG5cbiAgdmFyIHNldHVwQWNjZXNzaWJpbGl0eSA9IGZ1bmN0aW9uIHNldHVwQWNjZXNzaWJpbGl0eShwYXJhbXMpIHtcbiAgICB2YXIgcG9wdXAgPSBnZXRQb3B1cCgpO1xuICAgIHBvcHVwLnNldEF0dHJpYnV0ZSgncm9sZScsIHBhcmFtcy50b2FzdCA/ICdhbGVydCcgOiAnZGlhbG9nJyk7XG4gICAgcG9wdXAuc2V0QXR0cmlidXRlKCdhcmlhLWxpdmUnLCBwYXJhbXMudG9hc3QgPyAncG9saXRlJyA6ICdhc3NlcnRpdmUnKTtcblxuICAgIGlmICghcGFyYW1zLnRvYXN0KSB7XG4gICAgICBwb3B1cC5zZXRBdHRyaWJ1dGUoJ2FyaWEtbW9kYWwnLCAndHJ1ZScpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgc2V0dXBSVEwgPSBmdW5jdGlvbiBzZXR1cFJUTCh0YXJnZXRFbGVtZW50KSB7XG4gICAgaWYgKHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRhcmdldEVsZW1lbnQpLmRpcmVjdGlvbiA9PT0gJ3J0bCcpIHtcbiAgICAgIGFkZENsYXNzKGdldENvbnRhaW5lcigpLCBzd2FsQ2xhc3Nlcy5ydGwpO1xuICAgIH1cbiAgfTtcbiAgLypcbiAgICogQWRkIG1vZGFsICsgYmFja2Ryb3AgdG8gRE9NXG4gICAqL1xuXG5cbiAgdmFyIGluaXQgPSBmdW5jdGlvbiBpbml0KHBhcmFtcykge1xuICAgIC8vIENsZWFuIHVwIHRoZSBvbGQgcG9wdXAgY29udGFpbmVyIGlmIGl0IGV4aXN0c1xuICAgIHZhciBvbGRDb250YWluZXJFeGlzdGVkID0gcmVzZXRPbGRDb250YWluZXIoKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cblxuICAgIGlmIChpc05vZGVFbnYoKSkge1xuICAgICAgZXJyb3IoJ1N3ZWV0QWxlcnQyIHJlcXVpcmVzIGRvY3VtZW50IHRvIGluaXRpYWxpemUnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29udGFpbmVyLmNsYXNzTmFtZSA9IHN3YWxDbGFzc2VzLmNvbnRhaW5lcjtcblxuICAgIGlmIChvbGRDb250YWluZXJFeGlzdGVkKSB7XG4gICAgICBhZGRDbGFzcyhjb250YWluZXIsIHN3YWxDbGFzc2VzWyduby10cmFuc2l0aW9uJ10pO1xuICAgIH1cblxuICAgIHNldElubmVySHRtbChjb250YWluZXIsIHN3ZWV0SFRNTCk7XG4gICAgdmFyIHRhcmdldEVsZW1lbnQgPSBnZXRUYXJnZXQocGFyYW1zLnRhcmdldCk7XG4gICAgdGFyZ2V0RWxlbWVudC5hcHBlbmRDaGlsZChjb250YWluZXIpO1xuICAgIHNldHVwQWNjZXNzaWJpbGl0eShwYXJhbXMpO1xuICAgIHNldHVwUlRMKHRhcmdldEVsZW1lbnQpO1xuICAgIGFkZElucHV0Q2hhbmdlTGlzdGVuZXJzKCk7XG4gIH07XG5cbiAgdmFyIHBhcnNlSHRtbFRvQ29udGFpbmVyID0gZnVuY3Rpb24gcGFyc2VIdG1sVG9Db250YWluZXIocGFyYW0sIHRhcmdldCkge1xuICAgIC8vIERPTSBlbGVtZW50XG4gICAgaWYgKHBhcmFtIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgIHRhcmdldC5hcHBlbmRDaGlsZChwYXJhbSk7IC8vIE9iamVjdFxuICAgIH0gZWxzZSBpZiAoX3R5cGVvZihwYXJhbSkgPT09ICdvYmplY3QnKSB7XG4gICAgICBoYW5kbGVPYmplY3QocGFyYW0sIHRhcmdldCk7IC8vIFBsYWluIHN0cmluZ1xuICAgIH0gZWxzZSBpZiAocGFyYW0pIHtcbiAgICAgIHNldElubmVySHRtbCh0YXJnZXQsIHBhcmFtKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGhhbmRsZU9iamVjdCA9IGZ1bmN0aW9uIGhhbmRsZU9iamVjdChwYXJhbSwgdGFyZ2V0KSB7XG4gICAgLy8gSlF1ZXJ5IGVsZW1lbnQocylcbiAgICBpZiAocGFyYW0uanF1ZXJ5KSB7XG4gICAgICBoYW5kbGVKcXVlcnlFbGVtKHRhcmdldCwgcGFyYW0pOyAvLyBGb3Igb3RoZXIgb2JqZWN0cyB1c2UgdGhlaXIgc3RyaW5nIHJlcHJlc2VudGF0aW9uXG4gICAgfSBlbHNlIHtcbiAgICAgIHNldElubmVySHRtbCh0YXJnZXQsIHBhcmFtLnRvU3RyaW5nKCkpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgaGFuZGxlSnF1ZXJ5RWxlbSA9IGZ1bmN0aW9uIGhhbmRsZUpxdWVyeUVsZW0odGFyZ2V0LCBlbGVtKSB7XG4gICAgdGFyZ2V0LnRleHRDb250ZW50ID0gJyc7XG5cbiAgICBpZiAoMCBpbiBlbGVtKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgKGkgaW4gZWxlbSk7IGkrKykge1xuICAgICAgICB0YXJnZXQuYXBwZW5kQ2hpbGQoZWxlbVtpXS5jbG9uZU5vZGUodHJ1ZSkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0YXJnZXQuYXBwZW5kQ2hpbGQoZWxlbS5jbG9uZU5vZGUodHJ1ZSkpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgYW5pbWF0aW9uRW5kRXZlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gUHJldmVudCBydW4gaW4gTm9kZSBlbnZcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChpc05vZGVFbnYoKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciB0ZXN0RWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB2YXIgdHJhbnNFbmRFdmVudE5hbWVzID0ge1xuICAgICAgV2Via2l0QW5pbWF0aW9uOiAnd2Via2l0QW5pbWF0aW9uRW5kJyxcbiAgICAgIE9BbmltYXRpb246ICdvQW5pbWF0aW9uRW5kIG9hbmltYXRpb25lbmQnLFxuICAgICAgYW5pbWF0aW9uOiAnYW5pbWF0aW9uZW5kJ1xuICAgIH07XG5cbiAgICBmb3IgKHZhciBpIGluIHRyYW5zRW5kRXZlbnROYW1lcykge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0cmFuc0VuZEV2ZW50TmFtZXMsIGkpICYmIHR5cGVvZiB0ZXN0RWwuc3R5bGVbaV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiB0cmFuc0VuZEV2ZW50TmFtZXNbaV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9KCk7XG5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFzdGVyL2pzL3NyYy9tb2RhbC5qc1xuXG4gIHZhciBtZWFzdXJlU2Nyb2xsYmFyID0gZnVuY3Rpb24gbWVhc3VyZVNjcm9sbGJhcigpIHtcbiAgICB2YXIgc2Nyb2xsRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgc2Nyb2xsRGl2LmNsYXNzTmFtZSA9IHN3YWxDbGFzc2VzWydzY3JvbGxiYXItbWVhc3VyZSddO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc2Nyb2xsRGl2KTtcbiAgICB2YXIgc2Nyb2xsYmFyV2lkdGggPSBzY3JvbGxEaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggLSBzY3JvbGxEaXYuY2xpZW50V2lkdGg7XG4gICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChzY3JvbGxEaXYpO1xuICAgIHJldHVybiBzY3JvbGxiYXJXaWR0aDtcbiAgfTtcblxuICB2YXIgcmVuZGVyQWN0aW9ucyA9IGZ1bmN0aW9uIHJlbmRlckFjdGlvbnMoaW5zdGFuY2UsIHBhcmFtcykge1xuICAgIHZhciBhY3Rpb25zID0gZ2V0QWN0aW9ucygpO1xuICAgIHZhciBjb25maXJtQnV0dG9uID0gZ2V0Q29uZmlybUJ1dHRvbigpO1xuICAgIHZhciBjYW5jZWxCdXR0b24gPSBnZXRDYW5jZWxCdXR0b24oKTsgLy8gQWN0aW9ucyAoYnV0dG9ucykgd3JhcHBlclxuXG4gICAgaWYgKCFwYXJhbXMuc2hvd0NvbmZpcm1CdXR0b24gJiYgIXBhcmFtcy5zaG93Q2FuY2VsQnV0dG9uKSB7XG4gICAgICBoaWRlKGFjdGlvbnMpO1xuICAgIH0gLy8gQ3VzdG9tIGNsYXNzXG5cblxuICAgIGFwcGx5Q3VzdG9tQ2xhc3MoYWN0aW9ucywgcGFyYW1zLCAnYWN0aW9ucycpOyAvLyBSZW5kZXIgY29uZmlybSBidXR0b25cblxuICAgIHJlbmRlckJ1dHRvbihjb25maXJtQnV0dG9uLCAnY29uZmlybScsIHBhcmFtcyk7IC8vIHJlbmRlciBDYW5jZWwgQnV0dG9uXG5cbiAgICByZW5kZXJCdXR0b24oY2FuY2VsQnV0dG9uLCAnY2FuY2VsJywgcGFyYW1zKTtcblxuICAgIGlmIChwYXJhbXMuYnV0dG9uc1N0eWxpbmcpIHtcbiAgICAgIGhhbmRsZUJ1dHRvbnNTdHlsaW5nKGNvbmZpcm1CdXR0b24sIGNhbmNlbEJ1dHRvbiwgcGFyYW1zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVtb3ZlQ2xhc3MoW2NvbmZpcm1CdXR0b24sIGNhbmNlbEJ1dHRvbl0sIHN3YWxDbGFzc2VzLnN0eWxlZCk7XG4gICAgICBjb25maXJtQnV0dG9uLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IGNvbmZpcm1CdXR0b24uc3R5bGUuYm9yZGVyTGVmdENvbG9yID0gY29uZmlybUJ1dHRvbi5zdHlsZS5ib3JkZXJSaWdodENvbG9yID0gJyc7XG4gICAgICBjYW5jZWxCdXR0b24uc3R5bGUuYmFja2dyb3VuZENvbG9yID0gY2FuY2VsQnV0dG9uLnN0eWxlLmJvcmRlckxlZnRDb2xvciA9IGNhbmNlbEJ1dHRvbi5zdHlsZS5ib3JkZXJSaWdodENvbG9yID0gJyc7XG4gICAgfVxuXG4gICAgaWYgKHBhcmFtcy5yZXZlcnNlQnV0dG9ucykge1xuICAgICAgY29uZmlybUJ1dHRvbi5wYXJlbnROb2RlLmluc2VydEJlZm9yZShjYW5jZWxCdXR0b24sIGNvbmZpcm1CdXR0b24pO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBoYW5kbGVCdXR0b25zU3R5bGluZyhjb25maXJtQnV0dG9uLCBjYW5jZWxCdXR0b24sIHBhcmFtcykge1xuICAgIGFkZENsYXNzKFtjb25maXJtQnV0dG9uLCBjYW5jZWxCdXR0b25dLCBzd2FsQ2xhc3Nlcy5zdHlsZWQpOyAvLyBCdXR0b25zIGJhY2tncm91bmQgY29sb3JzXG5cbiAgICBpZiAocGFyYW1zLmNvbmZpcm1CdXR0b25Db2xvcikge1xuICAgICAgY29uZmlybUJ1dHRvbi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBwYXJhbXMuY29uZmlybUJ1dHRvbkNvbG9yO1xuICAgIH1cblxuICAgIGlmIChwYXJhbXMuY2FuY2VsQnV0dG9uQ29sb3IpIHtcbiAgICAgIGNhbmNlbEJ1dHRvbi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBwYXJhbXMuY2FuY2VsQnV0dG9uQ29sb3I7XG4gICAgfSAvLyBMb2FkaW5nIHN0YXRlXG5cblxuICAgIGlmICghaXNMb2FkaW5nKCkpIHtcbiAgICAgIHZhciBjb25maXJtQnV0dG9uQmFja2dyb3VuZENvbG9yID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoY29uZmlybUJ1dHRvbikuZ2V0UHJvcGVydHlWYWx1ZSgnYmFja2dyb3VuZC1jb2xvcicpO1xuICAgICAgY29uZmlybUJ1dHRvbi5zdHlsZS5ib3JkZXJMZWZ0Q29sb3IgPSBjb25maXJtQnV0dG9uQmFja2dyb3VuZENvbG9yO1xuICAgICAgY29uZmlybUJ1dHRvbi5zdHlsZS5ib3JkZXJSaWdodENvbG9yID0gY29uZmlybUJ1dHRvbkJhY2tncm91bmRDb2xvcjtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW5kZXJCdXR0b24oYnV0dG9uLCBidXR0b25UeXBlLCBwYXJhbXMpIHtcbiAgICB0b2dnbGUoYnV0dG9uLCBwYXJhbXNbXCJzaG93XCIuY29uY2F0KGNhcGl0YWxpemVGaXJzdExldHRlcihidXR0b25UeXBlKSwgXCJCdXR0b25cIildLCAnaW5saW5lLWJsb2NrJyk7XG4gICAgc2V0SW5uZXJIdG1sKGJ1dHRvbiwgcGFyYW1zW1wiXCIuY29uY2F0KGJ1dHRvblR5cGUsIFwiQnV0dG9uVGV4dFwiKV0pOyAvLyBTZXQgY2FwdGlvbiB0ZXh0XG5cbiAgICBidXR0b24uc2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJywgcGFyYW1zW1wiXCIuY29uY2F0KGJ1dHRvblR5cGUsIFwiQnV0dG9uQXJpYUxhYmVsXCIpXSk7IC8vIEFSSUEgbGFiZWxcbiAgICAvLyBBZGQgYnV0dG9ucyBjdXN0b20gY2xhc3Nlc1xuXG4gICAgYnV0dG9uLmNsYXNzTmFtZSA9IHN3YWxDbGFzc2VzW2J1dHRvblR5cGVdO1xuICAgIGFwcGx5Q3VzdG9tQ2xhc3MoYnV0dG9uLCBwYXJhbXMsIFwiXCIuY29uY2F0KGJ1dHRvblR5cGUsIFwiQnV0dG9uXCIpKTtcbiAgICBhZGRDbGFzcyhidXR0b24sIHBhcmFtc1tcIlwiLmNvbmNhdChidXR0b25UeXBlLCBcIkJ1dHRvbkNsYXNzXCIpXSk7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVCYWNrZHJvcFBhcmFtKGNvbnRhaW5lciwgYmFja2Ryb3ApIHtcbiAgICBpZiAodHlwZW9mIGJhY2tkcm9wID09PSAnc3RyaW5nJykge1xuICAgICAgY29udGFpbmVyLnN0eWxlLmJhY2tncm91bmQgPSBiYWNrZHJvcDtcbiAgICB9IGVsc2UgaWYgKCFiYWNrZHJvcCkge1xuICAgICAgYWRkQ2xhc3MoW2RvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgZG9jdW1lbnQuYm9keV0sIHN3YWxDbGFzc2VzWyduby1iYWNrZHJvcCddKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVQb3NpdGlvblBhcmFtKGNvbnRhaW5lciwgcG9zaXRpb24pIHtcbiAgICBpZiAocG9zaXRpb24gaW4gc3dhbENsYXNzZXMpIHtcbiAgICAgIGFkZENsYXNzKGNvbnRhaW5lciwgc3dhbENsYXNzZXNbcG9zaXRpb25dKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2FybignVGhlIFwicG9zaXRpb25cIiBwYXJhbWV0ZXIgaXMgbm90IHZhbGlkLCBkZWZhdWx0aW5nIHRvIFwiY2VudGVyXCInKTtcbiAgICAgIGFkZENsYXNzKGNvbnRhaW5lciwgc3dhbENsYXNzZXMuY2VudGVyKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVHcm93UGFyYW0oY29udGFpbmVyLCBncm93KSB7XG4gICAgaWYgKGdyb3cgJiYgdHlwZW9mIGdyb3cgPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YXIgZ3Jvd0NsYXNzID0gXCJncm93LVwiLmNvbmNhdChncm93KTtcblxuICAgICAgaWYgKGdyb3dDbGFzcyBpbiBzd2FsQ2xhc3Nlcykge1xuICAgICAgICBhZGRDbGFzcyhjb250YWluZXIsIHN3YWxDbGFzc2VzW2dyb3dDbGFzc10pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciByZW5kZXJDb250YWluZXIgPSBmdW5jdGlvbiByZW5kZXJDb250YWluZXIoaW5zdGFuY2UsIHBhcmFtcykge1xuICAgIHZhciBjb250YWluZXIgPSBnZXRDb250YWluZXIoKTtcblxuICAgIGlmICghY29udGFpbmVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaGFuZGxlQmFja2Ryb3BQYXJhbShjb250YWluZXIsIHBhcmFtcy5iYWNrZHJvcCk7XG5cbiAgICBpZiAoIXBhcmFtcy5iYWNrZHJvcCAmJiBwYXJhbXMuYWxsb3dPdXRzaWRlQ2xpY2spIHtcbiAgICAgIHdhcm4oJ1wiYWxsb3dPdXRzaWRlQ2xpY2tcIiBwYXJhbWV0ZXIgcmVxdWlyZXMgYGJhY2tkcm9wYCBwYXJhbWV0ZXIgdG8gYmUgc2V0IHRvIGB0cnVlYCcpO1xuICAgIH1cblxuICAgIGhhbmRsZVBvc2l0aW9uUGFyYW0oY29udGFpbmVyLCBwYXJhbXMucG9zaXRpb24pO1xuICAgIGhhbmRsZUdyb3dQYXJhbShjb250YWluZXIsIHBhcmFtcy5ncm93KTsgLy8gQ3VzdG9tIGNsYXNzXG5cbiAgICBhcHBseUN1c3RvbUNsYXNzKGNvbnRhaW5lciwgcGFyYW1zLCAnY29udGFpbmVyJyk7IC8vIFNldCBxdWV1ZSBzdGVwIGF0dHJpYnV0ZSBmb3IgZ2V0UXVldWVTdGVwKCkgbWV0aG9kXG5cbiAgICB2YXIgcXVldWVTdGVwID0gZG9jdW1lbnQuYm9keS5nZXRBdHRyaWJ1dGUoJ2RhdGEtc3dhbDItcXVldWUtc3RlcCcpO1xuXG4gICAgaWYgKHF1ZXVlU3RlcCkge1xuICAgICAgY29udGFpbmVyLnNldEF0dHJpYnV0ZSgnZGF0YS1xdWV1ZS1zdGVwJywgcXVldWVTdGVwKTtcbiAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQXR0cmlidXRlKCdkYXRhLXN3YWwyLXF1ZXVlLXN0ZXAnKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgbW9kdWxlIGNvbnRhaW50cyBgV2Vha01hcGBzIGZvciBlYWNoIGVmZmVjdGl2ZWx5LVwicHJpdmF0ZSAgcHJvcGVydHlcIiB0aGF0IGEgYFN3YWxgIGhhcy5cbiAgICogRm9yIGV4YW1wbGUsIHRvIHNldCB0aGUgcHJpdmF0ZSBwcm9wZXJ0eSBcImZvb1wiIG9mIGB0aGlzYCB0byBcImJhclwiLCB5b3UgY2FuIGBwcml2YXRlUHJvcHMuZm9vLnNldCh0aGlzLCAnYmFyJylgXG4gICAqIFRoaXMgaXMgdGhlIGFwcHJvYWNoIHRoYXQgQmFiZWwgd2lsbCBwcm9iYWJseSB0YWtlIHRvIGltcGxlbWVudCBwcml2YXRlIG1ldGhvZHMvZmllbGRzXG4gICAqICAgaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtcHJpdmF0ZS1tZXRob2RzXG4gICAqICAgaHR0cHM6Ly9naXRodWIuY29tL2JhYmVsL2JhYmVsL3B1bGwvNzU1NVxuICAgKiBPbmNlIHdlIGhhdmUgdGhlIGNoYW5nZXMgZnJvbSB0aGF0IFBSIGluIEJhYmVsLCBhbmQgb3VyIGNvcmUgY2xhc3MgZml0cyByZWFzb25hYmxlIGluICpvbmUgbW9kdWxlKlxuICAgKiAgIHRoZW4gd2UgY2FuIHVzZSB0aGF0IGxhbmd1YWdlIGZlYXR1cmUuXG4gICAqL1xuICB2YXIgcHJpdmF0ZVByb3BzID0ge1xuICAgIHByb21pc2U6IG5ldyBXZWFrTWFwKCksXG4gICAgaW5uZXJQYXJhbXM6IG5ldyBXZWFrTWFwKCksXG4gICAgZG9tQ2FjaGU6IG5ldyBXZWFrTWFwKClcbiAgfTtcblxuICB2YXIgaW5wdXRUeXBlcyA9IFsnaW5wdXQnLCAnZmlsZScsICdyYW5nZScsICdzZWxlY3QnLCAncmFkaW8nLCAnY2hlY2tib3gnLCAndGV4dGFyZWEnXTtcbiAgdmFyIHJlbmRlcklucHV0ID0gZnVuY3Rpb24gcmVuZGVySW5wdXQoaW5zdGFuY2UsIHBhcmFtcykge1xuICAgIHZhciBjb250ZW50ID0gZ2V0Q29udGVudCgpO1xuICAgIHZhciBpbm5lclBhcmFtcyA9IHByaXZhdGVQcm9wcy5pbm5lclBhcmFtcy5nZXQoaW5zdGFuY2UpO1xuICAgIHZhciByZXJlbmRlciA9ICFpbm5lclBhcmFtcyB8fCBwYXJhbXMuaW5wdXQgIT09IGlubmVyUGFyYW1zLmlucHV0O1xuICAgIGlucHV0VHlwZXMuZm9yRWFjaChmdW5jdGlvbiAoaW5wdXRUeXBlKSB7XG4gICAgICB2YXIgaW5wdXRDbGFzcyA9IHN3YWxDbGFzc2VzW2lucHV0VHlwZV07XG4gICAgICB2YXIgaW5wdXRDb250YWluZXIgPSBnZXRDaGlsZEJ5Q2xhc3MoY29udGVudCwgaW5wdXRDbGFzcyk7IC8vIHNldCBhdHRyaWJ1dGVzXG5cbiAgICAgIHNldEF0dHJpYnV0ZXMoaW5wdXRUeXBlLCBwYXJhbXMuaW5wdXRBdHRyaWJ1dGVzKTsgLy8gc2V0IGNsYXNzXG5cbiAgICAgIGlucHV0Q29udGFpbmVyLmNsYXNzTmFtZSA9IGlucHV0Q2xhc3M7XG5cbiAgICAgIGlmIChyZXJlbmRlcikge1xuICAgICAgICBoaWRlKGlucHV0Q29udGFpbmVyKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChwYXJhbXMuaW5wdXQpIHtcbiAgICAgIGlmIChyZXJlbmRlcikge1xuICAgICAgICBzaG93SW5wdXQocGFyYW1zKTtcbiAgICAgIH0gLy8gc2V0IGN1c3RvbSBjbGFzc1xuXG5cbiAgICAgIHNldEN1c3RvbUNsYXNzKHBhcmFtcyk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBzaG93SW5wdXQgPSBmdW5jdGlvbiBzaG93SW5wdXQocGFyYW1zKSB7XG4gICAgaWYgKCFyZW5kZXJJbnB1dFR5cGVbcGFyYW1zLmlucHV0XSkge1xuICAgICAgcmV0dXJuIGVycm9yKFwiVW5leHBlY3RlZCB0eXBlIG9mIGlucHV0ISBFeHBlY3RlZCBcXFwidGV4dFxcXCIsIFxcXCJlbWFpbFxcXCIsIFxcXCJwYXNzd29yZFxcXCIsIFxcXCJudW1iZXJcXFwiLCBcXFwidGVsXFxcIiwgXFxcInNlbGVjdFxcXCIsIFxcXCJyYWRpb1xcXCIsIFxcXCJjaGVja2JveFxcXCIsIFxcXCJ0ZXh0YXJlYVxcXCIsIFxcXCJmaWxlXFxcIiBvciBcXFwidXJsXFxcIiwgZ290IFxcXCJcIi5jb25jYXQocGFyYW1zLmlucHV0LCBcIlxcXCJcIikpO1xuICAgIH1cblxuICAgIHZhciBpbnB1dENvbnRhaW5lciA9IGdldElucHV0Q29udGFpbmVyKHBhcmFtcy5pbnB1dCk7XG4gICAgdmFyIGlucHV0ID0gcmVuZGVySW5wdXRUeXBlW3BhcmFtcy5pbnB1dF0oaW5wdXRDb250YWluZXIsIHBhcmFtcyk7XG4gICAgc2hvdyhpbnB1dCk7IC8vIGlucHV0IGF1dG9mb2N1c1xuXG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBmb2N1c0lucHV0KGlucHV0KTtcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgcmVtb3ZlQXR0cmlidXRlcyA9IGZ1bmN0aW9uIHJlbW92ZUF0dHJpYnV0ZXMoaW5wdXQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlucHV0LmF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBhdHRyTmFtZSA9IGlucHV0LmF0dHJpYnV0ZXNbaV0ubmFtZTtcblxuICAgICAgaWYgKCEoWyd0eXBlJywgJ3ZhbHVlJywgJ3N0eWxlJ10uaW5kZXhPZihhdHRyTmFtZSkgIT09IC0xKSkge1xuICAgICAgICBpbnB1dC5yZW1vdmVBdHRyaWJ1dGUoYXR0ck5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgc2V0QXR0cmlidXRlcyA9IGZ1bmN0aW9uIHNldEF0dHJpYnV0ZXMoaW5wdXRUeXBlLCBpbnB1dEF0dHJpYnV0ZXMpIHtcbiAgICB2YXIgaW5wdXQgPSBnZXRJbnB1dChnZXRDb250ZW50KCksIGlucHV0VHlwZSk7XG5cbiAgICBpZiAoIWlucHV0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcmVtb3ZlQXR0cmlidXRlcyhpbnB1dCk7XG5cbiAgICBmb3IgKHZhciBhdHRyIGluIGlucHV0QXR0cmlidXRlcykge1xuICAgICAgLy8gRG8gbm90IHNldCBhIHBsYWNlaG9sZGVyIGZvciA8aW5wdXQgdHlwZT1cInJhbmdlXCI+XG4gICAgICAvLyBpdCdsbCBjcmFzaCBFZGdlLCAjMTI5OFxuICAgICAgaWYgKGlucHV0VHlwZSA9PT0gJ3JhbmdlJyAmJiBhdHRyID09PSAncGxhY2Vob2xkZXInKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoYXR0ciwgaW5wdXRBdHRyaWJ1dGVzW2F0dHJdKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHNldEN1c3RvbUNsYXNzID0gZnVuY3Rpb24gc2V0Q3VzdG9tQ2xhc3MocGFyYW1zKSB7XG4gICAgdmFyIGlucHV0Q29udGFpbmVyID0gZ2V0SW5wdXRDb250YWluZXIocGFyYW1zLmlucHV0KTtcblxuICAgIGlmIChwYXJhbXMuY3VzdG9tQ2xhc3MpIHtcbiAgICAgIGFkZENsYXNzKGlucHV0Q29udGFpbmVyLCBwYXJhbXMuY3VzdG9tQ2xhc3MuaW5wdXQpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgc2V0SW5wdXRQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIHNldElucHV0UGxhY2Vob2xkZXIoaW5wdXQsIHBhcmFtcykge1xuICAgIGlmICghaW5wdXQucGxhY2Vob2xkZXIgfHwgcGFyYW1zLmlucHV0UGxhY2Vob2xkZXIpIHtcbiAgICAgIGlucHV0LnBsYWNlaG9sZGVyID0gcGFyYW1zLmlucHV0UGxhY2Vob2xkZXI7XG4gICAgfVxuICB9O1xuXG4gIHZhciBnZXRJbnB1dENvbnRhaW5lciA9IGZ1bmN0aW9uIGdldElucHV0Q29udGFpbmVyKGlucHV0VHlwZSkge1xuICAgIHZhciBpbnB1dENsYXNzID0gc3dhbENsYXNzZXNbaW5wdXRUeXBlXSA/IHN3YWxDbGFzc2VzW2lucHV0VHlwZV0gOiBzd2FsQ2xhc3Nlcy5pbnB1dDtcbiAgICByZXR1cm4gZ2V0Q2hpbGRCeUNsYXNzKGdldENvbnRlbnQoKSwgaW5wdXRDbGFzcyk7XG4gIH07XG5cbiAgdmFyIHJlbmRlcklucHV0VHlwZSA9IHt9O1xuXG4gIHJlbmRlcklucHV0VHlwZS50ZXh0ID0gcmVuZGVySW5wdXRUeXBlLmVtYWlsID0gcmVuZGVySW5wdXRUeXBlLnBhc3N3b3JkID0gcmVuZGVySW5wdXRUeXBlLm51bWJlciA9IHJlbmRlcklucHV0VHlwZS50ZWwgPSByZW5kZXJJbnB1dFR5cGUudXJsID0gZnVuY3Rpb24gKGlucHV0LCBwYXJhbXMpIHtcbiAgICBpZiAodHlwZW9mIHBhcmFtcy5pbnB1dFZhbHVlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgcGFyYW1zLmlucHV0VmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICBpbnB1dC52YWx1ZSA9IHBhcmFtcy5pbnB1dFZhbHVlO1xuICAgIH0gZWxzZSBpZiAoIWlzUHJvbWlzZShwYXJhbXMuaW5wdXRWYWx1ZSkpIHtcbiAgICAgIHdhcm4oXCJVbmV4cGVjdGVkIHR5cGUgb2YgaW5wdXRWYWx1ZSEgRXhwZWN0ZWQgXFxcInN0cmluZ1xcXCIsIFxcXCJudW1iZXJcXFwiIG9yIFxcXCJQcm9taXNlXFxcIiwgZ290IFxcXCJcIi5jb25jYXQoX3R5cGVvZihwYXJhbXMuaW5wdXRWYWx1ZSksIFwiXFxcIlwiKSk7XG4gICAgfVxuXG4gICAgc2V0SW5wdXRQbGFjZWhvbGRlcihpbnB1dCwgcGFyYW1zKTtcbiAgICBpbnB1dC50eXBlID0gcGFyYW1zLmlucHV0O1xuICAgIHJldHVybiBpbnB1dDtcbiAgfTtcblxuICByZW5kZXJJbnB1dFR5cGUuZmlsZSA9IGZ1bmN0aW9uIChpbnB1dCwgcGFyYW1zKSB7XG4gICAgc2V0SW5wdXRQbGFjZWhvbGRlcihpbnB1dCwgcGFyYW1zKTtcbiAgICByZXR1cm4gaW5wdXQ7XG4gIH07XG5cbiAgcmVuZGVySW5wdXRUeXBlLnJhbmdlID0gZnVuY3Rpb24gKHJhbmdlLCBwYXJhbXMpIHtcbiAgICB2YXIgcmFuZ2VJbnB1dCA9IHJhbmdlLnF1ZXJ5U2VsZWN0b3IoJ2lucHV0Jyk7XG4gICAgdmFyIHJhbmdlT3V0cHV0ID0gcmFuZ2UucXVlcnlTZWxlY3Rvcignb3V0cHV0Jyk7XG4gICAgcmFuZ2VJbnB1dC52YWx1ZSA9IHBhcmFtcy5pbnB1dFZhbHVlO1xuICAgIHJhbmdlSW5wdXQudHlwZSA9IHBhcmFtcy5pbnB1dDtcbiAgICByYW5nZU91dHB1dC52YWx1ZSA9IHBhcmFtcy5pbnB1dFZhbHVlO1xuICAgIHJldHVybiByYW5nZTtcbiAgfTtcblxuICByZW5kZXJJbnB1dFR5cGUuc2VsZWN0ID0gZnVuY3Rpb24gKHNlbGVjdCwgcGFyYW1zKSB7XG4gICAgc2VsZWN0LnRleHRDb250ZW50ID0gJyc7XG5cbiAgICBpZiAocGFyYW1zLmlucHV0UGxhY2Vob2xkZXIpIHtcbiAgICAgIHZhciBwbGFjZWhvbGRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29wdGlvbicpO1xuICAgICAgc2V0SW5uZXJIdG1sKHBsYWNlaG9sZGVyLCBwYXJhbXMuaW5wdXRQbGFjZWhvbGRlcik7XG4gICAgICBwbGFjZWhvbGRlci52YWx1ZSA9ICcnO1xuICAgICAgcGxhY2Vob2xkZXIuZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgcGxhY2Vob2xkZXIuc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgc2VsZWN0LmFwcGVuZENoaWxkKHBsYWNlaG9sZGVyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VsZWN0O1xuICB9O1xuXG4gIHJlbmRlcklucHV0VHlwZS5yYWRpbyA9IGZ1bmN0aW9uIChyYWRpbykge1xuICAgIHJhZGlvLnRleHRDb250ZW50ID0gJyc7XG4gICAgcmV0dXJuIHJhZGlvO1xuICB9O1xuXG4gIHJlbmRlcklucHV0VHlwZS5jaGVja2JveCA9IGZ1bmN0aW9uIChjaGVja2JveENvbnRhaW5lciwgcGFyYW1zKSB7XG4gICAgdmFyIGNoZWNrYm94ID0gZ2V0SW5wdXQoZ2V0Q29udGVudCgpLCAnY2hlY2tib3gnKTtcbiAgICBjaGVja2JveC52YWx1ZSA9IDE7XG4gICAgY2hlY2tib3guaWQgPSBzd2FsQ2xhc3Nlcy5jaGVja2JveDtcbiAgICBjaGVja2JveC5jaGVja2VkID0gQm9vbGVhbihwYXJhbXMuaW5wdXRWYWx1ZSk7XG4gICAgdmFyIGxhYmVsID0gY2hlY2tib3hDb250YWluZXIucXVlcnlTZWxlY3Rvcignc3BhbicpO1xuICAgIHNldElubmVySHRtbChsYWJlbCwgcGFyYW1zLmlucHV0UGxhY2Vob2xkZXIpO1xuICAgIHJldHVybiBjaGVja2JveENvbnRhaW5lcjtcbiAgfTtcblxuICByZW5kZXJJbnB1dFR5cGUudGV4dGFyZWEgPSBmdW5jdGlvbiAodGV4dGFyZWEsIHBhcmFtcykge1xuICAgIHRleHRhcmVhLnZhbHVlID0gcGFyYW1zLmlucHV0VmFsdWU7XG4gICAgc2V0SW5wdXRQbGFjZWhvbGRlcih0ZXh0YXJlYSwgcGFyYW1zKTtcblxuICAgIGlmICgnTXV0YXRpb25PYnNlcnZlcicgaW4gd2luZG93KSB7XG4gICAgICAvLyAjMTY5OVxuICAgICAgdmFyIGluaXRpYWxQb3B1cFdpZHRoID0gcGFyc2VJbnQod2luZG93LmdldENvbXB1dGVkU3R5bGUoZ2V0UG9wdXAoKSkud2lkdGgpO1xuICAgICAgdmFyIHBvcHVwUGFkZGluZyA9IHBhcnNlSW50KHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGdldFBvcHVwKCkpLnBhZGRpbmdMZWZ0KSArIHBhcnNlSW50KHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGdldFBvcHVwKCkpLnBhZGRpbmdSaWdodCk7XG5cbiAgICAgIHZhciBvdXRwdXRzaXplID0gZnVuY3Rpb24gb3V0cHV0c2l6ZSgpIHtcbiAgICAgICAgdmFyIGNvbnRlbnRXaWR0aCA9IHRleHRhcmVhLm9mZnNldFdpZHRoICsgcG9wdXBQYWRkaW5nO1xuXG4gICAgICAgIGlmIChjb250ZW50V2lkdGggPiBpbml0aWFsUG9wdXBXaWR0aCkge1xuICAgICAgICAgIGdldFBvcHVwKCkuc3R5bGUud2lkdGggPSBcIlwiLmNvbmNhdChjb250ZW50V2lkdGgsIFwicHhcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZ2V0UG9wdXAoKS5zdHlsZS53aWR0aCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIG5ldyBNdXRhdGlvbk9ic2VydmVyKG91dHB1dHNpemUpLm9ic2VydmUodGV4dGFyZWEsIHtcbiAgICAgICAgYXR0cmlidXRlczogdHJ1ZSxcbiAgICAgICAgYXR0cmlidXRlRmlsdGVyOiBbJ3N0eWxlJ11cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0ZXh0YXJlYTtcbiAgfTtcblxuICB2YXIgcmVuZGVyQ29udGVudCA9IGZ1bmN0aW9uIHJlbmRlckNvbnRlbnQoaW5zdGFuY2UsIHBhcmFtcykge1xuICAgIHZhciBjb250ZW50ID0gZ2V0Q29udGVudCgpLnF1ZXJ5U2VsZWN0b3IoXCIjXCIuY29uY2F0KHN3YWxDbGFzc2VzLmNvbnRlbnQpKTsgLy8gQ29udGVudCBhcyBIVE1MXG5cbiAgICBpZiAocGFyYW1zLmh0bWwpIHtcbiAgICAgIHBhcnNlSHRtbFRvQ29udGFpbmVyKHBhcmFtcy5odG1sLCBjb250ZW50KTtcbiAgICAgIHNob3coY29udGVudCwgJ2Jsb2NrJyk7IC8vIENvbnRlbnQgYXMgcGxhaW4gdGV4dFxuICAgIH0gZWxzZSBpZiAocGFyYW1zLnRleHQpIHtcbiAgICAgIGNvbnRlbnQudGV4dENvbnRlbnQgPSBwYXJhbXMudGV4dDtcbiAgICAgIHNob3coY29udGVudCwgJ2Jsb2NrJyk7IC8vIE5vIGNvbnRlbnRcbiAgICB9IGVsc2Uge1xuICAgICAgaGlkZShjb250ZW50KTtcbiAgICB9XG5cbiAgICByZW5kZXJJbnB1dChpbnN0YW5jZSwgcGFyYW1zKTsgLy8gQ3VzdG9tIGNsYXNzXG5cbiAgICBhcHBseUN1c3RvbUNsYXNzKGdldENvbnRlbnQoKSwgcGFyYW1zLCAnY29udGVudCcpO1xuICB9O1xuXG4gIHZhciByZW5kZXJGb290ZXIgPSBmdW5jdGlvbiByZW5kZXJGb290ZXIoaW5zdGFuY2UsIHBhcmFtcykge1xuICAgIHZhciBmb290ZXIgPSBnZXRGb290ZXIoKTtcbiAgICB0b2dnbGUoZm9vdGVyLCBwYXJhbXMuZm9vdGVyKTtcblxuICAgIGlmIChwYXJhbXMuZm9vdGVyKSB7XG4gICAgICBwYXJzZUh0bWxUb0NvbnRhaW5lcihwYXJhbXMuZm9vdGVyLCBmb290ZXIpO1xuICAgIH0gLy8gQ3VzdG9tIGNsYXNzXG5cblxuICAgIGFwcGx5Q3VzdG9tQ2xhc3MoZm9vdGVyLCBwYXJhbXMsICdmb290ZXInKTtcbiAgfTtcblxuICB2YXIgcmVuZGVyQ2xvc2VCdXR0b24gPSBmdW5jdGlvbiByZW5kZXJDbG9zZUJ1dHRvbihpbnN0YW5jZSwgcGFyYW1zKSB7XG4gICAgdmFyIGNsb3NlQnV0dG9uID0gZ2V0Q2xvc2VCdXR0b24oKTtcbiAgICBzZXRJbm5lckh0bWwoY2xvc2VCdXR0b24sIHBhcmFtcy5jbG9zZUJ1dHRvbkh0bWwpOyAvLyBDdXN0b20gY2xhc3NcblxuICAgIGFwcGx5Q3VzdG9tQ2xhc3MoY2xvc2VCdXR0b24sIHBhcmFtcywgJ2Nsb3NlQnV0dG9uJyk7XG4gICAgdG9nZ2xlKGNsb3NlQnV0dG9uLCBwYXJhbXMuc2hvd0Nsb3NlQnV0dG9uKTtcbiAgICBjbG9zZUJ1dHRvbi5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnLCBwYXJhbXMuY2xvc2VCdXR0b25BcmlhTGFiZWwpO1xuICB9O1xuXG4gIHZhciByZW5kZXJJY29uID0gZnVuY3Rpb24gcmVuZGVySWNvbihpbnN0YW5jZSwgcGFyYW1zKSB7XG4gICAgdmFyIGlubmVyUGFyYW1zID0gcHJpdmF0ZVByb3BzLmlubmVyUGFyYW1zLmdldChpbnN0YW5jZSk7IC8vIGlmIHRoZSBnaXZlIGljb24gYWxyZWFkeSByZW5kZXJlZCwgYXBwbHkgdGhlIGN1c3RvbSBjbGFzcyB3aXRob3V0IHJlLXJlbmRlcmluZyB0aGUgaWNvblxuXG4gICAgaWYgKGlubmVyUGFyYW1zICYmIHBhcmFtcy5pY29uID09PSBpbm5lclBhcmFtcy5pY29uICYmIGdldEljb24oKSkge1xuICAgICAgYXBwbHlDdXN0b21DbGFzcyhnZXRJY29uKCksIHBhcmFtcywgJ2ljb24nKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBoaWRlQWxsSWNvbnMoKTtcblxuICAgIGlmICghcGFyYW1zLmljb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoT2JqZWN0LmtleXMoaWNvblR5cGVzKS5pbmRleE9mKHBhcmFtcy5pY29uKSAhPT0gLTEpIHtcbiAgICAgIHZhciBpY29uID0gZWxlbWVudEJ5U2VsZWN0b3IoXCIuXCIuY29uY2F0KHN3YWxDbGFzc2VzLmljb24sIFwiLlwiKS5jb25jYXQoaWNvblR5cGVzW3BhcmFtcy5pY29uXSkpO1xuICAgICAgc2hvdyhpY29uKTsgLy8gQ3VzdG9tIG9yIGRlZmF1bHQgY29udGVudFxuXG4gICAgICBzZXRDb250ZW50KGljb24sIHBhcmFtcyk7XG4gICAgICBhZGp1c3RTdWNjZXNzSWNvbkJhY2tnb3VuZENvbG9yKCk7IC8vIEN1c3RvbSBjbGFzc1xuXG4gICAgICBhcHBseUN1c3RvbUNsYXNzKGljb24sIHBhcmFtcywgJ2ljb24nKTsgLy8gQW5pbWF0ZSBpY29uXG5cbiAgICAgIGFkZENsYXNzKGljb24sIHBhcmFtcy5zaG93Q2xhc3MuaWNvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVycm9yKFwiVW5rbm93biBpY29uISBFeHBlY3RlZCBcXFwic3VjY2Vzc1xcXCIsIFxcXCJlcnJvclxcXCIsIFxcXCJ3YXJuaW5nXFxcIiwgXFxcImluZm9cXFwiIG9yIFxcXCJxdWVzdGlvblxcXCIsIGdvdCBcXFwiXCIuY29uY2F0KHBhcmFtcy5pY29uLCBcIlxcXCJcIikpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgaGlkZUFsbEljb25zID0gZnVuY3Rpb24gaGlkZUFsbEljb25zKCkge1xuICAgIHZhciBpY29ucyA9IGdldEljb25zKCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGljb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBoaWRlKGljb25zW2ldKTtcbiAgICB9XG4gIH07IC8vIEFkanVzdCBzdWNjZXNzIGljb24gYmFja2dyb3VuZCBjb2xvciB0byBtYXRjaCB0aGUgcG9wdXAgYmFja2dyb3VuZCBjb2xvclxuXG5cbiAgdmFyIGFkanVzdFN1Y2Nlc3NJY29uQmFja2dvdW5kQ29sb3IgPSBmdW5jdGlvbiBhZGp1c3RTdWNjZXNzSWNvbkJhY2tnb3VuZENvbG9yKCkge1xuICAgIHZhciBwb3B1cCA9IGdldFBvcHVwKCk7XG4gICAgdmFyIHBvcHVwQmFja2dyb3VuZENvbG9yID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUocG9wdXApLmdldFByb3BlcnR5VmFsdWUoJ2JhY2tncm91bmQtY29sb3InKTtcbiAgICB2YXIgc3VjY2Vzc0ljb25QYXJ0cyA9IHBvcHVwLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tjbGFzc149c3dhbDItc3VjY2Vzcy1jaXJjdWxhci1saW5lXSwgLnN3YWwyLXN1Y2Nlc3MtZml4Jyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN1Y2Nlc3NJY29uUGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHN1Y2Nlc3NJY29uUGFydHNbaV0uc3R5bGUuYmFja2dyb3VuZENvbG9yID0gcG9wdXBCYWNrZ3JvdW5kQ29sb3I7XG4gICAgfVxuICB9O1xuXG4gIHZhciBzZXRDb250ZW50ID0gZnVuY3Rpb24gc2V0Q29udGVudChpY29uLCBwYXJhbXMpIHtcbiAgICBpY29uLnRleHRDb250ZW50ID0gJyc7XG5cbiAgICBpZiAocGFyYW1zLmljb25IdG1sKSB7XG4gICAgICBzZXRJbm5lckh0bWwoaWNvbiwgaWNvbkNvbnRlbnQocGFyYW1zLmljb25IdG1sKSk7XG4gICAgfSBlbHNlIGlmIChwYXJhbXMuaWNvbiA9PT0gJ3N1Y2Nlc3MnKSB7XG4gICAgICBzZXRJbm5lckh0bWwoaWNvbiwgXCJcXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJzd2FsMi1zdWNjZXNzLWNpcmN1bGFyLWxpbmUtbGVmdFxcXCI+PC9kaXY+XFxuICAgICAgPHNwYW4gY2xhc3M9XFxcInN3YWwyLXN1Y2Nlc3MtbGluZS10aXBcXFwiPjwvc3Bhbj4gPHNwYW4gY2xhc3M9XFxcInN3YWwyLXN1Y2Nlc3MtbGluZS1sb25nXFxcIj48L3NwYW4+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwic3dhbDItc3VjY2Vzcy1yaW5nXFxcIj48L2Rpdj4gPGRpdiBjbGFzcz1cXFwic3dhbDItc3VjY2Vzcy1maXhcXFwiPjwvZGl2PlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcInN3YWwyLXN1Y2Nlc3MtY2lyY3VsYXItbGluZS1yaWdodFxcXCI+PC9kaXY+XFxuICAgIFwiKTtcbiAgICB9IGVsc2UgaWYgKHBhcmFtcy5pY29uID09PSAnZXJyb3InKSB7XG4gICAgICBzZXRJbm5lckh0bWwoaWNvbiwgXCJcXG4gICAgICA8c3BhbiBjbGFzcz1cXFwic3dhbDIteC1tYXJrXFxcIj5cXG4gICAgICAgIDxzcGFuIGNsYXNzPVxcXCJzd2FsMi14LW1hcmstbGluZS1sZWZ0XFxcIj48L3NwYW4+XFxuICAgICAgICA8c3BhbiBjbGFzcz1cXFwic3dhbDIteC1tYXJrLWxpbmUtcmlnaHRcXFwiPjwvc3Bhbj5cXG4gICAgICA8L3NwYW4+XFxuICAgIFwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGRlZmF1bHRJY29uSHRtbCA9IHtcbiAgICAgICAgcXVlc3Rpb246ICc/JyxcbiAgICAgICAgd2FybmluZzogJyEnLFxuICAgICAgICBpbmZvOiAnaSdcbiAgICAgIH07XG4gICAgICBzZXRJbm5lckh0bWwoaWNvbiwgaWNvbkNvbnRlbnQoZGVmYXVsdEljb25IdG1sW3BhcmFtcy5pY29uXSkpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgaWNvbkNvbnRlbnQgPSBmdW5jdGlvbiBpY29uQ29udGVudChjb250ZW50KSB7XG4gICAgcmV0dXJuIFwiPGRpdiBjbGFzcz1cXFwiXCIuY29uY2F0KHN3YWxDbGFzc2VzWydpY29uLWNvbnRlbnQnXSwgXCJcXFwiPlwiKS5jb25jYXQoY29udGVudCwgXCI8L2Rpdj5cIik7XG4gIH07XG5cbiAgdmFyIHJlbmRlckltYWdlID0gZnVuY3Rpb24gcmVuZGVySW1hZ2UoaW5zdGFuY2UsIHBhcmFtcykge1xuICAgIHZhciBpbWFnZSA9IGdldEltYWdlKCk7XG5cbiAgICBpZiAoIXBhcmFtcy5pbWFnZVVybCkge1xuICAgICAgcmV0dXJuIGhpZGUoaW1hZ2UpO1xuICAgIH1cblxuICAgIHNob3coaW1hZ2UsICcnKTsgLy8gU3JjLCBhbHRcblxuICAgIGltYWdlLnNldEF0dHJpYnV0ZSgnc3JjJywgcGFyYW1zLmltYWdlVXJsKTtcbiAgICBpbWFnZS5zZXRBdHRyaWJ1dGUoJ2FsdCcsIHBhcmFtcy5pbWFnZUFsdCk7IC8vIFdpZHRoLCBoZWlnaHRcblxuICAgIGFwcGx5TnVtZXJpY2FsU3R5bGUoaW1hZ2UsICd3aWR0aCcsIHBhcmFtcy5pbWFnZVdpZHRoKTtcbiAgICBhcHBseU51bWVyaWNhbFN0eWxlKGltYWdlLCAnaGVpZ2h0JywgcGFyYW1zLmltYWdlSGVpZ2h0KTsgLy8gQ2xhc3NcblxuICAgIGltYWdlLmNsYXNzTmFtZSA9IHN3YWxDbGFzc2VzLmltYWdlO1xuICAgIGFwcGx5Q3VzdG9tQ2xhc3MoaW1hZ2UsIHBhcmFtcywgJ2ltYWdlJyk7XG4gIH07XG5cbiAgdmFyIGN1cnJlbnRTdGVwcyA9IFtdO1xuICAvKlxuICAgKiBHbG9iYWwgZnVuY3Rpb24gZm9yIGNoYWluaW5nIHN3ZWV0QWxlcnQgcG9wdXBzXG4gICAqL1xuXG4gIHZhciBxdWV1ZSA9IGZ1bmN0aW9uIHF1ZXVlKHN0ZXBzKSB7XG4gICAgdmFyIFN3YWwgPSB0aGlzO1xuICAgIGN1cnJlbnRTdGVwcyA9IHN0ZXBzO1xuXG4gICAgdmFyIHJlc2V0QW5kUmVzb2x2ZSA9IGZ1bmN0aW9uIHJlc2V0QW5kUmVzb2x2ZShyZXNvbHZlLCB2YWx1ZSkge1xuICAgICAgY3VycmVudFN0ZXBzID0gW107XG4gICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICB9O1xuXG4gICAgdmFyIHF1ZXVlUmVzdWx0ID0gW107XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAoZnVuY3Rpb24gc3RlcChpLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoaSA8IGN1cnJlbnRTdGVwcy5sZW5ndGgpIHtcbiAgICAgICAgICBkb2N1bWVudC5ib2R5LnNldEF0dHJpYnV0ZSgnZGF0YS1zd2FsMi1xdWV1ZS1zdGVwJywgaSk7XG4gICAgICAgICAgU3dhbC5maXJlKGN1cnJlbnRTdGVwc1tpXSkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJlc3VsdC52YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgcXVldWVSZXN1bHQucHVzaChyZXN1bHQudmFsdWUpO1xuICAgICAgICAgICAgICBzdGVwKGkgKyAxLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXNldEFuZFJlc29sdmUocmVzb2x2ZSwge1xuICAgICAgICAgICAgICAgIGRpc21pc3M6IHJlc3VsdC5kaXNtaXNzXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc2V0QW5kUmVzb2x2ZShyZXNvbHZlLCB7XG4gICAgICAgICAgICB2YWx1ZTogcXVldWVSZXN1bHRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSkoMCk7XG4gICAgfSk7XG4gIH07XG4gIC8qXG4gICAqIEdsb2JhbCBmdW5jdGlvbiBmb3IgZ2V0dGluZyB0aGUgaW5kZXggb2YgY3VycmVudCBwb3B1cCBpbiBxdWV1ZVxuICAgKi9cblxuICB2YXIgZ2V0UXVldWVTdGVwID0gZnVuY3Rpb24gZ2V0UXVldWVTdGVwKCkge1xuICAgIHJldHVybiBnZXRDb250YWluZXIoKSAmJiBnZXRDb250YWluZXIoKS5nZXRBdHRyaWJ1dGUoJ2RhdGEtcXVldWUtc3RlcCcpO1xuICB9O1xuICAvKlxuICAgKiBHbG9iYWwgZnVuY3Rpb24gZm9yIGluc2VydGluZyBhIHBvcHVwIHRvIHRoZSBxdWV1ZVxuICAgKi9cblxuICB2YXIgaW5zZXJ0UXVldWVTdGVwID0gZnVuY3Rpb24gaW5zZXJ0UXVldWVTdGVwKHN0ZXAsIGluZGV4KSB7XG4gICAgaWYgKGluZGV4ICYmIGluZGV4IDwgY3VycmVudFN0ZXBzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGN1cnJlbnRTdGVwcy5zcGxpY2UoaW5kZXgsIDAsIHN0ZXApO1xuICAgIH1cblxuICAgIHJldHVybiBjdXJyZW50U3RlcHMucHVzaChzdGVwKTtcbiAgfTtcbiAgLypcbiAgICogR2xvYmFsIGZ1bmN0aW9uIGZvciBkZWxldGluZyBhIHBvcHVwIGZyb20gdGhlIHF1ZXVlXG4gICAqL1xuXG4gIHZhciBkZWxldGVRdWV1ZVN0ZXAgPSBmdW5jdGlvbiBkZWxldGVRdWV1ZVN0ZXAoaW5kZXgpIHtcbiAgICBpZiAodHlwZW9mIGN1cnJlbnRTdGVwc1tpbmRleF0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjdXJyZW50U3RlcHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGNyZWF0ZVN0ZXBFbGVtZW50ID0gZnVuY3Rpb24gY3JlYXRlU3RlcEVsZW1lbnQoc3RlcCkge1xuICAgIHZhciBzdGVwRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaScpO1xuICAgIGFkZENsYXNzKHN0ZXBFbCwgc3dhbENsYXNzZXNbJ3Byb2dyZXNzLXN0ZXAnXSk7XG4gICAgc2V0SW5uZXJIdG1sKHN0ZXBFbCwgc3RlcCk7XG4gICAgcmV0dXJuIHN0ZXBFbDtcbiAgfTtcblxuICB2YXIgY3JlYXRlTGluZUVsZW1lbnQgPSBmdW5jdGlvbiBjcmVhdGVMaW5lRWxlbWVudChwYXJhbXMpIHtcbiAgICB2YXIgbGluZUVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKTtcbiAgICBhZGRDbGFzcyhsaW5lRWwsIHN3YWxDbGFzc2VzWydwcm9ncmVzcy1zdGVwLWxpbmUnXSk7XG5cbiAgICBpZiAocGFyYW1zLnByb2dyZXNzU3RlcHNEaXN0YW5jZSkge1xuICAgICAgbGluZUVsLnN0eWxlLndpZHRoID0gcGFyYW1zLnByb2dyZXNzU3RlcHNEaXN0YW5jZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbGluZUVsO1xuICB9O1xuXG4gIHZhciByZW5kZXJQcm9ncmVzc1N0ZXBzID0gZnVuY3Rpb24gcmVuZGVyUHJvZ3Jlc3NTdGVwcyhpbnN0YW5jZSwgcGFyYW1zKSB7XG4gICAgdmFyIHByb2dyZXNzU3RlcHNDb250YWluZXIgPSBnZXRQcm9ncmVzc1N0ZXBzKCk7XG5cbiAgICBpZiAoIXBhcmFtcy5wcm9ncmVzc1N0ZXBzIHx8IHBhcmFtcy5wcm9ncmVzc1N0ZXBzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGhpZGUocHJvZ3Jlc3NTdGVwc0NvbnRhaW5lcik7XG4gICAgfVxuXG4gICAgc2hvdyhwcm9ncmVzc1N0ZXBzQ29udGFpbmVyKTtcbiAgICBwcm9ncmVzc1N0ZXBzQ29udGFpbmVyLnRleHRDb250ZW50ID0gJyc7XG4gICAgdmFyIGN1cnJlbnRQcm9ncmVzc1N0ZXAgPSBwYXJzZUludChwYXJhbXMuY3VycmVudFByb2dyZXNzU3RlcCA9PT0gdW5kZWZpbmVkID8gZ2V0UXVldWVTdGVwKCkgOiBwYXJhbXMuY3VycmVudFByb2dyZXNzU3RlcCk7XG5cbiAgICBpZiAoY3VycmVudFByb2dyZXNzU3RlcCA+PSBwYXJhbXMucHJvZ3Jlc3NTdGVwcy5sZW5ndGgpIHtcbiAgICAgIHdhcm4oJ0ludmFsaWQgY3VycmVudFByb2dyZXNzU3RlcCBwYXJhbWV0ZXIsIGl0IHNob3VsZCBiZSBsZXNzIHRoYW4gcHJvZ3Jlc3NTdGVwcy5sZW5ndGggJyArICcoY3VycmVudFByb2dyZXNzU3RlcCBsaWtlIEpTIGFycmF5cyBzdGFydHMgZnJvbSAwKScpO1xuICAgIH1cblxuICAgIHBhcmFtcy5wcm9ncmVzc1N0ZXBzLmZvckVhY2goZnVuY3Rpb24gKHN0ZXAsIGluZGV4KSB7XG4gICAgICB2YXIgc3RlcEVsID0gY3JlYXRlU3RlcEVsZW1lbnQoc3RlcCk7XG4gICAgICBwcm9ncmVzc1N0ZXBzQ29udGFpbmVyLmFwcGVuZENoaWxkKHN0ZXBFbCk7XG5cbiAgICAgIGlmIChpbmRleCA9PT0gY3VycmVudFByb2dyZXNzU3RlcCkge1xuICAgICAgICBhZGRDbGFzcyhzdGVwRWwsIHN3YWxDbGFzc2VzWydhY3RpdmUtcHJvZ3Jlc3Mtc3RlcCddKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGluZGV4ICE9PSBwYXJhbXMucHJvZ3Jlc3NTdGVwcy5sZW5ndGggLSAxKSB7XG4gICAgICAgIHZhciBsaW5lRWwgPSBjcmVhdGVMaW5lRWxlbWVudChwYXJhbXMpO1xuICAgICAgICBwcm9ncmVzc1N0ZXBzQ29udGFpbmVyLmFwcGVuZENoaWxkKGxpbmVFbCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIHJlbmRlclRpdGxlID0gZnVuY3Rpb24gcmVuZGVyVGl0bGUoaW5zdGFuY2UsIHBhcmFtcykge1xuICAgIHZhciB0aXRsZSA9IGdldFRpdGxlKCk7XG4gICAgdG9nZ2xlKHRpdGxlLCBwYXJhbXMudGl0bGUgfHwgcGFyYW1zLnRpdGxlVGV4dCk7XG5cbiAgICBpZiAocGFyYW1zLnRpdGxlKSB7XG4gICAgICBwYXJzZUh0bWxUb0NvbnRhaW5lcihwYXJhbXMudGl0bGUsIHRpdGxlKTtcbiAgICB9XG5cbiAgICBpZiAocGFyYW1zLnRpdGxlVGV4dCkge1xuICAgICAgdGl0bGUuaW5uZXJUZXh0ID0gcGFyYW1zLnRpdGxlVGV4dDtcbiAgICB9IC8vIEN1c3RvbSBjbGFzc1xuXG5cbiAgICBhcHBseUN1c3RvbUNsYXNzKHRpdGxlLCBwYXJhbXMsICd0aXRsZScpO1xuICB9O1xuXG4gIHZhciByZW5kZXJIZWFkZXIgPSBmdW5jdGlvbiByZW5kZXJIZWFkZXIoaW5zdGFuY2UsIHBhcmFtcykge1xuICAgIHZhciBoZWFkZXIgPSBnZXRIZWFkZXIoKTsgLy8gQ3VzdG9tIGNsYXNzXG5cbiAgICBhcHBseUN1c3RvbUNsYXNzKGhlYWRlciwgcGFyYW1zLCAnaGVhZGVyJyk7IC8vIFByb2dyZXNzIHN0ZXBzXG5cbiAgICByZW5kZXJQcm9ncmVzc1N0ZXBzKGluc3RhbmNlLCBwYXJhbXMpOyAvLyBJY29uXG5cbiAgICByZW5kZXJJY29uKGluc3RhbmNlLCBwYXJhbXMpOyAvLyBJbWFnZVxuXG4gICAgcmVuZGVySW1hZ2UoaW5zdGFuY2UsIHBhcmFtcyk7IC8vIFRpdGxlXG5cbiAgICByZW5kZXJUaXRsZShpbnN0YW5jZSwgcGFyYW1zKTsgLy8gQ2xvc2UgYnV0dG9uXG5cbiAgICByZW5kZXJDbG9zZUJ1dHRvbihpbnN0YW5jZSwgcGFyYW1zKTtcbiAgfTtcblxuICB2YXIgcmVuZGVyUG9wdXAgPSBmdW5jdGlvbiByZW5kZXJQb3B1cChpbnN0YW5jZSwgcGFyYW1zKSB7XG4gICAgdmFyIHBvcHVwID0gZ2V0UG9wdXAoKTsgLy8gV2lkdGhcblxuICAgIGFwcGx5TnVtZXJpY2FsU3R5bGUocG9wdXAsICd3aWR0aCcsIHBhcmFtcy53aWR0aCk7IC8vIFBhZGRpbmdcblxuICAgIGFwcGx5TnVtZXJpY2FsU3R5bGUocG9wdXAsICdwYWRkaW5nJywgcGFyYW1zLnBhZGRpbmcpOyAvLyBCYWNrZ3JvdW5kXG5cbiAgICBpZiAocGFyYW1zLmJhY2tncm91bmQpIHtcbiAgICAgIHBvcHVwLnN0eWxlLmJhY2tncm91bmQgPSBwYXJhbXMuYmFja2dyb3VuZDtcbiAgICB9IC8vIENsYXNzZXNcblxuXG4gICAgYWRkQ2xhc3Nlcyhwb3B1cCwgcGFyYW1zKTtcbiAgfTtcblxuICB2YXIgYWRkQ2xhc3NlcyA9IGZ1bmN0aW9uIGFkZENsYXNzZXMocG9wdXAsIHBhcmFtcykge1xuICAgIC8vIERlZmF1bHQgQ2xhc3MgKyBzaG93Q2xhc3Mgd2hlbiB1cGRhdGluZyBTd2FsLnVwZGF0ZSh7fSlcbiAgICBwb3B1cC5jbGFzc05hbWUgPSBcIlwiLmNvbmNhdChzd2FsQ2xhc3Nlcy5wb3B1cCwgXCIgXCIpLmNvbmNhdChpc1Zpc2libGUocG9wdXApID8gcGFyYW1zLnNob3dDbGFzcy5wb3B1cCA6ICcnKTtcblxuICAgIGlmIChwYXJhbXMudG9hc3QpIHtcbiAgICAgIGFkZENsYXNzKFtkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIGRvY3VtZW50LmJvZHldLCBzd2FsQ2xhc3Nlc1sndG9hc3Qtc2hvd24nXSk7XG4gICAgICBhZGRDbGFzcyhwb3B1cCwgc3dhbENsYXNzZXMudG9hc3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhZGRDbGFzcyhwb3B1cCwgc3dhbENsYXNzZXMubW9kYWwpO1xuICAgIH0gLy8gQ3VzdG9tIGNsYXNzXG5cblxuICAgIGFwcGx5Q3VzdG9tQ2xhc3MocG9wdXAsIHBhcmFtcywgJ3BvcHVwJyk7XG5cbiAgICBpZiAodHlwZW9mIHBhcmFtcy5jdXN0b21DbGFzcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGFkZENsYXNzKHBvcHVwLCBwYXJhbXMuY3VzdG9tQ2xhc3MpO1xuICAgIH0gLy8gSWNvbiBjbGFzcyAoIzE4NDIpXG5cblxuICAgIGlmIChwYXJhbXMuaWNvbikge1xuICAgICAgYWRkQ2xhc3MocG9wdXAsIHN3YWxDbGFzc2VzW1wiaWNvbi1cIi5jb25jYXQocGFyYW1zLmljb24pXSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciByZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoaW5zdGFuY2UsIHBhcmFtcykge1xuICAgIHJlbmRlclBvcHVwKGluc3RhbmNlLCBwYXJhbXMpO1xuICAgIHJlbmRlckNvbnRhaW5lcihpbnN0YW5jZSwgcGFyYW1zKTtcbiAgICByZW5kZXJIZWFkZXIoaW5zdGFuY2UsIHBhcmFtcyk7XG4gICAgcmVuZGVyQ29udGVudChpbnN0YW5jZSwgcGFyYW1zKTtcbiAgICByZW5kZXJBY3Rpb25zKGluc3RhbmNlLCBwYXJhbXMpO1xuICAgIHJlbmRlckZvb3RlcihpbnN0YW5jZSwgcGFyYW1zKTtcblxuICAgIGlmICh0eXBlb2YgcGFyYW1zLm9uUmVuZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwYXJhbXMub25SZW5kZXIoZ2V0UG9wdXAoKSk7XG4gICAgfVxuICB9O1xuXG4gIC8qXG4gICAqIEdsb2JhbCBmdW5jdGlvbiB0byBkZXRlcm1pbmUgaWYgU3dlZXRBbGVydDIgcG9wdXAgaXMgc2hvd25cbiAgICovXG5cbiAgdmFyIGlzVmlzaWJsZSQxID0gZnVuY3Rpb24gaXNWaXNpYmxlJCQxKCkge1xuICAgIHJldHVybiBpc1Zpc2libGUoZ2V0UG9wdXAoKSk7XG4gIH07XG4gIC8qXG4gICAqIEdsb2JhbCBmdW5jdGlvbiB0byBjbGljayAnQ29uZmlybScgYnV0dG9uXG4gICAqL1xuXG4gIHZhciBjbGlja0NvbmZpcm0gPSBmdW5jdGlvbiBjbGlja0NvbmZpcm0oKSB7XG4gICAgcmV0dXJuIGdldENvbmZpcm1CdXR0b24oKSAmJiBnZXRDb25maXJtQnV0dG9uKCkuY2xpY2soKTtcbiAgfTtcbiAgLypcbiAgICogR2xvYmFsIGZ1bmN0aW9uIHRvIGNsaWNrICdDYW5jZWwnIGJ1dHRvblxuICAgKi9cblxuICB2YXIgY2xpY2tDYW5jZWwgPSBmdW5jdGlvbiBjbGlja0NhbmNlbCgpIHtcbiAgICByZXR1cm4gZ2V0Q2FuY2VsQnV0dG9uKCkgJiYgZ2V0Q2FuY2VsQnV0dG9uKCkuY2xpY2soKTtcbiAgfTtcblxuICBmdW5jdGlvbiBmaXJlKCkge1xuICAgIHZhciBTd2FsID0gdGhpcztcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gX2NvbnN0cnVjdChTd2FsLCBhcmdzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGV4dGVuZGVkIHZlcnNpb24gb2YgYFN3YWxgIGNvbnRhaW5pbmcgYHBhcmFtc2AgYXMgZGVmYXVsdHMuXG4gICAqIFVzZWZ1bCBmb3IgcmV1c2luZyBTd2FsIGNvbmZpZ3VyYXRpb24uXG4gICAqXG4gICAqIEZvciBleGFtcGxlOlxuICAgKlxuICAgKiBCZWZvcmU6XG4gICAqIGNvbnN0IHRleHRQcm9tcHRPcHRpb25zID0geyBpbnB1dDogJ3RleHQnLCBzaG93Q2FuY2VsQnV0dG9uOiB0cnVlIH1cbiAgICogY29uc3Qge3ZhbHVlOiBmaXJzdE5hbWV9ID0gYXdhaXQgU3dhbC5maXJlKHsgLi4udGV4dFByb21wdE9wdGlvbnMsIHRpdGxlOiAnV2hhdCBpcyB5b3VyIGZpcnN0IG5hbWU/JyB9KVxuICAgKiBjb25zdCB7dmFsdWU6IGxhc3ROYW1lfSA9IGF3YWl0IFN3YWwuZmlyZSh7IC4uLnRleHRQcm9tcHRPcHRpb25zLCB0aXRsZTogJ1doYXQgaXMgeW91ciBsYXN0IG5hbWU/JyB9KVxuICAgKlxuICAgKiBBZnRlcjpcbiAgICogY29uc3QgVGV4dFByb21wdCA9IFN3YWwubWl4aW4oeyBpbnB1dDogJ3RleHQnLCBzaG93Q2FuY2VsQnV0dG9uOiB0cnVlIH0pXG4gICAqIGNvbnN0IHt2YWx1ZTogZmlyc3ROYW1lfSA9IGF3YWl0IFRleHRQcm9tcHQoJ1doYXQgaXMgeW91ciBmaXJzdCBuYW1lPycpXG4gICAqIGNvbnN0IHt2YWx1ZTogbGFzdE5hbWV9ID0gYXdhaXQgVGV4dFByb21wdCgnV2hhdCBpcyB5b3VyIGxhc3QgbmFtZT8nKVxuICAgKlxuICAgKiBAcGFyYW0gbWl4aW5QYXJhbXNcbiAgICovXG4gIGZ1bmN0aW9uIG1peGluKG1peGluUGFyYW1zKSB7XG4gICAgdmFyIE1peGluU3dhbCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX3RoaXMpIHtcbiAgICAgIF9pbmhlcml0cyhNaXhpblN3YWwsIF90aGlzKTtcblxuICAgICAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihNaXhpblN3YWwpO1xuXG4gICAgICBmdW5jdGlvbiBNaXhpblN3YWwoKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNaXhpblN3YWwpO1xuXG4gICAgICAgIHJldHVybiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgX2NyZWF0ZUNsYXNzKE1peGluU3dhbCwgW3tcbiAgICAgICAga2V5OiBcIl9tYWluXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfbWFpbihwYXJhbXMpIHtcbiAgICAgICAgICByZXR1cm4gX2dldChfZ2V0UHJvdG90eXBlT2YoTWl4aW5Td2FsLnByb3RvdHlwZSksIFwiX21haW5cIiwgdGhpcykuY2FsbCh0aGlzLCBfZXh0ZW5kcyh7fSwgbWl4aW5QYXJhbXMsIHBhcmFtcykpO1xuICAgICAgICB9XG4gICAgICB9XSk7XG5cbiAgICAgIHJldHVybiBNaXhpblN3YWw7XG4gICAgfSh0aGlzKTtcblxuICAgIHJldHVybiBNaXhpblN3YWw7XG4gIH1cblxuICAvKipcbiAgICogU2hvdyBzcGlubmVyIGluc3RlYWQgb2YgQ29uZmlybSBidXR0b25cbiAgICovXG5cbiAgdmFyIHNob3dMb2FkaW5nID0gZnVuY3Rpb24gc2hvd0xvYWRpbmcoKSB7XG4gICAgdmFyIHBvcHVwID0gZ2V0UG9wdXAoKTtcblxuICAgIGlmICghcG9wdXApIHtcbiAgICAgIFN3YWwuZmlyZSgpO1xuICAgIH1cblxuICAgIHBvcHVwID0gZ2V0UG9wdXAoKTtcbiAgICB2YXIgYWN0aW9ucyA9IGdldEFjdGlvbnMoKTtcbiAgICB2YXIgY29uZmlybUJ1dHRvbiA9IGdldENvbmZpcm1CdXR0b24oKTtcbiAgICBzaG93KGFjdGlvbnMpO1xuICAgIHNob3coY29uZmlybUJ1dHRvbiwgJ2lubGluZS1ibG9jaycpO1xuICAgIGFkZENsYXNzKFtwb3B1cCwgYWN0aW9uc10sIHN3YWxDbGFzc2VzLmxvYWRpbmcpO1xuICAgIGNvbmZpcm1CdXR0b24uZGlzYWJsZWQgPSB0cnVlO1xuICAgIHBvcHVwLnNldEF0dHJpYnV0ZSgnZGF0YS1sb2FkaW5nJywgdHJ1ZSk7XG4gICAgcG9wdXAuc2V0QXR0cmlidXRlKCdhcmlhLWJ1c3knLCB0cnVlKTtcbiAgICBwb3B1cC5mb2N1cygpO1xuICB9O1xuXG4gIHZhciBSRVNUT1JFX0ZPQ1VTX1RJTUVPVVQgPSAxMDA7XG5cbiAgdmFyIGdsb2JhbFN0YXRlID0ge307XG5cbiAgdmFyIGZvY3VzUHJldmlvdXNBY3RpdmVFbGVtZW50ID0gZnVuY3Rpb24gZm9jdXNQcmV2aW91c0FjdGl2ZUVsZW1lbnQoKSB7XG4gICAgaWYgKGdsb2JhbFN0YXRlLnByZXZpb3VzQWN0aXZlRWxlbWVudCAmJiBnbG9iYWxTdGF0ZS5wcmV2aW91c0FjdGl2ZUVsZW1lbnQuZm9jdXMpIHtcbiAgICAgIGdsb2JhbFN0YXRlLnByZXZpb3VzQWN0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgICAgZ2xvYmFsU3RhdGUucHJldmlvdXNBY3RpdmVFbGVtZW50ID0gbnVsbDtcbiAgICB9IGVsc2UgaWYgKGRvY3VtZW50LmJvZHkpIHtcbiAgICAgIGRvY3VtZW50LmJvZHkuZm9jdXMoKTtcbiAgICB9XG4gIH07IC8vIFJlc3RvcmUgcHJldmlvdXMgYWN0aXZlIChmb2N1c2VkKSBlbGVtZW50XG5cblxuICB2YXIgcmVzdG9yZUFjdGl2ZUVsZW1lbnQgPSBmdW5jdGlvbiByZXN0b3JlQWN0aXZlRWxlbWVudCgpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgIHZhciB4ID0gd2luZG93LnNjcm9sbFg7XG4gICAgICB2YXIgeSA9IHdpbmRvdy5zY3JvbGxZO1xuICAgICAgZ2xvYmFsU3RhdGUucmVzdG9yZUZvY3VzVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBmb2N1c1ByZXZpb3VzQWN0aXZlRWxlbWVudCgpO1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9LCBSRVNUT1JFX0ZPQ1VTX1RJTUVPVVQpOyAvLyBpc3N1ZXMvOTAwXG5cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuXG4gICAgICBpZiAodHlwZW9mIHggIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAvLyBJRSBkb2Vzbid0IGhhdmUgc2Nyb2xsWC9zY3JvbGxZIHN1cHBvcnRcbiAgICAgICAgd2luZG93LnNjcm9sbFRvKHgsIHkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBJZiBgdGltZXJgIHBhcmFtZXRlciBpcyBzZXQsIHJldHVybnMgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBvZiB0aW1lciByZW1haW5lZC5cbiAgICogT3RoZXJ3aXNlLCByZXR1cm5zIHVuZGVmaW5lZC5cbiAgICovXG5cbiAgdmFyIGdldFRpbWVyTGVmdCA9IGZ1bmN0aW9uIGdldFRpbWVyTGVmdCgpIHtcbiAgICByZXR1cm4gZ2xvYmFsU3RhdGUudGltZW91dCAmJiBnbG9iYWxTdGF0ZS50aW1lb3V0LmdldFRpbWVyTGVmdCgpO1xuICB9O1xuICAvKipcbiAgICogU3RvcCB0aW1lci4gUmV0dXJucyBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIG9mIHRpbWVyIHJlbWFpbmVkLlxuICAgKiBJZiBgdGltZXJgIHBhcmFtZXRlciBpc24ndCBzZXQsIHJldHVybnMgdW5kZWZpbmVkLlxuICAgKi9cblxuICB2YXIgc3RvcFRpbWVyID0gZnVuY3Rpb24gc3RvcFRpbWVyKCkge1xuICAgIGlmIChnbG9iYWxTdGF0ZS50aW1lb3V0KSB7XG4gICAgICBzdG9wVGltZXJQcm9ncmVzc0JhcigpO1xuICAgICAgcmV0dXJuIGdsb2JhbFN0YXRlLnRpbWVvdXQuc3RvcCgpO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIFJlc3VtZSB0aW1lci4gUmV0dXJucyBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIG9mIHRpbWVyIHJlbWFpbmVkLlxuICAgKiBJZiBgdGltZXJgIHBhcmFtZXRlciBpc24ndCBzZXQsIHJldHVybnMgdW5kZWZpbmVkLlxuICAgKi9cblxuICB2YXIgcmVzdW1lVGltZXIgPSBmdW5jdGlvbiByZXN1bWVUaW1lcigpIHtcbiAgICBpZiAoZ2xvYmFsU3RhdGUudGltZW91dCkge1xuICAgICAgdmFyIHJlbWFpbmluZyA9IGdsb2JhbFN0YXRlLnRpbWVvdXQuc3RhcnQoKTtcbiAgICAgIGFuaW1hdGVUaW1lclByb2dyZXNzQmFyKHJlbWFpbmluZyk7XG4gICAgICByZXR1cm4gcmVtYWluaW5nO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIFJlc3VtZSB0aW1lci4gUmV0dXJucyBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIG9mIHRpbWVyIHJlbWFpbmVkLlxuICAgKiBJZiBgdGltZXJgIHBhcmFtZXRlciBpc24ndCBzZXQsIHJldHVybnMgdW5kZWZpbmVkLlxuICAgKi9cblxuICB2YXIgdG9nZ2xlVGltZXIgPSBmdW5jdGlvbiB0b2dnbGVUaW1lcigpIHtcbiAgICB2YXIgdGltZXIgPSBnbG9iYWxTdGF0ZS50aW1lb3V0O1xuICAgIHJldHVybiB0aW1lciAmJiAodGltZXIucnVubmluZyA/IHN0b3BUaW1lcigpIDogcmVzdW1lVGltZXIoKSk7XG4gIH07XG4gIC8qKlxuICAgKiBJbmNyZWFzZSB0aW1lci4gUmV0dXJucyBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIG9mIGFuIHVwZGF0ZWQgdGltZXIuXG4gICAqIElmIGB0aW1lcmAgcGFyYW1ldGVyIGlzbid0IHNldCwgcmV0dXJucyB1bmRlZmluZWQuXG4gICAqL1xuXG4gIHZhciBpbmNyZWFzZVRpbWVyID0gZnVuY3Rpb24gaW5jcmVhc2VUaW1lcihuKSB7XG4gICAgaWYgKGdsb2JhbFN0YXRlLnRpbWVvdXQpIHtcbiAgICAgIHZhciByZW1haW5pbmcgPSBnbG9iYWxTdGF0ZS50aW1lb3V0LmluY3JlYXNlKG4pO1xuICAgICAgYW5pbWF0ZVRpbWVyUHJvZ3Jlc3NCYXIocmVtYWluaW5nLCB0cnVlKTtcbiAgICAgIHJldHVybiByZW1haW5pbmc7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogQ2hlY2sgaWYgdGltZXIgaXMgcnVubmluZy4gUmV0dXJucyB0cnVlIGlmIHRpbWVyIGlzIHJ1bm5pbmdcbiAgICogb3IgZmFsc2UgaWYgdGltZXIgaXMgcGF1c2VkIG9yIHN0b3BwZWQuXG4gICAqIElmIGB0aW1lcmAgcGFyYW1ldGVyIGlzbid0IHNldCwgcmV0dXJucyB1bmRlZmluZWRcbiAgICovXG5cbiAgdmFyIGlzVGltZXJSdW5uaW5nID0gZnVuY3Rpb24gaXNUaW1lclJ1bm5pbmcoKSB7XG4gICAgcmV0dXJuIGdsb2JhbFN0YXRlLnRpbWVvdXQgJiYgZ2xvYmFsU3RhdGUudGltZW91dC5pc1J1bm5pbmcoKTtcbiAgfTtcblxuICB2YXIgZGVmYXVsdFBhcmFtcyA9IHtcbiAgICB0aXRsZTogJycsXG4gICAgdGl0bGVUZXh0OiAnJyxcbiAgICB0ZXh0OiAnJyxcbiAgICBodG1sOiAnJyxcbiAgICBmb290ZXI6ICcnLFxuICAgIGljb246IHVuZGVmaW5lZCxcbiAgICBpY29uSHRtbDogdW5kZWZpbmVkLFxuICAgIHRvYXN0OiBmYWxzZSxcbiAgICBhbmltYXRpb246IHRydWUsXG4gICAgc2hvd0NsYXNzOiB7XG4gICAgICBwb3B1cDogJ3N3YWwyLXNob3cnLFxuICAgICAgYmFja2Ryb3A6ICdzd2FsMi1iYWNrZHJvcC1zaG93JyxcbiAgICAgIGljb246ICdzd2FsMi1pY29uLXNob3cnXG4gICAgfSxcbiAgICBoaWRlQ2xhc3M6IHtcbiAgICAgIHBvcHVwOiAnc3dhbDItaGlkZScsXG4gICAgICBiYWNrZHJvcDogJ3N3YWwyLWJhY2tkcm9wLWhpZGUnLFxuICAgICAgaWNvbjogJ3N3YWwyLWljb24taGlkZSdcbiAgICB9LFxuICAgIGN1c3RvbUNsYXNzOiB1bmRlZmluZWQsXG4gICAgdGFyZ2V0OiAnYm9keScsXG4gICAgYmFja2Ryb3A6IHRydWUsXG4gICAgaGVpZ2h0QXV0bzogdHJ1ZSxcbiAgICBhbGxvd091dHNpZGVDbGljazogdHJ1ZSxcbiAgICBhbGxvd0VzY2FwZUtleTogdHJ1ZSxcbiAgICBhbGxvd0VudGVyS2V5OiB0cnVlLFxuICAgIHN0b3BLZXlkb3duUHJvcGFnYXRpb246IHRydWUsXG4gICAga2V5ZG93bkxpc3RlbmVyQ2FwdHVyZTogZmFsc2UsXG4gICAgc2hvd0NvbmZpcm1CdXR0b246IHRydWUsXG4gICAgc2hvd0NhbmNlbEJ1dHRvbjogZmFsc2UsXG4gICAgcHJlQ29uZmlybTogdW5kZWZpbmVkLFxuICAgIGNvbmZpcm1CdXR0b25UZXh0OiAnT0snLFxuICAgIGNvbmZpcm1CdXR0b25BcmlhTGFiZWw6ICcnLFxuICAgIGNvbmZpcm1CdXR0b25Db2xvcjogdW5kZWZpbmVkLFxuICAgIGNhbmNlbEJ1dHRvblRleHQ6ICdDYW5jZWwnLFxuICAgIGNhbmNlbEJ1dHRvbkFyaWFMYWJlbDogJycsXG4gICAgY2FuY2VsQnV0dG9uQ29sb3I6IHVuZGVmaW5lZCxcbiAgICBidXR0b25zU3R5bGluZzogdHJ1ZSxcbiAgICByZXZlcnNlQnV0dG9uczogZmFsc2UsXG4gICAgZm9jdXNDb25maXJtOiB0cnVlLFxuICAgIGZvY3VzQ2FuY2VsOiBmYWxzZSxcbiAgICBzaG93Q2xvc2VCdXR0b246IGZhbHNlLFxuICAgIGNsb3NlQnV0dG9uSHRtbDogJyZ0aW1lczsnLFxuICAgIGNsb3NlQnV0dG9uQXJpYUxhYmVsOiAnQ2xvc2UgdGhpcyBkaWFsb2cnLFxuICAgIHNob3dMb2FkZXJPbkNvbmZpcm06IGZhbHNlLFxuICAgIGltYWdlVXJsOiB1bmRlZmluZWQsXG4gICAgaW1hZ2VXaWR0aDogdW5kZWZpbmVkLFxuICAgIGltYWdlSGVpZ2h0OiB1bmRlZmluZWQsXG4gICAgaW1hZ2VBbHQ6ICcnLFxuICAgIHRpbWVyOiB1bmRlZmluZWQsXG4gICAgdGltZXJQcm9ncmVzc0JhcjogZmFsc2UsXG4gICAgd2lkdGg6IHVuZGVmaW5lZCxcbiAgICBwYWRkaW5nOiB1bmRlZmluZWQsXG4gICAgYmFja2dyb3VuZDogdW5kZWZpbmVkLFxuICAgIGlucHV0OiB1bmRlZmluZWQsXG4gICAgaW5wdXRQbGFjZWhvbGRlcjogJycsXG4gICAgaW5wdXRWYWx1ZTogJycsXG4gICAgaW5wdXRPcHRpb25zOiB7fSxcbiAgICBpbnB1dEF1dG9UcmltOiB0cnVlLFxuICAgIGlucHV0QXR0cmlidXRlczoge30sXG4gICAgaW5wdXRWYWxpZGF0b3I6IHVuZGVmaW5lZCxcbiAgICB2YWxpZGF0aW9uTWVzc2FnZTogdW5kZWZpbmVkLFxuICAgIGdyb3c6IGZhbHNlLFxuICAgIHBvc2l0aW9uOiAnY2VudGVyJyxcbiAgICBwcm9ncmVzc1N0ZXBzOiBbXSxcbiAgICBjdXJyZW50UHJvZ3Jlc3NTdGVwOiB1bmRlZmluZWQsXG4gICAgcHJvZ3Jlc3NTdGVwc0Rpc3RhbmNlOiB1bmRlZmluZWQsXG4gICAgb25CZWZvcmVPcGVuOiB1bmRlZmluZWQsXG4gICAgb25PcGVuOiB1bmRlZmluZWQsXG4gICAgb25SZW5kZXI6IHVuZGVmaW5lZCxcbiAgICBvbkNsb3NlOiB1bmRlZmluZWQsXG4gICAgb25BZnRlckNsb3NlOiB1bmRlZmluZWQsXG4gICAgb25EZXN0cm95OiB1bmRlZmluZWQsXG4gICAgc2Nyb2xsYmFyUGFkZGluZzogdHJ1ZVxuICB9O1xuICB2YXIgdXBkYXRhYmxlUGFyYW1zID0gWydhbGxvd0VzY2FwZUtleScsICdhbGxvd091dHNpZGVDbGljaycsICdidXR0b25zU3R5bGluZycsICdjYW5jZWxCdXR0b25BcmlhTGFiZWwnLCAnY2FuY2VsQnV0dG9uQ29sb3InLCAnY2FuY2VsQnV0dG9uVGV4dCcsICdjbG9zZUJ1dHRvbkFyaWFMYWJlbCcsICdjbG9zZUJ1dHRvbkh0bWwnLCAnY29uZmlybUJ1dHRvbkFyaWFMYWJlbCcsICdjb25maXJtQnV0dG9uQ29sb3InLCAnY29uZmlybUJ1dHRvblRleHQnLCAnY3VycmVudFByb2dyZXNzU3RlcCcsICdjdXN0b21DbGFzcycsICdmb290ZXInLCAnaGlkZUNsYXNzJywgJ2h0bWwnLCAnaWNvbicsICdpbWFnZUFsdCcsICdpbWFnZUhlaWdodCcsICdpbWFnZVVybCcsICdpbWFnZVdpZHRoJywgJ29uQWZ0ZXJDbG9zZScsICdvbkNsb3NlJywgJ29uRGVzdHJveScsICdwcm9ncmVzc1N0ZXBzJywgJ3JldmVyc2VCdXR0b25zJywgJ3Nob3dDYW5jZWxCdXR0b24nLCAnc2hvd0Nsb3NlQnV0dG9uJywgJ3Nob3dDb25maXJtQnV0dG9uJywgJ3RleHQnLCAndGl0bGUnLCAndGl0bGVUZXh0J107XG4gIHZhciBkZXByZWNhdGVkUGFyYW1zID0ge1xuICAgIGFuaW1hdGlvbjogJ3Nob3dDbGFzc1wiIGFuZCBcImhpZGVDbGFzcydcbiAgfTtcbiAgdmFyIHRvYXN0SW5jb21wYXRpYmxlUGFyYW1zID0gWydhbGxvd091dHNpZGVDbGljaycsICdhbGxvd0VudGVyS2V5JywgJ2JhY2tkcm9wJywgJ2ZvY3VzQ29uZmlybScsICdmb2N1c0NhbmNlbCcsICdoZWlnaHRBdXRvJywgJ2tleWRvd25MaXN0ZW5lckNhcHR1cmUnXTtcbiAgLyoqXG4gICAqIElzIHZhbGlkIHBhcmFtZXRlclxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1OYW1lXG4gICAqL1xuXG4gIHZhciBpc1ZhbGlkUGFyYW1ldGVyID0gZnVuY3Rpb24gaXNWYWxpZFBhcmFtZXRlcihwYXJhbU5hbWUpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGRlZmF1bHRQYXJhbXMsIHBhcmFtTmFtZSk7XG4gIH07XG4gIC8qKlxuICAgKiBJcyB2YWxpZCBwYXJhbWV0ZXIgZm9yIFN3YWwudXBkYXRlKCkgbWV0aG9kXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbU5hbWVcbiAgICovXG5cbiAgdmFyIGlzVXBkYXRhYmxlUGFyYW1ldGVyID0gZnVuY3Rpb24gaXNVcGRhdGFibGVQYXJhbWV0ZXIocGFyYW1OYW1lKSB7XG4gICAgcmV0dXJuIHVwZGF0YWJsZVBhcmFtcy5pbmRleE9mKHBhcmFtTmFtZSkgIT09IC0xO1xuICB9O1xuICAvKipcbiAgICogSXMgZGVwcmVjYXRlZCBwYXJhbWV0ZXJcbiAgICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtTmFtZVxuICAgKi9cblxuICB2YXIgaXNEZXByZWNhdGVkUGFyYW1ldGVyID0gZnVuY3Rpb24gaXNEZXByZWNhdGVkUGFyYW1ldGVyKHBhcmFtTmFtZSkge1xuICAgIHJldHVybiBkZXByZWNhdGVkUGFyYW1zW3BhcmFtTmFtZV07XG4gIH07XG5cbiAgdmFyIGNoZWNrSWZQYXJhbUlzVmFsaWQgPSBmdW5jdGlvbiBjaGVja0lmUGFyYW1Jc1ZhbGlkKHBhcmFtKSB7XG4gICAgaWYgKCFpc1ZhbGlkUGFyYW1ldGVyKHBhcmFtKSkge1xuICAgICAgd2FybihcIlVua25vd24gcGFyYW1ldGVyIFxcXCJcIi5jb25jYXQocGFyYW0sIFwiXFxcIlwiKSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBjaGVja0lmVG9hc3RQYXJhbUlzVmFsaWQgPSBmdW5jdGlvbiBjaGVja0lmVG9hc3RQYXJhbUlzVmFsaWQocGFyYW0pIHtcbiAgICBpZiAodG9hc3RJbmNvbXBhdGlibGVQYXJhbXMuaW5kZXhPZihwYXJhbSkgIT09IC0xKSB7XG4gICAgICB3YXJuKFwiVGhlIHBhcmFtZXRlciBcXFwiXCIuY29uY2F0KHBhcmFtLCBcIlxcXCIgaXMgaW5jb21wYXRpYmxlIHdpdGggdG9hc3RzXCIpKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGNoZWNrSWZQYXJhbUlzRGVwcmVjYXRlZCA9IGZ1bmN0aW9uIGNoZWNrSWZQYXJhbUlzRGVwcmVjYXRlZChwYXJhbSkge1xuICAgIGlmIChpc0RlcHJlY2F0ZWRQYXJhbWV0ZXIocGFyYW0pKSB7XG4gICAgICB3YXJuQWJvdXREZXByZWF0aW9uKHBhcmFtLCBpc0RlcHJlY2F0ZWRQYXJhbWV0ZXIocGFyYW0pKTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBTaG93IHJlbGV2YW50IHdhcm5pbmdzIGZvciBnaXZlbiBwYXJhbXNcbiAgICpcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKi9cblxuXG4gIHZhciBzaG93V2FybmluZ3NGb3JQYXJhbXMgPSBmdW5jdGlvbiBzaG93V2FybmluZ3NGb3JQYXJhbXMocGFyYW1zKSB7XG4gICAgZm9yICh2YXIgcGFyYW0gaW4gcGFyYW1zKSB7XG4gICAgICBjaGVja0lmUGFyYW1Jc1ZhbGlkKHBhcmFtKTtcblxuICAgICAgaWYgKHBhcmFtcy50b2FzdCkge1xuICAgICAgICBjaGVja0lmVG9hc3RQYXJhbUlzVmFsaWQocGFyYW0pO1xuICAgICAgfVxuXG4gICAgICBjaGVja0lmUGFyYW1Jc0RlcHJlY2F0ZWQocGFyYW0pO1xuICAgIH1cbiAgfTtcblxuXG5cbiAgdmFyIHN0YXRpY01ldGhvZHMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgaXNWYWxpZFBhcmFtZXRlcjogaXNWYWxpZFBhcmFtZXRlcixcbiAgICBpc1VwZGF0YWJsZVBhcmFtZXRlcjogaXNVcGRhdGFibGVQYXJhbWV0ZXIsXG4gICAgaXNEZXByZWNhdGVkUGFyYW1ldGVyOiBpc0RlcHJlY2F0ZWRQYXJhbWV0ZXIsXG4gICAgYXJnc1RvUGFyYW1zOiBhcmdzVG9QYXJhbXMsXG4gICAgaXNWaXNpYmxlOiBpc1Zpc2libGUkMSxcbiAgICBjbGlja0NvbmZpcm06IGNsaWNrQ29uZmlybSxcbiAgICBjbGlja0NhbmNlbDogY2xpY2tDYW5jZWwsXG4gICAgZ2V0Q29udGFpbmVyOiBnZXRDb250YWluZXIsXG4gICAgZ2V0UG9wdXA6IGdldFBvcHVwLFxuICAgIGdldFRpdGxlOiBnZXRUaXRsZSxcbiAgICBnZXRDb250ZW50OiBnZXRDb250ZW50LFxuICAgIGdldEh0bWxDb250YWluZXI6IGdldEh0bWxDb250YWluZXIsXG4gICAgZ2V0SW1hZ2U6IGdldEltYWdlLFxuICAgIGdldEljb246IGdldEljb24sXG4gICAgZ2V0SWNvbnM6IGdldEljb25zLFxuICAgIGdldENsb3NlQnV0dG9uOiBnZXRDbG9zZUJ1dHRvbixcbiAgICBnZXRBY3Rpb25zOiBnZXRBY3Rpb25zLFxuICAgIGdldENvbmZpcm1CdXR0b246IGdldENvbmZpcm1CdXR0b24sXG4gICAgZ2V0Q2FuY2VsQnV0dG9uOiBnZXRDYW5jZWxCdXR0b24sXG4gICAgZ2V0SGVhZGVyOiBnZXRIZWFkZXIsXG4gICAgZ2V0Rm9vdGVyOiBnZXRGb290ZXIsXG4gICAgZ2V0VGltZXJQcm9ncmVzc0JhcjogZ2V0VGltZXJQcm9ncmVzc0JhcixcbiAgICBnZXRGb2N1c2FibGVFbGVtZW50czogZ2V0Rm9jdXNhYmxlRWxlbWVudHMsXG4gICAgZ2V0VmFsaWRhdGlvbk1lc3NhZ2U6IGdldFZhbGlkYXRpb25NZXNzYWdlLFxuICAgIGlzTG9hZGluZzogaXNMb2FkaW5nLFxuICAgIGZpcmU6IGZpcmUsXG4gICAgbWl4aW46IG1peGluLFxuICAgIHF1ZXVlOiBxdWV1ZSxcbiAgICBnZXRRdWV1ZVN0ZXA6IGdldFF1ZXVlU3RlcCxcbiAgICBpbnNlcnRRdWV1ZVN0ZXA6IGluc2VydFF1ZXVlU3RlcCxcbiAgICBkZWxldGVRdWV1ZVN0ZXA6IGRlbGV0ZVF1ZXVlU3RlcCxcbiAgICBzaG93TG9hZGluZzogc2hvd0xvYWRpbmcsXG4gICAgZW5hYmxlTG9hZGluZzogc2hvd0xvYWRpbmcsXG4gICAgZ2V0VGltZXJMZWZ0OiBnZXRUaW1lckxlZnQsXG4gICAgc3RvcFRpbWVyOiBzdG9wVGltZXIsXG4gICAgcmVzdW1lVGltZXI6IHJlc3VtZVRpbWVyLFxuICAgIHRvZ2dsZVRpbWVyOiB0b2dnbGVUaW1lcixcbiAgICBpbmNyZWFzZVRpbWVyOiBpbmNyZWFzZVRpbWVyLFxuICAgIGlzVGltZXJSdW5uaW5nOiBpc1RpbWVyUnVubmluZ1xuICB9KTtcblxuICAvKipcbiAgICogRW5hYmxlcyBidXR0b25zIGFuZCBoaWRlIGxvYWRlci5cbiAgICovXG5cbiAgZnVuY3Rpb24gaGlkZUxvYWRpbmcoKSB7XG4gICAgLy8gZG8gbm90aGluZyBpZiBwb3B1cCBpcyBjbG9zZWRcbiAgICB2YXIgaW5uZXJQYXJhbXMgPSBwcml2YXRlUHJvcHMuaW5uZXJQYXJhbXMuZ2V0KHRoaXMpO1xuXG4gICAgaWYgKCFpbm5lclBhcmFtcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBkb21DYWNoZSA9IHByaXZhdGVQcm9wcy5kb21DYWNoZS5nZXQodGhpcyk7XG5cbiAgICBpZiAoIWlubmVyUGFyYW1zLnNob3dDb25maXJtQnV0dG9uKSB7XG4gICAgICBoaWRlKGRvbUNhY2hlLmNvbmZpcm1CdXR0b24pO1xuXG4gICAgICBpZiAoIWlubmVyUGFyYW1zLnNob3dDYW5jZWxCdXR0b24pIHtcbiAgICAgICAgaGlkZShkb21DYWNoZS5hY3Rpb25zKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZW1vdmVDbGFzcyhbZG9tQ2FjaGUucG9wdXAsIGRvbUNhY2hlLmFjdGlvbnNdLCBzd2FsQ2xhc3Nlcy5sb2FkaW5nKTtcbiAgICBkb21DYWNoZS5wb3B1cC5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtYnVzeScpO1xuICAgIGRvbUNhY2hlLnBvcHVwLnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1sb2FkaW5nJyk7XG4gICAgZG9tQ2FjaGUuY29uZmlybUJ1dHRvbi5kaXNhYmxlZCA9IGZhbHNlO1xuICAgIGRvbUNhY2hlLmNhbmNlbEJ1dHRvbi5kaXNhYmxlZCA9IGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0SW5wdXQkMShpbnN0YW5jZSkge1xuICAgIHZhciBpbm5lclBhcmFtcyA9IHByaXZhdGVQcm9wcy5pbm5lclBhcmFtcy5nZXQoaW5zdGFuY2UgfHwgdGhpcyk7XG4gICAgdmFyIGRvbUNhY2hlID0gcHJpdmF0ZVByb3BzLmRvbUNhY2hlLmdldChpbnN0YW5jZSB8fCB0aGlzKTtcblxuICAgIGlmICghZG9tQ2FjaGUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBnZXRJbnB1dChkb21DYWNoZS5jb250ZW50LCBpbm5lclBhcmFtcy5pbnB1dCk7XG4gIH1cblxuICB2YXIgZml4U2Nyb2xsYmFyID0gZnVuY3Rpb24gZml4U2Nyb2xsYmFyKCkge1xuICAgIC8vIGZvciBxdWV1ZXMsIGRvIG5vdCBkbyB0aGlzIG1vcmUgdGhhbiBvbmNlXG4gICAgaWYgKHN0YXRlcy5wcmV2aW91c0JvZHlQYWRkaW5nICE9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBpZiB0aGUgYm9keSBoYXMgb3ZlcmZsb3dcblxuXG4gICAgaWYgKGRvY3VtZW50LmJvZHkuc2Nyb2xsSGVpZ2h0ID4gd2luZG93LmlubmVySGVpZ2h0KSB7XG4gICAgICAvLyBhZGQgcGFkZGluZyBzbyB0aGUgY29udGVudCBkb2Vzbid0IHNoaWZ0IGFmdGVyIHJlbW92YWwgb2Ygc2Nyb2xsYmFyXG4gICAgICBzdGF0ZXMucHJldmlvdXNCb2R5UGFkZGluZyA9IHBhcnNlSW50KHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRvY3VtZW50LmJvZHkpLmdldFByb3BlcnR5VmFsdWUoJ3BhZGRpbmctcmlnaHQnKSk7XG4gICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLnBhZGRpbmdSaWdodCA9IFwiXCIuY29uY2F0KHN0YXRlcy5wcmV2aW91c0JvZHlQYWRkaW5nICsgbWVhc3VyZVNjcm9sbGJhcigpLCBcInB4XCIpO1xuICAgIH1cbiAgfTtcbiAgdmFyIHVuZG9TY3JvbGxiYXIgPSBmdW5jdGlvbiB1bmRvU2Nyb2xsYmFyKCkge1xuICAgIGlmIChzdGF0ZXMucHJldmlvdXNCb2R5UGFkZGluZyAhPT0gbnVsbCkge1xuICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5wYWRkaW5nUmlnaHQgPSBcIlwiLmNvbmNhdChzdGF0ZXMucHJldmlvdXNCb2R5UGFkZGluZywgXCJweFwiKTtcbiAgICAgIHN0YXRlcy5wcmV2aW91c0JvZHlQYWRkaW5nID0gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGZpbGUgKi9cblxuICB2YXIgaU9TZml4ID0gZnVuY3Rpb24gaU9TZml4KCkge1xuICAgIHZhciBpT1MgPSAvaVBhZHxpUGhvbmV8aVBvZC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJiAhd2luZG93Lk1TU3RyZWFtIHx8IG5hdmlnYXRvci5wbGF0Zm9ybSA9PT0gJ01hY0ludGVsJyAmJiBuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgPiAxO1xuXG4gICAgaWYgKGlPUyAmJiAhaGFzQ2xhc3MoZG9jdW1lbnQuYm9keSwgc3dhbENsYXNzZXMuaW9zZml4KSkge1xuICAgICAgdmFyIG9mZnNldCA9IGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wO1xuICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS50b3AgPSBcIlwiLmNvbmNhdChvZmZzZXQgKiAtMSwgXCJweFwiKTtcbiAgICAgIGFkZENsYXNzKGRvY3VtZW50LmJvZHksIHN3YWxDbGFzc2VzLmlvc2ZpeCk7XG4gICAgICBsb2NrQm9keVNjcm9sbCgpO1xuICAgICAgYWRkQm90dG9tUGFkZGluZ0ZvclRhbGxQb3B1cHMoKTsgLy8gIzE5NDhcbiAgICB9XG4gIH07XG5cbiAgdmFyIGFkZEJvdHRvbVBhZGRpbmdGb3JUYWxsUG9wdXBzID0gZnVuY3Rpb24gYWRkQm90dG9tUGFkZGluZ0ZvclRhbGxQb3B1cHMoKSB7XG4gICAgdmFyIHNhZmFyaSA9ICFuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC8oQ3JpT1N8RnhpT1N8RWRnaU9TfFlhQnJvd3NlcnxVQ0Jyb3dzZXIpL2kpO1xuXG4gICAgaWYgKHNhZmFyaSkge1xuICAgICAgdmFyIGJvdHRvbVBhbmVsSGVpZ2h0ID0gNDQ7XG5cbiAgICAgIGlmIChnZXRQb3B1cCgpLnNjcm9sbEhlaWdodCA+IHdpbmRvdy5pbm5lckhlaWdodCAtIGJvdHRvbVBhbmVsSGVpZ2h0KSB7XG4gICAgICAgIGdldENvbnRhaW5lcigpLnN0eWxlLnBhZGRpbmdCb3R0b20gPSBcIlwiLmNvbmNhdChib3R0b21QYW5lbEhlaWdodCwgXCJweFwiKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFyIGxvY2tCb2R5U2Nyb2xsID0gZnVuY3Rpb24gbG9ja0JvZHlTY3JvbGwoKSB7XG4gICAgLy8gIzEyNDZcbiAgICB2YXIgY29udGFpbmVyID0gZ2V0Q29udGFpbmVyKCk7XG4gICAgdmFyIHByZXZlbnRUb3VjaE1vdmU7XG5cbiAgICBjb250YWluZXIub250b3VjaHN0YXJ0ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHByZXZlbnRUb3VjaE1vdmUgPSBzaG91bGRQcmV2ZW50VG91Y2hNb3ZlKGUudGFyZ2V0KTtcbiAgICB9O1xuXG4gICAgY29udGFpbmVyLm9udG91Y2htb3ZlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmIChwcmV2ZW50VG91Y2hNb3ZlKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIHZhciBzaG91bGRQcmV2ZW50VG91Y2hNb3ZlID0gZnVuY3Rpb24gc2hvdWxkUHJldmVudFRvdWNoTW92ZSh0YXJnZXQpIHtcbiAgICB2YXIgY29udGFpbmVyID0gZ2V0Q29udGFpbmVyKCk7XG5cbiAgICBpZiAodGFyZ2V0ID09PSBjb250YWluZXIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmICghaXNTY3JvbGxhYmxlKGNvbnRhaW5lcikgJiYgdGFyZ2V0LnRhZ05hbWUgIT09ICdJTlBVVCcgJiYgLy8gIzE2MDNcbiAgICAhKGlzU2Nyb2xsYWJsZShnZXRDb250ZW50KCkpICYmIC8vICMxOTQ0XG4gICAgZ2V0Q29udGVudCgpLmNvbnRhaW5zKHRhcmdldCkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgdmFyIHVuZG9JT1NmaXggPSBmdW5jdGlvbiB1bmRvSU9TZml4KCkge1xuICAgIGlmIChoYXNDbGFzcyhkb2N1bWVudC5ib2R5LCBzd2FsQ2xhc3Nlcy5pb3NmaXgpKSB7XG4gICAgICB2YXIgb2Zmc2V0ID0gcGFyc2VJbnQoZG9jdW1lbnQuYm9keS5zdHlsZS50b3AsIDEwKTtcbiAgICAgIHJlbW92ZUNsYXNzKGRvY3VtZW50LmJvZHksIHN3YWxDbGFzc2VzLmlvc2ZpeCk7XG4gICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLnRvcCA9ICcnO1xuICAgICAgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3AgPSBvZmZzZXQgKiAtMTtcbiAgICB9XG4gIH07XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGZpbGUgKi9cblxuICB2YXIgaXNJRTExID0gZnVuY3Rpb24gaXNJRTExKCkge1xuICAgIHJldHVybiAhIXdpbmRvdy5NU0lucHV0TWV0aG9kQ29udGV4dCAmJiAhIWRvY3VtZW50LmRvY3VtZW50TW9kZTtcbiAgfTsgLy8gRml4IElFMTEgY2VudGVyaW5nIHN3ZWV0YWxlcnQyL2lzc3Vlcy85MzNcblxuXG4gIHZhciBmaXhWZXJ0aWNhbFBvc2l0aW9uSUUgPSBmdW5jdGlvbiBmaXhWZXJ0aWNhbFBvc2l0aW9uSUUoKSB7XG4gICAgdmFyIGNvbnRhaW5lciA9IGdldENvbnRhaW5lcigpO1xuICAgIHZhciBwb3B1cCA9IGdldFBvcHVwKCk7XG4gICAgY29udGFpbmVyLnN0eWxlLnJlbW92ZVByb3BlcnR5KCdhbGlnbi1pdGVtcycpO1xuXG4gICAgaWYgKHBvcHVwLm9mZnNldFRvcCA8IDApIHtcbiAgICAgIGNvbnRhaW5lci5zdHlsZS5hbGlnbkl0ZW1zID0gJ2ZsZXgtc3RhcnQnO1xuICAgIH1cbiAgfTtcblxuICB2YXIgSUVmaXggPSBmdW5jdGlvbiBJRWZpeCgpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNJRTExKCkpIHtcbiAgICAgIGZpeFZlcnRpY2FsUG9zaXRpb25JRSgpO1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGZpeFZlcnRpY2FsUG9zaXRpb25JRSk7XG4gICAgfVxuICB9O1xuICB2YXIgdW5kb0lFZml4ID0gZnVuY3Rpb24gdW5kb0lFZml4KCkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiBpc0lFMTEoKSkge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGZpeFZlcnRpY2FsUG9zaXRpb25JRSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIEFkZGluZyBhcmlhLWhpZGRlbj1cInRydWVcIiB0byBlbGVtZW50cyBvdXRzaWRlIG9mIHRoZSBhY3RpdmUgbW9kYWwgZGlhbG9nIGVuc3VyZXMgdGhhdFxuICAvLyBlbGVtZW50cyBub3Qgd2l0aGluIHRoZSBhY3RpdmUgbW9kYWwgZGlhbG9nIHdpbGwgbm90IGJlIHN1cmZhY2VkIGlmIGEgdXNlciBvcGVucyBhIHNjcmVlblxuICAvLyByZWFkZXLigJlzIGxpc3Qgb2YgZWxlbWVudHMgKGhlYWRpbmdzLCBmb3JtIGNvbnRyb2xzLCBsYW5kbWFya3MsIGV0Yy4pIGluIHRoZSBkb2N1bWVudC5cblxuICB2YXIgc2V0QXJpYUhpZGRlbiA9IGZ1bmN0aW9uIHNldEFyaWFIaWRkZW4oKSB7XG4gICAgdmFyIGJvZHlDaGlsZHJlbiA9IHRvQXJyYXkoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gICAgYm9keUNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICBpZiAoZWwgPT09IGdldENvbnRhaW5lcigpIHx8IGNvbnRhaW5zKGVsLCBnZXRDb250YWluZXIoKSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoZWwuaGFzQXR0cmlidXRlKCdhcmlhLWhpZGRlbicpKSB7XG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZSgnZGF0YS1wcmV2aW91cy1hcmlhLWhpZGRlbicsIGVsLmdldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nKSk7XG4gICAgICB9XG5cbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCAndHJ1ZScpO1xuICAgIH0pO1xuICB9O1xuICB2YXIgdW5zZXRBcmlhSGlkZGVuID0gZnVuY3Rpb24gdW5zZXRBcmlhSGlkZGVuKCkge1xuICAgIHZhciBib2R5Q2hpbGRyZW4gPSB0b0FycmF5KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICAgIGJvZHlDaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgaWYgKGVsLmhhc0F0dHJpYnV0ZSgnZGF0YS1wcmV2aW91cy1hcmlhLWhpZGRlbicpKSB7XG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCBlbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtcHJldmlvdXMtYXJpYS1oaWRkZW4nKSk7XG4gICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1wcmV2aW91cy1hcmlhLWhpZGRlbicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWhpZGRlbicpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIG1vZHVsZSBjb250YWludHMgYFdlYWtNYXBgcyBmb3IgZWFjaCBlZmZlY3RpdmVseS1cInByaXZhdGUgIHByb3BlcnR5XCIgdGhhdCBhIGBTd2FsYCBoYXMuXG4gICAqIEZvciBleGFtcGxlLCB0byBzZXQgdGhlIHByaXZhdGUgcHJvcGVydHkgXCJmb29cIiBvZiBgdGhpc2AgdG8gXCJiYXJcIiwgeW91IGNhbiBgcHJpdmF0ZVByb3BzLmZvby5zZXQodGhpcywgJ2JhcicpYFxuICAgKiBUaGlzIGlzIHRoZSBhcHByb2FjaCB0aGF0IEJhYmVsIHdpbGwgcHJvYmFibHkgdGFrZSB0byBpbXBsZW1lbnQgcHJpdmF0ZSBtZXRob2RzL2ZpZWxkc1xuICAgKiAgIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXByaXZhdGUtbWV0aG9kc1xuICAgKiAgIGh0dHBzOi8vZ2l0aHViLmNvbS9iYWJlbC9iYWJlbC9wdWxsLzc1NTVcbiAgICogT25jZSB3ZSBoYXZlIHRoZSBjaGFuZ2VzIGZyb20gdGhhdCBQUiBpbiBCYWJlbCwgYW5kIG91ciBjb3JlIGNsYXNzIGZpdHMgcmVhc29uYWJsZSBpbiAqb25lIG1vZHVsZSpcbiAgICogICB0aGVuIHdlIGNhbiB1c2UgdGhhdCBsYW5ndWFnZSBmZWF0dXJlLlxuICAgKi9cbiAgdmFyIHByaXZhdGVNZXRob2RzID0ge1xuICAgIHN3YWxQcm9taXNlUmVzb2x2ZTogbmV3IFdlYWtNYXAoKVxuICB9O1xuXG4gIC8qXG4gICAqIEluc3RhbmNlIG1ldGhvZCB0byBjbG9zZSBzd2VldEFsZXJ0XG4gICAqL1xuXG4gIGZ1bmN0aW9uIHJlbW92ZVBvcHVwQW5kUmVzZXRTdGF0ZShpbnN0YW5jZSwgY29udGFpbmVyLCBpc1RvYXN0JCQxLCBvbkFmdGVyQ2xvc2UpIHtcbiAgICBpZiAoaXNUb2FzdCQkMSkge1xuICAgICAgdHJpZ2dlck9uQWZ0ZXJDbG9zZUFuZERpc3Bvc2UoaW5zdGFuY2UsIG9uQWZ0ZXJDbG9zZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3RvcmVBY3RpdmVFbGVtZW50KCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0cmlnZ2VyT25BZnRlckNsb3NlQW5kRGlzcG9zZShpbnN0YW5jZSwgb25BZnRlckNsb3NlKTtcbiAgICAgIH0pO1xuICAgICAgZ2xvYmFsU3RhdGUua2V5ZG93blRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZ2xvYmFsU3RhdGUua2V5ZG93bkhhbmRsZXIsIHtcbiAgICAgICAgY2FwdHVyZTogZ2xvYmFsU3RhdGUua2V5ZG93bkxpc3RlbmVyQ2FwdHVyZVxuICAgICAgfSk7XG4gICAgICBnbG9iYWxTdGF0ZS5rZXlkb3duSGFuZGxlckFkZGVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGNvbnRhaW5lci5wYXJlbnROb2RlICYmICFkb2N1bWVudC5ib2R5LmdldEF0dHJpYnV0ZSgnZGF0YS1zd2FsMi1xdWV1ZS1zdGVwJykpIHtcbiAgICAgIGNvbnRhaW5lci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNvbnRhaW5lcik7XG4gICAgfVxuXG4gICAgaWYgKGlzTW9kYWwoKSkge1xuICAgICAgdW5kb1Njcm9sbGJhcigpO1xuICAgICAgdW5kb0lPU2ZpeCgpO1xuICAgICAgdW5kb0lFZml4KCk7XG4gICAgICB1bnNldEFyaWFIaWRkZW4oKTtcbiAgICB9XG5cbiAgICByZW1vdmVCb2R5Q2xhc3NlcygpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlQm9keUNsYXNzZXMoKSB7XG4gICAgcmVtb3ZlQ2xhc3MoW2RvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgZG9jdW1lbnQuYm9keV0sIFtzd2FsQ2xhc3Nlcy5zaG93biwgc3dhbENsYXNzZXNbJ2hlaWdodC1hdXRvJ10sIHN3YWxDbGFzc2VzWyduby1iYWNrZHJvcCddLCBzd2FsQ2xhc3Nlc1sndG9hc3Qtc2hvd24nXSwgc3dhbENsYXNzZXNbJ3RvYXN0LWNvbHVtbiddXSk7XG4gIH1cblxuICBmdW5jdGlvbiBjbG9zZShyZXNvbHZlVmFsdWUpIHtcbiAgICB2YXIgcG9wdXAgPSBnZXRQb3B1cCgpO1xuXG4gICAgaWYgKCFwb3B1cCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBpbm5lclBhcmFtcyA9IHByaXZhdGVQcm9wcy5pbm5lclBhcmFtcy5nZXQodGhpcyk7XG5cbiAgICBpZiAoIWlubmVyUGFyYW1zIHx8IGhhc0NsYXNzKHBvcHVwLCBpbm5lclBhcmFtcy5oaWRlQ2xhc3MucG9wdXApKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHN3YWxQcm9taXNlUmVzb2x2ZSA9IHByaXZhdGVNZXRob2RzLnN3YWxQcm9taXNlUmVzb2x2ZS5nZXQodGhpcyk7XG4gICAgcmVtb3ZlQ2xhc3MocG9wdXAsIGlubmVyUGFyYW1zLnNob3dDbGFzcy5wb3B1cCk7XG4gICAgYWRkQ2xhc3MocG9wdXAsIGlubmVyUGFyYW1zLmhpZGVDbGFzcy5wb3B1cCk7XG4gICAgdmFyIGJhY2tkcm9wID0gZ2V0Q29udGFpbmVyKCk7XG4gICAgcmVtb3ZlQ2xhc3MoYmFja2Ryb3AsIGlubmVyUGFyYW1zLnNob3dDbGFzcy5iYWNrZHJvcCk7XG4gICAgYWRkQ2xhc3MoYmFja2Ryb3AsIGlubmVyUGFyYW1zLmhpZGVDbGFzcy5iYWNrZHJvcCk7XG4gICAgaGFuZGxlUG9wdXBBbmltYXRpb24odGhpcywgcG9wdXAsIGlubmVyUGFyYW1zKTtcblxuICAgIGlmICh0eXBlb2YgcmVzb2x2ZVZhbHVlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmVzb2x2ZVZhbHVlLmlzRGlzbWlzc2VkID0gdHlwZW9mIHJlc29sdmVWYWx1ZS5kaXNtaXNzICE9PSAndW5kZWZpbmVkJztcbiAgICAgIHJlc29sdmVWYWx1ZS5pc0NvbmZpcm1lZCA9IHR5cGVvZiByZXNvbHZlVmFsdWUuZGlzbWlzcyA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc29sdmVWYWx1ZSA9IHtcbiAgICAgICAgaXNEaXNtaXNzZWQ6IHRydWUsXG4gICAgICAgIGlzQ29uZmlybWVkOiBmYWxzZVxuICAgICAgfTtcbiAgICB9IC8vIFJlc29sdmUgU3dhbCBwcm9taXNlXG5cblxuICAgIHN3YWxQcm9taXNlUmVzb2x2ZShyZXNvbHZlVmFsdWUgfHwge30pO1xuICB9XG5cbiAgdmFyIGhhbmRsZVBvcHVwQW5pbWF0aW9uID0gZnVuY3Rpb24gaGFuZGxlUG9wdXBBbmltYXRpb24oaW5zdGFuY2UsIHBvcHVwLCBpbm5lclBhcmFtcykge1xuICAgIHZhciBjb250YWluZXIgPSBnZXRDb250YWluZXIoKTsgLy8gSWYgYW5pbWF0aW9uIGlzIHN1cHBvcnRlZCwgYW5pbWF0ZVxuXG4gICAgdmFyIGFuaW1hdGlvbklzU3VwcG9ydGVkID0gYW5pbWF0aW9uRW5kRXZlbnQgJiYgaGFzQ3NzQW5pbWF0aW9uKHBvcHVwKTtcbiAgICB2YXIgb25DbG9zZSA9IGlubmVyUGFyYW1zLm9uQ2xvc2UsXG4gICAgICAgIG9uQWZ0ZXJDbG9zZSA9IGlubmVyUGFyYW1zLm9uQWZ0ZXJDbG9zZTtcblxuICAgIGlmIChvbkNsb3NlICE9PSBudWxsICYmIHR5cGVvZiBvbkNsb3NlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBvbkNsb3NlKHBvcHVwKTtcbiAgICB9XG5cbiAgICBpZiAoYW5pbWF0aW9uSXNTdXBwb3J0ZWQpIHtcbiAgICAgIGFuaW1hdGVQb3B1cChpbnN0YW5jZSwgcG9wdXAsIGNvbnRhaW5lciwgb25BZnRlckNsb3NlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gT3RoZXJ3aXNlLCByZW1vdmUgaW1tZWRpYXRlbHlcbiAgICAgIHJlbW92ZVBvcHVwQW5kUmVzZXRTdGF0ZShpbnN0YW5jZSwgY29udGFpbmVyLCBpc1RvYXN0KCksIG9uQWZ0ZXJDbG9zZSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBhbmltYXRlUG9wdXAgPSBmdW5jdGlvbiBhbmltYXRlUG9wdXAoaW5zdGFuY2UsIHBvcHVwLCBjb250YWluZXIsIG9uQWZ0ZXJDbG9zZSkge1xuICAgIGdsb2JhbFN0YXRlLnN3YWxDbG9zZUV2ZW50RmluaXNoZWRDYWxsYmFjayA9IHJlbW92ZVBvcHVwQW5kUmVzZXRTdGF0ZS5iaW5kKG51bGwsIGluc3RhbmNlLCBjb250YWluZXIsIGlzVG9hc3QoKSwgb25BZnRlckNsb3NlKTtcbiAgICBwb3B1cC5hZGRFdmVudExpc3RlbmVyKGFuaW1hdGlvbkVuZEV2ZW50LCBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKGUudGFyZ2V0ID09PSBwb3B1cCkge1xuICAgICAgICBnbG9iYWxTdGF0ZS5zd2FsQ2xvc2VFdmVudEZpbmlzaGVkQ2FsbGJhY2soKTtcbiAgICAgICAgZGVsZXRlIGdsb2JhbFN0YXRlLnN3YWxDbG9zZUV2ZW50RmluaXNoZWRDYWxsYmFjaztcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICB2YXIgdHJpZ2dlck9uQWZ0ZXJDbG9zZUFuZERpc3Bvc2UgPSBmdW5jdGlvbiB0cmlnZ2VyT25BZnRlckNsb3NlQW5kRGlzcG9zZShpbnN0YW5jZSwgb25BZnRlckNsb3NlKSB7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodHlwZW9mIG9uQWZ0ZXJDbG9zZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBvbkFmdGVyQ2xvc2UoKTtcbiAgICAgIH1cblxuICAgICAgaW5zdGFuY2UuX2Rlc3Ryb3koKTtcbiAgICB9KTtcbiAgfTtcblxuICBmdW5jdGlvbiBzZXRCdXR0b25zRGlzYWJsZWQoaW5zdGFuY2UsIGJ1dHRvbnMsIGRpc2FibGVkKSB7XG4gICAgdmFyIGRvbUNhY2hlID0gcHJpdmF0ZVByb3BzLmRvbUNhY2hlLmdldChpbnN0YW5jZSk7XG4gICAgYnV0dG9ucy5mb3JFYWNoKGZ1bmN0aW9uIChidXR0b24pIHtcbiAgICAgIGRvbUNhY2hlW2J1dHRvbl0uZGlzYWJsZWQgPSBkaXNhYmxlZDtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldElucHV0RGlzYWJsZWQoaW5wdXQsIGRpc2FibGVkKSB7XG4gICAgaWYgKCFpbnB1dCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChpbnB1dC50eXBlID09PSAncmFkaW8nKSB7XG4gICAgICB2YXIgcmFkaW9zQ29udGFpbmVyID0gaW5wdXQucGFyZW50Tm9kZS5wYXJlbnROb2RlO1xuICAgICAgdmFyIHJhZGlvcyA9IHJhZGlvc0NvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dCcpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhZGlvcy5sZW5ndGg7IGkrKykge1xuICAgICAgICByYWRpb3NbaV0uZGlzYWJsZWQgPSBkaXNhYmxlZDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaW5wdXQuZGlzYWJsZWQgPSBkaXNhYmxlZDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBlbmFibGVCdXR0b25zKCkge1xuICAgIHNldEJ1dHRvbnNEaXNhYmxlZCh0aGlzLCBbJ2NvbmZpcm1CdXR0b24nLCAnY2FuY2VsQnV0dG9uJ10sIGZhbHNlKTtcbiAgfVxuICBmdW5jdGlvbiBkaXNhYmxlQnV0dG9ucygpIHtcbiAgICBzZXRCdXR0b25zRGlzYWJsZWQodGhpcywgWydjb25maXJtQnV0dG9uJywgJ2NhbmNlbEJ1dHRvbiddLCB0cnVlKTtcbiAgfVxuICBmdW5jdGlvbiBlbmFibGVJbnB1dCgpIHtcbiAgICByZXR1cm4gc2V0SW5wdXREaXNhYmxlZCh0aGlzLmdldElucHV0KCksIGZhbHNlKTtcbiAgfVxuICBmdW5jdGlvbiBkaXNhYmxlSW5wdXQoKSB7XG4gICAgcmV0dXJuIHNldElucHV0RGlzYWJsZWQodGhpcy5nZXRJbnB1dCgpLCB0cnVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNob3dWYWxpZGF0aW9uTWVzc2FnZShlcnJvcikge1xuICAgIHZhciBkb21DYWNoZSA9IHByaXZhdGVQcm9wcy5kb21DYWNoZS5nZXQodGhpcyk7XG4gICAgc2V0SW5uZXJIdG1sKGRvbUNhY2hlLnZhbGlkYXRpb25NZXNzYWdlLCBlcnJvcik7XG4gICAgdmFyIHBvcHVwQ29tcHV0ZWRTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRvbUNhY2hlLnBvcHVwKTtcbiAgICBkb21DYWNoZS52YWxpZGF0aW9uTWVzc2FnZS5zdHlsZS5tYXJnaW5MZWZ0ID0gXCItXCIuY29uY2F0KHBvcHVwQ29tcHV0ZWRTdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCdwYWRkaW5nLWxlZnQnKSk7XG4gICAgZG9tQ2FjaGUudmFsaWRhdGlvbk1lc3NhZ2Uuc3R5bGUubWFyZ2luUmlnaHQgPSBcIi1cIi5jb25jYXQocG9wdXBDb21wdXRlZFN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ3BhZGRpbmctcmlnaHQnKSk7XG4gICAgc2hvdyhkb21DYWNoZS52YWxpZGF0aW9uTWVzc2FnZSk7XG4gICAgdmFyIGlucHV0ID0gdGhpcy5nZXRJbnB1dCgpO1xuXG4gICAgaWYgKGlucHV0KSB7XG4gICAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoJ2FyaWEtaW52YWxpZCcsIHRydWUpO1xuICAgICAgaW5wdXQuc2V0QXR0cmlidXRlKCdhcmlhLWRlc2NyaWJlZEJ5Jywgc3dhbENsYXNzZXNbJ3ZhbGlkYXRpb24tbWVzc2FnZSddKTtcbiAgICAgIGZvY3VzSW5wdXQoaW5wdXQpO1xuICAgICAgYWRkQ2xhc3MoaW5wdXQsIHN3YWxDbGFzc2VzLmlucHV0ZXJyb3IpO1xuICAgIH1cbiAgfSAvLyBIaWRlIGJsb2NrIHdpdGggdmFsaWRhdGlvbiBtZXNzYWdlXG5cbiAgZnVuY3Rpb24gcmVzZXRWYWxpZGF0aW9uTWVzc2FnZSQxKCkge1xuICAgIHZhciBkb21DYWNoZSA9IHByaXZhdGVQcm9wcy5kb21DYWNoZS5nZXQodGhpcyk7XG5cbiAgICBpZiAoZG9tQ2FjaGUudmFsaWRhdGlvbk1lc3NhZ2UpIHtcbiAgICAgIGhpZGUoZG9tQ2FjaGUudmFsaWRhdGlvbk1lc3NhZ2UpO1xuICAgIH1cblxuICAgIHZhciBpbnB1dCA9IHRoaXMuZ2V0SW5wdXQoKTtcblxuICAgIGlmIChpbnB1dCkge1xuICAgICAgaW5wdXQucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWludmFsaWQnKTtcbiAgICAgIGlucHV0LnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1kZXNjcmliZWRCeScpO1xuICAgICAgcmVtb3ZlQ2xhc3MoaW5wdXQsIHN3YWxDbGFzc2VzLmlucHV0ZXJyb3IpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFByb2dyZXNzU3RlcHMkMSgpIHtcbiAgICB2YXIgZG9tQ2FjaGUgPSBwcml2YXRlUHJvcHMuZG9tQ2FjaGUuZ2V0KHRoaXMpO1xuICAgIHJldHVybiBkb21DYWNoZS5wcm9ncmVzc1N0ZXBzO1xuICB9XG5cbiAgdmFyIFRpbWVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUaW1lcihjYWxsYmFjaywgZGVsYXkpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUaW1lcik7XG5cbiAgICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgIHRoaXMucmVtYWluaW5nID0gZGVsYXk7XG4gICAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgIHRoaXMuc3RhcnQoKTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoVGltZXIsIFt7XG4gICAgICBrZXk6IFwic3RhcnRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzdGFydCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnJ1bm5pbmcpIHtcbiAgICAgICAgICB0aGlzLnJ1bm5pbmcgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuc3RhcnRlZCA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgdGhpcy5pZCA9IHNldFRpbWVvdXQodGhpcy5jYWxsYmFjaywgdGhpcy5yZW1haW5pbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucmVtYWluaW5nO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJzdG9wXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc3RvcCgpIHtcbiAgICAgICAgaWYgKHRoaXMucnVubmluZykge1xuICAgICAgICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmlkKTtcbiAgICAgICAgICB0aGlzLnJlbWFpbmluZyAtPSBuZXcgRGF0ZSgpIC0gdGhpcy5zdGFydGVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucmVtYWluaW5nO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJpbmNyZWFzZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGluY3JlYXNlKG4pIHtcbiAgICAgICAgdmFyIHJ1bm5pbmcgPSB0aGlzLnJ1bm5pbmc7XG5cbiAgICAgICAgaWYgKHJ1bm5pbmcpIHtcbiAgICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucmVtYWluaW5nICs9IG47XG5cbiAgICAgICAgaWYgKHJ1bm5pbmcpIHtcbiAgICAgICAgICB0aGlzLnN0YXJ0KCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5yZW1haW5pbmc7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImdldFRpbWVyTGVmdFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFRpbWVyTGVmdCgpIHtcbiAgICAgICAgaWYgKHRoaXMucnVubmluZykge1xuICAgICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICAgIHRoaXMuc3RhcnQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnJlbWFpbmluZztcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiaXNSdW5uaW5nXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaXNSdW5uaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ydW5uaW5nO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBUaW1lcjtcbiAgfSgpO1xuXG4gIHZhciBkZWZhdWx0SW5wdXRWYWxpZGF0b3JzID0ge1xuICAgIGVtYWlsOiBmdW5jdGlvbiBlbWFpbChzdHJpbmcsIHZhbGlkYXRpb25NZXNzYWdlKSB7XG4gICAgICByZXR1cm4gL15bYS16QS1aMC05LitfLV0rQFthLXpBLVowLTkuLV0rXFwuW2EtekEtWjAtOS1dezIsMjR9JC8udGVzdChzdHJpbmcpID8gUHJvbWlzZS5yZXNvbHZlKCkgOiBQcm9taXNlLnJlc29sdmUodmFsaWRhdGlvbk1lc3NhZ2UgfHwgJ0ludmFsaWQgZW1haWwgYWRkcmVzcycpO1xuICAgIH0sXG4gICAgdXJsOiBmdW5jdGlvbiB1cmwoc3RyaW5nLCB2YWxpZGF0aW9uTWVzc2FnZSkge1xuICAgICAgLy8gdGFrZW4gZnJvbSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzgwOTQzNSB3aXRoIGEgc21hbGwgY2hhbmdlIGZyb20gIzEzMDYgYW5kICMyMDEzXG4gICAgICByZXR1cm4gL15odHRwcz86XFwvXFwvKHd3d1xcLik/Wy1hLXpBLVowLTlAOiUuXyt+Iz1dezEsMjU2fVxcLlthLXpdezIsNjN9XFxiKFstYS16QS1aMC05QDolXysufiM/Ji89XSopJC8udGVzdChzdHJpbmcpID8gUHJvbWlzZS5yZXNvbHZlKCkgOiBQcm9taXNlLnJlc29sdmUodmFsaWRhdGlvbk1lc3NhZ2UgfHwgJ0ludmFsaWQgVVJMJyk7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIHNldERlZmF1bHRJbnB1dFZhbGlkYXRvcnMocGFyYW1zKSB7XG4gICAgLy8gVXNlIGRlZmF1bHQgYGlucHV0VmFsaWRhdG9yYCBmb3Igc3VwcG9ydGVkIGlucHV0IHR5cGVzIGlmIG5vdCBwcm92aWRlZFxuICAgIGlmICghcGFyYW1zLmlucHV0VmFsaWRhdG9yKSB7XG4gICAgICBPYmplY3Qua2V5cyhkZWZhdWx0SW5wdXRWYWxpZGF0b3JzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKHBhcmFtcy5pbnB1dCA9PT0ga2V5KSB7XG4gICAgICAgICAgcGFyYW1zLmlucHV0VmFsaWRhdG9yID0gZGVmYXVsdElucHV0VmFsaWRhdG9yc1trZXldO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB2YWxpZGF0ZUN1c3RvbVRhcmdldEVsZW1lbnQocGFyYW1zKSB7XG4gICAgLy8gRGV0ZXJtaW5lIGlmIHRoZSBjdXN0b20gdGFyZ2V0IGVsZW1lbnQgaXMgdmFsaWRcbiAgICBpZiAoIXBhcmFtcy50YXJnZXQgfHwgdHlwZW9mIHBhcmFtcy50YXJnZXQgPT09ICdzdHJpbmcnICYmICFkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHBhcmFtcy50YXJnZXQpIHx8IHR5cGVvZiBwYXJhbXMudGFyZ2V0ICE9PSAnc3RyaW5nJyAmJiAhcGFyYW1zLnRhcmdldC5hcHBlbmRDaGlsZCkge1xuICAgICAgd2FybignVGFyZ2V0IHBhcmFtZXRlciBpcyBub3QgdmFsaWQsIGRlZmF1bHRpbmcgdG8gXCJib2R5XCInKTtcbiAgICAgIHBhcmFtcy50YXJnZXQgPSAnYm9keSc7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBTZXQgdHlwZSwgdGV4dCBhbmQgYWN0aW9ucyBvbiBwb3B1cFxuICAgKlxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIHNldFBhcmFtZXRlcnMocGFyYW1zKSB7XG4gICAgc2V0RGVmYXVsdElucHV0VmFsaWRhdG9ycyhwYXJhbXMpOyAvLyBzaG93TG9hZGVyT25Db25maXJtICYmIHByZUNvbmZpcm1cblxuICAgIGlmIChwYXJhbXMuc2hvd0xvYWRlck9uQ29uZmlybSAmJiAhcGFyYW1zLnByZUNvbmZpcm0pIHtcbiAgICAgIHdhcm4oJ3Nob3dMb2FkZXJPbkNvbmZpcm0gaXMgc2V0IHRvIHRydWUsIGJ1dCBwcmVDb25maXJtIGlzIG5vdCBkZWZpbmVkLlxcbicgKyAnc2hvd0xvYWRlck9uQ29uZmlybSBzaG91bGQgYmUgdXNlZCB0b2dldGhlciB3aXRoIHByZUNvbmZpcm0sIHNlZSB1c2FnZSBleGFtcGxlOlxcbicgKyAnaHR0cHM6Ly9zd2VldGFsZXJ0Mi5naXRodWIuaW8vI2FqYXgtcmVxdWVzdCcpO1xuICAgIH0gLy8gcGFyYW1zLmFuaW1hdGlvbiB3aWxsIGJlIGFjdHVhbGx5IHVzZWQgaW4gcmVuZGVyUG9wdXAuanNcbiAgICAvLyBidXQgaW4gY2FzZSB3aGVuIHBhcmFtcy5hbmltYXRpb24gaXMgYSBmdW5jdGlvbiwgd2UgbmVlZCB0byBjYWxsIHRoYXQgZnVuY3Rpb25cbiAgICAvLyBiZWZvcmUgcG9wdXAgKHJlKWluaXRpYWxpemF0aW9uLCBzbyBpdCdsbCBiZSBwb3NzaWJsZSB0byBjaGVjayBTd2FsLmlzVmlzaWJsZSgpXG4gICAgLy8gaW5zaWRlIHRoZSBwYXJhbXMuYW5pbWF0aW9uIGZ1bmN0aW9uXG5cblxuICAgIHBhcmFtcy5hbmltYXRpb24gPSBjYWxsSWZGdW5jdGlvbihwYXJhbXMuYW5pbWF0aW9uKTtcbiAgICB2YWxpZGF0ZUN1c3RvbVRhcmdldEVsZW1lbnQocGFyYW1zKTsgLy8gUmVwbGFjZSBuZXdsaW5lcyB3aXRoIDxicj4gaW4gdGl0bGVcblxuICAgIGlmICh0eXBlb2YgcGFyYW1zLnRpdGxlID09PSAnc3RyaW5nJykge1xuICAgICAgcGFyYW1zLnRpdGxlID0gcGFyYW1zLnRpdGxlLnNwbGl0KCdcXG4nKS5qb2luKCc8YnIgLz4nKTtcbiAgICB9XG5cbiAgICBpbml0KHBhcmFtcyk7XG4gIH1cblxuICAvKipcbiAgICogT3BlbiBwb3B1cCwgYWRkIG5lY2Vzc2FyeSBjbGFzc2VzIGFuZCBzdHlsZXMsIGZpeCBzY3JvbGxiYXJcbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gcGFyYW1zXG4gICAqL1xuXG4gIHZhciBvcGVuUG9wdXAgPSBmdW5jdGlvbiBvcGVuUG9wdXAocGFyYW1zKSB7XG4gICAgdmFyIGNvbnRhaW5lciA9IGdldENvbnRhaW5lcigpO1xuICAgIHZhciBwb3B1cCA9IGdldFBvcHVwKCk7XG5cbiAgICBpZiAodHlwZW9mIHBhcmFtcy5vbkJlZm9yZU9wZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHBhcmFtcy5vbkJlZm9yZU9wZW4ocG9wdXApO1xuICAgIH1cblxuICAgIHZhciBib2R5U3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuYm9keSk7XG4gICAgdmFyIGluaXRpYWxCb2R5T3ZlcmZsb3cgPSBib2R5U3R5bGVzLm92ZXJmbG93WTtcbiAgICBhZGRDbGFzc2VzJDEoY29udGFpbmVyLCBwb3B1cCwgcGFyYW1zKTsgLy8gc2Nyb2xsaW5nIGlzICdoaWRkZW4nIHVudGlsIGFuaW1hdGlvbiBpcyBkb25lLCBhZnRlciB0aGF0ICdhdXRvJ1xuXG4gICAgc2V0U2Nyb2xsaW5nVmlzaWJpbGl0eShjb250YWluZXIsIHBvcHVwKTtcblxuICAgIGlmIChpc01vZGFsKCkpIHtcbiAgICAgIGZpeFNjcm9sbENvbnRhaW5lcihjb250YWluZXIsIHBhcmFtcy5zY3JvbGxiYXJQYWRkaW5nLCBpbml0aWFsQm9keU92ZXJmbG93KTtcbiAgICAgIHNldEFyaWFIaWRkZW4oKTtcbiAgICB9XG5cbiAgICBpZiAoIWlzVG9hc3QoKSAmJiAhZ2xvYmFsU3RhdGUucHJldmlvdXNBY3RpdmVFbGVtZW50KSB7XG4gICAgICBnbG9iYWxTdGF0ZS5wcmV2aW91c0FjdGl2ZUVsZW1lbnQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgcGFyYW1zLm9uT3BlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBwYXJhbXMub25PcGVuKHBvcHVwKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJlbW92ZUNsYXNzKGNvbnRhaW5lciwgc3dhbENsYXNzZXNbJ25vLXRyYW5zaXRpb24nXSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gc3dhbE9wZW5BbmltYXRpb25GaW5pc2hlZChldmVudCkge1xuICAgIHZhciBwb3B1cCA9IGdldFBvcHVwKCk7XG5cbiAgICBpZiAoZXZlbnQudGFyZ2V0ICE9PSBwb3B1cCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBjb250YWluZXIgPSBnZXRDb250YWluZXIoKTtcbiAgICBwb3B1cC5yZW1vdmVFdmVudExpc3RlbmVyKGFuaW1hdGlvbkVuZEV2ZW50LCBzd2FsT3BlbkFuaW1hdGlvbkZpbmlzaGVkKTtcbiAgICBjb250YWluZXIuc3R5bGUub3ZlcmZsb3dZID0gJ2F1dG8nO1xuICB9XG5cbiAgdmFyIHNldFNjcm9sbGluZ1Zpc2liaWxpdHkgPSBmdW5jdGlvbiBzZXRTY3JvbGxpbmdWaXNpYmlsaXR5KGNvbnRhaW5lciwgcG9wdXApIHtcbiAgICBpZiAoYW5pbWF0aW9uRW5kRXZlbnQgJiYgaGFzQ3NzQW5pbWF0aW9uKHBvcHVwKSkge1xuICAgICAgY29udGFpbmVyLnN0eWxlLm92ZXJmbG93WSA9ICdoaWRkZW4nO1xuICAgICAgcG9wdXAuYWRkRXZlbnRMaXN0ZW5lcihhbmltYXRpb25FbmRFdmVudCwgc3dhbE9wZW5BbmltYXRpb25GaW5pc2hlZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRhaW5lci5zdHlsZS5vdmVyZmxvd1kgPSAnYXV0byc7XG4gICAgfVxuICB9O1xuXG4gIHZhciBmaXhTY3JvbGxDb250YWluZXIgPSBmdW5jdGlvbiBmaXhTY3JvbGxDb250YWluZXIoY29udGFpbmVyLCBzY3JvbGxiYXJQYWRkaW5nLCBpbml0aWFsQm9keU92ZXJmbG93KSB7XG4gICAgaU9TZml4KCk7XG4gICAgSUVmaXgoKTtcblxuICAgIGlmIChzY3JvbGxiYXJQYWRkaW5nICYmIGluaXRpYWxCb2R5T3ZlcmZsb3cgIT09ICdoaWRkZW4nKSB7XG4gICAgICBmaXhTY3JvbGxiYXIoKTtcbiAgICB9IC8vIHN3ZWV0YWxlcnQyL2lzc3Vlcy8xMjQ3XG5cblxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgY29udGFpbmVyLnNjcm9sbFRvcCA9IDA7XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIGFkZENsYXNzZXMkMSA9IGZ1bmN0aW9uIGFkZENsYXNzZXMoY29udGFpbmVyLCBwb3B1cCwgcGFyYW1zKSB7XG4gICAgYWRkQ2xhc3MoY29udGFpbmVyLCBwYXJhbXMuc2hvd0NsYXNzLmJhY2tkcm9wKTtcbiAgICBzaG93KHBvcHVwKTsgLy8gQW5pbWF0ZSBwb3B1cCByaWdodCBhZnRlciBzaG93aW5nIGl0XG5cbiAgICBhZGRDbGFzcyhwb3B1cCwgcGFyYW1zLnNob3dDbGFzcy5wb3B1cCk7XG4gICAgYWRkQ2xhc3MoW2RvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgZG9jdW1lbnQuYm9keV0sIHN3YWxDbGFzc2VzLnNob3duKTtcblxuICAgIGlmIChwYXJhbXMuaGVpZ2h0QXV0byAmJiBwYXJhbXMuYmFja2Ryb3AgJiYgIXBhcmFtcy50b2FzdCkge1xuICAgICAgYWRkQ2xhc3MoW2RvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgZG9jdW1lbnQuYm9keV0sIHN3YWxDbGFzc2VzWydoZWlnaHQtYXV0byddKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGhhbmRsZUlucHV0T3B0aW9uc0FuZFZhbHVlID0gZnVuY3Rpb24gaGFuZGxlSW5wdXRPcHRpb25zQW5kVmFsdWUoaW5zdGFuY2UsIHBhcmFtcykge1xuICAgIGlmIChwYXJhbXMuaW5wdXQgPT09ICdzZWxlY3QnIHx8IHBhcmFtcy5pbnB1dCA9PT0gJ3JhZGlvJykge1xuICAgICAgaGFuZGxlSW5wdXRPcHRpb25zKGluc3RhbmNlLCBwYXJhbXMpO1xuICAgIH0gZWxzZSBpZiAoWyd0ZXh0JywgJ2VtYWlsJywgJ251bWJlcicsICd0ZWwnLCAndGV4dGFyZWEnXS5pbmRleE9mKHBhcmFtcy5pbnB1dCkgIT09IC0xICYmIChoYXNUb1Byb21pc2VGbihwYXJhbXMuaW5wdXRWYWx1ZSkgfHwgaXNQcm9taXNlKHBhcmFtcy5pbnB1dFZhbHVlKSkpIHtcbiAgICAgIGhhbmRsZUlucHV0VmFsdWUoaW5zdGFuY2UsIHBhcmFtcyk7XG4gICAgfVxuICB9O1xuICB2YXIgZ2V0SW5wdXRWYWx1ZSA9IGZ1bmN0aW9uIGdldElucHV0VmFsdWUoaW5zdGFuY2UsIGlubmVyUGFyYW1zKSB7XG4gICAgdmFyIGlucHV0ID0gaW5zdGFuY2UuZ2V0SW5wdXQoKTtcblxuICAgIGlmICghaW5wdXQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHN3aXRjaCAoaW5uZXJQYXJhbXMuaW5wdXQpIHtcbiAgICAgIGNhc2UgJ2NoZWNrYm94JzpcbiAgICAgICAgcmV0dXJuIGdldENoZWNrYm94VmFsdWUoaW5wdXQpO1xuXG4gICAgICBjYXNlICdyYWRpbyc6XG4gICAgICAgIHJldHVybiBnZXRSYWRpb1ZhbHVlKGlucHV0KTtcblxuICAgICAgY2FzZSAnZmlsZSc6XG4gICAgICAgIHJldHVybiBnZXRGaWxlVmFsdWUoaW5wdXQpO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gaW5uZXJQYXJhbXMuaW5wdXRBdXRvVHJpbSA/IGlucHV0LnZhbHVlLnRyaW0oKSA6IGlucHV0LnZhbHVlO1xuICAgIH1cbiAgfTtcblxuICB2YXIgZ2V0Q2hlY2tib3hWYWx1ZSA9IGZ1bmN0aW9uIGdldENoZWNrYm94VmFsdWUoaW5wdXQpIHtcbiAgICByZXR1cm4gaW5wdXQuY2hlY2tlZCA/IDEgOiAwO1xuICB9O1xuXG4gIHZhciBnZXRSYWRpb1ZhbHVlID0gZnVuY3Rpb24gZ2V0UmFkaW9WYWx1ZShpbnB1dCkge1xuICAgIHJldHVybiBpbnB1dC5jaGVja2VkID8gaW5wdXQudmFsdWUgOiBudWxsO1xuICB9O1xuXG4gIHZhciBnZXRGaWxlVmFsdWUgPSBmdW5jdGlvbiBnZXRGaWxlVmFsdWUoaW5wdXQpIHtcbiAgICByZXR1cm4gaW5wdXQuZmlsZXMubGVuZ3RoID8gaW5wdXQuZ2V0QXR0cmlidXRlKCdtdWx0aXBsZScpICE9PSBudWxsID8gaW5wdXQuZmlsZXMgOiBpbnB1dC5maWxlc1swXSA6IG51bGw7XG4gIH07XG5cbiAgdmFyIGhhbmRsZUlucHV0T3B0aW9ucyA9IGZ1bmN0aW9uIGhhbmRsZUlucHV0T3B0aW9ucyhpbnN0YW5jZSwgcGFyYW1zKSB7XG4gICAgdmFyIGNvbnRlbnQgPSBnZXRDb250ZW50KCk7XG5cbiAgICB2YXIgcHJvY2Vzc0lucHV0T3B0aW9ucyA9IGZ1bmN0aW9uIHByb2Nlc3NJbnB1dE9wdGlvbnMoaW5wdXRPcHRpb25zKSB7XG4gICAgICByZXR1cm4gcG9wdWxhdGVJbnB1dE9wdGlvbnNbcGFyYW1zLmlucHV0XShjb250ZW50LCBmb3JtYXRJbnB1dE9wdGlvbnMoaW5wdXRPcHRpb25zKSwgcGFyYW1zKTtcbiAgICB9O1xuXG4gICAgaWYgKGhhc1RvUHJvbWlzZUZuKHBhcmFtcy5pbnB1dE9wdGlvbnMpIHx8IGlzUHJvbWlzZShwYXJhbXMuaW5wdXRPcHRpb25zKSkge1xuICAgICAgc2hvd0xvYWRpbmcoKTtcbiAgICAgIGFzUHJvbWlzZShwYXJhbXMuaW5wdXRPcHRpb25zKS50aGVuKGZ1bmN0aW9uIChpbnB1dE9wdGlvbnMpIHtcbiAgICAgICAgaW5zdGFuY2UuaGlkZUxvYWRpbmcoKTtcbiAgICAgICAgcHJvY2Vzc0lucHV0T3B0aW9ucyhpbnB1dE9wdGlvbnMpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChfdHlwZW9mKHBhcmFtcy5pbnB1dE9wdGlvbnMpID09PSAnb2JqZWN0Jykge1xuICAgICAgcHJvY2Vzc0lucHV0T3B0aW9ucyhwYXJhbXMuaW5wdXRPcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXJyb3IoXCJVbmV4cGVjdGVkIHR5cGUgb2YgaW5wdXRPcHRpb25zISBFeHBlY3RlZCBvYmplY3QsIE1hcCBvciBQcm9taXNlLCBnb3QgXCIuY29uY2F0KF90eXBlb2YocGFyYW1zLmlucHV0T3B0aW9ucykpKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGhhbmRsZUlucHV0VmFsdWUgPSBmdW5jdGlvbiBoYW5kbGVJbnB1dFZhbHVlKGluc3RhbmNlLCBwYXJhbXMpIHtcbiAgICB2YXIgaW5wdXQgPSBpbnN0YW5jZS5nZXRJbnB1dCgpO1xuICAgIGhpZGUoaW5wdXQpO1xuICAgIGFzUHJvbWlzZShwYXJhbXMuaW5wdXRWYWx1ZSkudGhlbihmdW5jdGlvbiAoaW5wdXRWYWx1ZSkge1xuICAgICAgaW5wdXQudmFsdWUgPSBwYXJhbXMuaW5wdXQgPT09ICdudW1iZXInID8gcGFyc2VGbG9hdChpbnB1dFZhbHVlKSB8fCAwIDogXCJcIi5jb25jYXQoaW5wdXRWYWx1ZSk7XG4gICAgICBzaG93KGlucHV0KTtcbiAgICAgIGlucHV0LmZvY3VzKCk7XG4gICAgICBpbnN0YW5jZS5oaWRlTG9hZGluZygpO1xuICAgIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGVycikge1xuICAgICAgZXJyb3IoXCJFcnJvciBpbiBpbnB1dFZhbHVlIHByb21pc2U6IFwiLmNvbmNhdChlcnIpKTtcbiAgICAgIGlucHV0LnZhbHVlID0gJyc7XG4gICAgICBzaG93KGlucHV0KTtcbiAgICAgIGlucHV0LmZvY3VzKCk7XG4gICAgICBpbnN0YW5jZS5oaWRlTG9hZGluZygpO1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciBwb3B1bGF0ZUlucHV0T3B0aW9ucyA9IHtcbiAgICBzZWxlY3Q6IGZ1bmN0aW9uIHNlbGVjdChjb250ZW50LCBpbnB1dE9wdGlvbnMsIHBhcmFtcykge1xuICAgICAgdmFyIHNlbGVjdCA9IGdldENoaWxkQnlDbGFzcyhjb250ZW50LCBzd2FsQ2xhc3Nlcy5zZWxlY3QpO1xuXG4gICAgICB2YXIgcmVuZGVyT3B0aW9uID0gZnVuY3Rpb24gcmVuZGVyT3B0aW9uKHBhcmVudCwgb3B0aW9uTGFiZWwsIG9wdGlvblZhbHVlKSB7XG4gICAgICAgIHZhciBvcHRpb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdvcHRpb24nKTtcbiAgICAgICAgb3B0aW9uLnZhbHVlID0gb3B0aW9uVmFsdWU7XG4gICAgICAgIHNldElubmVySHRtbChvcHRpb24sIG9wdGlvbkxhYmVsKTtcblxuICAgICAgICBpZiAocGFyYW1zLmlucHV0VmFsdWUudG9TdHJpbmcoKSA9PT0gb3B0aW9uVmFsdWUudG9TdHJpbmcoKSkge1xuICAgICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQob3B0aW9uKTtcbiAgICAgIH07XG5cbiAgICAgIGlucHV0T3B0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChpbnB1dE9wdGlvbikge1xuICAgICAgICB2YXIgb3B0aW9uVmFsdWUgPSBpbnB1dE9wdGlvblswXTtcbiAgICAgICAgdmFyIG9wdGlvbkxhYmVsID0gaW5wdXRPcHRpb25bMV07IC8vIDxvcHRncm91cD4gc3BlYzpcbiAgICAgICAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw0MDEvaW50ZXJhY3QvZm9ybXMuaHRtbCNoLTE3LjZcbiAgICAgICAgLy8gXCIuLi5hbGwgT1BUR1JPVVAgZWxlbWVudHMgbXVzdCBiZSBzcGVjaWZpZWQgZGlyZWN0bHkgd2l0aGluIGEgU0VMRUNUIGVsZW1lbnQgKGkuZS4sIGdyb3VwcyBtYXkgbm90IGJlIG5lc3RlZCkuLi5cIlxuICAgICAgICAvLyBjaGVjayB3aGV0aGVyIHRoaXMgaXMgYSA8b3B0Z3JvdXA+XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9uTGFiZWwpKSB7XG4gICAgICAgICAgLy8gaWYgaXQgaXMgYW4gYXJyYXksIHRoZW4gaXQgaXMgYW4gPG9wdGdyb3VwPlxuICAgICAgICAgIHZhciBvcHRncm91cCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29wdGdyb3VwJyk7XG4gICAgICAgICAgb3B0Z3JvdXAubGFiZWwgPSBvcHRpb25WYWx1ZTtcbiAgICAgICAgICBvcHRncm91cC5kaXNhYmxlZCA9IGZhbHNlOyAvLyBub3QgY29uZmlndXJhYmxlIGZvciBub3dcblxuICAgICAgICAgIHNlbGVjdC5hcHBlbmRDaGlsZChvcHRncm91cCk7XG4gICAgICAgICAgb3B0aW9uTGFiZWwuZm9yRWFjaChmdW5jdGlvbiAobykge1xuICAgICAgICAgICAgcmV0dXJuIHJlbmRlck9wdGlvbihvcHRncm91cCwgb1sxXSwgb1swXSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gY2FzZSBvZiA8b3B0aW9uPlxuICAgICAgICAgIHJlbmRlck9wdGlvbihzZWxlY3QsIG9wdGlvbkxhYmVsLCBvcHRpb25WYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgc2VsZWN0LmZvY3VzKCk7XG4gICAgfSxcbiAgICByYWRpbzogZnVuY3Rpb24gcmFkaW8oY29udGVudCwgaW5wdXRPcHRpb25zLCBwYXJhbXMpIHtcbiAgICAgIHZhciByYWRpbyA9IGdldENoaWxkQnlDbGFzcyhjb250ZW50LCBzd2FsQ2xhc3Nlcy5yYWRpbyk7XG4gICAgICBpbnB1dE9wdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoaW5wdXRPcHRpb24pIHtcbiAgICAgICAgdmFyIHJhZGlvVmFsdWUgPSBpbnB1dE9wdGlvblswXTtcbiAgICAgICAgdmFyIHJhZGlvTGFiZWwgPSBpbnB1dE9wdGlvblsxXTtcbiAgICAgICAgdmFyIHJhZGlvSW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgICAgICB2YXIgcmFkaW9MYWJlbEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpO1xuICAgICAgICByYWRpb0lucHV0LnR5cGUgPSAncmFkaW8nO1xuICAgICAgICByYWRpb0lucHV0Lm5hbWUgPSBzd2FsQ2xhc3Nlcy5yYWRpbztcbiAgICAgICAgcmFkaW9JbnB1dC52YWx1ZSA9IHJhZGlvVmFsdWU7XG5cbiAgICAgICAgaWYgKHBhcmFtcy5pbnB1dFZhbHVlLnRvU3RyaW5nKCkgPT09IHJhZGlvVmFsdWUudG9TdHJpbmcoKSkge1xuICAgICAgICAgIHJhZGlvSW5wdXQuY2hlY2tlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgIHNldElubmVySHRtbChsYWJlbCwgcmFkaW9MYWJlbCk7XG4gICAgICAgIGxhYmVsLmNsYXNzTmFtZSA9IHN3YWxDbGFzc2VzLmxhYmVsO1xuICAgICAgICByYWRpb0xhYmVsRWxlbWVudC5hcHBlbmRDaGlsZChyYWRpb0lucHV0KTtcbiAgICAgICAgcmFkaW9MYWJlbEVsZW1lbnQuYXBwZW5kQ2hpbGQobGFiZWwpO1xuICAgICAgICByYWRpby5hcHBlbmRDaGlsZChyYWRpb0xhYmVsRWxlbWVudCk7XG4gICAgICB9KTtcbiAgICAgIHZhciByYWRpb3MgPSByYWRpby5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dCcpO1xuXG4gICAgICBpZiAocmFkaW9zLmxlbmd0aCkge1xuICAgICAgICByYWRpb3NbMF0uZm9jdXMoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBDb252ZXJ0cyBgaW5wdXRPcHRpb25zYCBpbnRvIGFuIGFycmF5IG9mIGBbdmFsdWUsIGxhYmVsXWBzXG4gICAqIEBwYXJhbSBpbnB1dE9wdGlvbnNcbiAgICovXG5cbiAgdmFyIGZvcm1hdElucHV0T3B0aW9ucyA9IGZ1bmN0aW9uIGZvcm1hdElucHV0T3B0aW9ucyhpbnB1dE9wdGlvbnMpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICBpZiAodHlwZW9mIE1hcCAhPT0gJ3VuZGVmaW5lZCcgJiYgaW5wdXRPcHRpb25zIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICBpbnB1dE9wdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICB2YXIgdmFsdWVGb3JtYXR0ZWQgPSB2YWx1ZTtcblxuICAgICAgICBpZiAoX3R5cGVvZih2YWx1ZUZvcm1hdHRlZCkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgLy8gY2FzZSBvZiA8b3B0Z3JvdXA+XG4gICAgICAgICAgdmFsdWVGb3JtYXR0ZWQgPSBmb3JtYXRJbnB1dE9wdGlvbnModmFsdWVGb3JtYXR0ZWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0LnB1c2goW2tleSwgdmFsdWVGb3JtYXR0ZWRdKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBPYmplY3Qua2V5cyhpbnB1dE9wdGlvbnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgdmFsdWVGb3JtYXR0ZWQgPSBpbnB1dE9wdGlvbnNba2V5XTtcblxuICAgICAgICBpZiAoX3R5cGVvZih2YWx1ZUZvcm1hdHRlZCkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgLy8gY2FzZSBvZiA8b3B0Z3JvdXA+XG4gICAgICAgICAgdmFsdWVGb3JtYXR0ZWQgPSBmb3JtYXRJbnB1dE9wdGlvbnModmFsdWVGb3JtYXR0ZWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0LnB1c2goW2tleSwgdmFsdWVGb3JtYXR0ZWRdKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgdmFyIGhhbmRsZUNvbmZpcm1CdXR0b25DbGljayA9IGZ1bmN0aW9uIGhhbmRsZUNvbmZpcm1CdXR0b25DbGljayhpbnN0YW5jZSwgaW5uZXJQYXJhbXMpIHtcbiAgICBpbnN0YW5jZS5kaXNhYmxlQnV0dG9ucygpO1xuXG4gICAgaWYgKGlubmVyUGFyYW1zLmlucHV0KSB7XG4gICAgICBoYW5kbGVDb25maXJtV2l0aElucHV0KGluc3RhbmNlLCBpbm5lclBhcmFtcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbmZpcm0oaW5zdGFuY2UsIGlubmVyUGFyYW1zLCB0cnVlKTtcbiAgICB9XG4gIH07XG4gIHZhciBoYW5kbGVDYW5jZWxCdXR0b25DbGljayA9IGZ1bmN0aW9uIGhhbmRsZUNhbmNlbEJ1dHRvbkNsaWNrKGluc3RhbmNlLCBkaXNtaXNzV2l0aCkge1xuICAgIGluc3RhbmNlLmRpc2FibGVCdXR0b25zKCk7XG4gICAgZGlzbWlzc1dpdGgoRGlzbWlzc1JlYXNvbi5jYW5jZWwpO1xuICB9O1xuXG4gIHZhciBoYW5kbGVDb25maXJtV2l0aElucHV0ID0gZnVuY3Rpb24gaGFuZGxlQ29uZmlybVdpdGhJbnB1dChpbnN0YW5jZSwgaW5uZXJQYXJhbXMpIHtcbiAgICB2YXIgaW5wdXRWYWx1ZSA9IGdldElucHV0VmFsdWUoaW5zdGFuY2UsIGlubmVyUGFyYW1zKTtcblxuICAgIGlmIChpbm5lclBhcmFtcy5pbnB1dFZhbGlkYXRvcikge1xuICAgICAgaW5zdGFuY2UuZGlzYWJsZUlucHV0KCk7XG4gICAgICB2YXIgdmFsaWRhdGlvblByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGFzUHJvbWlzZShpbm5lclBhcmFtcy5pbnB1dFZhbGlkYXRvcihpbnB1dFZhbHVlLCBpbm5lclBhcmFtcy52YWxpZGF0aW9uTWVzc2FnZSkpO1xuICAgICAgfSk7XG4gICAgICB2YWxpZGF0aW9uUHJvbWlzZS50aGVuKGZ1bmN0aW9uICh2YWxpZGF0aW9uTWVzc2FnZSkge1xuICAgICAgICBpbnN0YW5jZS5lbmFibGVCdXR0b25zKCk7XG4gICAgICAgIGluc3RhbmNlLmVuYWJsZUlucHV0KCk7XG5cbiAgICAgICAgaWYgKHZhbGlkYXRpb25NZXNzYWdlKSB7XG4gICAgICAgICAgaW5zdGFuY2Uuc2hvd1ZhbGlkYXRpb25NZXNzYWdlKHZhbGlkYXRpb25NZXNzYWdlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25maXJtKGluc3RhbmNlLCBpbm5lclBhcmFtcywgaW5wdXRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoIWluc3RhbmNlLmdldElucHV0KCkuY2hlY2tWYWxpZGl0eSgpKSB7XG4gICAgICBpbnN0YW5jZS5lbmFibGVCdXR0b25zKCk7XG4gICAgICBpbnN0YW5jZS5zaG93VmFsaWRhdGlvbk1lc3NhZ2UoaW5uZXJQYXJhbXMudmFsaWRhdGlvbk1lc3NhZ2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25maXJtKGluc3RhbmNlLCBpbm5lclBhcmFtcywgaW5wdXRWYWx1ZSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBzdWNjZWVkV2l0aCA9IGZ1bmN0aW9uIHN1Y2NlZWRXaXRoKGluc3RhbmNlLCB2YWx1ZSkge1xuICAgIGluc3RhbmNlLmNsb3NlUG9wdXAoe1xuICAgICAgdmFsdWU6IHZhbHVlXG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIGNvbmZpcm0gPSBmdW5jdGlvbiBjb25maXJtKGluc3RhbmNlLCBpbm5lclBhcmFtcywgdmFsdWUpIHtcbiAgICBpZiAoaW5uZXJQYXJhbXMuc2hvd0xvYWRlck9uQ29uZmlybSkge1xuICAgICAgc2hvd0xvYWRpbmcoKTsgLy8gVE9ETzogbWFrZSBzaG93TG9hZGluZyBhbiAqaW5zdGFuY2UqIG1ldGhvZFxuICAgIH1cblxuICAgIGlmIChpbm5lclBhcmFtcy5wcmVDb25maXJtKSB7XG4gICAgICBpbnN0YW5jZS5yZXNldFZhbGlkYXRpb25NZXNzYWdlKCk7XG4gICAgICB2YXIgcHJlQ29uZmlybVByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGFzUHJvbWlzZShpbm5lclBhcmFtcy5wcmVDb25maXJtKHZhbHVlLCBpbm5lclBhcmFtcy52YWxpZGF0aW9uTWVzc2FnZSkpO1xuICAgICAgfSk7XG4gICAgICBwcmVDb25maXJtUHJvbWlzZS50aGVuKGZ1bmN0aW9uIChwcmVDb25maXJtVmFsdWUpIHtcbiAgICAgICAgaWYgKGlzVmlzaWJsZShnZXRWYWxpZGF0aW9uTWVzc2FnZSgpKSB8fCBwcmVDb25maXJtVmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgaW5zdGFuY2UuaGlkZUxvYWRpbmcoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdWNjZWVkV2l0aChpbnN0YW5jZSwgdHlwZW9mIHByZUNvbmZpcm1WYWx1ZSA9PT0gJ3VuZGVmaW5lZCcgPyB2YWx1ZSA6IHByZUNvbmZpcm1WYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdWNjZWVkV2l0aChpbnN0YW5jZSwgdmFsdWUpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgYWRkS2V5ZG93bkhhbmRsZXIgPSBmdW5jdGlvbiBhZGRLZXlkb3duSGFuZGxlcihpbnN0YW5jZSwgZ2xvYmFsU3RhdGUsIGlubmVyUGFyYW1zLCBkaXNtaXNzV2l0aCkge1xuICAgIGlmIChnbG9iYWxTdGF0ZS5rZXlkb3duVGFyZ2V0ICYmIGdsb2JhbFN0YXRlLmtleWRvd25IYW5kbGVyQWRkZWQpIHtcbiAgICAgIGdsb2JhbFN0YXRlLmtleWRvd25UYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGdsb2JhbFN0YXRlLmtleWRvd25IYW5kbGVyLCB7XG4gICAgICAgIGNhcHR1cmU6IGdsb2JhbFN0YXRlLmtleWRvd25MaXN0ZW5lckNhcHR1cmVcbiAgICAgIH0pO1xuICAgICAgZ2xvYmFsU3RhdGUua2V5ZG93bkhhbmRsZXJBZGRlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghaW5uZXJQYXJhbXMudG9hc3QpIHtcbiAgICAgIGdsb2JhbFN0YXRlLmtleWRvd25IYW5kbGVyID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuIGtleWRvd25IYW5kbGVyKGluc3RhbmNlLCBlLCBkaXNtaXNzV2l0aCk7XG4gICAgICB9O1xuXG4gICAgICBnbG9iYWxTdGF0ZS5rZXlkb3duVGFyZ2V0ID0gaW5uZXJQYXJhbXMua2V5ZG93bkxpc3RlbmVyQ2FwdHVyZSA/IHdpbmRvdyA6IGdldFBvcHVwKCk7XG4gICAgICBnbG9iYWxTdGF0ZS5rZXlkb3duTGlzdGVuZXJDYXB0dXJlID0gaW5uZXJQYXJhbXMua2V5ZG93bkxpc3RlbmVyQ2FwdHVyZTtcbiAgICAgIGdsb2JhbFN0YXRlLmtleWRvd25UYXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGdsb2JhbFN0YXRlLmtleWRvd25IYW5kbGVyLCB7XG4gICAgICAgIGNhcHR1cmU6IGdsb2JhbFN0YXRlLmtleWRvd25MaXN0ZW5lckNhcHR1cmVcbiAgICAgIH0pO1xuICAgICAgZ2xvYmFsU3RhdGUua2V5ZG93bkhhbmRsZXJBZGRlZCA9IHRydWU7XG4gICAgfVxuICB9OyAvLyBGb2N1cyBoYW5kbGluZ1xuXG4gIHZhciBzZXRGb2N1cyA9IGZ1bmN0aW9uIHNldEZvY3VzKGlubmVyUGFyYW1zLCBpbmRleCwgaW5jcmVtZW50KSB7XG4gICAgdmFyIGZvY3VzYWJsZUVsZW1lbnRzID0gZ2V0Rm9jdXNhYmxlRWxlbWVudHMoKTsgLy8gc2VhcmNoIGZvciB2aXNpYmxlIGVsZW1lbnRzIGFuZCBzZWxlY3QgdGhlIG5leHQgcG9zc2libGUgbWF0Y2hcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZm9jdXNhYmxlRWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGluZGV4ID0gaW5kZXggKyBpbmNyZW1lbnQ7IC8vIHJvbGxvdmVyIHRvIGZpcnN0IGl0ZW1cblxuICAgICAgaWYgKGluZGV4ID09PSBmb2N1c2FibGVFbGVtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgaW5kZXggPSAwOyAvLyBnbyB0byBsYXN0IGl0ZW1cbiAgICAgIH0gZWxzZSBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgIGluZGV4ID0gZm9jdXNhYmxlRWxlbWVudHMubGVuZ3RoIC0gMTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZvY3VzYWJsZUVsZW1lbnRzW2luZGV4XS5mb2N1cygpO1xuICAgIH0gLy8gbm8gdmlzaWJsZSBmb2N1c2FibGUgZWxlbWVudHMsIGZvY3VzIHRoZSBwb3B1cFxuXG5cbiAgICBnZXRQb3B1cCgpLmZvY3VzKCk7XG4gIH07XG4gIHZhciBhcnJvd0tleXMgPSBbJ0Fycm93TGVmdCcsICdBcnJvd1JpZ2h0JywgJ0Fycm93VXAnLCAnQXJyb3dEb3duJywgJ0xlZnQnLCAnUmlnaHQnLCAnVXAnLCAnRG93bicgLy8gSUUxMVxuICBdO1xuICB2YXIgZXNjS2V5cyA9IFsnRXNjYXBlJywgJ0VzYycgLy8gSUUxMVxuICBdO1xuXG4gIHZhciBrZXlkb3duSGFuZGxlciA9IGZ1bmN0aW9uIGtleWRvd25IYW5kbGVyKGluc3RhbmNlLCBlLCBkaXNtaXNzV2l0aCkge1xuICAgIHZhciBpbm5lclBhcmFtcyA9IHByaXZhdGVQcm9wcy5pbm5lclBhcmFtcy5nZXQoaW5zdGFuY2UpO1xuXG4gICAgaWYgKGlubmVyUGFyYW1zLnN0b3BLZXlkb3duUHJvcGFnYXRpb24pIHtcbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfSAvLyBFTlRFUlxuXG5cbiAgICBpZiAoZS5rZXkgPT09ICdFbnRlcicpIHtcbiAgICAgIGhhbmRsZUVudGVyKGluc3RhbmNlLCBlLCBpbm5lclBhcmFtcyk7IC8vIFRBQlxuICAgIH0gZWxzZSBpZiAoZS5rZXkgPT09ICdUYWInKSB7XG4gICAgICBoYW5kbGVUYWIoZSwgaW5uZXJQYXJhbXMpOyAvLyBBUlJPV1MgLSBzd2l0Y2ggZm9jdXMgYmV0d2VlbiBidXR0b25zXG4gICAgfSBlbHNlIGlmIChhcnJvd0tleXMuaW5kZXhPZihlLmtleSkgIT09IC0xKSB7XG4gICAgICBoYW5kbGVBcnJvd3MoKTsgLy8gRVNDXG4gICAgfSBlbHNlIGlmIChlc2NLZXlzLmluZGV4T2YoZS5rZXkpICE9PSAtMSkge1xuICAgICAgaGFuZGxlRXNjKGUsIGlubmVyUGFyYW1zLCBkaXNtaXNzV2l0aCk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBoYW5kbGVFbnRlciA9IGZ1bmN0aW9uIGhhbmRsZUVudGVyKGluc3RhbmNlLCBlLCBpbm5lclBhcmFtcykge1xuICAgIC8vICM3MjAgIzcyMVxuICAgIGlmIChlLmlzQ29tcG9zaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGUudGFyZ2V0ICYmIGluc3RhbmNlLmdldElucHV0KCkgJiYgZS50YXJnZXQub3V0ZXJIVE1MID09PSBpbnN0YW5jZS5nZXRJbnB1dCgpLm91dGVySFRNTCkge1xuICAgICAgaWYgKFsndGV4dGFyZWEnLCAnZmlsZSddLmluZGV4T2YoaW5uZXJQYXJhbXMuaW5wdXQpICE9PSAtMSkge1xuICAgICAgICByZXR1cm47IC8vIGRvIG5vdCBzdWJtaXRcbiAgICAgIH1cblxuICAgICAgY2xpY2tDb25maXJtKCk7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBoYW5kbGVUYWIgPSBmdW5jdGlvbiBoYW5kbGVUYWIoZSwgaW5uZXJQYXJhbXMpIHtcbiAgICB2YXIgdGFyZ2V0RWxlbWVudCA9IGUudGFyZ2V0O1xuICAgIHZhciBmb2N1c2FibGVFbGVtZW50cyA9IGdldEZvY3VzYWJsZUVsZW1lbnRzKCk7XG4gICAgdmFyIGJ0bkluZGV4ID0gLTE7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZvY3VzYWJsZUVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodGFyZ2V0RWxlbWVudCA9PT0gZm9jdXNhYmxlRWxlbWVudHNbaV0pIHtcbiAgICAgICAgYnRuSW5kZXggPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWUuc2hpZnRLZXkpIHtcbiAgICAgIC8vIEN5Y2xlIHRvIHRoZSBuZXh0IGJ1dHRvblxuICAgICAgc2V0Rm9jdXMoaW5uZXJQYXJhbXMsIGJ0bkluZGV4LCAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ3ljbGUgdG8gdGhlIHByZXYgYnV0dG9uXG4gICAgICBzZXRGb2N1cyhpbm5lclBhcmFtcywgYnRuSW5kZXgsIC0xKTtcbiAgICB9XG5cbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgfTtcblxuICB2YXIgaGFuZGxlQXJyb3dzID0gZnVuY3Rpb24gaGFuZGxlQXJyb3dzKCkge1xuICAgIHZhciBjb25maXJtQnV0dG9uID0gZ2V0Q29uZmlybUJ1dHRvbigpO1xuICAgIHZhciBjYW5jZWxCdXR0b24gPSBnZXRDYW5jZWxCdXR0b24oKTsgLy8gZm9jdXMgQ2FuY2VsIGJ1dHRvbiBpZiBDb25maXJtIGJ1dHRvbiBpcyBjdXJyZW50bHkgZm9jdXNlZFxuXG4gICAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IGNvbmZpcm1CdXR0b24gJiYgaXNWaXNpYmxlKGNhbmNlbEJ1dHRvbikpIHtcbiAgICAgIGNhbmNlbEJ1dHRvbi5mb2N1cygpOyAvLyBhbmQgdmljZSB2ZXJzYVxuICAgIH0gZWxzZSBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gY2FuY2VsQnV0dG9uICYmIGlzVmlzaWJsZShjb25maXJtQnV0dG9uKSkge1xuICAgICAgY29uZmlybUJ1dHRvbi5mb2N1cygpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgaGFuZGxlRXNjID0gZnVuY3Rpb24gaGFuZGxlRXNjKGUsIGlubmVyUGFyYW1zLCBkaXNtaXNzV2l0aCkge1xuICAgIGlmIChjYWxsSWZGdW5jdGlvbihpbm5lclBhcmFtcy5hbGxvd0VzY2FwZUtleSkpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGRpc21pc3NXaXRoKERpc21pc3NSZWFzb24uZXNjKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGhhbmRsZVBvcHVwQ2xpY2sgPSBmdW5jdGlvbiBoYW5kbGVQb3B1cENsaWNrKGluc3RhbmNlLCBkb21DYWNoZSwgZGlzbWlzc1dpdGgpIHtcbiAgICB2YXIgaW5uZXJQYXJhbXMgPSBwcml2YXRlUHJvcHMuaW5uZXJQYXJhbXMuZ2V0KGluc3RhbmNlKTtcblxuICAgIGlmIChpbm5lclBhcmFtcy50b2FzdCkge1xuICAgICAgaGFuZGxlVG9hc3RDbGljayhpbnN0YW5jZSwgZG9tQ2FjaGUsIGRpc21pc3NXaXRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWdub3JlIGNsaWNrIGV2ZW50cyB0aGF0IGhhZCBtb3VzZWRvd24gb24gdGhlIHBvcHVwIGJ1dCBtb3VzZXVwIG9uIHRoZSBjb250YWluZXJcbiAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiB3aGVuIHRoZSB1c2VyIGRyYWdzIGEgc2xpZGVyXG4gICAgICBoYW5kbGVNb2RhbE1vdXNlZG93bihkb21DYWNoZSk7IC8vIElnbm9yZSBjbGljayBldmVudHMgdGhhdCBoYWQgbW91c2Vkb3duIG9uIHRoZSBjb250YWluZXIgYnV0IG1vdXNldXAgb24gdGhlIHBvcHVwXG5cbiAgICAgIGhhbmRsZUNvbnRhaW5lck1vdXNlZG93bihkb21DYWNoZSk7XG4gICAgICBoYW5kbGVNb2RhbENsaWNrKGluc3RhbmNlLCBkb21DYWNoZSwgZGlzbWlzc1dpdGgpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgaGFuZGxlVG9hc3RDbGljayA9IGZ1bmN0aW9uIGhhbmRsZVRvYXN0Q2xpY2soaW5zdGFuY2UsIGRvbUNhY2hlLCBkaXNtaXNzV2l0aCkge1xuICAgIC8vIENsb3NpbmcgdG9hc3QgYnkgaW50ZXJuYWwgY2xpY2tcbiAgICBkb21DYWNoZS5wb3B1cC5vbmNsaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGlubmVyUGFyYW1zID0gcHJpdmF0ZVByb3BzLmlubmVyUGFyYW1zLmdldChpbnN0YW5jZSk7XG5cbiAgICAgIGlmIChpbm5lclBhcmFtcy5zaG93Q29uZmlybUJ1dHRvbiB8fCBpbm5lclBhcmFtcy5zaG93Q2FuY2VsQnV0dG9uIHx8IGlubmVyUGFyYW1zLnNob3dDbG9zZUJ1dHRvbiB8fCBpbm5lclBhcmFtcy5pbnB1dCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGRpc21pc3NXaXRoKERpc21pc3NSZWFzb24uY2xvc2UpO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIGlnbm9yZU91dHNpZGVDbGljayA9IGZhbHNlO1xuXG4gIHZhciBoYW5kbGVNb2RhbE1vdXNlZG93biA9IGZ1bmN0aW9uIGhhbmRsZU1vZGFsTW91c2Vkb3duKGRvbUNhY2hlKSB7XG4gICAgZG9tQ2FjaGUucG9wdXAub25tb3VzZWRvd24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICBkb21DYWNoZS5jb250YWluZXIub25tb3VzZXVwID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZG9tQ2FjaGUuY29udGFpbmVyLm9ubW91c2V1cCA9IHVuZGVmaW5lZDsgLy8gV2Ugb25seSBjaGVjayBpZiB0aGUgbW91c2V1cCB0YXJnZXQgaXMgdGhlIGNvbnRhaW5lciBiZWNhdXNlIHVzdWFsbHkgaXQgZG9lc24ndFxuICAgICAgICAvLyBoYXZlIGFueSBvdGhlciBkaXJlY3QgY2hpbGRyZW4gYXNpZGUgb2YgdGhlIHBvcHVwXG5cbiAgICAgICAgaWYgKGUudGFyZ2V0ID09PSBkb21DYWNoZS5jb250YWluZXIpIHtcbiAgICAgICAgICBpZ25vcmVPdXRzaWRlQ2xpY2sgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH07XG4gIH07XG5cbiAgdmFyIGhhbmRsZUNvbnRhaW5lck1vdXNlZG93biA9IGZ1bmN0aW9uIGhhbmRsZUNvbnRhaW5lck1vdXNlZG93bihkb21DYWNoZSkge1xuICAgIGRvbUNhY2hlLmNvbnRhaW5lci5vbm1vdXNlZG93biA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGRvbUNhY2hlLnBvcHVwLm9ubW91c2V1cCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGRvbUNhY2hlLnBvcHVwLm9ubW91c2V1cCA9IHVuZGVmaW5lZDsgLy8gV2UgYWxzbyBuZWVkIHRvIGNoZWNrIGlmIHRoZSBtb3VzZXVwIHRhcmdldCBpcyBhIGNoaWxkIG9mIHRoZSBwb3B1cFxuXG4gICAgICAgIGlmIChlLnRhcmdldCA9PT0gZG9tQ2FjaGUucG9wdXAgfHwgZG9tQ2FjaGUucG9wdXAuY29udGFpbnMoZS50YXJnZXQpKSB7XG4gICAgICAgICAgaWdub3JlT3V0c2lkZUNsaWNrID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBoYW5kbGVNb2RhbENsaWNrID0gZnVuY3Rpb24gaGFuZGxlTW9kYWxDbGljayhpbnN0YW5jZSwgZG9tQ2FjaGUsIGRpc21pc3NXaXRoKSB7XG4gICAgZG9tQ2FjaGUuY29udGFpbmVyLm9uY2xpY2sgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgdmFyIGlubmVyUGFyYW1zID0gcHJpdmF0ZVByb3BzLmlubmVyUGFyYW1zLmdldChpbnN0YW5jZSk7XG5cbiAgICAgIGlmIChpZ25vcmVPdXRzaWRlQ2xpY2spIHtcbiAgICAgICAgaWdub3JlT3V0c2lkZUNsaWNrID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGUudGFyZ2V0ID09PSBkb21DYWNoZS5jb250YWluZXIgJiYgY2FsbElmRnVuY3Rpb24oaW5uZXJQYXJhbXMuYWxsb3dPdXRzaWRlQ2xpY2spKSB7XG4gICAgICAgIGRpc21pc3NXaXRoKERpc21pc3NSZWFzb24uYmFja2Ryb3ApO1xuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gX21haW4odXNlclBhcmFtcykge1xuICAgIHNob3dXYXJuaW5nc0ZvclBhcmFtcyh1c2VyUGFyYW1zKTtcblxuICAgIGlmIChnbG9iYWxTdGF0ZS5jdXJyZW50SW5zdGFuY2UpIHtcbiAgICAgIGdsb2JhbFN0YXRlLmN1cnJlbnRJbnN0YW5jZS5fZGVzdHJveSgpO1xuICAgIH1cblxuICAgIGdsb2JhbFN0YXRlLmN1cnJlbnRJbnN0YW5jZSA9IHRoaXM7XG4gICAgdmFyIGlubmVyUGFyYW1zID0gcHJlcGFyZVBhcmFtcyh1c2VyUGFyYW1zKTtcbiAgICBzZXRQYXJhbWV0ZXJzKGlubmVyUGFyYW1zKTtcbiAgICBPYmplY3QuZnJlZXplKGlubmVyUGFyYW1zKTsgLy8gY2xlYXIgdGhlIHByZXZpb3VzIHRpbWVyXG5cbiAgICBpZiAoZ2xvYmFsU3RhdGUudGltZW91dCkge1xuICAgICAgZ2xvYmFsU3RhdGUudGltZW91dC5zdG9wKCk7XG4gICAgICBkZWxldGUgZ2xvYmFsU3RhdGUudGltZW91dDtcbiAgICB9IC8vIGNsZWFyIHRoZSByZXN0b3JlIGZvY3VzIHRpbWVvdXRcblxuXG4gICAgY2xlYXJUaW1lb3V0KGdsb2JhbFN0YXRlLnJlc3RvcmVGb2N1c1RpbWVvdXQpO1xuICAgIHZhciBkb21DYWNoZSA9IHBvcHVsYXRlRG9tQ2FjaGUodGhpcyk7XG4gICAgcmVuZGVyKHRoaXMsIGlubmVyUGFyYW1zKTtcbiAgICBwcml2YXRlUHJvcHMuaW5uZXJQYXJhbXMuc2V0KHRoaXMsIGlubmVyUGFyYW1zKTtcbiAgICByZXR1cm4gc3dhbFByb21pc2UodGhpcywgZG9tQ2FjaGUsIGlubmVyUGFyYW1zKTtcbiAgfVxuXG4gIHZhciBwcmVwYXJlUGFyYW1zID0gZnVuY3Rpb24gcHJlcGFyZVBhcmFtcyh1c2VyUGFyYW1zKSB7XG4gICAgdmFyIHNob3dDbGFzcyA9IF9leHRlbmRzKHt9LCBkZWZhdWx0UGFyYW1zLnNob3dDbGFzcywgdXNlclBhcmFtcy5zaG93Q2xhc3MpO1xuXG4gICAgdmFyIGhpZGVDbGFzcyA9IF9leHRlbmRzKHt9LCBkZWZhdWx0UGFyYW1zLmhpZGVDbGFzcywgdXNlclBhcmFtcy5oaWRlQ2xhc3MpO1xuXG4gICAgdmFyIHBhcmFtcyA9IF9leHRlbmRzKHt9LCBkZWZhdWx0UGFyYW1zLCB1c2VyUGFyYW1zKTtcblxuICAgIHBhcmFtcy5zaG93Q2xhc3MgPSBzaG93Q2xhc3M7XG4gICAgcGFyYW1zLmhpZGVDbGFzcyA9IGhpZGVDbGFzczsgLy8gQGRlcHJlY2F0ZWRcblxuICAgIGlmICh1c2VyUGFyYW1zLmFuaW1hdGlvbiA9PT0gZmFsc2UpIHtcbiAgICAgIHBhcmFtcy5zaG93Q2xhc3MgPSB7XG4gICAgICAgIHBvcHVwOiAnc3dhbDItbm9hbmltYXRpb24nLFxuICAgICAgICBiYWNrZHJvcDogJ3N3YWwyLW5vYW5pbWF0aW9uJ1xuICAgICAgfTtcbiAgICAgIHBhcmFtcy5oaWRlQ2xhc3MgPSB7fTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyYW1zO1xuICB9O1xuXG4gIHZhciBzd2FsUHJvbWlzZSA9IGZ1bmN0aW9uIHN3YWxQcm9taXNlKGluc3RhbmNlLCBkb21DYWNoZSwgaW5uZXJQYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgIC8vIGZ1bmN0aW9ucyB0byBoYW5kbGUgYWxsIGNsb3NpbmdzL2Rpc21pc3NhbHNcbiAgICAgIHZhciBkaXNtaXNzV2l0aCA9IGZ1bmN0aW9uIGRpc21pc3NXaXRoKGRpc21pc3MpIHtcbiAgICAgICAgaW5zdGFuY2UuY2xvc2VQb3B1cCh7XG4gICAgICAgICAgZGlzbWlzczogZGlzbWlzc1xuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIHByaXZhdGVNZXRob2RzLnN3YWxQcm9taXNlUmVzb2x2ZS5zZXQoaW5zdGFuY2UsIHJlc29sdmUpO1xuXG4gICAgICBkb21DYWNoZS5jb25maXJtQnV0dG9uLm9uY2xpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBoYW5kbGVDb25maXJtQnV0dG9uQ2xpY2soaW5zdGFuY2UsIGlubmVyUGFyYW1zKTtcbiAgICAgIH07XG5cbiAgICAgIGRvbUNhY2hlLmNhbmNlbEJ1dHRvbi5vbmNsaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gaGFuZGxlQ2FuY2VsQnV0dG9uQ2xpY2soaW5zdGFuY2UsIGRpc21pc3NXaXRoKTtcbiAgICAgIH07XG5cbiAgICAgIGRvbUNhY2hlLmNsb3NlQnV0dG9uLm9uY2xpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBkaXNtaXNzV2l0aChEaXNtaXNzUmVhc29uLmNsb3NlKTtcbiAgICAgIH07XG5cbiAgICAgIGhhbmRsZVBvcHVwQ2xpY2soaW5zdGFuY2UsIGRvbUNhY2hlLCBkaXNtaXNzV2l0aCk7XG4gICAgICBhZGRLZXlkb3duSGFuZGxlcihpbnN0YW5jZSwgZ2xvYmFsU3RhdGUsIGlubmVyUGFyYW1zLCBkaXNtaXNzV2l0aCk7XG5cbiAgICAgIGlmIChpbm5lclBhcmFtcy50b2FzdCAmJiAoaW5uZXJQYXJhbXMuaW5wdXQgfHwgaW5uZXJQYXJhbXMuZm9vdGVyIHx8IGlubmVyUGFyYW1zLnNob3dDbG9zZUJ1dHRvbikpIHtcbiAgICAgICAgYWRkQ2xhc3MoZG9jdW1lbnQuYm9keSwgc3dhbENsYXNzZXNbJ3RvYXN0LWNvbHVtbiddKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlbW92ZUNsYXNzKGRvY3VtZW50LmJvZHksIHN3YWxDbGFzc2VzWyd0b2FzdC1jb2x1bW4nXSk7XG4gICAgICB9XG5cbiAgICAgIGhhbmRsZUlucHV0T3B0aW9uc0FuZFZhbHVlKGluc3RhbmNlLCBpbm5lclBhcmFtcyk7XG4gICAgICBvcGVuUG9wdXAoaW5uZXJQYXJhbXMpO1xuICAgICAgc2V0dXBUaW1lcihnbG9iYWxTdGF0ZSwgaW5uZXJQYXJhbXMsIGRpc21pc3NXaXRoKTtcbiAgICAgIGluaXRGb2N1cyhkb21DYWNoZSwgaW5uZXJQYXJhbXMpOyAvLyBTY3JvbGwgY29udGFpbmVyIHRvIHRvcCBvbiBvcGVuICgjMTI0NywgIzE5NDYpXG5cbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBkb21DYWNoZS5jb250YWluZXIuc2Nyb2xsVG9wID0gMDtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciBwb3B1bGF0ZURvbUNhY2hlID0gZnVuY3Rpb24gcG9wdWxhdGVEb21DYWNoZShpbnN0YW5jZSkge1xuICAgIHZhciBkb21DYWNoZSA9IHtcbiAgICAgIHBvcHVwOiBnZXRQb3B1cCgpLFxuICAgICAgY29udGFpbmVyOiBnZXRDb250YWluZXIoKSxcbiAgICAgIGNvbnRlbnQ6IGdldENvbnRlbnQoKSxcbiAgICAgIGFjdGlvbnM6IGdldEFjdGlvbnMoKSxcbiAgICAgIGNvbmZpcm1CdXR0b246IGdldENvbmZpcm1CdXR0b24oKSxcbiAgICAgIGNhbmNlbEJ1dHRvbjogZ2V0Q2FuY2VsQnV0dG9uKCksXG4gICAgICBjbG9zZUJ1dHRvbjogZ2V0Q2xvc2VCdXR0b24oKSxcbiAgICAgIHZhbGlkYXRpb25NZXNzYWdlOiBnZXRWYWxpZGF0aW9uTWVzc2FnZSgpLFxuICAgICAgcHJvZ3Jlc3NTdGVwczogZ2V0UHJvZ3Jlc3NTdGVwcygpXG4gICAgfTtcbiAgICBwcml2YXRlUHJvcHMuZG9tQ2FjaGUuc2V0KGluc3RhbmNlLCBkb21DYWNoZSk7XG4gICAgcmV0dXJuIGRvbUNhY2hlO1xuICB9O1xuXG4gIHZhciBzZXR1cFRpbWVyID0gZnVuY3Rpb24gc2V0dXBUaW1lcihnbG9iYWxTdGF0ZSQkMSwgaW5uZXJQYXJhbXMsIGRpc21pc3NXaXRoKSB7XG4gICAgdmFyIHRpbWVyUHJvZ3Jlc3NCYXIgPSBnZXRUaW1lclByb2dyZXNzQmFyKCk7XG4gICAgaGlkZSh0aW1lclByb2dyZXNzQmFyKTtcblxuICAgIGlmIChpbm5lclBhcmFtcy50aW1lcikge1xuICAgICAgZ2xvYmFsU3RhdGUkJDEudGltZW91dCA9IG5ldyBUaW1lcihmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRpc21pc3NXaXRoKCd0aW1lcicpO1xuICAgICAgICBkZWxldGUgZ2xvYmFsU3RhdGUkJDEudGltZW91dDtcbiAgICAgIH0sIGlubmVyUGFyYW1zLnRpbWVyKTtcblxuICAgICAgaWYgKGlubmVyUGFyYW1zLnRpbWVyUHJvZ3Jlc3NCYXIpIHtcbiAgICAgICAgc2hvdyh0aW1lclByb2dyZXNzQmFyKTtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKGdsb2JhbFN0YXRlJCQxLnRpbWVvdXQucnVubmluZykge1xuICAgICAgICAgICAgLy8gdGltZXIgY2FuIGJlIGFscmVhZHkgc3RvcHBlZCBhdCB0aGlzIHBvaW50XG4gICAgICAgICAgICBhbmltYXRlVGltZXJQcm9ncmVzc0Jhcihpbm5lclBhcmFtcy50aW1lcik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFyIGluaXRGb2N1cyA9IGZ1bmN0aW9uIGluaXRGb2N1cyhkb21DYWNoZSwgaW5uZXJQYXJhbXMpIHtcbiAgICBpZiAoaW5uZXJQYXJhbXMudG9hc3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIWNhbGxJZkZ1bmN0aW9uKGlubmVyUGFyYW1zLmFsbG93RW50ZXJLZXkpKSB7XG4gICAgICByZXR1cm4gYmx1ckFjdGl2ZUVsZW1lbnQoKTtcbiAgICB9XG5cbiAgICBpZiAoaW5uZXJQYXJhbXMuZm9jdXNDYW5jZWwgJiYgaXNWaXNpYmxlKGRvbUNhY2hlLmNhbmNlbEJ1dHRvbikpIHtcbiAgICAgIHJldHVybiBkb21DYWNoZS5jYW5jZWxCdXR0b24uZm9jdXMoKTtcbiAgICB9XG5cbiAgICBpZiAoaW5uZXJQYXJhbXMuZm9jdXNDb25maXJtICYmIGlzVmlzaWJsZShkb21DYWNoZS5jb25maXJtQnV0dG9uKSkge1xuICAgICAgcmV0dXJuIGRvbUNhY2hlLmNvbmZpcm1CdXR0b24uZm9jdXMoKTtcbiAgICB9XG5cbiAgICBzZXRGb2N1cyhpbm5lclBhcmFtcywgLTEsIDEpO1xuICB9O1xuXG4gIHZhciBibHVyQWN0aXZlRWxlbWVudCA9IGZ1bmN0aW9uIGJsdXJBY3RpdmVFbGVtZW50KCkge1xuICAgIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmIHR5cGVvZiBkb2N1bWVudC5hY3RpdmVFbGVtZW50LmJsdXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuYmx1cigpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlcyBwb3B1cCBwYXJhbWV0ZXJzLlxuICAgKi9cblxuICBmdW5jdGlvbiB1cGRhdGUocGFyYW1zKSB7XG4gICAgdmFyIHBvcHVwID0gZ2V0UG9wdXAoKTtcbiAgICB2YXIgaW5uZXJQYXJhbXMgPSBwcml2YXRlUHJvcHMuaW5uZXJQYXJhbXMuZ2V0KHRoaXMpO1xuXG4gICAgaWYgKCFwb3B1cCB8fCBoYXNDbGFzcyhwb3B1cCwgaW5uZXJQYXJhbXMuaGlkZUNsYXNzLnBvcHVwKSkge1xuICAgICAgcmV0dXJuIHdhcm4oXCJZb3UncmUgdHJ5aW5nIHRvIHVwZGF0ZSB0aGUgY2xvc2VkIG9yIGNsb3NpbmcgcG9wdXAsIHRoYXQgd29uJ3Qgd29yay4gVXNlIHRoZSB1cGRhdGUoKSBtZXRob2QgaW4gcHJlQ29uZmlybSBwYXJhbWV0ZXIgb3Igc2hvdyBhIG5ldyBwb3B1cC5cIik7XG4gICAgfVxuXG4gICAgdmFyIHZhbGlkVXBkYXRhYmxlUGFyYW1zID0ge307IC8vIGFzc2lnbiB2YWxpZCBwYXJhbXMgZnJvbSBgcGFyYW1zYCB0byBgZGVmYXVsdHNgXG5cbiAgICBPYmplY3Qua2V5cyhwYXJhbXMpLmZvckVhY2goZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgICBpZiAoU3dhbC5pc1VwZGF0YWJsZVBhcmFtZXRlcihwYXJhbSkpIHtcbiAgICAgICAgdmFsaWRVcGRhdGFibGVQYXJhbXNbcGFyYW1dID0gcGFyYW1zW3BhcmFtXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdhcm4oXCJJbnZhbGlkIHBhcmFtZXRlciB0byB1cGRhdGU6IFxcXCJcIi5jb25jYXQocGFyYW0sIFwiXFxcIi4gVXBkYXRhYmxlIHBhcmFtcyBhcmUgbGlzdGVkIGhlcmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9zd2VldGFsZXJ0Mi9zd2VldGFsZXJ0Mi9ibG9iL21hc3Rlci9zcmMvdXRpbHMvcGFyYW1zLmpzXCIpKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciB1cGRhdGVkUGFyYW1zID0gX2V4dGVuZHMoe30sIGlubmVyUGFyYW1zLCB2YWxpZFVwZGF0YWJsZVBhcmFtcyk7XG5cbiAgICByZW5kZXIodGhpcywgdXBkYXRlZFBhcmFtcyk7XG4gICAgcHJpdmF0ZVByb3BzLmlubmVyUGFyYW1zLnNldCh0aGlzLCB1cGRhdGVkUGFyYW1zKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgdmFsdWU6IF9leHRlbmRzKHt9LCB0aGlzLnBhcmFtcywgcGFyYW1zKSxcbiAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBfZGVzdHJveSgpIHtcbiAgICB2YXIgZG9tQ2FjaGUgPSBwcml2YXRlUHJvcHMuZG9tQ2FjaGUuZ2V0KHRoaXMpO1xuICAgIHZhciBpbm5lclBhcmFtcyA9IHByaXZhdGVQcm9wcy5pbm5lclBhcmFtcy5nZXQodGhpcyk7XG5cbiAgICBpZiAoIWlubmVyUGFyYW1zKSB7XG4gICAgICByZXR1cm47IC8vIFRoaXMgaW5zdGFuY2UgaGFzIGFscmVhZHkgYmVlbiBkZXN0cm95ZWRcbiAgICB9IC8vIENoZWNrIGlmIHRoZXJlIGlzIGFub3RoZXIgU3dhbCBjbG9zaW5nXG5cblxuICAgIGlmIChkb21DYWNoZS5wb3B1cCAmJiBnbG9iYWxTdGF0ZS5zd2FsQ2xvc2VFdmVudEZpbmlzaGVkQ2FsbGJhY2spIHtcbiAgICAgIGdsb2JhbFN0YXRlLnN3YWxDbG9zZUV2ZW50RmluaXNoZWRDYWxsYmFjaygpO1xuICAgICAgZGVsZXRlIGdsb2JhbFN0YXRlLnN3YWxDbG9zZUV2ZW50RmluaXNoZWRDYWxsYmFjaztcbiAgICB9IC8vIENoZWNrIGlmIHRoZXJlIGlzIGEgc3dhbCBkaXNwb3NhbCBkZWZlciB0aW1lclxuXG5cbiAgICBpZiAoZ2xvYmFsU3RhdGUuZGVmZXJEaXNwb3NhbFRpbWVyKSB7XG4gICAgICBjbGVhclRpbWVvdXQoZ2xvYmFsU3RhdGUuZGVmZXJEaXNwb3NhbFRpbWVyKTtcbiAgICAgIGRlbGV0ZSBnbG9iYWxTdGF0ZS5kZWZlckRpc3Bvc2FsVGltZXI7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbm5lclBhcmFtcy5vbkRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlubmVyUGFyYW1zLm9uRGVzdHJveSgpO1xuICAgIH1cblxuICAgIGRpc3Bvc2VTd2FsKHRoaXMpO1xuICB9XG5cbiAgdmFyIGRpc3Bvc2VTd2FsID0gZnVuY3Rpb24gZGlzcG9zZVN3YWwoaW5zdGFuY2UpIHtcbiAgICAvLyBVbnNldCB0aGlzLnBhcmFtcyBzbyBHQyB3aWxsIGRpc3Bvc2UgaXQgKCMxNTY5KVxuICAgIGRlbGV0ZSBpbnN0YW5jZS5wYXJhbXM7IC8vIFVuc2V0IGdsb2JhbFN0YXRlIHByb3BzIHNvIEdDIHdpbGwgZGlzcG9zZSBnbG9iYWxTdGF0ZSAoIzE1NjkpXG5cbiAgICBkZWxldGUgZ2xvYmFsU3RhdGUua2V5ZG93bkhhbmRsZXI7XG4gICAgZGVsZXRlIGdsb2JhbFN0YXRlLmtleWRvd25UYXJnZXQ7IC8vIFVuc2V0IFdlYWtNYXBzIHNvIEdDIHdpbGwgYmUgYWJsZSB0byBkaXNwb3NlIHRoZW0gKCMxNTY5KVxuXG4gICAgdW5zZXRXZWFrTWFwcyhwcml2YXRlUHJvcHMpO1xuICAgIHVuc2V0V2Vha01hcHMocHJpdmF0ZU1ldGhvZHMpO1xuICB9O1xuXG4gIHZhciB1bnNldFdlYWtNYXBzID0gZnVuY3Rpb24gdW5zZXRXZWFrTWFwcyhvYmopIHtcbiAgICBmb3IgKHZhciBpIGluIG9iaikge1xuICAgICAgb2JqW2ldID0gbmV3IFdlYWtNYXAoKTtcbiAgICB9XG4gIH07XG5cblxuXG4gIHZhciBpbnN0YW5jZU1ldGhvZHMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgaGlkZUxvYWRpbmc6IGhpZGVMb2FkaW5nLFxuICAgIGRpc2FibGVMb2FkaW5nOiBoaWRlTG9hZGluZyxcbiAgICBnZXRJbnB1dDogZ2V0SW5wdXQkMSxcbiAgICBjbG9zZTogY2xvc2UsXG4gICAgY2xvc2VQb3B1cDogY2xvc2UsXG4gICAgY2xvc2VNb2RhbDogY2xvc2UsXG4gICAgY2xvc2VUb2FzdDogY2xvc2UsXG4gICAgZW5hYmxlQnV0dG9uczogZW5hYmxlQnV0dG9ucyxcbiAgICBkaXNhYmxlQnV0dG9uczogZGlzYWJsZUJ1dHRvbnMsXG4gICAgZW5hYmxlSW5wdXQ6IGVuYWJsZUlucHV0LFxuICAgIGRpc2FibGVJbnB1dDogZGlzYWJsZUlucHV0LFxuICAgIHNob3dWYWxpZGF0aW9uTWVzc2FnZTogc2hvd1ZhbGlkYXRpb25NZXNzYWdlLFxuICAgIHJlc2V0VmFsaWRhdGlvbk1lc3NhZ2U6IHJlc2V0VmFsaWRhdGlvbk1lc3NhZ2UkMSxcbiAgICBnZXRQcm9ncmVzc1N0ZXBzOiBnZXRQcm9ncmVzc1N0ZXBzJDEsXG4gICAgX21haW46IF9tYWluLFxuICAgIHVwZGF0ZTogdXBkYXRlLFxuICAgIF9kZXN0cm95OiBfZGVzdHJveVxuICB9KTtcblxuICB2YXIgY3VycmVudEluc3RhbmNlO1xuXG4gIHZhciBTd2VldEFsZXJ0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTd2VldEFsZXJ0KCkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFN3ZWV0QWxlcnQpO1xuXG4gICAgICAvLyBQcmV2ZW50IHJ1biBpbiBOb2RlIGVudlxuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gQ2hlY2sgZm9yIHRoZSBleGlzdGVuY2Ugb2YgUHJvbWlzZVxuXG5cbiAgICAgIGlmICh0eXBlb2YgUHJvbWlzZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgZXJyb3IoJ1RoaXMgcGFja2FnZSByZXF1aXJlcyBhIFByb21pc2UgbGlicmFyeSwgcGxlYXNlIGluY2x1ZGUgYSBzaGltIHRvIGVuYWJsZSBpdCBpbiB0aGlzIGJyb3dzZXIgKFNlZTogaHR0cHM6Ly9naXRodWIuY29tL3N3ZWV0YWxlcnQyL3N3ZWV0YWxlcnQyL3dpa2kvTWlncmF0aW9uLWZyb20tU3dlZXRBbGVydC10by1Td2VldEFsZXJ0MiMxLWllLXN1cHBvcnQpJyk7XG4gICAgICB9XG5cbiAgICAgIGN1cnJlbnRJbnN0YW5jZSA9IHRoaXM7XG5cbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICB2YXIgb3V0ZXJQYXJhbXMgPSBPYmplY3QuZnJlZXplKHRoaXMuY29uc3RydWN0b3IuYXJnc1RvUGFyYW1zKGFyZ3MpKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgdmFsdWU6IG91dGVyUGFyYW1zLFxuICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgdmFyIHByb21pc2UgPSB0aGlzLl9tYWluKHRoaXMucGFyYW1zKTtcblxuICAgICAgcHJpdmF0ZVByb3BzLnByb21pc2Uuc2V0KHRoaXMsIHByb21pc2UpO1xuICAgIH0gLy8gYGNhdGNoYCBjYW5ub3QgYmUgdGhlIG5hbWUgb2YgYSBtb2R1bGUgZXhwb3J0LCBzbyB3ZSBkZWZpbmUgb3VyIHRoZW5hYmxlIG1ldGhvZHMgaGVyZSBpbnN0ZWFkXG5cblxuICAgIF9jcmVhdGVDbGFzcyhTd2VldEFsZXJ0LCBbe1xuICAgICAga2V5OiBcInRoZW5cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB0aGVuKG9uRnVsZmlsbGVkKSB7XG4gICAgICAgIHZhciBwcm9taXNlID0gcHJpdmF0ZVByb3BzLnByb21pc2UuZ2V0KHRoaXMpO1xuICAgICAgICByZXR1cm4gcHJvbWlzZS50aGVuKG9uRnVsZmlsbGVkKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZmluYWxseVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9maW5hbGx5KG9uRmluYWxseSkge1xuICAgICAgICB2YXIgcHJvbWlzZSA9IHByaXZhdGVQcm9wcy5wcm9taXNlLmdldCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHByb21pc2VbXCJmaW5hbGx5XCJdKG9uRmluYWxseSk7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIFN3ZWV0QWxlcnQ7XG4gIH0oKTsgLy8gQXNzaWduIGluc3RhbmNlIG1ldGhvZHMgZnJvbSBzcmMvaW5zdGFuY2VNZXRob2RzLyouanMgdG8gcHJvdG90eXBlXG5cblxuICBfZXh0ZW5kcyhTd2VldEFsZXJ0LnByb3RvdHlwZSwgaW5zdGFuY2VNZXRob2RzKTsgLy8gQXNzaWduIHN0YXRpYyBtZXRob2RzIGZyb20gc3JjL3N0YXRpY01ldGhvZHMvKi5qcyB0byBjb25zdHJ1Y3RvclxuXG5cbiAgX2V4dGVuZHMoU3dlZXRBbGVydCwgc3RhdGljTWV0aG9kcyk7IC8vIFByb3h5IHRvIGluc3RhbmNlIG1ldGhvZHMgdG8gY29uc3RydWN0b3IsIGZvciBub3csIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuXG5cbiAgT2JqZWN0LmtleXMoaW5zdGFuY2VNZXRob2RzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBTd2VldEFsZXJ0W2tleV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoY3VycmVudEluc3RhbmNlKSB7XG4gICAgICAgIHZhciBfY3VycmVudEluc3RhbmNlO1xuXG4gICAgICAgIHJldHVybiAoX2N1cnJlbnRJbnN0YW5jZSA9IGN1cnJlbnRJbnN0YW5jZSlba2V5XS5hcHBseShfY3VycmVudEluc3RhbmNlLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgIH07XG4gIH0pO1xuICBTd2VldEFsZXJ0LkRpc21pc3NSZWFzb24gPSBEaXNtaXNzUmVhc29uO1xuICBTd2VldEFsZXJ0LnZlcnNpb24gPSAnOS4xNy4yJztcblxuICB2YXIgU3dhbCA9IFN3ZWV0QWxlcnQ7XG4gIFN3YWxbXCJkZWZhdWx0XCJdID0gU3dhbDtcblxuICByZXR1cm4gU3dhbDtcblxufSkpO1xuaWYgKHR5cGVvZiB0aGlzICE9PSAndW5kZWZpbmVkJyAmJiB0aGlzLlN3ZWV0YWxlcnQyKXsgIHRoaXMuc3dhbCA9IHRoaXMuc3dlZXRBbGVydCA9IHRoaXMuU3dhbCA9IHRoaXMuU3dlZXRBbGVydCA9IHRoaXMuU3dlZXRhbGVydDJ9XG5cblwidW5kZWZpbmVkXCIhPXR5cGVvZiBkb2N1bWVudCYmZnVuY3Rpb24oZSx0KXt2YXIgbj1lLmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtpZihlLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaGVhZFwiKVswXS5hcHBlbmRDaGlsZChuKSxuLnN0eWxlU2hlZXQpbi5zdHlsZVNoZWV0LmRpc2FibGVkfHwobi5zdHlsZVNoZWV0LmNzc1RleHQ9dCk7ZWxzZSB0cnl7bi5pbm5lckhUTUw9dH1jYXRjaChlKXtuLmlubmVyVGV4dD10fX0oZG9jdW1lbnQsXCIuc3dhbDItcG9wdXAuc3dhbDItdG9hc3R7ZmxleC1kaXJlY3Rpb246cm93O2FsaWduLWl0ZW1zOmNlbnRlcjt3aWR0aDphdXRvO3BhZGRpbmc6LjYyNWVtO292ZXJmbG93LXk6aGlkZGVuO2JhY2tncm91bmQ6I2ZmZjtib3gtc2hhZG93OjAgMCAuNjI1ZW0gI2Q5ZDlkOX0uc3dhbDItcG9wdXAuc3dhbDItdG9hc3QgLnN3YWwyLWhlYWRlcntmbGV4LWRpcmVjdGlvbjpyb3c7cGFkZGluZzowfS5zd2FsMi1wb3B1cC5zd2FsMi10b2FzdCAuc3dhbDItdGl0bGV7ZmxleC1ncm93OjE7anVzdGlmeS1jb250ZW50OmZsZXgtc3RhcnQ7bWFyZ2luOjAgLjZlbTtmb250LXNpemU6MWVtfS5zd2FsMi1wb3B1cC5zd2FsMi10b2FzdCAuc3dhbDItZm9vdGVye21hcmdpbjouNWVtIDAgMDtwYWRkaW5nOi41ZW0gMCAwO2ZvbnQtc2l6ZTouOGVtfS5zd2FsMi1wb3B1cC5zd2FsMi10b2FzdCAuc3dhbDItY2xvc2V7cG9zaXRpb246c3RhdGljO3dpZHRoOi44ZW07aGVpZ2h0Oi44ZW07bGluZS1oZWlnaHQ6Ljh9LnN3YWwyLXBvcHVwLnN3YWwyLXRvYXN0IC5zd2FsMi1jb250ZW50e2p1c3RpZnktY29udGVudDpmbGV4LXN0YXJ0O3BhZGRpbmc6MDtmb250LXNpemU6MWVtfS5zd2FsMi1wb3B1cC5zd2FsMi10b2FzdCAuc3dhbDItaWNvbnt3aWR0aDoyZW07bWluLXdpZHRoOjJlbTtoZWlnaHQ6MmVtO21hcmdpbjowfS5zd2FsMi1wb3B1cC5zd2FsMi10b2FzdCAuc3dhbDItaWNvbiAuc3dhbDItaWNvbi1jb250ZW50e2Rpc3BsYXk6ZmxleDthbGlnbi1pdGVtczpjZW50ZXI7Zm9udC1zaXplOjEuOGVtO2ZvbnQtd2VpZ2h0OjcwMH1AbWVkaWEgYWxsIGFuZCAoLW1zLWhpZ2gtY29udHJhc3Q6bm9uZSksKC1tcy1oaWdoLWNvbnRyYXN0OmFjdGl2ZSl7LnN3YWwyLXBvcHVwLnN3YWwyLXRvYXN0IC5zd2FsMi1pY29uIC5zd2FsMi1pY29uLWNvbnRlbnR7Zm9udC1zaXplOi4yNWVtfX0uc3dhbDItcG9wdXAuc3dhbDItdG9hc3QgLnN3YWwyLWljb24uc3dhbDItc3VjY2VzcyAuc3dhbDItc3VjY2Vzcy1yaW5ne3dpZHRoOjJlbTtoZWlnaHQ6MmVtfS5zd2FsMi1wb3B1cC5zd2FsMi10b2FzdCAuc3dhbDItaWNvbi5zd2FsMi1lcnJvciBbY2xhc3NePXN3YWwyLXgtbWFyay1saW5lXXt0b3A6Ljg3NWVtO3dpZHRoOjEuMzc1ZW19LnN3YWwyLXBvcHVwLnN3YWwyLXRvYXN0IC5zd2FsMi1pY29uLnN3YWwyLWVycm9yIFtjbGFzc149c3dhbDIteC1tYXJrLWxpbmVdW2NsYXNzJD1sZWZ0XXtsZWZ0Oi4zMTI1ZW19LnN3YWwyLXBvcHVwLnN3YWwyLXRvYXN0IC5zd2FsMi1pY29uLnN3YWwyLWVycm9yIFtjbGFzc149c3dhbDIteC1tYXJrLWxpbmVdW2NsYXNzJD1yaWdodF17cmlnaHQ6LjMxMjVlbX0uc3dhbDItcG9wdXAuc3dhbDItdG9hc3QgLnN3YWwyLWFjdGlvbnN7ZmxleC1iYXNpczphdXRvIWltcG9ydGFudDt3aWR0aDphdXRvO2hlaWdodDphdXRvO21hcmdpbjowIC4zMTI1ZW19LnN3YWwyLXBvcHVwLnN3YWwyLXRvYXN0IC5zd2FsMi1zdHlsZWR7bWFyZ2luOjAgLjMxMjVlbTtwYWRkaW5nOi4zMTI1ZW0gLjYyNWVtO2ZvbnQtc2l6ZToxZW19LnN3YWwyLXBvcHVwLnN3YWwyLXRvYXN0IC5zd2FsMi1zdHlsZWQ6Zm9jdXN7Ym94LXNoYWRvdzowIDAgMCAxcHggI2ZmZiwwIDAgMCAzcHggcmdiYSg1MCwxMDAsMTUwLC40KX0uc3dhbDItcG9wdXAuc3dhbDItdG9hc3QgLnN3YWwyLXN1Y2Nlc3N7Ym9yZGVyLWNvbG9yOiNhNWRjODZ9LnN3YWwyLXBvcHVwLnN3YWwyLXRvYXN0IC5zd2FsMi1zdWNjZXNzIFtjbGFzc149c3dhbDItc3VjY2Vzcy1jaXJjdWxhci1saW5lXXtwb3NpdGlvbjphYnNvbHV0ZTt3aWR0aDoxLjZlbTtoZWlnaHQ6M2VtO3RyYW5zZm9ybTpyb3RhdGUoNDVkZWcpO2JvcmRlci1yYWRpdXM6NTAlfS5zd2FsMi1wb3B1cC5zd2FsMi10b2FzdCAuc3dhbDItc3VjY2VzcyBbY2xhc3NePXN3YWwyLXN1Y2Nlc3MtY2lyY3VsYXItbGluZV1bY2xhc3MkPWxlZnRde3RvcDotLjhlbTtsZWZ0Oi0uNWVtO3RyYW5zZm9ybTpyb3RhdGUoLTQ1ZGVnKTt0cmFuc2Zvcm0tb3JpZ2luOjJlbSAyZW07Ym9yZGVyLXJhZGl1czo0ZW0gMCAwIDRlbX0uc3dhbDItcG9wdXAuc3dhbDItdG9hc3QgLnN3YWwyLXN1Y2Nlc3MgW2NsYXNzXj1zd2FsMi1zdWNjZXNzLWNpcmN1bGFyLWxpbmVdW2NsYXNzJD1yaWdodF17dG9wOi0uMjVlbTtsZWZ0Oi45Mzc1ZW07dHJhbnNmb3JtLW9yaWdpbjowIDEuNWVtO2JvcmRlci1yYWRpdXM6MCA0ZW0gNGVtIDB9LnN3YWwyLXBvcHVwLnN3YWwyLXRvYXN0IC5zd2FsMi1zdWNjZXNzIC5zd2FsMi1zdWNjZXNzLXJpbmd7d2lkdGg6MmVtO2hlaWdodDoyZW19LnN3YWwyLXBvcHVwLnN3YWwyLXRvYXN0IC5zd2FsMi1zdWNjZXNzIC5zd2FsMi1zdWNjZXNzLWZpeHt0b3A6MDtsZWZ0Oi40Mzc1ZW07d2lkdGg6LjQzNzVlbTtoZWlnaHQ6Mi42ODc1ZW19LnN3YWwyLXBvcHVwLnN3YWwyLXRvYXN0IC5zd2FsMi1zdWNjZXNzIFtjbGFzc149c3dhbDItc3VjY2Vzcy1saW5lXXtoZWlnaHQ6LjMxMjVlbX0uc3dhbDItcG9wdXAuc3dhbDItdG9hc3QgLnN3YWwyLXN1Y2Nlc3MgW2NsYXNzXj1zd2FsMi1zdWNjZXNzLWxpbmVdW2NsYXNzJD10aXBde3RvcDoxLjEyNWVtO2xlZnQ6LjE4NzVlbTt3aWR0aDouNzVlbX0uc3dhbDItcG9wdXAuc3dhbDItdG9hc3QgLnN3YWwyLXN1Y2Nlc3MgW2NsYXNzXj1zd2FsMi1zdWNjZXNzLWxpbmVdW2NsYXNzJD1sb25nXXt0b3A6LjkzNzVlbTtyaWdodDouMTg3NWVtO3dpZHRoOjEuMzc1ZW19LnN3YWwyLXBvcHVwLnN3YWwyLXRvYXN0IC5zd2FsMi1zdWNjZXNzLnN3YWwyLWljb24tc2hvdyAuc3dhbDItc3VjY2Vzcy1saW5lLXRpcHstd2Via2l0LWFuaW1hdGlvbjpzd2FsMi10b2FzdC1hbmltYXRlLXN1Y2Nlc3MtbGluZS10aXAgLjc1czthbmltYXRpb246c3dhbDItdG9hc3QtYW5pbWF0ZS1zdWNjZXNzLWxpbmUtdGlwIC43NXN9LnN3YWwyLXBvcHVwLnN3YWwyLXRvYXN0IC5zd2FsMi1zdWNjZXNzLnN3YWwyLWljb24tc2hvdyAuc3dhbDItc3VjY2Vzcy1saW5lLWxvbmd7LXdlYmtpdC1hbmltYXRpb246c3dhbDItdG9hc3QtYW5pbWF0ZS1zdWNjZXNzLWxpbmUtbG9uZyAuNzVzO2FuaW1hdGlvbjpzd2FsMi10b2FzdC1hbmltYXRlLXN1Y2Nlc3MtbGluZS1sb25nIC43NXN9LnN3YWwyLXBvcHVwLnN3YWwyLXRvYXN0LnN3YWwyLXNob3d7LXdlYmtpdC1hbmltYXRpb246c3dhbDItdG9hc3Qtc2hvdyAuNXM7YW5pbWF0aW9uOnN3YWwyLXRvYXN0LXNob3cgLjVzfS5zd2FsMi1wb3B1cC5zd2FsMi10b2FzdC5zd2FsMi1oaWRley13ZWJraXQtYW5pbWF0aW9uOnN3YWwyLXRvYXN0LWhpZGUgLjFzIGZvcndhcmRzO2FuaW1hdGlvbjpzd2FsMi10b2FzdC1oaWRlIC4xcyBmb3J3YXJkc30uc3dhbDItY29udGFpbmVye2Rpc3BsYXk6ZmxleDtwb3NpdGlvbjpmaXhlZDt6LWluZGV4OjEwNjA7dG9wOjA7cmlnaHQ6MDtib3R0b206MDtsZWZ0OjA7ZmxleC1kaXJlY3Rpb246cm93O2FsaWduLWl0ZW1zOmNlbnRlcjtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO3BhZGRpbmc6LjYyNWVtO292ZXJmbG93LXg6aGlkZGVuO3RyYW5zaXRpb246YmFja2dyb3VuZC1jb2xvciAuMXM7LXdlYmtpdC1vdmVyZmxvdy1zY3JvbGxpbmc6dG91Y2h9LnN3YWwyLWNvbnRhaW5lci5zd2FsMi1iYWNrZHJvcC1zaG93LC5zd2FsMi1jb250YWluZXIuc3dhbDItbm9hbmltYXRpb257YmFja2dyb3VuZDpyZ2JhKDAsMCwwLC40KX0uc3dhbDItY29udGFpbmVyLnN3YWwyLWJhY2tkcm9wLWhpZGV7YmFja2dyb3VuZDowIDAhaW1wb3J0YW50fS5zd2FsMi1jb250YWluZXIuc3dhbDItdG9we2FsaWduLWl0ZW1zOmZsZXgtc3RhcnR9LnN3YWwyLWNvbnRhaW5lci5zd2FsMi10b3AtbGVmdCwuc3dhbDItY29udGFpbmVyLnN3YWwyLXRvcC1zdGFydHthbGlnbi1pdGVtczpmbGV4LXN0YXJ0O2p1c3RpZnktY29udGVudDpmbGV4LXN0YXJ0fS5zd2FsMi1jb250YWluZXIuc3dhbDItdG9wLWVuZCwuc3dhbDItY29udGFpbmVyLnN3YWwyLXRvcC1yaWdodHthbGlnbi1pdGVtczpmbGV4LXN0YXJ0O2p1c3RpZnktY29udGVudDpmbGV4LWVuZH0uc3dhbDItY29udGFpbmVyLnN3YWwyLWNlbnRlcnthbGlnbi1pdGVtczpjZW50ZXJ9LnN3YWwyLWNvbnRhaW5lci5zd2FsMi1jZW50ZXItbGVmdCwuc3dhbDItY29udGFpbmVyLnN3YWwyLWNlbnRlci1zdGFydHthbGlnbi1pdGVtczpjZW50ZXI7anVzdGlmeS1jb250ZW50OmZsZXgtc3RhcnR9LnN3YWwyLWNvbnRhaW5lci5zd2FsMi1jZW50ZXItZW5kLC5zd2FsMi1jb250YWluZXIuc3dhbDItY2VudGVyLXJpZ2h0e2FsaWduLWl0ZW1zOmNlbnRlcjtqdXN0aWZ5LWNvbnRlbnQ6ZmxleC1lbmR9LnN3YWwyLWNvbnRhaW5lci5zd2FsMi1ib3R0b217YWxpZ24taXRlbXM6ZmxleC1lbmR9LnN3YWwyLWNvbnRhaW5lci5zd2FsMi1ib3R0b20tbGVmdCwuc3dhbDItY29udGFpbmVyLnN3YWwyLWJvdHRvbS1zdGFydHthbGlnbi1pdGVtczpmbGV4LWVuZDtqdXN0aWZ5LWNvbnRlbnQ6ZmxleC1zdGFydH0uc3dhbDItY29udGFpbmVyLnN3YWwyLWJvdHRvbS1lbmQsLnN3YWwyLWNvbnRhaW5lci5zd2FsMi1ib3R0b20tcmlnaHR7YWxpZ24taXRlbXM6ZmxleC1lbmQ7anVzdGlmeS1jb250ZW50OmZsZXgtZW5kfS5zd2FsMi1jb250YWluZXIuc3dhbDItYm90dG9tLWVuZD46Zmlyc3QtY2hpbGQsLnN3YWwyLWNvbnRhaW5lci5zd2FsMi1ib3R0b20tbGVmdD46Zmlyc3QtY2hpbGQsLnN3YWwyLWNvbnRhaW5lci5zd2FsMi1ib3R0b20tcmlnaHQ+OmZpcnN0LWNoaWxkLC5zd2FsMi1jb250YWluZXIuc3dhbDItYm90dG9tLXN0YXJ0PjpmaXJzdC1jaGlsZCwuc3dhbDItY29udGFpbmVyLnN3YWwyLWJvdHRvbT46Zmlyc3QtY2hpbGR7bWFyZ2luLXRvcDphdXRvfS5zd2FsMi1jb250YWluZXIuc3dhbDItZ3Jvdy1mdWxsc2NyZWVuPi5zd2FsMi1tb2RhbHtkaXNwbGF5OmZsZXghaW1wb3J0YW50O2ZsZXg6MTthbGlnbi1zZWxmOnN0cmV0Y2g7anVzdGlmeS1jb250ZW50OmNlbnRlcn0uc3dhbDItY29udGFpbmVyLnN3YWwyLWdyb3ctcm93Pi5zd2FsMi1tb2RhbHtkaXNwbGF5OmZsZXghaW1wb3J0YW50O2ZsZXg6MTthbGlnbi1jb250ZW50OmNlbnRlcjtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyfS5zd2FsMi1jb250YWluZXIuc3dhbDItZ3Jvdy1jb2x1bW57ZmxleDoxO2ZsZXgtZGlyZWN0aW9uOmNvbHVtbn0uc3dhbDItY29udGFpbmVyLnN3YWwyLWdyb3ctY29sdW1uLnN3YWwyLWJvdHRvbSwuc3dhbDItY29udGFpbmVyLnN3YWwyLWdyb3ctY29sdW1uLnN3YWwyLWNlbnRlciwuc3dhbDItY29udGFpbmVyLnN3YWwyLWdyb3ctY29sdW1uLnN3YWwyLXRvcHthbGlnbi1pdGVtczpjZW50ZXJ9LnN3YWwyLWNvbnRhaW5lci5zd2FsMi1ncm93LWNvbHVtbi5zd2FsMi1ib3R0b20tbGVmdCwuc3dhbDItY29udGFpbmVyLnN3YWwyLWdyb3ctY29sdW1uLnN3YWwyLWJvdHRvbS1zdGFydCwuc3dhbDItY29udGFpbmVyLnN3YWwyLWdyb3ctY29sdW1uLnN3YWwyLWNlbnRlci1sZWZ0LC5zd2FsMi1jb250YWluZXIuc3dhbDItZ3Jvdy1jb2x1bW4uc3dhbDItY2VudGVyLXN0YXJ0LC5zd2FsMi1jb250YWluZXIuc3dhbDItZ3Jvdy1jb2x1bW4uc3dhbDItdG9wLWxlZnQsLnN3YWwyLWNvbnRhaW5lci5zd2FsMi1ncm93LWNvbHVtbi5zd2FsMi10b3Atc3RhcnR7YWxpZ24taXRlbXM6ZmxleC1zdGFydH0uc3dhbDItY29udGFpbmVyLnN3YWwyLWdyb3ctY29sdW1uLnN3YWwyLWJvdHRvbS1lbmQsLnN3YWwyLWNvbnRhaW5lci5zd2FsMi1ncm93LWNvbHVtbi5zd2FsMi1ib3R0b20tcmlnaHQsLnN3YWwyLWNvbnRhaW5lci5zd2FsMi1ncm93LWNvbHVtbi5zd2FsMi1jZW50ZXItZW5kLC5zd2FsMi1jb250YWluZXIuc3dhbDItZ3Jvdy1jb2x1bW4uc3dhbDItY2VudGVyLXJpZ2h0LC5zd2FsMi1jb250YWluZXIuc3dhbDItZ3Jvdy1jb2x1bW4uc3dhbDItdG9wLWVuZCwuc3dhbDItY29udGFpbmVyLnN3YWwyLWdyb3ctY29sdW1uLnN3YWwyLXRvcC1yaWdodHthbGlnbi1pdGVtczpmbGV4LWVuZH0uc3dhbDItY29udGFpbmVyLnN3YWwyLWdyb3ctY29sdW1uPi5zd2FsMi1tb2RhbHtkaXNwbGF5OmZsZXghaW1wb3J0YW50O2ZsZXg6MTthbGlnbi1jb250ZW50OmNlbnRlcjtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyfS5zd2FsMi1jb250YWluZXIuc3dhbDItbm8tdHJhbnNpdGlvbnt0cmFuc2l0aW9uOm5vbmUhaW1wb3J0YW50fS5zd2FsMi1jb250YWluZXI6bm90KC5zd2FsMi10b3ApOm5vdCguc3dhbDItdG9wLXN0YXJ0KTpub3QoLnN3YWwyLXRvcC1lbmQpOm5vdCguc3dhbDItdG9wLWxlZnQpOm5vdCguc3dhbDItdG9wLXJpZ2h0KTpub3QoLnN3YWwyLWNlbnRlci1zdGFydCk6bm90KC5zd2FsMi1jZW50ZXItZW5kKTpub3QoLnN3YWwyLWNlbnRlci1sZWZ0KTpub3QoLnN3YWwyLWNlbnRlci1yaWdodCk6bm90KC5zd2FsMi1ib3R0b20pOm5vdCguc3dhbDItYm90dG9tLXN0YXJ0KTpub3QoLnN3YWwyLWJvdHRvbS1lbmQpOm5vdCguc3dhbDItYm90dG9tLWxlZnQpOm5vdCguc3dhbDItYm90dG9tLXJpZ2h0KTpub3QoLnN3YWwyLWdyb3ctZnVsbHNjcmVlbik+LnN3YWwyLW1vZGFse21hcmdpbjphdXRvfUBtZWRpYSBhbGwgYW5kICgtbXMtaGlnaC1jb250cmFzdDpub25lKSwoLW1zLWhpZ2gtY29udHJhc3Q6YWN0aXZlKXsuc3dhbDItY29udGFpbmVyIC5zd2FsMi1tb2RhbHttYXJnaW46MCFpbXBvcnRhbnR9fS5zd2FsMi1wb3B1cHtkaXNwbGF5Om5vbmU7cG9zaXRpb246cmVsYXRpdmU7Ym94LXNpemluZzpib3JkZXItYm94O2ZsZXgtZGlyZWN0aW9uOmNvbHVtbjtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO3dpZHRoOjMyZW07bWF4LXdpZHRoOjEwMCU7cGFkZGluZzoxLjI1ZW07Ym9yZGVyOm5vbmU7Ym9yZGVyLXJhZGl1czouMzEyNWVtO2JhY2tncm91bmQ6I2ZmZjtmb250LWZhbWlseTppbmhlcml0O2ZvbnQtc2l6ZToxcmVtfS5zd2FsMi1wb3B1cDpmb2N1c3tvdXRsaW5lOjB9LnN3YWwyLXBvcHVwLnN3YWwyLWxvYWRpbmd7b3ZlcmZsb3cteTpoaWRkZW59LnN3YWwyLWhlYWRlcntkaXNwbGF5OmZsZXg7ZmxleC1kaXJlY3Rpb246Y29sdW1uO2FsaWduLWl0ZW1zOmNlbnRlcjtwYWRkaW5nOjAgMS44ZW19LnN3YWwyLXRpdGxle3Bvc2l0aW9uOnJlbGF0aXZlO21heC13aWR0aDoxMDAlO21hcmdpbjowIDAgLjRlbTtwYWRkaW5nOjA7Y29sb3I6IzU5NTk1OTtmb250LXNpemU6MS44NzVlbTtmb250LXdlaWdodDo2MDA7dGV4dC1hbGlnbjpjZW50ZXI7dGV4dC10cmFuc2Zvcm06bm9uZTt3b3JkLXdyYXA6YnJlYWstd29yZH0uc3dhbDItYWN0aW9uc3tkaXNwbGF5OmZsZXg7ei1pbmRleDoxO2ZsZXgtd3JhcDp3cmFwO2FsaWduLWl0ZW1zOmNlbnRlcjtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO3dpZHRoOjEwMCU7bWFyZ2luOjEuMjVlbSBhdXRvIDB9LnN3YWwyLWFjdGlvbnM6bm90KC5zd2FsMi1sb2FkaW5nKSAuc3dhbDItc3R5bGVkW2Rpc2FibGVkXXtvcGFjaXR5Oi40fS5zd2FsMi1hY3Rpb25zOm5vdCguc3dhbDItbG9hZGluZykgLnN3YWwyLXN0eWxlZDpob3ZlcntiYWNrZ3JvdW5kLWltYWdlOmxpbmVhci1ncmFkaWVudChyZ2JhKDAsMCwwLC4xKSxyZ2JhKDAsMCwwLC4xKSl9LnN3YWwyLWFjdGlvbnM6bm90KC5zd2FsMi1sb2FkaW5nKSAuc3dhbDItc3R5bGVkOmFjdGl2ZXtiYWNrZ3JvdW5kLWltYWdlOmxpbmVhci1ncmFkaWVudChyZ2JhKDAsMCwwLC4yKSxyZ2JhKDAsMCwwLC4yKSl9LnN3YWwyLWFjdGlvbnMuc3dhbDItbG9hZGluZyAuc3dhbDItc3R5bGVkLnN3YWwyLWNvbmZpcm17Ym94LXNpemluZzpib3JkZXItYm94O3dpZHRoOjIuNWVtO2hlaWdodDoyLjVlbTttYXJnaW46LjQ2ODc1ZW07cGFkZGluZzowOy13ZWJraXQtYW5pbWF0aW9uOnN3YWwyLXJvdGF0ZS1sb2FkaW5nIDEuNXMgbGluZWFyIDBzIGluZmluaXRlIG5vcm1hbDthbmltYXRpb246c3dhbDItcm90YXRlLWxvYWRpbmcgMS41cyBsaW5lYXIgMHMgaW5maW5pdGUgbm9ybWFsO2JvcmRlcjouMjVlbSBzb2xpZCB0cmFuc3BhcmVudDtib3JkZXItcmFkaXVzOjEwMCU7Ym9yZGVyLWNvbG9yOnRyYW5zcGFyZW50O2JhY2tncm91bmQtY29sb3I6dHJhbnNwYXJlbnQhaW1wb3J0YW50O2NvbG9yOnRyYW5zcGFyZW50IWltcG9ydGFudDtjdXJzb3I6ZGVmYXVsdDstd2Via2l0LXVzZXItc2VsZWN0Om5vbmU7LW1vei11c2VyLXNlbGVjdDpub25lOy1tcy11c2VyLXNlbGVjdDpub25lO3VzZXItc2VsZWN0Om5vbmV9LnN3YWwyLWFjdGlvbnMuc3dhbDItbG9hZGluZyAuc3dhbDItc3R5bGVkLnN3YWwyLWNhbmNlbHttYXJnaW4tcmlnaHQ6MzBweDttYXJnaW4tbGVmdDozMHB4fS5zd2FsMi1hY3Rpb25zLnN3YWwyLWxvYWRpbmcgOm5vdCguc3dhbDItc3R5bGVkKS5zd2FsMi1jb25maXJtOjphZnRlcntjb250ZW50OlxcXCJcXFwiO2Rpc3BsYXk6aW5saW5lLWJsb2NrO3dpZHRoOjE1cHg7aGVpZ2h0OjE1cHg7bWFyZ2luLWxlZnQ6NXB4Oy13ZWJraXQtYW5pbWF0aW9uOnN3YWwyLXJvdGF0ZS1sb2FkaW5nIDEuNXMgbGluZWFyIDBzIGluZmluaXRlIG5vcm1hbDthbmltYXRpb246c3dhbDItcm90YXRlLWxvYWRpbmcgMS41cyBsaW5lYXIgMHMgaW5maW5pdGUgbm9ybWFsO2JvcmRlcjozcHggc29saWQgIzk5OTtib3JkZXItcmFkaXVzOjUwJTtib3JkZXItcmlnaHQtY29sb3I6dHJhbnNwYXJlbnQ7Ym94LXNoYWRvdzoxcHggMXB4IDFweCAjZmZmfS5zd2FsMi1zdHlsZWR7bWFyZ2luOi4zMTI1ZW07cGFkZGluZzouNjI1ZW0gMmVtO2JveC1zaGFkb3c6bm9uZTtmb250LXdlaWdodDo1MDB9LnN3YWwyLXN0eWxlZDpub3QoW2Rpc2FibGVkXSl7Y3Vyc29yOnBvaW50ZXJ9LnN3YWwyLXN0eWxlZC5zd2FsMi1jb25maXJte2JvcmRlcjowO2JvcmRlci1yYWRpdXM6LjI1ZW07YmFja2dyb3VuZDppbml0aWFsO2JhY2tncm91bmQtY29sb3I6IzMwODVkNjtjb2xvcjojZmZmO2ZvbnQtc2l6ZToxLjA2MjVlbX0uc3dhbDItc3R5bGVkLnN3YWwyLWNhbmNlbHtib3JkZXI6MDtib3JkZXItcmFkaXVzOi4yNWVtO2JhY2tncm91bmQ6aW5pdGlhbDtiYWNrZ3JvdW5kLWNvbG9yOiNhYWE7Y29sb3I6I2ZmZjtmb250LXNpemU6MS4wNjI1ZW19LnN3YWwyLXN0eWxlZDpmb2N1c3tvdXRsaW5lOjA7Ym94LXNoYWRvdzowIDAgMCAxcHggI2ZmZiwwIDAgMCAzcHggcmdiYSg1MCwxMDAsMTUwLC40KX0uc3dhbDItc3R5bGVkOjotbW96LWZvY3VzLWlubmVye2JvcmRlcjowfS5zd2FsMi1mb290ZXJ7anVzdGlmeS1jb250ZW50OmNlbnRlcjttYXJnaW46MS4yNWVtIDAgMDtwYWRkaW5nOjFlbSAwIDA7Ym9yZGVyLXRvcDoxcHggc29saWQgI2VlZTtjb2xvcjojNTQ1NDU0O2ZvbnQtc2l6ZToxZW19LnN3YWwyLXRpbWVyLXByb2dyZXNzLWJhci1jb250YWluZXJ7cG9zaXRpb246YWJzb2x1dGU7cmlnaHQ6MDtib3R0b206MDtsZWZ0OjA7aGVpZ2h0Oi4yNWVtO292ZXJmbG93OmhpZGRlbjtib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czouMzEyNWVtO2JvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6LjMxMjVlbX0uc3dhbDItdGltZXItcHJvZ3Jlc3MtYmFye3dpZHRoOjEwMCU7aGVpZ2h0Oi4yNWVtO2JhY2tncm91bmQ6cmdiYSgwLDAsMCwuMil9LnN3YWwyLWltYWdle21heC13aWR0aDoxMDAlO21hcmdpbjoxLjI1ZW0gYXV0b30uc3dhbDItY2xvc2V7cG9zaXRpb246YWJzb2x1dGU7ei1pbmRleDoyO3RvcDowO3JpZ2h0OjA7YWxpZ24taXRlbXM6Y2VudGVyO2p1c3RpZnktY29udGVudDpjZW50ZXI7d2lkdGg6MS4yZW07aGVpZ2h0OjEuMmVtO3BhZGRpbmc6MDtvdmVyZmxvdzpoaWRkZW47dHJhbnNpdGlvbjpjb2xvciAuMXMgZWFzZS1vdXQ7Ym9yZGVyOm5vbmU7Ym9yZGVyLXJhZGl1czowO2JhY2tncm91bmQ6MCAwO2NvbG9yOiNjY2M7Zm9udC1mYW1pbHk6c2VyaWY7Zm9udC1zaXplOjIuNWVtO2xpbmUtaGVpZ2h0OjEuMjtjdXJzb3I6cG9pbnRlcn0uc3dhbDItY2xvc2U6aG92ZXJ7dHJhbnNmb3JtOm5vbmU7YmFja2dyb3VuZDowIDA7Y29sb3I6I2YyNzQ3NH0uc3dhbDItY2xvc2U6Oi1tb3otZm9jdXMtaW5uZXJ7Ym9yZGVyOjB9LnN3YWwyLWNvbnRlbnR7ei1pbmRleDoxO2p1c3RpZnktY29udGVudDpjZW50ZXI7bWFyZ2luOjA7cGFkZGluZzowIDEuNmVtO2NvbG9yOiM1NDU0NTQ7Zm9udC1zaXplOjEuMTI1ZW07Zm9udC13ZWlnaHQ6NDAwO2xpbmUtaGVpZ2h0Om5vcm1hbDt0ZXh0LWFsaWduOmNlbnRlcjt3b3JkLXdyYXA6YnJlYWstd29yZH0uc3dhbDItY2hlY2tib3gsLnN3YWwyLWZpbGUsLnN3YWwyLWlucHV0LC5zd2FsMi1yYWRpbywuc3dhbDItc2VsZWN0LC5zd2FsMi10ZXh0YXJlYXttYXJnaW46MWVtIGF1dG99LnN3YWwyLWZpbGUsLnN3YWwyLWlucHV0LC5zd2FsMi10ZXh0YXJlYXtib3gtc2l6aW5nOmJvcmRlci1ib3g7d2lkdGg6MTAwJTt0cmFuc2l0aW9uOmJvcmRlci1jb2xvciAuM3MsYm94LXNoYWRvdyAuM3M7Ym9yZGVyOjFweCBzb2xpZCAjZDlkOWQ5O2JvcmRlci1yYWRpdXM6LjE4NzVlbTtiYWNrZ3JvdW5kOmluaGVyaXQ7Ym94LXNoYWRvdzppbnNldCAwIDFweCAxcHggcmdiYSgwLDAsMCwuMDYpO2NvbG9yOmluaGVyaXQ7Zm9udC1zaXplOjEuMTI1ZW19LnN3YWwyLWZpbGUuc3dhbDItaW5wdXRlcnJvciwuc3dhbDItaW5wdXQuc3dhbDItaW5wdXRlcnJvciwuc3dhbDItdGV4dGFyZWEuc3dhbDItaW5wdXRlcnJvcntib3JkZXItY29sb3I6I2YyNzQ3NCFpbXBvcnRhbnQ7Ym94LXNoYWRvdzowIDAgMnB4ICNmMjc0NzQhaW1wb3J0YW50fS5zd2FsMi1maWxlOmZvY3VzLC5zd2FsMi1pbnB1dDpmb2N1cywuc3dhbDItdGV4dGFyZWE6Zm9jdXN7Ym9yZGVyOjFweCBzb2xpZCAjYjRkYmVkO291dGxpbmU6MDtib3gtc2hhZG93OjAgMCAzcHggI2M0ZTZmNX0uc3dhbDItZmlsZTo6LW1vei1wbGFjZWhvbGRlciwuc3dhbDItaW5wdXQ6Oi1tb3otcGxhY2Vob2xkZXIsLnN3YWwyLXRleHRhcmVhOjotbW96LXBsYWNlaG9sZGVye2NvbG9yOiNjY2N9LnN3YWwyLWZpbGU6LW1zLWlucHV0LXBsYWNlaG9sZGVyLC5zd2FsMi1pbnB1dDotbXMtaW5wdXQtcGxhY2Vob2xkZXIsLnN3YWwyLXRleHRhcmVhOi1tcy1pbnB1dC1wbGFjZWhvbGRlcntjb2xvcjojY2NjfS5zd2FsMi1maWxlOjotbXMtaW5wdXQtcGxhY2Vob2xkZXIsLnN3YWwyLWlucHV0OjotbXMtaW5wdXQtcGxhY2Vob2xkZXIsLnN3YWwyLXRleHRhcmVhOjotbXMtaW5wdXQtcGxhY2Vob2xkZXJ7Y29sb3I6I2NjY30uc3dhbDItZmlsZTo6cGxhY2Vob2xkZXIsLnN3YWwyLWlucHV0OjpwbGFjZWhvbGRlciwuc3dhbDItdGV4dGFyZWE6OnBsYWNlaG9sZGVye2NvbG9yOiNjY2N9LnN3YWwyLXJhbmdle21hcmdpbjoxZW0gYXV0bztiYWNrZ3JvdW5kOiNmZmZ9LnN3YWwyLXJhbmdlIGlucHV0e3dpZHRoOjgwJX0uc3dhbDItcmFuZ2Ugb3V0cHV0e3dpZHRoOjIwJTtjb2xvcjppbmhlcml0O2ZvbnQtd2VpZ2h0OjYwMDt0ZXh0LWFsaWduOmNlbnRlcn0uc3dhbDItcmFuZ2UgaW5wdXQsLnN3YWwyLXJhbmdlIG91dHB1dHtoZWlnaHQ6Mi42MjVlbTtwYWRkaW5nOjA7Zm9udC1zaXplOjEuMTI1ZW07bGluZS1oZWlnaHQ6Mi42MjVlbX0uc3dhbDItaW5wdXR7aGVpZ2h0OjIuNjI1ZW07cGFkZGluZzowIC43NWVtfS5zd2FsMi1pbnB1dFt0eXBlPW51bWJlcl17bWF4LXdpZHRoOjEwZW19LnN3YWwyLWZpbGV7YmFja2dyb3VuZDppbmhlcml0O2ZvbnQtc2l6ZToxLjEyNWVtfS5zd2FsMi10ZXh0YXJlYXtoZWlnaHQ6Ni43NWVtO3BhZGRpbmc6Ljc1ZW19LnN3YWwyLXNlbGVjdHttaW4td2lkdGg6NTAlO21heC13aWR0aDoxMDAlO3BhZGRpbmc6LjM3NWVtIC42MjVlbTtiYWNrZ3JvdW5kOmluaGVyaXQ7Y29sb3I6aW5oZXJpdDtmb250LXNpemU6MS4xMjVlbX0uc3dhbDItY2hlY2tib3gsLnN3YWwyLXJhZGlve2FsaWduLWl0ZW1zOmNlbnRlcjtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO2JhY2tncm91bmQ6I2ZmZjtjb2xvcjppbmhlcml0fS5zd2FsMi1jaGVja2JveCBsYWJlbCwuc3dhbDItcmFkaW8gbGFiZWx7bWFyZ2luOjAgLjZlbTtmb250LXNpemU6MS4xMjVlbX0uc3dhbDItY2hlY2tib3ggaW5wdXQsLnN3YWwyLXJhZGlvIGlucHV0e21hcmdpbjowIC40ZW19LnN3YWwyLXZhbGlkYXRpb24tbWVzc2FnZXtkaXNwbGF5Om5vbmU7YWxpZ24taXRlbXM6Y2VudGVyO2p1c3RpZnktY29udGVudDpjZW50ZXI7cGFkZGluZzouNjI1ZW07b3ZlcmZsb3c6aGlkZGVuO2JhY2tncm91bmQ6I2YwZjBmMDtjb2xvcjojNjY2O2ZvbnQtc2l6ZToxZW07Zm9udC13ZWlnaHQ6MzAwfS5zd2FsMi12YWxpZGF0aW9uLW1lc3NhZ2U6OmJlZm9yZXtjb250ZW50OlxcXCIhXFxcIjtkaXNwbGF5OmlubGluZS1ibG9jazt3aWR0aDoxLjVlbTttaW4td2lkdGg6MS41ZW07aGVpZ2h0OjEuNWVtO21hcmdpbjowIC42MjVlbTtib3JkZXItcmFkaXVzOjUwJTtiYWNrZ3JvdW5kLWNvbG9yOiNmMjc0NzQ7Y29sb3I6I2ZmZjtmb250LXdlaWdodDo2MDA7bGluZS1oZWlnaHQ6MS41ZW07dGV4dC1hbGlnbjpjZW50ZXJ9LnN3YWwyLWljb257cG9zaXRpb246cmVsYXRpdmU7Ym94LXNpemluZzpjb250ZW50LWJveDtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO3dpZHRoOjVlbTtoZWlnaHQ6NWVtO21hcmdpbjoxLjI1ZW0gYXV0byAxLjg3NWVtO2JvcmRlcjouMjVlbSBzb2xpZCB0cmFuc3BhcmVudDtib3JkZXItcmFkaXVzOjUwJTtmb250LWZhbWlseTppbmhlcml0O2xpbmUtaGVpZ2h0OjVlbTtjdXJzb3I6ZGVmYXVsdDstd2Via2l0LXVzZXItc2VsZWN0Om5vbmU7LW1vei11c2VyLXNlbGVjdDpub25lOy1tcy11c2VyLXNlbGVjdDpub25lO3VzZXItc2VsZWN0Om5vbmV9LnN3YWwyLWljb24gLnN3YWwyLWljb24tY29udGVudHtkaXNwbGF5OmZsZXg7YWxpZ24taXRlbXM6Y2VudGVyO2ZvbnQtc2l6ZTozLjc1ZW19LnN3YWwyLWljb24uc3dhbDItZXJyb3J7Ym9yZGVyLWNvbG9yOiNmMjc0NzQ7Y29sb3I6I2YyNzQ3NH0uc3dhbDItaWNvbi5zd2FsMi1lcnJvciAuc3dhbDIteC1tYXJre3Bvc2l0aW9uOnJlbGF0aXZlO2ZsZXgtZ3JvdzoxfS5zd2FsMi1pY29uLnN3YWwyLWVycm9yIFtjbGFzc149c3dhbDIteC1tYXJrLWxpbmVde2Rpc3BsYXk6YmxvY2s7cG9zaXRpb246YWJzb2x1dGU7dG9wOjIuMzEyNWVtO3dpZHRoOjIuOTM3NWVtO2hlaWdodDouMzEyNWVtO2JvcmRlci1yYWRpdXM6LjEyNWVtO2JhY2tncm91bmQtY29sb3I6I2YyNzQ3NH0uc3dhbDItaWNvbi5zd2FsMi1lcnJvciBbY2xhc3NePXN3YWwyLXgtbWFyay1saW5lXVtjbGFzcyQ9bGVmdF17bGVmdDoxLjA2MjVlbTt0cmFuc2Zvcm06cm90YXRlKDQ1ZGVnKX0uc3dhbDItaWNvbi5zd2FsMi1lcnJvciBbY2xhc3NePXN3YWwyLXgtbWFyay1saW5lXVtjbGFzcyQ9cmlnaHRde3JpZ2h0OjFlbTt0cmFuc2Zvcm06cm90YXRlKC00NWRlZyl9LnN3YWwyLWljb24uc3dhbDItZXJyb3Iuc3dhbDItaWNvbi1zaG93ey13ZWJraXQtYW5pbWF0aW9uOnN3YWwyLWFuaW1hdGUtZXJyb3ItaWNvbiAuNXM7YW5pbWF0aW9uOnN3YWwyLWFuaW1hdGUtZXJyb3ItaWNvbiAuNXN9LnN3YWwyLWljb24uc3dhbDItZXJyb3Iuc3dhbDItaWNvbi1zaG93IC5zd2FsMi14LW1hcmt7LXdlYmtpdC1hbmltYXRpb246c3dhbDItYW5pbWF0ZS1lcnJvci14LW1hcmsgLjVzO2FuaW1hdGlvbjpzd2FsMi1hbmltYXRlLWVycm9yLXgtbWFyayAuNXN9LnN3YWwyLWljb24uc3dhbDItd2FybmluZ3tib3JkZXItY29sb3I6I2ZhY2VhODtjb2xvcjojZjhiYjg2fS5zd2FsMi1pY29uLnN3YWwyLWluZm97Ym9yZGVyLWNvbG9yOiM5ZGUwZjY7Y29sb3I6IzNmYzNlZX0uc3dhbDItaWNvbi5zd2FsMi1xdWVzdGlvbntib3JkZXItY29sb3I6I2M5ZGFlMTtjb2xvcjojODdhZGJkfS5zd2FsMi1pY29uLnN3YWwyLXN1Y2Nlc3N7Ym9yZGVyLWNvbG9yOiNhNWRjODY7Y29sb3I6I2E1ZGM4Nn0uc3dhbDItaWNvbi5zd2FsMi1zdWNjZXNzIFtjbGFzc149c3dhbDItc3VjY2Vzcy1jaXJjdWxhci1saW5lXXtwb3NpdGlvbjphYnNvbHV0ZTt3aWR0aDozLjc1ZW07aGVpZ2h0OjcuNWVtO3RyYW5zZm9ybTpyb3RhdGUoNDVkZWcpO2JvcmRlci1yYWRpdXM6NTAlfS5zd2FsMi1pY29uLnN3YWwyLXN1Y2Nlc3MgW2NsYXNzXj1zd2FsMi1zdWNjZXNzLWNpcmN1bGFyLWxpbmVdW2NsYXNzJD1sZWZ0XXt0b3A6LS40Mzc1ZW07bGVmdDotMi4wNjM1ZW07dHJhbnNmb3JtOnJvdGF0ZSgtNDVkZWcpO3RyYW5zZm9ybS1vcmlnaW46My43NWVtIDMuNzVlbTtib3JkZXItcmFkaXVzOjcuNWVtIDAgMCA3LjVlbX0uc3dhbDItaWNvbi5zd2FsMi1zdWNjZXNzIFtjbGFzc149c3dhbDItc3VjY2Vzcy1jaXJjdWxhci1saW5lXVtjbGFzcyQ9cmlnaHRde3RvcDotLjY4NzVlbTtsZWZ0OjEuODc1ZW07dHJhbnNmb3JtOnJvdGF0ZSgtNDVkZWcpO3RyYW5zZm9ybS1vcmlnaW46MCAzLjc1ZW07Ym9yZGVyLXJhZGl1czowIDcuNWVtIDcuNWVtIDB9LnN3YWwyLWljb24uc3dhbDItc3VjY2VzcyAuc3dhbDItc3VjY2Vzcy1yaW5ne3Bvc2l0aW9uOmFic29sdXRlO3otaW5kZXg6Mjt0b3A6LS4yNWVtO2xlZnQ6LS4yNWVtO2JveC1zaXppbmc6Y29udGVudC1ib3g7d2lkdGg6MTAwJTtoZWlnaHQ6MTAwJTtib3JkZXI6LjI1ZW0gc29saWQgcmdiYSgxNjUsMjIwLDEzNCwuMyk7Ym9yZGVyLXJhZGl1czo1MCV9LnN3YWwyLWljb24uc3dhbDItc3VjY2VzcyAuc3dhbDItc3VjY2Vzcy1maXh7cG9zaXRpb246YWJzb2x1dGU7ei1pbmRleDoxO3RvcDouNWVtO2xlZnQ6MS42MjVlbTt3aWR0aDouNDM3NWVtO2hlaWdodDo1LjYyNWVtO3RyYW5zZm9ybTpyb3RhdGUoLTQ1ZGVnKX0uc3dhbDItaWNvbi5zd2FsMi1zdWNjZXNzIFtjbGFzc149c3dhbDItc3VjY2Vzcy1saW5lXXtkaXNwbGF5OmJsb2NrO3Bvc2l0aW9uOmFic29sdXRlO3otaW5kZXg6MjtoZWlnaHQ6LjMxMjVlbTtib3JkZXItcmFkaXVzOi4xMjVlbTtiYWNrZ3JvdW5kLWNvbG9yOiNhNWRjODZ9LnN3YWwyLWljb24uc3dhbDItc3VjY2VzcyBbY2xhc3NePXN3YWwyLXN1Y2Nlc3MtbGluZV1bY2xhc3MkPXRpcF17dG9wOjIuODc1ZW07bGVmdDouODEyNWVtO3dpZHRoOjEuNTYyNWVtO3RyYW5zZm9ybTpyb3RhdGUoNDVkZWcpfS5zd2FsMi1pY29uLnN3YWwyLXN1Y2Nlc3MgW2NsYXNzXj1zd2FsMi1zdWNjZXNzLWxpbmVdW2NsYXNzJD1sb25nXXt0b3A6Mi4zNzVlbTtyaWdodDouNWVtO3dpZHRoOjIuOTM3NWVtO3RyYW5zZm9ybTpyb3RhdGUoLTQ1ZGVnKX0uc3dhbDItaWNvbi5zd2FsMi1zdWNjZXNzLnN3YWwyLWljb24tc2hvdyAuc3dhbDItc3VjY2Vzcy1saW5lLXRpcHstd2Via2l0LWFuaW1hdGlvbjpzd2FsMi1hbmltYXRlLXN1Y2Nlc3MtbGluZS10aXAgLjc1czthbmltYXRpb246c3dhbDItYW5pbWF0ZS1zdWNjZXNzLWxpbmUtdGlwIC43NXN9LnN3YWwyLWljb24uc3dhbDItc3VjY2Vzcy5zd2FsMi1pY29uLXNob3cgLnN3YWwyLXN1Y2Nlc3MtbGluZS1sb25ney13ZWJraXQtYW5pbWF0aW9uOnN3YWwyLWFuaW1hdGUtc3VjY2Vzcy1saW5lLWxvbmcgLjc1czthbmltYXRpb246c3dhbDItYW5pbWF0ZS1zdWNjZXNzLWxpbmUtbG9uZyAuNzVzfS5zd2FsMi1pY29uLnN3YWwyLXN1Y2Nlc3Muc3dhbDItaWNvbi1zaG93IC5zd2FsMi1zdWNjZXNzLWNpcmN1bGFyLWxpbmUtcmlnaHR7LXdlYmtpdC1hbmltYXRpb246c3dhbDItcm90YXRlLXN1Y2Nlc3MtY2lyY3VsYXItbGluZSA0LjI1cyBlYXNlLWluO2FuaW1hdGlvbjpzd2FsMi1yb3RhdGUtc3VjY2Vzcy1jaXJjdWxhci1saW5lIDQuMjVzIGVhc2UtaW59LnN3YWwyLXByb2dyZXNzLXN0ZXBze2FsaWduLWl0ZW1zOmNlbnRlcjttYXJnaW46MCAwIDEuMjVlbTtwYWRkaW5nOjA7YmFja2dyb3VuZDppbmhlcml0O2ZvbnQtd2VpZ2h0OjYwMH0uc3dhbDItcHJvZ3Jlc3Mtc3RlcHMgbGl7ZGlzcGxheTppbmxpbmUtYmxvY2s7cG9zaXRpb246cmVsYXRpdmV9LnN3YWwyLXByb2dyZXNzLXN0ZXBzIC5zd2FsMi1wcm9ncmVzcy1zdGVwe3otaW5kZXg6MjA7d2lkdGg6MmVtO2hlaWdodDoyZW07Ym9yZGVyLXJhZGl1czoyZW07YmFja2dyb3VuZDojMzA4NWQ2O2NvbG9yOiNmZmY7bGluZS1oZWlnaHQ6MmVtO3RleHQtYWxpZ246Y2VudGVyfS5zd2FsMi1wcm9ncmVzcy1zdGVwcyAuc3dhbDItcHJvZ3Jlc3Mtc3RlcC5zd2FsMi1hY3RpdmUtcHJvZ3Jlc3Mtc3RlcHtiYWNrZ3JvdW5kOiMzMDg1ZDZ9LnN3YWwyLXByb2dyZXNzLXN0ZXBzIC5zd2FsMi1wcm9ncmVzcy1zdGVwLnN3YWwyLWFjdGl2ZS1wcm9ncmVzcy1zdGVwfi5zd2FsMi1wcm9ncmVzcy1zdGVwe2JhY2tncm91bmQ6I2FkZDhlNjtjb2xvcjojZmZmfS5zd2FsMi1wcm9ncmVzcy1zdGVwcyAuc3dhbDItcHJvZ3Jlc3Mtc3RlcC5zd2FsMi1hY3RpdmUtcHJvZ3Jlc3Mtc3RlcH4uc3dhbDItcHJvZ3Jlc3Mtc3RlcC1saW5le2JhY2tncm91bmQ6I2FkZDhlNn0uc3dhbDItcHJvZ3Jlc3Mtc3RlcHMgLnN3YWwyLXByb2dyZXNzLXN0ZXAtbGluZXt6LWluZGV4OjEwO3dpZHRoOjIuNWVtO2hlaWdodDouNGVtO21hcmdpbjowIC0xcHg7YmFja2dyb3VuZDojMzA4NWQ2fVtjbGFzc149c3dhbDJdey13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvcjp0cmFuc3BhcmVudH0uc3dhbDItc2hvd3std2Via2l0LWFuaW1hdGlvbjpzd2FsMi1zaG93IC4zczthbmltYXRpb246c3dhbDItc2hvdyAuM3N9LnN3YWwyLWhpZGV7LXdlYmtpdC1hbmltYXRpb246c3dhbDItaGlkZSAuMTVzIGZvcndhcmRzO2FuaW1hdGlvbjpzd2FsMi1oaWRlIC4xNXMgZm9yd2FyZHN9LnN3YWwyLW5vYW5pbWF0aW9ue3RyYW5zaXRpb246bm9uZX0uc3dhbDItc2Nyb2xsYmFyLW1lYXN1cmV7cG9zaXRpb246YWJzb2x1dGU7dG9wOi05OTk5cHg7d2lkdGg6NTBweDtoZWlnaHQ6NTBweDtvdmVyZmxvdzpzY3JvbGx9LnN3YWwyLXJ0bCAuc3dhbDItY2xvc2V7cmlnaHQ6YXV0bztsZWZ0OjB9LnN3YWwyLXJ0bCAuc3dhbDItdGltZXItcHJvZ3Jlc3MtYmFye3JpZ2h0OjA7bGVmdDphdXRvfUBzdXBwb3J0cyAoLW1zLWFjY2VsZXJhdG9yOnRydWUpey5zd2FsMi1yYW5nZSBpbnB1dHt3aWR0aDoxMDAlIWltcG9ydGFudH0uc3dhbDItcmFuZ2Ugb3V0cHV0e2Rpc3BsYXk6bm9uZX19QG1lZGlhIGFsbCBhbmQgKC1tcy1oaWdoLWNvbnRyYXN0Om5vbmUpLCgtbXMtaGlnaC1jb250cmFzdDphY3RpdmUpey5zd2FsMi1yYW5nZSBpbnB1dHt3aWR0aDoxMDAlIWltcG9ydGFudH0uc3dhbDItcmFuZ2Ugb3V0cHV0e2Rpc3BsYXk6bm9uZX19QC1tb3otZG9jdW1lbnQgdXJsLXByZWZpeCgpey5zd2FsMi1jbG9zZTpmb2N1c3tvdXRsaW5lOjJweCBzb2xpZCByZ2JhKDUwLDEwMCwxNTAsLjQpfX1ALXdlYmtpdC1rZXlmcmFtZXMgc3dhbDItdG9hc3Qtc2hvd3swJXt0cmFuc2Zvcm06dHJhbnNsYXRlWSgtLjYyNWVtKSByb3RhdGVaKDJkZWcpfTMzJXt0cmFuc2Zvcm06dHJhbnNsYXRlWSgwKSByb3RhdGVaKC0yZGVnKX02NiV7dHJhbnNmb3JtOnRyYW5zbGF0ZVkoLjMxMjVlbSkgcm90YXRlWigyZGVnKX0xMDAle3RyYW5zZm9ybTp0cmFuc2xhdGVZKDApIHJvdGF0ZVooMCl9fUBrZXlmcmFtZXMgc3dhbDItdG9hc3Qtc2hvd3swJXt0cmFuc2Zvcm06dHJhbnNsYXRlWSgtLjYyNWVtKSByb3RhdGVaKDJkZWcpfTMzJXt0cmFuc2Zvcm06dHJhbnNsYXRlWSgwKSByb3RhdGVaKC0yZGVnKX02NiV7dHJhbnNmb3JtOnRyYW5zbGF0ZVkoLjMxMjVlbSkgcm90YXRlWigyZGVnKX0xMDAle3RyYW5zZm9ybTp0cmFuc2xhdGVZKDApIHJvdGF0ZVooMCl9fUAtd2Via2l0LWtleWZyYW1lcyBzd2FsMi10b2FzdC1oaWRlezEwMCV7dHJhbnNmb3JtOnJvdGF0ZVooMWRlZyk7b3BhY2l0eTowfX1Aa2V5ZnJhbWVzIHN3YWwyLXRvYXN0LWhpZGV7MTAwJXt0cmFuc2Zvcm06cm90YXRlWigxZGVnKTtvcGFjaXR5OjB9fUAtd2Via2l0LWtleWZyYW1lcyBzd2FsMi10b2FzdC1hbmltYXRlLXN1Y2Nlc3MtbGluZS10aXB7MCV7dG9wOi41NjI1ZW07bGVmdDouMDYyNWVtO3dpZHRoOjB9NTQle3RvcDouMTI1ZW07bGVmdDouMTI1ZW07d2lkdGg6MH03MCV7dG9wOi42MjVlbTtsZWZ0Oi0uMjVlbTt3aWR0aDoxLjYyNWVtfTg0JXt0b3A6MS4wNjI1ZW07bGVmdDouNzVlbTt3aWR0aDouNWVtfTEwMCV7dG9wOjEuMTI1ZW07bGVmdDouMTg3NWVtO3dpZHRoOi43NWVtfX1Aa2V5ZnJhbWVzIHN3YWwyLXRvYXN0LWFuaW1hdGUtc3VjY2Vzcy1saW5lLXRpcHswJXt0b3A6LjU2MjVlbTtsZWZ0Oi4wNjI1ZW07d2lkdGg6MH01NCV7dG9wOi4xMjVlbTtsZWZ0Oi4xMjVlbTt3aWR0aDowfTcwJXt0b3A6LjYyNWVtO2xlZnQ6LS4yNWVtO3dpZHRoOjEuNjI1ZW19ODQle3RvcDoxLjA2MjVlbTtsZWZ0Oi43NWVtO3dpZHRoOi41ZW19MTAwJXt0b3A6MS4xMjVlbTtsZWZ0Oi4xODc1ZW07d2lkdGg6Ljc1ZW19fUAtd2Via2l0LWtleWZyYW1lcyBzd2FsMi10b2FzdC1hbmltYXRlLXN1Y2Nlc3MtbGluZS1sb25nezAle3RvcDoxLjYyNWVtO3JpZ2h0OjEuMzc1ZW07d2lkdGg6MH02NSV7dG9wOjEuMjVlbTtyaWdodDouOTM3NWVtO3dpZHRoOjB9ODQle3RvcDouOTM3NWVtO3JpZ2h0OjA7d2lkdGg6MS4xMjVlbX0xMDAle3RvcDouOTM3NWVtO3JpZ2h0Oi4xODc1ZW07d2lkdGg6MS4zNzVlbX19QGtleWZyYW1lcyBzd2FsMi10b2FzdC1hbmltYXRlLXN1Y2Nlc3MtbGluZS1sb25nezAle3RvcDoxLjYyNWVtO3JpZ2h0OjEuMzc1ZW07d2lkdGg6MH02NSV7dG9wOjEuMjVlbTtyaWdodDouOTM3NWVtO3dpZHRoOjB9ODQle3RvcDouOTM3NWVtO3JpZ2h0OjA7d2lkdGg6MS4xMjVlbX0xMDAle3RvcDouOTM3NWVtO3JpZ2h0Oi4xODc1ZW07d2lkdGg6MS4zNzVlbX19QC13ZWJraXQta2V5ZnJhbWVzIHN3YWwyLXNob3d7MCV7dHJhbnNmb3JtOnNjYWxlKC43KX00NSV7dHJhbnNmb3JtOnNjYWxlKDEuMDUpfTgwJXt0cmFuc2Zvcm06c2NhbGUoLjk1KX0xMDAle3RyYW5zZm9ybTpzY2FsZSgxKX19QGtleWZyYW1lcyBzd2FsMi1zaG93ezAle3RyYW5zZm9ybTpzY2FsZSguNyl9NDUle3RyYW5zZm9ybTpzY2FsZSgxLjA1KX04MCV7dHJhbnNmb3JtOnNjYWxlKC45NSl9MTAwJXt0cmFuc2Zvcm06c2NhbGUoMSl9fUAtd2Via2l0LWtleWZyYW1lcyBzd2FsMi1oaWRlezAle3RyYW5zZm9ybTpzY2FsZSgxKTtvcGFjaXR5OjF9MTAwJXt0cmFuc2Zvcm06c2NhbGUoLjUpO29wYWNpdHk6MH19QGtleWZyYW1lcyBzd2FsMi1oaWRlezAle3RyYW5zZm9ybTpzY2FsZSgxKTtvcGFjaXR5OjF9MTAwJXt0cmFuc2Zvcm06c2NhbGUoLjUpO29wYWNpdHk6MH19QC13ZWJraXQta2V5ZnJhbWVzIHN3YWwyLWFuaW1hdGUtc3VjY2Vzcy1saW5lLXRpcHswJXt0b3A6MS4xODc1ZW07bGVmdDouMDYyNWVtO3dpZHRoOjB9NTQle3RvcDoxLjA2MjVlbTtsZWZ0Oi4xMjVlbTt3aWR0aDowfTcwJXt0b3A6Mi4xODc1ZW07bGVmdDotLjM3NWVtO3dpZHRoOjMuMTI1ZW19ODQle3RvcDozZW07bGVmdDoxLjMxMjVlbTt3aWR0aDoxLjA2MjVlbX0xMDAle3RvcDoyLjgxMjVlbTtsZWZ0Oi44MTI1ZW07d2lkdGg6MS41NjI1ZW19fUBrZXlmcmFtZXMgc3dhbDItYW5pbWF0ZS1zdWNjZXNzLWxpbmUtdGlwezAle3RvcDoxLjE4NzVlbTtsZWZ0Oi4wNjI1ZW07d2lkdGg6MH01NCV7dG9wOjEuMDYyNWVtO2xlZnQ6LjEyNWVtO3dpZHRoOjB9NzAle3RvcDoyLjE4NzVlbTtsZWZ0Oi0uMzc1ZW07d2lkdGg6My4xMjVlbX04NCV7dG9wOjNlbTtsZWZ0OjEuMzEyNWVtO3dpZHRoOjEuMDYyNWVtfTEwMCV7dG9wOjIuODEyNWVtO2xlZnQ6LjgxMjVlbTt3aWR0aDoxLjU2MjVlbX19QC13ZWJraXQta2V5ZnJhbWVzIHN3YWwyLWFuaW1hdGUtc3VjY2Vzcy1saW5lLWxvbmd7MCV7dG9wOjMuMzc1ZW07cmlnaHQ6Mi44NzVlbTt3aWR0aDowfTY1JXt0b3A6My4zNzVlbTtyaWdodDoyLjg3NWVtO3dpZHRoOjB9ODQle3RvcDoyLjE4NzVlbTtyaWdodDowO3dpZHRoOjMuNDM3NWVtfTEwMCV7dG9wOjIuMzc1ZW07cmlnaHQ6LjVlbTt3aWR0aDoyLjkzNzVlbX19QGtleWZyYW1lcyBzd2FsMi1hbmltYXRlLXN1Y2Nlc3MtbGluZS1sb25nezAle3RvcDozLjM3NWVtO3JpZ2h0OjIuODc1ZW07d2lkdGg6MH02NSV7dG9wOjMuMzc1ZW07cmlnaHQ6Mi44NzVlbTt3aWR0aDowfTg0JXt0b3A6Mi4xODc1ZW07cmlnaHQ6MDt3aWR0aDozLjQzNzVlbX0xMDAle3RvcDoyLjM3NWVtO3JpZ2h0Oi41ZW07d2lkdGg6Mi45Mzc1ZW19fUAtd2Via2l0LWtleWZyYW1lcyBzd2FsMi1yb3RhdGUtc3VjY2Vzcy1jaXJjdWxhci1saW5lezAle3RyYW5zZm9ybTpyb3RhdGUoLTQ1ZGVnKX01JXt0cmFuc2Zvcm06cm90YXRlKC00NWRlZyl9MTIle3RyYW5zZm9ybTpyb3RhdGUoLTQwNWRlZyl9MTAwJXt0cmFuc2Zvcm06cm90YXRlKC00MDVkZWcpfX1Aa2V5ZnJhbWVzIHN3YWwyLXJvdGF0ZS1zdWNjZXNzLWNpcmN1bGFyLWxpbmV7MCV7dHJhbnNmb3JtOnJvdGF0ZSgtNDVkZWcpfTUle3RyYW5zZm9ybTpyb3RhdGUoLTQ1ZGVnKX0xMiV7dHJhbnNmb3JtOnJvdGF0ZSgtNDA1ZGVnKX0xMDAle3RyYW5zZm9ybTpyb3RhdGUoLTQwNWRlZyl9fUAtd2Via2l0LWtleWZyYW1lcyBzd2FsMi1hbmltYXRlLWVycm9yLXgtbWFya3swJXttYXJnaW4tdG9wOjEuNjI1ZW07dHJhbnNmb3JtOnNjYWxlKC40KTtvcGFjaXR5OjB9NTAle21hcmdpbi10b3A6MS42MjVlbTt0cmFuc2Zvcm06c2NhbGUoLjQpO29wYWNpdHk6MH04MCV7bWFyZ2luLXRvcDotLjM3NWVtO3RyYW5zZm9ybTpzY2FsZSgxLjE1KX0xMDAle21hcmdpbi10b3A6MDt0cmFuc2Zvcm06c2NhbGUoMSk7b3BhY2l0eToxfX1Aa2V5ZnJhbWVzIHN3YWwyLWFuaW1hdGUtZXJyb3IteC1tYXJrezAle21hcmdpbi10b3A6MS42MjVlbTt0cmFuc2Zvcm06c2NhbGUoLjQpO29wYWNpdHk6MH01MCV7bWFyZ2luLXRvcDoxLjYyNWVtO3RyYW5zZm9ybTpzY2FsZSguNCk7b3BhY2l0eTowfTgwJXttYXJnaW4tdG9wOi0uMzc1ZW07dHJhbnNmb3JtOnNjYWxlKDEuMTUpfTEwMCV7bWFyZ2luLXRvcDowO3RyYW5zZm9ybTpzY2FsZSgxKTtvcGFjaXR5OjF9fUAtd2Via2l0LWtleWZyYW1lcyBzd2FsMi1hbmltYXRlLWVycm9yLWljb257MCV7dHJhbnNmb3JtOnJvdGF0ZVgoMTAwZGVnKTtvcGFjaXR5OjB9MTAwJXt0cmFuc2Zvcm06cm90YXRlWCgwKTtvcGFjaXR5OjF9fUBrZXlmcmFtZXMgc3dhbDItYW5pbWF0ZS1lcnJvci1pY29uezAle3RyYW5zZm9ybTpyb3RhdGVYKDEwMGRlZyk7b3BhY2l0eTowfTEwMCV7dHJhbnNmb3JtOnJvdGF0ZVgoMCk7b3BhY2l0eToxfX1ALXdlYmtpdC1rZXlmcmFtZXMgc3dhbDItcm90YXRlLWxvYWRpbmd7MCV7dHJhbnNmb3JtOnJvdGF0ZSgwKX0xMDAle3RyYW5zZm9ybTpyb3RhdGUoMzYwZGVnKX19QGtleWZyYW1lcyBzd2FsMi1yb3RhdGUtbG9hZGluZ3swJXt0cmFuc2Zvcm06cm90YXRlKDApfTEwMCV7dHJhbnNmb3JtOnJvdGF0ZSgzNjBkZWcpfX1ib2R5LnN3YWwyLXNob3duOm5vdCguc3dhbDItbm8tYmFja2Ryb3ApOm5vdCguc3dhbDItdG9hc3Qtc2hvd24pe292ZXJmbG93OmhpZGRlbn1ib2R5LnN3YWwyLWhlaWdodC1hdXRve2hlaWdodDphdXRvIWltcG9ydGFudH1ib2R5LnN3YWwyLW5vLWJhY2tkcm9wIC5zd2FsMi1jb250YWluZXJ7dG9wOmF1dG87cmlnaHQ6YXV0bztib3R0b206YXV0bztsZWZ0OmF1dG87bWF4LXdpZHRoOmNhbGMoMTAwJSAtIC42MjVlbSAqIDIpO2JhY2tncm91bmQtY29sb3I6dHJhbnNwYXJlbnQhaW1wb3J0YW50fWJvZHkuc3dhbDItbm8tYmFja2Ryb3AgLnN3YWwyLWNvbnRhaW5lcj4uc3dhbDItbW9kYWx7Ym94LXNoYWRvdzowIDAgMTBweCByZ2JhKDAsMCwwLC40KX1ib2R5LnN3YWwyLW5vLWJhY2tkcm9wIC5zd2FsMi1jb250YWluZXIuc3dhbDItdG9we3RvcDowO2xlZnQ6NTAlO3RyYW5zZm9ybTp0cmFuc2xhdGVYKC01MCUpfWJvZHkuc3dhbDItbm8tYmFja2Ryb3AgLnN3YWwyLWNvbnRhaW5lci5zd2FsMi10b3AtbGVmdCxib2R5LnN3YWwyLW5vLWJhY2tkcm9wIC5zd2FsMi1jb250YWluZXIuc3dhbDItdG9wLXN0YXJ0e3RvcDowO2xlZnQ6MH1ib2R5LnN3YWwyLW5vLWJhY2tkcm9wIC5zd2FsMi1jb250YWluZXIuc3dhbDItdG9wLWVuZCxib2R5LnN3YWwyLW5vLWJhY2tkcm9wIC5zd2FsMi1jb250YWluZXIuc3dhbDItdG9wLXJpZ2h0e3RvcDowO3JpZ2h0OjB9Ym9keS5zd2FsMi1uby1iYWNrZHJvcCAuc3dhbDItY29udGFpbmVyLnN3YWwyLWNlbnRlcnt0b3A6NTAlO2xlZnQ6NTAlO3RyYW5zZm9ybTp0cmFuc2xhdGUoLTUwJSwtNTAlKX1ib2R5LnN3YWwyLW5vLWJhY2tkcm9wIC5zd2FsMi1jb250YWluZXIuc3dhbDItY2VudGVyLWxlZnQsYm9keS5zd2FsMi1uby1iYWNrZHJvcCAuc3dhbDItY29udGFpbmVyLnN3YWwyLWNlbnRlci1zdGFydHt0b3A6NTAlO2xlZnQ6MDt0cmFuc2Zvcm06dHJhbnNsYXRlWSgtNTAlKX1ib2R5LnN3YWwyLW5vLWJhY2tkcm9wIC5zd2FsMi1jb250YWluZXIuc3dhbDItY2VudGVyLWVuZCxib2R5LnN3YWwyLW5vLWJhY2tkcm9wIC5zd2FsMi1jb250YWluZXIuc3dhbDItY2VudGVyLXJpZ2h0e3RvcDo1MCU7cmlnaHQ6MDt0cmFuc2Zvcm06dHJhbnNsYXRlWSgtNTAlKX1ib2R5LnN3YWwyLW5vLWJhY2tkcm9wIC5zd2FsMi1jb250YWluZXIuc3dhbDItYm90dG9te2JvdHRvbTowO2xlZnQ6NTAlO3RyYW5zZm9ybTp0cmFuc2xhdGVYKC01MCUpfWJvZHkuc3dhbDItbm8tYmFja2Ryb3AgLnN3YWwyLWNvbnRhaW5lci5zd2FsMi1ib3R0b20tbGVmdCxib2R5LnN3YWwyLW5vLWJhY2tkcm9wIC5zd2FsMi1jb250YWluZXIuc3dhbDItYm90dG9tLXN0YXJ0e2JvdHRvbTowO2xlZnQ6MH1ib2R5LnN3YWwyLW5vLWJhY2tkcm9wIC5zd2FsMi1jb250YWluZXIuc3dhbDItYm90dG9tLWVuZCxib2R5LnN3YWwyLW5vLWJhY2tkcm9wIC5zd2FsMi1jb250YWluZXIuc3dhbDItYm90dG9tLXJpZ2h0e3JpZ2h0OjA7Ym90dG9tOjB9QG1lZGlhIHByaW50e2JvZHkuc3dhbDItc2hvd246bm90KC5zd2FsMi1uby1iYWNrZHJvcCk6bm90KC5zd2FsMi10b2FzdC1zaG93bil7b3ZlcmZsb3cteTpzY3JvbGwhaW1wb3J0YW50fWJvZHkuc3dhbDItc2hvd246bm90KC5zd2FsMi1uby1iYWNrZHJvcCk6bm90KC5zd2FsMi10b2FzdC1zaG93bik+W2FyaWEtaGlkZGVuPXRydWVde2Rpc3BsYXk6bm9uZX1ib2R5LnN3YWwyLXNob3duOm5vdCguc3dhbDItbm8tYmFja2Ryb3ApOm5vdCguc3dhbDItdG9hc3Qtc2hvd24pIC5zd2FsMi1jb250YWluZXJ7cG9zaXRpb246c3RhdGljIWltcG9ydGFudH19Ym9keS5zd2FsMi10b2FzdC1zaG93biAuc3dhbDItY29udGFpbmVye2JhY2tncm91bmQtY29sb3I6dHJhbnNwYXJlbnR9Ym9keS5zd2FsMi10b2FzdC1zaG93biAuc3dhbDItY29udGFpbmVyLnN3YWwyLXRvcHt0b3A6MDtyaWdodDphdXRvO2JvdHRvbTphdXRvO2xlZnQ6NTAlO3RyYW5zZm9ybTp0cmFuc2xhdGVYKC01MCUpfWJvZHkuc3dhbDItdG9hc3Qtc2hvd24gLnN3YWwyLWNvbnRhaW5lci5zd2FsMi10b3AtZW5kLGJvZHkuc3dhbDItdG9hc3Qtc2hvd24gLnN3YWwyLWNvbnRhaW5lci5zd2FsMi10b3AtcmlnaHR7dG9wOjA7cmlnaHQ6MDtib3R0b206YXV0bztsZWZ0OmF1dG99Ym9keS5zd2FsMi10b2FzdC1zaG93biAuc3dhbDItY29udGFpbmVyLnN3YWwyLXRvcC1sZWZ0LGJvZHkuc3dhbDItdG9hc3Qtc2hvd24gLnN3YWwyLWNvbnRhaW5lci5zd2FsMi10b3Atc3RhcnR7dG9wOjA7cmlnaHQ6YXV0bztib3R0b206YXV0bztsZWZ0OjB9Ym9keS5zd2FsMi10b2FzdC1zaG93biAuc3dhbDItY29udGFpbmVyLnN3YWwyLWNlbnRlci1sZWZ0LGJvZHkuc3dhbDItdG9hc3Qtc2hvd24gLnN3YWwyLWNvbnRhaW5lci5zd2FsMi1jZW50ZXItc3RhcnR7dG9wOjUwJTtyaWdodDphdXRvO2JvdHRvbTphdXRvO2xlZnQ6MDt0cmFuc2Zvcm06dHJhbnNsYXRlWSgtNTAlKX1ib2R5LnN3YWwyLXRvYXN0LXNob3duIC5zd2FsMi1jb250YWluZXIuc3dhbDItY2VudGVye3RvcDo1MCU7cmlnaHQ6YXV0bztib3R0b206YXV0bztsZWZ0OjUwJTt0cmFuc2Zvcm06dHJhbnNsYXRlKC01MCUsLTUwJSl9Ym9keS5zd2FsMi10b2FzdC1zaG93biAuc3dhbDItY29udGFpbmVyLnN3YWwyLWNlbnRlci1lbmQsYm9keS5zd2FsMi10b2FzdC1zaG93biAuc3dhbDItY29udGFpbmVyLnN3YWwyLWNlbnRlci1yaWdodHt0b3A6NTAlO3JpZ2h0OjA7Ym90dG9tOmF1dG87bGVmdDphdXRvO3RyYW5zZm9ybTp0cmFuc2xhdGVZKC01MCUpfWJvZHkuc3dhbDItdG9hc3Qtc2hvd24gLnN3YWwyLWNvbnRhaW5lci5zd2FsMi1ib3R0b20tbGVmdCxib2R5LnN3YWwyLXRvYXN0LXNob3duIC5zd2FsMi1jb250YWluZXIuc3dhbDItYm90dG9tLXN0YXJ0e3RvcDphdXRvO3JpZ2h0OmF1dG87Ym90dG9tOjA7bGVmdDowfWJvZHkuc3dhbDItdG9hc3Qtc2hvd24gLnN3YWwyLWNvbnRhaW5lci5zd2FsMi1ib3R0b217dG9wOmF1dG87cmlnaHQ6YXV0bztib3R0b206MDtsZWZ0OjUwJTt0cmFuc2Zvcm06dHJhbnNsYXRlWCgtNTAlKX1ib2R5LnN3YWwyLXRvYXN0LXNob3duIC5zd2FsMi1jb250YWluZXIuc3dhbDItYm90dG9tLWVuZCxib2R5LnN3YWwyLXRvYXN0LXNob3duIC5zd2FsMi1jb250YWluZXIuc3dhbDItYm90dG9tLXJpZ2h0e3RvcDphdXRvO3JpZ2h0OjA7Ym90dG9tOjA7bGVmdDphdXRvfWJvZHkuc3dhbDItdG9hc3QtY29sdW1uIC5zd2FsMi10b2FzdHtmbGV4LWRpcmVjdGlvbjpjb2x1bW47YWxpZ24taXRlbXM6c3RyZXRjaH1ib2R5LnN3YWwyLXRvYXN0LWNvbHVtbiAuc3dhbDItdG9hc3QgLnN3YWwyLWFjdGlvbnN7ZmxleDoxO2FsaWduLXNlbGY6c3RyZXRjaDtoZWlnaHQ6Mi4yZW07bWFyZ2luLXRvcDouMzEyNWVtfWJvZHkuc3dhbDItdG9hc3QtY29sdW1uIC5zd2FsMi10b2FzdCAuc3dhbDItbG9hZGluZ3tqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyfWJvZHkuc3dhbDItdG9hc3QtY29sdW1uIC5zd2FsMi10b2FzdCAuc3dhbDItaW5wdXR7aGVpZ2h0OjJlbTttYXJnaW46LjMxMjVlbSBhdXRvO2ZvbnQtc2l6ZToxZW19Ym9keS5zd2FsMi10b2FzdC1jb2x1bW4gLnN3YWwyLXRvYXN0IC5zd2FsMi12YWxpZGF0aW9uLW1lc3NhZ2V7Zm9udC1zaXplOjFlbX1cIik7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/sweetalert2/dist/sweetalert2.all.js\n");

/***/ }),

/***/ "./resources/js/dashboard/main.js":
/*!****************************************!*\
  !*** ./resources/js/dashboard/main.js ***!
  \****************************************/
/*! exports provided: ALLOWEDTYPES, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ALLOWEDTYPES\", function() { return ALLOWEDTYPES; });\n/* harmony import */ var sweetalert2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! sweetalert2 */ \"./node_modules/sweetalert2/dist/sweetalert2.all.js\");\n/* harmony import */ var sweetalert2__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(sweetalert2__WEBPACK_IMPORTED_MODULE_0__);\n\nElement.prototype.findParent = function (loops) {\n  var parent = this;\n\n  for (var i = 0; i < loops; i++) {\n    parent = parent.parentElement;\n  }\n\n  return parent;\n}, false;\nElement.prototype.appendBefore = function (element) {\n  element.parentNode.insertBefore(this, element);\n}, false;\nElement.prototype.appendAfter = function (element) {\n  element.parentNode.insertBefore(this, element.nextSibling);\n}, false; //!##########################################\n//!\t\t\t\tGlobal Variables\t\tF\t#\n//!##########################################\n\nvar baseUrl = window.location.origin;\nvar timer = 0;\nvar ALLOWEDTYPES = [\"application/octet-stream\", \"application/x-zip-compressed\", \"application/pdf\", \"application/msword\", \"application/vnd.openxmlformats-officedocument.wordprocessingml.document\", \"application/vnd.openxmlformats-officedocument.wordprocessingml.template\", \"application/vnd.ms-word.document.macroEnabled.12\", \"application/vnd.ms-word.template.macroEnabled.12\", \"application/vnd.ms-excel\", \"application/vnd.ms-excel\", \"application/vnd.ms-excel\", \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\", \"application/vnd.openxmlformats-officedocument.spreadsheetml.template\", \"application/vnd.ms-excel.sheet.macroEnabled.12\", \"application/vnd.ms-excel.template.macroEnabled.12\", \"application/vnd.ms-excel.addin.macroEnabled.12\", \"application/vnd.ms-excel.sheet.binary.macroEnabled.12\", \"application/vnd.ms-powerpoint\", \"application/vnd.openxmlformats-officedocument.presentationml.presentation\", \"application/vnd.openxmlformats-officedocument.presentationml.template\", \"application/vnd.openxmlformats-officedocument.presentationml.slideshow\", \"application/vnd.ms-powerpoint.addin.macroEnabled.12\", \"application/vnd.ms-powerpoint.presentation.macroEnabled.12\", \"application/vnd.ms-powerpoint.template.macroEnabled.12\", \"application/vnd.ms-powerpoint.slideshow.macroEnabled.12\", \"application/vnd.ms-access\", \"audio/mpeg\", \"application/vnd.oasis.opendocument.presentation\", \"application/vnd.oasis.opendocument.spreadsheet\", \"application/vnd.oasis.opendocument.text\", \"application/rtf\", \"application/vnd.oasis.opendocument.graphics\", \"text/html\"]; //!##########################################\n//!\t\t\t\tConfigurations\t\t\t\t#\n//!##########################################\n//!ALERT\n//!============================================================\n\nfunction toastAlert(icon, message) {\n  sweetalert2__WEBPACK_IMPORTED_MODULE_0___default.a.fire({\n    toast: 'true',\n    position: 'top-end',\n    icon: icon,\n    title: message,\n    showConfirmButton: false,\n    timer: 3000,\n    timerProgressBar: true\n  });\n}\n\nfunction toastAlertDelete(text) {\n  var icon = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"warning\";\n  return sweetalert2__WEBPACK_IMPORTED_MODULE_0___default.a.fire({\n    title: 'Είστε σίγουρος/η;',\n    text: text,\n    icon: icon,\n    showCancelButton: true,\n    confirmButtonColor: '#ff5b5b',\n    confirmButtonText: 'Ναί, διαγραφή!',\n    cancelButtonText: 'Άκυρο'\n  });\n} //!CONFIG\n//!============================================================\n\n\nvar articleConfig = {\n  css: \"/css/\",\n  custom: {\n    css: [\"/css/bootstrap.min.css\", \"/css/customArticleStyle.css\"]\n  },\n  // plugins: ['mediaLibrary', 'reorder'],\n  classes: {\n    img: 'img-fluid',\n    p: 'text-wrap'\n  },\n  grid: {\n    classname: 'row',\n    columns: 12,\n    gutter: '1px',\n    offset: {\n      left: '15px',\n      right: '15px'\n    },\n    patterns: {\n      '6|6': 'col-6|col-6',\n      '4|4|4': 'col-4|col-4|col-4',\n      '3|3|3|3': 'col-3|col-3|col-3|col-3',\n      '2|2|2|2|2|2': 'col-2|col-2|col-2|col-2|col-2|col-2',\n      '3|6|3': 'col-3|col-6|col-3',\n      '2|8|2': 'col-2|col-8|col-2',\n      '5|7': 'col-5|col-7',\n      '7|5': 'col-7|col-5',\n      '4|8': 'col-4|col-8',\n      '8|4': 'col-8|col-4',\n      '3|9': 'col-3|col-9',\n      '9|3': 'col-9|col-3',\n      '2|10': 'col-2|col-10',\n      '10|2': 'col-10|col-2',\n      '12': 'col-12'\n    }\n  },\n  align: {\n    left: \"text-left\",\n    center: \"text-center\",\n    right: \"text-right\"\n  },\n  editor: {\n    minHeight: \"300px\"\n  },\n  image: {\n    upload: \"/media/upload-images\",\n    data: {\n      \"_token\": $('meta[name=\"csrf-token\"]').attr('content')\n    }\n  }\n};\nvar redactorConfig = {\n  buttons: ['html', 'undo', 'redo', 'format', 'bold', 'underline', 'italic', 'deleted', 'sup', 'sub', 'lists', 'file', 'link', 'image'],\n  style: false,\n  plugins: ['alignment'],\n  minHeight: '150px'\n};\nvar datePickerConfig = {\n  ranges: {\n    'Today': [moment(), moment()],\n    'Yesterday': [moment().subtract(1, 'days'), moment().subtract(1, 'days')],\n    'Last 7 Days': [moment().subtract(6, 'days'), moment()],\n    'Last 30 Days': [moment().subtract(29, 'days'), moment()],\n    'This Month': [moment().startOf('month'), moment().endOf('month')],\n    'Last Month': [moment().subtract(1, 'month').startOf('month'), moment().subtract(1, 'month').endOf('month')],\n    'This Year': [moment().startOf('year'), moment().endOf('year')],\n    'Last Year': [moment().subtract(1, 'year').startOf('year'), moment().subtract(1, 'year').endOf('year')]\n  },\n  alwaysShowCalendars: true,\n  showCustomRangeLabel: false,\n  drops: \"auto\",\n  autoUpdateInput: false,\n  opens: \"center\",\n  locale: {\n    format: \"DD/MM/YYYY\"\n  }\n};\nvar tableLocale = {\n  emptyTable: \"Δεν υπάρχουν εγγραφές\",\n  info: \"_START_ έως _END_ απο τα _TOTAL_ αποτελέσματα\",\n  infoEmpty: \"0 απο 0 τα 0 αποτελέσματα\",\n  lengthMenu: \"_MENU_\",\n  loadingRecords: \"Φόρτωση ...\",\n  processing: \"Επεξεργασία ...\",\n  search: \"\",\n  searchPlaceholder: \"Αναζήτηση... \",\n  zeroRecords: \"Δεν βρέθηκαν αποτελέσματα\",\n  paginate: {\n    previous: \"<i class='mdi mdi-chevron-left'>\",\n    next: \"<i class='mdi mdi-chevron-right'>\"\n  },\n  infoFiltered: \"(Φιλτραρισμένα απο τις _MAX_ εγγραφές)\"\n}; //!GLOBAL FUNCTION\n//!============================================================\n\nfunction mainCheckboxSwitcher(main, minor) {\n  var bulkBtn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var status = true;\n  var counter = 0;\n  main.checked = true;\n\n  for (var i = 0; i < minor.length; i++) {\n    if (!minor[i].checked) {\n      minor[i].findParent(3).classList.remove(\"bg-selected\");\n      main.checked = false;\n    } else {\n      minor[i].findParent(3).classList.add(\"bg-selected\");\n      counter++;\n      status = false;\n    }\n  }\n\n  if (bulkBtn) {\n    bulkModifier(bulkBtn, status, counter);\n  }\n}\n\nfunction minorCheckboxSwitcher(main, minor) {\n  var bulkBtn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var counter = 0;\n  var status = true;\n\n  if (main.checked && minor.length > 0) {\n    counter = minor.length;\n    status = false;\n\n    for (var i = 0; i < minor.length; i++) {\n      minor[i].checked = true;\n      minor[i].findParent(3).classList.add(\"bg-selected\");\n    }\n  } else {\n    for (var i = 0; i < minor.length; i++) {\n      minor[i].checked = false;\n      minor[i].findParent(3).classList.remove(\"bg-selected\");\n    }\n  }\n\n  if (bulkBtn) {\n    bulkModifier(bulkBtn, status, counter);\n  }\n}\n\nfunction bulkModifier(bulkBtn, status, sum) {\n  var text = bulkBtn.dataset.text ? bulkBtn.dataset.text : \"Επιλογές\";\n  var enabledColor = bulkBtn.dataset.enabledColor ? bulkBtn.dataset.enabledColor : \"btn-warning\";\n  var disabledColor = bulkBtn.dataset.disabledColor ? bulkBtn.dataset.disabledColor : \"btn-secondary\";\n\n  if (status) {\n    bulkBtn.classList.remove(enabledColor);\n    bulkBtn.classList.add(disabledColor);\n    bulkBtn.textContent = \"\".concat(text, \" (0)  \");\n    bulkBtn.disabled = true;\n  } else {\n    bulkBtn.classList.remove(disabledColor);\n    bulkBtn.classList.add(enabledColor);\n    bulkBtn.textContent = \"\".concat(text, \"  (\").concat(sum, \")  \");\n    bulkBtn.disabled = false;\n  }\n}\n\nfunction filterStyle(input, value) {\n  if (value == \"\") {\n    input.classList.remove(\"select2-selected\");\n  } else {\n    input.classList.add(\"select2-selected\");\n  }\n}\n\nvar filterButton = function filterButton(attr, column, table, tableId) {\n  $(attr).detach().appendTo(tableId);\n  $(attr).on('change', function () {\n    table.columns(column).search(this.value).draw();\n  });\n};\n\nvar changeInputHidden = function changeInputHidden(attr, hiddenAttr) {\n  $(attr).change(function () {\n    if (attr == \"#activeMaterial\") {\n      this.value = $(this).prop('checked') == true ? 1 : 0;\n    }\n\n    var hiddenValue = $(hiddenAttr)[0].value = this.value;\n  });\n};\n\nfunction createStateSelect() {\n  var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n  var selectElm = document.createElement(\"select\");\n  selectElm.classList.add(\"ml-1\", \"select2\");\n  selectElm.id = id;\n  selectElm.innerHTML = \"\\n\\t\\t<option value=\\\"\\\">\\u038C\\u03BB\\u03B5\\u03C2 \\u03BF\\u03B9 \\u039A\\u03B1\\u03C4\\u03B1\\u03C3\\u03C4\\u03AC\\u03C3\\u03B5\\u03B9\\u03C2</option>\\n\\t\\t<option value=\\\"1\\\">\\u0395\\u03BD\\u03B5\\u03C1\\u03B3\\u03AC</option>\\n\\t\\t<option value=\\\"0\\\">\\u0391\\u03BD\\u03B5\\u03BD\\u03B5\\u03C1\\u03B3\\u03AC</option>\\n\\t\";\n  return selectElm;\n}\n\nfunction createDateElm(id) {\n  var input = document.createElement(\"input\");\n  input.classList.add(\"form-control\", \"date\", \"d-inline-block\", \"ml-1\", \"js-date-search\");\n  input.id = id;\n  input.dataset.toggle = \"date-picker\";\n  input.dataset.cancelClass = \"btn-secondary\";\n  input.style.height = \"31.96px\";\n  input.style.width = \"195px\";\n  input.placeholder = \"Επιλέξτε ημερομηνίες...\";\n  return input;\n}\n\nfunction createCourseTypeSelect() {\n  var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n  var selectElm = document.createElement(\"select\");\n  selectElm.classList.add(\"ml-1\", \"select2\");\n  selectElm.id = id;\n  selectElm.innerHTML = \"\\n\\t\\t<option value=\\\"\\\">\\u038C\\u03BB\\u03B5\\u03C2 \\u03BF\\u03B9 \\u0395\\u03BA\\u03B4\\u03CC\\u03C3\\u03B5\\u03B9\\u03C2</option>\\n\\t\\t<option value=\\\"Normal\\\">Normal</option>\\n\\t\\t<option value=\\\"Trial\\\">Trial</option>\\n\\t\";\n  return selectElm;\n}\n\nfunction startDate(input) {\n  var dateInput = input;\n\n  if (!dateInput || dateInput.value == \"\") {\n    return \"\";\n  }\n\n  var dateInputValue = dateInput.value.split(\" - \");\n  var firstDate = dateInputValue[0].split(\"/\").reverse().join(\"-\");\n  return firstDate;\n}\n\nfunction endDate(input) {\n  var dateInput = input;\n\n  if (!dateInput || dateInput.value == \"\") {\n    return \"\";\n  }\n\n  var dateInputValue = dateInput.value.split(\" - \");\n  var secondDate = dateInputValue[1].split(\"/\").reverse().join(\"-\");\n  return secondDate;\n}\n\nfunction resetBulk(bulkBtn, checkbox) {\n  var text = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"Επιλογές  (0)\";\n  bulkBtn.text(text);\n  bulkBtn.addClass(\"btn-secondary\");\n  bulkBtn.removeClass(\"btn-warning btn-danger\");\n  bulkBtn.prop(\"disabled\", true);\n  checkbox.prop(\"checked\", false);\n}\n\nfunction resetAddButton(addBtn, checkbox) {\n  addBtn.text(\"Προσθήκη Επιλογών (0)\");\n  addBtn.addClass(\"btn-secondary\");\n  addBtn.removeClass(\"btn-primary\");\n  addBtn.prop(\"disabled\", true);\n  checkbox.prop(\"checked\", false);\n}\n\nfunction passwordValidation() {\n  return sweetalert2__WEBPACK_IMPORTED_MODULE_0___default.a.fire({\n    title: \"Παρακαλώ εισάγεται Κωδικό\",\n    input: \"password\",\n    showCancelButton: true,\n    confirmButtonColor: \"#536de6\",\n    showLoaderOnConfirm: true,\n    preConfirm: function preConfirm(password) {\n      return axios.post(\"/users-ajax/confirm-password\", {\n        password: password\n      }).then(function (res) {\n        return res.status;\n      })[\"catch\"](function (err) {\n        sweetalert2__WEBPACK_IMPORTED_MODULE_0___default.a.showValidationMessage(err.response.data);\n      });\n    }\n  });\n} //!##############################################\n//!\t\t\t\tMedia Library Functions\t\t\t#\n//!##############################################\n\n\nfunction paginationHandler(event) {\n  event.preventDefault();\n  var activePage = this.href.split(\"page=\")[1];\n  var search = $(\"#image-search\").val();\n  paginationRequest(activePage, search);\n}\n\nfunction searchHandler() {\n  clearTimeout(timer);\n\n  if (this.value.length < 3 || this.value == \"\") {\n    timer = setTimeout(paginationRequest, 800, 1, \"\");\n  } else {\n    timer = setTimeout(paginationRequest, 800, 1, this.value);\n  }\n}\n\nfunction imageHandler() {\n  var modal = $(\"#gallery-content\")[0];\n  var model = modal.dataset.model;\n  var modelId = modal.dataset.id;\n  var editorId = modal.dataset.editorId;\n  var type = modal.dataset.type;\n  var image = {\n    'img': {\n      url: \"\".concat(this.dataset.imageSource)\n    }\n  };\n\n  if (type == \"article\") {\n    ArticleEditor(editorId).image.insert(image);\n  } else if (type == \"redactor\") {\n    $R(editorId, 'insertion.insertHtml', \"<img class=\\\"img-fluid\\\" src=\\\"\".concat(this.dataset.imageSource, \"\\\" alt=\\\"\").concat(this.dataset.name, \"\\\" />\"));\n  } else if (type == \"gallery\") {\n    $(\"#remove-all-images-btn\").removeClass(\"d-none\");\n    addToGallery(model, modelId, this.dataset.imageId);\n    return;\n  } else {\n    changeCoverRequest(model, modelId, this.dataset.imageSource);\n  }\n\n  $(\"#gallery-modal\").modal('hide');\n}\n\nfunction paginationRequest(activePage, search) {\n  axios.get(\"/media/images\", {\n    params: {\n      page: activePage,\n      search: search\n    }\n  }).then(function (res) {\n    var gallery = $(\"#gallery-content\")[0];\n    gallery.innerHTML = res.data;\n    var pagination = gallery.getElementsByClassName(\"js-gallery-page-btn\");\n    var addBtns = gallery.getElementsByClassName(\"js-add-image\");\n\n    for (var i = 0; i < addBtns.length; i++) {\n      addBtns[i].removeEventListener(\"click\", imageHandler);\n      addBtns[i].addEventListener(\"click\", imageHandler);\n    }\n\n    for (var _i = 0; _i < pagination.length; _i++) {\n      pagination[_i].removeEventListener(\"click\", paginationHandler);\n\n      pagination[_i].addEventListener(\"click\", paginationHandler);\n    }\n  });\n}\n\nfunction changeCoverRequest(namespace, id, url) {\n  if (typeof id === \"undefined\" && namespace == \"App\\\\Models\\\\User\") {\n    var img = $(\"#cover-image\")[0];\n    var removeBtnCnt = $(\"#remove-cover-btn\").parent();\n    img.src = \"\".concat(url);\n    img.classList.remove(\"d-none\");\n    removeBtnCnt.removeClass(\"d-none\");\n    removeBtnCnt.addClass(\"d-flex\");\n    $(\"#custom-file\")[0].value = \"\".concat(url);\n  } else {\n    axios.patch(\"/media/cover/replace\", {\n      namespace: namespace,\n      id: id,\n      url: url\n    }).then(function (res) {\n      var img = $(\"#cover-image\")[0];\n      var removeBtnCnt = $(\"#remove-cover-btn\").parent();\n      img.src = res.data.imgUrl;\n      img.classList.remove(\"d-none\");\n      $(\"#change-cover-btn\").text(\"Αλλαγή\");\n      $(\"#cover-status\").addClass(\"d-none\");\n      removeBtnCnt.removeClass(\"d-none\");\n      removeBtnCnt.addClass(\"d-flex\");\n      toastAlert(\"success\", \"Το Cover άλλαξε!\");\n    })[\"catch\"](function (err) {\n      console.log(err);\n      toastAlert('error', \"Παρουσιάστηκε κάποιο πρόβλημα ...\");\n    });\n  }\n}\n\nfunction addToGallery(namespace, id, imageId) {\n  axios.post(\"/media/gallery\", {\n    namespace: namespace,\n    modelId: id,\n    ids: [imageId]\n  }).then(function (res) {\n    var gallery = $(\"#gallery-cnt\");\n    gallery.html(res.data);\n    var closeBtns = gallery.find(\".js-remove-image\");\n    closeBtns.on(\"click\", removeImageHandler);\n    toastAlert(\"success\", \"Η εικόνα προστέθηκε.\");\n    gallery.modal(\"hide\");\n    var bulk = $(\"#gallery-bulk-action-btn\");\n    var checkboxes = $(\".js-gallery-checkbox\");\n    resetGalleryBtns(bulk, checkboxes);\n  })[\"catch\"](function (err) {\n    console.log(err);\n    toastAlert('error', \"Παρουσιάστηκε κάποιο πρόβλημα ...\");\n  });\n}\n\nfunction removeImageHandler() {\n  var _this = this;\n\n  sweetalert2__WEBPACK_IMPORTED_MODULE_0___default.a.fire({\n    icon: 'info',\n    title: 'Προσοχή!',\n    text: 'Η εικόνα θα αφαιρεθεί απο το Gallery.',\n    showCancelButton: true,\n    confirmButtonColor: '#536de6',\n    confirmButtonText: \"\\u039D\\u03B1\\u03B9, \\u03B1\\u03C6\\u03B1\\u03AF\\u03C1\\u03B5\\u03C3\\u03B7!\",\n    cancelButtonText: \"Άκυρο\"\n  }).then(function (result) {\n    if (result.isConfirmed) {\n      removeImages([_this.dataset.imageId]);\n    }\n  });\n}\n\nfunction removeImages(ids) {\n  var gallery = $(\"#gallery-cnt\")[0];\n  var namespace = gallery.dataset.namespace;\n  var modelId = gallery.dataset.modelId;\n  axios.post(\"/media/gallery-remove\", {\n    namespace: namespace,\n    modelId: modelId,\n    ids: ids\n  }).then(function (res) {\n    var gallery = $(\"#gallery-cnt\");\n    gallery.html(res.data);\n    var closeBtns = gallery.find(\".js-remove-image\");\n    closeBtns.on(\"click\", removeImageHandler);\n\n    if (closeBtns.length == 0) {\n      $(\"#remove-all-images-btn\").addClass(\"d-none\");\n    }\n  })[\"catch\"](function (err) {\n    console.log(err);\n    utilities.toastAlert('error', \"Παρουσιάστηκε κάποιο πρόβλημα ...\");\n  });\n}\n\nfunction resetGalleryBtns(bulk, checkboxes) {\n  bulk.text(\"Επιλογές (0)\");\n  bulk.prop(\"disabled\", true);\n  bulk.removeClass(\"btn-warning\");\n  bulk.addClass(\"btn-secondary\");\n\n  for (var i = 0; i < checkboxes.length; i++) {\n    checkboxes[i].checked = false;\n  }\n} //!######################################################\n//!\t\t\t\tMedia Library Functions End\t\t\t\t#\n//!######################################################\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  toastAlert: toastAlert,\n  mainCheckboxSwitcher: mainCheckboxSwitcher,\n  minorCheckboxSwitcher: minorCheckboxSwitcher,\n  filterButton: filterButton,\n  tableLocale: tableLocale,\n  changeInputHidden: changeInputHidden,\n  redactorConfig: redactorConfig,\n  createStateSelect: createStateSelect,\n  datePickerConfig: datePickerConfig,\n  toastAlertDelete: toastAlertDelete,\n  filterStyle: filterStyle,\n  createDateElm: createDateElm,\n  startDate: startDate,\n  endDate: endDate,\n  resetBulk: resetBulk,\n  resetAddButton: resetAddButton,\n  createCourseTypeSelect: createCourseTypeSelect,\n  paginationHandler: paginationHandler,\n  searchHandler: searchHandler,\n  imageHandler: imageHandler,\n  paginationRequest: paginationRequest,\n  resetGalleryBtns: resetGalleryBtns,\n  removeImageHandler: removeImageHandler,\n  removeImages: removeImages,\n  articleConfig: articleConfig,\n  ALLOWEDTYPES: ALLOWEDTYPES,\n  passwordValidation: passwordValidation\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvZGFzaGJvYXJkL21haW4uanM/ODIyYiJdLCJuYW1lcyI6WyJFbGVtZW50IiwicHJvdG90eXBlIiwiZmluZFBhcmVudCIsImxvb3BzIiwicGFyZW50IiwiaSIsInBhcmVudEVsZW1lbnQiLCJhcHBlbmRCZWZvcmUiLCJlbGVtZW50IiwicGFyZW50Tm9kZSIsImluc2VydEJlZm9yZSIsImFwcGVuZEFmdGVyIiwibmV4dFNpYmxpbmciLCJiYXNlVXJsIiwid2luZG93IiwibG9jYXRpb24iLCJvcmlnaW4iLCJ0aW1lciIsIkFMTE9XRURUWVBFUyIsInRvYXN0QWxlcnQiLCJpY29uIiwibWVzc2FnZSIsIlN3YWwiLCJmaXJlIiwidG9hc3QiLCJwb3NpdGlvbiIsInRpdGxlIiwic2hvd0NvbmZpcm1CdXR0b24iLCJ0aW1lclByb2dyZXNzQmFyIiwidG9hc3RBbGVydERlbGV0ZSIsInRleHQiLCJzaG93Q2FuY2VsQnV0dG9uIiwiY29uZmlybUJ1dHRvbkNvbG9yIiwiY29uZmlybUJ1dHRvblRleHQiLCJjYW5jZWxCdXR0b25UZXh0IiwiYXJ0aWNsZUNvbmZpZyIsImNzcyIsImN1c3RvbSIsImNsYXNzZXMiLCJpbWciLCJwIiwiZ3JpZCIsImNsYXNzbmFtZSIsImNvbHVtbnMiLCJndXR0ZXIiLCJvZmZzZXQiLCJsZWZ0IiwicmlnaHQiLCJwYXR0ZXJucyIsImFsaWduIiwiY2VudGVyIiwiZWRpdG9yIiwibWluSGVpZ2h0IiwiaW1hZ2UiLCJ1cGxvYWQiLCJkYXRhIiwiJCIsImF0dHIiLCJyZWRhY3RvckNvbmZpZyIsImJ1dHRvbnMiLCJzdHlsZSIsInBsdWdpbnMiLCJkYXRlUGlja2VyQ29uZmlnIiwicmFuZ2VzIiwibW9tZW50Iiwic3VidHJhY3QiLCJzdGFydE9mIiwiZW5kT2YiLCJhbHdheXNTaG93Q2FsZW5kYXJzIiwic2hvd0N1c3RvbVJhbmdlTGFiZWwiLCJkcm9wcyIsImF1dG9VcGRhdGVJbnB1dCIsIm9wZW5zIiwibG9jYWxlIiwiZm9ybWF0IiwidGFibGVMb2NhbGUiLCJlbXB0eVRhYmxlIiwiaW5mbyIsImluZm9FbXB0eSIsImxlbmd0aE1lbnUiLCJsb2FkaW5nUmVjb3JkcyIsInByb2Nlc3NpbmciLCJzZWFyY2giLCJzZWFyY2hQbGFjZWhvbGRlciIsInplcm9SZWNvcmRzIiwicGFnaW5hdGUiLCJwcmV2aW91cyIsIm5leHQiLCJpbmZvRmlsdGVyZWQiLCJtYWluQ2hlY2tib3hTd2l0Y2hlciIsIm1haW4iLCJtaW5vciIsImJ1bGtCdG4iLCJzdGF0dXMiLCJjb3VudGVyIiwiY2hlY2tlZCIsImxlbmd0aCIsImNsYXNzTGlzdCIsInJlbW92ZSIsImFkZCIsImJ1bGtNb2RpZmllciIsIm1pbm9yQ2hlY2tib3hTd2l0Y2hlciIsInN1bSIsImRhdGFzZXQiLCJlbmFibGVkQ29sb3IiLCJkaXNhYmxlZENvbG9yIiwidGV4dENvbnRlbnQiLCJkaXNhYmxlZCIsImZpbHRlclN0eWxlIiwiaW5wdXQiLCJ2YWx1ZSIsImZpbHRlckJ1dHRvbiIsImNvbHVtbiIsInRhYmxlIiwidGFibGVJZCIsImRldGFjaCIsImFwcGVuZFRvIiwib24iLCJkcmF3IiwiY2hhbmdlSW5wdXRIaWRkZW4iLCJoaWRkZW5BdHRyIiwiY2hhbmdlIiwicHJvcCIsImhpZGRlblZhbHVlIiwiY3JlYXRlU3RhdGVTZWxlY3QiLCJpZCIsInNlbGVjdEVsbSIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImlubmVySFRNTCIsImNyZWF0ZURhdGVFbG0iLCJ0b2dnbGUiLCJjYW5jZWxDbGFzcyIsImhlaWdodCIsIndpZHRoIiwicGxhY2Vob2xkZXIiLCJjcmVhdGVDb3Vyc2VUeXBlU2VsZWN0Iiwic3RhcnREYXRlIiwiZGF0ZUlucHV0IiwiZGF0ZUlucHV0VmFsdWUiLCJzcGxpdCIsImZpcnN0RGF0ZSIsInJldmVyc2UiLCJqb2luIiwiZW5kRGF0ZSIsInNlY29uZERhdGUiLCJyZXNldEJ1bGsiLCJjaGVja2JveCIsImFkZENsYXNzIiwicmVtb3ZlQ2xhc3MiLCJyZXNldEFkZEJ1dHRvbiIsImFkZEJ0biIsInBhc3N3b3JkVmFsaWRhdGlvbiIsInNob3dMb2FkZXJPbkNvbmZpcm0iLCJwcmVDb25maXJtIiwicGFzc3dvcmQiLCJheGlvcyIsInBvc3QiLCJ0aGVuIiwicmVzIiwiZXJyIiwic2hvd1ZhbGlkYXRpb25NZXNzYWdlIiwicmVzcG9uc2UiLCJwYWdpbmF0aW9uSGFuZGxlciIsImV2ZW50IiwicHJldmVudERlZmF1bHQiLCJhY3RpdmVQYWdlIiwiaHJlZiIsInZhbCIsInBhZ2luYXRpb25SZXF1ZXN0Iiwic2VhcmNoSGFuZGxlciIsImNsZWFyVGltZW91dCIsInNldFRpbWVvdXQiLCJpbWFnZUhhbmRsZXIiLCJtb2RhbCIsIm1vZGVsIiwibW9kZWxJZCIsImVkaXRvcklkIiwidHlwZSIsInVybCIsImltYWdlU291cmNlIiwiQXJ0aWNsZUVkaXRvciIsImluc2VydCIsIiRSIiwibmFtZSIsImFkZFRvR2FsbGVyeSIsImltYWdlSWQiLCJjaGFuZ2VDb3ZlclJlcXVlc3QiLCJnZXQiLCJwYXJhbXMiLCJwYWdlIiwiZ2FsbGVyeSIsInBhZ2luYXRpb24iLCJnZXRFbGVtZW50c0J5Q2xhc3NOYW1lIiwiYWRkQnRucyIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJhZGRFdmVudExpc3RlbmVyIiwibmFtZXNwYWNlIiwicmVtb3ZlQnRuQ250Iiwic3JjIiwicGF0Y2giLCJpbWdVcmwiLCJjb25zb2xlIiwibG9nIiwiaWRzIiwiaHRtbCIsImNsb3NlQnRucyIsImZpbmQiLCJyZW1vdmVJbWFnZUhhbmRsZXIiLCJidWxrIiwiY2hlY2tib3hlcyIsInJlc2V0R2FsbGVyeUJ0bnMiLCJyZXN1bHQiLCJpc0NvbmZpcm1lZCIsInJlbW92ZUltYWdlcyIsInV0aWxpdGllcyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVBQSxPQUFPLENBQUNDLFNBQVIsQ0FBa0JDLFVBQWxCLEdBQStCLFVBQVVDLEtBQVYsRUFBaUI7QUFDNUMsTUFB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QUFoQkEsZ0JBVlc7QUFXWCtFLGFBQVcsRUFBWEEsV0FYVztBQVlYc0IsZUFBYSxFQUFiQSxhQVpXO0FBYVhPLFdBQVMsRUFBVEEsU0FiVztBQWNYTyxTQUFPLEVBQVBBLE9BZFc7QUFlWEUsV0FBUyxFQUFUQSxTQWZXO0FBZ0JYSSxnQkFBYyxFQUFkQSxjQWhCVztBQWlCWGQsd0JBQXNCLEVBQXRCQSxzQkFqQlc7QUFrQlgyQixtQkFBaUIsRUFBakJBLGlCQWxCVztBQW1CWE8sZUFBYSxFQUFiQSxhQW5CVztBQW9CWEcsY0FBWSxFQUFaQSxZQXBCVztBQXFCZEosbUJBQWlCLEVBQWpCQSxpQkFyQmM7QUFzQmQwQyxrQkFBZ0IsRUFBaEJBLGdCQXRCYztBQXVCZEgsb0JBQWtCLEVBQWxCQSxrQkF2QmM7QUF3QmRNLGNBQVksRUFBWkEsWUF4QmM7QUF5QmRuTCxlQUFhLEVBQWJBLGFBekJjO0FBMEJkakIsY0FBWSxFQUFaQSxZQTFCYztBQTJCZHNJLG9CQUFrQixFQUFsQkE7QUEzQmMsQ0FBZiIsImZpbGUiOiIuL3Jlc291cmNlcy9qcy9kYXNoYm9hcmQvbWFpbi5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBTd2FsIGZyb20gXCJzd2VldGFsZXJ0MlwiO1xyXG5cclxuRWxlbWVudC5wcm90b3R5cGUuZmluZFBhcmVudCA9IGZ1bmN0aW9uIChsb29wcykge1xyXG4gICAgbGV0IHBhcmVudCA9IHRoaXM7XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsb29wczsgaSsrKSB7XHJcbiAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudEVsZW1lbnQ7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHBhcmVudDtcclxufSwgZmFsc2U7XHJcblxyXG5FbGVtZW50LnByb3RvdHlwZS5hcHBlbmRCZWZvcmUgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xyXG4gICAgZWxlbWVudC5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLCBlbGVtZW50KTtcclxufSwgZmFsc2U7XHJcblxyXG5FbGVtZW50LnByb3RvdHlwZS5hcHBlbmRBZnRlciA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XHJcblxyXG4gICAgZWxlbWVudC5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLCBlbGVtZW50Lm5leHRTaWJsaW5nKTtcclxuXHJcbn0sIGZhbHNlO1xyXG5cclxuLy8hIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXHJcbi8vIVx0XHRcdFx0R2xvYmFsIFZhcmlhYmxlc1x0XHRGXHQjXHJcbi8vISMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xyXG5cclxuY29uc3QgYmFzZVVybCA9IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW47XHJcbnZhciB0aW1lciA9IDA7XHJcbmV4cG9ydCBjb25zdCBBTExPV0VEVFlQRVMgPSBbXHJcblx0XCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIiwgXCJhcHBsaWNhdGlvbi94LXppcC1jb21wcmVzc2VkXCIsIFwiYXBwbGljYXRpb24vcGRmXCIsXHJcblx0XCJhcHBsaWNhdGlvbi9tc3dvcmRcIiwgXCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQud29yZHByb2Nlc3NpbmdtbC5kb2N1bWVudFwiLFxyXG5cdFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LndvcmRwcm9jZXNzaW5nbWwudGVtcGxhdGVcIiwgXCJhcHBsaWNhdGlvbi92bmQubXMtd29yZC5kb2N1bWVudC5tYWNyb0VuYWJsZWQuMTJcIixcclxuXHRcImFwcGxpY2F0aW9uL3ZuZC5tcy13b3JkLnRlbXBsYXRlLm1hY3JvRW5hYmxlZC4xMlwiLCBcImFwcGxpY2F0aW9uL3ZuZC5tcy1leGNlbFwiLCBcImFwcGxpY2F0aW9uL3ZuZC5tcy1leGNlbFwiLCBcImFwcGxpY2F0aW9uL3ZuZC5tcy1leGNlbFwiLFxyXG5cdFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LnNwcmVhZHNoZWV0bWwuc2hlZXRcIiwgXCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQuc3ByZWFkc2hlZXRtbC50ZW1wbGF0ZVwiLFxyXG5cdFwiYXBwbGljYXRpb24vdm5kLm1zLWV4Y2VsLnNoZWV0Lm1hY3JvRW5hYmxlZC4xMlwiLCBcImFwcGxpY2F0aW9uL3ZuZC5tcy1leGNlbC50ZW1wbGF0ZS5tYWNyb0VuYWJsZWQuMTJcIixcclxuXHRcImFwcGxpY2F0aW9uL3ZuZC5tcy1leGNlbC5hZGRpbi5tYWNyb0VuYWJsZWQuMTJcIiwgXCJhcHBsaWNhdGlvbi92bmQubXMtZXhjZWwuc2hlZXQuYmluYXJ5Lm1hY3JvRW5hYmxlZC4xMlwiLFxyXG5cdFwiYXBwbGljYXRpb24vdm5kLm1zLXBvd2VycG9pbnRcIiwgXCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQucHJlc2VudGF0aW9ubWwucHJlc2VudGF0aW9uXCIsXHJcblx0XCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQucHJlc2VudGF0aW9ubWwudGVtcGxhdGVcIiwgXCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQucHJlc2VudGF0aW9ubWwuc2xpZGVzaG93XCIsXHJcblx0XCJhcHBsaWNhdGlvbi92bmQubXMtcG93ZXJwb2ludC5hZGRpbi5tYWNyb0VuYWJsZWQuMTJcIiwgXCJhcHBsaWNhdGlvbi92bmQubXMtcG93ZXJwb2ludC5wcmVzZW50YXRpb24ubWFjcm9FbmFibGVkLjEyXCIsXHJcblx0XCJhcHBsaWNhdGlvbi92bmQubXMtcG93ZXJwb2ludC50ZW1wbGF0ZS5tYWNyb0VuYWJsZWQuMTJcIiwgXCJhcHBsaWNhdGlvbi92bmQubXMtcG93ZXJwb2ludC5zbGlkZXNob3cubWFjcm9FbmFibGVkLjEyXCIsXHJcblx0XCJhcHBsaWNhdGlvbi92bmQubXMtYWNjZXNzXCIsIFwiYXVkaW8vbXBlZ1wiLCBcImFwcGxpY2F0aW9uL3ZuZC5vYXNpcy5vcGVuZG9jdW1lbnQucHJlc2VudGF0aW9uXCIsXHJcblx0XCJhcHBsaWNhdGlvbi92bmQub2FzaXMub3BlbmRvY3VtZW50LnNwcmVhZHNoZWV0XCIsIFwiYXBwbGljYXRpb24vdm5kLm9hc2lzLm9wZW5kb2N1bWVudC50ZXh0XCIsXHJcblx0XCJhcHBsaWNhdGlvbi9ydGZcIiwgXCJhcHBsaWNhdGlvbi92bmQub2FzaXMub3BlbmRvY3VtZW50LmdyYXBoaWNzXCIsIFwidGV4dC9odG1sXCJcclxuXTtcclxuXHJcbi8vISMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xyXG4vLyFcdFx0XHRcdENvbmZpZ3VyYXRpb25zXHRcdFx0XHQjXHJcbi8vISMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xyXG5cclxuLy8hQUxFUlRcclxuLy8hPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbmZ1bmN0aW9uIHRvYXN0QWxlcnQoaWNvbiwgbWVzc2FnZSkge1xyXG4gICAgU3dhbC5maXJlKHtcclxuICAgICAgICB0b2FzdDogJ3RydWUnLFxyXG4gICAgICAgIHBvc2l0aW9uOiAndG9wLWVuZCcsXHJcbiAgICAgICAgaWNvbjogaWNvbixcclxuICAgICAgICB0aXRsZTogbWVzc2FnZSxcclxuICAgICAgICBzaG93Q29uZmlybUJ1dHRvbjogZmFsc2UsXHJcbiAgICAgICAgdGltZXI6IDMwMDAsXHJcbiAgICAgICAgdGltZXJQcm9ncmVzc0JhcjogdHJ1ZVxyXG4gICAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHRvYXN0QWxlcnREZWxldGUodGV4dCwgaWNvbiA9IFwid2FybmluZ1wiKSB7XHJcbiAgICByZXR1cm4gU3dhbC5maXJlKHtcclxuICAgICAgICB0aXRsZTogJ86Vzq/Pg8+EzrUgz4POr86zzr/Phc+Bzr/Pgi/OtzsnLFxyXG4gICAgICAgIHRleHQ6IHRleHQsXHJcbiAgICAgICAgaWNvbjogaWNvbixcclxuXHRcdHNob3dDYW5jZWxCdXR0b246IHRydWUsXHJcblx0XHRjb25maXJtQnV0dG9uQ29sb3I6ICcjZmY1YjViJyxcclxuICAgICAgICBjb25maXJtQnV0dG9uVGV4dDogJ86dzrHOrywgzrTOuc6xzrPPgc6xz4bOriEnLFxyXG4gICAgICAgIGNhbmNlbEJ1dHRvblRleHQ6ICfOhs66z4XPgc6/J1xyXG4gICAgfSk7XHJcbn1cclxuXHJcblxyXG4vLyFDT05GSUdcclxuLy8hPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbmNvbnN0IGFydGljbGVDb25maWcgPSB7XHJcblx0Y3NzOiBcIi9jc3MvXCIsXHJcblx0Y3VzdG9tOiB7XHJcblx0XHRjc3M6IFtcclxuXHRcdFx0XCIvY3NzL2Jvb3RzdHJhcC5taW4uY3NzXCIsXHJcblx0XHRcdFwiL2Nzcy9jdXN0b21BcnRpY2xlU3R5bGUuY3NzXCIsXHJcblx0XHRdXHJcblx0fSxcclxuXHQvLyBwbHVnaW5zOiBbJ21lZGlhTGlicmFyeScsICdyZW9yZGVyJ10sXHJcblx0Y2xhc3Nlczoge1xyXG5cdFx0aW1nOiAnaW1nLWZsdWlkJyxcclxuXHRcdHA6ICd0ZXh0LXdyYXAnXHJcblx0fSxcclxuXHRncmlkOiB7XHJcblx0XHRjbGFzc25hbWU6ICdyb3cnLFxyXG5cdFx0Y29sdW1uczogMTIsXHJcblx0XHRndXR0ZXI6ICcxcHgnLFxyXG5cdFx0b2Zmc2V0OiB7XHJcblx0XHRcdGxlZnQ6ICcxNXB4JyxcclxuXHRcdFx0cmlnaHQ6ICcxNXB4J1xyXG5cdFx0fSxcclxuXHRcdHBhdHRlcm5zOiB7XHJcblx0XHRcdCc2fDYnOiAnY29sLTZ8Y29sLTYnLFxyXG5cdFx0XHQnNHw0fDQnOiAnY29sLTR8Y29sLTR8Y29sLTQnLFxyXG5cdFx0XHQnM3wzfDN8Myc6ICdjb2wtM3xjb2wtM3xjb2wtM3xjb2wtMycsXHJcblx0XHRcdCcyfDJ8MnwyfDJ8Mic6ICdjb2wtMnxjb2wtMnxjb2wtMnxjb2wtMnxjb2wtMnxjb2wtMicsXHJcblx0XHRcdCczfDZ8Myc6ICdjb2wtM3xjb2wtNnxjb2wtMycsXHJcblx0XHRcdCcyfDh8Mic6ICdjb2wtMnxjb2wtOHxjb2wtMicsXHJcblx0XHRcdCc1fDcnOiAnY29sLTV8Y29sLTcnLFxyXG5cdFx0XHQnN3w1JzogJ2NvbC03fGNvbC01JyxcclxuXHRcdFx0JzR8OCc6ICdjb2wtNHxjb2wtOCcsXHJcblx0XHRcdCc4fDQnOiAnY29sLTh8Y29sLTQnLFxyXG5cdFx0XHQnM3w5JzogJ2NvbC0zfGNvbC05JyxcclxuXHRcdFx0Jzl8Myc6ICdjb2wtOXxjb2wtMycsXHJcblx0XHRcdCcyfDEwJzogJ2NvbC0yfGNvbC0xMCcsXHJcblx0XHRcdCcxMHwyJzogJ2NvbC0xMHxjb2wtMicsXHJcblx0XHRcdCcxMic6ICdjb2wtMTInXHJcblx0XHR9XHJcblx0fSxcclxuXHRhbGlnbjoge1xyXG5cdFx0bGVmdDogXCJ0ZXh0LWxlZnRcIixcclxuXHRcdGNlbnRlcjogXCJ0ZXh0LWNlbnRlclwiLFxyXG5cdFx0cmlnaHQ6IFwidGV4dC1yaWdodFwiLFxyXG5cdH0sXHJcblx0ZWRpdG9yOiB7XHJcblx0XHRtaW5IZWlnaHQ6IFwiMzAwcHhcIlxyXG5cdH0sXHJcblx0aW1hZ2U6IHtcclxuXHRcdHVwbG9hZDogXCIvbWVkaWEvdXBsb2FkLWltYWdlc1wiLFxyXG5cdFx0ZGF0YToge1xyXG5cdFx0XHRcIl90b2tlblwiOiAkKCdtZXRhW25hbWU9XCJjc3JmLXRva2VuXCJdJykuYXR0cignY29udGVudCcpLFxyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cclxuY29uc3QgcmVkYWN0b3JDb25maWcgPSB7XHJcbiAgICBidXR0b25zOiBbXHJcblx0XHQnaHRtbCcsICd1bmRvJywgJ3JlZG8nLCAnZm9ybWF0JyxcclxuXHRcdCdib2xkJywgJ3VuZGVybGluZScsICdpdGFsaWMnLCAnZGVsZXRlZCcsXHJcblx0XHQnc3VwJywgJ3N1YicsICdsaXN0cycsICdmaWxlJywgJ2xpbmsnLCAnaW1hZ2UnXHJcblx0XSxcclxuXHRzdHlsZTogZmFsc2UsXHJcblx0cGx1Z2luczogWydhbGlnbm1lbnQnXSxcclxuXHRtaW5IZWlnaHQ6ICcxNTBweCcsXHJcbn1cclxuXHJcbmNvbnN0IGRhdGVQaWNrZXJDb25maWcgPSB7XHJcbiAgICByYW5nZXM6IHtcclxuICAgICAgICAnVG9kYXknOiBbbW9tZW50KCksIG1vbWVudCgpXSxcclxuICAgICAgICAnWWVzdGVyZGF5JzogW21vbWVudCgpLnN1YnRyYWN0KDEsICdkYXlzJyksIG1vbWVudCgpLnN1YnRyYWN0KDEsICdkYXlzJyldLFxyXG4gICAgICAgICdMYXN0IDcgRGF5cyc6IFttb21lbnQoKS5zdWJ0cmFjdCg2LCAnZGF5cycpLCBtb21lbnQoKV0sXHJcbiAgICAgICAgJ0xhc3QgMzAgRGF5cyc6IFttb21lbnQoKS5zdWJ0cmFjdCgyOSwgJ2RheXMnKSwgbW9tZW50KCldLFxyXG4gICAgICAgICdUaGlzIE1vbnRoJzogW21vbWVudCgpLnN0YXJ0T2YoJ21vbnRoJyksIG1vbWVudCgpLmVuZE9mKCdtb250aCcpXSxcclxuICAgICAgICAnTGFzdCBNb250aCc6IFttb21lbnQoKS5zdWJ0cmFjdCgxLCAnbW9udGgnKS5zdGFydE9mKCdtb250aCcpLCBtb21lbnQoKS5zdWJ0cmFjdCgxLCAnbW9udGgnKS5lbmRPZignbW9udGgnKV0sXHJcbiAgICAgICAgJ1RoaXMgWWVhcic6IFttb21lbnQoKS5zdGFydE9mKCd5ZWFyJyksIG1vbWVudCgpLmVuZE9mKCd5ZWFyJyldLFxyXG4gICAgICAgICdMYXN0IFllYXInOiBbbW9tZW50KCkuc3VidHJhY3QoMSwgJ3llYXInKS5zdGFydE9mKCd5ZWFyJyksIG1vbWVudCgpLnN1YnRyYWN0KDEsICd5ZWFyJykuZW5kT2YoJ3llYXInKV1cclxuICAgIH0sXHJcbiAgICBhbHdheXNTaG93Q2FsZW5kYXJzOiB0cnVlLFxyXG4gICAgc2hvd0N1c3RvbVJhbmdlTGFiZWw6IGZhbHNlLFxyXG4gICAgZHJvcHM6IFwiYXV0b1wiLFxyXG4gICAgYXV0b1VwZGF0ZUlucHV0OiBmYWxzZSxcclxuICAgIG9wZW5zOiBcImNlbnRlclwiLFxyXG4gICAgbG9jYWxlOiB7XHJcbiAgICAgICAgZm9ybWF0OiBcIkREL01NL1lZWVlcIixcclxuICAgIH0sXHJcbn1cclxuXHJcbmNvbnN0IHRhYmxlTG9jYWxlID0ge1xyXG4gICAgZW1wdHlUYWJsZTogXCLOlM61zr0gz4XPgM6sz4HPh86/z4XOvSDOtc6zzrPPgc6xz4bOrc+CXCIsXHJcbiAgICBpbmZvOiBcIl9TVEFSVF8gzq3Pic+CIF9FTkRfIM6xz4DOvyDPhM6xIF9UT1RBTF8gzrHPgM6/z4TOtc67zq3Pg868zrHPhM6xXCIsXHJcbiAgICBpbmZvRW1wdHk6IFwiMCDOsc+Azr8gMCDPhM6xIDAgzrHPgM6/z4TOtc67zq3Pg868zrHPhM6xXCIsXHJcbiAgICBsZW5ndGhNZW51OiBcIl9NRU5VX1wiLFxyXG4gICAgbG9hZGluZ1JlY29yZHM6IFwizqbPjM+Bz4TPic+DzrcgLi4uXCIsXHJcbiAgICBwcm9jZXNzaW5nOiBcIs6Vz4DOtc6+zrXPgc6zzrHPg86vzrEgLi4uXCIsXHJcbiAgICBzZWFyY2g6IFwiXCIsXHJcbiAgICBzZWFyY2hQbGFjZWhvbGRlcjogXCLOkc69zrHOts6uz4TOt8+DzrcuLi4gXCIsXHJcbiAgICB6ZXJvUmVjb3JkczogXCLOlM61zr0gzrLPgc6tzrjOt866zrHOvSDOsc+Azr/PhM61zrvOrc+DzrzOsc+EzrFcIixcclxuICAgIHBhZ2luYXRlOiB7XHJcbiAgICAgICAgcHJldmlvdXM6IFwiPGkgY2xhc3M9J21kaSBtZGktY2hldnJvbi1sZWZ0Jz5cIixcclxuICAgICAgICBuZXh0OiBcIjxpIGNsYXNzPSdtZGkgbWRpLWNoZXZyb24tcmlnaHQnPlwiXHJcblx0fSxcclxuXHRpbmZvRmlsdGVyZWQ6IFwiKM6mzrnOu8+Ez4HOsc+BzrnPg868zq3Ovc6xIM6xz4DOvyDPhM65z4IgX01BWF8gzrXOs86zz4HOsc+Gzq3PgilcIlxyXG59XHJcblxyXG4vLyFHTE9CQUwgRlVOQ1RJT05cclxuLy8hPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbmZ1bmN0aW9uIG1haW5DaGVja2JveFN3aXRjaGVyKG1haW4sIG1pbm9yLCBidWxrQnRuID0gZmFsc2UpIHtcclxuICAgIGxldCBzdGF0dXMgPSB0cnVlO1xyXG4gICAgbGV0IGNvdW50ZXIgPSAwO1xyXG4gICAgbWFpbi5jaGVja2VkID0gdHJ1ZTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1pbm9yLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKCFtaW5vcltpXS5jaGVja2VkKSB7XHJcbiAgICAgICAgICAgIG1pbm9yW2ldLmZpbmRQYXJlbnQoMykuY2xhc3NMaXN0LnJlbW92ZShcImJnLXNlbGVjdGVkXCIpO1xyXG4gICAgICAgICAgICBtYWluLmNoZWNrZWQgPSBmYWxzZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBtaW5vcltpXS5maW5kUGFyZW50KDMpLmNsYXNzTGlzdC5hZGQoXCJiZy1zZWxlY3RlZFwiKTtcclxuICAgICAgICAgICAgY291bnRlcisrXHJcbiAgICAgICAgICAgIHN0YXR1cyA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoYnVsa0J0bikge1xyXG4gICAgICAgIGJ1bGtNb2RpZmllcihidWxrQnRuLCBzdGF0dXMsIGNvdW50ZXIpO1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBtaW5vckNoZWNrYm94U3dpdGNoZXIobWFpbiwgbWlub3IsIGJ1bGtCdG4gPSBmYWxzZSkge1xyXG4gICAgbGV0IGNvdW50ZXIgPSAwO1xyXG4gICAgbGV0IHN0YXR1cyA9IHRydWU7XHJcblxyXG4gICAgaWYgKG1haW4uY2hlY2tlZCAmJiBtaW5vci5sZW5ndGggPiAwKSB7XHJcblxyXG4gICAgICAgIGNvdW50ZXIgPSBtaW5vci5sZW5ndGg7XHJcbiAgICAgICAgc3RhdHVzID0gZmFsc2U7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWlub3IubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgbWlub3JbaV0uY2hlY2tlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIG1pbm9yW2ldLmZpbmRQYXJlbnQoMykuY2xhc3NMaXN0LmFkZChcImJnLXNlbGVjdGVkXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtaW5vci5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBtaW5vcltpXS5jaGVja2VkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIG1pbm9yW2ldLmZpbmRQYXJlbnQoMykuY2xhc3NMaXN0LnJlbW92ZShcImJnLXNlbGVjdGVkXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoYnVsa0J0bikge1xyXG4gICAgICAgIGJ1bGtNb2RpZmllcihidWxrQnRuLCBzdGF0dXMsIGNvdW50ZXIpO1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBidWxrTW9kaWZpZXIoYnVsa0J0biwgc3RhdHVzLCBzdW0pIHtcclxuXHJcbiAgICBsZXQgdGV4dCA9IGJ1bGtCdG4uZGF0YXNldC50ZXh0ID8gYnVsa0J0bi5kYXRhc2V0LnRleHQgOiBcIs6Vz4DOuc67zr/Os86tz4JcIjtcclxuICAgIGxldCBlbmFibGVkQ29sb3IgPSBidWxrQnRuLmRhdGFzZXQuZW5hYmxlZENvbG9yID8gYnVsa0J0bi5kYXRhc2V0LmVuYWJsZWRDb2xvciA6IFwiYnRuLXdhcm5pbmdcIjtcclxuICAgIGxldCBkaXNhYmxlZENvbG9yID0gYnVsa0J0bi5kYXRhc2V0LmRpc2FibGVkQ29sb3IgPyBidWxrQnRuLmRhdGFzZXQuZGlzYWJsZWRDb2xvciA6IFwiYnRuLXNlY29uZGFyeVwiO1xyXG5cclxuICAgIGlmIChzdGF0dXMpIHtcclxuXHRcdGJ1bGtCdG4uY2xhc3NMaXN0LnJlbW92ZShlbmFibGVkQ29sb3IpXHJcbiAgICAgICAgYnVsa0J0bi5jbGFzc0xpc3QuYWRkKGRpc2FibGVkQ29sb3IpXHJcbiAgICAgICAgYnVsa0J0bi50ZXh0Q29udGVudCA9IGAke3RleHR9ICgwKSAgYFxyXG4gICAgICAgIGJ1bGtCdG4uZGlzYWJsZWQgPSB0cnVlO1xyXG4gICAgfSBlbHNlIHtcclxuXHRcdGJ1bGtCdG4uY2xhc3NMaXN0LnJlbW92ZShkaXNhYmxlZENvbG9yKTtcclxuICAgICAgICBidWxrQnRuLmNsYXNzTGlzdC5hZGQoZW5hYmxlZENvbG9yKTtcclxuICAgICAgICBidWxrQnRuLnRleHRDb250ZW50ID0gYCR7dGV4dH0gICgke3N1bX0pICBgXHJcbiAgICAgICAgYnVsa0J0bi5kaXNhYmxlZCA9IGZhbHNlO1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBmaWx0ZXJTdHlsZShpbnB1dCwgdmFsdWUpIHtcclxuXHJcbiAgICBpZiAodmFsdWUgPT0gXCJcIikge1xyXG4gICAgICAgIGlucHV0LmNsYXNzTGlzdC5yZW1vdmUoXCJzZWxlY3QyLXNlbGVjdGVkXCIpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBpbnB1dC5jbGFzc0xpc3QuYWRkKFwic2VsZWN0Mi1zZWxlY3RlZFwiKTtcclxuICAgIH1cclxuXHJcbn1cclxuXHJcbmNvbnN0IGZpbHRlckJ1dHRvbiA9IGZ1bmN0aW9uIChhdHRyLCBjb2x1bW4sIHRhYmxlLCB0YWJsZUlkKSB7XHJcbiAgICAkKGF0dHIpLmRldGFjaCgpLmFwcGVuZFRvKHRhYmxlSWQpXHJcblxyXG5cclxuXHJcbiAgICAkKGF0dHIpLm9uKCdjaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGFibGUuY29sdW1ucyhjb2x1bW4pLnNlYXJjaCh0aGlzLnZhbHVlKS5kcmF3KCk7XHJcblxyXG5cclxuICAgIH0pO1xyXG59XHJcblxyXG5jb25zdCBjaGFuZ2VJbnB1dEhpZGRlbiA9IChhdHRyLCBoaWRkZW5BdHRyKSA9PiB7XHJcblxyXG4gICAgJChhdHRyKS5jaGFuZ2UoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChhdHRyID09IFwiI2FjdGl2ZU1hdGVyaWFsXCIpIHtcclxuICAgICAgICAgICAgdGhpcy52YWx1ZSA9ICQodGhpcykucHJvcCgnY2hlY2tlZCcpID09IHRydWUgPyAxIDogMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBoaWRkZW5WYWx1ZSA9ICQoaGlkZGVuQXR0cilbMF0udmFsdWUgPSB0aGlzLnZhbHVlXHJcblxyXG4gICAgfSlcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlU3RhdGVTZWxlY3QoaWQgPSBcIlwiKSB7XHJcbiAgICBjb25zdCBzZWxlY3RFbG0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2VsZWN0XCIpO1xyXG4gICAgc2VsZWN0RWxtLmNsYXNzTGlzdC5hZGQoXCJtbC0xXCIsIFwic2VsZWN0MlwiKTtcclxuICAgIHNlbGVjdEVsbS5pZCA9IGlkO1xyXG5cclxuICAgIHNlbGVjdEVsbS5pbm5lckhUTUwgPSBgXHJcblx0XHQ8b3B0aW9uIHZhbHVlPVwiXCI+zozOu861z4Igzr/OuSDOms6xz4TOsc+Dz4TOrM+DzrXOuc+CPC9vcHRpb24+XHJcblx0XHQ8b3B0aW9uIHZhbHVlPVwiMVwiPs6Vzr3Otc+BzrPOrDwvb3B0aW9uPlxyXG5cdFx0PG9wdGlvbiB2YWx1ZT1cIjBcIj7Okc69zrXOvc61z4HOs86sPC9vcHRpb24+XHJcblx0YDtcclxuXHJcbiAgICByZXR1cm4gc2VsZWN0RWxtO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVEYXRlRWxtKGlkKSB7XHJcbiAgICBsZXQgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XHJcblxyXG4gICAgaW5wdXQuY2xhc3NMaXN0LmFkZChcImZvcm0tY29udHJvbFwiLCBcImRhdGVcIiwgXCJkLWlubGluZS1ibG9ja1wiLCBcIm1sLTFcIiwgXCJqcy1kYXRlLXNlYXJjaFwiKTtcclxuICAgIGlucHV0LmlkID0gaWQ7XHJcbiAgICBpbnB1dC5kYXRhc2V0LnRvZ2dsZSA9IFwiZGF0ZS1waWNrZXJcIjtcclxuICAgIGlucHV0LmRhdGFzZXQuY2FuY2VsQ2xhc3MgPSBcImJ0bi1zZWNvbmRhcnlcIjtcclxuICAgIGlucHV0LnN0eWxlLmhlaWdodCA9IFwiMzEuOTZweFwiO1xyXG4gICAgaW5wdXQuc3R5bGUud2lkdGggPSBcIjE5NXB4XCI7XHJcbiAgICBpbnB1dC5wbGFjZWhvbGRlciA9IFwizpXPgM65zrvOrc6+z4TOtSDOt868zrXPgc6/zrzOt869zq/Otc+CLi4uXCI7XHJcblxyXG4gICAgcmV0dXJuIGlucHV0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVDb3Vyc2VUeXBlU2VsZWN0KGlkID0gXCJcIikge1xyXG5cclxuICAgIGNvbnN0IHNlbGVjdEVsbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzZWxlY3RcIik7XHJcblxyXG4gICAgc2VsZWN0RWxtLmNsYXNzTGlzdC5hZGQoXCJtbC0xXCIsIFwic2VsZWN0MlwiKTtcclxuICAgIHNlbGVjdEVsbS5pZCA9IGlkO1xyXG5cclxuICAgIHNlbGVjdEVsbS5pbm5lckhUTUwgPSBgXHJcblx0XHQ8b3B0aW9uIHZhbHVlPVwiXCI+zozOu861z4Igzr/OuSDOlc66zrTPjM+DzrXOuc+CPC9vcHRpb24+XHJcblx0XHQ8b3B0aW9uIHZhbHVlPVwiTm9ybWFsXCI+Tm9ybWFsPC9vcHRpb24+XHJcblx0XHQ8b3B0aW9uIHZhbHVlPVwiVHJpYWxcIj5UcmlhbDwvb3B0aW9uPlxyXG5cdGA7XHJcblxyXG4gICAgcmV0dXJuIHNlbGVjdEVsbTtcclxufVxyXG5cclxuZnVuY3Rpb24gc3RhcnREYXRlKGlucHV0KSB7XHJcblxyXG4gICAgbGV0IGRhdGVJbnB1dCA9IGlucHV0O1xyXG5cclxuICAgIGlmICghZGF0ZUlucHV0IHx8IGRhdGVJbnB1dC52YWx1ZSA9PSBcIlwiKSB7XHJcbiAgICAgICAgcmV0dXJuIFwiXCI7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IGRhdGVJbnB1dFZhbHVlID0gZGF0ZUlucHV0LnZhbHVlLnNwbGl0KFwiIC0gXCIpO1xyXG4gICAgbGV0IGZpcnN0RGF0ZSA9IGRhdGVJbnB1dFZhbHVlWzBdLnNwbGl0KFwiL1wiKS5yZXZlcnNlKCkuam9pbihcIi1cIik7XHJcblxyXG4gICAgcmV0dXJuIGZpcnN0RGF0ZTtcclxufVxyXG5cclxuZnVuY3Rpb24gZW5kRGF0ZShpbnB1dCkge1xyXG5cclxuICAgIGxldCBkYXRlSW5wdXQgPSBpbnB1dDtcclxuXHJcbiAgICBpZiAoIWRhdGVJbnB1dCB8fCBkYXRlSW5wdXQudmFsdWUgPT0gXCJcIikge1xyXG4gICAgICAgIHJldHVybiBcIlwiO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBkYXRlSW5wdXRWYWx1ZSA9IGRhdGVJbnB1dC52YWx1ZS5zcGxpdChcIiAtIFwiKTtcclxuICAgIGxldCBzZWNvbmREYXRlID0gZGF0ZUlucHV0VmFsdWVbMV0uc3BsaXQoXCIvXCIpLnJldmVyc2UoKS5qb2luKFwiLVwiKTtcclxuXHJcbiAgICByZXR1cm4gc2Vjb25kRGF0ZTtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVzZXRCdWxrKGJ1bGtCdG4sIGNoZWNrYm94LCB0ZXh0ID0gXCLOlc+AzrnOu86/zrPOrc+CICAoMClcIikge1xyXG5cclxuICAgIGJ1bGtCdG4udGV4dCh0ZXh0KTtcclxuICAgIGJ1bGtCdG4uYWRkQ2xhc3MoXCJidG4tc2Vjb25kYXJ5XCIpO1xyXG4gICAgYnVsa0J0bi5yZW1vdmVDbGFzcyhcImJ0bi13YXJuaW5nIGJ0bi1kYW5nZXJcIik7XHJcbiAgICBidWxrQnRuLnByb3AoXCJkaXNhYmxlZFwiLCB0cnVlKTtcclxuICAgIGNoZWNrYm94LnByb3AoXCJjaGVja2VkXCIsIGZhbHNlKTtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVzZXRBZGRCdXR0b24oYWRkQnRuLCBjaGVja2JveCkge1xyXG4gICAgYWRkQnRuLnRleHQoXCLOoM+Bzr/Pg864zq7Ous63IM6Vz4DOuc67zr/Os8+Ozr0gKDApXCIpO1xyXG4gICAgYWRkQnRuLmFkZENsYXNzKFwiYnRuLXNlY29uZGFyeVwiKTtcclxuICAgIGFkZEJ0bi5yZW1vdmVDbGFzcyhcImJ0bi1wcmltYXJ5XCIpO1xyXG4gICAgYWRkQnRuLnByb3AoXCJkaXNhYmxlZFwiLCB0cnVlKTtcclxuICAgIGNoZWNrYm94LnByb3AoXCJjaGVja2VkXCIsIGZhbHNlKTtcclxufVxyXG5cclxuZnVuY3Rpb24gcGFzc3dvcmRWYWxpZGF0aW9uKCkge1xyXG5cdHJldHVybiBTd2FsLmZpcmUoe1xyXG5cdFx0dGl0bGU6IFwizqDOsc+BzrHOus6xzrvPjiDOtc65z4POrM6zzrXPhM6xzrkgzprPic60zrnOus+MXCIsXHJcblx0XHRpbnB1dDogXCJwYXNzd29yZFwiLFxyXG5cdFx0c2hvd0NhbmNlbEJ1dHRvbjogdHJ1ZSxcclxuXHRcdGNvbmZpcm1CdXR0b25Db2xvcjogXCIjNTM2ZGU2XCIsXHJcblx0XHRzaG93TG9hZGVyT25Db25maXJtOiB0cnVlLFxyXG5cdFx0cHJlQ29uZmlybTogZnVuY3Rpb24ocGFzc3dvcmQpIHtcclxuXHRcdFx0XHJcblx0XHRcdHJldHVybiBheGlvcy5wb3N0KGAvdXNlcnMtYWpheC9jb25maXJtLXBhc3N3b3JkYCwge1xyXG5cdFx0XHRcdHBhc3N3b3JkOiBwYXNzd29yZFxyXG5cdFx0XHR9KVxyXG5cdFx0XHQudGhlbiggcmVzID0+IHtcclxuXHRcdFx0XHRyZXR1cm4gcmVzLnN0YXR1cztcclxuXHRcdFx0fSlcclxuXHRcdFx0LmNhdGNoKCBlcnIgPT4ge1xyXG5cdFx0XHRcdFN3YWwuc2hvd1ZhbGlkYXRpb25NZXNzYWdlKGVyci5yZXNwb25zZS5kYXRhKTtcclxuXHRcdFx0fSlcclxuXHRcdH1cclxuXHR9KVxyXG59XHJcblxyXG4vLyEjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXHJcbi8vIVx0XHRcdFx0TWVkaWEgTGlicmFyeSBGdW5jdGlvbnNcdFx0XHQjXHJcbi8vISMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcclxuXHJcbmZ1bmN0aW9uIHBhZ2luYXRpb25IYW5kbGVyKGV2ZW50KSB7XHJcblxyXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuXHJcbiAgICBsZXQgYWN0aXZlUGFnZSA9IHRoaXMuaHJlZi5zcGxpdChcInBhZ2U9XCIpWzFdO1xyXG4gICAgbGV0IHNlYXJjaCA9ICQoXCIjaW1hZ2Utc2VhcmNoXCIpLnZhbCgpO1xyXG5cclxuICAgIHBhZ2luYXRpb25SZXF1ZXN0KGFjdGl2ZVBhZ2UsIHNlYXJjaCk7XHJcblxyXG59XHJcblxyXG5mdW5jdGlvbiBzZWFyY2hIYW5kbGVyKCkge1xyXG5cclxuICAgIGNsZWFyVGltZW91dCh0aW1lcik7XHJcblxyXG4gICAgaWYgKHRoaXMudmFsdWUubGVuZ3RoIDwgMyB8fCB0aGlzLnZhbHVlID09IFwiXCIpIHtcclxuICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQocGFnaW5hdGlvblJlcXVlc3QsIDgwMCwgMSwgXCJcIik7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRpbWVyID0gc2V0VGltZW91dChwYWdpbmF0aW9uUmVxdWVzdCwgODAwLCAxLCB0aGlzLnZhbHVlKTtcclxuICAgIH1cclxuXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGltYWdlSGFuZGxlcigpIHtcclxuXHJcbiAgICBsZXQgbW9kYWwgPSAkKFwiI2dhbGxlcnktY29udGVudFwiKVswXTtcclxuICAgIGxldCBtb2RlbCA9IG1vZGFsLmRhdGFzZXQubW9kZWw7XHJcbiAgICBsZXQgbW9kZWxJZCA9IG1vZGFsLmRhdGFzZXQuaWQ7XHJcbiAgICBsZXQgZWRpdG9ySWQgPSBtb2RhbC5kYXRhc2V0LmVkaXRvcklkO1xyXG4gICAgbGV0IHR5cGUgPSBtb2RhbC5kYXRhc2V0LnR5cGU7XHJcblxyXG4gICAgbGV0IGltYWdlID0ge1xyXG4gICAgICAgICdpbWcnOiB7XHJcbiAgICAgICAgICAgIHVybDogYCR7dGhpcy5kYXRhc2V0LmltYWdlU291cmNlfWAsXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmICh0eXBlID09IFwiYXJ0aWNsZVwiKSB7XHJcbiAgICAgICAgQXJ0aWNsZUVkaXRvcihlZGl0b3JJZCkuaW1hZ2UuaW5zZXJ0KGltYWdlKTtcclxuXHR9XHJcblx0ZWxzZSBpZiAodHlwZSA9PSBcInJlZGFjdG9yXCIpIHtcclxuICAgICAgICAkUiggZWRpdG9ySWQsXHJcbiAgICAgICAgICAgICdpbnNlcnRpb24uaW5zZXJ0SHRtbCcsXHJcbiAgICAgICAgICAgIGA8aW1nIGNsYXNzPVwiaW1nLWZsdWlkXCIgc3JjPVwiJHt0aGlzLmRhdGFzZXQuaW1hZ2VTb3VyY2V9XCIgYWx0PVwiJHt0aGlzLmRhdGFzZXQubmFtZX1cIiAvPmBcclxuICAgICAgICApO1xyXG5cdH1cclxuXHRlbHNlIGlmICggdHlwZSA9PSBcImdhbGxlcnlcIiApIHtcclxuXHJcblx0XHQkKFwiI3JlbW92ZS1hbGwtaW1hZ2VzLWJ0blwiKS5yZW1vdmVDbGFzcyhcImQtbm9uZVwiKTtcclxuXHRcdGFkZFRvR2FsbGVyeShtb2RlbCwgbW9kZWxJZCwgdGhpcy5kYXRhc2V0LmltYWdlSWQpO1xyXG5cdFx0cmV0dXJuO1xyXG5cdH1cclxuICAgIGVsc2Uge1xyXG5cclxuICAgICAgICBjaGFuZ2VDb3ZlclJlcXVlc3QobW9kZWwsIG1vZGVsSWQsIHRoaXMuZGF0YXNldC5pbWFnZVNvdXJjZSk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgICQoXCIjZ2FsbGVyeS1tb2RhbFwiKS5tb2RhbCgnaGlkZScpO1xyXG5cclxufVxyXG5cclxuZnVuY3Rpb24gcGFnaW5hdGlvblJlcXVlc3QoYWN0aXZlUGFnZSwgc2VhcmNoKSB7XHJcblxyXG4gICAgYXhpb3MuZ2V0KGAvbWVkaWEvaW1hZ2VzYCwge1xyXG4gICAgICAgIHBhcmFtczoge1xyXG4gICAgICAgICAgICBwYWdlOiBhY3RpdmVQYWdlLFxyXG4gICAgICAgICAgICBzZWFyY2hcclxuICAgICAgICB9XHJcbiAgICB9KVxyXG4gICAgICAgIC50aGVuKChyZXMpID0+IHtcclxuICAgICAgICAgICAgbGV0IGdhbGxlcnkgPSAkKFwiI2dhbGxlcnktY29udGVudFwiKVswXVxyXG4gICAgICAgICAgICBnYWxsZXJ5LmlubmVySFRNTCA9IHJlcy5kYXRhO1xyXG5cclxuICAgICAgICAgICAgbGV0IHBhZ2luYXRpb24gPSBnYWxsZXJ5LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoXCJqcy1nYWxsZXJ5LXBhZ2UtYnRuXCIpO1xyXG4gICAgICAgICAgICBsZXQgYWRkQnRucyA9IGdhbGxlcnkuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcImpzLWFkZC1pbWFnZVwiKTtcclxuXHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWRkQnRucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgYWRkQnRuc1tpXS5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgaW1hZ2VIYW5kbGVyKTtcclxuXHRcdFx0XHRhZGRCdG5zW2ldLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBpbWFnZUhhbmRsZXIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhZ2luYXRpb24ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHBhZ2luYXRpb25baV0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHBhZ2luYXRpb25IYW5kbGVyKTtcclxuICAgICAgICAgICAgICAgIHBhZ2luYXRpb25baV0uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHBhZ2luYXRpb25IYW5kbGVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNoYW5nZUNvdmVyUmVxdWVzdChuYW1lc3BhY2UsIGlkLCB1cmwpIHtcclxuXHRpZiAoIHR5cGVvZiBpZCA9PT0gXCJ1bmRlZmluZWRcIiAmJiBuYW1lc3BhY2UgPT0gXCJBcHBcXFxcTW9kZWxzXFxcXFVzZXJcIiApIHtcclxuXHRcdGxldCBpbWcgPSAkKFwiI2NvdmVyLWltYWdlXCIpWzBdO1xyXG5cdFx0bGV0IHJlbW92ZUJ0bkNudCA9ICQoXCIjcmVtb3ZlLWNvdmVyLWJ0blwiKS5wYXJlbnQoKTtcclxuXHJcblx0XHRpbWcuc3JjID0gYCR7dXJsfWA7XHJcblx0XHRpbWcuY2xhc3NMaXN0LnJlbW92ZShcImQtbm9uZVwiKTtcclxuXHJcblx0XHRyZW1vdmVCdG5DbnQucmVtb3ZlQ2xhc3MoXCJkLW5vbmVcIik7XHJcblx0XHRyZW1vdmVCdG5DbnQuYWRkQ2xhc3MoXCJkLWZsZXhcIik7XHJcblxyXG4gICAgICAgICQoXCIjY3VzdG9tLWZpbGVcIilbMF0udmFsdWUgPSBgJHt1cmx9YDtcclxuXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGF4aW9zLnBhdGNoKFwiL21lZGlhL2NvdmVyL3JlcGxhY2VcIiwge1xyXG4gICAgICAgICAgICBuYW1lc3BhY2UsIGlkLCB1cmxcclxuICAgICAgICB9KVxyXG4gICAgICAgICAgICAudGhlbihyZXMgPT4ge1xyXG5cclxuXHRcdFx0XHRsZXQgaW1nID0gJChcIiNjb3Zlci1pbWFnZVwiKVswXTtcclxuXHRcdFx0XHRsZXQgcmVtb3ZlQnRuQ250ID0gJChcIiNyZW1vdmUtY292ZXItYnRuXCIpLnBhcmVudCgpO1xyXG5cclxuXHRcdFx0XHRpbWcuc3JjID0gcmVzLmRhdGEuaW1nVXJsO1xyXG5cdFx0XHRcdGltZy5jbGFzc0xpc3QucmVtb3ZlKFwiZC1ub25lXCIpO1xyXG5cclxuXHRcdFx0XHQkKFwiI2NoYW5nZS1jb3Zlci1idG5cIikudGV4dChcIs6RzrvOu86xzrPOrlwiKTtcclxuXHRcdFx0XHQkKFwiI2NvdmVyLXN0YXR1c1wiKS5hZGRDbGFzcyhcImQtbm9uZVwiKTtcclxuXHJcblx0XHRcdFx0cmVtb3ZlQnRuQ250LnJlbW92ZUNsYXNzKFwiZC1ub25lXCIpO1xyXG5cdFx0XHRcdHJlbW92ZUJ0bkNudC5hZGRDbGFzcyhcImQtZmxleFwiKTtcclxuXHJcbiAgICAgICAgICAgICAgICB0b2FzdEFsZXJ0KFwic3VjY2Vzc1wiLCBcIs6kzr8gQ292ZXIgzqzOu867zrHOvs61IVwiKTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLmNhdGNoKGVyciA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xyXG4gICAgICAgICAgICAgICAgdG9hc3RBbGVydCgnZXJyb3InLCBcIs6gzrHPgc6/z4XPg865zqzPg8+EzrfOus61IM66zqzPgM6/zrnOvyDPgM+Bz4zOss67zrfOvM6xIC4uLlwiKTtcclxuICAgICAgICAgICAgfSlcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gYWRkVG9HYWxsZXJ5KG5hbWVzcGFjZSwgaWQsIGltYWdlSWQpIHtcclxuXHJcblx0YXhpb3MucG9zdCggXCIvbWVkaWEvZ2FsbGVyeVwiLCB7XHJcblx0XHRuYW1lc3BhY2UsXHJcblx0XHRtb2RlbElkOiBpZCxcclxuXHRcdGlkczogW2ltYWdlSWRdXHJcblx0fSlcclxuXHQudGhlbiggcmVzID0+IHtcclxuXHJcblx0XHRsZXQgZ2FsbGVyeSA9ICQoXCIjZ2FsbGVyeS1jbnRcIik7XHJcblx0XHRnYWxsZXJ5Lmh0bWwocmVzLmRhdGEpO1xyXG5cclxuXHRcdGxldCBjbG9zZUJ0bnMgPSBnYWxsZXJ5LmZpbmQoXCIuanMtcmVtb3ZlLWltYWdlXCIpO1xyXG5cdFx0Y2xvc2VCdG5zLm9uKFwiY2xpY2tcIiwgcmVtb3ZlSW1hZ2VIYW5kbGVyKTtcclxuXHJcblx0XHR0b2FzdEFsZXJ0KFwic3VjY2Vzc1wiLCBcIs6XIM61zrnOus+Mzr3OsSDPgM+Bzr/Pg8+Ezq3OuM63zrrOtS5cIik7XHJcblx0XHRnYWxsZXJ5Lm1vZGFsKFwiaGlkZVwiKTtcclxuXHJcblx0XHRsZXQgYnVsayA9ICQoXCIjZ2FsbGVyeS1idWxrLWFjdGlvbi1idG5cIik7XHJcblx0XHRsZXQgY2hlY2tib3hlcyA9ICQoXCIuanMtZ2FsbGVyeS1jaGVja2JveFwiKTtcclxuXHJcblx0XHRyZXNldEdhbGxlcnlCdG5zKCBidWxrLCBjaGVja2JveGVzICk7XHJcblx0fSlcclxuXHQuY2F0Y2goIGVyciA9PiB7XHJcblx0XHRjb25zb2xlLmxvZyhlcnIpO1xyXG5cdFx0dG9hc3RBbGVydCgnZXJyb3InLCBcIs6gzrHPgc6/z4XPg865zqzPg8+EzrfOus61IM66zqzPgM6/zrnOvyDPgM+Bz4zOss67zrfOvM6xIC4uLlwiKTtcclxuXHR9KVxyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gcmVtb3ZlSW1hZ2VIYW5kbGVyKCkge1xyXG5cdFN3YWwuZmlyZSh7XHJcblx0XHRpY29uOiAnaW5mbycsXHJcblx0XHR0aXRsZTogJ86gz4HOv8+Dzr/Ph86uIScsXHJcblx0XHR0ZXh0OiAnzpcgzrXOuc66z4zOvc6xIM64zrEgzrHPhs6xzrnPgc61zrjOtc6vIM6xz4DOvyDPhM6/IEdhbGxlcnkuJyxcclxuXHRcdHNob3dDYW5jZWxCdXR0b246IHRydWUsXHJcblx0XHRjb25maXJtQnV0dG9uQ29sb3I6ICcjNTM2ZGU2JyxcclxuXHRcdGNvbmZpcm1CdXR0b25UZXh0OiBgzp3Osc65LCDOsc+GzrHOr8+BzrXPg863IWAsXHJcblx0XHRjYW5jZWxCdXR0b25UZXh0OiBcIs6GzrrPhc+Bzr9cIlxyXG5cdH0pXHJcblx0LnRoZW4oKHJlc3VsdCkgPT4ge1xyXG5cclxuXHRcdGlmICggcmVzdWx0LmlzQ29uZmlybWVkICkge1xyXG5cdFx0XHRyZW1vdmVJbWFnZXMoIFt0aGlzLmRhdGFzZXQuaW1hZ2VJZF0gKTtcclxuXHRcdH1cclxuXHJcblx0fSlcclxufVxyXG5cclxuZnVuY3Rpb24gcmVtb3ZlSW1hZ2VzKCBpZHMgKSB7XHJcblxyXG5cdGxldCBnYWxsZXJ5ID0gJChcIiNnYWxsZXJ5LWNudFwiKVswXTtcclxuXHRsZXQgbmFtZXNwYWNlID0gZ2FsbGVyeS5kYXRhc2V0Lm5hbWVzcGFjZTtcclxuXHRsZXQgbW9kZWxJZCA9IGdhbGxlcnkuZGF0YXNldC5tb2RlbElkO1xyXG5cclxuXHRheGlvcy5wb3N0KFwiL21lZGlhL2dhbGxlcnktcmVtb3ZlXCIsIHtcclxuXHRcdG5hbWVzcGFjZSwgbW9kZWxJZCwgaWRzXHJcblx0fSlcclxuXHQudGhlbiggcmVzID0+IHtcclxuXHJcblx0XHRsZXQgZ2FsbGVyeSA9ICQoXCIjZ2FsbGVyeS1jbnRcIik7XHJcblx0XHRnYWxsZXJ5Lmh0bWwocmVzLmRhdGEpO1xyXG5cclxuXHRcdGxldCBjbG9zZUJ0bnMgPSBnYWxsZXJ5LmZpbmQoXCIuanMtcmVtb3ZlLWltYWdlXCIpO1xyXG5cdFx0Y2xvc2VCdG5zLm9uKFwiY2xpY2tcIiwgcmVtb3ZlSW1hZ2VIYW5kbGVyKTtcclxuXHJcblx0XHRpZiAoIGNsb3NlQnRucy5sZW5ndGggPT0gMCApIHtcclxuXHRcdFx0JChcIiNyZW1vdmUtYWxsLWltYWdlcy1idG5cIikuYWRkQ2xhc3MoXCJkLW5vbmVcIik7XHJcblx0XHR9XHJcblxyXG5cdH0pXHJcblx0LmNhdGNoKCBlcnIgPT4ge1xyXG5cdFx0Y29uc29sZS5sb2coZXJyKTtcclxuXHRcdHV0aWxpdGllcy50b2FzdEFsZXJ0KCAnZXJyb3InLCBcIs6gzrHPgc6/z4XPg865zqzPg8+EzrfOus61IM66zqzPgM6/zrnOvyDPgM+Bz4zOss67zrfOvM6xIC4uLlwiICk7XHJcblx0fSlcclxuXHJcbn1cclxuXHJcblxyXG5cclxuZnVuY3Rpb24gcmVzZXRHYWxsZXJ5QnRucyggYnVsaywgY2hlY2tib3hlcyApIHtcclxuXHJcblx0YnVsay50ZXh0KFwizpXPgM65zrvOv86zzq3PgiAoMClcIilcclxuXHRidWxrLnByb3AoXCJkaXNhYmxlZFwiLCB0cnVlKTtcclxuXHRidWxrLnJlbW92ZUNsYXNzKFwiYnRuLXdhcm5pbmdcIik7XHJcblx0YnVsay5hZGRDbGFzcyhcImJ0bi1zZWNvbmRhcnlcIik7XHJcblxyXG5cdGZvciAobGV0IGkgPSAwOyBpIDwgY2hlY2tib3hlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0Y2hlY2tib3hlc1tpXS5jaGVja2VkID0gZmFsc2U7XHJcblx0fVxyXG5cclxufVxyXG5cclxuLy8hIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXHJcbi8vIVx0XHRcdFx0TWVkaWEgTGlicmFyeSBGdW5jdGlvbnMgRW5kXHRcdFx0XHQjXHJcbi8vISMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gICAgdG9hc3RBbGVydCxcclxuICAgIG1haW5DaGVja2JveFN3aXRjaGVyLFxyXG4gICAgbWlub3JDaGVja2JveFN3aXRjaGVyLFxyXG4gICAgZmlsdGVyQnV0dG9uLFxyXG4gICAgdGFibGVMb2NhbGUsXHJcbiAgICBjaGFuZ2VJbnB1dEhpZGRlbixcclxuICAgIHJlZGFjdG9yQ29uZmlnLFxyXG4gICAgY3JlYXRlU3RhdGVTZWxlY3QsXHJcbiAgICBkYXRlUGlja2VyQ29uZmlnLFxyXG4gICAgdG9hc3RBbGVydERlbGV0ZSxcclxuICAgIGZpbHRlclN0eWxlLFxyXG4gICAgY3JlYXRlRGF0ZUVsbSxcclxuICAgIHN0YXJ0RGF0ZSxcclxuICAgIGVuZERhdGUsXHJcbiAgICByZXNldEJ1bGssXHJcbiAgICByZXNldEFkZEJ1dHRvbixcclxuICAgIGNyZWF0ZUNvdXJzZVR5cGVTZWxlY3QsXHJcbiAgICBwYWdpbmF0aW9uSGFuZGxlcixcclxuICAgIHNlYXJjaEhhbmRsZXIsXHJcbiAgICBpbWFnZUhhbmRsZXIsXHJcblx0cGFnaW5hdGlvblJlcXVlc3QsXHJcblx0cmVzZXRHYWxsZXJ5QnRucyxcclxuXHRyZW1vdmVJbWFnZUhhbmRsZXIsXHJcblx0cmVtb3ZlSW1hZ2VzLFxyXG5cdGFydGljbGVDb25maWcsXHJcblx0QUxMT1dFRFRZUEVTLFxyXG5cdHBhc3N3b3JkVmFsaWRhdGlvblxyXG59XHJcblxyXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/js/dashboard/main.js\n");

/***/ }),

/***/ "./resources/js/dashboard/materials/newMaterial.js":
/*!*********************************************************!*\
  !*** ./resources/js/dashboard/materials/newMaterial.js ***!
  \*********************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _main__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../main */ \"./resources/js/dashboard/main.js\");\n/* harmony import */ var filepond__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! filepond */ \"./node_modules/filepond/dist/filepond.js\");\n/* harmony import */ var filepond__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(filepond__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var filepond_plugin_file_validate_type__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! filepond-plugin-file-validate-type */ \"./node_modules/filepond-plugin-file-validate-type/dist/filepond-plugin-file-validate-type.js\");\n/* harmony import */ var filepond_plugin_file_validate_type__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(filepond_plugin_file_validate_type__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var filepond_plugin_file_validate_size__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! filepond-plugin-file-validate-size */ \"./node_modules/filepond-plugin-file-validate-size/dist/filepond-plugin-file-validate-size.js\");\n/* harmony import */ var filepond_plugin_file_validate_size__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(filepond_plugin_file_validate_size__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var filepond_dist_filepond_min_css__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! filepond/dist/filepond.min.css */ \"./node_modules/filepond/dist/filepond.min.css\");\n/* harmony import */ var filepond_dist_filepond_min_css__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(filepond_dist_filepond_min_css__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var codemirror_lib_codemirror__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! codemirror/lib/codemirror */ \"./node_modules/codemirror/lib/codemirror.js\");\n/* harmony import */ var codemirror_lib_codemirror__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(codemirror_lib_codemirror__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var codemirror_lib_codemirror_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! codemirror/lib/codemirror.css */ \"./node_modules/codemirror/lib/codemirror.css\");\n/* harmony import */ var codemirror_lib_codemirror_css__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(codemirror_lib_codemirror_css__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var codemirror_theme_shadowfox_css__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! codemirror/theme/shadowfox.css */ \"./node_modules/codemirror/theme/shadowfox.css\");\n/* harmony import */ var codemirror_theme_shadowfox_css__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(codemirror_theme_shadowfox_css__WEBPACK_IMPORTED_MODULE_7__);\n\n\n\n\n\n\n\n__webpack_require__(/*! codemirror/mode/htmlmixed/htmlmixed */ \"./node_modules/codemirror/mode/htmlmixed/htmlmixed.js\");\n\n__webpack_require__(/*! codemirror/addon/display/autorefresh */ \"./node_modules/codemirror/addon/display/autorefresh.js\");\n\n\n\n\nvar beautify_html = __webpack_require__(/*! js-beautify */ \"./node_modules/js-beautify/js/index.js\").html;\n\nvar baseUrl = window.location.origin;\nvar timer = 0;\nvar localRedactorConf = {\n  buttons: ['html', 'undo', 'redo', 'format', 'bold', 'underline', 'italic', 'deleted', 'sup', 'sub', 'lists', 'file', 'link', 'image'],\n  buttonsAddBefore: {\n    before: 'image',\n    buttons: ['mediaLibrary']\n  },\n  style: false,\n  plugins: [\"mediaLibrary\", 'alignment'],\n  minHeight: '150px',\n  imageResizable: true,\n  imagePosition: {\n    \"left\": \"image-left\",\n    \"right\": \"image-right\",\n    \"center\": \"image-center text-center\"\n  },\n  imageFloatMargin: '20px',\n  imageUpload: \"/media/upload-images\",\n  callbacks: {\n    upload: {\n      beforeSend: function beforeSend(xhr) {\n        xhr.setRequestHeader('X-CSRF-Token', $('meta[name=\"csrf-token\"]').attr('content'));\n      }\n    }\n  }\n};\n$(\".tab-link\").on(\"show.bs.tab\", function (event) {\n  event.preventDefault();\n  Swal.fire({\n    icon: 'info',\n    title: 'Προσοχή!',\n    html: \"<p class=\\\"mb-0\\\">\\u0398\\u03B1 \\u03C0\\u03C1\\u03AD\\u03C0\\u03B5\\u03B9 \\u03BD\\u03B1 \\u03B1\\u03C0\\u03BF\\u03B8\\u03B7\\u03BA\\u03B5\\u03CD\\u03C3\\u03B5\\u03C4\\u03B5 \\u03C4\\u03BF \\u03BC\\u03AC\\u03B8\\u03B7\\u03BC\\u03B1</p>\\u03B3\\u03B9\\u03B1 \\u03BD\\u03B1 \\u03C3\\u03C5\\u03BD\\u03B5\\u03C7\\u03AF\\u03C3\\u03B5\\u03C4\\u03B5!\",\n    confirmButtonColor: '#536de6'\n  });\n});\nvar pluginConfig = {\n  translations: {\n    en: {\n      \"mediaLibrary\": \"Media Library\"\n    }\n  },\n  init: function init(app) {\n    this.app = app;\n    this.lang = app.lang;\n    this.toolbar = app.toolbar;\n  },\n  start: function start() {\n    var buttonData = {\n      title: this.lang.get(\"mediaLibrary\"),\n      icon: \"<i class='mdi mdi-book-open-page-variant'></i>\",\n      api: \"plugin.mediaLibrary.toggle\"\n    };\n    var $button = this.toolbar.addButton(\"mediaLibrary\", buttonData);\n  },\n  toggle: function toggle() {\n    var id = this.app.rootElement.id;\n    $('#gallery-content')[0].dataset.editorId = \"#\".concat(id);\n    $('#gallery-content')[0].dataset.type = \"redactor\";\n    $('#gallery-modal').modal('show');\n  }\n};\n$R.add('plugin', 'mediaLibrary', pluginConfig);\n$R(\"#summary\", localRedactorConf);\n$R(\"#description\", localRedactorConf);\n$R(\"#material-content\", localRedactorConf);\nfilepond__WEBPACK_IMPORTED_MODULE_1__[\"registerPlugin\"](filepond_plugin_file_validate_type__WEBPACK_IMPORTED_MODULE_2___default.a);\nfilepond__WEBPACK_IMPORTED_MODULE_1__[\"registerPlugin\"](filepond_plugin_file_validate_size__WEBPACK_IMPORTED_MODULE_3___default.a);\nvar dropzone = document.getElementById(\"file-pond\");\nvar pond = filepond__WEBPACK_IMPORTED_MODULE_1__[\"create\"](dropzone, {\n  name: 'file[]',\n  allowMultiple: true,\n  className: \"js-filepond-file-dragging\",\n  labelIdle: \"Drag & Drop your files or Browse\",\n  allowRevert: false,\n  server: {\n    url: baseUrl,\n    process: {\n      url: '/media/upload-images',\n      headers: {\n        \"X-CSRF-TOKEN\": $('meta[name=\"csrf-token\"]').attr('content')\n      },\n      onload: function onload(data) {\n        _main__WEBPACK_IMPORTED_MODULE_0__[\"default\"].paginationRequest(1, \"\");\n      }\n    }\n  },\n  onprocessfile: function onprocessfile(error, data) {\n    if (pond.status === 2) {\n      (function () {\n        clearTimeout(timer);\n        var files = pond.getFiles();\n\n        var _loop = function _loop(i) {\n          if (files[i].status === 5) {\n            timer = setTimeout(function () {\n              pond.removeFile(files[i]);\n            }, (i + 1) * 500);\n          }\n        };\n\n        for (var i = 0; i < files.length; i++) {\n          _loop(i);\n        }\n      })();\n    }\n  },\n  onprocessfiles: function onprocessfiles() {\n    var files = pond.getFiles();\n\n    var _loop2 = function _loop2(i) {\n      timer = setTimeout(function () {\n        pond.removeFile(files[i]);\n      }, (i + 1) * 500);\n    };\n\n    for (var i = 0; i < files.length; i++) {\n      _loop2(i);\n    }\n  },\n  acceptedFileTypes: ['image/png', 'image/jpeg']\n});\n$(\"#image-search\").on(\"input\", _main__WEBPACK_IMPORTED_MODULE_0__[\"default\"].searchHandler);\n$(\".js-gallery-page-btn\").on('click', _main__WEBPACK_IMPORTED_MODULE_0__[\"default\"].paginationHandler);\n$(\".js-add-image\").on(\"click\", _main__WEBPACK_IMPORTED_MODULE_0__[\"default\"].imageHandler);\nvar dropArea = document.getElementsByClassName(\"js-filepond-file-dragging\");\n\nfor (var i = 0; i < dropArea.length; i++) {\n  dropArea[i].addEventListener(\"dragover\", function (event) {\n    var draggingArea = this.getElementsByClassName(\"filepond--drop-label\")[0];\n    var label = draggingArea.querySelector(\"label\");\n    draggingArea.classList.add(\"limegreen\");\n    label.classList.add(\"text-limegreen\");\n  });\n  dropArea[i].addEventListener(\"dragleave\", function (event) {\n    var draggingArea = this.getElementsByClassName(\"filepond--drop-label\")[0];\n    var label = draggingArea.querySelector(\"label\");\n    draggingArea.classList.remove(\"limegreen\");\n    label.classList.remove(\"text-limegreen\");\n  });\n  dropArea[i].addEventListener(\"drop\", function (event) {\n    var draggingArea = this.getElementsByClassName(\"filepond--drop-label\")[0];\n    var label = draggingArea.querySelector(\"label\");\n    draggingArea.classList.remove(\"limegreen\");\n    label.classList.remove(\"text-limegreen\");\n  });\n}\n\nvar editor = document.getElementById(\"editor\");\nvar scriptArea = document.getElementById(\"script-area\");\nvar format = beautify_html(scriptArea.value, {\n  indent_size: 4\n});\nvar myCodeMirror = codemirror_lib_codemirror__WEBPACK_IMPORTED_MODULE_5___default()(editor, {\n  viewportMargin: Infinity,\n  value: format,\n  mode: \"htmlmixed\",\n  theme: \"shadowfox\",\n  indentWithTabs: true,\n  lineNumbers: true,\n  lineWrapping: true,\n  autoRefresh: true,\n  styleActiveLine: true\n});\n$(\"#material-create\").on(\"submit\", function (event) {\n  var scriptValue = myCodeMirror.getValue();\n  scriptArea.value = scriptValue;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvZGFzaGJvYXJkL21hdGVyaWFscy9uZXdNYXRlcmlhbC5qcz84MjllIl0sIm5hbWVzIjpbInJlcXVpcmUiLCJiZWF1dGlmeV9odG1sIiwiaHRtbCIsImJhc2VVcmwiLCJ3aW5kb3ciLCJsb2NhdGlvbiIsIm9yaWdpbiIsInRpbWVyIiwibG9jYWxSZWRhY3RvckNvbmYiLCJidXR0b25zIiwiYnV0dG9uc0FkZEJlZm9yZSIsImJlZm9yZSIsInN0eWxlIiwicGx1Z2lucyIsIm1pbkhlaWdodCIsImltYWdlUmVzaXphYmxlIiwiaW1hZ2VQb3NpdGlvbiIsImltYWdlRmxvYXRNYXJnaW4iLCJpbWFnZVVwbG9hZCIsImNhbGxiYWNrcyIsInVwbG9hZCIsImJlZm9yZVNlbmQiLCJ4aHIiLCJzZXRSZXF1ZXN0SGVhZGVyIiwiJCIsImF0dHIiLCJvbiIsImV2ZW50IiwicHJldmVudERlZmF1bHQiLCJTd2FsIiwiZmlyZSIsImljb24iLCJ0aXRsZSIsImNvbmZpcm1CdXR0b25Db2xvciIsInBsdWdpbkNvbmZpZyIsInRyYW5zbGF0aW9ucyIsImVuIiwiaW5pdCIsImFwcCIsImxhbmciLCJ0b29sYmFyIiwic3RhcnQiLCJidXR0b25EYXRhIiwiZ2V0IiwiYXBpIiwiJGJ1dHRvbiIsImFkZEJ1dHRvbiIsInRvZ2dsZSIsImlkIiwicm9vdEVsZW1lbnQiLCJkYXRhc2V0IiwiZWRpdG9ySWQiLCJ0eXBlIiwibW9kYWwiLCIkUiIsImFkZCIsIkZpbGVQb25kIiwiRmlsZVBvbmRQbHVnaW5GaWxlVmFsaWRhdGVUeXBlIiwiRmlsZVBvbmRQbHVnaW5GaWxlVmFsaWRhdGVTaXplIiwiZHJvcHpvbmUiLCJkb2N1bWVudCIsImdldEVsZW1lbnRCeUlkIiwicG9uZCIsIm5hbWUiLCJhbGxvd011bHRpcGxlIiwiY2xhc3NOYW1lIiwibGFiZWxJZGxlIiwiYWxsb3dSZXZlcnQiLCJzZXJ2ZXIiLCJ1cmwiLCJwcm9jZXNzIiwiaGVhZGVycyIsIm9ubG9hZCIsImRhdGEiLCJ1dGlsaXRpZXMiLCJwYWdpbmF0aW9uUmVxdWVzdCIsIm9ucHJvY2Vzc2ZpbGUiLCJlcnJvciIsInN0YXR1cyIsImNsZWFyVGltZW91dCIsImZpbGVzIiwiZ2V0RmlsZXMiLCJpIiwic2V0VGltZW91dCIsInJlbW92ZUZpbGUiLCJsZW5ndGgiLCJvbnByb2Nlc3NmaWxlcyIsImFjY2VwdGVkRmlsZVR5cGVzIiwic2VhcmNoSGFuZGxlciIsInBhZ2luYXRpb25IYW5kbGVyIiwiaW1hZ2VIYW5kbGVyIiwiZHJvcEFyZWEiLCJnZXRFbGVtZW50c0J5Q2xhc3NOYW1lIiwiYWRkRXZlbnRMaXN0ZW5lciIsImRyYWdnaW5nQXJlYSIsImxhYmVsIiwicXVlcnlTZWxlY3RvciIsImNsYXNzTGlzdCIsInJlbW92ZSIsImVkaXRvciIsInNjcmlwdEFyZWEiLCJmb3JtYXQiLCJ2YWx1ZSIsImluZGVudF9zaXplIiwibXlDb2RlTWlycm9yIiwiQ29kZU1pcnJvciIsInZpZXdwb3J0TWFyZ2luIiwiSW5maW5pdHkiLCJtb2RlIiwidGhlbWUiLCJpbmRlbnRXaXRoVGFicyIsImxpbmVOdW1iZXJzIiwibGluZVdyYXBwaW5nIiwiYXV0b1JlZnJlc2giLCJzdHlsZUFjdGl2ZUxpbmUiLCJzY3JpcHRWYWx1ZSIsImdldFZhbHVlIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFDQUEsbUJBQU8sQ0FBQyxrR0FBRCxDQUFQOztBQUNBQSxtQkFBTyxDQUFDLG9HQUFELENBQVA7O0FBQ0E7QUFDQTs7QUFFQSxJQUFNQyxhQUFhLEdBQUdELG1CQUFPLENBQUMsMkRBQUQsQ0FBUCxDQUF1QkUsSUFBN0M7O0FBRUEsSUFBTUMsT0FBTyxHQUFHQyxNQUFNLENBQUNDLFFBQVAsQ0FBZ0JDLE1BQWhDO0FBQ0EsSUFBSUMsS0FB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YWwuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdXRpbGl0aWVzIGZyb20gJy4uL21haW4nO1xyXG5pbXBvcnQgKiBhcyBGaWxlUG9uZCBmcm9tIFwiZmlsZXBvbmRcIjtcclxuaW1wb3J0IEZpbGVQb25kUGx1Z2luRmlsZVZhbGlkYXRlVHlwZSBmcm9tICdmaWxlcG9uZC1wbHVnaW4tZmlsZS12YWxpZGF0ZS10eXBlJztcclxuaW1wb3J0IEZpbGVQb25kUGx1Z2luRmlsZVZhbGlkYXRlU2l6ZSBmcm9tICdmaWxlcG9uZC1wbHVnaW4tZmlsZS12YWxpZGF0ZS1zaXplJztcclxuaW1wb3J0ICdmaWxlcG9uZC9kaXN0L2ZpbGVwb25kLm1pbi5jc3MnO1xyXG5cclxuaW1wb3J0IENvZGVNaXJyb3IgZnJvbSBcImNvZGVtaXJyb3IvbGliL2NvZGVtaXJyb3JcIjtcclxucmVxdWlyZShcImNvZGVtaXJyb3IvbW9kZS9odG1sbWl4ZWQvaHRtbG1peGVkXCIpO1xyXG5yZXF1aXJlKFwiY29kZW1pcnJvci9hZGRvbi9kaXNwbGF5L2F1dG9yZWZyZXNoXCIpO1xyXG5pbXBvcnQgXCJjb2RlbWlycm9yL2xpYi9jb2RlbWlycm9yLmNzc1wiO1xyXG5pbXBvcnQgXCJjb2RlbWlycm9yL3RoZW1lL3NoYWRvd2ZveC5jc3NcIjtcclxuXHJcbmNvbnN0IGJlYXV0aWZ5X2h0bWwgPSByZXF1aXJlKCdqcy1iZWF1dGlmeScpLmh0bWxcclxuXHJcbmNvbnN0IGJhc2VVcmwgPSB3aW5kb3cubG9jYXRpb24ub3JpZ2luO1xyXG5sZXQgdGltZXIgPSAwO1xyXG5cclxuY29uc3QgbG9jYWxSZWRhY3RvckNvbmYgPSB7XHJcbiAgICBidXR0b25zOiBbXHJcbiAgICAgICAgJ2h0bWwnLCAndW5kbycsICdyZWRvJywgJ2Zvcm1hdCcsXHJcbiAgICAgICAgJ2JvbGQnLCAndW5kZXJsaW5lJywgJ2l0YWxpYycsICdkZWxldGVkJyxcclxuICAgICAgICAnc3VwJywgJ3N1YicsICdsaXN0cycsICdmaWxlJywgJ2xpbmsnLCAnaW1hZ2UnXHJcbiAgICBdLFxyXG4gICAgYnV0dG9uc0FkZEJlZm9yZToge2JlZm9yZTogJ2ltYWdlJywgYnV0dG9uczogWydtZWRpYUxpYnJhcnknXX0sXHJcbiAgICBzdHlsZTogZmFsc2UsXHJcbiAgICBwbHVnaW5zOiBbXCJtZWRpYUxpYnJhcnlcIiwgJ2FsaWdubWVudCddLFxyXG4gICAgbWluSGVpZ2h0OiAnMTUwcHgnLFxyXG4gICAgaW1hZ2VSZXNpemFibGU6IHRydWUsXHJcbiAgICBpbWFnZVBvc2l0aW9uOiB7XHJcbiAgICAgICAgXCJsZWZ0XCI6IFwiaW1hZ2UtbGVmdFwiLFxyXG4gICAgICAgIFwicmlnaHRcIjogXCJpbWFnZS1yaWdodFwiLFxyXG4gICAgICAgIFwiY2VudGVyXCI6IFwiaW1hZ2UtY2VudGVyIHRleHQtY2VudGVyXCJcclxuICAgIH0sXHJcbiAgICBpbWFnZUZsb2F0TWFyZ2luOiAnMjBweCcsXHJcbiAgICBpbWFnZVVwbG9hZDogXCIvbWVkaWEvdXBsb2FkLWltYWdlc1wiLFxyXG4gICAgY2FsbGJhY2tzOiB7XHJcbiAgICAgICAgdXBsb2FkOiB7XHJcbiAgICAgICAgICAgIGJlZm9yZVNlbmQ6IGZ1bmN0aW9uICh4aHIpIHtcclxuICAgICAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdYLUNTUkYtVG9rZW4nLCAkKCdtZXRhW25hbWU9XCJjc3JmLXRva2VuXCJdJykuYXR0cignY29udGVudCcpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuJChcIi50YWItbGlua1wiKS5vbihcInNob3cuYnMudGFiXCIsIGZ1bmN0aW9uKGV2ZW50KSB7XHJcblx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuXHJcblx0U3dhbC5maXJlKHtcclxuXHRcdGljb246ICdpbmZvJyxcclxuXHRcdHRpdGxlOiAnzqDPgc6/z4POv8+Hzq4hJyxcclxuXHRcdGh0bWw6IGA8cCBjbGFzcz1cIm1iLTBcIj7OmM6xIM+Az4HOrc+AzrXOuSDOvc6xIM6xz4DOv864zrfOus61z43Pg861z4TOtSDPhM6/IM68zqzOuM63zrzOsTwvcD7Os865zrEgzr3OsSDPg8+Fzr3Otc+Hzq/Pg861z4TOtSFgLFxyXG5cdFx0Y29uZmlybUJ1dHRvbkNvbG9yOiAnIzUzNmRlNidcclxuXHR9KTtcclxufSlcclxuXHJcbmxldCBwbHVnaW5Db25maWcgPSB7XHJcbiAgICB0cmFuc2xhdGlvbnM6IHtcclxuICAgICAgICBlbjoge1xyXG4gICAgICAgICAgICBcIm1lZGlhTGlicmFyeVwiOiBcIk1lZGlhIExpYnJhcnlcIlxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBpbml0OiBmdW5jdGlvbiAoYXBwKSB7XHJcbiAgICAgICAgdGhpcy5hcHAgPSBhcHA7XHJcbiAgICAgICAgdGhpcy5sYW5nID0gYXBwLmxhbmc7XHJcbiAgICAgICAgdGhpcy50b29sYmFyID0gYXBwLnRvb2xiYXI7XHJcbiAgICB9LFxyXG4gICAgc3RhcnQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgYnV0dG9uRGF0YSA9IHtcclxuICAgICAgICAgICAgdGl0bGU6IHRoaXMubGFuZy5nZXQoXCJtZWRpYUxpYnJhcnlcIiksXHJcbiAgICAgICAgICAgIGljb246IFwiPGkgY2xhc3M9J21kaSBtZGktYm9vay1vcGVuLXBhZ2UtdmFyaWFudCc+PC9pPlwiLFxyXG4gICAgICAgICAgICBhcGk6IFwicGx1Z2luLm1lZGlhTGlicmFyeS50b2dnbGVcIlxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHZhciAkYnV0dG9uID0gdGhpcy50b29sYmFyLmFkZEJ1dHRvbihcIm1lZGlhTGlicmFyeVwiLCBidXR0b25EYXRhKTtcclxuICAgIH0sXHJcbiAgICB0b2dnbGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGNvbnN0IGlkID0gdGhpcy5hcHAucm9vdEVsZW1lbnQuaWQ7XHJcblxyXG4gICAgICAgICQoJyNnYWxsZXJ5LWNvbnRlbnQnKVswXS5kYXRhc2V0LmVkaXRvcklkID0gYCMke2lkfWBcclxuICAgICAgICAkKCcjZ2FsbGVyeS1jb250ZW50JylbMF0uZGF0YXNldC50eXBlID0gXCJyZWRhY3RvclwiXHJcbiAgICAgICAgJCgnI2dhbGxlcnktbW9kYWwnKS5tb2RhbCgnc2hvdycpXHJcbiAgICB9XHJcbn1cclxuXHJcbiRSLmFkZCgncGx1Z2luJywgJ21lZGlhTGlicmFyeScsIHBsdWdpbkNvbmZpZyk7XHJcbiRSKFwiI3N1bW1hcnlcIiwgbG9jYWxSZWRhY3RvckNvbmYpO1xyXG4kUihcIiNkZXNjcmlwdGlvblwiLCBsb2NhbFJlZGFjdG9yQ29uZik7XHJcbiRSKFwiI21hdGVyaWFsLWNvbnRlbnRcIiwgbG9jYWxSZWRhY3RvckNvbmYpO1xyXG5cclxuRmlsZVBvbmQucmVnaXN0ZXJQbHVnaW4oRmlsZVBvbmRQbHVnaW5GaWxlVmFsaWRhdGVUeXBlKTtcclxuRmlsZVBvbmQucmVnaXN0ZXJQbHVnaW4oRmlsZVBvbmRQbHVnaW5GaWxlVmFsaWRhdGVTaXplKTtcclxuXHJcbmxldCBkcm9wem9uZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZmlsZS1wb25kXCIpO1xyXG5jb25zdCBwb25kID0gRmlsZVBvbmQuY3JlYXRlKGRyb3B6b25lLCB7XHJcblx0bmFtZTogJ2ZpbGVbXScsXHJcblx0YWxsb3dNdWx0aXBsZTogdHJ1ZSxcclxuXHRjbGFzc05hbWU6IFwianMtZmlsZXBvbmQtZmlsZS1kcmFnZ2luZ1wiLFxyXG5cdGxhYmVsSWRsZTogXCJEcmFnICYgRHJvcCB5b3VyIGZpbGVzIG9yIEJyb3dzZVwiLFxyXG5cdGFsbG93UmV2ZXJ0OiBmYWxzZSxcclxuICAgIHNlcnZlcjoge1xyXG5cdFx0dXJsOiBiYXNlVXJsLFxyXG5cdFx0cHJvY2Vzczoge1xyXG5cdFx0XHR1cmw6ICcvbWVkaWEvdXBsb2FkLWltYWdlcycsXHJcblx0XHRcdGhlYWRlcnM6IHtcclxuXHRcdFx0XHRcIlgtQ1NSRi1UT0tFTlwiOiAkKCdtZXRhW25hbWU9XCJjc3JmLXRva2VuXCJdJykuYXR0cignY29udGVudCcpLFxyXG5cdFx0XHR9LFxyXG5cdFx0XHRvbmxvYWQ6IGZ1bmN0aW9uKGRhdGEpIHtcclxuXHRcdFx0XHR1dGlsaXRpZXMucGFnaW5hdGlvblJlcXVlc3QoIDEsIFwiXCIgKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblx0b25wcm9jZXNzZmlsZTogZnVuY3Rpb24gKGVycm9yLCBkYXRhKSB7XHJcblx0XHRpZiAoIHBvbmQuc3RhdHVzID09PSAyICkge1xyXG5cdFx0XHRjbGVhclRpbWVvdXQodGltZXIpO1xyXG5cdFx0XHRsZXQgZmlsZXMgPSBwb25kLmdldEZpbGVzKCk7XHJcblxyXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGZpbGVzLmxlbmd0aDsgaSsrICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIGZpbGVzW2ldLnN0YXR1cyA9PT0gNSApIHtcclxuXHRcdFx0XHRcdHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdFx0cG9uZC5yZW1vdmVGaWxlKGZpbGVzW2ldKTtcclxuXHRcdFx0XHRcdH0sICggaSArIDEgKSAqIDUwMCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHRvbnByb2Nlc3NmaWxlczogZnVuY3Rpb24oKSB7XHJcblx0XHRsZXQgZmlsZXMgPSBwb25kLmdldEZpbGVzKCk7XHJcblxyXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBmaWxlcy5sZW5ndGg7IGkrKyApIHtcclxuXHJcblx0XHRcdHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRwb25kLnJlbW92ZUZpbGUoZmlsZXNbaV0pO1xyXG5cdFx0XHRcdFxyXG5cdFx0XHR9LCAoIGkgKyAxICkgKiA1MDApO1xyXG5cdFx0XHRcclxuXHRcdH1cclxuXHR9LFxyXG5cdGFjY2VwdGVkRmlsZVR5cGVzOiBbJ2ltYWdlL3BuZycsICdpbWFnZS9qcGVnJ10sXHJcbn0pO1xyXG5cclxuJChcIiNpbWFnZS1zZWFyY2hcIikub24oXCJpbnB1dFwiLCB1dGlsaXRpZXMuc2VhcmNoSGFuZGxlcik7XHJcblxyXG4kKFwiLmpzLWdhbGxlcnktcGFnZS1idG5cIikub24oICdjbGljaycsIHV0aWxpdGllcy5wYWdpbmF0aW9uSGFuZGxlcik7XHJcblxyXG4kKFwiLmpzLWFkZC1pbWFnZVwiKS5vbihcImNsaWNrXCIsIHV0aWxpdGllcy5pbWFnZUhhbmRsZXIpO1xyXG5cclxuY29uc3QgZHJvcEFyZWEgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwianMtZmlsZXBvbmQtZmlsZS1kcmFnZ2luZ1wiKTtcclxuXHJcbmZvciAoIGxldCBpID0gMDsgaSA8IGRyb3BBcmVhLmxlbmd0aDsgaSsrICkge1xyXG5cclxuXHRkcm9wQXJlYVtpXS5hZGRFdmVudExpc3RlbmVyKFwiZHJhZ292ZXJcIiwgZnVuY3Rpb24oZXZlbnQpIHtcclxuXHRcdGNvbnN0IGRyYWdnaW5nQXJlYSA9IHRoaXMuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcImZpbGVwb25kLS1kcm9wLWxhYmVsXCIpWzBdO1xyXG5cdFx0Y29uc3QgbGFiZWwgPSBkcmFnZ2luZ0FyZWEucXVlcnlTZWxlY3RvcihcImxhYmVsXCIpO1xyXG5cclxuXHRcdGRyYWdnaW5nQXJlYS5jbGFzc0xpc3QuYWRkKFwibGltZWdyZWVuXCIpO1xyXG5cdFx0bGFiZWwuY2xhc3NMaXN0LmFkZChcInRleHQtbGltZWdyZWVuXCIpO1xyXG5cclxuXHR9KTtcclxuXHJcblx0ZHJvcEFyZWFbaV0uYWRkRXZlbnRMaXN0ZW5lcihcImRyYWdsZWF2ZVwiLCBmdW5jdGlvbihldmVudCkge1xyXG5cdFx0Y29uc3QgZHJhZ2dpbmdBcmVhID0gdGhpcy5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwiZmlsZXBvbmQtLWRyb3AtbGFiZWxcIilbMF07XHJcblx0XHRjb25zdCBsYWJlbCA9IGRyYWdnaW5nQXJlYS5xdWVyeVNlbGVjdG9yKFwibGFiZWxcIik7XHJcblxyXG5cdFx0ZHJhZ2dpbmdBcmVhLmNsYXNzTGlzdC5yZW1vdmUoXCJsaW1lZ3JlZW5cIik7XHJcblx0XHRsYWJlbC5jbGFzc0xpc3QucmVtb3ZlKFwidGV4dC1saW1lZ3JlZW5cIik7XHJcblxyXG5cdH0pO1xyXG5cclxuXHRkcm9wQXJlYVtpXS5hZGRFdmVudExpc3RlbmVyKFwiZHJvcFwiLCBmdW5jdGlvbihldmVudCkge1xyXG5cdFx0Y29uc3QgZHJhZ2dpbmdBcmVhID0gdGhpcy5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwiZmlsZXBvbmQtLWRyb3AtbGFiZWxcIilbMF07XHJcblx0XHRjb25zdCBsYWJlbCA9IGRyYWdnaW5nQXJlYS5xdWVyeVNlbGVjdG9yKFwibGFiZWxcIik7XHJcblxyXG5cdFx0ZHJhZ2dpbmdBcmVhLmNsYXNzTGlzdC5yZW1vdmUoXCJsaW1lZ3JlZW5cIik7XHJcblx0XHRsYWJlbC5jbGFzc0xpc3QucmVtb3ZlKFwidGV4dC1saW1lZ3JlZW5cIik7XHJcblxyXG5cdH0pO1xyXG59XHJcblxyXG5jb25zdCBlZGl0b3IgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImVkaXRvclwiKTtcclxuY29uc3Qgc2NyaXB0QXJlYSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic2NyaXB0LWFyZWFcIik7XHJcblxyXG5jb25zdCBmb3JtYXQgPSBiZWF1dGlmeV9odG1sKHNjcmlwdEFyZWEudmFsdWUsIHtpbmRlbnRfc2l6ZTogNH0pXHJcblxyXG5jb25zdCBteUNvZGVNaXJyb3IgPSBDb2RlTWlycm9yKGVkaXRvciwge1xyXG5cdHZpZXdwb3J0TWFyZ2luOiBJbmZpbml0eSxcclxuXHR2YWx1ZTogZm9ybWF0LFxyXG5cdG1vZGU6ICBcImh0bWxtaXhlZFwiLFxyXG5cdHRoZW1lOiBcInNoYWRvd2ZveFwiLFxyXG5cdGluZGVudFdpdGhUYWJzOiB0cnVlLFxyXG5cdGxpbmVOdW1iZXJzOiB0cnVlLFxyXG5cdGxpbmVXcmFwcGluZzogdHJ1ZSxcclxuXHRhdXRvUmVmcmVzaDogdHJ1ZSxcclxuXHRzdHlsZUFjdGl2ZUxpbmU6IHRydWVcclxufSk7XHJcblxyXG4kKFwiI21hdGVyaWFsLWNyZWF0ZVwiKS5vbihcInN1Ym1pdFwiLCBmdW5jdGlvbihldmVudCkge1xyXG5cclxuXHRjb25zdCBzY3JpcHRWYWx1ZSA9IG15Q29kZU1pcnJvci5nZXRWYWx1ZSgpO1xyXG5cdHNjcmlwdEFyZWEudmFsdWUgPSBzY3JpcHRWYWx1ZTtcclxuXHJcbn0pOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./resources/js/dashboard/materials/newMaterial.js\n");

/***/ }),

/***/ 10:
/*!***************************************************************!*\
  !*** multi ./resources/js/dashboard/materials/newMaterial.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! D:\Coding\Darkpony\Idrogeios\Demo LMS\resources\js\dashboard\materials\newMaterial.js */"./resources/js/dashboard/materials/newMaterial.js");


/***/ })

/******/ });