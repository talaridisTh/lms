/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 19);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/css-loader/index.js?!./node_modules/postcss-loader/src/index.js?!./node_modules/filepond/dist/filepond.min.css":
/*!*************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader??ref--9-1!./node_modules/postcss-loader/src??ref--9-2!./node_modules/filepond/dist/filepond.min.css ***!
  \*************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(/*! ../../css-loader/lib/css-base.js */ \"./node_modules/css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.i, \"/*!\\n * FilePond 4.23.1\\n * Licensed under MIT, https://opensource.org/licenses/MIT/\\n * Please visit https://pqina.nl/filepond/ for details.\\n */\\n\\n/* eslint-disable */\\n.filepond--assistant{position:absolute;overflow:hidden;height:1px;width:1px;padding:0;border:0;clip:rect(1px,1px,1px,1px);-webkit-clip-path:inset(50%);clip-path:inset(50%);white-space:nowrap}.filepond--browser.filepond--browser{position:absolute;margin:0;padding:0;left:1em;top:1.75em;width:calc(100% - 2em);opacity:0;font-size:0}.filepond--data{position:absolute;width:0;height:0;padding:0;margin:0;border:none;visibility:hidden;pointer-events:none;contain:strict}.filepond--drip{position:absolute;top:0;left:0;right:0;bottom:0;overflow:hidden;opacity:.1;pointer-events:none;border-radius:.5em;background:rgba(0,0,0,.01)}.filepond--drip-blob{-webkit-transform-origin:center center;transform-origin:center center;width:8em;height:8em;margin-left:-4em;margin-top:-4em;background:#292625;border-radius:50%}.filepond--drip-blob,.filepond--drop-label{position:absolute;top:0;left:0;will-change:transform,opacity}.filepond--drop-label{right:0;margin:0;color:#4f4f4f;display:flex;justify-content:center;align-items:center;height:0;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.filepond--drop-label.filepond--drop-label label{display:block;margin:0;padding:.5em}.filepond--drop-label label{cursor:default;font-size:.875em;font-weight:400;text-align:center;line-height:1.5}.filepond--label-action{text-decoration:underline;-webkit-text-decoration-skip:ink;text-decoration-skip-ink:auto;-webkit-text-decoration-color:#a7a4a4;text-decoration-color:#a7a4a4;cursor:pointer}.filepond--root[data-disabled] .filepond--drop-label label{opacity:.5}.filepond--file-action-button.filepond--file-action-button{font-size:1em;width:1.625em;height:1.625em;font-family:inherit;line-height:inherit;margin:0;padding:0;border:none;outline:none;will-change:transform,opacity}.filepond--file-action-button.filepond--file-action-button span{position:absolute;overflow:hidden;height:1px;width:1px;padding:0;border:0;clip:rect(1px,1px,1px,1px);-webkit-clip-path:inset(50%);clip-path:inset(50%);white-space:nowrap}.filepond--file-action-button.filepond--file-action-button svg{width:100%;height:100%}.filepond--file-action-button.filepond--file-action-button:after{position:absolute;left:-.75em;right:-.75em;top:-.75em;bottom:-.75em;content:\\\"\\\"}.filepond--file-action-button{cursor:auto;color:#fff;border-radius:50%;background-color:rgba(0,0,0,.5);background-image:none;box-shadow:0 0 0 0 hsla(0,0%,100%,0);transition:box-shadow .25s ease-in}.filepond--file-action-button:focus,.filepond--file-action-button:hover{box-shadow:0 0 0 .125em hsla(0,0%,100%,.9)}.filepond--file-action-button[disabled]{color:hsla(0,0%,100%,.5);background-color:rgba(0,0,0,.25)}.filepond--file-action-button[hidden]{display:none}.filepond--file-info{position:static;display:flex;flex-direction:column;align-items:flex-start;flex:1;margin:0 .5em 0 0;min-width:0;will-change:transform,opacity;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.filepond--file-info *{margin:0}.filepond--file-info .filepond--file-info-main{font-size:.75em;line-height:1.2;text-overflow:ellipsis;overflow:hidden;white-space:nowrap;width:100%}.filepond--file-info .filepond--file-info-sub{font-size:.625em;opacity:.5;transition:opacity .25s ease-in-out;white-space:nowrap}.filepond--file-info .filepond--file-info-sub:empty{display:none}.filepond--file-status{position:static;display:flex;flex-direction:column;align-items:flex-end;flex-grow:0;flex-shrink:0;margin:0;min-width:2.25em;text-align:right;will-change:transform,opacity;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.filepond--file-status *{margin:0;white-space:nowrap}.filepond--file-status .filepond--file-status-main{font-size:.75em;line-height:1.2}.filepond--file-status .filepond--file-status-sub{font-size:.625em;opacity:.5;transition:opacity .25s ease-in-out}.filepond--file-wrapper.filepond--file-wrapper{border:none;margin:0;padding:0;min-width:0;height:100%}.filepond--file-wrapper.filepond--file-wrapper>legend{position:absolute;overflow:hidden;height:1px;width:1px;padding:0;border:0;clip:rect(1px,1px,1px,1px);-webkit-clip-path:inset(50%);clip-path:inset(50%);white-space:nowrap}.filepond--file{position:static;display:flex;height:100%;align-items:flex-start;padding:.5625em;color:#fff;border-radius:.5em}.filepond--file .filepond--file-status{margin-left:auto;margin-right:2.25em}.filepond--file .filepond--processing-complete-indicator{pointer-events:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;z-index:3}.filepond--file .filepond--file-action-button,.filepond--file .filepond--processing-complete-indicator,.filepond--file .filepond--progress-indicator{position:absolute}.filepond--file [data-align*=left]{left:.5625em}.filepond--file [data-align*=right]{right:.5625em}.filepond--file [data-align*=center]{left:calc(50% - .8125em)}.filepond--file [data-align*=bottom]{bottom:1.125em}.filepond--file [data-align=center]{top:calc(50% - .8125em)}.filepond--file .filepond--progress-indicator{margin-top:.1875em}.filepond--file .filepond--progress-indicator[data-align*=right]{margin-right:.1875em}.filepond--file .filepond--progress-indicator[data-align*=left]{margin-left:.1875em}[data-filepond-item-state*=error] .filepond--file-info,[data-filepond-item-state*=invalid] .filepond--file-info,[data-filepond-item-state=cancelled] .filepond--file-info{margin-right:2.25em}[data-filepond-item-state~=processing] .filepond--file-status-sub{opacity:0}[data-filepond-item-state~=processing] .filepond--action-abort-item-processing~.filepond--file-status .filepond--file-status-sub{opacity:.5}[data-filepond-item-state=processing-error] .filepond--file-status-sub{opacity:0}[data-filepond-item-state=processing-error] .filepond--action-retry-item-processing~.filepond--file-status .filepond--file-status-sub{opacity:.5}[data-filepond-item-state=processing-complete] .filepond--action-revert-item-processing svg{-webkit-animation:fall .5s linear .125s both;animation:fall .5s linear .125s both}[data-filepond-item-state=processing-complete] .filepond--file-status-sub{opacity:.5}[data-filepond-item-state=processing-complete] .filepond--file-info-sub,[data-filepond-item-state=processing-complete] .filepond--processing-complete-indicator:not([style*=hidden])~.filepond--file-status .filepond--file-status-sub{opacity:0}[data-filepond-item-state=processing-complete] .filepond--action-revert-item-processing~.filepond--file-info .filepond--file-info-sub{opacity:.5}[data-filepond-item-state*=error] .filepond--file-wrapper,[data-filepond-item-state*=error] .filepond--panel,[data-filepond-item-state*=invalid] .filepond--file-wrapper,[data-filepond-item-state*=invalid] .filepond--panel{-webkit-animation:shake .65s linear both;animation:shake .65s linear both}[data-filepond-item-state*=busy] .filepond--progress-indicator svg{-webkit-animation:spin 1s linear infinite;animation:spin 1s linear infinite}@-webkit-keyframes spin{0%{-webkit-transform:rotate(0deg);transform:rotate(0deg)}to{-webkit-transform:rotate(1turn);transform:rotate(1turn)}}@keyframes spin{0%{-webkit-transform:rotate(0deg);transform:rotate(0deg)}to{-webkit-transform:rotate(1turn);transform:rotate(1turn)}}@-webkit-keyframes shake{10%,90%{-webkit-transform:translateX(-.0625em);transform:translateX(-.0625em)}20%,80%{-webkit-transform:translateX(.125em);transform:translateX(.125em)}30%,50%,70%{-webkit-transform:translateX(-.25em);transform:translateX(-.25em)}40%,60%{-webkit-transform:translateX(.25em);transform:translateX(.25em)}}@keyframes shake{10%,90%{-webkit-transform:translateX(-.0625em);transform:translateX(-.0625em)}20%,80%{-webkit-transform:translateX(.125em);transform:translateX(.125em)}30%,50%,70%{-webkit-transform:translateX(-.25em);transform:translateX(-.25em)}40%,60%{-webkit-transform:translateX(.25em);transform:translateX(.25em)}}@-webkit-keyframes fall{0%{opacity:0;-webkit-transform:scale(.5);transform:scale(.5);-webkit-animation-timing-function:ease-out;animation-timing-function:ease-out}70%{opacity:1;-webkit-transform:scale(1.1);transform:scale(1.1);-webkit-animation-timing-function:ease-in-out;animation-timing-function:ease-in-out}to{-webkit-transform:scale(1);transform:scale(1);-webkit-animation-timing-function:ease-out;animation-timing-function:ease-out}}@keyframes fall{0%{opacity:0;-webkit-transform:scale(.5);transform:scale(.5);-webkit-animation-timing-function:ease-out;animation-timing-function:ease-out}70%{opacity:1;-webkit-transform:scale(1.1);transform:scale(1.1);-webkit-animation-timing-function:ease-in-out;animation-timing-function:ease-in-out}to{-webkit-transform:scale(1);transform:scale(1);-webkit-animation-timing-function:ease-out;animation-timing-function:ease-out}}.filepond--hopper[data-hopper-state=drag-over]>*{pointer-events:none}.filepond--hopper[data-hopper-state=drag-over]:after{content:\\\"\\\";position:absolute;left:0;top:0;right:0;bottom:0;z-index:100}.filepond--progress-indicator{z-index:103}.filepond--file-action-button{z-index:102}.filepond--file-status{z-index:101}.filepond--file-info{z-index:100}.filepond--item{position:absolute;top:0;left:0;right:0;z-index:1;padding:0;margin:.25em;will-change:transform,opacity}.filepond--item>.filepond--panel{z-index:-1}.filepond--item>.filepond--panel .filepond--panel-bottom{box-shadow:0 .0625em .125em -.0625em rgba(0,0,0,.25)}.filepond--item>.filepond--file-wrapper,.filepond--item>.filepond--panel{transition:opacity .15s ease-out}.filepond--item[data-drag-state]{cursor:-webkit-grab;cursor:grab}.filepond--item[data-drag-state]>.filepond--panel{transition:box-shadow .125s ease-in-out;box-shadow:0 0 0 transparent}.filepond--item[data-drag-state=drag]{cursor:-webkit-grabbing;cursor:grabbing}.filepond--item[data-drag-state=drag]>.filepond--panel{box-shadow:0 .125em .3125em rgba(0,0,0,.325)}.filepond--item[data-drag-state]:not([data-drag-state=idle]){z-index:2}.filepond--item-panel{background-color:#64605e}[data-filepond-item-state=processing-complete] .filepond--item-panel{background-color:#369763}[data-filepond-item-state*=error] .filepond--item-panel,[data-filepond-item-state*=invalid] .filepond--item-panel{background-color:#c44e47}.filepond--item-panel{border-radius:.5em;transition:background-color .25s}.filepond--list-scroller{position:absolute;top:0;left:0;right:0;margin:0;will-change:transform}.filepond--list-scroller[data-state=overflow]{overflow-y:scroll;overflow-x:hidden;-webkit-overflow-scrolling:touch;-webkit-mask:linear-gradient(180deg,#000 calc(100% - .5em),transparent);mask:linear-gradient(180deg,#000 calc(100% - .5em),transparent)}.filepond--list-scroller[data-state=overflow] .filepond--list{bottom:0;right:0}.filepond--list-scroller::-webkit-scrollbar{background:transparent}.filepond--list-scroller::-webkit-scrollbar:vertical{width:1em}.filepond--list-scroller::-webkit-scrollbar:horizontal{height:0}.filepond--list-scroller::-webkit-scrollbar-thumb{background-color:rgba(0,0,0,.3);border-radius:99999px;border:.3125em solid transparent;background-clip:content-box}.filepond--list.filepond--list{position:absolute;top:0;margin:0;padding:0;list-style-type:none;will-change:transform}.filepond--list{left:.75em;right:.75em}.filepond--root[data-style-panel-layout~=integrated]{width:100%;height:100%;max-width:none;margin:0}.filepond--root[data-style-panel-layout~=circle] .filepond--panel-root,.filepond--root[data-style-panel-layout~=integrated] .filepond--panel-root{border-radius:0}.filepond--root[data-style-panel-layout~=circle] .filepond--panel-root>*,.filepond--root[data-style-panel-layout~=integrated] .filepond--panel-root>*{display:none}.filepond--root[data-style-panel-layout~=circle] .filepond--drop-label,.filepond--root[data-style-panel-layout~=integrated] .filepond--drop-label{bottom:0;height:auto;display:flex;justify-content:center;align-items:center;z-index:7}.filepond--root[data-style-panel-layout~=circle] .filepond--item-panel,.filepond--root[data-style-panel-layout~=integrated] .filepond--item-panel{display:none}.filepond--root[data-style-panel-layout~=compact] .filepond--list-scroller,.filepond--root[data-style-panel-layout~=integrated] .filepond--list-scroller{overflow:hidden;height:100%;margin-top:0;margin-bottom:0}.filepond--root[data-style-panel-layout~=compact] .filepond--list,.filepond--root[data-style-panel-layout~=integrated] .filepond--list{left:0;right:0;height:100%}.filepond--root[data-style-panel-layout~=compact] .filepond--item,.filepond--root[data-style-panel-layout~=integrated] .filepond--item{margin:0}.filepond--root[data-style-panel-layout~=compact] .filepond--file-wrapper,.filepond--root[data-style-panel-layout~=integrated] .filepond--file-wrapper{height:100%}.filepond--root[data-style-panel-layout~=compact] .filepond--drop-label,.filepond--root[data-style-panel-layout~=integrated] .filepond--drop-label{z-index:7}.filepond--root[data-style-panel-layout~=circle]{border-radius:99999rem;overflow:hidden}.filepond--root[data-style-panel-layout~=circle]>.filepond--panel{border-radius:inherit}.filepond--root[data-style-panel-layout~=circle] .filepond--file-info,.filepond--root[data-style-panel-layout~=circle] .filepond--file-status,.filepond--root[data-style-panel-layout~=circle]>.filepond--panel>*{display:none}@media not all and (min-resolution:0.001dpcm){@supports (-webkit-appearance:none) and (stroke-color:transparent){.filepond--root[data-style-panel-layout~=circle]{will-change:transform}}}.filepond--panel-root{border-radius:.5em;background-color:#f1f0ef}.filepond--panel{position:absolute;left:0;top:0;right:0;margin:0;height:100%!important;pointer-events:none}.filepond-panel:not([data-scalable=false]){height:auto!important}.filepond--panel[data-scalable=false]>div{display:none}.filepond--panel[data-scalable=true]{-webkit-transform-style:preserve-3d;transform-style:preserve-3d;background-color:transparent!important;border:none!important}.filepond--panel-bottom,.filepond--panel-center,.filepond--panel-top{position:absolute;left:0;top:0;right:0;margin:0;padding:0}.filepond--panel-bottom,.filepond--panel-top{height:.5em}.filepond--panel-top{border-bottom-left-radius:0!important;border-bottom-right-radius:0!important;border-bottom:none!important}.filepond--panel-top:after{content:\\\"\\\";position:absolute;height:2px;left:0;right:0;bottom:-1px;background-color:inherit}.filepond--panel-bottom,.filepond--panel-center{will-change:transform;-webkit-backface-visibility:hidden;backface-visibility:hidden;-webkit-transform-origin:left top;transform-origin:left top;-webkit-transform:translate3d(0,.5em,0);transform:translate3d(0,.5em,0)}.filepond--panel-bottom{border-top-left-radius:0!important;border-top-right-radius:0!important;border-top:none!important}.filepond--panel-bottom:before{content:\\\"\\\";position:absolute;height:2px;left:0;right:0;top:-1px;background-color:inherit}.filepond--panel-center{height:100px!important;border-top:none!important;border-bottom:none!important;border-radius:0!important}.filepond--panel-center:not([style]){visibility:hidden}.filepond--progress-indicator{position:static;width:1.25em;height:1.25em;color:#fff;margin:0;pointer-events:none;will-change:transform,opacity}.filepond--progress-indicator svg{width:100%;height:100%;vertical-align:top;transform-box:fill-box}.filepond--progress-indicator path{fill:none;stroke:currentColor}.filepond--list-scroller{z-index:6}.filepond--drop-label{z-index:5}.filepond--drip{z-index:3}.filepond--root>.filepond--panel{z-index:2}.filepond--browser{z-index:1}.filepond--root{box-sizing:border-box;position:relative;margin-bottom:1em;font-size:1rem;line-height:normal;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol;font-weight:450;text-align:left;text-rendering:optimizeLegibility;direction:ltr;contain:layout style size}.filepond--root *{box-sizing:inherit;line-height:inherit}.filepond--root :not(text){font-size:inherit}.filepond--root[data-disabled]{pointer-events:none}.filepond--root[data-disabled] .filepond--list-scroller{pointer-events:all}.filepond--root[data-disabled] .filepond--list{pointer-events:none}.filepond--root .filepond--drop-label{min-height:4.75em}.filepond--root .filepond--list-scroller{margin-top:1em;margin-bottom:1em}.filepond--root .filepond--credits{position:absolute;right:0;opacity:.175;line-height:.85;font-size:11px;color:inherit;text-decoration:none;z-index:3;bottom:-14px}.filepond--root .filepond--credits[style]{top:0;bottom:auto;margin-top:14px}\", \"\"]);\n\n// exports\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmlsZXBvbmQvZGlzdC9maWxlcG9uZC5taW4uY3NzPzZlMTAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsMkJBQTJCLG1CQUFPLENBQUMsbUZBQWtDO0FBQ3JFOzs7QUFHQTtBQUNBLGNBQWMsUUFBUyxvTUFBb00sa0JBQWtCLGdCQUFnQixXQUFXLFVBQVUsVUFBVSxTQUFTLDJCQUEyQiw2QkFBNkIscUJBQXFCLG1CQUFtQixxQ0FBcUMsa0JBQWtCLFNBQVMsVUFBVSxTQUFTLFdBQVcsdUJBQXVCLFVBQVUsWUFBWSxnQkFBZ0Isa0JBQWtCLFFBQVEsU0FBUyxVQUFVLFNBQVMsWUFBWSxrQkFBa0Isb0JBQW9CLGVBQWUsZ0JBQWdCLGtCQUFrQixNQUFNLE9BQU8sUUFBUSxTQUFTLGdCQUFnQixXQUFXLG9CQUFvQixtQkFBbUIsMkJBQTJCLHFCQUFxQix1Q0FBdUMsK0JBQStCLFVBQVUsV0FBVyxpQkFBaUIsZ0JBQWdCLG1CQUFtQixrQkFBa0IsMkNBQTJDLGtCQUFrQixNQUFNLE9BQU8sOEJBQThCLHNCQUFzQixRQUFRLFNBQVMsY0FBYyxhQUFhLHVCQUF1QixtQkFBbUIsU0FBUyx5QkFBeUIsc0JBQXNCLHFCQUFxQixpQkFBaUIsaURBQWlELGNBQWMsU0FBUyxhQUFhLDRCQUE0QixlQUFlLGlCQUFpQixnQkFBZ0Isa0JBQWtCLGdCQUFnQix3QkFBd0IsMEJBQTBCLGlDQUFpQyw4QkFBOEIsc0NBQXNDLDhCQUE4QixlQUFlLDJEQUEyRCxXQUFXLDJEQUEyRCxjQUFjLGNBQWMsZUFBZSxvQkFBb0Isb0JBQW9CLFNBQVMsVUFBVSxZQUFZLGFBQWEsOEJBQThCLGdFQUFnRSxrQkFBa0IsZ0JBQWdCLFdBQVcsVUFBVSxVQUFVLFNBQVMsMkJBQTJCLDZCQUE2QixxQkFBcUIsbUJBQW1CLCtEQUErRCxXQUFXLFlBQVksaUVBQWlFLGtCQUFrQixZQUFZLGFBQWEsV0FBVyxjQUFjLGFBQWEsOEJBQThCLFlBQVks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QTZCLDBCQUEwQixxQ0FBcUMsa0JBQWtCLDhCQUE4QixnQkFBZ0IsYUFBYSxjQUFjLFdBQVcsU0FBUyxvQkFBb0IsOEJBQThCLGtDQUFrQyxXQUFXLFlBQVksbUJBQW1CLHVCQUF1QixtQ0FBbUMsVUFBVSxvQkFBb0IseUJBQXlCLFVBQVUsc0JBQXNCLFVBQVUsZ0JBQWdCLFVBQVUsaUNBQWlDLFVBQVUsbUJBQW1CLFVBQVUsZ0JBQWdCLHNCQUFzQixrQkFBa0Isa0JBQWtCLGVBQWUsbUJBQW1CLHlJQUF5SSxnQkFBZ0IsZ0JBQWdCLGtDQUFrQyxjQUFjLDBCQUEwQixrQkFBa0IsbUJBQW1CLG9CQUFvQiwyQkFBMkIsa0JBQWtCLCtCQUErQixvQkFBb0Isd0RBQXdELG1CQUFtQiwrQ0FBK0Msb0JBQW9CLHNDQUFzQyxrQkFBa0IseUNBQXlDLGVBQWUsa0JBQWtCLG1DQUFtQyxrQkFBa0IsUUFBUSxhQUFhLGdCQUFnQixlQUFlLGNBQWMscUJBQXFCLFVBQVUsYUFBYSwwQ0FBMEMsTUFBTSxZQUFZLGdCQUFnQjs7QUFFajJnQiIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzPyEuL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/IS4vbm9kZV9tb2R1bGVzL2ZpbGVwb25kL2Rpc3QvZmlsZXBvbmQubWluLmNzcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKShmYWxzZSk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIvKiFcXG4gKiBGaWxlUG9uZCA0LjIzLjFcXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQsIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUL1xcbiAqIFBsZWFzZSB2aXNpdCBodHRwczovL3BxaW5hLm5sL2ZpbGVwb25kLyBmb3IgZGV0YWlscy5cXG4gKi9cXG5cXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xcbi5maWxlcG9uZC0tYXNzaXN0YW50e3Bvc2l0aW9uOmFic29sdXRlO292ZXJmbG93OmhpZGRlbjtoZWlnaHQ6MXB4O3dpZHRoOjFweDtwYWRkaW5nOjA7Ym9yZGVyOjA7Y2xpcDpyZWN0KDFweCwxcHgsMXB4LDFweCk7LXdlYmtpdC1jbGlwLXBhdGg6aW5zZXQoNTAlKTtjbGlwLXBhdGg6aW5zZXQoNTAlKTt3aGl0ZS1zcGFjZTpub3dyYXB9LmZpbGVwb25kLS1icm93c2VyLmZpbGVwb25kLS1icm93c2Vye3Bvc2l0aW9uOmFic29sdXRlO21hcmdpbjowO3BhZGRpbmc6MDtsZWZ0OjFlbTt0b3A6MS43NWVtO3dpZHRoOmNhbGMoMTAwJSAtIDJlbSk7b3BhY2l0eTowO2ZvbnQtc2l6ZTowfS5maWxlcG9uZC0tZGF0YXtwb3NpdGlvbjphYnNvbHV0ZTt3aWR0aDowO2hlaWdodDowO3BhZGRpbmc6MDttYXJnaW46MDtib3JkZXI6bm9uZTt2aXNpYmlsaXR5OmhpZGRlbjtwb2ludGVyLWV2ZW50czpub25lO2NvbnRhaW46c3RyaWN0fS5maWxlcG9uZC0tZHJpcHtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtsZWZ0OjA7cmlnaHQ6MDtib3R0b206MDtvdmVyZmxvdzpoaWRkZW47b3BhY2l0eTouMTtwb2ludGVyLWV2ZW50czpub25lO2JvcmRlci1yYWRpdXM6LjVlbTtiYWNrZ3JvdW5kOnJnYmEoMCwwLDAsLjAxKX0uZmlsZXBvbmQtLWRyaXAtYmxvYnstd2Via2l0LXRyYW5zZm9ybS1vcmlnaW46Y2VudGVyIGNlbnRlcjt0cmFuc2Zvcm0tb3JpZ2luOmNlbnRlciBjZW50ZXI7d2lkdGg6OGVtO2hlaWdodDo4ZW07bWFyZ2luLWxlZnQ6LTRlbTttYXJnaW4tdG9wOi00ZW07YmFja2dyb3VuZDojMjkyNjI1O2JvcmRlci1yYWRpdXM6NTAlfS5maWxlcG9uZC0tZHJpcC1ibG9iLC5maWxlcG9uZC0tZHJvcC1sYWJlbHtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtsZWZ0OjA7d2lsbC1jaGFuZ2U6dHJhbnNmb3JtLG9wYWNpdHl9LmZpbGVwb25kLS1kcm9wLWxhYmVse3JpZ2h0OjA7bWFyZ2luOjA7Y29sb3I6IzRmNGY0ZjtkaXNwbGF5OmZsZXg7anVzdGlmeS1jb250ZW50OmNlbnRlcjthbGlnbi1pdGVtczpjZW50ZXI7aGVpZ2h0OjA7LXdlYmtpdC11c2VyLXNlbGVjdDpub25lOy1tb3otdXNlci1zZWxlY3Q6bm9uZTstbXMtdXNlci1zZWxlY3Q6bm9uZTt1c2VyLXNlbGVjdDpub25lfS5maWxlcG9uZC0tZHJvcC1sYWJlbC5maWxlcG9uZC0tZHJvcC1sYWJlbCBsYWJlbHtkaXNwbGF5OmJsb2NrO21hcmdpbjowO3BhZGRpbmc6LjVlbX0uZmlsZXBvbmQtLWRyb3AtbGFiZWwgbGFiZWx7Y3Vyc29yOmRlZmF1bHQ7Zm9udC1zaXplOi44NzVlbTtmb250LXdlaWdodDo0MDA7dGV4dC1hbGlnbjpjZW50ZXI7bGluZS1oZWlnaHQ6MS41fS5maWxlcG9uZC0tbGFiZWwtYWN0aW9ue3RleHQtZGVjb3JhdGlvbjp1bmRlcmxpbmU7LXdlYmtpdC10ZXh0LWRlY29yYXRpb24tc2tpcDppbms7dGV4dC1kZWNvcmF0aW9uLXNraXAtaW5rOmF1dG87LXdlYmtpdC10ZXh0LWRlY29yYXRpb24tY29sb3I6I2E3YTRhNDt0ZXh0LWRlY29yYXRpb24tY29sb3I6I2E3YTRhNDtjdXJzb3I6cG9pbnRlcn0uZmlsZXBvbmQtLXJvb3RbZGF0YS1kaXNhYmxlZF0gLmZpbGVwb25kLS1kcm9wLWxhYmVsIGxhYmVse29wYWNpdHk6LjV9LmZpbGVwb25kLS1maWxlLWFjdGlvbi1idXR0b24uZmlsZXBvbmQtLWZpbGUtYWN0aW9uLWJ1dHRvbntmb250LXNpemU6MWVtO3dpZHRoOjEuNjI1ZW07aGVpZ2h0OjEuNjI1ZW07Zm9udC1mYW1pbHk6aW5oZXJpdDtsaW5lLWhlaWdodDppbmhlcml0O21hcmdpbjowO3BhZGRpbmc6MDtib3JkZXI6bm9uZTtvdXRsaW5lOm5vbmU7d2lsbC1jaGFuZ2U6dHJhbnNmb3JtLG9wYWNpdHl9LmZpbGVwb25kLS1maWxlLWFjdGlvbi1idXR0b24uZmlsZXBvbmQtLWZpbGUtYWN0aW9uLWJ1dHRvbiBzcGFue3Bvc2l0aW9uOmFic29sdXRlO292ZXJmbG93OmhpZGRlbjtoZWlnaHQ6MXB4O3dpZHRoOjFweDtwYWRkaW5nOjA7Ym9yZGVyOjA7Y2xpcDpyZWN0KDFweCwxcHgsMXB4LDFweCk7LXdlYmtpdC1jbGlwLXBhdGg6aW5zZXQoNTAlKTtjbGlwLXBhdGg6aW5zZXQoNTAlKTt3aGl0ZS1zcGFjZTpub3dyYXB9LmZpbGVwb25kLS1maWxlLWFjdGlvbi1idXR0b24uZmlsZXBvbmQtLWZpbGUtYWN0aW9uLWJ1dHRvbiBzdmd7d2lkdGg6MTAwJTtoZWlnaHQ6MTAwJX0uZmlsZXBvbmQtLWZpbGUtYWN0aW9uLWJ1dHRvbi5maWxlcG9uZC0tZmlsZS1hY3Rpb24tYnV0dG9uOmFmdGVye3Bvc2l0aW9uOmFic29sdXRlO2xlZnQ6LS43NWVtO3JpZ2h0Oi0uNzVlbTt0b3A6LS43NWVtO2JvdHRvbTotLjc1ZW07Y29udGVudDpcXFwiXFxcIn0uZmlsZXBvbmQtLWZpbGUtYWN0aW9uLWJ1dHRvbntjdXJzb3I6YXV0bztjb2xvcjojZmZmO2JvcmRlci1yYWRpdXM6NTAlO2JhY2tncm91bmQtY29sb3I6cmdiYSgwLDAsMCwuNSk7YmFja2dyb3VuZC1pbWFnZTpub25lO2JveC1zaGFkb3c6MCAwIDAgMCBoc2xhKDAsMCUsMTAwJSwwKTt0cmFuc2l0aW9uOmJveC1zaGFkb3cgLjI1cyBlYXNlLWlufS5maWxlcG9uZC0tZmlsZS1hY3Rpb24tYnV0dG9uOmZvY3VzLC5maWxlcG9uZC0tZmlsZS1hY3Rpb24tYnV0dG9uOmhvdmVye2JveC1zaGFkb3c6MCAwIDAgLjEyNWVtIGhzbGEoMCwwJSwxMDAlLC45KX0uZmlsZXBvbmQtLWZpbGUtYWN0aW9uLWJ1dHRvbltkaXNhYmxlZF17Y29sb3I6aHNsYSgwLDAlLDEwMCUsLjUpO2JhY2tncm91bmQtY29sb3I6cmdiYSgwLDAsMCwuMjUpfS5maWxlcG9uZC0tZmlsZS1hY3Rpb24tYnV0dG9uW2hpZGRlbl17ZGlzcGxheTpub25lfS5maWxlcG9uZC0tZmlsZS1pbmZve3Bvc2l0aW9uOnN0YXRpYztkaXNwbGF5OmZsZXg7ZmxleC1kaXJlY3Rpb246Y29sdW1uO2FsaWduLWl0ZW1zOmZsZXgtc3RhcnQ7ZmxleDoxO21hcmdpbjowIC41ZW0gMCAwO21pbi13aWR0aDowO3dpbGwtY2hhbmdlOnRyYW5zZm9ybSxvcGFjaXR5O3BvaW50ZXItZXZlbnRzOm5vbmU7LXdlYmtpdC11c2VyLXNlbGVjdDpub25lOy1tb3otdXNlci1zZWxlY3Q6bm9uZTstbXMtdXNlci1zZWxlY3Q6bm9uZTt1c2VyLXNlbGVjdDpub25lfS5maWxlcG9uZC0tZmlsZS1pbmZvICp7bWFyZ2luOjB9LmZpbGVwb25kLS1maWxlLWluZm8gLmZpbGVwb25kLS1maWxlLWluZm8tbWFpbntmb250LXNpemU6Ljc1ZW07bGluZS1oZWlnaHQ6MS4yO3RleHQtb3ZlcmZsb3c6ZWxsaXBzaXM7b3ZlcmZsb3c6aGlkZGVuO3doaXRlLXNwYWNlOm5vd3JhcDt3aWR0aDoxMDAlfS5maWxlcG9uZC0tZmlsZS1pbmZvIC5maWxlcG9uZC0tZmlsZS1pbmZvLXN1Yntmb250LXNpemU6LjYyNWVtO29wYWNpdHk6LjU7dHJhbnNpdGlvbjpvcGFjaXR5IC4yNXMgZWFzZS1pbi1vdXQ7d2hpdGUtc3BhY2U6bm93cmFwfS5maWxlcG9uZC0tZmlsZS1pbmZvIC5maWxlcG9uZC0tZmlsZS1pbmZvLXN1YjplbXB0eXtkaXNwbGF5Om5vbmV9LmZpbGVwb25kLS1maWxlLXN0YXR1c3twb3NpdGlvbjpzdGF0aWM7ZGlzcGxheTpmbGV4O2ZsZXgtZGlyZWN0aW9uOmNvbHVtbjthbGlnbi1pdGVtczpmbGV4LWVuZDtmbGV4LWdyb3c6MDtmbGV4LXNocmluazowO21hcmdpbjowO21pbi13aWR0aDoyLjI1ZW07dGV4dC1hbGlnbjpyaWdodDt3aWxsLWNoYW5nZTp0cmFuc2Zvcm0sb3BhY2l0eTtwb2ludGVyLWV2ZW50czpub25lOy13ZWJraXQtdXNlci1zZWxlY3Q6bm9uZTstbW96LXVzZXItc2VsZWN0Om5vbmU7LW1zLXVzZXItc2VsZWN0Om5vbmU7dXNlci1zZWxlY3Q6bm9uZX0uZmlsZXBvbmQtLWZpbGUtc3RhdHVzICp7bWFyZ2luOjA7d2hpdGUtc3BhY2U6bm93cmFwfS5maWxlcG9uZC0tZmlsZS1zdGF0dXMgLmZpbGVwb25kLS1maWxlLXN0YXR1cy1tYWlue2ZvbnQtc2l6ZTouNzVlbTtsaW5lLWhlaWdodDoxLjJ9LmZpbGVwb25kLS1maWxlLXN0YXR1cyAuZmlsZXBvbmQtLWZpbGUtc3RhdHVzLXN1Yntmb250LXNpemU6LjYyNWVtO29wYWNpdHk6LjU7dHJhbnNpdGlvbjpvcGFjaXR5IC4yNXMgZWFzZS1pbi1vdXR9LmZpbGVwb25kLS1maWxlLXdyYXBwZXIuZmlsZXBvbmQtLWZpbGUtd3JhcHBlcntib3JkZXI6bm9uZTttYXJnaW46MDtwYWRkaW5nOjA7bWluLXdpZHRoOjA7aGVpZ2h0OjEwMCV9LmZpbGVwb25kLS1maWxlLXdyYXBwZXIuZmlsZXBvbmQtLWZpbGUtd3JhcHBlcj5sZWdlbmR7cG9zaXRpb246YWJzb2x1dGU7b3ZlcmZsb3c6aGlkZGVuO2hlaWdodDoxcHg7d2lkdGg6MXB4O3BhZGRpbmc6MDtib3JkZXI6MDtjbGlwOnJlY3QoMXB4LDFweCwxcHgsMXB4KTstd2Via2l0LWNsaXAtcGF0aDppbnNldCg1MCUpO2NsaXAtcGF0aDppbnNldCg1MCUpO3doaXRlLXNwYWNlOm5vd3JhcH0uZmlsZXBvbmQtLWZpbGV7cG9zaXRpb246c3RhdGljO2Rpc3BsYXk6ZmxleDtoZWlnaHQ6MTAwJTthbGlnbi1pdGVtczpmbGV4LXN0YXJ0O3BhZGRpbmc6LjU2MjVlbTtjb2xvcjojZmZmO2JvcmRlci1yYWRpdXM6LjVlbX0uZmlsZXBvbmQtLWZpbGUgLmZpbGVwb25kLS1maWxlLXN0YXR1c3ttYXJnaW4tbGVmdDphdXRvO21hcmdpbi1yaWdodDoyLjI1ZW19LmZpbGVwb25kLS1maWxlIC5maWxlcG9uZC0tcHJvY2Vzc2luZy1jb21wbGV0ZS1pbmRpY2F0b3J7cG9pbnRlci1ldmVudHM6bm9uZTstd2Via2l0LXVzZXItc2VsZWN0Om5vbmU7LW1vei11c2VyLXNlbGVjdDpub25lOy1tcy11c2VyLXNlbGVjdDpub25lO3VzZXItc2VsZWN0Om5vbmU7ei1pbmRleDozfS5maWxlcG9uZC0tZmlsZSAuZmlsZXBvbmQtLWZpbGUtYWN0aW9uLWJ1dHRvbiwuZmlsZXBvbmQtLWZpbGUgLmZpbGVwb25kLS1wcm9jZXNzaW5nLWNvbXBsZXRlLWluZGljYXRvciwuZmlsZXBvbmQtLWZpbGUgLmZpbGVwb25kLS1wcm9ncmVzcy1pbmRpY2F0b3J7cG9zaXRpb246YWJzb2x1dGV9LmZpbGVwb25kLS1maWxlIFtkYXRhLWFsaWduKj1sZWZ0XXtsZWZ0Oi41NjI1ZW19LmZpbGVwb25kLS1maWxlIFtkYXRhLWFsaWduKj1yaWdodF17cmlnaHQ6LjU2MjVlbX0uZmlsZXBvbmQtLWZpbGUgW2RhdGEtYWxpZ24qPWNlbnRlcl17bGVmdDpjYWxjKDUwJSAtIC44MTI1ZW0pfS5maWxlcG9uZC0tZmlsZSBbZGF0YS1hbGlnbio9Ym90dG9tXXtib3R0b206MS4xMjVlbX0uZmlsZXBvbmQtLWZpbGUgW2RhdGEtYWxpZ249Y2VudGVyXXt0b3A6Y2FsYyg1MCUgLSAuODEyNWVtKX0uZmlsZXBvbmQtLWZpbGUgLmZpbGVwb25kLS1wcm9ncmVzcy1pbmRpY2F0b3J7bWFyZ2luLXRvcDouMTg3NWVtfS5maWxlcG9uZC0tZmlsZSAuZmlsZXBvbmQtLXByb2dyZXNzLWluZGljYXRvcltkYXRhLWFsaWduKj1yaWdodF17bWFyZ2luLXJpZ2h0Oi4xODc1ZW19LmZpbGVwb25kLS1maWxlIC5maWxlcG9uZC0tcHJvZ3Jlc3MtaW5kaWNhdG9yW2RhdGEtYWxpZ24qPWxlZnRde21hcmdpbi1sZWZ0Oi4xODc1ZW19W2RhdGEtZmlsZXBvbmQtaXRlbS1zdGF0ZSo9ZXJyb3JdIC5maWxlcG9uZC0tZmlsZS1pbmZvLFtkYXRhLWZpbGVwb25kLWl0ZW0tc3RhdGUqPWludmFsaWRdIC5maWxlcG9uZC0tZmlsZS1pbmZvLFtkYXRhLWZpbGVwb25kLWl0ZW0tc3RhdGU9Y2FuY2VsbGVkXSAuZmlsZXBvbmQtLWZpbGUtaW5mb3ttYXJnaW4tcmlnaHQ6Mi4yNWVtfVtkYXRhLWZpbGVwb25kLWl0ZW0tc3RhdGV+PXByb2Nlc3NpbmddIC5maWxlcG9uZC0tZmlsZS1zdGF0dXMtc3Vie29wYWNpdHk6MH1bZGF0YS1maWxlcG9uZC1pdGVtLXN0YXRlfj1wcm9jZXNzaW5nXSAuZmlsZXBvbmQtLWFjdGlvbi1hYm9ydC1pdGVtLXByb2Nlc3Npbmd+LmZpbGVwb25kLS1maWxlLXN0YXR1cyAuZmlsZXBvbmQtLWZpbGUtc3RhdHVzLXN1YntvcGFjaXR5Oi41fVtkYXRhLWZpbGVwb25kLWl0ZW0tc3RhdGU9cHJvY2Vzc2luZy1lcnJvcl0gLmZpbGVwb25kLS1maWxlLXN0YXR1cy1zdWJ7b3BhY2l0eTowfVtkYXRhLWZpbGVwb25kLWl0ZW0tc3RhdGU9cHJvY2Vzc2luZy1lcnJvcl0gLmZpbGVwb25kLS1hY3Rpb24tcmV0cnktaXRlbS1wcm9jZXNzaW5nfi5maWxlcG9uZC0tZmlsZS1zdGF0dXMgLmZpbGVwb25kLS1maWxlLXN0YXR1cy1zdWJ7b3BhY2l0eTouNX1bZGF0YS1maWxlcG9uZC1pdGVtLXN0YXRlPXByb2Nlc3NpbmctY29tcGxldGVdIC5maWxlcG9uZC0tYWN0aW9uLXJldmVydC1pdGVtLXByb2Nlc3Npbmcgc3Zney13ZWJraXQtYW5pbWF0aW9uOmZhbGwgLjVzIGxpbmVhciAuMTI1cyBib3RoO2FuaW1hdGlvbjpmYWxsIC41cyBsaW5lYXIgLjEyNXMgYm90aH1bZGF0YS1maWxlcG9uZC1pdGVtLXN0YXRlPXByb2Nlc3NpbmctY29tcGxldGVdIC5maWxlcG9uZC0tZmlsZS1zdGF0dXMtc3Vie29wYWNpdHk6LjV9W2RhdGEtZmlsZXBvbmQtaXRlbS1zdGF0ZT1wcm9jZXNzaW5nLWNvbXBsZXRlXSAuZmlsZXBvbmQtLWZpbGUtaW5mby1zdWIsW2RhdGEtZmlsZXBvbmQtaXRlbS1zdGF0ZT1wcm9jZXNzaW5nLWNvbXBsZXRlXSAuZmlsZXBvbmQtLXByb2Nlc3NpbmctY29tcGxldGUtaW5kaWNhdG9yOm5vdChbc3R5bGUqPWhpZGRlbl0pfi5maWxlcG9uZC0tZmlsZS1zdGF0dXMgLmZpbGVwb25kLS1maWxlLXN0YXR1cy1zdWJ7b3BhY2l0eTowfVtkYXRhLWZpbGVwb25kLWl0ZW0tc3RhdGU9cHJvY2Vzc2luZy1jb21wbGV0ZV0gLmZpbGVwb25kLS1hY3Rpb24tcmV2ZXJ0LWl0ZW0tcHJvY2Vzc2luZ34uZmlsZXBvbmQtLWZpbGUtaW5mbyAuZmlsZXBvbmQtLWZpbGUtaW5mby1zdWJ7b3BhY2l0eTouNX1bZGF0YS1maWxlcG9uZC1pdGVtLXN0YXRlKj1lcnJvcl0gLmZpbGVwb25kLS1maWxlLXdyYXBwZXIsW2RhdGEtZmlsZXBvbmQtaXRlbS1zdGF0ZSo9ZXJyb3JdIC5maWxlcG9uZC0tcGFuZWwsW2RhdGEtZmlsZXBvbmQtaXRlbS1zdGF0ZSo9aW52YWxpZF0gLmZpbGVwb25kLS1maWxlLXdyYXBwZXIsW2RhdGEtZmlsZXBvbmQtaXRlbS1zdGF0ZSo9aW52YWxpZF0gLmZpbGVwb25kLS1wYW5lbHstd2Via2l0LWFuaW1hdGlvbjpzaGFrZSAuNjVzIGxpbmVhciBib3RoO2FuaW1hdGlvbjpzaGFrZSAuNjVzIGxpbmVhciBib3RofVtkYXRhLWZpbGVwb25kLWl0ZW0tc3RhdGUqPWJ1c3ldIC5maWxlcG9uZC0tcHJvZ3Jlc3MtaW5kaWNhdG9yIHN2Z3std2Via2l0LWFuaW1hdGlvbjpzcGluIDFzIGxpbmVhciBpbmZpbml0ZTthbmltYXRpb246c3BpbiAxcyBsaW5lYXIgaW5maW5pdGV9QC13ZWJraXQta2V5ZnJhbWVzIHNwaW57MCV7LXdlYmtpdC10cmFuc2Zvcm06cm90YXRlKDBkZWcpO3RyYW5zZm9ybTpyb3RhdGUoMGRlZyl9dG97LXdlYmtpdC10cmFuc2Zvcm06cm90YXRlKDF0dXJuKTt0cmFuc2Zvcm06cm90YXRlKDF0dXJuKX19QGtleWZyYW1lcyBzcGluezAley13ZWJraXQtdHJhbnNmb3JtOnJvdGF0ZSgwZGVnKTt0cmFuc2Zvcm06cm90YXRlKDBkZWcpfXRvey13ZWJraXQtdHJhbnNmb3JtOnJvdGF0ZSgxdHVybik7dHJhbnNmb3JtOnJvdGF0ZSgxdHVybil9fUAtd2Via2l0LWtleWZyYW1lcyBzaGFrZXsxMCUsOTAley13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVgoLS4wNjI1ZW0pO3RyYW5zZm9ybTp0cmFuc2xhdGVYKC0uMDYyNWVtKX0yMCUsODAley13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVgoLjEyNWVtKTt0cmFuc2Zvcm06dHJhbnNsYXRlWCguMTI1ZW0pfTMwJSw1MCUsNzAley13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVgoLS4yNWVtKTt0cmFuc2Zvcm06dHJhbnNsYXRlWCgtLjI1ZW0pfTQwJSw2MCV7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWCguMjVlbSk7dHJhbnNmb3JtOnRyYW5zbGF0ZVgoLjI1ZW0pfX1Aa2V5ZnJhbWVzIHNoYWtlezEwJSw5MCV7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWCgtLjA2MjVlbSk7dHJhbnNmb3JtOnRyYW5zbGF0ZVgoLS4wNjI1ZW0pfTIwJSw4MCV7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWCguMTI1ZW0pO3RyYW5zZm9ybTp0cmFuc2xhdGVYKC4xMjVlbSl9MzAlLDUwJSw3MCV7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWCgtLjI1ZW0pO3RyYW5zZm9ybTp0cmFuc2xhdGVYKC0uMjVlbSl9NDAlLDYwJXstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVYKC4yNWVtKTt0cmFuc2Zvcm06dHJhbnNsYXRlWCguMjVlbSl9fUAtd2Via2l0LWtleWZyYW1lcyBmYWxsezAle29wYWNpdHk6MDstd2Via2l0LXRyYW5zZm9ybTpzY2FsZSguNSk7dHJhbnNmb3JtOnNjYWxlKC41KTstd2Via2l0LWFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246ZWFzZS1vdXQ7YW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjplYXNlLW91dH03MCV7b3BhY2l0eToxOy13ZWJraXQtdHJhbnNmb3JtOnNjYWxlKDEuMSk7dHJhbnNmb3JtOnNjYWxlKDEuMSk7LXdlYmtpdC1hbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOmVhc2UtaW4tb3V0O2FuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246ZWFzZS1pbi1vdXR9dG97LXdlYmtpdC10cmFuc2Zvcm06c2NhbGUoMSk7dHJhbnNmb3JtOnNjYWxlKDEpOy13ZWJraXQtYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjplYXNlLW91dDthbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOmVhc2Utb3V0fX1Aa2V5ZnJhbWVzIGZhbGx7MCV7b3BhY2l0eTowOy13ZWJraXQtdHJhbnNmb3JtOnNjYWxlKC41KTt0cmFuc2Zvcm06c2NhbGUoLjUpOy13ZWJraXQtYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjplYXNlLW91dDthbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOmVhc2Utb3V0fTcwJXtvcGFjaXR5OjE7LXdlYmtpdC10cmFuc2Zvcm06c2NhbGUoMS4xKTt0cmFuc2Zvcm06c2NhbGUoMS4xKTstd2Via2l0LWFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246ZWFzZS1pbi1vdXQ7YW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjplYXNlLWluLW91dH10b3std2Via2l0LXRyYW5zZm9ybTpzY2FsZSgxKTt0cmFuc2Zvcm06c2NhbGUoMSk7LXdlYmtpdC1hbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOmVhc2Utb3V0O2FuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246ZWFzZS1vdXR9fS5maWxlcG9uZC0taG9wcGVyW2RhdGEtaG9wcGVyLXN0YXRlPWRyYWctb3Zlcl0+Kntwb2ludGVyLWV2ZW50czpub25lfS5maWxlcG9uZC0taG9wcGVyW2RhdGEtaG9wcGVyLXN0YXRlPWRyYWctb3Zlcl06YWZ0ZXJ7Y29udGVudDpcXFwiXFxcIjtwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0OjA7dG9wOjA7cmlnaHQ6MDtib3R0b206MDt6LWluZGV4OjEwMH0uZmlsZXBvbmQtLXByb2dyZXNzLWluZGljYXRvcnt6LWluZGV4OjEwM30uZmlsZXBvbmQtLWZpbGUtYWN0aW9uLWJ1dHRvbnt6LWluZGV4OjEwMn0uZmlsZXBvbmQtLWZpbGUtc3RhdHVze3otaW5kZXg6MTAxfS5maWxlcG9uZC0tZmlsZS1pbmZve3otaW5kZXg6MTAwfS5maWxlcG9uZC0taXRlbXtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtsZWZ0OjA7cmlnaHQ6MDt6LWluZGV4OjE7cGFkZGluZzowO21hcmdpbjouMjVlbTt3aWxsLWNoYW5nZTp0cmFuc2Zvcm0sb3BhY2l0eX0uZmlsZXBvbmQtLWl0ZW0+LmZpbGVwb25kLS1wYW5lbHt6LWluZGV4Oi0xfS5maWxlcG9uZC0taXRlbT4uZmlsZXBvbmQtLXBhbmVsIC5maWxlcG9uZC0tcGFuZWwtYm90dG9te2JveC1zaGFkb3c6MCAuMDYyNWVtIC4xMjVlbSAtLjA2MjVlbSByZ2JhKDAsMCwwLC4yNSl9LmZpbGVwb25kLS1pdGVtPi5maWxlcG9uZC0tZmlsZS13cmFwcGVyLC5maWxlcG9uZC0taXRlbT4uZmlsZXBvbmQtLXBhbmVse3RyYW5zaXRpb246b3BhY2l0eSAuMTVzIGVhc2Utb3V0fS5maWxlcG9uZC0taXRlbVtkYXRhLWRyYWctc3RhdGVde2N1cnNvcjotd2Via2l0LWdyYWI7Y3Vyc29yOmdyYWJ9LmZpbGVwb25kLS1pdGVtW2RhdGEtZHJhZy1zdGF0ZV0+LmZpbGVwb25kLS1wYW5lbHt0cmFuc2l0aW9uOmJveC1zaGFkb3cgLjEyNXMgZWFzZS1pbi1vdXQ7Ym94LXNoYWRvdzowIDAgMCB0cmFuc3BhcmVudH0uZmlsZXBvbmQtLWl0ZW1bZGF0YS1kcmFnLXN0YXRlPWRyYWdde2N1cnNvcjotd2Via2l0LWdyYWJiaW5nO2N1cnNvcjpncmFiYmluZ30uZmlsZXBvbmQtLWl0ZW1bZGF0YS1kcmFnLXN0YXRlPWRyYWddPi5maWxlcG9uZC0tcGFuZWx7Ym94LXNoYWRvdzowIC4xMjVlbSAuMzEyNWVtIHJnYmEoMCwwLDAsLjMyNSl9LmZpbGVwb25kLS1pdGVtW2RhdGEtZHJhZy1zdGF0ZV06bm90KFtkYXRhLWRyYWctc3RhdGU9aWRsZV0pe3otaW5kZXg6Mn0uZmlsZXBvbmQtLWl0ZW0tcGFuZWx7YmFja2dyb3VuZC1jb2xvcjojNjQ2MDVlfVtkYXRhLWZpbGVwb25kLWl0ZW0tc3RhdGU9cHJvY2Vzc2luZy1jb21wbGV0ZV0gLmZpbGVwb25kLS1pdGVtLXBhbmVse2JhY2tncm91bmQtY29sb3I6IzM2OTc2M31bZGF0YS1maWxlcG9uZC1pdGVtLXN0YXRlKj1lcnJvcl0gLmZpbGVwb25kLS1pdGVtLXBhbmVsLFtkYXRhLWZpbGVwb25kLWl0ZW0tc3RhdGUqPWludmFsaWRdIC5maWxlcG9uZC0taXRlbS1wYW5lbHtiYWNrZ3JvdW5kLWNvbG9yOiNjNDRlNDd9LmZpbGVwb25kLS1pdGVtLXBhbmVse2JvcmRlci1yYWRpdXM6LjVlbTt0cmFuc2l0aW9uOmJhY2tncm91bmQtY29sb3IgLjI1c30uZmlsZXBvbmQtLWxpc3Qtc2Nyb2xsZXJ7cG9zaXRpb246YWJzb2x1dGU7dG9wOjA7bGVmdDowO3JpZ2h0OjA7bWFyZ2luOjA7d2lsbC1jaGFuZ2U6dHJhbnNmb3JtfS5maWxlcG9uZC0tbGlzdC1zY3JvbGxlcltkYXRhLXN0YXRlPW92ZXJmbG93XXtvdmVyZmxvdy15OnNjcm9sbDtvdmVyZmxvdy14OmhpZGRlbjstd2Via2l0LW92ZXJmbG93LXNjcm9sbGluZzp0b3VjaDstd2Via2l0LW1hc2s6bGluZWFyLWdyYWRpZW50KDE4MGRlZywjMDAwIGNhbGMoMTAwJSAtIC41ZW0pLHRyYW5zcGFyZW50KTttYXNrOmxpbmVhci1ncmFkaWVudCgxODBkZWcsIzAwMCBjYWxjKDEwMCUgLSAuNWVtKSx0cmFuc3BhcmVudCl9LmZpbGVwb25kLS1saXN0LXNjcm9sbGVyW2RhdGEtc3RhdGU9b3ZlcmZsb3ddIC5maWxlcG9uZC0tbGlzdHtib3R0b206MDtyaWdodDowfS5maWxlcG9uZC0tbGlzdC1zY3JvbGxlcjo6LXdlYmtpdC1zY3JvbGxiYXJ7YmFja2dyb3VuZDp0cmFuc3BhcmVudH0uZmlsZXBvbmQtLWxpc3Qtc2Nyb2xsZXI6Oi13ZWJraXQtc2Nyb2xsYmFyOnZlcnRpY2Fse3dpZHRoOjFlbX0uZmlsZXBvbmQtLWxpc3Qtc2Nyb2xsZXI6Oi13ZWJraXQtc2Nyb2xsYmFyOmhvcml6b250YWx7aGVpZ2h0OjB9LmZpbGVwb25kLS1saXN0LXNjcm9sbGVyOjotd2Via2l0LXNjcm9sbGJhci10aHVtYntiYWNrZ3JvdW5kLWNvbG9yOnJnYmEoMCwwLDAsLjMpO2JvcmRlci1yYWRpdXM6OTk5OTlweDtib3JkZXI6LjMxMjVlbSBzb2xpZCB0cmFuc3BhcmVudDtiYWNrZ3JvdW5kLWNsaXA6Y29udGVudC1ib3h9LmZpbGVwb25kLS1saXN0LmZpbGVwb25kLS1saXN0e3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO21hcmdpbjowO3BhZGRpbmc6MDtsaXN0LXN0eWxlLXR5cGU6bm9uZTt3aWxsLWNoYW5nZTp0cmFuc2Zvcm19LmZpbGVwb25kLS1saXN0e2xlZnQ6Ljc1ZW07cmlnaHQ6Ljc1ZW19LmZpbGVwb25kLS1yb290W2RhdGEtc3R5bGUtcGFuZWwtbGF5b3V0fj1pbnRlZ3JhdGVkXXt3aWR0aDoxMDAlO2hlaWdodDoxMDAlO21heC13aWR0aDpub25lO21hcmdpbjowfS5maWxlcG9uZC0tcm9vdFtkYXRhLXN0eWxlLXBhbmVsLWxheW91dH49Y2lyY2xlXSAuZmlsZXBvbmQtLXBhbmVsLXJvb3QsLmZpbGVwb25kLS1yb290W2RhdGEtc3R5bGUtcGFuZWwtbGF5b3V0fj1pbnRlZ3JhdGVkXSAuZmlsZXBvbmQtLXBhbmVsLXJvb3R7Ym9yZGVyLXJhZGl1czowfS5maWxlcG9uZC0tcm9vdFtkYXRhLXN0eWxlLXBhbmVsLWxheW91dH49Y2lyY2xlXSAuZmlsZXBvbmQtLXBhbmVsLXJvb3Q+KiwuZmlsZXBvbmQtLXJvb3RbZGF0YS1zdHlsZS1wYW5lbC1sYXlvdXR+PWludGVncmF0ZWRdIC5maWxlcG9uZC0tcGFuZWwtcm9vdD4qe2Rpc3BsYXk6bm9uZX0uZmlsZXBvbmQtLXJvb3RbZGF0YS1zdHlsZS1wYW5lbC1sYXlvdXR+PWNpcmNsZV0gLmZpbGVwb25kLS1kcm9wLWxhYmVsLC5maWxlcG9uZC0tcm9vdFtkYXRhLXN0eWxlLXBhbmVsLWxheW91dH49aW50ZWdyYXRlZF0gLmZpbGVwb25kLS1kcm9wLWxhYmVse2JvdHRvbTowO2hlaWdodDphdXRvO2Rpc3BsYXk6ZmxleDtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO2FsaWduLWl0ZW1zOmNlbnRlcjt6LWluZGV4Ojd9LmZpbGVwb25kLS1yb290W2RhdGEtc3R5bGUtcGFuZWwtbGF5b3V0fj1jaXJjbGVdIC5maWxlcG9uZC0taXRlbS1wYW5lbCwuZmlsZXBvbmQtLXJvb3RbZGF0YS1zdHlsZS1wYW5lbC1sYXlvdXR+PWludGVncmF0ZWRdIC5maWxlcG9uZC0taXRlbS1wYW5lbHtkaXNwbGF5Om5vbmV9LmZpbGVwb25kLS1yb290W2RhdGEtc3R5bGUtcGFuZWwtbGF5b3V0fj1jb21wYWN0XSAuZmlsZXBvbmQtLWxpc3Qtc2Nyb2xsZXIsLmZpbGVwb25kLS1yb290W2RhdGEtc3R5bGUtcGFuZWwtbGF5b3V0fj1pbnRlZ3JhdGVkXSAuZmlsZXBvbmQtLWxpc3Qtc2Nyb2xsZXJ7b3ZlcmZsb3c6aGlkZGVuO2hlaWdodDoxMDAlO21hcmdpbi10b3A6MDttYXJnaW4tYm90dG9tOjB9LmZpbGVwb25kLS1yb290W2RhdGEtc3R5bGUtcGFuZWwtbGF5b3V0fj1jb21wYWN0XSAuZmlsZXBvbmQtLWxpc3QsLmZpbGVwb25kLS1yb290W2RhdGEtc3R5bGUtcGFuZWwtbGF5b3V0fj1pbnRlZ3JhdGVkXSAuZmlsZXBvbmQtLWxpc3R7bGVmdDowO3JpZ2h0OjA7aGVpZ2h0OjEwMCV9LmZpbGVwb25kLS1yb290W2RhdGEtc3R5bGUtcGFuZWwtbGF5b3V0fj1jb21wYWN0XSAuZmlsZXBvbmQtLWl0ZW0sLmZpbGVwb25kLS1yb290W2RhdGEtc3R5bGUtcGFuZWwtbGF5b3V0fj1pbnRlZ3JhdGVkXSAuZmlsZXBvbmQtLWl0ZW17bWFyZ2luOjB9LmZpbGVwb25kLS1yb290W2RhdGEtc3R5bGUtcGFuZWwtbGF5b3V0fj1jb21wYWN0XSAuZmlsZXBvbmQtLWZpbGUtd3JhcHBlciwuZmlsZXBvbmQtLXJvb3RbZGF0YS1zdHlsZS1wYW5lbC1sYXlvdXR+PWludGVncmF0ZWRdIC5maWxlcG9uZC0tZmlsZS13cmFwcGVye2hlaWdodDoxMDAlfS5maWxlcG9uZC0tcm9vdFtkYXRhLXN0eWxlLXBhbmVsLWxheW91dH49Y29tcGFjdF0gLmZpbGVwb25kLS1kcm9wLWxhYmVsLC5maWxlcG9uZC0tcm9vdFtkYXRhLXN0eWxlLXBhbmVsLWxheW91dH49aW50ZWdyYXRlZF0gLmZpbGVwb25kLS1kcm9wLWxhYmVse3otaW5kZXg6N30uZmlsZXBvbmQtLXJvb3RbZGF0YS1zdHlsZS1wYW5lbC1sYXlvdXR+PWNpcmNsZV17Ym9yZGVyLXJhZGl1czo5OTk5OXJlbTtvdmVyZmxvdzpoaWRkZW59LmZpbGVwb25kLS1yb290W2RhdGEtc3R5bGUtcGFuZWwtbGF5b3V0fj1jaXJjbGVdPi5maWxlcG9uZC0tcGFuZWx7Ym9yZGVyLXJhZGl1czppbmhlcml0fS5maWxlcG9uZC0tcm9vdFtkYXRhLXN0eWxlLXBhbmVsLWxheW91dH49Y2lyY2xlXSAuZmlsZXBvbmQtLWZpbGUtaW5mbywuZmlsZXBvbmQtLXJvb3RbZGF0YS1zdHlsZS1wYW5lbC1sYXlvdXR+PWNpcmNsZV0gLmZpbGVwb25kLS1maWxlLXN0YXR1cywuZmlsZXBvbmQtLXJvb3RbZGF0YS1zdHlsZS1wYW5lbC1sYXlvdXR+PWNpcmNsZV0+LmZpbGVwb25kLS1wYW5lbD4qe2Rpc3BsYXk6bm9uZX1AbWVkaWEgbm90IGFsbCBhbmQgKG1pbi1yZXNvbHV0aW9uOjAuMDAxZHBjbSl7QHN1cHBvcnRzICgtd2Via2l0LWFwcGVhcmFuY2U6bm9uZSkgYW5kIChzdHJva2UtY29sb3I6dHJhbnNwYXJlbnQpey5maWxlcG9uZC0tcm9vdFtkYXRhLXN0eWxlLXBhbmVsLWxheW91dH49Y2lyY2xlXXt3aWxsLWNoYW5nZTp0cmFuc2Zvcm19fX0uZmlsZXBvbmQtLXBhbmVsLXJvb3R7Ym9yZGVyLXJhZGl1czouNWVtO2JhY2tncm91bmQtY29sb3I6I2YxZjBlZn0uZmlsZXBvbmQtLXBhbmVse3Bvc2l0aW9uOmFic29sdXRlO2xlZnQ6MDt0b3A6MDtyaWdodDowO21hcmdpbjowO2hlaWdodDoxMDAlIWltcG9ydGFudDtwb2ludGVyLWV2ZW50czpub25lfS5maWxlcG9uZC1wYW5lbDpub3QoW2RhdGEtc2NhbGFibGU9ZmFsc2VdKXtoZWlnaHQ6YXV0byFpbXBvcnRhbnR9LmZpbGVwb25kLS1wYW5lbFtkYXRhLXNjYWxhYmxlPWZhbHNlXT5kaXZ7ZGlzcGxheTpub25lfS5maWxlcG9uZC0tcGFuZWxbZGF0YS1zY2FsYWJsZT10cnVlXXstd2Via2l0LXRyYW5zZm9ybS1zdHlsZTpwcmVzZXJ2ZS0zZDt0cmFuc2Zvcm0tc3R5bGU6cHJlc2VydmUtM2Q7YmFja2dyb3VuZC1jb2xvcjp0cmFuc3BhcmVudCFpbXBvcnRhbnQ7Ym9yZGVyOm5vbmUhaW1wb3J0YW50fS5maWxlcG9uZC0tcGFuZWwtYm90dG9tLC5maWxlcG9uZC0tcGFuZWwtY2VudGVyLC5maWxlcG9uZC0tcGFuZWwtdG9we3Bvc2l0aW9uOmFic29sdXRlO2xlZnQ6MDt0b3A6MDtyaWdodDowO21hcmdpbjowO3BhZGRpbmc6MH0uZmlsZXBvbmQtLXBhbmVsLWJvdHRvbSwuZmlsZXBvbmQtLXBhbmVsLXRvcHtoZWlnaHQ6LjVlbX0uZmlsZXBvbmQtLXBhbmVsLXRvcHtib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOjAhaW1wb3J0YW50O2JvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOjAhaW1wb3J0YW50O2JvcmRlci1ib3R0b206bm9uZSFpbXBvcnRhbnR9LmZpbGVwb25kLS1wYW5lbC10b3A6YWZ0ZXJ7Y29udGVudDpcXFwiXFxcIjtwb3NpdGlvbjphYnNvbHV0ZTtoZWlnaHQ6MnB4O2xlZnQ6MDtyaWdodDowO2JvdHRvbTotMXB4O2JhY2tncm91bmQtY29sb3I6aW5oZXJpdH0uZmlsZXBvbmQtLXBhbmVsLWJvdHRvbSwuZmlsZXBvbmQtLXBhbmVsLWNlbnRlcnt3aWxsLWNoYW5nZTp0cmFuc2Zvcm07LXdlYmtpdC1iYWNrZmFjZS12aXNpYmlsaXR5OmhpZGRlbjtiYWNrZmFjZS12aXNpYmlsaXR5OmhpZGRlbjstd2Via2l0LXRyYW5zZm9ybS1vcmlnaW46bGVmdCB0b3A7dHJhbnNmb3JtLW9yaWdpbjpsZWZ0IHRvcDstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGUzZCgwLC41ZW0sMCk7dHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDAsLjVlbSwwKX0uZmlsZXBvbmQtLXBhbmVsLWJvdHRvbXtib3JkZXItdG9wLWxlZnQtcmFkaXVzOjAhaW1wb3J0YW50O2JvcmRlci10b3AtcmlnaHQtcmFkaXVzOjAhaW1wb3J0YW50O2JvcmRlci10b3A6bm9uZSFpbXBvcnRhbnR9LmZpbGVwb25kLS1wYW5lbC1ib3R0b206YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXCI7cG9zaXRpb246YWJzb2x1dGU7aGVpZ2h0OjJweDtsZWZ0OjA7cmlnaHQ6MDt0b3A6LTFweDtiYWNrZ3JvdW5kLWNvbG9yOmluaGVyaXR9LmZpbGVwb25kLS1wYW5lbC1jZW50ZXJ7aGVpZ2h0OjEwMHB4IWltcG9ydGFudDtib3JkZXItdG9wOm5vbmUhaW1wb3J0YW50O2JvcmRlci1ib3R0b206bm9uZSFpbXBvcnRhbnQ7Ym9yZGVyLXJhZGl1czowIWltcG9ydGFudH0uZmlsZXBvbmQtLXBhbmVsLWNlbnRlcjpub3QoW3N0eWxlXSl7dmlzaWJpbGl0eTpoaWRkZW59LmZpbGVwb25kLS1wcm9ncmVzcy1pbmRpY2F0b3J7cG9zaXRpb246c3RhdGljO3dpZHRoOjEuMjVlbTtoZWlnaHQ6MS4yNWVtO2NvbG9yOiNmZmY7bWFyZ2luOjA7cG9pbnRlci1ldmVudHM6bm9uZTt3aWxsLWNoYW5nZTp0cmFuc2Zvcm0sb3BhY2l0eX0uZmlsZXBvbmQtLXByb2dyZXNzLWluZGljYXRvciBzdmd7d2lkdGg6MTAwJTtoZWlnaHQ6MTAwJTt2ZXJ0aWNhbC1hbGlnbjp0b3A7dHJhbnNmb3JtLWJveDpmaWxsLWJveH0uZmlsZXBvbmQtLXByb2dyZXNzLWluZGljYXRvciBwYXRoe2ZpbGw6bm9uZTtzdHJva2U6Y3VycmVudENvbG9yfS5maWxlcG9uZC0tbGlzdC1zY3JvbGxlcnt6LWluZGV4OjZ9LmZpbGVwb25kLS1kcm9wLWxhYmVse3otaW5kZXg6NX0uZmlsZXBvbmQtLWRyaXB7ei1pbmRleDozfS5maWxlcG9uZC0tcm9vdD4uZmlsZXBvbmQtLXBhbmVse3otaW5kZXg6Mn0uZmlsZXBvbmQtLWJyb3dzZXJ7ei1pbmRleDoxfS5maWxlcG9uZC0tcm9vdHtib3gtc2l6aW5nOmJvcmRlci1ib3g7cG9zaXRpb246cmVsYXRpdmU7bWFyZ2luLWJvdHRvbToxZW07Zm9udC1zaXplOjFyZW07bGluZS1oZWlnaHQ6bm9ybWFsO2ZvbnQtZmFtaWx5Oi1hcHBsZS1zeXN0ZW0sQmxpbmtNYWNTeXN0ZW1Gb250LFNlZ29lIFVJLFJvYm90byxIZWx2ZXRpY2EsQXJpYWwsc2Fucy1zZXJpZixBcHBsZSBDb2xvciBFbW9qaSxTZWdvZSBVSSBFbW9qaSxTZWdvZSBVSSBTeW1ib2w7Zm9udC13ZWlnaHQ6NDUwO3RleHQtYWxpZ246bGVmdDt0ZXh0LXJlbmRlcmluZzpvcHRpbWl6ZUxlZ2liaWxpdHk7ZGlyZWN0aW9uOmx0cjtjb250YWluOmxheW91dCBzdHlsZSBzaXplfS5maWxlcG9uZC0tcm9vdCAqe2JveC1zaXppbmc6aW5oZXJpdDtsaW5lLWhlaWdodDppbmhlcml0fS5maWxlcG9uZC0tcm9vdCA6bm90KHRleHQpe2ZvbnQtc2l6ZTppbmhlcml0fS5maWxlcG9uZC0tcm9vdFtkYXRhLWRpc2FibGVkXXtwb2ludGVyLWV2ZW50czpub25lfS5maWxlcG9uZC0tcm9vdFtkYXRhLWRpc2FibGVkXSAuZmlsZXBvbmQtLWxpc3Qtc2Nyb2xsZXJ7cG9pbnRlci1ldmVudHM6YWxsfS5maWxlcG9uZC0tcm9vdFtkYXRhLWRpc2FibGVkXSAuZmlsZXBvbmQtLWxpc3R7cG9pbnRlci1ldmVudHM6bm9uZX0uZmlsZXBvbmQtLXJvb3QgLmZpbGVwb25kLS1kcm9wLWxhYmVse21pbi1oZWlnaHQ6NC43NWVtfS5maWxlcG9uZC0tcm9vdCAuZmlsZXBvbmQtLWxpc3Qtc2Nyb2xsZXJ7bWFyZ2luLXRvcDoxZW07bWFyZ2luLWJvdHRvbToxZW19LmZpbGVwb25kLS1yb290IC5maWxlcG9uZC0tY3JlZGl0c3twb3NpdGlvbjphYnNvbHV0ZTtyaWdodDowO29wYWNpdHk6LjE3NTtsaW5lLWhlaWdodDouODU7Zm9udC1zaXplOjExcHg7Y29sb3I6aW5oZXJpdDt0ZXh0LWRlY29yYXRpb246bm9uZTt6LWluZGV4OjM7Ym90dG9tOi0xNHB4fS5maWxlcG9uZC0tcm9vdCAuZmlsZXBvbmQtLWNyZWRpdHNbc3R5bGVde3RvcDowO2JvdHRvbTphdXRvO21hcmdpbi10b3A6MTRweH1cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/css-loader/index.js?!./node_modules/postcss-loader/src/index.js?!./node_modules/filepond/dist/filepond.min.css\n");

/***/ }),

/***/ "./node_modules/css-loader/lib/css-base.js":
/*!*************************************************!*\
  !*** ./node_modules/css-loader/lib/css-base.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function(useSourceMap) {\n\tvar list = [];\n\n\t// return the list of modules as css string\n\tlist.toString = function toString() {\n\t\treturn this.map(function (item) {\n\t\t\tvar content = cssWithMappingToString(item, useSourceMap);\n\t\t\tif(item[2]) {\n\t\t\t\treturn \"@media \" + item[2] + \"{\" + content + \"}\";\n\t\t\t} else {\n\t\t\t\treturn content;\n\t\t\t}\n\t\t}).join(\"\");\n\t};\n\n\t// import a list of modules into the list\n\tlist.i = function(modules, mediaQuery) {\n\t\tif(typeof modules === \"string\")\n\t\t\tmodules = [[null, modules, \"\"]];\n\t\tvar alreadyImportedModules = {};\n\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\tvar id = this[i][0];\n\t\t\tif(typeof id === \"number\")\n\t\t\t\talreadyImportedModules[id] = true;\n\t\t}\n\t\tfor(i = 0; i < modules.length; i++) {\n\t\t\tvar item = modules[i];\n\t\t\t// skip already imported module\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\n\t\t\t\tif(mediaQuery && !item[2]) {\n\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t} else if(mediaQuery) {\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\n\t\t\t\t}\n\t\t\t\tlist.push(item);\n\t\t\t}\n\t\t}\n\t};\n\treturn list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n\tvar content = item[1] || '';\n\tvar cssMapping = item[3];\n\tif (!cssMapping) {\n\t\treturn content;\n\t}\n\n\tif (useSourceMap && typeof btoa === 'function') {\n\t\tvar sourceMapping = toComment(cssMapping);\n\t\tvar sourceURLs = cssMapping.sources.map(function (source) {\n\t\t\treturn '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'\n\t\t});\n\n\t\treturn [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n\t}\n\n\treturn [content].join('\\n');\n}\n\n// Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n\t// eslint-disable-next-line no-undef\n\tvar base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n\tvar data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n\n\treturn '/*# ' + data + ' */';\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanM/MjM1MCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGdCQUFnQjtBQUNuRCxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0JBQW9CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxjQUFjOztBQUVsRTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbi8vIGNzcyBiYXNlIGNvZGUsIGluamVjdGVkIGJ5IHRoZSBjc3MtbG9hZGVyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHVzZVNvdXJjZU1hcCkge1xuXHR2YXIgbGlzdCA9IFtdO1xuXG5cdC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcblx0bGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuXHRcdFx0dmFyIGNvbnRlbnQgPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCk7XG5cdFx0XHRpZihpdGVtWzJdKSB7XG5cdFx0XHRcdHJldHVybiBcIkBtZWRpYSBcIiArIGl0ZW1bMl0gKyBcIntcIiArIGNvbnRlbnQgKyBcIn1cIjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiBjb250ZW50O1xuXHRcdFx0fVxuXHRcdH0pLmpvaW4oXCJcIik7XG5cdH07XG5cblx0Ly8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3Rcblx0bGlzdC5pID0gZnVuY3Rpb24obW9kdWxlcywgbWVkaWFRdWVyeSkge1xuXHRcdGlmKHR5cGVvZiBtb2R1bGVzID09PSBcInN0cmluZ1wiKVxuXHRcdFx0bW9kdWxlcyA9IFtbbnVsbCwgbW9kdWxlcywgXCJcIl1dO1xuXHRcdHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpZCA9IHRoaXNbaV1bMF07XG5cdFx0XHRpZih0eXBlb2YgaWQgPT09IFwibnVtYmVyXCIpXG5cdFx0XHRcdGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcblx0XHR9XG5cdFx0Zm9yKGkgPSAwOyBpIDwgbW9kdWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSBtb2R1bGVzW2ldO1xuXHRcdFx0Ly8gc2tpcCBhbHJlYWR5IGltcG9ydGVkIG1vZHVsZVxuXHRcdFx0Ly8gdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBub3QgMTAwJSBwZXJmZWN0IGZvciB3ZWlyZCBtZWRpYSBxdWVyeSBjb21iaW5hdGlvbnNcblx0XHRcdC8vICB3aGVuIGEgbW9kdWxlIGlzIGltcG9ydGVkIG11bHRpcGxlIHRpbWVzIHdpdGggZGlmZmVyZW50IG1lZGlhIHF1ZXJpZXMuXG5cdFx0XHQvLyAgSSBob3BlIHRoaXMgd2lsbCBuZXZlciBvY2N1ciAoSGV5IHRoaXMgd2F5IHdlIGhhdmUgc21hbGxlciBidW5kbGVzKVxuXHRcdFx0aWYodHlwZW9mIGl0ZW1bMF0gIT09IFwibnVtYmVyXCIgfHwgIWFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcblx0XHRcdFx0aWYobWVkaWFRdWVyeSAmJiAhaXRlbVsyXSkge1xuXHRcdFx0XHRcdGl0ZW1bMl0gPSBtZWRpYVF1ZXJ5O1xuXHRcdFx0XHR9IGVsc2UgaWYobWVkaWFRdWVyeSkge1xuXHRcdFx0XHRcdGl0ZW1bMl0gPSBcIihcIiArIGl0ZW1bMl0gKyBcIikgYW5kIChcIiArIG1lZGlhUXVlcnkgKyBcIilcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRsaXN0LnB1c2goaXRlbSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHRyZXR1cm4gbGlzdDtcbn07XG5cbmZ1bmN0aW9uIGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKSB7XG5cdHZhciBjb250ZW50ID0gaXRlbVsxXSB8fCAnJztcblx0dmFyIGNzc01hcHBpbmcgPSBpdGVtWzNdO1xuXHRpZiAoIWNzc01hcHBpbmcpIHtcblx0XHRyZXR1cm4gY29udGVudDtcblx0fVxuXG5cdGlmICh1c2VTb3VyY2VNYXAgJiYgdHlwZW9mIGJ0b2EgPT09ICdmdW5jdGlvbicpIHtcblx0XHR2YXIgc291cmNlTWFwcGluZyA9IHRvQ29tbWVudChjc3NNYXBwaW5nKTtcblx0XHR2YXIgc291cmNlVVJMcyA9IGNzc01hcHBpbmcuc291cmNlcy5tYXAoZnVuY3Rpb24gKHNvdXJjZSkge1xuXHRcdFx0cmV0dXJuICcvKiMgc291cmNlVVJMPScgKyBjc3NNYXBwaW5nLnNvdXJjZVJvb3QgKyBzb3VyY2UgKyAnICovJ1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIFtjb250ZW50XS5jb25jYXQoc291cmNlVVJMcykuY29uY2F0KFtzb3VyY2VNYXBwaW5nXSkuam9pbignXFxuJyk7XG5cdH1cblxuXHRyZXR1cm4gW2NvbnRlbnRdLmpvaW4oJ1xcbicpO1xufVxuXG4vLyBBZGFwdGVkIGZyb20gY29udmVydC1zb3VyY2UtbWFwIChNSVQpXG5mdW5jdGlvbiB0b0NvbW1lbnQoc291cmNlTWFwKSB7XG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuXHR2YXIgYmFzZTY0ID0gYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKTtcblx0dmFyIGRhdGEgPSAnc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsJyArIGJhc2U2NDtcblxuXHRyZXR1cm4gJy8qIyAnICsgZGF0YSArICcgKi8nO1xufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/css-loader/lib/css-base.js\n");

/***/ }),

/***/ "./node_modules/filepond-plugin-file-validate-size/dist/filepond-plugin-file-validate-size.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/filepond-plugin-file-validate-size/dist/filepond-plugin-file-validate-size.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\n * FilePondPluginFileValidateSize 2.2.1\n * Licensed under MIT, https://opensource.org/licenses/MIT/\n * Please visit https://pqina.nl/filepond/ for details.\n */\n\n/* eslint-disable */\n\n(function(global, factory) {\n   true\n    ? (module.exports = factory())\n    : undefined;\n})(this, function() {\n  'use strict';\n\n  var plugin = function plugin(_ref) {\n    var addFilter = _ref.addFilter,\n      utils = _ref.utils;\n    // get quick reference to Type utils\n    var Type = utils.Type,\n      replaceInString = utils.replaceInString,\n      toNaturalFileSize = utils.toNaturalFileSize;\n\n    // filtering if an item is allowed in hopper\n    addFilter('ALLOW_HOPPER_ITEM', function(file, _ref2) {\n      var query = _ref2.query;\n      if (!query('GET_ALLOW_FILE_SIZE_VALIDATION')) {\n        return true;\n      }\n\n      var sizeMax = query('GET_MAX_FILE_SIZE');\n      if (sizeMax !== null && file.size >= sizeMax) {\n        return false;\n      }\n\n      var sizeMin = query('GET_MIN_FILE_SIZE');\n      if (sizeMin !== null && file.size <= sizeMin) {\n        return false;\n      }\n\n      return true;\n    });\n\n    // called for each file that is loaded\n    // right before it is set to the item state\n    // should return a promise\n    addFilter('LOAD_FILE', function(file, _ref3) {\n      var query = _ref3.query;\n      return new Promise(function(resolve, reject) {\n        // if not allowed, all fine, exit\n        if (!query('GET_ALLOW_FILE_SIZE_VALIDATION')) {\n          return resolve(file);\n        }\n\n        // check if file should be filtered\n        var fileFilter = query('GET_FILE_VALIDATE_SIZE_FILTER');\n        if (fileFilter && !fileFilter(file)) {\n          return resolve(file);\n        }\n\n        // reject or resolve based on file size\n        var sizeMax = query('GET_MAX_FILE_SIZE');\n        if (sizeMax !== null && file.size >= sizeMax) {\n          reject({\n            status: {\n              main: query('GET_LABEL_MAX_FILE_SIZE_EXCEEDED'),\n              sub: replaceInString(query('GET_LABEL_MAX_FILE_SIZE'), {\n                filesize: toNaturalFileSize(sizeMax)\n              })\n            }\n          });\n\n          return;\n        }\n\n        // reject or resolve based on file size\n        var sizeMin = query('GET_MIN_FILE_SIZE');\n        if (sizeMin !== null && file.size <= sizeMin) {\n          reject({\n            status: {\n              main: query('GET_LABEL_MIN_FILE_SIZE_EXCEEDED'),\n              sub: replaceInString(query('GET_LABEL_MIN_FILE_SIZE'), {\n                filesize: toNaturalFileSize(sizeMin)\n              })\n            }\n          });\n\n          return;\n        }\n\n        // returns the current option value\n        var totalSizeMax = query('GET_MAX_TOTAL_FILE_SIZE');\n        if (totalSizeMax !== null) {\n          // get the current total file size\n          var currentTotalSize = query('GET_ACTIVE_ITEMS').reduce(function(\n            total,\n            item\n          ) {\n            return total + item.fileSize;\n          },\n          0);\n\n          // get the size of the new file\n          if (currentTotalSize > totalSizeMax) {\n            reject({\n              status: {\n                main: query('GET_LABEL_MAX_TOTAL_FILE_SIZE_EXCEEDED'),\n\n                sub: replaceInString(query('GET_LABEL_MAX_TOTAL_FILE_SIZE'), {\n                  filesize: toNaturalFileSize(totalSizeMax)\n                })\n              }\n            });\n\n            return;\n          }\n        }\n\n        // file is fine, let's pass it back\n        resolve(file);\n      });\n    });\n\n    return {\n      options: {\n        // Enable or disable file type validation\n        allowFileSizeValidation: [true, Type.BOOLEAN],\n\n        // Max individual file size in bytes\n        maxFileSize: [null, Type.INT],\n\n        // Min individual file size in bytes\n        minFileSize: [null, Type.INT],\n\n        // Max total file size in bytes\n        maxTotalFileSize: [null, Type.INT],\n\n        // Filter the files that need to be validated for size\n        fileValidateSizeFilter: [null, Type.FUNCTION],\n\n        // error labels\n        labelMinFileSizeExceeded: ['File is too small', Type.STRING],\n        labelMinFileSize: ['Minimum file size is {filesize}', Type.STRING],\n\n        labelMaxFileSizeExceeded: ['File is too large', Type.STRING],\n        labelMaxFileSize: ['Maximum file size is {filesize}', Type.STRING],\n\n        labelMaxTotalFileSizeExceeded: [\n          'Maximum total size exceeded',\n          Type.STRING\n        ],\n\n        labelMaxTotalFileSize: [\n          'Maximum total file size is {filesize}',\n          Type.STRING\n        ]\n      }\n    };\n  };\n\n  // fire pluginloaded event if running in browser, this allows registering the plugin when using async script tags\n  var isBrowser =\n    typeof window !== 'undefined' && typeof window.document !== 'undefined';\n  if (isBrowser) {\n    document.dispatchEvent(\n      new CustomEvent('FilePond:pluginloaded', { detail: plugin })\n    );\n  }\n\n  return plugin;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmlsZXBvbmQtcGx1Z2luLWZpbGUtdmFsaWRhdGUtc2l6ZS9kaXN0L2ZpbGVwb25kLXBsdWdpbi1maWxlLXZhbGlkYXRlLXNpemUuanM/M2I5NiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsRUFBRSxLQUE0RDtBQUM5RDtBQUNBLE1BQU0sU0FHb0Q7QUFDMUQsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsV0FBVzs7QUFFWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxXQUFXOztBQUVYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrREFBa0QsU0FBUzs7QUFFM0Q7QUFDQSxrREFBa0QsU0FBUzs7QUFFM0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1Q0FBdUMsU0FBUztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsaUJBQWlCO0FBQ2pFO0FBQ0E7O0FBRUE7QUFDQSxDQUFDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2ZpbGVwb25kLXBsdWdpbi1maWxlLXZhbGlkYXRlLXNpemUvZGlzdC9maWxlcG9uZC1wbHVnaW4tZmlsZS12YWxpZGF0ZS1zaXplLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBGaWxlUG9uZFBsdWdpbkZpbGVWYWxpZGF0ZVNpemUgMi4yLjFcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCwgaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQvXG4gKiBQbGVhc2UgdmlzaXQgaHR0cHM6Ly9wcWluYS5ubC9maWxlcG9uZC8gZm9yIGRldGFpbHMuXG4gKi9cblxuLyogZXNsaW50LWRpc2FibGUgKi9cblxuKGZ1bmN0aW9uKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcbiAgICA/IChtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSlcbiAgICA6IHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZFxuICAgID8gZGVmaW5lKGZhY3RvcnkpXG4gICAgOiAoKGdsb2JhbCA9IGdsb2JhbCB8fCBzZWxmKSxcbiAgICAgIChnbG9iYWwuRmlsZVBvbmRQbHVnaW5GaWxlVmFsaWRhdGVTaXplID0gZmFjdG9yeSgpKSk7XG59KSh0aGlzLCBmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBwbHVnaW4gPSBmdW5jdGlvbiBwbHVnaW4oX3JlZikge1xuICAgIHZhciBhZGRGaWx0ZXIgPSBfcmVmLmFkZEZpbHRlcixcbiAgICAgIHV0aWxzID0gX3JlZi51dGlscztcbiAgICAvLyBnZXQgcXVpY2sgcmVmZXJlbmNlIHRvIFR5cGUgdXRpbHNcbiAgICB2YXIgVHlwZSA9IHV0aWxzLlR5cGUsXG4gICAgICByZXBsYWNlSW5TdHJpbmcgPSB1dGlscy5yZXBsYWNlSW5TdHJpbmcsXG4gICAgICB0b05hdHVyYWxGaWxlU2l6ZSA9IHV0aWxzLnRvTmF0dXJhbEZpbGVTaXplO1xuXG4gICAgLy8gZmlsdGVyaW5nIGlmIGFuIGl0ZW0gaXMgYWxsb3dlZCBpbiBob3BwZXJcbiAgICBhZGRGaWx0ZXIoJ0FMTE9XX0hPUFBFUl9JVEVNJywgZnVuY3Rpb24oZmlsZSwgX3JlZjIpIHtcbiAgICAgIHZhciBxdWVyeSA9IF9yZWYyLnF1ZXJ5O1xuICAgICAgaWYgKCFxdWVyeSgnR0VUX0FMTE9XX0ZJTEVfU0laRV9WQUxJREFUSU9OJykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBzaXplTWF4ID0gcXVlcnkoJ0dFVF9NQVhfRklMRV9TSVpFJyk7XG4gICAgICBpZiAoc2l6ZU1heCAhPT0gbnVsbCAmJiBmaWxlLnNpemUgPj0gc2l6ZU1heCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciBzaXplTWluID0gcXVlcnkoJ0dFVF9NSU5fRklMRV9TSVpFJyk7XG4gICAgICBpZiAoc2l6ZU1pbiAhPT0gbnVsbCAmJiBmaWxlLnNpemUgPD0gc2l6ZU1pbikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuXG4gICAgLy8gY2FsbGVkIGZvciBlYWNoIGZpbGUgdGhhdCBpcyBsb2FkZWRcbiAgICAvLyByaWdodCBiZWZvcmUgaXQgaXMgc2V0IHRvIHRoZSBpdGVtIHN0YXRlXG4gICAgLy8gc2hvdWxkIHJldHVybiBhIHByb21pc2VcbiAgICBhZGRGaWx0ZXIoJ0xPQURfRklMRScsIGZ1bmN0aW9uKGZpbGUsIF9yZWYzKSB7XG4gICAgICB2YXIgcXVlcnkgPSBfcmVmMy5xdWVyeTtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgLy8gaWYgbm90IGFsbG93ZWQsIGFsbCBmaW5lLCBleGl0XG4gICAgICAgIGlmICghcXVlcnkoJ0dFVF9BTExPV19GSUxFX1NJWkVfVkFMSURBVElPTicpKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc29sdmUoZmlsZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjaGVjayBpZiBmaWxlIHNob3VsZCBiZSBmaWx0ZXJlZFxuICAgICAgICB2YXIgZmlsZUZpbHRlciA9IHF1ZXJ5KCdHRVRfRklMRV9WQUxJREFURV9TSVpFX0ZJTFRFUicpO1xuICAgICAgICBpZiAoZmlsZUZpbHRlciAmJiAhZmlsZUZpbHRlcihmaWxlKSkge1xuICAgICAgICAgIHJldHVybiByZXNvbHZlKGZpbGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVqZWN0IG9yIHJlc29sdmUgYmFzZWQgb24gZmlsZSBzaXplXG4gICAgICAgIHZhciBzaXplTWF4ID0gcXVlcnkoJ0dFVF9NQVhfRklMRV9TSVpFJyk7XG4gICAgICAgIGlmIChzaXplTWF4ICE9PSBudWxsICYmIGZpbGUuc2l6ZSA+PSBzaXplTWF4KSB7XG4gICAgICAgICAgcmVqZWN0KHtcbiAgICAgICAgICAgIHN0YXR1czoge1xuICAgICAgICAgICAgICBtYWluOiBxdWVyeSgnR0VUX0xBQkVMX01BWF9GSUxFX1NJWkVfRVhDRUVERUQnKSxcbiAgICAgICAgICAgICAgc3ViOiByZXBsYWNlSW5TdHJpbmcocXVlcnkoJ0dFVF9MQUJFTF9NQVhfRklMRV9TSVpFJyksIHtcbiAgICAgICAgICAgICAgICBmaWxlc2l6ZTogdG9OYXR1cmFsRmlsZVNpemUoc2l6ZU1heClcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlamVjdCBvciByZXNvbHZlIGJhc2VkIG9uIGZpbGUgc2l6ZVxuICAgICAgICB2YXIgc2l6ZU1pbiA9IHF1ZXJ5KCdHRVRfTUlOX0ZJTEVfU0laRScpO1xuICAgICAgICBpZiAoc2l6ZU1pbiAhPT0gbnVsbCAmJiBmaWxlLnNpemUgPD0gc2l6ZU1pbikge1xuICAgICAgICAgIHJlamVjdCh7XG4gICAgICAgICAgICBzdGF0dXM6IHtcbiAgICAgICAgICAgICAgbWFpbjogcXVlcnkoJ0dFVF9MQUJFTF9NSU5fRklMRV9TSVpFX0VYQ0VFREVEJyksXG4gICAgICAgICAgICAgIHN1YjogcmVwbGFjZUluU3RyaW5nKHF1ZXJ5KCdHRVRfTEFCRUxfTUlOX0ZJTEVfU0laRScpLCB7XG4gICAgICAgICAgICAgICAgZmlsZXNpemU6IHRvTmF0dXJhbEZpbGVTaXplKHNpemVNaW4pXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXR1cm5zIHRoZSBjdXJyZW50IG9wdGlvbiB2YWx1ZVxuICAgICAgICB2YXIgdG90YWxTaXplTWF4ID0gcXVlcnkoJ0dFVF9NQVhfVE9UQUxfRklMRV9TSVpFJyk7XG4gICAgICAgIGlmICh0b3RhbFNpemVNYXggIT09IG51bGwpIHtcbiAgICAgICAgICAvLyBnZXQgdGhlIGN1cnJlbnQgdG90YWwgZmlsZSBzaXplXG4gICAgICAgICAgdmFyIGN1cnJlbnRUb3RhbFNpemUgPSBxdWVyeSgnR0VUX0FDVElWRV9JVEVNUycpLnJlZHVjZShmdW5jdGlvbihcbiAgICAgICAgICAgIHRvdGFsLFxuICAgICAgICAgICAgaXRlbVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIHRvdGFsICsgaXRlbS5maWxlU2l6ZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIDApO1xuXG4gICAgICAgICAgLy8gZ2V0IHRoZSBzaXplIG9mIHRoZSBuZXcgZmlsZVxuICAgICAgICAgIGlmIChjdXJyZW50VG90YWxTaXplID4gdG90YWxTaXplTWF4KSB7XG4gICAgICAgICAgICByZWplY3Qoe1xuICAgICAgICAgICAgICBzdGF0dXM6IHtcbiAgICAgICAgICAgICAgICBtYWluOiBxdWVyeSgnR0VUX0xBQkVMX01BWF9UT1RBTF9GSUxFX1NJWkVfRVhDRUVERUQnKSxcblxuICAgICAgICAgICAgICAgIHN1YjogcmVwbGFjZUluU3RyaW5nKHF1ZXJ5KCdHRVRfTEFCRUxfTUFYX1RPVEFMX0ZJTEVfU0laRScpLCB7XG4gICAgICAgICAgICAgICAgICBmaWxlc2l6ZTogdG9OYXR1cmFsRmlsZVNpemUodG90YWxTaXplTWF4KVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmlsZSBpcyBmaW5lLCBsZXQncyBwYXNzIGl0IGJhY2tcbiAgICAgICAgcmVzb2x2ZShmaWxlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgLy8gRW5hYmxlIG9yIGRpc2FibGUgZmlsZSB0eXBlIHZhbGlkYXRpb25cbiAgICAgICAgYWxsb3dGaWxlU2l6ZVZhbGlkYXRpb246IFt0cnVlLCBUeXBlLkJPT0xFQU5dLFxuXG4gICAgICAgIC8vIE1heCBpbmRpdmlkdWFsIGZpbGUgc2l6ZSBpbiBieXRlc1xuICAgICAgICBtYXhGaWxlU2l6ZTogW251bGwsIFR5cGUuSU5UXSxcblxuICAgICAgICAvLyBNaW4gaW5kaXZpZHVhbCBmaWxlIHNpemUgaW4gYnl0ZXNcbiAgICAgICAgbWluRmlsZVNpemU6IFtudWxsLCBUeXBlLklOVF0sXG5cbiAgICAgICAgLy8gTWF4IHRvdGFsIGZpbGUgc2l6ZSBpbiBieXRlc1xuICAgICAgICBtYXhUb3RhbEZpbGVTaXplOiBbbnVsbCwgVHlwZS5JTlRdLFxuXG4gICAgICAgIC8vIEZpbHRlciB0aGUgZmlsZXMgdGhhdCBuZWVkIHRvIGJlIHZhbGlkYXRlZCBmb3Igc2l6ZVxuICAgICAgICBmaWxlVmFsaWRhdGVTaXplRmlsdGVyOiBbbnVsbCwgVHlwZS5GVU5DVElPTl0sXG5cbiAgICAgICAgLy8gZXJyb3IgbGFiZWxzXG4gICAgICAgIGxhYmVsTWluRmlsZVNpemVFeGNlZWRlZDogWydGaWxlIGlzIHRvbyBzbWFsbCcsIFR5cGUuU1RSSU5HXSxcbiAgICAgICAgbGFiZWxNaW5GaWxlU2l6ZTogWydNaW5pbXVtIGZpbGUgc2l6ZSBpcyB7ZmlsZXNpemV9JywgVHlwZS5TVFJJTkddLFxuXG4gICAgICAgIGxhYmVsTWF4RmlsZVNpemVFeGNlZWRlZDogWydGaWxlIGlzIHRvbyBsYXJnZScsIFR5cGUuU1RSSU5HXSxcbiAgICAgICAgbGFiZWxNYXhGaWxlU2l6ZTogWydNYXhpbXVtIGZpbGUgc2l6ZSBpcyB7ZmlsZXNpemV9JywgVHlwZS5TVFJJTkddLFxuXG4gICAgICAgIGxhYmVsTWF4VG90YWxGaWxlU2l6ZUV4Y2VlZGVkOiBbXG4gICAgICAgICAgJ01heGltdW0gdG90YWwgc2l6ZSBleGNlZWRlZCcsXG4gICAgICAgICAgVHlwZS5TVFJJTkdcbiAgICAgICAgXSxcblxuICAgICAgICBsYWJlbE1heFRvdGFsRmlsZVNpemU6IFtcbiAgICAgICAgICAnTWF4aW11bSB0b3RhbCBmaWxlIHNpemUgaXMge2ZpbGVzaXplfScsXG4gICAgICAgICAgVHlwZS5TVFJJTkdcbiAgICAgICAgXVxuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgLy8gZmlyZSBwbHVnaW5sb2FkZWQgZXZlbnQgaWYgcnVubmluZyBpbiBicm93c2VyLCB0aGlzIGFsbG93cyByZWdpc3RlcmluZyB0aGUgcGx1Z2luIHdoZW4gdXNpbmcgYXN5bmMgc2NyaXB0IHRhZ3NcbiAgdmFyIGlzQnJvd3NlciA9XG4gICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCc7XG4gIGlmIChpc0Jyb3dzZXIpIHtcbiAgICBkb2N1bWVudC5kaXNwYXRjaEV2ZW50KFxuICAgICAgbmV3IEN1c3RvbUV2ZW50KCdGaWxlUG9uZDpwbHVnaW5sb2FkZWQnLCB7IGRldGFpbDogcGx1Z2luIH0pXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiBwbHVnaW47XG59KTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/filepond-plugin-file-validate-size/dist/filepond-plugin-file-validate-size.js\n");

/***/ }),

/***/ "./node_modules/filepond-plugin-file-validate-type/dist/filepond-plugin-file-validate-type.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/filepond-plugin-file-validate-type/dist/filepond-plugin-file-validate-type.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\n * FilePondPluginFileValidateType 1.2.5\n * Licensed under MIT, https://opensource.org/licenses/MIT/\n * Please visit https://pqina.nl/filepond/ for details.\n */\n\n/* eslint-disable */\n\n(function(global, factory) {\n   true\n    ? (module.exports = factory())\n    : undefined;\n})(this, function() {\n  'use strict';\n\n  var plugin = function plugin(_ref) {\n    var addFilter = _ref.addFilter,\n      utils = _ref.utils;\n    // get quick reference to Type utils\n    var Type = utils.Type,\n      isString = utils.isString,\n      replaceInString = utils.replaceInString,\n      guesstimateMimeType = utils.guesstimateMimeType,\n      getExtensionFromFilename = utils.getExtensionFromFilename,\n      getFilenameFromURL = utils.getFilenameFromURL;\n\n    var mimeTypeMatchesWildCard = function mimeTypeMatchesWildCard(\n      mimeType,\n      wildcard\n    ) {\n      var mimeTypeGroup = (/^[^/]+/.exec(mimeType) || []).pop(); // image/png -> image\n      var wildcardGroup = wildcard.slice(0, -2); // image/* -> image\n      return mimeTypeGroup === wildcardGroup;\n    };\n\n    var isValidMimeType = function isValidMimeType(\n      acceptedTypes,\n      userInputType\n    ) {\n      return acceptedTypes.some(function(acceptedType) {\n        // accepted is wildcard mime type\n        if (/\\*$/.test(acceptedType)) {\n          return mimeTypeMatchesWildCard(userInputType, acceptedType);\n        }\n\n        // is normal mime type\n        return acceptedType === userInputType;\n      });\n    };\n\n    var getItemType = function getItemType(item) {\n      // if the item is a url we guess the mime type by the extension\n      var type = '';\n      if (isString(item)) {\n        var filename = getFilenameFromURL(item);\n        var extension = getExtensionFromFilename(filename);\n        if (extension) {\n          type = guesstimateMimeType(extension);\n        }\n      } else {\n        type = item.type;\n      }\n\n      return type;\n    };\n\n    var validateFile = function validateFile(\n      item,\n      acceptedFileTypes,\n      typeDetector\n    ) {\n      // no types defined, everything is allowed \\o/\n      if (acceptedFileTypes.length === 0) {\n        return true;\n      }\n\n      // gets the item type\n      var type = getItemType(item);\n\n      // no type detector, test now\n      if (!typeDetector) {\n        return isValidMimeType(acceptedFileTypes, type);\n      }\n\n      // use type detector\n      return new Promise(function(resolve, reject) {\n        typeDetector(item, type)\n          .then(function(detectedType) {\n            if (isValidMimeType(acceptedFileTypes, detectedType)) {\n              resolve();\n            } else {\n              reject();\n            }\n          })\n          .catch(reject);\n      });\n    };\n\n    var applyMimeTypeMap = function applyMimeTypeMap(map) {\n      return function(acceptedFileType) {\n        return map[acceptedFileType] === null\n          ? false\n          : map[acceptedFileType] || acceptedFileType;\n      };\n    };\n\n    // setup attribute mapping for accept\n    addFilter('SET_ATTRIBUTE_TO_OPTION_MAP', function(map) {\n      return Object.assign(map, {\n        accept: 'acceptedFileTypes'\n      });\n    });\n\n    // filtering if an item is allowed in hopper\n    addFilter('ALLOW_HOPPER_ITEM', function(file, _ref2) {\n      var query = _ref2.query;\n      // if we are not doing file type validation exit\n      if (!query('GET_ALLOW_FILE_TYPE_VALIDATION')) {\n        return true;\n      }\n\n      // we validate the file against the accepted file types\n      return validateFile(file, query('GET_ACCEPTED_FILE_TYPES'));\n    });\n\n    // called for each file that is loaded\n    // right before it is set to the item state\n    // should return a promise\n    addFilter('LOAD_FILE', function(file, _ref3) {\n      var query = _ref3.query;\n      return new Promise(function(resolve, reject) {\n        if (!query('GET_ALLOW_FILE_TYPE_VALIDATION')) {\n          resolve(file);\n          return;\n        }\n\n        var acceptedFileTypes = query('GET_ACCEPTED_FILE_TYPES');\n\n        // custom type detector method\n        var typeDetector = query('GET_FILE_VALIDATE_TYPE_DETECT_TYPE');\n\n        // if invalid, exit here\n        var validationResult = validateFile(\n          file,\n          acceptedFileTypes,\n          typeDetector\n        );\n\n        var handleRejection = function handleRejection() {\n          var acceptedFileTypesMapped = acceptedFileTypes\n            .map(\n              applyMimeTypeMap(\n                query('GET_FILE_VALIDATE_TYPE_LABEL_EXPECTED_TYPES_MAP')\n              )\n            )\n            .filter(function(label) {\n              return label !== false;\n            });\n\n          reject({\n            status: {\n              main: query('GET_LABEL_FILE_TYPE_NOT_ALLOWED'),\n              sub: replaceInString(\n                query('GET_FILE_VALIDATE_TYPE_LABEL_EXPECTED_TYPES'),\n                {\n                  allTypes: acceptedFileTypesMapped.join(', '),\n                  allButLastType: acceptedFileTypesMapped\n                    .slice(0, -1)\n                    .join(', '),\n                  lastType:\n                    acceptedFileTypesMapped[acceptedFileTypesMapped.length - 1]\n                }\n              )\n            }\n          });\n        };\n\n        // has returned new filename immidiately\n        if (typeof validationResult === 'boolean') {\n          if (!validationResult) {\n            return handleRejection();\n          }\n          return resolve(file);\n        }\n\n        // is promise\n        validationResult\n          .then(function() {\n            resolve(file);\n          })\n          .catch(handleRejection);\n      });\n    });\n\n    // expose plugin\n    return {\n      // default options\n      options: {\n        // Enable or disable file type validation\n        allowFileTypeValidation: [true, Type.BOOLEAN],\n\n        // What file types to accept\n        acceptedFileTypes: [[], Type.ARRAY],\n        // - must be comma separated\n        // - mime types: image/png, image/jpeg, image/gif\n        // - extensions: .png, .jpg, .jpeg ( not enabled yet )\n        // - wildcards: image/*\n\n        // label to show when a type is not allowed\n        labelFileTypeNotAllowed: ['File is of invalid type', Type.STRING],\n\n        // nicer label\n        fileValidateTypeLabelExpectedTypes: [\n          'Expects {allButLastType} or {lastType}',\n          Type.STRING\n        ],\n\n        // map mime types to extensions\n        fileValidateTypeLabelExpectedTypesMap: [{}, Type.OBJECT],\n\n        // Custom function to detect type of file\n        fileValidateTypeDetectType: [null, Type.FUNCTION]\n      }\n    };\n  };\n\n  // fire pluginloaded event if running in browser, this allows registering the plugin when using async script tags\n  var isBrowser =\n    typeof window !== 'undefined' && typeof window.document !== 'undefined';\n  if (isBrowser) {\n    document.dispatchEvent(\n      new CustomEvent('FilePond:pluginloaded', { detail: plugin })\n    );\n  }\n\n  return plugin;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmlsZXBvbmQtcGx1Z2luLWZpbGUtdmFsaWRhdGUtdHlwZS9kaXN0L2ZpbGVwb25kLXBsdWdpbi1maWxlLXZhbGlkYXRlLXR5cGUuanM/MTk0MiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsRUFBRSxLQUE0RDtBQUM5RDtBQUNBLE1BQU0sU0FHb0Q7QUFDMUQsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFLGdEQUFnRDtBQUNoRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLGVBQWUsS0FBSyxTQUFTO0FBQ2pEO0FBQ0E7O0FBRUE7QUFDQSxrREFBa0Q7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxpQkFBaUI7QUFDakU7QUFDQTs7QUFFQTtBQUNBLENBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmlsZXBvbmQtcGx1Z2luLWZpbGUtdmFsaWRhdGUtdHlwZS9kaXN0L2ZpbGVwb25kLXBsdWdpbi1maWxlLXZhbGlkYXRlLXR5cGUuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIEZpbGVQb25kUGx1Z2luRmlsZVZhbGlkYXRlVHlwZSAxLjIuNVxuICogTGljZW5zZWQgdW5kZXIgTUlULCBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC9cbiAqIFBsZWFzZSB2aXNpdCBodHRwczovL3BxaW5hLm5sL2ZpbGVwb25kLyBmb3IgZGV0YWlscy5cbiAqL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuXG4oZnVuY3Rpb24oZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xuICAgID8gKG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpKVxuICAgIDogdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kXG4gICAgPyBkZWZpbmUoZmFjdG9yeSlcbiAgICA6ICgoZ2xvYmFsID0gZ2xvYmFsIHx8IHNlbGYpLFxuICAgICAgKGdsb2JhbC5GaWxlUG9uZFBsdWdpbkZpbGVWYWxpZGF0ZVR5cGUgPSBmYWN0b3J5KCkpKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIHBsdWdpbiA9IGZ1bmN0aW9uIHBsdWdpbihfcmVmKSB7XG4gICAgdmFyIGFkZEZpbHRlciA9IF9yZWYuYWRkRmlsdGVyLFxuICAgICAgdXRpbHMgPSBfcmVmLnV0aWxzO1xuICAgIC8vIGdldCBxdWljayByZWZlcmVuY2UgdG8gVHlwZSB1dGlsc1xuICAgIHZhciBUeXBlID0gdXRpbHMuVHlwZSxcbiAgICAgIGlzU3RyaW5nID0gdXRpbHMuaXNTdHJpbmcsXG4gICAgICByZXBsYWNlSW5TdHJpbmcgPSB1dGlscy5yZXBsYWNlSW5TdHJpbmcsXG4gICAgICBndWVzc3RpbWF0ZU1pbWVUeXBlID0gdXRpbHMuZ3Vlc3N0aW1hdGVNaW1lVHlwZSxcbiAgICAgIGdldEV4dGVuc2lvbkZyb21GaWxlbmFtZSA9IHV0aWxzLmdldEV4dGVuc2lvbkZyb21GaWxlbmFtZSxcbiAgICAgIGdldEZpbGVuYW1lRnJvbVVSTCA9IHV0aWxzLmdldEZpbGVuYW1lRnJvbVVSTDtcblxuICAgIHZhciBtaW1lVHlwZU1hdGNoZXNXaWxkQ2FyZCA9IGZ1bmN0aW9uIG1pbWVUeXBlTWF0Y2hlc1dpbGRDYXJkKFxuICAgICAgbWltZVR5cGUsXG4gICAgICB3aWxkY2FyZFxuICAgICkge1xuICAgICAgdmFyIG1pbWVUeXBlR3JvdXAgPSAoL15bXi9dKy8uZXhlYyhtaW1lVHlwZSkgfHwgW10pLnBvcCgpOyAvLyBpbWFnZS9wbmcgLT4gaW1hZ2VcbiAgICAgIHZhciB3aWxkY2FyZEdyb3VwID0gd2lsZGNhcmQuc2xpY2UoMCwgLTIpOyAvLyBpbWFnZS8qIC0+IGltYWdlXG4gICAgICByZXR1cm4gbWltZVR5cGVHcm91cCA9PT0gd2lsZGNhcmRHcm91cDtcbiAgICB9O1xuXG4gICAgdmFyIGlzVmFsaWRNaW1lVHlwZSA9IGZ1bmN0aW9uIGlzVmFsaWRNaW1lVHlwZShcbiAgICAgIGFjY2VwdGVkVHlwZXMsXG4gICAgICB1c2VySW5wdXRUeXBlXG4gICAgKSB7XG4gICAgICByZXR1cm4gYWNjZXB0ZWRUeXBlcy5zb21lKGZ1bmN0aW9uKGFjY2VwdGVkVHlwZSkge1xuICAgICAgICAvLyBhY2NlcHRlZCBpcyB3aWxkY2FyZCBtaW1lIHR5cGVcbiAgICAgICAgaWYgKC9cXCokLy50ZXN0KGFjY2VwdGVkVHlwZSkpIHtcbiAgICAgICAgICByZXR1cm4gbWltZVR5cGVNYXRjaGVzV2lsZENhcmQodXNlcklucHV0VHlwZSwgYWNjZXB0ZWRUeXBlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlzIG5vcm1hbCBtaW1lIHR5cGVcbiAgICAgICAgcmV0dXJuIGFjY2VwdGVkVHlwZSA9PT0gdXNlcklucHV0VHlwZTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICB2YXIgZ2V0SXRlbVR5cGUgPSBmdW5jdGlvbiBnZXRJdGVtVHlwZShpdGVtKSB7XG4gICAgICAvLyBpZiB0aGUgaXRlbSBpcyBhIHVybCB3ZSBndWVzcyB0aGUgbWltZSB0eXBlIGJ5IHRoZSBleHRlbnNpb25cbiAgICAgIHZhciB0eXBlID0gJyc7XG4gICAgICBpZiAoaXNTdHJpbmcoaXRlbSkpIHtcbiAgICAgICAgdmFyIGZpbGVuYW1lID0gZ2V0RmlsZW5hbWVGcm9tVVJMKGl0ZW0pO1xuICAgICAgICB2YXIgZXh0ZW5zaW9uID0gZ2V0RXh0ZW5zaW9uRnJvbUZpbGVuYW1lKGZpbGVuYW1lKTtcbiAgICAgICAgaWYgKGV4dGVuc2lvbikge1xuICAgICAgICAgIHR5cGUgPSBndWVzc3RpbWF0ZU1pbWVUeXBlKGV4dGVuc2lvbik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHR5cGUgPSBpdGVtLnR5cGU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0eXBlO1xuICAgIH07XG5cbiAgICB2YXIgdmFsaWRhdGVGaWxlID0gZnVuY3Rpb24gdmFsaWRhdGVGaWxlKFxuICAgICAgaXRlbSxcbiAgICAgIGFjY2VwdGVkRmlsZVR5cGVzLFxuICAgICAgdHlwZURldGVjdG9yXG4gICAgKSB7XG4gICAgICAvLyBubyB0eXBlcyBkZWZpbmVkLCBldmVyeXRoaW5nIGlzIGFsbG93ZWQgXFxvL1xuICAgICAgaWYgKGFjY2VwdGVkRmlsZVR5cGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gZ2V0cyB0aGUgaXRlbSB0eXBlXG4gICAgICB2YXIgdHlwZSA9IGdldEl0ZW1UeXBlKGl0ZW0pO1xuXG4gICAgICAvLyBubyB0eXBlIGRldGVjdG9yLCB0ZXN0IG5vd1xuICAgICAgaWYgKCF0eXBlRGV0ZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIGlzVmFsaWRNaW1lVHlwZShhY2NlcHRlZEZpbGVUeXBlcywgdHlwZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIHVzZSB0eXBlIGRldGVjdG9yXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHR5cGVEZXRlY3RvcihpdGVtLCB0eXBlKVxuICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKGRldGVjdGVkVHlwZSkge1xuICAgICAgICAgICAgaWYgKGlzVmFsaWRNaW1lVHlwZShhY2NlcHRlZEZpbGVUeXBlcywgZGV0ZWN0ZWRUeXBlKSkge1xuICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZWplY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICAgIC5jYXRjaChyZWplY3QpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHZhciBhcHBseU1pbWVUeXBlTWFwID0gZnVuY3Rpb24gYXBwbHlNaW1lVHlwZU1hcChtYXApIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihhY2NlcHRlZEZpbGVUeXBlKSB7XG4gICAgICAgIHJldHVybiBtYXBbYWNjZXB0ZWRGaWxlVHlwZV0gPT09IG51bGxcbiAgICAgICAgICA/IGZhbHNlXG4gICAgICAgICAgOiBtYXBbYWNjZXB0ZWRGaWxlVHlwZV0gfHwgYWNjZXB0ZWRGaWxlVHlwZTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIC8vIHNldHVwIGF0dHJpYnV0ZSBtYXBwaW5nIGZvciBhY2NlcHRcbiAgICBhZGRGaWx0ZXIoJ1NFVF9BVFRSSUJVVEVfVE9fT1BUSU9OX01BUCcsIGZ1bmN0aW9uKG1hcCkge1xuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obWFwLCB7XG4gICAgICAgIGFjY2VwdDogJ2FjY2VwdGVkRmlsZVR5cGVzJ1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvLyBmaWx0ZXJpbmcgaWYgYW4gaXRlbSBpcyBhbGxvd2VkIGluIGhvcHBlclxuICAgIGFkZEZpbHRlcignQUxMT1dfSE9QUEVSX0lURU0nLCBmdW5jdGlvbihmaWxlLCBfcmVmMikge1xuICAgICAgdmFyIHF1ZXJ5ID0gX3JlZjIucXVlcnk7XG4gICAgICAvLyBpZiB3ZSBhcmUgbm90IGRvaW5nIGZpbGUgdHlwZSB2YWxpZGF0aW9uIGV4aXRcbiAgICAgIGlmICghcXVlcnkoJ0dFVF9BTExPV19GSUxFX1RZUEVfVkFMSURBVElPTicpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyB3ZSB2YWxpZGF0ZSB0aGUgZmlsZSBhZ2FpbnN0IHRoZSBhY2NlcHRlZCBmaWxlIHR5cGVzXG4gICAgICByZXR1cm4gdmFsaWRhdGVGaWxlKGZpbGUsIHF1ZXJ5KCdHRVRfQUNDRVBURURfRklMRV9UWVBFUycpKTtcbiAgICB9KTtcblxuICAgIC8vIGNhbGxlZCBmb3IgZWFjaCBmaWxlIHRoYXQgaXMgbG9hZGVkXG4gICAgLy8gcmlnaHQgYmVmb3JlIGl0IGlzIHNldCB0byB0aGUgaXRlbSBzdGF0ZVxuICAgIC8vIHNob3VsZCByZXR1cm4gYSBwcm9taXNlXG4gICAgYWRkRmlsdGVyKCdMT0FEX0ZJTEUnLCBmdW5jdGlvbihmaWxlLCBfcmVmMykge1xuICAgICAgdmFyIHF1ZXJ5ID0gX3JlZjMucXVlcnk7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGlmICghcXVlcnkoJ0dFVF9BTExPV19GSUxFX1RZUEVfVkFMSURBVElPTicpKSB7XG4gICAgICAgICAgcmVzb2x2ZShmaWxlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYWNjZXB0ZWRGaWxlVHlwZXMgPSBxdWVyeSgnR0VUX0FDQ0VQVEVEX0ZJTEVfVFlQRVMnKTtcblxuICAgICAgICAvLyBjdXN0b20gdHlwZSBkZXRlY3RvciBtZXRob2RcbiAgICAgICAgdmFyIHR5cGVEZXRlY3RvciA9IHF1ZXJ5KCdHRVRfRklMRV9WQUxJREFURV9UWVBFX0RFVEVDVF9UWVBFJyk7XG5cbiAgICAgICAgLy8gaWYgaW52YWxpZCwgZXhpdCBoZXJlXG4gICAgICAgIHZhciB2YWxpZGF0aW9uUmVzdWx0ID0gdmFsaWRhdGVGaWxlKFxuICAgICAgICAgIGZpbGUsXG4gICAgICAgICAgYWNjZXB0ZWRGaWxlVHlwZXMsXG4gICAgICAgICAgdHlwZURldGVjdG9yXG4gICAgICAgICk7XG5cbiAgICAgICAgdmFyIGhhbmRsZVJlamVjdGlvbiA9IGZ1bmN0aW9uIGhhbmRsZVJlamVjdGlvbigpIHtcbiAgICAgICAgICB2YXIgYWNjZXB0ZWRGaWxlVHlwZXNNYXBwZWQgPSBhY2NlcHRlZEZpbGVUeXBlc1xuICAgICAgICAgICAgLm1hcChcbiAgICAgICAgICAgICAgYXBwbHlNaW1lVHlwZU1hcChcbiAgICAgICAgICAgICAgICBxdWVyeSgnR0VUX0ZJTEVfVkFMSURBVEVfVFlQRV9MQUJFTF9FWFBFQ1RFRF9UWVBFU19NQVAnKVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKGxhYmVsKSB7XG4gICAgICAgICAgICAgIHJldHVybiBsYWJlbCAhPT0gZmFsc2U7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIHJlamVjdCh7XG4gICAgICAgICAgICBzdGF0dXM6IHtcbiAgICAgICAgICAgICAgbWFpbjogcXVlcnkoJ0dFVF9MQUJFTF9GSUxFX1RZUEVfTk9UX0FMTE9XRUQnKSxcbiAgICAgICAgICAgICAgc3ViOiByZXBsYWNlSW5TdHJpbmcoXG4gICAgICAgICAgICAgICAgcXVlcnkoJ0dFVF9GSUxFX1ZBTElEQVRFX1RZUEVfTEFCRUxfRVhQRUNURURfVFlQRVMnKSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBhbGxUeXBlczogYWNjZXB0ZWRGaWxlVHlwZXNNYXBwZWQuam9pbignLCAnKSxcbiAgICAgICAgICAgICAgICAgIGFsbEJ1dExhc3RUeXBlOiBhY2NlcHRlZEZpbGVUeXBlc01hcHBlZFxuICAgICAgICAgICAgICAgICAgICAuc2xpY2UoMCwgLTEpXG4gICAgICAgICAgICAgICAgICAgIC5qb2luKCcsICcpLFxuICAgICAgICAgICAgICAgICAgbGFzdFR5cGU6XG4gICAgICAgICAgICAgICAgICAgIGFjY2VwdGVkRmlsZVR5cGVzTWFwcGVkW2FjY2VwdGVkRmlsZVR5cGVzTWFwcGVkLmxlbmd0aCAtIDFdXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gaGFzIHJldHVybmVkIG5ldyBmaWxlbmFtZSBpbW1pZGlhdGVseVxuICAgICAgICBpZiAodHlwZW9mIHZhbGlkYXRpb25SZXN1bHQgPT09ICdib29sZWFuJykge1xuICAgICAgICAgIGlmICghdmFsaWRhdGlvblJlc3VsdCkge1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZVJlamVjdGlvbigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzb2x2ZShmaWxlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlzIHByb21pc2VcbiAgICAgICAgdmFsaWRhdGlvblJlc3VsdFxuICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmVzb2x2ZShmaWxlKTtcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5jYXRjaChoYW5kbGVSZWplY3Rpb24pO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvLyBleHBvc2UgcGx1Z2luXG4gICAgcmV0dXJuIHtcbiAgICAgIC8vIGRlZmF1bHQgb3B0aW9uc1xuICAgICAgb3B0aW9uczoge1xuICAgICAgICAvLyBFbmFibGUgb3IgZGlzYWJsZSBmaWxlIHR5cGUgdmFsaWRhdGlvblxuICAgICAgICBhbGxvd0ZpbGVUeXBlVmFsaWRhdGlvbjogW3RydWUsIFR5cGUuQk9PTEVBTl0sXG5cbiAgICAgICAgLy8gV2hhdCBmaWxlIHR5cGVzIHRvIGFjY2VwdFxuICAgICAgICBhY2NlcHRlZEZpbGVUeXBlczogW1tdLCBUeXBlLkFSUkFZXSxcbiAgICAgICAgLy8gLSBtdXN0IGJlIGNvbW1hIHNlcGFyYXRlZFxuICAgICAgICAvLyAtIG1pbWUgdHlwZXM6IGltYWdlL3BuZywgaW1hZ2UvanBlZywgaW1hZ2UvZ2lmXG4gICAgICAgIC8vIC0gZXh0ZW5zaW9uczogLnBuZywgLmpwZywgLmpwZWcgKCBub3QgZW5hYmxlZCB5ZXQgKVxuICAgICAgICAvLyAtIHdpbGRjYXJkczogaW1hZ2UvKlxuXG4gICAgICAgIC8vIGxhYmVsIHRvIHNob3cgd2hlbiBhIHR5cGUgaXMgbm90IGFsbG93ZWRcbiAgICAgICAgbGFiZWxGaWxlVHlwZU5vdEFsbG93ZWQ6IFsnRmlsZSBpcyBvZiBpbnZhbGlkIHR5cGUnLCBUeXBlLlNUUklOR10sXG5cbiAgICAgICAgLy8gbmljZXIgbGFiZWxcbiAgICAgICAgZmlsZVZhbGlkYXRlVHlwZUxhYmVsRXhwZWN0ZWRUeXBlczogW1xuICAgICAgICAgICdFeHBlY3RzIHthbGxCdXRMYXN0VHlwZX0gb3Ige2xhc3RUeXBlfScsXG4gICAgICAgICAgVHlwZS5TVFJJTkdcbiAgICAgICAgXSxcblxuICAgICAgICAvLyBtYXAgbWltZSB0eXBlcyB0byBleHRlbnNpb25zXG4gICAgICAgIGZpbGVWYWxpZGF0ZVR5cGVMYWJlbEV4cGVjdGVkVHlwZXNNYXA6IFt7fSwgVHlwZS5PQkpFQ1RdLFxuXG4gICAgICAgIC8vIEN1c3RvbSBmdW5jdGlvbiB0byBkZXRlY3QgdHlwZSBvZiBmaWxlXG4gICAgICAgIGZpbGVWYWxpZGF0ZVR5cGVEZXRlY3RUeXBlOiBbbnVsbCwgVHlwZS5GVU5DVElPTl1cbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIC8vIGZpcmUgcGx1Z2lubG9hZGVkIGV2ZW50IGlmIHJ1bm5pbmcgaW4gYnJvd3NlciwgdGhpcyBhbGxvd3MgcmVnaXN0ZXJpbmcgdGhlIHBsdWdpbiB3aGVuIHVzaW5nIGFzeW5jIHNjcmlwdCB0YWdzXG4gIHZhciBpc0Jyb3dzZXIgPVxuICAgIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnO1xuICBpZiAoaXNCcm93c2VyKSB7XG4gICAgZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChcbiAgICAgIG5ldyBDdXN0b21FdmVudCgnRmlsZVBvbmQ6cGx1Z2lubG9hZGVkJywgeyBkZXRhaWw6IHBsdWdpbiB9KVxuICAgICk7XG4gIH1cblxuICByZXR1cm4gcGx1Z2luO1xufSk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/filepond-plugin-file-validate-type/dist/filepond-plugin-file-validate-type.js\n");

/***/ }),

/***/ "./node_modules/filepond/dist/filepond.js":
/*!************************************************!*\
  !*** ./node_modules/filepond/dist/filepond.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\n * FilePond 4.23.1\n * Licensed under MIT, https://opensource.org/licenses/MIT/\n * Please visit https://pqina.nl/filepond/ for details.\n */\n\n/* eslint-disable */\n\n(function(global, factory) {\n   true\n    ? factory(exports)\n    : undefined;\n})(this, function(exports) {\n  'use strict';\n\n  var isNode = function isNode(value) {\n    return value instanceof HTMLElement;\n  };\n\n  var createStore = function createStore(initialState) {\n    var queries =\n      arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    var actions =\n      arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    // internal state\n    var state = Object.assign({}, initialState);\n\n    // contains all actions for next frame, is clear when actions are requested\n    var actionQueue = [];\n    var dispatchQueue = [];\n\n    // returns a duplicate of the current state\n    var getState = function getState() {\n      return Object.assign({}, state);\n    };\n\n    // returns a duplicate of the actions array and clears the actions array\n    var processActionQueue = function processActionQueue() {\n      // create copy of actions queue\n      var queue = [].concat(actionQueue);\n\n      // clear actions queue (we don't want no double actions)\n      actionQueue.length = 0;\n\n      return queue;\n    };\n\n    // processes actions that might block the main UI thread\n    var processDispatchQueue = function processDispatchQueue() {\n      // create copy of actions queue\n      var queue = [].concat(dispatchQueue);\n\n      // clear actions queue (we don't want no double actions)\n      dispatchQueue.length = 0;\n\n      // now dispatch these actions\n      queue.forEach(function(_ref) {\n        var type = _ref.type,\n          data = _ref.data;\n        dispatch(type, data);\n      });\n    };\n\n    // adds a new action, calls its handler and\n    var dispatch = function dispatch(type, data, isBlocking) {\n      // is blocking action (should never block if document is hidden)\n      if (isBlocking && !document.hidden) {\n        dispatchQueue.push({ type: type, data: data });\n        return;\n      }\n\n      // if this action has a handler, handle the action\n      if (actionHandlers[type]) {\n        actionHandlers[type](data);\n      }\n\n      // now add action\n      actionQueue.push({\n        type: type,\n        data: data\n      });\n    };\n\n    var query = function query(str) {\n      var _queryHandles;\n      for (\n        var _len = arguments.length,\n          args = new Array(_len > 1 ? _len - 1 : 0),\n          _key = 1;\n        _key < _len;\n        _key++\n      ) {\n        args[_key - 1] = arguments[_key];\n      }\n      return queryHandles[str]\n        ? (_queryHandles = queryHandles)[str].apply(_queryHandles, args)\n        : null;\n    };\n\n    var api = {\n      getState: getState,\n      processActionQueue: processActionQueue,\n      processDispatchQueue: processDispatchQueue,\n      dispatch: dispatch,\n      query: query\n    };\n\n    var queryHandles = {};\n    queries.forEach(function(query) {\n      queryHandles = Object.assign({}, query(state), {}, queryHandles);\n    });\n\n    var actionHandlers = {};\n    actions.forEach(function(action) {\n      actionHandlers = Object.assign(\n        {},\n        action(dispatch, query, state),\n        {},\n        actionHandlers\n      );\n    });\n\n    return api;\n  };\n\n  var defineProperty = function defineProperty(obj, property, definition) {\n    if (typeof definition === 'function') {\n      obj[property] = definition;\n      return;\n    }\n    Object.defineProperty(obj, property, Object.assign({}, definition));\n  };\n\n  var forin = function forin(obj, cb) {\n    for (var key in obj) {\n      if (!obj.hasOwnProperty(key)) {\n        continue;\n      }\n\n      cb(key, obj[key]);\n    }\n  };\n\n  var createObject = function createObject(definition) {\n    var obj = {};\n    forin(definition, function(property) {\n      defineProperty(obj, property, definition[property]);\n    });\n    return obj;\n  };\n\n  var attr = function attr(node, name) {\n    var value =\n      arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    if (value === null) {\n      return node.getAttribute(name) || node.hasAttribute(name);\n    }\n    node.setAttribute(name, value);\n  };\n\n  var ns = 'http://www.w3.org/2000/svg';\n  var svgElements = ['svg', 'path']; // only svg elements used\n\n  var isSVGElement = function isSVGElement(tag) {\n    return svgElements.includes(tag);\n  };\n\n  var createElement = function createElement(tag, className) {\n    var attributes =\n      arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    if (typeof className === 'object') {\n      attributes = className;\n      className = null;\n    }\n    var element = isSVGElement(tag)\n      ? document.createElementNS(ns, tag)\n      : document.createElement(tag);\n    if (className) {\n      if (isSVGElement(tag)) {\n        attr(element, 'class', className);\n      } else {\n        element.className = className;\n      }\n    }\n    forin(attributes, function(name, value) {\n      attr(element, name, value);\n    });\n    return element;\n  };\n\n  var appendChild = function appendChild(parent) {\n    return function(child, index) {\n      if (typeof index !== 'undefined' && parent.children[index]) {\n        parent.insertBefore(child, parent.children[index]);\n      } else {\n        parent.appendChild(child);\n      }\n    };\n  };\n\n  var appendChildView = function appendChildView(parent, childViews) {\n    return function(view, index) {\n      if (typeof index !== 'undefined') {\n        childViews.splice(index, 0, view);\n      } else {\n        childViews.push(view);\n      }\n\n      return view;\n    };\n  };\n\n  var removeChildView = function removeChildView(parent, childViews) {\n    return function(view) {\n      // remove from child views\n      childViews.splice(childViews.indexOf(view), 1);\n\n      // remove the element\n      if (view.element.parentNode) {\n        parent.removeChild(view.element);\n      }\n\n      return view;\n    };\n  };\n\n  var IS_BROWSER = (function() {\n    return (\n      typeof window !== 'undefined' && typeof window.document !== 'undefined'\n    );\n  })();\n  var isBrowser = function isBrowser() {\n    return IS_BROWSER;\n  };\n\n  var testElement = isBrowser() ? createElement('svg') : {};\n  var getChildCount =\n    'children' in testElement\n      ? function(el) {\n          return el.children.length;\n        }\n      : function(el) {\n          return el.childNodes.length;\n        };\n\n  var getViewRect = function getViewRect(\n    elementRect,\n    childViews,\n    offset,\n    scale\n  ) {\n    var left = offset[0] || elementRect.left;\n    var top = offset[1] || elementRect.top;\n    var right = left + elementRect.width;\n    var bottom = top + elementRect.height * (scale[1] || 1);\n\n    var rect = {\n      // the rectangle of the element itself\n      element: Object.assign({}, elementRect),\n\n      // the rectangle of the element expanded to contain its children, does not include any margins\n      inner: {\n        left: elementRect.left,\n        top: elementRect.top,\n        right: elementRect.right,\n        bottom: elementRect.bottom\n      },\n\n      // the rectangle of the element expanded to contain its children including own margin and child margins\n      // margins will be added after we've recalculated the size\n      outer: {\n        left: left,\n        top: top,\n        right: right,\n        bottom: bottom\n      }\n    };\n\n    // expand rect to fit all child rectangles\n    childViews\n      .filter(function(childView) {\n        return !childView.isRectIgnored();\n      })\n      .map(function(childView) {\n        return childView.rect;\n      })\n      .forEach(function(childViewRect) {\n        expandRect(rect.inner, Object.assign({}, childViewRect.inner));\n        expandRect(rect.outer, Object.assign({}, childViewRect.outer));\n      });\n\n    // calculate inner width and height\n    calculateRectSize(rect.inner);\n\n    // append additional margin (top and left margins are included in top and left automatically)\n    rect.outer.bottom += rect.element.marginBottom;\n    rect.outer.right += rect.element.marginRight;\n\n    // calculate outer width and height\n    calculateRectSize(rect.outer);\n\n    return rect;\n  };\n\n  var expandRect = function expandRect(parent, child) {\n    // adjust for parent offset\n    child.top += parent.top;\n    child.right += parent.left;\n    child.bottom += parent.top;\n    child.left += parent.left;\n\n    if (child.bottom > parent.bottom) {\n      parent.bottom = child.bottom;\n    }\n\n    if (child.right > parent.right) {\n      parent.right = child.right;\n    }\n  };\n\n  var calculateRectSize = function calculateRectSize(rect) {\n    rect.width = rect.right - rect.left;\n    rect.height = rect.bottom - rect.top;\n  };\n\n  var isNumber = function isNumber(value) {\n    return typeof value === 'number';\n  };\n\n  /**\n   * Determines if position is at destination\n   * @param position\n   * @param destination\n   * @param velocity\n   * @param errorMargin\n   * @returns {boolean}\n   */\n  var thereYet = function thereYet(position, destination, velocity) {\n    var errorMargin =\n      arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.001;\n    return (\n      Math.abs(position - destination) < errorMargin &&\n      Math.abs(velocity) < errorMargin\n    );\n  };\n\n  /**\n   * Spring animation\n   */\n  var spring =\n    // default options\n    function spring() // method definition\n    {\n      var _ref =\n          arguments.length > 0 && arguments[0] !== undefined\n            ? arguments[0]\n            : {},\n        _ref$stiffness = _ref.stiffness,\n        stiffness = _ref$stiffness === void 0 ? 0.5 : _ref$stiffness,\n        _ref$damping = _ref.damping,\n        damping = _ref$damping === void 0 ? 0.75 : _ref$damping,\n        _ref$mass = _ref.mass,\n        mass = _ref$mass === void 0 ? 10 : _ref$mass;\n      var target = null;\n      var position = null;\n      var velocity = 0;\n      var resting = false;\n\n      // updates spring state\n      var interpolate = function interpolate(ts, skipToEndState) {\n        // in rest, don't animate\n        if (resting) return;\n\n        // need at least a target or position to do springy things\n        if (!(isNumber(target) && isNumber(position))) {\n          resting = true;\n          velocity = 0;\n          return;\n        }\n\n        // calculate spring force\n        var f = -(position - target) * stiffness;\n\n        // update velocity by adding force based on mass\n        velocity += f / mass;\n\n        // update position by adding velocity\n        position += velocity;\n\n        // slow down based on amount of damping\n        velocity *= damping;\n\n        // we've arrived if we're near target and our velocity is near zero\n        if (thereYet(position, target, velocity) || skipToEndState) {\n          position = target;\n          velocity = 0;\n          resting = true;\n\n          // we done\n          api.onupdate(position);\n          api.oncomplete(position);\n        } else {\n          // progress update\n          api.onupdate(position);\n        }\n      };\n\n      /**\n       * Set new target value\n       * @param value\n       */\n      var setTarget = function setTarget(value) {\n        // if currently has no position, set target and position to this value\n        if (isNumber(value) && !isNumber(position)) {\n          position = value;\n        }\n\n        // next target value will not be animated to\n        if (target === null) {\n          target = value;\n          position = value;\n        }\n\n        // let start moving to target\n        target = value;\n\n        // already at target\n        if (position === target || typeof target === 'undefined') {\n          // now resting as target is current position, stop moving\n          resting = true;\n          velocity = 0;\n\n          // done!\n          api.onupdate(position);\n          api.oncomplete(position);\n\n          return;\n        }\n\n        resting = false;\n      };\n\n      // need 'api' to call onupdate callback\n      var api = createObject({\n        interpolate: interpolate,\n        target: {\n          set: setTarget,\n          get: function get() {\n            return target;\n          }\n        },\n\n        resting: {\n          get: function get() {\n            return resting;\n          }\n        },\n\n        onupdate: function onupdate(value) {},\n        oncomplete: function oncomplete(value) {}\n      });\n\n      return api;\n    };\n\n  var easeLinear = function easeLinear(t) {\n    return t;\n  };\n  var easeInOutQuad = function easeInOutQuad(t) {\n    return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;\n  };\n\n  var tween =\n    // default values\n    function tween() // method definition\n    {\n      var _ref =\n          arguments.length > 0 && arguments[0] !== undefined\n            ? arguments[0]\n            : {},\n        _ref$duration = _ref.duration,\n        duration = _ref$duration === void 0 ? 500 : _ref$duration,\n        _ref$easing = _ref.easing,\n        easing = _ref$easing === void 0 ? easeInOutQuad : _ref$easing,\n        _ref$delay = _ref.delay,\n        delay = _ref$delay === void 0 ? 0 : _ref$delay;\n      var start = null;\n      var t;\n      var p;\n      var resting = true;\n      var reverse = false;\n      var target = null;\n\n      var interpolate = function interpolate(ts, skipToEndState) {\n        if (resting || target === null) return;\n\n        if (start === null) {\n          start = ts;\n        }\n\n        if (ts - start < delay) return;\n\n        t = ts - start - delay;\n\n        if (t >= duration || skipToEndState) {\n          t = 1;\n          p = reverse ? 0 : 1;\n          api.onupdate(p * target);\n          api.oncomplete(p * target);\n          resting = true;\n        } else {\n          p = t / duration;\n          api.onupdate((t >= 0 ? easing(reverse ? 1 - p : p) : 0) * target);\n        }\n      };\n\n      // need 'api' to call onupdate callback\n      var api = createObject({\n        interpolate: interpolate,\n        target: {\n          get: function get() {\n            return reverse ? 0 : target;\n          },\n          set: function set(value) {\n            // is initial value\n            if (target === null) {\n              target = value;\n              api.onupdate(value);\n              api.oncomplete(value);\n              return;\n            }\n\n            // want to tween to a smaller value and have a current value\n            if (value < target) {\n              target = 1;\n              reverse = true;\n            } else {\n              // not tweening to a smaller value\n              reverse = false;\n              target = value;\n            }\n\n            // let's go!\n            resting = false;\n            start = null;\n          }\n        },\n\n        resting: {\n          get: function get() {\n            return resting;\n          }\n        },\n\n        onupdate: function onupdate(value) {},\n        oncomplete: function oncomplete(value) {}\n      });\n\n      return api;\n    };\n\n  var animator = {\n    spring: spring,\n    tween: tween\n  };\n\n  /*\n                       { type: 'spring', stiffness: .5, damping: .75, mass: 10 };\n                       { translation: { type: 'spring', ... }, ... }\n                       { translation: { x: { type: 'spring', ... } } }\n                      */\n  var createAnimator = function createAnimator(definition, category, property) {\n    // default is single definition\n    // we check if transform is set, if so, we check if property is set\n    var def =\n      definition[category] && typeof definition[category][property] === 'object'\n        ? definition[category][property]\n        : definition[category] || definition;\n\n    var type = typeof def === 'string' ? def : def.type;\n    var props = typeof def === 'object' ? Object.assign({}, def) : {};\n\n    return animator[type] ? animator[type](props) : null;\n  };\n\n  var addGetSet = function addGetSet(keys, obj, props) {\n    var overwrite =\n      arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    obj = Array.isArray(obj) ? obj : [obj];\n    obj.forEach(function(o) {\n      keys.forEach(function(key) {\n        var name = key;\n        var getter = function getter() {\n          return props[key];\n        };\n        var setter = function setter(value) {\n          return (props[key] = value);\n        };\n\n        if (typeof key === 'object') {\n          name = key.key;\n          getter = key.getter || getter;\n          setter = key.setter || setter;\n        }\n\n        if (o[name] && !overwrite) {\n          return;\n        }\n\n        o[name] = {\n          get: getter,\n          set: setter\n        };\n      });\n    });\n  };\n\n  // add to state,\n  // add getters and setters to internal and external api (if not set)\n  // setup animators\n\n  var animations = function animations(_ref) {\n    var mixinConfig = _ref.mixinConfig,\n      viewProps = _ref.viewProps,\n      viewInternalAPI = _ref.viewInternalAPI,\n      viewExternalAPI = _ref.viewExternalAPI;\n    // initial properties\n    var initialProps = Object.assign({}, viewProps);\n\n    // list of all active animations\n    var animations = [];\n\n    // setup animators\n    forin(mixinConfig, function(property, animation) {\n      var animator = createAnimator(animation);\n      if (!animator) {\n        return;\n      }\n\n      // when the animator updates, update the view state value\n      animator.onupdate = function(value) {\n        viewProps[property] = value;\n      };\n\n      // set animator target\n      animator.target = initialProps[property];\n\n      // when value is set, set the animator target value\n      var prop = {\n        key: property,\n        setter: function setter(value) {\n          // if already at target, we done!\n          if (animator.target === value) {\n            return;\n          }\n\n          animator.target = value;\n        },\n        getter: function getter() {\n          return viewProps[property];\n        }\n      };\n\n      // add getters and setters\n      addGetSet([prop], [viewInternalAPI, viewExternalAPI], viewProps, true);\n\n      // add it to the list for easy updating from the _write method\n      animations.push(animator);\n    });\n\n    // expose internal write api\n    return {\n      write: function write(ts) {\n        var skipToEndState = document.hidden;\n        var resting = true;\n        animations.forEach(function(animation) {\n          if (!animation.resting) resting = false;\n          animation.interpolate(ts, skipToEndState);\n        });\n        return resting;\n      },\n      destroy: function destroy() {}\n    };\n  };\n\n  var addEvent = function addEvent(element) {\n    return function(type, fn) {\n      element.addEventListener(type, fn);\n    };\n  };\n\n  var removeEvent = function removeEvent(element) {\n    return function(type, fn) {\n      element.removeEventListener(type, fn);\n    };\n  };\n\n  // mixin\n  var listeners = function listeners(_ref) {\n    var mixinConfig = _ref.mixinConfig,\n      viewProps = _ref.viewProps,\n      viewInternalAPI = _ref.viewInternalAPI,\n      viewExternalAPI = _ref.viewExternalAPI,\n      viewState = _ref.viewState,\n      view = _ref.view;\n    var events = [];\n\n    var add = addEvent(view.element);\n    var remove = removeEvent(view.element);\n\n    viewExternalAPI.on = function(type, fn) {\n      events.push({\n        type: type,\n        fn: fn\n      });\n\n      add(type, fn);\n    };\n\n    viewExternalAPI.off = function(type, fn) {\n      events.splice(\n        events.findIndex(function(event) {\n          return event.type === type && event.fn === fn;\n        }),\n        1\n      );\n\n      remove(type, fn);\n    };\n\n    return {\n      write: function write() {\n        // not busy\n        return true;\n      },\n      destroy: function destroy() {\n        events.forEach(function(event) {\n          remove(event.type, event.fn);\n        });\n      }\n    };\n  };\n\n  // add to external api and link to props\n\n  var apis = function apis(_ref) {\n    var mixinConfig = _ref.mixinConfig,\n      viewProps = _ref.viewProps,\n      viewExternalAPI = _ref.viewExternalAPI;\n    addGetSet(mixinConfig, viewExternalAPI, viewProps);\n  };\n\n  var isDefined = function isDefined(value) {\n    return value != null;\n  };\n\n  // add to state,\n  // add getters and setters to internal and external api (if not set)\n  // set initial state based on props in viewProps\n  // apply as transforms each frame\n\n  var defaults = {\n    opacity: 1,\n    scaleX: 1,\n    scaleY: 1,\n    translateX: 0,\n    translateY: 0,\n    rotateX: 0,\n    rotateY: 0,\n    rotateZ: 0,\n    originX: 0,\n    originY: 0\n  };\n\n  var styles = function styles(_ref) {\n    var mixinConfig = _ref.mixinConfig,\n      viewProps = _ref.viewProps,\n      viewInternalAPI = _ref.viewInternalAPI,\n      viewExternalAPI = _ref.viewExternalAPI,\n      view = _ref.view;\n    // initial props\n    var initialProps = Object.assign({}, viewProps);\n\n    // current props\n    var currentProps = {};\n\n    // we will add those properties to the external API and link them to the viewState\n    addGetSet(mixinConfig, [viewInternalAPI, viewExternalAPI], viewProps);\n\n    // override rect on internal and external rect getter so it takes in account transforms\n    var getOffset = function getOffset() {\n      return [viewProps['translateX'] || 0, viewProps['translateY'] || 0];\n    };\n\n    var getScale = function getScale() {\n      return [viewProps['scaleX'] || 0, viewProps['scaleY'] || 0];\n    };\n    var getRect = function getRect() {\n      return view.rect\n        ? getViewRect(view.rect, view.childViews, getOffset(), getScale())\n        : null;\n    };\n    viewInternalAPI.rect = { get: getRect };\n    viewExternalAPI.rect = { get: getRect };\n\n    // apply view props\n    mixinConfig.forEach(function(key) {\n      viewProps[key] =\n        typeof initialProps[key] === 'undefined'\n          ? defaults[key]\n          : initialProps[key];\n    });\n\n    // expose api\n    return {\n      write: function write() {\n        // see if props have changed\n        if (!propsHaveChanged(currentProps, viewProps)) {\n          return;\n        }\n\n        // moves element to correct position on screen\n        applyStyles(view.element, viewProps);\n\n        // store new transforms\n        Object.assign(currentProps, Object.assign({}, viewProps));\n\n        // no longer busy\n        return true;\n      },\n      destroy: function destroy() {}\n    };\n  };\n\n  var propsHaveChanged = function propsHaveChanged(currentProps, newProps) {\n    // different amount of keys\n    if (Object.keys(currentProps).length !== Object.keys(newProps).length) {\n      return true;\n    }\n\n    // lets analyze the individual props\n    for (var prop in newProps) {\n      if (newProps[prop] !== currentProps[prop]) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  var applyStyles = function applyStyles(element, _ref2) {\n    var opacity = _ref2.opacity,\n      perspective = _ref2.perspective,\n      translateX = _ref2.translateX,\n      translateY = _ref2.translateY,\n      scaleX = _ref2.scaleX,\n      scaleY = _ref2.scaleY,\n      rotateX = _ref2.rotateX,\n      rotateY = _ref2.rotateY,\n      rotateZ = _ref2.rotateZ,\n      originX = _ref2.originX,\n      originY = _ref2.originY,\n      width = _ref2.width,\n      height = _ref2.height;\n\n    var transforms = '';\n    var styles = '';\n\n    // handle transform origin\n    if (isDefined(originX) || isDefined(originY)) {\n      styles +=\n        'transform-origin: ' + (originX || 0) + 'px ' + (originY || 0) + 'px;';\n    }\n\n    // transform order is relevant\n    // 0. perspective\n    if (isDefined(perspective)) {\n      transforms += 'perspective(' + perspective + 'px) ';\n    }\n\n    // 1. translate\n    if (isDefined(translateX) || isDefined(translateY)) {\n      transforms +=\n        'translate3d(' +\n        (translateX || 0) +\n        'px, ' +\n        (translateY || 0) +\n        'px, 0) ';\n    }\n\n    // 2. scale\n    if (isDefined(scaleX) || isDefined(scaleY)) {\n      transforms +=\n        'scale3d(' +\n        (isDefined(scaleX) ? scaleX : 1) +\n        ', ' +\n        (isDefined(scaleY) ? scaleY : 1) +\n        ', 1) ';\n    }\n\n    // 3. rotate\n    if (isDefined(rotateZ)) {\n      transforms += 'rotateZ(' + rotateZ + 'rad) ';\n    }\n\n    if (isDefined(rotateX)) {\n      transforms += 'rotateX(' + rotateX + 'rad) ';\n    }\n\n    if (isDefined(rotateY)) {\n      transforms += 'rotateY(' + rotateY + 'rad) ';\n    }\n\n    // add transforms\n    if (transforms.length) {\n      styles += 'transform:' + transforms + ';';\n    }\n\n    // add opacity\n    if (isDefined(opacity)) {\n      styles += 'opacity:' + opacity + ';';\n\n      // if we reach zero, we make the element inaccessible\n      if (opacity === 0) {\n        styles += 'visibility:hidden;';\n      }\n\n      // if we're below 100% opacity this element can't be clicked\n      if (opacity < 1) {\n        styles += 'pointer-events:none;';\n      }\n    }\n\n    // add height\n    if (isDefined(height)) {\n      styles += 'height:' + height + 'px;';\n    }\n\n    // add width\n    if (isDefined(width)) {\n      styles += 'width:' + width + 'px;';\n    }\n\n    // apply styles\n    var elementCurrentStyle = element.elementCurrentStyle || '';\n\n    // if new styles does not match current styles, lets update!\n    if (\n      styles.length !== elementCurrentStyle.length ||\n      styles !== elementCurrentStyle\n    ) {\n      element.style.cssText = styles;\n      // store current styles so we can compare them to new styles later on\n      // _not_ getting the style value is faster\n      element.elementCurrentStyle = styles;\n    }\n  };\n\n  var Mixins = {\n    styles: styles,\n    listeners: listeners,\n    animations: animations,\n    apis: apis\n  };\n\n  var updateRect = function updateRect() {\n    var rect =\n      arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var element =\n      arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var style =\n      arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    if (!element.layoutCalculated) {\n      rect.paddingTop = parseInt(style.paddingTop, 10) || 0;\n      rect.marginTop = parseInt(style.marginTop, 10) || 0;\n      rect.marginRight = parseInt(style.marginRight, 10) || 0;\n      rect.marginBottom = parseInt(style.marginBottom, 10) || 0;\n      rect.marginLeft = parseInt(style.marginLeft, 10) || 0;\n      element.layoutCalculated = true;\n    }\n\n    rect.left = element.offsetLeft || 0;\n    rect.top = element.offsetTop || 0;\n    rect.width = element.offsetWidth || 0;\n    rect.height = element.offsetHeight || 0;\n\n    rect.right = rect.left + rect.width;\n    rect.bottom = rect.top + rect.height;\n\n    rect.scrollTop = element.scrollTop;\n\n    rect.hidden = element.offsetParent === null;\n\n    return rect;\n  };\n\n  var createView =\n    // default view definition\n    function createView() {\n      var _ref =\n          arguments.length > 0 && arguments[0] !== undefined\n            ? arguments[0]\n            : {},\n        _ref$tag = _ref.tag,\n        tag = _ref$tag === void 0 ? 'div' : _ref$tag,\n        _ref$name = _ref.name,\n        name = _ref$name === void 0 ? null : _ref$name,\n        _ref$attributes = _ref.attributes,\n        attributes = _ref$attributes === void 0 ? {} : _ref$attributes,\n        _ref$read = _ref.read,\n        read = _ref$read === void 0 ? function() {} : _ref$read,\n        _ref$write = _ref.write,\n        write = _ref$write === void 0 ? function() {} : _ref$write,\n        _ref$create = _ref.create,\n        create = _ref$create === void 0 ? function() {} : _ref$create,\n        _ref$destroy = _ref.destroy,\n        destroy = _ref$destroy === void 0 ? function() {} : _ref$destroy,\n        _ref$filterFrameActio = _ref.filterFrameActionsForChild,\n        filterFrameActionsForChild =\n          _ref$filterFrameActio === void 0\n            ? function(child, actions) {\n                return actions;\n              }\n            : _ref$filterFrameActio,\n        _ref$didCreateView = _ref.didCreateView,\n        didCreateView =\n          _ref$didCreateView === void 0 ? function() {} : _ref$didCreateView,\n        _ref$didWriteView = _ref.didWriteView,\n        didWriteView =\n          _ref$didWriteView === void 0 ? function() {} : _ref$didWriteView,\n        _ref$ignoreRect = _ref.ignoreRect,\n        ignoreRect = _ref$ignoreRect === void 0 ? false : _ref$ignoreRect,\n        _ref$ignoreRectUpdate = _ref.ignoreRectUpdate,\n        ignoreRectUpdate =\n          _ref$ignoreRectUpdate === void 0 ? false : _ref$ignoreRectUpdate,\n        _ref$mixins = _ref.mixins,\n        mixins = _ref$mixins === void 0 ? [] : _ref$mixins;\n      return function(\n        // each view requires reference to store\n        store\n      ) {\n        var props =\n          arguments.length > 1 && arguments[1] !== undefined\n            ? arguments[1]\n            : {};\n        // root element should not be changed\n        var element = createElement(tag, 'filepond--' + name, attributes);\n\n        // style reference should also not be changed\n        var style = window.getComputedStyle(element, null);\n\n        // element rectangle\n        var rect = updateRect();\n        var frameRect = null;\n\n        // rest state\n        var isResting = false;\n\n        // pretty self explanatory\n        var childViews = [];\n\n        // loaded mixins\n        var activeMixins = [];\n\n        // references to created children\n        var ref = {};\n\n        // state used for each instance\n        var state = {};\n\n        // list of writers that will be called to update this view\n        var writers = [\n          write // default writer\n        ];\n\n        var readers = [\n          read // default reader\n        ];\n\n        var destroyers = [\n          destroy // default destroy\n        ];\n\n        // core view methods\n        var getElement = function getElement() {\n          return element;\n        };\n        var getChildViews = function getChildViews() {\n          return childViews.concat();\n        };\n        var getReference = function getReference() {\n          return ref;\n        };\n        var createChildView = function createChildView(store) {\n          return function(view, props) {\n            return view(store, props);\n          };\n        };\n        var getRect = function getRect() {\n          if (frameRect) {\n            return frameRect;\n          }\n          frameRect = getViewRect(rect, childViews, [0, 0], [1, 1]);\n          return frameRect;\n        };\n        var getStyle = function getStyle() {\n          return style;\n        };\n\n        /**\n         * Read data from DOM\n         * @private\n         */\n        var _read = function _read() {\n          frameRect = null;\n\n          // read child views\n          childViews.forEach(function(child) {\n            return child._read();\n          });\n\n          var shouldUpdate = !(ignoreRectUpdate && rect.width && rect.height);\n          if (shouldUpdate) {\n            updateRect(rect, element, style);\n          }\n\n          // readers\n          var api = { root: internalAPI, props: props, rect: rect };\n          readers.forEach(function(reader) {\n            return reader(api);\n          });\n        };\n\n        /**\n         * Write data to DOM\n         * @private\n         */\n        var _write = function _write(ts, frameActions, shouldOptimize) {\n          // if no actions, we assume that the view is resting\n          var resting = frameActions.length === 0;\n\n          // writers\n          writers.forEach(function(writer) {\n            var writerResting = writer({\n              props: props,\n              root: internalAPI,\n              actions: frameActions,\n              timestamp: ts,\n              shouldOptimize: shouldOptimize\n            });\n\n            if (writerResting === false) {\n              resting = false;\n            }\n          });\n\n          // run mixins\n          activeMixins.forEach(function(mixin) {\n            // if one of the mixins is still busy after write operation, we are not resting\n            var mixinResting = mixin.write(ts);\n            if (mixinResting === false) {\n              resting = false;\n            }\n          });\n\n          // updates child views that are currently attached to the DOM\n          childViews\n            .filter(function(child) {\n              return !!child.element.parentNode;\n            })\n            .forEach(function(child) {\n              // if a child view is not resting, we are not resting\n              var childResting = child._write(\n                ts,\n                filterFrameActionsForChild(child, frameActions),\n                shouldOptimize\n              );\n\n              if (!childResting) {\n                resting = false;\n              }\n            });\n\n          // append new elements to DOM and update those\n          childViews\n            //.filter(child => !child.element.parentNode)\n            .forEach(function(child, index) {\n              // skip\n              if (child.element.parentNode) {\n                return;\n              }\n\n              // append to DOM\n              internalAPI.appendChild(child.element, index);\n\n              // call read (need to know the size of these elements)\n              child._read();\n\n              // re-call write\n              child._write(\n                ts,\n                filterFrameActionsForChild(child, frameActions),\n                shouldOptimize\n              );\n\n              // we just added somthing to the dom, no rest\n              resting = false;\n            });\n\n          // update resting state\n          isResting = resting;\n\n          didWriteView({\n            props: props,\n            root: internalAPI,\n            actions: frameActions,\n            timestamp: ts\n          });\n\n          // let parent know if we are resting\n          return resting;\n        };\n\n        var _destroy = function _destroy() {\n          activeMixins.forEach(function(mixin) {\n            return mixin.destroy();\n          });\n          destroyers.forEach(function(destroyer) {\n            destroyer({ root: internalAPI, props: props });\n          });\n          childViews.forEach(function(child) {\n            return child._destroy();\n          });\n        };\n\n        // sharedAPI\n        var sharedAPIDefinition = {\n          element: {\n            get: getElement\n          },\n\n          style: {\n            get: getStyle\n          },\n\n          childViews: {\n            get: getChildViews\n          }\n        };\n\n        // private API definition\n        var internalAPIDefinition = Object.assign({}, sharedAPIDefinition, {\n          rect: {\n            get: getRect\n          },\n\n          // access to custom children references\n          ref: {\n            get: getReference\n          },\n\n          // dom modifiers\n          is: function is(needle) {\n            return name === needle;\n          },\n          appendChild: appendChild(element),\n          createChildView: createChildView(store),\n          linkView: function linkView(view) {\n            childViews.push(view);\n            return view;\n          },\n          unlinkView: function unlinkView(view) {\n            childViews.splice(childViews.indexOf(view), 1);\n          },\n          appendChildView: appendChildView(element, childViews),\n          removeChildView: removeChildView(element, childViews),\n          registerWriter: function registerWriter(writer) {\n            return writers.push(writer);\n          },\n          registerReader: function registerReader(reader) {\n            return readers.push(reader);\n          },\n          registerDestroyer: function registerDestroyer(destroyer) {\n            return destroyers.push(destroyer);\n          },\n          invalidateLayout: function invalidateLayout() {\n            return (element.layoutCalculated = false);\n          },\n\n          // access to data store\n          dispatch: store.dispatch,\n          query: store.query\n        });\n\n        // public view API methods\n        var externalAPIDefinition = {\n          element: {\n            get: getElement\n          },\n\n          childViews: {\n            get: getChildViews\n          },\n\n          rect: {\n            get: getRect\n          },\n\n          resting: {\n            get: function get() {\n              return isResting;\n            }\n          },\n\n          isRectIgnored: function isRectIgnored() {\n            return ignoreRect;\n          },\n          _read: _read,\n          _write: _write,\n          _destroy: _destroy\n        };\n\n        // mixin API methods\n        var mixinAPIDefinition = Object.assign({}, sharedAPIDefinition, {\n          rect: {\n            get: function get() {\n              return rect;\n            }\n          }\n        });\n\n        // add mixin functionality\n        Object.keys(mixins)\n          .sort(function(a, b) {\n            // move styles to the back of the mixin list (so adjustments of other mixins are applied to the props correctly)\n            if (a === 'styles') {\n              return 1;\n            } else if (b === 'styles') {\n              return -1;\n            }\n            return 0;\n          })\n          .forEach(function(key) {\n            var mixinAPI = Mixins[key]({\n              mixinConfig: mixins[key],\n              viewProps: props,\n              viewState: state,\n              viewInternalAPI: internalAPIDefinition,\n              viewExternalAPI: externalAPIDefinition,\n              view: createObject(mixinAPIDefinition)\n            });\n\n            if (mixinAPI) {\n              activeMixins.push(mixinAPI);\n            }\n          });\n\n        // construct private api\n        var internalAPI = createObject(internalAPIDefinition);\n\n        // create the view\n        create({\n          root: internalAPI,\n          props: props\n        });\n\n        // append created child views to root node\n        var childCount = getChildCount(element); // need to know the current child count so appending happens in correct order\n        childViews.forEach(function(child, index) {\n          internalAPI.appendChild(child.element, childCount + index);\n        });\n\n        // call did create\n        didCreateView(internalAPI);\n\n        // expose public api\n        return createObject(externalAPIDefinition);\n      };\n    };\n\n  var createPainter = function createPainter(read, write) {\n    var fps =\n      arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 60;\n\n    var name = '__framePainter';\n\n    // set global painter\n    if (window[name]) {\n      window[name].readers.push(read);\n      window[name].writers.push(write);\n      return;\n    }\n\n    window[name] = {\n      readers: [read],\n      writers: [write]\n    };\n\n    var painter = window[name];\n\n    var interval = 1000 / fps;\n    var last = null;\n    var id = null;\n    var requestTick = null;\n    var cancelTick = null;\n\n    var setTimerType = function setTimerType() {\n      if (document.hidden) {\n        requestTick = function requestTick() {\n          return window.setTimeout(function() {\n            return tick(performance.now());\n          }, interval);\n        };\n        cancelTick = function cancelTick() {\n          return window.clearTimeout(id);\n        };\n      } else {\n        requestTick = function requestTick() {\n          return window.requestAnimationFrame(tick);\n        };\n        cancelTick = function cancelTick() {\n          return window.cancelAnimationFrame(id);\n        };\n      }\n    };\n\n    document.addEventListener('visibilitychange', function() {\n      if (cancelTick) cancelTick();\n      setTimerType();\n      tick(performance.now());\n    });\n\n    var tick = function tick(ts) {\n      // queue next tick\n      id = requestTick(tick);\n\n      // limit fps\n      if (!last) {\n        last = ts;\n      }\n\n      var delta = ts - last;\n\n      if (delta <= interval) {\n        // skip frame\n        return;\n      }\n\n      // align next frame\n      last = ts - (delta % interval);\n\n      // update view\n      painter.readers.forEach(function(read) {\n        return read();\n      });\n      painter.writers.forEach(function(write) {\n        return write(ts);\n      });\n    };\n\n    setTimerType();\n    tick(performance.now());\n\n    return {\n      pause: function pause() {\n        cancelTick(id);\n      }\n    };\n  };\n\n  var createRoute = function createRoute(routes, fn) {\n    return function(_ref) {\n      var root = _ref.root,\n        props = _ref.props,\n        _ref$actions = _ref.actions,\n        actions = _ref$actions === void 0 ? [] : _ref$actions,\n        timestamp = _ref.timestamp,\n        shouldOptimize = _ref.shouldOptimize;\n      actions\n        .filter(function(action) {\n          return routes[action.type];\n        })\n        .forEach(function(action) {\n          return routes[action.type]({\n            root: root,\n            props: props,\n            action: action.data,\n            timestamp: timestamp,\n            shouldOptimize: shouldOptimize\n          });\n        });\n\n      if (fn) {\n        fn({\n          root: root,\n          props: props,\n          actions: actions,\n          timestamp: timestamp,\n          shouldOptimize: shouldOptimize\n        });\n      }\n    };\n  };\n\n  var insertBefore = function insertBefore(newNode, referenceNode) {\n    return referenceNode.parentNode.insertBefore(newNode, referenceNode);\n  };\n\n  var insertAfter = function insertAfter(newNode, referenceNode) {\n    return referenceNode.parentNode.insertBefore(\n      newNode,\n      referenceNode.nextSibling\n    );\n  };\n\n  var isArray = function isArray(value) {\n    return Array.isArray(value);\n  };\n\n  var isEmpty = function isEmpty(value) {\n    return value == null;\n  };\n\n  var trim = function trim(str) {\n    return str.trim();\n  };\n\n  var toString = function toString(value) {\n    return '' + value;\n  };\n\n  var toArray = function toArray(value) {\n    var splitter =\n      arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ',';\n    if (isEmpty(value)) {\n      return [];\n    }\n    if (isArray(value)) {\n      return value;\n    }\n    return toString(value)\n      .split(splitter)\n      .map(trim)\n      .filter(function(str) {\n        return str.length;\n      });\n  };\n\n  var isBoolean = function isBoolean(value) {\n    return typeof value === 'boolean';\n  };\n\n  var toBoolean = function toBoolean(value) {\n    return isBoolean(value) ? value : value === 'true';\n  };\n\n  var isString = function isString(value) {\n    return typeof value === 'string';\n  };\n\n  var toNumber = function toNumber(value) {\n    return isNumber(value)\n      ? value\n      : isString(value)\n      ? toString(value).replace(/[a-z]+/gi, '')\n      : 0;\n  };\n\n  var toInt = function toInt(value) {\n    return parseInt(toNumber(value), 10);\n  };\n\n  var toFloat = function toFloat(value) {\n    return parseFloat(toNumber(value));\n  };\n\n  var isInt = function isInt(value) {\n    return isNumber(value) && isFinite(value) && Math.floor(value) === value;\n  };\n\n  var toBytes = function toBytes(value) {\n    var base =\n      arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;\n    // is in bytes\n    if (isInt(value)) {\n      return value;\n    }\n\n    // is natural file size\n    var naturalFileSize = toString(value).trim();\n\n    // if is value in megabytes\n    if (/MB$/i.test(naturalFileSize)) {\n      naturalFileSize = naturalFileSize.replace(/MB$i/, '').trim();\n      return toInt(naturalFileSize) * base * base;\n    }\n\n    // if is value in kilobytes\n    if (/KB/i.test(naturalFileSize)) {\n      naturalFileSize = naturalFileSize.replace(/KB$i/, '').trim();\n      return toInt(naturalFileSize) * base;\n    }\n\n    return toInt(naturalFileSize);\n  };\n\n  var isFunction = function isFunction(value) {\n    return typeof value === 'function';\n  };\n\n  var toFunctionReference = function toFunctionReference(string) {\n    var ref = self;\n    var levels = string.split('.');\n    var level = null;\n    while ((level = levels.shift())) {\n      ref = ref[level];\n      if (!ref) {\n        return null;\n      }\n    }\n    return ref;\n  };\n\n  var methods = {\n    process: 'POST',\n    patch: 'PATCH',\n    revert: 'DELETE',\n    fetch: 'GET',\n    restore: 'GET',\n    load: 'GET'\n  };\n\n  var createServerAPI = function createServerAPI(outline) {\n    var api = {};\n\n    api.url = isString(outline) ? outline : outline.url || '';\n    api.timeout = outline.timeout ? parseInt(outline.timeout, 10) : 0;\n    api.headers = outline.headers ? outline.headers : {};\n\n    forin(methods, function(key) {\n      api[key] = createAction(\n        key,\n        outline[key],\n        methods[key],\n        api.timeout,\n        api.headers\n      );\n    });\n\n    // special treatment for remove\n    api.remove = outline.remove || null;\n\n    // remove generic headers from api object\n    delete api.headers;\n\n    return api;\n  };\n\n  var createAction = function createAction(\n    name,\n    outline,\n    method,\n    timeout,\n    headers\n  ) {\n    // is explicitely set to null so disable\n    if (outline === null) {\n      return null;\n    }\n\n    // if is custom function, done! Dev handles everything.\n    if (typeof outline === 'function') {\n      return outline;\n    }\n\n    // build action object\n    var action = {\n      url: method === 'GET' || method === 'PATCH' ? '?' + name + '=' : '',\n      method: method,\n      headers: headers,\n      withCredentials: false,\n      timeout: timeout,\n      onload: null,\n      ondata: null,\n      onerror: null\n    };\n\n    // is a single url\n    if (isString(outline)) {\n      action.url = outline;\n      return action;\n    }\n\n    // overwrite\n    Object.assign(action, outline);\n\n    // see if should reformat headers;\n    if (isString(action.headers)) {\n      var parts = action.headers.split(/:(.+)/);\n      action.headers = {\n        header: parts[0],\n        value: parts[1]\n      };\n    }\n\n    // if is bool withCredentials\n    action.withCredentials = toBoolean(action.withCredentials);\n\n    return action;\n  };\n\n  var toServerAPI = function toServerAPI(value) {\n    return createServerAPI(value);\n  };\n\n  var isNull = function isNull(value) {\n    return value === null;\n  };\n\n  var isObject = function isObject(value) {\n    return typeof value === 'object' && value !== null;\n  };\n\n  var isAPI = function isAPI(value) {\n    return (\n      isObject(value) &&\n      isString(value.url) &&\n      isObject(value.process) &&\n      isObject(value.revert) &&\n      isObject(value.restore) &&\n      isObject(value.fetch)\n    );\n  };\n\n  var getType = function getType(value) {\n    if (isArray(value)) {\n      return 'array';\n    }\n\n    if (isNull(value)) {\n      return 'null';\n    }\n\n    if (isInt(value)) {\n      return 'int';\n    }\n\n    if (/^[0-9]+ ?(?:GB|MB|KB)$/gi.test(value)) {\n      return 'bytes';\n    }\n\n    if (isAPI(value)) {\n      return 'api';\n    }\n\n    return typeof value;\n  };\n\n  var replaceSingleQuotes = function replaceSingleQuotes(str) {\n    return str\n      .replace(/{\\s*'/g, '{\"')\n      .replace(/'\\s*}/g, '\"}')\n      .replace(/'\\s*:/g, '\":')\n      .replace(/:\\s*'/g, ':\"')\n      .replace(/,\\s*'/g, ',\"')\n      .replace(/'\\s*,/g, '\",');\n  };\n\n  var conversionTable = {\n    array: toArray,\n    boolean: toBoolean,\n    int: function int(value) {\n      return getType(value) === 'bytes' ? toBytes(value) : toInt(value);\n    },\n    number: toFloat,\n    float: toFloat,\n    bytes: toBytes,\n    string: function string(value) {\n      return isFunction(value) ? value : toString(value);\n    },\n    function: function _function(value) {\n      return toFunctionReference(value);\n    },\n    serverapi: toServerAPI,\n    object: function object(value) {\n      try {\n        return JSON.parse(replaceSingleQuotes(value));\n      } catch (e) {\n        return null;\n      }\n    }\n  };\n\n  var convertTo = function convertTo(value, type) {\n    return conversionTable[type](value);\n  };\n\n  var getValueByType = function getValueByType(\n    newValue,\n    defaultValue,\n    valueType\n  ) {\n    // can always assign default value\n    if (newValue === defaultValue) {\n      return newValue;\n    }\n\n    // get the type of the new value\n    var newValueType = getType(newValue);\n\n    // is valid type?\n    if (newValueType !== valueType) {\n      // is string input, let's attempt to convert\n      var convertedValue = convertTo(newValue, valueType);\n\n      // what is the type now\n      newValueType = getType(convertedValue);\n\n      // no valid conversions found\n      if (convertedValue === null) {\n        throw 'Trying to assign value with incorrect type to \"' +\n          option +\n          '\", allowed type: \"' +\n          valueType +\n          '\"';\n      } else {\n        newValue = convertedValue;\n      }\n    }\n\n    // assign new value\n    return newValue;\n  };\n\n  var createOption = function createOption(defaultValue, valueType) {\n    var currentValue = defaultValue;\n    return {\n      enumerable: true,\n      get: function get() {\n        return currentValue;\n      },\n      set: function set(newValue) {\n        currentValue = getValueByType(newValue, defaultValue, valueType);\n      }\n    };\n  };\n\n  var createOptions = function createOptions(options) {\n    var obj = {};\n    forin(options, function(prop) {\n      var optionDefinition = options[prop];\n      obj[prop] = createOption(optionDefinition[0], optionDefinition[1]);\n    });\n    return createObject(obj);\n  };\n\n  var createInitialState = function createInitialState(options) {\n    return {\n      // model\n      items: [],\n\n      // timeout used for calling update items\n      listUpdateTimeout: null,\n\n      // timeout used for stacking metadata updates\n      itemUpdateTimeout: null,\n\n      // queue of items waiting to be processed\n      processingQueue: [],\n\n      // options\n      options: createOptions(options)\n    };\n  };\n\n  var fromCamels = function fromCamels(string) {\n    var separator =\n      arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '-';\n    return string\n      .split(/(?=[A-Z])/)\n      .map(function(part) {\n        return part.toLowerCase();\n      })\n      .join(separator);\n  };\n\n  var createOptionAPI = function createOptionAPI(store, options) {\n    var obj = {};\n    forin(options, function(key) {\n      obj[key] = {\n        get: function get() {\n          return store.getState().options[key];\n        },\n        set: function set(value) {\n          store.dispatch('SET_' + fromCamels(key, '_').toUpperCase(), {\n            value: value\n          });\n        }\n      };\n    });\n    return obj;\n  };\n\n  var createOptionActions = function createOptionActions(options) {\n    return function(dispatch, query, state) {\n      var obj = {};\n      forin(options, function(key) {\n        var name = fromCamels(key, '_').toUpperCase();\n\n        obj['SET_' + name] = function(action) {\n          try {\n            state.options[key] = action.value;\n          } catch (e) {} // nope, failed\n\n          // we successfully set the value of this option\n          dispatch('DID_SET_' + name, { value: state.options[key] });\n        };\n      });\n      return obj;\n    };\n  };\n\n  var createOptionQueries = function createOptionQueries(options) {\n    return function(state) {\n      var obj = {};\n      forin(options, function(key) {\n        obj['GET_' + fromCamels(key, '_').toUpperCase()] = function(action) {\n          return state.options[key];\n        };\n      });\n      return obj;\n    };\n  };\n\n  var InteractionMethod = {\n    API: 1,\n    DROP: 2,\n    BROWSE: 3,\n    PASTE: 4,\n    NONE: 5\n  };\n\n  var getUniqueId = function getUniqueId() {\n    return Math.random()\n      .toString(36)\n      .substr(2, 9);\n  };\n\n  function _typeof(obj) {\n    if (typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol') {\n      _typeof = function(obj) {\n        return typeof obj;\n      };\n    } else {\n      _typeof = function(obj) {\n        return obj &&\n          typeof Symbol === 'function' &&\n          obj.constructor === Symbol &&\n          obj !== Symbol.prototype\n          ? 'symbol'\n          : typeof obj;\n      };\n    }\n\n    return _typeof(obj);\n  }\n\n  var REACT_ELEMENT_TYPE;\n\n  function _jsx(type, props, key, children) {\n    if (!REACT_ELEMENT_TYPE) {\n      REACT_ELEMENT_TYPE =\n        (typeof Symbol === 'function' &&\n          Symbol['for'] &&\n          Symbol['for']('react.element')) ||\n        0xeac7;\n    }\n\n    var defaultProps = type && type.defaultProps;\n    var childrenLength = arguments.length - 3;\n\n    if (!props && childrenLength !== 0) {\n      props = {\n        children: void 0\n      };\n    }\n\n    if (props && defaultProps) {\n      for (var propName in defaultProps) {\n        if (props[propName] === void 0) {\n          props[propName] = defaultProps[propName];\n        }\n      }\n    } else if (!props) {\n      props = defaultProps || {};\n    }\n\n    if (childrenLength === 1) {\n      props.children = children;\n    } else if (childrenLength > 1) {\n      var childArray = new Array(childrenLength);\n\n      for (var i = 0; i < childrenLength; i++) {\n        childArray[i] = arguments[i + 3];\n      }\n\n      props.children = childArray;\n    }\n\n    return {\n      $$typeof: REACT_ELEMENT_TYPE,\n      type: type,\n      key: key === undefined ? null : '' + key,\n      ref: null,\n      props: props,\n      _owner: null\n    };\n  }\n\n  function _asyncIterator(iterable) {\n    var method;\n\n    if (typeof Symbol !== 'undefined') {\n      if (Symbol.asyncIterator) {\n        method = iterable[Symbol.asyncIterator];\n        if (method != null) return method.call(iterable);\n      }\n\n      if (Symbol.iterator) {\n        method = iterable[Symbol.iterator];\n        if (method != null) return method.call(iterable);\n      }\n    }\n\n    throw new TypeError('Object is not async iterable');\n  }\n\n  function _AwaitValue(value) {\n    this.wrapped = value;\n  }\n\n  function _AsyncGenerator(gen) {\n    var front, back;\n\n    function send(key, arg) {\n      return new Promise(function(resolve, reject) {\n        var request = {\n          key: key,\n          arg: arg,\n          resolve: resolve,\n          reject: reject,\n          next: null\n        };\n\n        if (back) {\n          back = back.next = request;\n        } else {\n          front = back = request;\n          resume(key, arg);\n        }\n      });\n    }\n\n    function resume(key, arg) {\n      try {\n        var result = gen[key](arg);\n        var value = result.value;\n        var wrappedAwait = value instanceof _AwaitValue;\n        Promise.resolve(wrappedAwait ? value.wrapped : value).then(\n          function(arg) {\n            if (wrappedAwait) {\n              resume('next', arg);\n              return;\n            }\n\n            settle(result.done ? 'return' : 'normal', arg);\n          },\n          function(err) {\n            resume('throw', err);\n          }\n        );\n      } catch (err) {\n        settle('throw', err);\n      }\n    }\n\n    function settle(type, value) {\n      switch (type) {\n        case 'return':\n          front.resolve({\n            value: value,\n            done: true\n          });\n          break;\n\n        case 'throw':\n          front.reject(value);\n          break;\n\n        default:\n          front.resolve({\n            value: value,\n            done: false\n          });\n          break;\n      }\n\n      front = front.next;\n\n      if (front) {\n        resume(front.key, front.arg);\n      } else {\n        back = null;\n      }\n    }\n\n    this._invoke = send;\n\n    if (typeof gen.return !== 'function') {\n      this.return = undefined;\n    }\n  }\n\n  if (typeof Symbol === 'function' && Symbol.asyncIterator) {\n    _AsyncGenerator.prototype[Symbol.asyncIterator] = function() {\n      return this;\n    };\n  }\n\n  _AsyncGenerator.prototype.next = function(arg) {\n    return this._invoke('next', arg);\n  };\n\n  _AsyncGenerator.prototype.throw = function(arg) {\n    return this._invoke('throw', arg);\n  };\n\n  _AsyncGenerator.prototype.return = function(arg) {\n    return this._invoke('return', arg);\n  };\n\n  function _wrapAsyncGenerator(fn) {\n    return function() {\n      return new _AsyncGenerator(fn.apply(this, arguments));\n    };\n  }\n\n  function _awaitAsyncGenerator(value) {\n    return new _AwaitValue(value);\n  }\n\n  function _asyncGeneratorDelegate(inner, awaitWrap) {\n    var iter = {},\n      waiting = false;\n\n    function pump(key, value) {\n      waiting = true;\n      value = new Promise(function(resolve) {\n        resolve(inner[key](value));\n      });\n      return {\n        done: false,\n        value: awaitWrap(value)\n      };\n    }\n\n    if (typeof Symbol === 'function' && Symbol.iterator) {\n      iter[Symbol.iterator] = function() {\n        return this;\n      };\n    }\n\n    iter.next = function(value) {\n      if (waiting) {\n        waiting = false;\n        return value;\n      }\n\n      return pump('next', value);\n    };\n\n    if (typeof inner.throw === 'function') {\n      iter.throw = function(value) {\n        if (waiting) {\n          waiting = false;\n          throw value;\n        }\n\n        return pump('throw', value);\n      };\n    }\n\n    if (typeof inner.return === 'function') {\n      iter.return = function(value) {\n        return pump('return', value);\n      };\n    }\n\n    return iter;\n  }\n\n  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n    try {\n      var info = gen[key](arg);\n      var value = info.value;\n    } catch (error) {\n      reject(error);\n      return;\n    }\n\n    if (info.done) {\n      resolve(value);\n    } else {\n      Promise.resolve(value).then(_next, _throw);\n    }\n  }\n\n  function _asyncToGenerator(fn) {\n    return function() {\n      var self = this,\n        args = arguments;\n      return new Promise(function(resolve, reject) {\n        var gen = fn.apply(self, args);\n\n        function _next(value) {\n          asyncGeneratorStep(\n            gen,\n            resolve,\n            reject,\n            _next,\n            _throw,\n            'next',\n            value\n          );\n        }\n\n        function _throw(err) {\n          asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'throw', err);\n        }\n\n        _next(undefined);\n      });\n    };\n  }\n\n  function _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError('Cannot call a class as a function');\n    }\n  }\n\n  function _defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if ('value' in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  function _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n  }\n\n  function _defineEnumerableProperties(obj, descs) {\n    for (var key in descs) {\n      var desc = descs[key];\n      desc.configurable = desc.enumerable = true;\n      if ('value' in desc) desc.writable = true;\n      Object.defineProperty(obj, key, desc);\n    }\n\n    if (Object.getOwnPropertySymbols) {\n      var objectSymbols = Object.getOwnPropertySymbols(descs);\n\n      for (var i = 0; i < objectSymbols.length; i++) {\n        var sym = objectSymbols[i];\n        var desc = descs[sym];\n        desc.configurable = desc.enumerable = true;\n        if ('value' in desc) desc.writable = true;\n        Object.defineProperty(obj, sym, desc);\n      }\n    }\n\n    return obj;\n  }\n\n  function _defaults(obj, defaults) {\n    var keys = Object.getOwnPropertyNames(defaults);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      var value = Object.getOwnPropertyDescriptor(defaults, key);\n\n      if (value && value.configurable && obj[key] === undefined) {\n        Object.defineProperty(obj, key, value);\n      }\n    }\n\n    return obj;\n  }\n\n  function _defineProperty(obj, key, value) {\n    if (key in obj) {\n      Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n    } else {\n      obj[key] = value;\n    }\n\n    return obj;\n  }\n\n  function _extends() {\n    _extends =\n      Object.assign ||\n      function(target) {\n        for (var i = 1; i < arguments.length; i++) {\n          var source = arguments[i];\n\n          for (var key in source) {\n            if (Object.prototype.hasOwnProperty.call(source, key)) {\n              target[key] = source[key];\n            }\n          }\n        }\n\n        return target;\n      };\n\n    return _extends.apply(this, arguments);\n  }\n\n  function _objectSpread(target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i] != null ? arguments[i] : {};\n      var ownKeys = Object.keys(source);\n\n      if (typeof Object.getOwnPropertySymbols === 'function') {\n        ownKeys = ownKeys.concat(\n          Object.getOwnPropertySymbols(source).filter(function(sym) {\n            return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n          })\n        );\n      }\n\n      ownKeys.forEach(function(key) {\n        _defineProperty(target, key, source[key]);\n      });\n    }\n\n    return target;\n  }\n\n  function ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n\n    if (Object.getOwnPropertySymbols) {\n      var symbols = Object.getOwnPropertySymbols(object);\n      if (enumerableOnly)\n        symbols = symbols.filter(function(sym) {\n          return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n        });\n      keys.push.apply(keys, symbols);\n    }\n\n    return keys;\n  }\n\n  function _objectSpread2(target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i] != null ? arguments[i] : {};\n\n      if (i % 2) {\n        ownKeys(source, true).forEach(function(key) {\n          _defineProperty(target, key, source[key]);\n        });\n      } else if (Object.getOwnPropertyDescriptors) {\n        Object.defineProperties(\n          target,\n          Object.getOwnPropertyDescriptors(source)\n        );\n      } else {\n        ownKeys(source).forEach(function(key) {\n          Object.defineProperty(\n            target,\n            key,\n            Object.getOwnPropertyDescriptor(source, key)\n          );\n        });\n      }\n    }\n\n    return target;\n  }\n\n  function _inherits(subClass, superClass) {\n    if (typeof superClass !== 'function' && superClass !== null) {\n      throw new TypeError('Super expression must either be null or a function');\n    }\n\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n      constructor: {\n        value: subClass,\n        writable: true,\n        configurable: true\n      }\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n  }\n\n  function _inheritsLoose(subClass, superClass) {\n    subClass.prototype = Object.create(superClass.prototype);\n    subClass.prototype.constructor = subClass;\n    subClass.__proto__ = superClass;\n  }\n\n  function _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf\n      ? Object.getPrototypeOf\n      : function _getPrototypeOf(o) {\n          return o.__proto__ || Object.getPrototypeOf(o);\n        };\n    return _getPrototypeOf(o);\n  }\n\n  function _setPrototypeOf(o, p) {\n    _setPrototypeOf =\n      Object.setPrototypeOf ||\n      function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n      };\n\n    return _setPrototypeOf(o, p);\n  }\n\n  function isNativeReflectConstruct() {\n    if (typeof Reflect === 'undefined' || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === 'function') return true;\n\n    try {\n      Date.prototype.toString.call(Reflect.construct(Date, [], function() {}));\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  function _construct(Parent, args, Class) {\n    if (isNativeReflectConstruct()) {\n      _construct = Reflect.construct;\n    } else {\n      _construct = function _construct(Parent, args, Class) {\n        var a = [null];\n        a.push.apply(a, args);\n        var Constructor = Function.bind.apply(Parent, a);\n        var instance = new Constructor();\n        if (Class) _setPrototypeOf(instance, Class.prototype);\n        return instance;\n      };\n    }\n\n    return _construct.apply(null, arguments);\n  }\n\n  function _isNativeFunction(fn) {\n    return Function.toString.call(fn).indexOf('[native code]') !== -1;\n  }\n\n  function _wrapNativeSuper(Class) {\n    var _cache = typeof Map === 'function' ? new Map() : undefined;\n\n    _wrapNativeSuper = function _wrapNativeSuper(Class) {\n      if (Class === null || !_isNativeFunction(Class)) return Class;\n\n      if (typeof Class !== 'function') {\n        throw new TypeError(\n          'Super expression must either be null or a function'\n        );\n      }\n\n      if (typeof _cache !== 'undefined') {\n        if (_cache.has(Class)) return _cache.get(Class);\n\n        _cache.set(Class, Wrapper);\n      }\n\n      function Wrapper() {\n        return _construct(Class, arguments, _getPrototypeOf(this).constructor);\n      }\n\n      Wrapper.prototype = Object.create(Class.prototype, {\n        constructor: {\n          value: Wrapper,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      });\n      return _setPrototypeOf(Wrapper, Class);\n    };\n\n    return _wrapNativeSuper(Class);\n  }\n\n  function _instanceof(left, right) {\n    if (\n      right != null &&\n      typeof Symbol !== 'undefined' &&\n      right[Symbol.hasInstance]\n    ) {\n      return !!right[Symbol.hasInstance](left);\n    } else {\n      return left instanceof right;\n    }\n  }\n\n  function _interopRequireDefault(obj) {\n    return obj && obj.__esModule\n      ? obj\n      : {\n          default: obj\n        };\n  }\n\n  function _interopRequireWildcard(obj) {\n    if (obj && obj.__esModule) {\n      return obj;\n    } else {\n      var newObj = {};\n\n      if (obj != null) {\n        for (var key in obj) {\n          if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            var desc =\n              Object.defineProperty && Object.getOwnPropertyDescriptor\n                ? Object.getOwnPropertyDescriptor(obj, key)\n                : {};\n\n            if (desc.get || desc.set) {\n              Object.defineProperty(newObj, key, desc);\n            } else {\n              newObj[key] = obj[key];\n            }\n          }\n        }\n      }\n\n      newObj.default = obj;\n      return newObj;\n    }\n  }\n\n  function _newArrowCheck(innerThis, boundThis) {\n    if (innerThis !== boundThis) {\n      throw new TypeError('Cannot instantiate an arrow function');\n    }\n  }\n\n  function _objectDestructuringEmpty(obj) {\n    if (obj == null) throw new TypeError('Cannot destructure undefined');\n  }\n\n  function _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n\n    for (i = 0; i < sourceKeys.length; i++) {\n      key = sourceKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      target[key] = source[key];\n    }\n\n    return target;\n  }\n\n  function _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n\n    var key, i;\n\n    if (Object.getOwnPropertySymbols) {\n      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n      for (i = 0; i < sourceSymbolKeys.length; i++) {\n        key = sourceSymbolKeys[i];\n        if (excluded.indexOf(key) >= 0) continue;\n        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n        target[key] = source[key];\n      }\n    }\n\n    return target;\n  }\n\n  function _assertThisInitialized(self) {\n    if (self === void 0) {\n      throw new ReferenceError(\n        \"this hasn't been initialised - super() hasn't been called\"\n      );\n    }\n\n    return self;\n  }\n\n  function _possibleConstructorReturn(self, call) {\n    if (call && (typeof call === 'object' || typeof call === 'function')) {\n      return call;\n    }\n\n    return _assertThisInitialized(self);\n  }\n\n  function _superPropBase(object, property) {\n    while (!Object.prototype.hasOwnProperty.call(object, property)) {\n      object = _getPrototypeOf(object);\n      if (object === null) break;\n    }\n\n    return object;\n  }\n\n  function _get(target, property, receiver) {\n    if (typeof Reflect !== 'undefined' && Reflect.get) {\n      _get = Reflect.get;\n    } else {\n      _get = function _get(target, property, receiver) {\n        var base = _superPropBase(target, property);\n\n        if (!base) return;\n        var desc = Object.getOwnPropertyDescriptor(base, property);\n\n        if (desc.get) {\n          return desc.get.call(receiver);\n        }\n\n        return desc.value;\n      };\n    }\n\n    return _get(target, property, receiver || target);\n  }\n\n  function set(target, property, value, receiver) {\n    if (typeof Reflect !== 'undefined' && Reflect.set) {\n      set = Reflect.set;\n    } else {\n      set = function set(target, property, value, receiver) {\n        var base = _superPropBase(target, property);\n\n        var desc;\n\n        if (base) {\n          desc = Object.getOwnPropertyDescriptor(base, property);\n\n          if (desc.set) {\n            desc.set.call(receiver, value);\n            return true;\n          } else if (!desc.writable) {\n            return false;\n          }\n        }\n\n        desc = Object.getOwnPropertyDescriptor(receiver, property);\n\n        if (desc) {\n          if (!desc.writable) {\n            return false;\n          }\n\n          desc.value = value;\n          Object.defineProperty(receiver, property, desc);\n        } else {\n          _defineProperty(receiver, property, value);\n        }\n\n        return true;\n      };\n    }\n\n    return set(target, property, value, receiver);\n  }\n\n  function _set(target, property, value, receiver, isStrict) {\n    var s = set(target, property, value, receiver || target);\n\n    if (!s && isStrict) {\n      throw new Error('failed to set property');\n    }\n\n    return value;\n  }\n\n  function _taggedTemplateLiteral(strings, raw) {\n    if (!raw) {\n      raw = strings.slice(0);\n    }\n\n    return Object.freeze(\n      Object.defineProperties(strings, {\n        raw: {\n          value: Object.freeze(raw)\n        }\n      })\n    );\n  }\n\n  function _taggedTemplateLiteralLoose(strings, raw) {\n    if (!raw) {\n      raw = strings.slice(0);\n    }\n\n    strings.raw = raw;\n    return strings;\n  }\n\n  function _temporalRef(val, name) {\n    if (val === _temporalUndefined) {\n      throw new ReferenceError(name + ' is not defined - temporal dead zone');\n    } else {\n      return val;\n    }\n  }\n\n  function _readOnlyError(name) {\n    throw new Error('\"' + name + '\" is read-only');\n  }\n\n  function _classNameTDZError(name) {\n    throw new Error(\n      'Class \"' + name + '\" cannot be referenced in computed property keys.'\n    );\n  }\n\n  var _temporalUndefined = {};\n\n  function _slicedToArray(arr, i) {\n    return (\n      _arrayWithHoles(arr) ||\n      _iterableToArrayLimit(arr, i) ||\n      _nonIterableRest()\n    );\n  }\n\n  function _slicedToArrayLoose(arr, i) {\n    return (\n      _arrayWithHoles(arr) ||\n      _iterableToArrayLimitLoose(arr, i) ||\n      _nonIterableRest()\n    );\n  }\n\n  function _toArray(arr) {\n    return _arrayWithHoles(arr) || _iterableToArray(arr) || _nonIterableRest();\n  }\n\n  function _toConsumableArray(arr) {\n    return (\n      _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread()\n    );\n  }\n\n  function _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) {\n      for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++)\n        arr2[i] = arr[i];\n\n      return arr2;\n    }\n  }\n\n  function _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n  }\n\n  function _iterableToArray(iter) {\n    if (\n      Symbol.iterator in Object(iter) ||\n      Object.prototype.toString.call(iter) === '[object Arguments]'\n    )\n      return Array.from(iter);\n  }\n\n  function _iterableToArrayLimit(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (\n        var _i = arr[Symbol.iterator](), _s;\n        !(_n = (_s = _i.next()).done);\n        _n = true\n      ) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i['return'] != null) _i['return']();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  function _iterableToArrayLimitLoose(arr, i) {\n    var _arr = [];\n\n    for (\n      var _iterator = arr[Symbol.iterator](), _step;\n      !(_step = _iterator.next()).done;\n\n    ) {\n      _arr.push(_step.value);\n\n      if (i && _arr.length === i) break;\n    }\n\n    return _arr;\n  }\n\n  function _nonIterableSpread() {\n    throw new TypeError('Invalid attempt to spread non-iterable instance');\n  }\n\n  function _nonIterableRest() {\n    throw new TypeError('Invalid attempt to destructure non-iterable instance');\n  }\n\n  function _skipFirstGeneratorNext(fn) {\n    return function() {\n      var it = fn.apply(this, arguments);\n      it.next();\n      return it;\n    };\n  }\n\n  function _toPrimitive(input, hint) {\n    if (typeof input !== 'object' || input === null) return input;\n    var prim = input[Symbol.toPrimitive];\n\n    if (prim !== undefined) {\n      var res = prim.call(input, hint || 'default');\n      if (typeof res !== 'object') return res;\n      throw new TypeError('@@toPrimitive must return a primitive value.');\n    }\n\n    return (hint === 'string' ? String : Number)(input);\n  }\n\n  function _toPropertyKey(arg) {\n    var key = _toPrimitive(arg, 'string');\n\n    return typeof key === 'symbol' ? key : String(key);\n  }\n\n  function _initializerWarningHelper(descriptor, context) {\n    throw new Error(\n      'Decorating class property failed. Please ensure that ' +\n        'proposal-class-properties is enabled and set to use loose mode. ' +\n        'To use proposal-class-properties in spec mode with decorators, wait for ' +\n        'the next major version of decorators in stage 2.'\n    );\n  }\n\n  function _initializerDefineProperty(target, property, descriptor, context) {\n    if (!descriptor) return;\n    Object.defineProperty(target, property, {\n      enumerable: descriptor.enumerable,\n      configurable: descriptor.configurable,\n      writable: descriptor.writable,\n      value: descriptor.initializer\n        ? descriptor.initializer.call(context)\n        : void 0\n    });\n  }\n\n  function _applyDecoratedDescriptor(\n    target,\n    property,\n    decorators,\n    descriptor,\n    context\n  ) {\n    var desc = {};\n    Object.keys(descriptor).forEach(function(key) {\n      desc[key] = descriptor[key];\n    });\n    desc.enumerable = !!desc.enumerable;\n    desc.configurable = !!desc.configurable;\n\n    if ('value' in desc || desc.initializer) {\n      desc.writable = true;\n    }\n\n    desc = decorators\n      .slice()\n      .reverse()\n      .reduce(function(desc, decorator) {\n        return decorator(target, property, desc) || desc;\n      }, desc);\n\n    if (context && desc.initializer !== void 0) {\n      desc.value = desc.initializer ? desc.initializer.call(context) : void 0;\n      desc.initializer = undefined;\n    }\n\n    if (desc.initializer === void 0) {\n      Object.defineProperty(target, property, desc);\n      desc = null;\n    }\n\n    return desc;\n  }\n\n  var id = 0;\n\n  function _classPrivateFieldLooseKey(name) {\n    return '__private_' + id++ + '_' + name;\n  }\n\n  function _classPrivateFieldLooseBase(receiver, privateKey) {\n    if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {\n      throw new TypeError('attempted to use private field on non-instance');\n    }\n\n    return receiver;\n  }\n\n  function _classPrivateFieldGet(receiver, privateMap) {\n    var descriptor = privateMap.get(receiver);\n\n    if (!descriptor) {\n      throw new TypeError('attempted to get private field on non-instance');\n    }\n\n    if (descriptor.get) {\n      return descriptor.get.call(receiver);\n    }\n\n    return descriptor.value;\n  }\n\n  function _classPrivateFieldSet(receiver, privateMap, value) {\n    var descriptor = privateMap.get(receiver);\n\n    if (!descriptor) {\n      throw new TypeError('attempted to set private field on non-instance');\n    }\n\n    if (descriptor.set) {\n      descriptor.set.call(receiver, value);\n    } else {\n      if (!descriptor.writable) {\n        throw new TypeError('attempted to set read only private field');\n      }\n\n      descriptor.value = value;\n    }\n\n    return value;\n  }\n\n  function _classPrivateFieldDestructureSet(receiver, privateMap) {\n    if (!privateMap.has(receiver)) {\n      throw new TypeError('attempted to set private field on non-instance');\n    }\n\n    var descriptor = privateMap.get(receiver);\n\n    if (descriptor.set) {\n      if (!('__destrObj' in descriptor)) {\n        descriptor.__destrObj = {\n          set value(v) {\n            descriptor.set.call(receiver, v);\n          }\n        };\n      }\n\n      return descriptor.__destrObj;\n    } else {\n      if (!descriptor.writable) {\n        throw new TypeError('attempted to set read only private field');\n      }\n\n      return descriptor;\n    }\n  }\n\n  function _classStaticPrivateFieldSpecGet(\n    receiver,\n    classConstructor,\n    descriptor\n  ) {\n    if (receiver !== classConstructor) {\n      throw new TypeError('Private static access of wrong provenance');\n    }\n\n    return descriptor.value;\n  }\n\n  function _classStaticPrivateFieldSpecSet(\n    receiver,\n    classConstructor,\n    descriptor,\n    value\n  ) {\n    if (receiver !== classConstructor) {\n      throw new TypeError('Private static access of wrong provenance');\n    }\n\n    if (!descriptor.writable) {\n      throw new TypeError('attempted to set read only private field');\n    }\n\n    descriptor.value = value;\n    return value;\n  }\n\n  function _classStaticPrivateMethodGet(receiver, classConstructor, method) {\n    if (receiver !== classConstructor) {\n      throw new TypeError('Private static access of wrong provenance');\n    }\n\n    return method;\n  }\n\n  function _classStaticPrivateMethodSet() {\n    throw new TypeError('attempted to set read only static private field');\n  }\n\n  function _decorate(decorators, factory, superClass, mixins) {\n    var api = _getDecoratorsApi();\n\n    if (mixins) {\n      for (var i = 0; i < mixins.length; i++) {\n        api = mixins[i](api);\n      }\n    }\n\n    var r = factory(function initialize(O) {\n      api.initializeInstanceElements(O, decorated.elements);\n    }, superClass);\n    var decorated = api.decorateClass(\n      _coalesceClassElements(r.d.map(_createElementDescriptor)),\n      decorators\n    );\n    api.initializeClassElements(r.F, decorated.elements);\n    return api.runClassFinishers(r.F, decorated.finishers);\n  }\n\n  function _getDecoratorsApi() {\n    _getDecoratorsApi = function() {\n      return api;\n    };\n\n    var api = {\n      elementsDefinitionOrder: [['method'], ['field']],\n      initializeInstanceElements: function(O, elements) {\n        ['method', 'field'].forEach(function(kind) {\n          elements.forEach(function(element) {\n            if (element.kind === kind && element.placement === 'own') {\n              this.defineClassElement(O, element);\n            }\n          }, this);\n        }, this);\n      },\n      initializeClassElements: function(F, elements) {\n        var proto = F.prototype;\n        ['method', 'field'].forEach(function(kind) {\n          elements.forEach(function(element) {\n            var placement = element.placement;\n\n            if (\n              element.kind === kind &&\n              (placement === 'static' || placement === 'prototype')\n            ) {\n              var receiver = placement === 'static' ? F : proto;\n              this.defineClassElement(receiver, element);\n            }\n          }, this);\n        }, this);\n      },\n      defineClassElement: function(receiver, element) {\n        var descriptor = element.descriptor;\n\n        if (element.kind === 'field') {\n          var initializer = element.initializer;\n          descriptor = {\n            enumerable: descriptor.enumerable,\n            writable: descriptor.writable,\n            configurable: descriptor.configurable,\n            value: initializer === void 0 ? void 0 : initializer.call(receiver)\n          };\n        }\n\n        Object.defineProperty(receiver, element.key, descriptor);\n      },\n      decorateClass: function(elements, decorators) {\n        var newElements = [];\n        var finishers = [];\n        var placements = {\n          static: [],\n          prototype: [],\n          own: []\n        };\n        elements.forEach(function(element) {\n          this.addElementPlacement(element, placements);\n        }, this);\n        elements.forEach(function(element) {\n          if (!_hasDecorators(element)) return newElements.push(element);\n          var elementFinishersExtras = this.decorateElement(\n            element,\n            placements\n          );\n          newElements.push(elementFinishersExtras.element);\n          newElements.push.apply(newElements, elementFinishersExtras.extras);\n          finishers.push.apply(finishers, elementFinishersExtras.finishers);\n        }, this);\n\n        if (!decorators) {\n          return {\n            elements: newElements,\n            finishers: finishers\n          };\n        }\n\n        var result = this.decorateConstructor(newElements, decorators);\n        finishers.push.apply(finishers, result.finishers);\n        result.finishers = finishers;\n        return result;\n      },\n      addElementPlacement: function(element, placements, silent) {\n        var keys = placements[element.placement];\n\n        if (!silent && keys.indexOf(element.key) !== -1) {\n          throw new TypeError('Duplicated element (' + element.key + ')');\n        }\n\n        keys.push(element.key);\n      },\n      decorateElement: function(element, placements) {\n        var extras = [];\n        var finishers = [];\n\n        for (\n          var decorators = element.decorators, i = decorators.length - 1;\n          i >= 0;\n          i--\n        ) {\n          var keys = placements[element.placement];\n          keys.splice(keys.indexOf(element.key), 1);\n          var elementObject = this.fromElementDescriptor(element);\n          var elementFinisherExtras = this.toElementFinisherExtras(\n            (0, decorators[i])(elementObject) || elementObject\n          );\n          element = elementFinisherExtras.element;\n          this.addElementPlacement(element, placements);\n\n          if (elementFinisherExtras.finisher) {\n            finishers.push(elementFinisherExtras.finisher);\n          }\n\n          var newExtras = elementFinisherExtras.extras;\n\n          if (newExtras) {\n            for (var j = 0; j < newExtras.length; j++) {\n              this.addElementPlacement(newExtras[j], placements);\n            }\n\n            extras.push.apply(extras, newExtras);\n          }\n        }\n\n        return {\n          element: element,\n          finishers: finishers,\n          extras: extras\n        };\n      },\n      decorateConstructor: function(elements, decorators) {\n        var finishers = [];\n\n        for (var i = decorators.length - 1; i >= 0; i--) {\n          var obj = this.fromClassDescriptor(elements);\n          var elementsAndFinisher = this.toClassDescriptor(\n            (0, decorators[i])(obj) || obj\n          );\n\n          if (elementsAndFinisher.finisher !== undefined) {\n            finishers.push(elementsAndFinisher.finisher);\n          }\n\n          if (elementsAndFinisher.elements !== undefined) {\n            elements = elementsAndFinisher.elements;\n\n            for (var j = 0; j < elements.length - 1; j++) {\n              for (var k = j + 1; k < elements.length; k++) {\n                if (\n                  elements[j].key === elements[k].key &&\n                  elements[j].placement === elements[k].placement\n                ) {\n                  throw new TypeError(\n                    'Duplicated element (' + elements[j].key + ')'\n                  );\n                }\n              }\n            }\n          }\n        }\n\n        return {\n          elements: elements,\n          finishers: finishers\n        };\n      },\n      fromElementDescriptor: function(element) {\n        var obj = {\n          kind: element.kind,\n          key: element.key,\n          placement: element.placement,\n          descriptor: element.descriptor\n        };\n        var desc = {\n          value: 'Descriptor',\n          configurable: true\n        };\n        Object.defineProperty(obj, Symbol.toStringTag, desc);\n        if (element.kind === 'field') obj.initializer = element.initializer;\n        return obj;\n      },\n      toElementDescriptors: function(elementObjects) {\n        if (elementObjects === undefined) return;\n        return _toArray(elementObjects).map(function(elementObject) {\n          var element = this.toElementDescriptor(elementObject);\n          this.disallowProperty(\n            elementObject,\n            'finisher',\n            'An element descriptor'\n          );\n          this.disallowProperty(\n            elementObject,\n            'extras',\n            'An element descriptor'\n          );\n          return element;\n        }, this);\n      },\n      toElementDescriptor: function(elementObject) {\n        var kind = String(elementObject.kind);\n\n        if (kind !== 'method' && kind !== 'field') {\n          throw new TypeError(\n            'An element descriptor\\'s .kind property must be either \"method\" or' +\n              ' \"field\", but a decorator created an element descriptor with' +\n              ' .kind \"' +\n              kind +\n              '\"'\n          );\n        }\n\n        var key = _toPropertyKey(elementObject.key);\n\n        var placement = String(elementObject.placement);\n\n        if (\n          placement !== 'static' &&\n          placement !== 'prototype' &&\n          placement !== 'own'\n        ) {\n          throw new TypeError(\n            'An element descriptor\\'s .placement property must be one of \"static\",' +\n              ' \"prototype\" or \"own\", but a decorator created an element descriptor' +\n              ' with .placement \"' +\n              placement +\n              '\"'\n          );\n        }\n\n        var descriptor = elementObject.descriptor;\n        this.disallowProperty(\n          elementObject,\n          'elements',\n          'An element descriptor'\n        );\n        var element = {\n          kind: kind,\n          key: key,\n          placement: placement,\n          descriptor: Object.assign({}, descriptor)\n        };\n\n        if (kind !== 'field') {\n          this.disallowProperty(\n            elementObject,\n            'initializer',\n            'A method descriptor'\n          );\n        } else {\n          this.disallowProperty(\n            descriptor,\n            'get',\n            'The property descriptor of a field descriptor'\n          );\n          this.disallowProperty(\n            descriptor,\n            'set',\n            'The property descriptor of a field descriptor'\n          );\n          this.disallowProperty(\n            descriptor,\n            'value',\n            'The property descriptor of a field descriptor'\n          );\n          element.initializer = elementObject.initializer;\n        }\n\n        return element;\n      },\n      toElementFinisherExtras: function(elementObject) {\n        var element = this.toElementDescriptor(elementObject);\n\n        var finisher = _optionalCallableProperty(elementObject, 'finisher');\n\n        var extras = this.toElementDescriptors(elementObject.extras);\n        return {\n          element: element,\n          finisher: finisher,\n          extras: extras\n        };\n      },\n      fromClassDescriptor: function(elements) {\n        var obj = {\n          kind: 'class',\n          elements: elements.map(this.fromElementDescriptor, this)\n        };\n        var desc = {\n          value: 'Descriptor',\n          configurable: true\n        };\n        Object.defineProperty(obj, Symbol.toStringTag, desc);\n        return obj;\n      },\n      toClassDescriptor: function(obj) {\n        var kind = String(obj.kind);\n\n        if (kind !== 'class') {\n          throw new TypeError(\n            'A class descriptor\\'s .kind property must be \"class\", but a decorator' +\n              ' created a class descriptor with .kind \"' +\n              kind +\n              '\"'\n          );\n        }\n\n        this.disallowProperty(obj, 'key', 'A class descriptor');\n        this.disallowProperty(obj, 'placement', 'A class descriptor');\n        this.disallowProperty(obj, 'descriptor', 'A class descriptor');\n        this.disallowProperty(obj, 'initializer', 'A class descriptor');\n        this.disallowProperty(obj, 'extras', 'A class descriptor');\n\n        var finisher = _optionalCallableProperty(obj, 'finisher');\n\n        var elements = this.toElementDescriptors(obj.elements);\n        return {\n          elements: elements,\n          finisher: finisher\n        };\n      },\n      runClassFinishers: function(constructor, finishers) {\n        for (var i = 0; i < finishers.length; i++) {\n          var newConstructor = (0, finishers[i])(constructor);\n\n          if (newConstructor !== undefined) {\n            if (typeof newConstructor !== 'function') {\n              throw new TypeError('Finishers must return a constructor.');\n            }\n\n            constructor = newConstructor;\n          }\n        }\n\n        return constructor;\n      },\n      disallowProperty: function(obj, name, objectType) {\n        if (obj[name] !== undefined) {\n          throw new TypeError(\n            objectType + \" can't have a .\" + name + ' property.'\n          );\n        }\n      }\n    };\n    return api;\n  }\n\n  function _createElementDescriptor(def) {\n    var key = _toPropertyKey(def.key);\n\n    var descriptor;\n\n    if (def.kind === 'method') {\n      descriptor = {\n        value: def.value,\n        writable: true,\n        configurable: true,\n        enumerable: false\n      };\n    } else if (def.kind === 'get') {\n      descriptor = {\n        get: def.value,\n        configurable: true,\n        enumerable: false\n      };\n    } else if (def.kind === 'set') {\n      descriptor = {\n        set: def.value,\n        configurable: true,\n        enumerable: false\n      };\n    } else if (def.kind === 'field') {\n      descriptor = {\n        configurable: true,\n        writable: true,\n        enumerable: true\n      };\n    }\n\n    var element = {\n      kind: def.kind === 'field' ? 'field' : 'method',\n      key: key,\n      placement: def.static\n        ? 'static'\n        : def.kind === 'field'\n        ? 'own'\n        : 'prototype',\n      descriptor: descriptor\n    };\n    if (def.decorators) element.decorators = def.decorators;\n    if (def.kind === 'field') element.initializer = def.value;\n    return element;\n  }\n\n  function _coalesceGetterSetter(element, other) {\n    if (element.descriptor.get !== undefined) {\n      other.descriptor.get = element.descriptor.get;\n    } else {\n      other.descriptor.set = element.descriptor.set;\n    }\n  }\n\n  function _coalesceClassElements(elements) {\n    var newElements = [];\n\n    var isSameElement = function(other) {\n      return (\n        other.kind === 'method' &&\n        other.key === element.key &&\n        other.placement === element.placement\n      );\n    };\n\n    for (var i = 0; i < elements.length; i++) {\n      var element = elements[i];\n      var other;\n\n      if (\n        element.kind === 'method' &&\n        (other = newElements.find(isSameElement))\n      ) {\n        if (\n          _isDataDescriptor(element.descriptor) ||\n          _isDataDescriptor(other.descriptor)\n        ) {\n          if (_hasDecorators(element) || _hasDecorators(other)) {\n            throw new ReferenceError(\n              'Duplicated methods (' + element.key + \") can't be decorated.\"\n            );\n          }\n\n          other.descriptor = element.descriptor;\n        } else {\n          if (_hasDecorators(element)) {\n            if (_hasDecorators(other)) {\n              throw new ReferenceError(\n                \"Decorators can't be placed on different accessors with for \" +\n                  'the same property (' +\n                  element.key +\n                  ').'\n              );\n            }\n\n            other.decorators = element.decorators;\n          }\n\n          _coalesceGetterSetter(element, other);\n        }\n      } else {\n        newElements.push(element);\n      }\n    }\n\n    return newElements;\n  }\n\n  function _hasDecorators(element) {\n    return element.decorators && element.decorators.length;\n  }\n\n  function _isDataDescriptor(desc) {\n    return (\n      desc !== undefined &&\n      !(desc.value === undefined && desc.writable === undefined)\n    );\n  }\n\n  function _optionalCallableProperty(obj, name) {\n    var value = obj[name];\n\n    if (value !== undefined && typeof value !== 'function') {\n      throw new TypeError(\"Expected '\" + name + \"' to be a function\");\n    }\n\n    return value;\n  }\n\n  function _classPrivateMethodGet(receiver, privateSet, fn) {\n    if (!privateSet.has(receiver)) {\n      throw new TypeError('attempted to get private field on non-instance');\n    }\n\n    return fn;\n  }\n\n  function _classPrivateMethodSet() {\n    throw new TypeError('attempted to reassign private method');\n  }\n\n  function _wrapRegExp(re, groups) {\n    _wrapRegExp = function(re, groups) {\n      return new BabelRegExp(re, groups);\n    };\n\n    var _RegExp = _wrapNativeSuper(RegExp);\n\n    var _super = RegExp.prototype;\n\n    var _groups = new WeakMap();\n\n    function BabelRegExp(re, groups) {\n      var _this = _RegExp.call(this, re);\n\n      _groups.set(_this, groups);\n\n      return _this;\n    }\n\n    _inherits(BabelRegExp, _RegExp);\n\n    BabelRegExp.prototype.exec = function(str) {\n      var result = _super.exec.call(this, str);\n\n      if (result) result.groups = buildGroups(result, this);\n      return result;\n    };\n\n    BabelRegExp.prototype[Symbol.replace] = function(str, substitution) {\n      if (typeof substitution === 'string') {\n        var groups = _groups.get(this);\n\n        return _super[Symbol.replace].call(\n          this,\n          str,\n          substitution.replace(/\\$<([^>]+)>/g, function(_, name) {\n            return '$' + groups[name];\n          })\n        );\n      } else if (typeof substitution === 'function') {\n        var _this = this;\n\n        return _super[Symbol.replace].call(this, str, function() {\n          var args = [];\n          args.push.apply(args, arguments);\n\n          if (typeof args[args.length - 1] !== 'object') {\n            args.push(buildGroups(args, _this));\n          }\n\n          return substitution.apply(this, args);\n        });\n      } else {\n        return _super[Symbol.replace].call(this, str, substitution);\n      }\n    };\n\n    function buildGroups(result, re) {\n      var g = _groups.get(re);\n\n      return Object.keys(g).reduce(function(groups, name) {\n        groups[name] = result[g[name]];\n        return groups;\n      }, Object.create(null));\n    }\n\n    return _wrapRegExp.apply(this, arguments);\n  }\n\n  var arrayRemove = function arrayRemove(arr, index) {\n    return arr.splice(index, 1);\n  };\n\n  var run = function run(cb, sync) {\n    if (sync) {\n      cb();\n    } else if (document.hidden) {\n      Promise.resolve(1).then(cb);\n    } else {\n      setTimeout(cb, 0);\n    }\n  };\n\n  var on = function on() {\n    var listeners = [];\n    var off = function off(event, cb) {\n      arrayRemove(\n        listeners,\n        listeners.findIndex(function(listener) {\n          return listener.event === event && (listener.cb === cb || !cb);\n        })\n      );\n    };\n    var _fire = function fire(event, args, sync) {\n      listeners\n        .filter(function(listener) {\n          return listener.event === event;\n        })\n        .map(function(listener) {\n          return listener.cb;\n        })\n        .forEach(function(cb) {\n          return run(function() {\n            return cb.apply(void 0, _toConsumableArray(args));\n          }, sync);\n        });\n    };\n    return {\n      fireSync: function fireSync(event) {\n        for (\n          var _len = arguments.length,\n            args = new Array(_len > 1 ? _len - 1 : 0),\n            _key = 1;\n          _key < _len;\n          _key++\n        ) {\n          args[_key - 1] = arguments[_key];\n        }\n        _fire(event, args, true);\n      },\n      fire: function fire(event) {\n        for (\n          var _len2 = arguments.length,\n            args = new Array(_len2 > 1 ? _len2 - 1 : 0),\n            _key2 = 1;\n          _key2 < _len2;\n          _key2++\n        ) {\n          args[_key2 - 1] = arguments[_key2];\n        }\n        _fire(event, args, false);\n      },\n      on: function on(event, cb) {\n        listeners.push({ event: event, cb: cb });\n      },\n      onOnce: function onOnce(event, _cb) {\n        listeners.push({\n          event: event,\n          cb: function cb() {\n            off(event, _cb);\n            _cb.apply(void 0, arguments);\n          }\n        });\n      },\n      off: off\n    };\n  };\n\n  var copyObjectPropertiesToObject = function copyObjectPropertiesToObject(\n    src,\n    target,\n    excluded\n  ) {\n    Object.getOwnPropertyNames(src)\n      .filter(function(property) {\n        return !excluded.includes(property);\n      })\n      .forEach(function(key) {\n        return Object.defineProperty(\n          target,\n          key,\n          Object.getOwnPropertyDescriptor(src, key)\n        );\n      });\n  };\n\n  var PRIVATE = [\n    'fire',\n    'process',\n    'revert',\n    'load',\n    'on',\n    'off',\n    'onOnce',\n    'retryLoad',\n    'extend',\n    'archive',\n    'archived',\n    'release',\n    'released',\n    'requestProcessing',\n    'freeze'\n  ];\n\n  var createItemAPI = function createItemAPI(item) {\n    var api = {};\n    copyObjectPropertiesToObject(item, api, PRIVATE);\n    return api;\n  };\n\n  var removeReleasedItems = function removeReleasedItems(items) {\n    items.forEach(function(item, index) {\n      if (item.released) {\n        arrayRemove(items, index);\n      }\n    });\n  };\n\n  var ItemStatus = {\n    INIT: 1,\n    IDLE: 2,\n    PROCESSING_QUEUED: 9,\n    PROCESSING: 3,\n    PROCESSING_COMPLETE: 5,\n    PROCESSING_ERROR: 6,\n    PROCESSING_REVERT_ERROR: 10,\n    LOADING: 7,\n    LOAD_ERROR: 8\n  };\n\n  var FileOrigin = {\n    INPUT: 1,\n    LIMBO: 2,\n    LOCAL: 3\n  };\n\n  var getNonNumeric = function getNonNumeric(str) {\n    return /[^0-9]+/.exec(str);\n  };\n\n  var getDecimalSeparator = function getDecimalSeparator() {\n    return getNonNumeric((1.1).toLocaleString())[0];\n  };\n\n  var getThousandsSeparator = function getThousandsSeparator() {\n    // Added for browsers that do not return the thousands separator (happend on native browser Android 4.4.4)\n    // We check against the normal toString output and if they're the same return a comma when decimal separator is a dot\n    var decimalSeparator = getDecimalSeparator();\n    var thousandsStringWithSeparator = (1000.0).toLocaleString();\n    var thousandsStringWithoutSeparator = (1000.0).toString();\n    if (thousandsStringWithSeparator !== thousandsStringWithoutSeparator) {\n      return getNonNumeric(thousandsStringWithSeparator)[0];\n    }\n    return decimalSeparator === '.' ? ',' : '.';\n  };\n\n  var Type = {\n    BOOLEAN: 'boolean',\n    INT: 'int',\n    NUMBER: 'number',\n    STRING: 'string',\n    ARRAY: 'array',\n    OBJECT: 'object',\n    FUNCTION: 'function',\n    ACTION: 'action',\n    SERVER_API: 'serverapi',\n    REGEX: 'regex'\n  };\n\n  // all registered filters\n  var filters = [];\n\n  // loops over matching filters and passes options to each filter, returning the mapped results\n  var applyFilterChain = function applyFilterChain(key, value, utils) {\n    return new Promise(function(resolve, reject) {\n      // find matching filters for this key\n      var matchingFilters = filters\n        .filter(function(f) {\n          return f.key === key;\n        })\n        .map(function(f) {\n          return f.cb;\n        });\n\n      // resolve now\n      if (matchingFilters.length === 0) {\n        resolve(value);\n        return;\n      }\n\n      // first filter to kick things of\n      var initialFilter = matchingFilters.shift();\n\n      // chain filters\n      matchingFilters\n        .reduce(\n          // loop over promises passing value to next promise\n          function(current, next) {\n            return current.then(function(value) {\n              return next(value, utils);\n            });\n          },\n\n          // call initial filter, will return a promise\n          initialFilter(value, utils)\n\n          // all executed\n        )\n        .then(function(value) {\n          return resolve(value);\n        })\n        .catch(function(error) {\n          return reject(error);\n        });\n    });\n  };\n\n  var applyFilters = function applyFilters(key, value, utils) {\n    return filters\n      .filter(function(f) {\n        return f.key === key;\n      })\n      .map(function(f) {\n        return f.cb(value, utils);\n      });\n  };\n\n  // adds a new filter to the list\n  var addFilter = function addFilter(key, cb) {\n    return filters.push({ key: key, cb: cb });\n  };\n\n  var extendDefaultOptions = function extendDefaultOptions(additionalOptions) {\n    return Object.assign(defaultOptions, additionalOptions);\n  };\n\n  var getOptions = function getOptions() {\n    return Object.assign({}, defaultOptions);\n  };\n\n  var setOptions = function setOptions(opts) {\n    forin(opts, function(key, value) {\n      // key does not exist, so this option cannot be set\n      if (!defaultOptions[key]) {\n        return;\n      }\n      defaultOptions[key][0] = getValueByType(\n        value,\n        defaultOptions[key][0],\n        defaultOptions[key][1]\n      );\n    });\n  };\n\n  // default options on app\n  var defaultOptions = {\n    // the id to add to the root element\n    id: [null, Type.STRING],\n\n    // input field name to use\n    name: ['filepond', Type.STRING],\n\n    // disable the field\n    disabled: [false, Type.BOOLEAN],\n\n    // classname to put on wrapper\n    className: [null, Type.STRING],\n\n    // is the field required\n    required: [false, Type.BOOLEAN],\n\n    // Allow media capture when value is set\n    captureMethod: [null, Type.STRING],\n    // - \"camera\", \"microphone\" or \"camcorder\",\n    // - Does not work with multiple on apple devices\n    // - If set, acceptedFileTypes must be made to match with media wildcard \"image/*\", \"audio/*\" or \"video/*\"\n\n    // sync `acceptedFileTypes` property with `accept` attribute\n    allowSyncAcceptAttribute: [true, Type.BOOLEAN],\n\n    // Feature toggles\n    allowDrop: [true, Type.BOOLEAN], // Allow dropping of files\n    allowBrowse: [true, Type.BOOLEAN], // Allow browsing the file system\n    allowPaste: [true, Type.BOOLEAN], // Allow pasting files\n    allowMultiple: [false, Type.BOOLEAN], // Allow multiple files (disabled by default, as multiple attribute is also required on input to allow multiple)\n    allowReplace: [true, Type.BOOLEAN], // Allow dropping a file on other file to replace it (only works when multiple is set to false)\n    allowRevert: [true, Type.BOOLEAN], // Allows user to revert file upload\n    allowRemove: [true, Type.BOOLEAN], // Allow user to remove a file\n    allowProcess: [true, Type.BOOLEAN], // Allows user to process a file, when set to false, this removes the file upload button\n    allowReorder: [false, Type.BOOLEAN], // Allow reordering of files\n    allowDirectoriesOnly: [false, Type.BOOLEAN], // Allow only selecting directories with browse (no support for filtering dnd at this point)\n\n    // Revert mode\n    forceRevert: [false, Type.BOOLEAN], // Set to 'force' to require the file to be reverted before removal\n\n    // Input requirements\n    maxFiles: [null, Type.INT], // Max number of files\n    checkValidity: [false, Type.BOOLEAN], // Enables custom validity messages\n\n    // Where to put file\n    itemInsertLocationFreedom: [true, Type.BOOLEAN], // Set to false to always add items to begin or end of list\n    itemInsertLocation: ['before', Type.STRING], // Default index in list to add items that have been dropped at the top of the list\n    itemInsertInterval: [75, Type.INT],\n\n    // Drag 'n Drop related\n    dropOnPage: [false, Type.BOOLEAN], // Allow dropping of files anywhere on page (prevents browser from opening file if dropped outside of Up)\n    dropOnElement: [true, Type.BOOLEAN], // Drop needs to happen on element (set to false to also load drops outside of Up)\n    dropValidation: [false, Type.BOOLEAN], // Enable or disable validating files on drop\n    ignoredFiles: [['.ds_store', 'thumbs.db', 'desktop.ini'], Type.ARRAY],\n\n    // Upload related\n    instantUpload: [true, Type.BOOLEAN], // Should upload files immediately on drop\n    maxParallelUploads: [2, Type.INT], // Maximum files to upload in parallel\n\n    // Chunks\n    chunkUploads: [false, Type.BOOLEAN], // Enable chunked uploads\n    chunkForce: [false, Type.BOOLEAN], // Force use of chunk uploads even for files smaller than chunk size\n    chunkSize: [5000000, Type.INT], // Size of chunks (5MB default)\n    chunkRetryDelays: [[500, 1000, 3000], Type.Array], // Amount of times to retry upload of a chunk when it fails\n\n    // The server api end points to use for uploading (see docs)\n    server: [null, Type.SERVER_API],\n\n    // File size calculations, can set to 1024, this is only used for display, properties use file size base 1000\n    fileSizeBase: [1000, Type.INT],\n\n    // Labels and status messages\n    labelDecimalSeparator: [getDecimalSeparator(), Type.STRING], // Default is locale separator\n    labelThousandsSeparator: [getThousandsSeparator(), Type.STRING], // Default is locale separator\n\n    labelIdle: [\n      'Drag & Drop your files or <span class=\"filepond--label-action\">Browse</span>',\n      Type.STRING\n    ],\n    labelInvalidField: ['Field contains invalid files', Type.STRING],\n    labelFileWaitingForSize: ['Waiting for size', Type.STRING],\n    labelFileSizeNotAvailable: ['Size not available', Type.STRING],\n    labelFileCountSingular: ['file in list', Type.STRING],\n    labelFileCountPlural: ['files in list', Type.STRING],\n    labelFileLoading: ['Loading', Type.STRING],\n    labelFileAdded: ['Added', Type.STRING], // assistive only\n    labelFileLoadError: ['Error during load', Type.STRING],\n    labelFileRemoved: ['Removed', Type.STRING], // assistive only\n    labelFileRemoveError: ['Error during remove', Type.STRING],\n    labelFileProcessing: ['Uploading', Type.STRING],\n    labelFileProcessingComplete: ['Upload complete', Type.STRING],\n    labelFileProcessingAborted: ['Upload cancelled', Type.STRING],\n    labelFileProcessingError: ['Error during upload', Type.STRING],\n    labelFileProcessingRevertError: ['Error during revert', Type.STRING],\n\n    labelTapToCancel: ['tap to cancel', Type.STRING],\n    labelTapToRetry: ['tap to retry', Type.STRING],\n    labelTapToUndo: ['tap to undo', Type.STRING],\n\n    labelButtonRemoveItem: ['Remove', Type.STRING],\n    labelButtonAbortItemLoad: ['Abort', Type.STRING],\n    labelButtonRetryItemLoad: ['Retry', Type.STRING],\n    labelButtonAbortItemProcessing: ['Cancel', Type.STRING],\n    labelButtonUndoItemProcessing: ['Undo', Type.STRING],\n    labelButtonRetryItemProcessing: ['Retry', Type.STRING],\n    labelButtonProcessItem: ['Upload', Type.STRING],\n\n    // make sure width and height plus viewpox are even numbers so icons are nicely centered\n    iconRemove: [\n      '<svg width=\"26\" height=\"26\" viewBox=\"0 0 26 26\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M11.586 13l-2.293 2.293a1 1 0 0 0 1.414 1.414L13 14.414l2.293 2.293a1 1 0 0 0 1.414-1.414L14.414 13l2.293-2.293a1 1 0 0 0-1.414-1.414L13 11.586l-2.293-2.293a1 1 0 0 0-1.414 1.414L11.586 13z\" fill=\"currentColor\" fill-rule=\"nonzero\"/></svg>',\n      Type.STRING\n    ],\n\n    iconProcess: [\n      '<svg width=\"26\" height=\"26\" viewBox=\"0 0 26 26\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M14 10.414v3.585a1 1 0 0 1-2 0v-3.585l-1.293 1.293a1 1 0 0 1-1.414-1.415l3-3a1 1 0 0 1 1.414 0l3 3a1 1 0 0 1-1.414 1.415L14 10.414zM9 18a1 1 0 0 1 0-2h8a1 1 0 0 1 0 2H9z\" fill=\"currentColor\" fill-rule=\"evenodd\"/></svg>',\n      Type.STRING\n    ],\n\n    iconRetry: [\n      '<svg width=\"26\" height=\"26\" viewBox=\"0 0 26 26\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M10.81 9.185l-.038.02A4.997 4.997 0 0 0 8 13.683a5 5 0 0 0 5 5 5 5 0 0 0 5-5 1 1 0 0 1 2 0A7 7 0 1 1 9.722 7.496l-.842-.21a.999.999 0 1 1 .484-1.94l3.23.806c.535.133.86.675.73 1.21l-.804 3.233a.997.997 0 0 1-1.21.73.997.997 0 0 1-.73-1.21l.23-.928v-.002z\" fill=\"currentColor\" fill-rule=\"nonzero\"/></svg>',\n      Type.STRING\n    ],\n\n    iconUndo: [\n      '<svg width=\"26\" height=\"26\" viewBox=\"0 0 26 26\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M9.185 10.81l.02-.038A4.997 4.997 0 0 1 13.683 8a5 5 0 0 1 5 5 5 5 0 0 1-5 5 1 1 0 0 0 0 2A7 7 0 1 0 7.496 9.722l-.21-.842a.999.999 0 1 0-1.94.484l.806 3.23c.133.535.675.86 1.21.73l3.233-.803a.997.997 0 0 0 .73-1.21.997.997 0 0 0-1.21-.73l-.928.23-.002-.001z\" fill=\"currentColor\" fill-rule=\"nonzero\"/></svg>',\n      Type.STRING\n    ],\n\n    iconDone: [\n      '<svg width=\"26\" height=\"26\" viewBox=\"0 0 26 26\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M18.293 9.293a1 1 0 0 1 1.414 1.414l-7.002 7a1 1 0 0 1-1.414 0l-3.998-4a1 1 0 1 1 1.414-1.414L12 15.586l6.294-6.293z\" fill=\"currentColor\" fill-rule=\"nonzero\"/></svg>',\n      Type.STRING\n    ],\n\n    // event handlers\n    oninit: [null, Type.FUNCTION],\n    onwarning: [null, Type.FUNCTION],\n    onerror: [null, Type.FUNCTION],\n    onactivatefile: [null, Type.FUNCTION],\n    oninitfile: [null, Type.FUNCTION],\n    onaddfilestart: [null, Type.FUNCTION],\n    onaddfileprogress: [null, Type.FUNCTION],\n    onaddfile: [null, Type.FUNCTION],\n    onprocessfilestart: [null, Type.FUNCTION],\n    onprocessfileprogress: [null, Type.FUNCTION],\n    onprocessfileabort: [null, Type.FUNCTION],\n    onprocessfilerevert: [null, Type.FUNCTION],\n    onprocessfile: [null, Type.FUNCTION],\n    onprocessfiles: [null, Type.FUNCTION],\n    onremovefile: [null, Type.FUNCTION],\n    onpreparefile: [null, Type.FUNCTION],\n    onupdatefiles: [null, Type.FUNCTION],\n    onreorderfiles: [null, Type.FUNCTION],\n\n    // hooks\n    beforeDropFile: [null, Type.FUNCTION],\n    beforeAddFile: [null, Type.FUNCTION],\n    beforeRemoveFile: [null, Type.FUNCTION],\n\n    // styles\n    stylePanelLayout: [null, Type.STRING], // null 'integrated', 'compact', 'circle'\n    stylePanelAspectRatio: [null, Type.STRING], // null or '3:2' or 1\n    styleItemPanelAspectRatio: [null, Type.STRING],\n    styleButtonRemoveItemPosition: ['left', Type.STRING],\n    styleButtonProcessItemPosition: ['right', Type.STRING],\n    styleLoadIndicatorPosition: ['right', Type.STRING],\n    styleProgressIndicatorPosition: ['right', Type.STRING],\n    styleButtonRemoveItemAlign: [false, Type.BOOLEAN],\n\n    // custom initial files array\n    files: [[], Type.ARRAY],\n\n    // show support by displaying credits\n    credits: [['https://pqina.nl/', 'Powered by PQINA'], Type.ARRAY]\n  };\n\n  var getItemByQuery = function getItemByQuery(items, query) {\n    // just return first index\n    if (isEmpty(query)) {\n      return items[0] || null;\n    }\n\n    // query is index\n    if (isInt(query)) {\n      return items[query] || null;\n    }\n\n    // if query is item, get the id\n    if (typeof query === 'object') {\n      query = query.id;\n    }\n\n    // assume query is a string and return item by id\n    return (\n      items.find(function(item) {\n        return item.id === query;\n      }) || null\n    );\n  };\n\n  var getNumericAspectRatioFromString = function getNumericAspectRatioFromString(\n    aspectRatio\n  ) {\n    if (isEmpty(aspectRatio)) {\n      return aspectRatio;\n    }\n    if (/:/.test(aspectRatio)) {\n      var parts = aspectRatio.split(':');\n      return parts[1] / parts[0];\n    }\n    return parseFloat(aspectRatio);\n  };\n\n  var getActiveItems = function getActiveItems(items) {\n    return items.filter(function(item) {\n      return !item.archived;\n    });\n  };\n\n  var Status = {\n    EMPTY: 0,\n    IDLE: 1, // waiting\n    ERROR: 2, // a file is in error state\n    BUSY: 3, // busy processing or loading\n    READY: 4 // all files uploaded\n  };\n\n  var ITEM_ERROR = [\n    ItemStatus.LOAD_ERROR,\n    ItemStatus.PROCESSING_ERROR,\n    ItemStatus.PROCESSING_REVERT_ERROR\n  ];\n  var ITEM_BUSY = [\n    ItemStatus.LOADING,\n    ItemStatus.PROCESSING,\n    ItemStatus.PROCESSING_QUEUED,\n    ItemStatus.INIT\n  ];\n  var ITEM_READY = [ItemStatus.PROCESSING_COMPLETE];\n\n  var isItemInErrorState = function isItemInErrorState(item) {\n    return ITEM_ERROR.includes(item.status);\n  };\n  var isItemInBusyState = function isItemInBusyState(item) {\n    return ITEM_BUSY.includes(item.status);\n  };\n  var isItemInReadyState = function isItemInReadyState(item) {\n    return ITEM_READY.includes(item.status);\n  };\n\n  var queries = function queries(state) {\n    return {\n      GET_STATUS: function GET_STATUS() {\n        var items = getActiveItems(state.items);\n        var EMPTY = Status.EMPTY,\n          ERROR = Status.ERROR,\n          BUSY = Status.BUSY,\n          IDLE = Status.IDLE,\n          READY = Status.READY;\n\n        if (items.length === 0) return EMPTY;\n\n        if (items.some(isItemInErrorState)) return ERROR;\n\n        if (items.some(isItemInBusyState)) return BUSY;\n\n        if (items.some(isItemInReadyState)) return READY;\n\n        return IDLE;\n      },\n\n      GET_ITEM: function GET_ITEM(query) {\n        return getItemByQuery(state.items, query);\n      },\n\n      GET_ACTIVE_ITEM: function GET_ACTIVE_ITEM(query) {\n        return getItemByQuery(getActiveItems(state.items), query);\n      },\n\n      GET_ACTIVE_ITEMS: function GET_ACTIVE_ITEMS() {\n        return getActiveItems(state.items);\n      },\n\n      GET_ITEMS: function GET_ITEMS() {\n        return state.items;\n      },\n\n      GET_ITEM_NAME: function GET_ITEM_NAME(query) {\n        var item = getItemByQuery(state.items, query);\n        return item ? item.filename : null;\n      },\n\n      GET_ITEM_SIZE: function GET_ITEM_SIZE(query) {\n        var item = getItemByQuery(state.items, query);\n        return item ? item.fileSize : null;\n      },\n\n      GET_STYLES: function GET_STYLES() {\n        return Object.keys(state.options)\n          .filter(function(key) {\n            return /^style/.test(key);\n          })\n          .map(function(option) {\n            return {\n              name: option,\n              value: state.options[option]\n            };\n          });\n      },\n\n      GET_PANEL_ASPECT_RATIO: function GET_PANEL_ASPECT_RATIO() {\n        var isShapeCircle = /circle/.test(state.options.stylePanelLayout);\n        var aspectRatio = isShapeCircle\n          ? 1\n          : getNumericAspectRatioFromString(\n              state.options.stylePanelAspectRatio\n            );\n        return aspectRatio;\n      },\n\n      GET_ITEM_PANEL_ASPECT_RATIO: function GET_ITEM_PANEL_ASPECT_RATIO() {\n        return state.options.styleItemPanelAspectRatio;\n      },\n\n      GET_ITEMS_BY_STATUS: function GET_ITEMS_BY_STATUS(status) {\n        return getActiveItems(state.items).filter(function(item) {\n          return item.status === status;\n        });\n      },\n\n      GET_TOTAL_ITEMS: function GET_TOTAL_ITEMS() {\n        return getActiveItems(state.items).length;\n      },\n\n      IS_ASYNC: function IS_ASYNC() {\n        return (\n          isObject(state.options.server) &&\n          (isObject(state.options.server.process) ||\n            isFunction(state.options.server.process))\n        );\n      }\n    };\n  };\n\n  var hasRoomForItem = function hasRoomForItem(state) {\n    var count = getActiveItems(state.items).length;\n\n    // if cannot have multiple items, to add one item it should currently not contain items\n    if (!state.options.allowMultiple) {\n      return count === 0;\n    }\n\n    // if allows multiple items, we check if a max item count has been set, if not, there's no limit\n    var maxFileCount = state.options.maxFiles;\n    if (maxFileCount === null) {\n      return true;\n    }\n\n    // we check if the current count is smaller than the max count, if so, another file can still be added\n    if (count < maxFileCount) {\n      return true;\n    }\n\n    // no more room for another file\n    return false;\n  };\n\n  var limit = function limit(value, min, max) {\n    return Math.max(Math.min(max, value), min);\n  };\n\n  var arrayInsert = function arrayInsert(arr, index, item) {\n    return arr.splice(index, 0, item);\n  };\n\n  var insertItem = function insertItem(items, item, index) {\n    if (isEmpty(item)) {\n      return null;\n    }\n\n    // if index is undefined, append\n    if (typeof index === 'undefined') {\n      items.push(item);\n      return item;\n    }\n\n    // limit the index to the size of the items array\n    index = limit(index, 0, items.length);\n\n    // add item to array\n    arrayInsert(items, index, item);\n\n    // expose\n    return item;\n  };\n\n  var isBase64DataURI = function isBase64DataURI(str) {\n    return /^\\s*data:([a-z]+\\/[a-z0-9-+.]+(;[a-z-]+=[a-z0-9-]+)?)?(;base64)?,([a-z0-9!$&',()*+;=\\-._~:@\\/?%\\s]*)\\s*$/i.test(\n      str\n    );\n  };\n\n  var getFilenameFromURL = function getFilenameFromURL(url) {\n    return url\n      .split('/')\n      .pop()\n      .split('?')\n      .shift();\n  };\n\n  var getExtensionFromFilename = function getExtensionFromFilename(name) {\n    return name.split('.').pop();\n  };\n\n  var guesstimateExtension = function guesstimateExtension(type) {\n    // if no extension supplied, exit here\n    if (typeof type !== 'string') {\n      return '';\n    }\n\n    // get subtype\n    var subtype = type.split('/').pop();\n\n    // is svg subtype\n    if (/svg/.test(subtype)) {\n      return 'svg';\n    }\n\n    if (/zip|compressed/.test(subtype)) {\n      return 'zip';\n    }\n\n    if (/plain/.test(subtype)) {\n      return 'txt';\n    }\n\n    if (/msword/.test(subtype)) {\n      return 'doc';\n    }\n\n    // if is valid subtype\n    if (/[a-z]+/.test(subtype)) {\n      // always use jpg extension\n      if (subtype === 'jpeg') {\n        return 'jpg';\n      }\n\n      // return subtype\n      return subtype;\n    }\n\n    return '';\n  };\n\n  var leftPad = function leftPad(value) {\n    var padding =\n      arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n    return (padding + value).slice(-padding.length);\n  };\n\n  var getDateString = function getDateString() {\n    var date =\n      arguments.length > 0 && arguments[0] !== undefined\n        ? arguments[0]\n        : new Date();\n    return (\n      date.getFullYear() +\n      '-' +\n      leftPad(date.getMonth() + 1, '00') +\n      '-' +\n      leftPad(date.getDate(), '00') +\n      '_' +\n      leftPad(date.getHours(), '00') +\n      '-' +\n      leftPad(date.getMinutes(), '00') +\n      '-' +\n      leftPad(date.getSeconds(), '00')\n    );\n  };\n\n  var getFileFromBlob = function getFileFromBlob(blob, filename) {\n    var type =\n      arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    var extension =\n      arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    var file =\n      typeof type === 'string'\n        ? blob.slice(0, blob.size, type)\n        : blob.slice(0, blob.size, blob.type);\n    file.lastModifiedDate = new Date();\n\n    // copy relative path\n    if (blob._relativePath) file._relativePath = blob._relativePath;\n\n    // if blob has name property, use as filename if no filename supplied\n    if (!isString(filename)) {\n      filename = getDateString();\n    }\n\n    // if filename supplied but no extension and filename has extension\n    if (filename && extension === null && getExtensionFromFilename(filename)) {\n      file.name = filename;\n    } else {\n      extension = extension || guesstimateExtension(file.type);\n      file.name = filename + (extension ? '.' + extension : '');\n    }\n\n    return file;\n  };\n\n  var getBlobBuilder = function getBlobBuilder() {\n    return (window.BlobBuilder =\n      window.BlobBuilder ||\n      window.WebKitBlobBuilder ||\n      window.MozBlobBuilder ||\n      window.MSBlobBuilder);\n  };\n\n  var createBlob = function createBlob(arrayBuffer, mimeType) {\n    var BB = getBlobBuilder();\n\n    if (BB) {\n      var bb = new BB();\n      bb.append(arrayBuffer);\n      return bb.getBlob(mimeType);\n    }\n\n    return new Blob([arrayBuffer], {\n      type: mimeType\n    });\n  };\n\n  var getBlobFromByteStringWithMimeType = function getBlobFromByteStringWithMimeType(\n    byteString,\n    mimeType\n  ) {\n    var ab = new ArrayBuffer(byteString.length);\n    var ia = new Uint8Array(ab);\n\n    for (var i = 0; i < byteString.length; i++) {\n      ia[i] = byteString.charCodeAt(i);\n    }\n\n    return createBlob(ab, mimeType);\n  };\n\n  var getMimeTypeFromBase64DataURI = function getMimeTypeFromBase64DataURI(\n    dataURI\n  ) {\n    return (/^data:(.+);/.exec(dataURI) || [])[1] || null;\n  };\n\n  var getBase64DataFromBase64DataURI = function getBase64DataFromBase64DataURI(\n    dataURI\n  ) {\n    // get data part of string (remove data:image/jpeg...,)\n    var data = dataURI.split(',')[1];\n\n    // remove any whitespace as that causes InvalidCharacterError in IE\n    return data.replace(/\\s/g, '');\n  };\n\n  var getByteStringFromBase64DataURI = function getByteStringFromBase64DataURI(\n    dataURI\n  ) {\n    return atob(getBase64DataFromBase64DataURI(dataURI));\n  };\n\n  var getBlobFromBase64DataURI = function getBlobFromBase64DataURI(dataURI) {\n    var mimeType = getMimeTypeFromBase64DataURI(dataURI);\n    var byteString = getByteStringFromBase64DataURI(dataURI);\n\n    return getBlobFromByteStringWithMimeType(byteString, mimeType);\n  };\n\n  var getFileFromBase64DataURI = function getFileFromBase64DataURI(\n    dataURI,\n    filename,\n    extension\n  ) {\n    return getFileFromBlob(\n      getBlobFromBase64DataURI(dataURI),\n      filename,\n      null,\n      extension\n    );\n  };\n\n  var getFileNameFromHeader = function getFileNameFromHeader(header) {\n    // test if is content disposition header, if not exit\n    if (!/^content-disposition:/i.test(header)) return null;\n\n    // get filename parts\n    var matches = header\n      .split(/filename=|filename\\*=.+''/)\n      .splice(1)\n      .map(function(name) {\n        return name.trim().replace(/^[\"']|[;\"']{0,2}$/g, '');\n      })\n      .filter(function(name) {\n        return name.length;\n      });\n\n    return matches.length ? decodeURI(matches[matches.length - 1]) : null;\n  };\n\n  var getFileSizeFromHeader = function getFileSizeFromHeader(header) {\n    if (/content-length:/i.test(header)) {\n      var size = header.match(/[0-9]+/)[0];\n      return size ? parseInt(size, 10) : null;\n    }\n    return null;\n  };\n\n  var getTranfserIdFromHeader = function getTranfserIdFromHeader(header) {\n    if (/x-content-transfer-id:/i.test(header)) {\n      var id = (header.split(':')[1] || '').trim();\n      return id || null;\n    }\n    return null;\n  };\n\n  var getFileInfoFromHeaders = function getFileInfoFromHeaders(headers) {\n    var info = {\n      source: null,\n      name: null,\n      size: null\n    };\n\n    var rows = headers.split('\\n');\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n    try {\n      for (\n        var _iterator = rows[Symbol.iterator](), _step;\n        !(_iteratorNormalCompletion = (_step = _iterator.next()).done);\n        _iteratorNormalCompletion = true\n      ) {\n        var header = _step.value;\n\n        var name = getFileNameFromHeader(header);\n        if (name) {\n          info.name = name;\n          continue;\n        }\n\n        var size = getFileSizeFromHeader(header);\n        if (size) {\n          info.size = size;\n          continue;\n        }\n\n        var source = getTranfserIdFromHeader(header);\n        if (source) {\n          info.source = source;\n          continue;\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    return info;\n  };\n\n  var createFileLoader = function createFileLoader(fetchFn) {\n    var state = {\n      source: null,\n      complete: false,\n      progress: 0,\n      size: null,\n      timestamp: null,\n      duration: 0,\n      request: null\n    };\n\n    var getProgress = function getProgress() {\n      return state.progress;\n    };\n    var abort = function abort() {\n      if (state.request && state.request.abort) {\n        state.request.abort();\n      }\n    };\n\n    // load source\n    var load = function load() {\n      // get quick reference\n      var source = state.source;\n\n      api.fire('init', source);\n\n      // Load Files\n      if (source instanceof File) {\n        api.fire('load', source);\n      } else if (source instanceof Blob) {\n        // Load blobs, set default name to current date\n        api.fire('load', getFileFromBlob(source, source.name));\n      } else if (isBase64DataURI(source)) {\n        // Load base 64, set default name to current date\n        api.fire('load', getFileFromBase64DataURI(source));\n      } else {\n        // Deal as if is external URL, let's load it!\n        loadURL(source);\n      }\n    };\n\n    // loads a url\n    var loadURL = function loadURL(url) {\n      // is remote url and no fetch method supplied\n      if (!fetchFn) {\n        api.fire('error', {\n          type: 'error',\n          body: \"Can't load URL\",\n          code: 400\n        });\n\n        return;\n      }\n\n      // set request start\n      state.timestamp = Date.now();\n\n      // load file\n      state.request = fetchFn(\n        url,\n        function(response) {\n          // update duration\n          state.duration = Date.now() - state.timestamp;\n\n          // done!\n          state.complete = true;\n\n          // turn blob response into a file\n          if (response instanceof Blob) {\n            response = getFileFromBlob(\n              response,\n              response.name || getFilenameFromURL(url)\n            );\n          }\n\n          api.fire(\n            'load',\n            // if has received blob, we go with blob, if no response, we return null\n            response instanceof Blob\n              ? response\n              : response\n              ? response.body\n              : null\n          );\n        },\n        function(error) {\n          api.fire(\n            'error',\n            typeof error === 'string'\n              ? {\n                  type: 'error',\n                  code: 0,\n                  body: error\n                }\n              : error\n          );\n        },\n        function(computable, current, total) {\n          // collected some meta data already\n          if (total) {\n            state.size = total;\n          }\n\n          // update duration\n          state.duration = Date.now() - state.timestamp;\n\n          // if we can't compute progress, we're not going to fire progress events\n          if (!computable) {\n            state.progress = null;\n            return;\n          }\n\n          // update progress percentage\n          state.progress = current / total;\n\n          // expose\n          api.fire('progress', state.progress);\n        },\n        function() {\n          api.fire('abort');\n        },\n        function(response) {\n          var fileinfo = getFileInfoFromHeaders(\n            typeof response === 'string' ? response : response.headers\n          );\n          api.fire('meta', {\n            size: state.size || fileinfo.size,\n            filename: fileinfo.name,\n            source: fileinfo.source\n          });\n        }\n      );\n    };\n\n    var api = Object.assign({}, on(), {\n      setSource: function setSource(source) {\n        return (state.source = source);\n      },\n      getProgress: getProgress, // file load progress\n      abort: abort, // abort file load\n      load: load // start load\n    });\n\n    return api;\n  };\n\n  var isGet = function isGet(method) {\n    return /GET|HEAD/.test(method);\n  };\n\n  var sendRequest = function sendRequest(data, url, options) {\n    var api = {\n      onheaders: function onheaders() {},\n      onprogress: function onprogress() {},\n      onload: function onload() {},\n      ontimeout: function ontimeout() {},\n      onerror: function onerror() {},\n      onabort: function onabort() {},\n      abort: function abort() {\n        aborted = true;\n        xhr.abort();\n      }\n    };\n\n    // timeout identifier, only used when timeout is defined\n    var aborted = false;\n    var headersReceived = false;\n\n    // set default options\n    options = Object.assign(\n      {\n        method: 'POST',\n        headers: {},\n        withCredentials: false\n      },\n      options\n    );\n\n    // encode url\n    url = encodeURI(url);\n\n    // if method is GET, add any received data to url\n\n    if (isGet(options.method) && data) {\n      url =\n        '' +\n        url +\n        encodeURIComponent(\n          typeof data === 'string' ? data : JSON.stringify(data)\n        );\n    }\n\n    // create request\n    var xhr = new XMLHttpRequest();\n\n    // progress of load\n    var process = isGet(options.method) ? xhr : xhr.upload;\n    process.onprogress = function(e) {\n      // no progress event when aborted ( onprogress is called once after abort() )\n      if (aborted) {\n        return;\n      }\n\n      api.onprogress(e.lengthComputable, e.loaded, e.total);\n    };\n\n    // tries to get header info to the app as fast as possible\n    xhr.onreadystatechange = function() {\n      // not interesting in these states ('unsent' and 'openend' as they don't give us any additional info)\n      if (xhr.readyState < 2) {\n        return;\n      }\n\n      // no server response\n      if (xhr.readyState === 4 && xhr.status === 0) {\n        return;\n      }\n\n      if (headersReceived) {\n        return;\n      }\n\n      headersReceived = true;\n\n      // we've probably received some useful data in response headers\n      api.onheaders(xhr);\n    };\n\n    // load successful\n    xhr.onload = function() {\n      // is classified as valid response\n      if (xhr.status >= 200 && xhr.status < 300) {\n        api.onload(xhr);\n      } else {\n        api.onerror(xhr);\n      }\n    };\n\n    // error during load\n    xhr.onerror = function() {\n      return api.onerror(xhr);\n    };\n\n    // request aborted\n    xhr.onabort = function() {\n      aborted = true;\n      api.onabort();\n    };\n\n    // request timeout\n    xhr.ontimeout = function() {\n      return api.ontimeout(xhr);\n    };\n\n    // open up open up!\n    xhr.open(options.method, url, true);\n\n    // set timeout if defined (do it after open so IE11 plays ball)\n    if (isInt(options.timeout)) {\n      xhr.timeout = options.timeout;\n    }\n\n    // add headers\n    Object.keys(options.headers).forEach(function(key) {\n      var value = unescape(encodeURIComponent(options.headers[key]));\n      xhr.setRequestHeader(key, value);\n    });\n\n    // set type of response\n    if (options.responseType) {\n      xhr.responseType = options.responseType;\n    }\n\n    // set credentials\n    if (options.withCredentials) {\n      xhr.withCredentials = true;\n    }\n\n    // let's send our data\n    xhr.send(data);\n\n    return api;\n  };\n\n  var createResponse = function createResponse(type, code, body, headers) {\n    return {\n      type: type,\n      code: code,\n      body: body,\n      headers: headers\n    };\n  };\n\n  var createTimeoutResponse = function createTimeoutResponse(cb) {\n    return function(xhr) {\n      cb(createResponse('error', 0, 'Timeout', xhr.getAllResponseHeaders()));\n    };\n  };\n\n  var hasQS = function hasQS(str) {\n    return /\\?/.test(str);\n  };\n  var buildURL = function buildURL() {\n    var url = '';\n    for (\n      var _len = arguments.length, parts = new Array(_len), _key = 0;\n      _key < _len;\n      _key++\n    ) {\n      parts[_key] = arguments[_key];\n    }\n    parts.forEach(function(part) {\n      url += hasQS(url) && hasQS(part) ? part.replace(/\\?/, '&') : part;\n    });\n    return url;\n  };\n\n  var createFetchFunction = function createFetchFunction() {\n    var apiUrl =\n      arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    var action = arguments.length > 1 ? arguments[1] : undefined;\n    // custom handler (should also handle file, load, error, progress and abort)\n    if (typeof action === 'function') {\n      return action;\n    }\n\n    // no action supplied\n    if (!action || !isString(action.url)) {\n      return null;\n    }\n\n    // set onload hanlder\n    var onload =\n      action.onload ||\n      function(res) {\n        return res;\n      };\n    var onerror =\n      action.onerror ||\n      function(res) {\n        return null;\n      };\n\n    // internal handler\n    return function(url, load, error, progress, abort, headers) {\n      // do local or remote request based on if the url is external\n      var request = sendRequest(\n        url,\n        buildURL(apiUrl, action.url),\n        Object.assign({}, action, {\n          responseType: 'blob'\n        })\n      );\n\n      request.onload = function(xhr) {\n        // get headers\n        var headers = xhr.getAllResponseHeaders();\n\n        // get filename\n        var filename =\n          getFileInfoFromHeaders(headers).name || getFilenameFromURL(url);\n\n        // create response\n        load(\n          createResponse(\n            'load',\n            xhr.status,\n            action.method === 'HEAD'\n              ? null\n              : getFileFromBlob(onload(xhr.response), filename),\n            headers\n          )\n        );\n      };\n\n      request.onerror = function(xhr) {\n        error(\n          createResponse(\n            'error',\n            xhr.status,\n            onerror(xhr.response) || xhr.statusText,\n            xhr.getAllResponseHeaders()\n          )\n        );\n      };\n\n      request.onheaders = function(xhr) {\n        headers(\n          createResponse(\n            'headers',\n            xhr.status,\n            null,\n            xhr.getAllResponseHeaders()\n          )\n        );\n      };\n\n      request.ontimeout = createTimeoutResponse(error);\n      request.onprogress = progress;\n      request.onabort = abort;\n\n      // should return request\n      return request;\n    };\n  };\n\n  var ChunkStatus = {\n    QUEUED: 0,\n    COMPLETE: 1,\n    PROCESSING: 2,\n    ERROR: 3,\n    WAITING: 4\n  };\n\n  /*\n                                                       function signature:\n                                                         (file, metadata, load, error, progress, abort, transfer, options) => {\n                                                           return {\n                                                           abort:() => {}\n                                                         }\n                                                       }\n                                                       */\n\n  // apiUrl, action, name, file, metadata, load, error, progress, abort, transfer, options\n  var processFileChunked = function processFileChunked(\n    apiUrl,\n    action,\n    name,\n    file,\n    metadata,\n    load,\n    error,\n    progress,\n    abort,\n    transfer,\n    options\n  ) {\n    // all chunks\n    var chunks = [];\n    var chunkTransferId = options.chunkTransferId,\n      chunkServer = options.chunkServer,\n      chunkSize = options.chunkSize,\n      chunkRetryDelays = options.chunkRetryDelays;\n\n    // default state\n    var state = {\n      serverId: chunkTransferId,\n      aborted: false\n    };\n\n    // set onload handlers\n    var ondata =\n      action.ondata ||\n      function(fd) {\n        return fd;\n      };\n    var onload =\n      action.onload ||\n      function(xhr, method) {\n        return method === 'HEAD'\n          ? xhr.getResponseHeader('Upload-Offset')\n          : xhr.response;\n      };\n    var onerror =\n      action.onerror ||\n      function(res) {\n        return null;\n      };\n\n    // create server hook\n    var requestTransferId = function requestTransferId(cb) {\n      var formData = new FormData();\n\n      // add metadata under same name\n      if (isObject(metadata)) formData.append(name, JSON.stringify(metadata));\n\n      var headers =\n        typeof action.headers === 'function'\n          ? action.headers(file, metadata)\n          : Object.assign({}, action.headers, {\n              'Upload-Length': file.size\n            });\n\n      var requestParams = Object.assign({}, action, {\n        headers: headers\n      });\n\n      // send request object\n      var request = sendRequest(\n        ondata(formData),\n        buildURL(apiUrl, action.url),\n        requestParams\n      );\n\n      request.onload = function(xhr) {\n        return cb(onload(xhr, requestParams.method));\n      };\n\n      request.onerror = function(xhr) {\n        return error(\n          createResponse(\n            'error',\n            xhr.status,\n            onerror(xhr.response) || xhr.statusText,\n            xhr.getAllResponseHeaders()\n          )\n        );\n      };\n\n      request.ontimeout = createTimeoutResponse(error);\n    };\n\n    var requestTransferOffset = function requestTransferOffset(cb) {\n      var requestUrl = buildURL(apiUrl, chunkServer.url, state.serverId);\n\n      var headers =\n        typeof action.headers === 'function'\n          ? action.headers(state.serverId)\n          : Object.assign({}, action.headers);\n\n      var requestParams = {\n        headers: headers,\n        method: 'HEAD'\n      };\n\n      var request = sendRequest(null, requestUrl, requestParams);\n\n      request.onload = function(xhr) {\n        return cb(onload(xhr, requestParams.method));\n      };\n\n      request.onerror = function(xhr) {\n        return error(\n          createResponse(\n            'error',\n            xhr.status,\n            onerror(xhr.response) || xhr.statusText,\n            xhr.getAllResponseHeaders()\n          )\n        );\n      };\n\n      request.ontimeout = createTimeoutResponse(error);\n    };\n\n    // create chunks\n    var lastChunkIndex = Math.floor(file.size / chunkSize);\n    for (var i = 0; i <= lastChunkIndex; i++) {\n      var offset = i * chunkSize;\n      var data = file.slice(\n        offset,\n        offset + chunkSize,\n        'application/offset+octet-stream'\n      );\n      chunks[i] = {\n        index: i,\n        size: data.size,\n        offset: offset,\n        data: data,\n        file: file,\n        progress: 0,\n        retries: _toConsumableArray(chunkRetryDelays),\n        status: ChunkStatus.QUEUED,\n        error: null,\n        request: null,\n        timeout: null\n      };\n    }\n\n    var completeProcessingChunks = function completeProcessingChunks() {\n      return load(state.serverId);\n    };\n\n    var canProcessChunk = function canProcessChunk(chunk) {\n      return (\n        chunk.status === ChunkStatus.QUEUED ||\n        chunk.status === ChunkStatus.ERROR\n      );\n    };\n\n    var processChunk = function processChunk(chunk) {\n      // processing is paused, wait here\n      if (state.aborted) return;\n\n      // get next chunk to process\n      chunk = chunk || chunks.find(canProcessChunk);\n\n      // no more chunks to process\n      if (!chunk) {\n        // all done?\n        if (\n          chunks.every(function(chunk) {\n            return chunk.status === ChunkStatus.COMPLETE;\n          })\n        ) {\n          completeProcessingChunks();\n        }\n\n        // no chunk to handle\n        return;\n      }\n\n      // now processing this chunk\n      chunk.status = ChunkStatus.PROCESSING;\n      chunk.progress = null;\n\n      // allow parsing of formdata\n      var ondata =\n        chunkServer.ondata ||\n        function(fd) {\n          return fd;\n        };\n      var onerror =\n        chunkServer.onerror ||\n        function(res) {\n          return null;\n        };\n\n      // send request object\n      var requestUrl = buildURL(apiUrl, chunkServer.url, state.serverId);\n\n      var headers =\n        typeof chunkServer.headers === 'function'\n          ? chunkServer.headers(chunk)\n          : Object.assign({}, chunkServer.headers, {\n              'Content-Type': 'application/offset+octet-stream',\n              'Upload-Offset': chunk.offset,\n              'Upload-Length': file.size,\n              'Upload-Name': file.name\n            });\n\n      var request = (chunk.request = sendRequest(\n        ondata(chunk.data),\n        requestUrl,\n        Object.assign({}, chunkServer, {\n          headers: headers\n        })\n      ));\n\n      request.onload = function() {\n        // done!\n        chunk.status = ChunkStatus.COMPLETE;\n\n        // remove request reference\n        chunk.request = null;\n\n        // start processing more chunks\n        processChunks();\n      };\n\n      request.onprogress = function(lengthComputable, loaded, total) {\n        chunk.progress = lengthComputable ? loaded : null;\n        updateTotalProgress();\n      };\n\n      request.onerror = function(xhr) {\n        chunk.status = ChunkStatus.ERROR;\n        chunk.request = null;\n        chunk.error = onerror(xhr.response) || xhr.statusText;\n        if (!retryProcessChunk(chunk)) {\n          error(\n            createResponse(\n              'error',\n              xhr.status,\n              onerror(xhr.response) || xhr.statusText,\n              xhr.getAllResponseHeaders()\n            )\n          );\n        }\n      };\n\n      request.ontimeout = function(xhr) {\n        chunk.status = ChunkStatus.ERROR;\n        chunk.request = null;\n        if (!retryProcessChunk(chunk)) {\n          createTimeoutResponse(error)(xhr);\n        }\n      };\n\n      request.onabort = function() {\n        chunk.status = ChunkStatus.QUEUED;\n        chunk.request = null;\n        abort();\n      };\n    };\n\n    var retryProcessChunk = function retryProcessChunk(chunk) {\n      // no more retries left\n      if (chunk.retries.length === 0) return false;\n\n      // new retry\n      chunk.status = ChunkStatus.WAITING;\n      clearTimeout(chunk.timeout);\n      chunk.timeout = setTimeout(function() {\n        processChunk(chunk);\n      }, chunk.retries.shift());\n\n      // we're going to retry\n      return true;\n    };\n\n    var updateTotalProgress = function updateTotalProgress() {\n      // calculate total progress fraction\n      var totalBytesTransfered = chunks.reduce(function(p, chunk) {\n        if (p === null || chunk.progress === null) return null;\n        return p + chunk.progress;\n      }, 0);\n\n      // can't compute progress\n      if (totalBytesTransfered === null) return progress(false, 0, 0);\n\n      // calculate progress values\n      var totalSize = chunks.reduce(function(total, chunk) {\n        return total + chunk.size;\n      }, 0);\n\n      // can update progress indicator\n      progress(true, totalBytesTransfered, totalSize);\n    };\n\n    // process new chunks\n    var processChunks = function processChunks() {\n      var totalProcessing = chunks.filter(function(chunk) {\n        return chunk.status === ChunkStatus.PROCESSING;\n      }).length;\n      if (totalProcessing >= 1) return;\n      processChunk();\n    };\n\n    var abortChunks = function abortChunks() {\n      chunks.forEach(function(chunk) {\n        clearTimeout(chunk.timeout);\n        if (chunk.request) {\n          chunk.request.abort();\n        }\n      });\n    };\n\n    // let's go!\n    if (!state.serverId) {\n      requestTransferId(function(serverId) {\n        // stop here if aborted, might have happened in between request and callback\n        if (state.aborted) return;\n\n        // pass back to item so we can use it if something goes wrong\n        transfer(serverId);\n\n        // store internally\n        state.serverId = serverId;\n        processChunks();\n      });\n    } else {\n      requestTransferOffset(function(offset) {\n        // stop here if aborted, might have happened in between request and callback\n        if (state.aborted) return;\n\n        // mark chunks with lower offset as complete\n        chunks\n          .filter(function(chunk) {\n            return chunk.offset < offset;\n          })\n          .forEach(function(chunk) {\n            chunk.status = ChunkStatus.COMPLETE;\n            chunk.progress = chunk.size;\n          });\n\n        // continue processing\n        processChunks();\n      });\n    }\n\n    return {\n      abort: function abort() {\n        state.aborted = true;\n        abortChunks();\n      }\n    };\n  };\n\n  /*\n                                                               function signature:\n                                                                 (file, metadata, load, error, progress, abort) => {\n                                                                   return {\n                                                                   abort:() => {}\n                                                                 }\n                                                               }\n                                                               */\n  var createFileProcessorFunction = function createFileProcessorFunction(\n    apiUrl,\n    action,\n    name,\n    options\n  ) {\n    return function(file, metadata, load, error, progress, abort, transfer) {\n      // no file received\n      if (!file) return;\n\n      // if was passed a file, and we can chunk it, exit here\n      var canChunkUpload = options.chunkUploads;\n      var shouldChunkUpload = canChunkUpload && file.size > options.chunkSize;\n      var willChunkUpload =\n        canChunkUpload && (shouldChunkUpload || options.chunkForce);\n      if (file instanceof Blob && willChunkUpload)\n        return processFileChunked(\n          apiUrl,\n          action,\n          name,\n          file,\n          metadata,\n          load,\n          error,\n          progress,\n          abort,\n          transfer,\n          options\n        );\n\n      // set handlers\n      var ondata =\n        action.ondata ||\n        function(fd) {\n          return fd;\n        };\n      var onload =\n        action.onload ||\n        function(res) {\n          return res;\n        };\n      var onerror =\n        action.onerror ||\n        function(res) {\n          return null;\n        };\n\n      // create formdata object\n      var formData = new FormData();\n\n      // add metadata under same name\n      if (isObject(metadata)) {\n        formData.append(name, JSON.stringify(metadata));\n      }\n\n      // Turn into an array of objects so no matter what the input, we can handle it the same way\n      (file instanceof Blob ? [{ name: null, file: file }] : file).forEach(\n        function(item) {\n          formData.append(\n            name,\n            item.file,\n            item.name === null\n              ? item.file.name\n              : '' + item.name + item.file.name\n          );\n        }\n      );\n\n      // send request object\n      var request = sendRequest(\n        ondata(formData),\n        buildURL(apiUrl, action.url),\n        action\n      );\n      request.onload = function(xhr) {\n        load(\n          createResponse(\n            'load',\n            xhr.status,\n            onload(xhr.response),\n            xhr.getAllResponseHeaders()\n          )\n        );\n      };\n\n      request.onerror = function(xhr) {\n        error(\n          createResponse(\n            'error',\n            xhr.status,\n            onerror(xhr.response) || xhr.statusText,\n            xhr.getAllResponseHeaders()\n          )\n        );\n      };\n\n      request.ontimeout = createTimeoutResponse(error);\n      request.onprogress = progress;\n      request.onabort = abort;\n\n      // should return request\n      return request;\n    };\n  };\n\n  var createProcessorFunction = function createProcessorFunction() {\n    var apiUrl =\n      arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    var action = arguments.length > 1 ? arguments[1] : undefined;\n    var name = arguments.length > 2 ? arguments[2] : undefined;\n    var options = arguments.length > 3 ? arguments[3] : undefined;\n\n    // custom handler (should also handle file, load, error, progress and abort)\n    if (typeof action === 'function')\n      return function() {\n        for (\n          var _len = arguments.length, params = new Array(_len), _key = 0;\n          _key < _len;\n          _key++\n        ) {\n          params[_key] = arguments[_key];\n        }\n        return action.apply(void 0, [name].concat(params, [options]));\n      };\n\n    // no action supplied\n    if (!action || !isString(action.url)) return null;\n\n    // internal handler\n    return createFileProcessorFunction(apiUrl, action, name, options);\n  };\n\n  /*\n                                                      function signature:\n                                                      (uniqueFileId, load, error) => { }\n                                                      */\n  var createRevertFunction = function createRevertFunction() {\n    var apiUrl =\n      arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    var action = arguments.length > 1 ? arguments[1] : undefined;\n    // is custom implementation\n    if (typeof action === 'function') {\n      return action;\n    }\n\n    // no action supplied, return stub function, interface will work, but file won't be removed\n    if (!action || !isString(action.url)) {\n      return function(uniqueFileId, load) {\n        return load();\n      };\n    }\n\n    // set onload hanlder\n    var onload =\n      action.onload ||\n      function(res) {\n        return res;\n      };\n    var onerror =\n      action.onerror ||\n      function(res) {\n        return null;\n      };\n\n    // internal implementation\n    return function(uniqueFileId, load, error) {\n      var request = sendRequest(\n        uniqueFileId,\n        apiUrl + action.url,\n        action // contains method, headers and withCredentials properties\n      );\n      request.onload = function(xhr) {\n        load(\n          createResponse(\n            'load',\n            xhr.status,\n            onload(xhr.response),\n            xhr.getAllResponseHeaders()\n          )\n        );\n      };\n\n      request.onerror = function(xhr) {\n        error(\n          createResponse(\n            'error',\n            xhr.status,\n            onerror(xhr.response) || xhr.statusText,\n            xhr.getAllResponseHeaders()\n          )\n        );\n      };\n\n      request.ontimeout = createTimeoutResponse(error);\n\n      return request;\n    };\n  };\n\n  var getRandomNumber = function getRandomNumber() {\n    var min =\n      arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var max =\n      arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    return min + Math.random() * (max - min);\n  };\n\n  var createPerceivedPerformanceUpdater = function createPerceivedPerformanceUpdater(\n    cb\n  ) {\n    var duration =\n      arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;\n    var offset =\n      arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var tickMin =\n      arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 25;\n    var tickMax =\n      arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 250;\n    var timeout = null;\n    var start = Date.now();\n\n    var tick = function tick() {\n      var runtime = Date.now() - start;\n      var delay = getRandomNumber(tickMin, tickMax);\n\n      if (runtime + delay > duration) {\n        delay = runtime + delay - duration;\n      }\n\n      var progress = runtime / duration;\n      if (progress >= 1 || document.hidden) {\n        cb(1);\n        return;\n      }\n\n      cb(progress);\n\n      timeout = setTimeout(tick, delay);\n    };\n\n    tick();\n\n    return {\n      clear: function clear() {\n        clearTimeout(timeout);\n      }\n    };\n  };\n\n  var createFileProcessor = function createFileProcessor(processFn) {\n    var state = {\n      complete: false,\n      perceivedProgress: 0,\n      perceivedPerformanceUpdater: null,\n      progress: null,\n      timestamp: null,\n      perceivedDuration: 0,\n      duration: 0,\n      request: null,\n      response: null\n    };\n\n    var process = function process(file, metadata) {\n      var progressFn = function progressFn() {\n        // we've not yet started the real download, stop here\n        // the request might not go through, for instance, there might be some server trouble\n        // if state.progress is null, the server does not allow computing progress and we show the spinner instead\n        if (state.duration === 0 || state.progress === null) return;\n\n        // as we're now processing, fire the progress event\n        api.fire('progress', api.getProgress());\n      };\n\n      var completeFn = function completeFn() {\n        state.complete = true;\n        api.fire('load-perceived', state.response.body);\n      };\n\n      // let's start processing\n      api.fire('start');\n\n      // set request start\n      state.timestamp = Date.now();\n\n      // create perceived performance progress indicator\n      state.perceivedPerformanceUpdater = createPerceivedPerformanceUpdater(\n        function(progress) {\n          state.perceivedProgress = progress;\n          state.perceivedDuration = Date.now() - state.timestamp;\n\n          progressFn();\n\n          // if fake progress is done, and a response has been received,\n          // and we've not yet called the complete method\n          if (\n            state.response &&\n            state.perceivedProgress === 1 &&\n            !state.complete\n          ) {\n            // we done!\n            completeFn();\n          }\n        },\n        // random delay as in a list of files you start noticing\n        // files uploading at the exact same speed\n        getRandomNumber(750, 1500)\n      );\n\n      // remember request so we can abort it later\n      state.request = processFn(\n        // the file to process\n        file,\n\n        // the metadata to send along\n        metadata,\n\n        // callbacks (load, error, progress, abort, transfer)\n        // load expects the body to be a server id if\n        // you want to make use of revert\n        function(response) {\n          // we put the response in state so we can access\n          // it outside of this method\n          state.response = isObject(response)\n            ? response\n            : {\n                type: 'load',\n                code: 200,\n                body: '' + response,\n                headers: {}\n              };\n\n          // update duration\n          state.duration = Date.now() - state.timestamp;\n\n          // force progress to 1 as we're now done\n          state.progress = 1;\n\n          // actual load is done let's share results\n          api.fire('load', state.response.body);\n\n          // we are really done\n          // if perceived progress is 1 ( wait for perceived progress to complete )\n          // or if server does not support progress ( null )\n          if (state.perceivedProgress === 1) {\n            completeFn();\n          }\n        },\n\n        // error is expected to be an object with type, code, body\n        function(error) {\n          // cancel updater\n          state.perceivedPerformanceUpdater.clear();\n\n          // update others about this error\n          api.fire(\n            'error',\n            isObject(error)\n              ? error\n              : {\n                  type: 'error',\n                  code: 0,\n                  body: '' + error\n                }\n          );\n        },\n\n        // actual processing progress\n        function(computable, current, total) {\n          // update actual duration\n          state.duration = Date.now() - state.timestamp;\n\n          // update actual progress\n          state.progress = computable ? current / total : null;\n\n          progressFn();\n        },\n\n        // abort does not expect a value\n        function() {\n          // stop updater\n          state.perceivedPerformanceUpdater.clear();\n\n          // fire the abort event so we can switch visuals\n          api.fire('abort', state.response ? state.response.body : null);\n        },\n\n        // register the id for this transfer\n        function(transferId) {\n          api.fire('transfer', transferId);\n        }\n      );\n    };\n\n    var abort = function abort() {\n      // no request running, can't abort\n      if (!state.request) return;\n\n      // stop updater\n      state.perceivedPerformanceUpdater.clear();\n\n      // abort actual request\n      if (state.request.abort) state.request.abort();\n\n      // if has response object, we've completed the request\n      state.complete = true;\n    };\n\n    var reset = function reset() {\n      abort();\n      state.complete = false;\n      state.perceivedProgress = 0;\n      state.progress = 0;\n      state.timestamp = null;\n      state.perceivedDuration = 0;\n      state.duration = 0;\n      state.request = null;\n      state.response = null;\n    };\n\n    var getProgress = function getProgress() {\n      return state.progress\n        ? Math.min(state.progress, state.perceivedProgress)\n        : null;\n    };\n    var getDuration = function getDuration() {\n      return Math.min(state.duration, state.perceivedDuration);\n    };\n\n    var api = Object.assign({}, on(), {\n      process: process, // start processing file\n      abort: abort, // abort active process request\n      getProgress: getProgress,\n      getDuration: getDuration,\n      reset: reset\n    });\n\n    return api;\n  };\n\n  var getFilenameWithoutExtension = function getFilenameWithoutExtension(name) {\n    return name.substr(0, name.lastIndexOf('.')) || name;\n  };\n\n  var createFileStub = function createFileStub(source) {\n    var data = [source.name, source.size, source.type];\n\n    // is blob or base64, then we need to set the name\n    if (source instanceof Blob || isBase64DataURI(source)) {\n      data[0] = source.name || getDateString();\n    } else if (isBase64DataURI(source)) {\n      // if is base64 data uri we need to determine the average size and type\n      data[1] = source.length;\n      data[2] = getMimeTypeFromBase64DataURI(source);\n    } else if (isString(source)) {\n      // url\n      data[0] = getFilenameFromURL(source);\n      data[1] = 0;\n      data[2] = 'application/octet-stream';\n    }\n\n    return {\n      name: data[0],\n      size: data[1],\n      type: data[2]\n    };\n  };\n\n  var isFile = function isFile(value) {\n    return !!(value instanceof File || (value instanceof Blob && value.name));\n  };\n\n  var deepCloneObject = function deepCloneObject(src) {\n    if (!isObject(src)) return src;\n    var target = isArray(src) ? [] : {};\n    for (var key in src) {\n      if (!src.hasOwnProperty(key)) continue;\n      var v = src[key];\n      target[key] = v && isObject(v) ? deepCloneObject(v) : v;\n    }\n    return target;\n  };\n\n  var createItem = function createItem() {\n    var origin =\n      arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    var serverFileReference =\n      arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    var file =\n      arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    // unique id for this item, is used to identify the item across views\n    var id = getUniqueId();\n\n    /**\n     * Internal item state\n     */\n    var state = {\n      // is archived\n      archived: false,\n\n      // if is frozen, no longer fires events\n      frozen: false,\n\n      // removed from view\n      released: false,\n\n      // original source\n      source: null,\n\n      // file model reference\n      file: file,\n\n      // id of file on server\n      serverFileReference: serverFileReference,\n\n      // id of file transfer on server\n      transferId: null,\n\n      // is aborted\n      processingAborted: false,\n\n      // current item status\n      status: serverFileReference\n        ? ItemStatus.PROCESSING_COMPLETE\n        : ItemStatus.INIT,\n\n      // active processes\n      activeLoader: null,\n      activeProcessor: null\n    };\n\n    // callback used when abort processing is called to link back to the resolve method\n    var abortProcessingRequestComplete = null;\n\n    /**\n     * Externally added item metadata\n     */\n    var metadata = {};\n\n    // item data\n    var setStatus = function setStatus(status) {\n      return (state.status = status);\n    };\n\n    // fire event unless the item has been archived\n    var fire = function fire(event) {\n      if (state.released || state.frozen) return;\n      for (\n        var _len = arguments.length,\n          params = new Array(_len > 1 ? _len - 1 : 0),\n          _key = 1;\n        _key < _len;\n        _key++\n      ) {\n        params[_key - 1] = arguments[_key];\n      }\n      api.fire.apply(api, [event].concat(params));\n    };\n\n    // file data\n    var getFileExtension = function getFileExtension() {\n      return getExtensionFromFilename(state.file.name);\n    };\n    var getFileType = function getFileType() {\n      return state.file.type;\n    };\n    var getFileSize = function getFileSize() {\n      return state.file.size;\n    };\n    var getFile = function getFile() {\n      return state.file;\n    };\n\n    //\n    // logic to load a file\n    //\n    var load = function load(source, loader, onload) {\n      // remember the original item source\n      state.source = source;\n\n      // source is known\n      api.fireSync('init');\n\n      // file stub is already there\n      if (state.file) {\n        api.fireSync('load-skip');\n        return;\n      }\n\n      // set a stub file object while loading the actual data\n      state.file = createFileStub(source);\n\n      // starts loading\n      loader.on('init', function() {\n        fire('load-init');\n      });\n\n      // we'eve received a size indication, let's update the stub\n      loader.on('meta', function(meta) {\n        // set size of file stub\n        state.file.size = meta.size;\n\n        // set name of file stub\n        state.file.filename = meta.filename;\n\n        // if has received source, we done\n        if (meta.source) {\n          origin = FileOrigin.LIMBO;\n          state.serverFileReference = meta.source;\n          state.status = ItemStatus.PROCESSING_COMPLETE;\n        }\n\n        // size has been updated\n        fire('load-meta');\n      });\n\n      // the file is now loading we need to update the progress indicators\n      loader.on('progress', function(progress) {\n        setStatus(ItemStatus.LOADING);\n\n        fire('load-progress', progress);\n      });\n\n      // an error was thrown while loading the file, we need to switch to error state\n      loader.on('error', function(error) {\n        setStatus(ItemStatus.LOAD_ERROR);\n\n        fire('load-request-error', error);\n      });\n\n      // user or another process aborted the file load (cannot retry)\n      loader.on('abort', function() {\n        setStatus(ItemStatus.INIT);\n        fire('load-abort');\n      });\n\n      // done loading\n      loader.on('load', function(file) {\n        // as we've now loaded the file the loader is no longer required\n        state.activeLoader = null;\n\n        // called when file has loaded succesfully\n        var success = function success(result) {\n          // set (possibly) transformed file\n          state.file = isFile(result) ? result : state.file;\n\n          // file received\n          if (origin === FileOrigin.LIMBO && state.serverFileReference) {\n            setStatus(ItemStatus.PROCESSING_COMPLETE);\n          } else {\n            setStatus(ItemStatus.IDLE);\n          }\n\n          fire('load');\n        };\n\n        var error = function error(result) {\n          // set original file\n          state.file = file;\n          fire('load-meta');\n\n          setStatus(ItemStatus.LOAD_ERROR);\n          fire('load-file-error', result);\n        };\n\n        // if we already have a server file reference, we don't need to call the onload method\n        if (state.serverFileReference) {\n          success(file);\n          return;\n        }\n\n        // no server id, let's give this file the full treatment\n        onload(file, success, error);\n      });\n\n      // set loader source data\n      loader.setSource(source);\n\n      // set as active loader\n      state.activeLoader = loader;\n\n      // load the source data\n      loader.load();\n    };\n\n    var retryLoad = function retryLoad() {\n      if (!state.activeLoader) {\n        return;\n      }\n      state.activeLoader.load();\n    };\n\n    var abortLoad = function abortLoad() {\n      if (state.activeLoader) {\n        state.activeLoader.abort();\n        return;\n      }\n      setStatus(ItemStatus.INIT);\n      fire('load-abort');\n    };\n\n    //\n    // logic to process a file\n    //\n    var process = function process(processor, onprocess) {\n      // processing was aborted\n      if (state.processingAborted) {\n        state.processingAborted = false;\n        return;\n      }\n\n      // now processing\n      setStatus(ItemStatus.PROCESSING);\n\n      // reset abort callback\n      abortProcessingRequestComplete = null;\n\n      // if no file loaded we'll wait for the load event\n      if (!(state.file instanceof Blob)) {\n        api.on('load', function() {\n          process(processor, onprocess);\n        });\n        return;\n      }\n\n      // setup processor\n      processor.on('load', function(serverFileReference) {\n        // need this id to be able to revert the upload\n        state.transferId = null;\n        state.serverFileReference = serverFileReference;\n      });\n\n      // register transfer id\n      processor.on('transfer', function(transferId) {\n        // need this id to be able to revert the upload\n        state.transferId = transferId;\n      });\n\n      processor.on('load-perceived', function(serverFileReference) {\n        // no longer required\n        state.activeProcessor = null;\n\n        // need this id to be able to rever the upload\n        state.transferId = null;\n        state.serverFileReference = serverFileReference;\n\n        setStatus(ItemStatus.PROCESSING_COMPLETE);\n        fire('process-complete', serverFileReference);\n      });\n\n      processor.on('start', function() {\n        fire('process-start');\n      });\n\n      processor.on('error', function(error) {\n        state.activeProcessor = null;\n        setStatus(ItemStatus.PROCESSING_ERROR);\n        fire('process-error', error);\n      });\n\n      processor.on('abort', function(serverFileReference) {\n        state.activeProcessor = null;\n\n        // if file was uploaded but processing was cancelled during perceived processor time store file reference\n        state.transferId = null;\n        state.serverFileReference = serverFileReference;\n\n        setStatus(ItemStatus.IDLE);\n        fire('process-abort');\n\n        // has timeout so doesn't interfere with remove action\n        if (abortProcessingRequestComplete) {\n          abortProcessingRequestComplete();\n        }\n      });\n\n      processor.on('progress', function(progress) {\n        fire('process-progress', progress);\n      });\n\n      // when successfully transformed\n      var success = function success(file) {\n        // if was archived in the mean time, don't process\n        if (state.archived) return;\n\n        // process file!\n        processor.process(file, Object.assign({}, metadata));\n      };\n\n      // something went wrong during transform phase\n      var error = console.error;\n\n      // start processing the file\n      onprocess(state.file, success, error);\n\n      // set as active processor\n      state.activeProcessor = processor;\n    };\n\n    var requestProcessing = function requestProcessing() {\n      state.processingAborted = false;\n      setStatus(ItemStatus.PROCESSING_QUEUED);\n    };\n\n    var abortProcessing = function abortProcessing() {\n      return new Promise(function(resolve) {\n        if (!state.activeProcessor) {\n          state.processingAborted = true;\n\n          setStatus(ItemStatus.IDLE);\n          fire('process-abort');\n\n          resolve();\n          return;\n        }\n\n        abortProcessingRequestComplete = function abortProcessingRequestComplete() {\n          resolve();\n        };\n\n        state.activeProcessor.abort();\n      });\n    };\n\n    //\n    // logic to revert a processed file\n    //\n    var revert = function revert(revertFileUpload, forceRevert) {\n      return new Promise(function(resolve, reject) {\n        // cannot revert without a server id for this process\n        if (state.serverFileReference === null) {\n          resolve();\n          return;\n        }\n\n        // revert the upload (fire and forget)\n        revertFileUpload(\n          state.serverFileReference,\n          function() {\n            // reset file server id as now it's no available on the server\n            state.serverFileReference = null;\n            resolve();\n          },\n          function(error) {\n            // don't set error state when reverting is optional, it will always resolve\n            if (!forceRevert) {\n              resolve();\n              return;\n            }\n\n            // oh no errors\n            setStatus(ItemStatus.PROCESSING_REVERT_ERROR);\n            fire('process-revert-error');\n            reject(error);\n          }\n        );\n\n        // fire event\n        setStatus(ItemStatus.IDLE);\n        fire('process-revert');\n      });\n    };\n\n    // exposed methods\n    var _setMetadata = function setMetadata(key, value, silent) {\n      var keys = key.split('.');\n      var root = keys[0];\n      var last = keys.pop();\n      var data = metadata;\n      keys.forEach(function(key) {\n        return (data = data[key]);\n      });\n\n      // compare old value against new value, if they're the same, we're not updating\n      if (JSON.stringify(data[last]) === JSON.stringify(value)) return;\n\n      // update value\n      data[last] = value;\n\n      // don't fire update\n      if (silent) return;\n\n      // fire update\n      fire('metadata-update', {\n        key: root,\n        value: metadata[root]\n      });\n    };\n\n    var getMetadata = function getMetadata(key) {\n      return deepCloneObject(key ? metadata[key] : metadata);\n    };\n\n    var api = Object.assign(\n      {\n        id: {\n          get: function get() {\n            return id;\n          }\n        },\n        origin: {\n          get: function get() {\n            return origin;\n          }\n        },\n        serverId: {\n          get: function get() {\n            return state.serverFileReference;\n          }\n        },\n        transferId: {\n          get: function get() {\n            return state.transferId;\n          }\n        },\n        status: {\n          get: function get() {\n            return state.status;\n          }\n        },\n        filename: {\n          get: function get() {\n            return state.file.name;\n          }\n        },\n        filenameWithoutExtension: {\n          get: function get() {\n            return getFilenameWithoutExtension(state.file.name);\n          }\n        },\n        fileExtension: { get: getFileExtension },\n        fileType: { get: getFileType },\n        fileSize: { get: getFileSize },\n        file: { get: getFile },\n        relativePath: {\n          get: function get() {\n            return state.file._relativePath;\n          }\n        },\n\n        source: {\n          get: function get() {\n            return state.source;\n          }\n        },\n\n        getMetadata: getMetadata,\n        setMetadata: function setMetadata(key, value, silent) {\n          if (isObject(key)) {\n            var data = key;\n            Object.keys(data).forEach(function(key) {\n              _setMetadata(key, data[key], value);\n            });\n            return key;\n          }\n          _setMetadata(key, value, silent);\n          return value;\n        },\n\n        extend: function extend(name, handler) {\n          return (itemAPI[name] = handler);\n        },\n\n        abortLoad: abortLoad,\n        retryLoad: retryLoad,\n        requestProcessing: requestProcessing,\n        abortProcessing: abortProcessing,\n\n        load: load,\n        process: process,\n        revert: revert\n      },\n\n      on(),\n      {\n        freeze: function freeze() {\n          return (state.frozen = true);\n        },\n\n        release: function release() {\n          return (state.released = true);\n        },\n        released: {\n          get: function get() {\n            return state.released;\n          }\n        },\n\n        archive: function archive() {\n          return (state.archived = true);\n        },\n        archived: {\n          get: function get() {\n            return state.archived;\n          }\n        }\n      }\n    );\n\n    // create it here instead of returning it instantly so we can extend it later\n    var itemAPI = createObject(api);\n\n    return itemAPI;\n  };\n\n  var getItemIndexByQuery = function getItemIndexByQuery(items, query) {\n    // just return first index\n    if (isEmpty(query)) {\n      return 0;\n    }\n\n    // invalid queries\n    if (!isString(query)) {\n      return -1;\n    }\n\n    // return item by id (or -1 if not found)\n    return items.findIndex(function(item) {\n      return item.id === query;\n    });\n  };\n\n  var getItemById = function getItemById(items, itemId) {\n    var index = getItemIndexByQuery(items, itemId);\n    if (index < 0) {\n      return;\n    }\n    return items[index] || null;\n  };\n\n  var fetchBlob = function fetchBlob(\n    url,\n    load,\n    error,\n    progress,\n    abort,\n    headers\n  ) {\n    var request = sendRequest(null, url, {\n      method: 'GET',\n      responseType: 'blob'\n    });\n\n    request.onload = function(xhr) {\n      // get headers\n      var headers = xhr.getAllResponseHeaders();\n\n      // get filename\n      var filename =\n        getFileInfoFromHeaders(headers).name || getFilenameFromURL(url);\n\n      // create response\n      load(\n        createResponse(\n          'load',\n          xhr.status,\n          getFileFromBlob(xhr.response, filename),\n          headers\n        )\n      );\n    };\n\n    request.onerror = function(xhr) {\n      error(\n        createResponse(\n          'error',\n          xhr.status,\n          xhr.statusText,\n          xhr.getAllResponseHeaders()\n        )\n      );\n    };\n\n    request.onheaders = function(xhr) {\n      headers(\n        createResponse('headers', xhr.status, null, xhr.getAllResponseHeaders())\n      );\n    };\n\n    request.ontimeout = createTimeoutResponse(error);\n    request.onprogress = progress;\n    request.onabort = abort;\n\n    // should return request\n    return request;\n  };\n\n  var getDomainFromURL = function getDomainFromURL(url) {\n    if (url.indexOf('//') === 0) {\n      url = location.protocol + url;\n    }\n    return url\n      .toLowerCase()\n      .replace('blob:', '')\n      .replace(/([a-z])?:\\/\\//, '$1')\n      .split('/')[0];\n  };\n\n  var isExternalURL = function isExternalURL(url) {\n    return (\n      (url.indexOf(':') > -1 || url.indexOf('//') > -1) &&\n      getDomainFromURL(location.href) !== getDomainFromURL(url)\n    );\n  };\n\n  var dynamicLabel = function dynamicLabel(label) {\n    return function() {\n      return isFunction(label) ? label.apply(void 0, arguments) : label;\n    };\n  };\n\n  var isMockItem = function isMockItem(item) {\n    return !isFile(item.file);\n  };\n\n  var listUpdated = function listUpdated(dispatch, state) {\n    clearTimeout(state.listUpdateTimeout);\n    state.listUpdateTimeout = setTimeout(function() {\n      dispatch('DID_UPDATE_ITEMS', { items: getActiveItems(state.items) });\n    }, 0);\n  };\n\n  var optionalPromise = function optionalPromise(fn) {\n    for (\n      var _len = arguments.length,\n        params = new Array(_len > 1 ? _len - 1 : 0),\n        _key = 1;\n      _key < _len;\n      _key++\n    ) {\n      params[_key - 1] = arguments[_key];\n    }\n    return new Promise(function(resolve) {\n      if (!fn) {\n        return resolve(true);\n      }\n\n      var result = fn.apply(void 0, params);\n\n      if (result == null) {\n        return resolve(true);\n      }\n\n      if (typeof result === 'boolean') {\n        return resolve(result);\n      }\n\n      if (typeof result.then === 'function') {\n        result.then(resolve);\n      }\n    });\n  };\n\n  var sortItems = function sortItems(state, compare) {\n    state.items.sort(function(a, b) {\n      return compare(createItemAPI(a), createItemAPI(b));\n    });\n  };\n\n  // returns item based on state\n  var getItemByQueryFromState = function getItemByQueryFromState(\n    state,\n    itemHandler\n  ) {\n    return function() {\n      var _ref =\n        arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var query = _ref.query,\n        _ref$success = _ref.success,\n        success = _ref$success === void 0 ? function() {} : _ref$success,\n        _ref$failure = _ref.failure,\n        failure = _ref$failure === void 0 ? function() {} : _ref$failure,\n        options = _objectWithoutProperties(_ref, [\n          'query',\n          'success',\n          'failure'\n        ]);\n      var item = getItemByQuery(state.items, query);\n      if (!item) {\n        failure({\n          error: createResponse('error', 0, 'Item not found'),\n\n          file: null\n        });\n\n        return;\n      }\n      itemHandler(item, success, failure, options || {});\n    };\n  };\n\n  var actions = function actions(dispatch, query, state) {\n    return {\n      /**\n       * Aborts all ongoing processes\n       */\n      ABORT_ALL: function ABORT_ALL() {\n        getActiveItems(state.items).forEach(function(item) {\n          item.freeze();\n          item.abortLoad();\n          item.abortProcessing();\n        });\n      },\n\n      /**\n       * Sets initial files\n       */\n      DID_SET_FILES: function DID_SET_FILES(_ref2) {\n        var _ref2$value = _ref2.value,\n          value = _ref2$value === void 0 ? [] : _ref2$value;\n\n        // map values to file objects\n        var files = value.map(function(file) {\n          return {\n            source: file.source ? file.source : file,\n            options: file.options\n          };\n        });\n\n        // loop over files, if file is in list, leave it be, if not, remove\n        // test if items should be moved\n        var activeItems = getActiveItems(state.items);\n\n        activeItems.forEach(function(item) {\n          // if item not is in new value, remove\n          if (\n            !files.find(function(file) {\n              return file.source === item.source || file.source === item.file;\n            })\n          ) {\n            dispatch('REMOVE_ITEM', { query: item, remove: false });\n          }\n        });\n\n        // add new files\n        activeItems = getActiveItems(state.items);\n        files.forEach(function(file, index) {\n          // if file is already in list\n          if (\n            activeItems.find(function(item) {\n              return item.source === file.source || item.file === file.source;\n            })\n          )\n            return;\n\n          // not in list, add\n          dispatch(\n            'ADD_ITEM',\n            Object.assign({}, file, {\n              interactionMethod: InteractionMethod.NONE,\n              index: index\n            })\n          );\n        });\n      },\n\n      DID_UPDATE_ITEM_METADATA: function DID_UPDATE_ITEM_METADATA(_ref3) {\n        var id = _ref3.id;\n\n        // if is called multiple times in close succession we combined all calls together to save resources\n        clearTimeout(state.itemUpdateTimeout);\n        state.itemUpdateTimeout = setTimeout(function() {\n          var item = getItemById(state.items, id);\n\n          // only revert and attempt to upload when we're uploading to a server\n          if (!query('IS_ASYNC')) {\n            // should we update the output data\n            applyFilterChain('SHOULD_PREPARE_OUTPUT', false, {\n              item: item,\n              query: query\n            }).then(function(shouldPrepareOutput) {\n              if (!shouldPrepareOutput) {\n                return;\n              }\n              dispatch(\n                'REQUEST_PREPARE_OUTPUT',\n                {\n                  query: id,\n                  item: item,\n                  success: function success(file) {\n                    dispatch('DID_PREPARE_OUTPUT', { id: id, file: file });\n                  }\n                },\n                true\n              );\n            });\n\n            return;\n          }\n\n          // for async scenarios\n          var upload = function upload() {\n            // we push this forward a bit so the interface is updated correctly\n            setTimeout(function() {\n              dispatch('REQUEST_ITEM_PROCESSING', { query: id });\n            }, 32);\n          };\n\n          var revert = function revert(doUpload) {\n            item\n              .revert(\n                createRevertFunction(\n                  state.options.server.url,\n                  state.options.server.revert\n                ),\n                query('GET_FORCE_REVERT')\n              )\n              .then(doUpload ? upload : function() {})\n              .catch(function() {});\n          };\n\n          var abort = function abort(doUpload) {\n            item.abortProcessing().then(doUpload ? upload : function() {});\n          };\n\n          // if we should re-upload the file immediately\n          if (item.status === ItemStatus.PROCESSING_COMPLETE) {\n            return revert(state.options.instantUpload);\n          }\n\n          // if currently uploading, cancel upload\n          if (item.status === ItemStatus.PROCESSING) {\n            return abort(state.options.instantUpload);\n          }\n\n          if (state.options.instantUpload) {\n            upload();\n          }\n        }, 0);\n      },\n\n      MOVE_ITEM: function MOVE_ITEM(_ref4) {\n        var query = _ref4.query,\n          index = _ref4.index;\n        var item = getItemByQuery(state.items, query);\n        if (!item) return;\n        var currentIndex = state.items.indexOf(item);\n        index = limit(index, 0, state.items.length - 1);\n        if (currentIndex === index) return;\n        state.items.splice(index, 0, state.items.splice(currentIndex, 1)[0]);\n      },\n\n      SORT: function SORT(_ref5) {\n        var compare = _ref5.compare;\n        sortItems(state, compare);\n        dispatch('DID_SORT_ITEMS', {\n          items: query('GET_ACTIVE_ITEMS')\n        });\n      },\n\n      ADD_ITEMS: function ADD_ITEMS(_ref6) {\n        var items = _ref6.items,\n          index = _ref6.index,\n          interactionMethod = _ref6.interactionMethod,\n          _ref6$success = _ref6.success,\n          success = _ref6$success === void 0 ? function() {} : _ref6$success,\n          _ref6$failure = _ref6.failure,\n          failure = _ref6$failure === void 0 ? function() {} : _ref6$failure;\n\n        var currentIndex = index;\n\n        if (index === -1 || typeof index === 'undefined') {\n          var insertLocation = query('GET_ITEM_INSERT_LOCATION');\n          var totalItems = query('GET_TOTAL_ITEMS');\n          currentIndex = insertLocation === 'before' ? 0 : totalItems;\n        }\n\n        var ignoredFiles = query('GET_IGNORED_FILES');\n        var isValidFile = function isValidFile(source) {\n          return isFile(source)\n            ? !ignoredFiles.includes(source.name.toLowerCase())\n            : !isEmpty(source);\n        };\n        var validItems = items.filter(isValidFile);\n\n        var promises = validItems.map(function(source) {\n          return new Promise(function(resolve, reject) {\n            dispatch('ADD_ITEM', {\n              interactionMethod: interactionMethod,\n              source: source.source || source,\n              success: resolve,\n              failure: reject,\n              index: currentIndex++,\n              options: source.options || {}\n            });\n          });\n        });\n\n        Promise.all(promises)\n          .then(success)\n          .catch(failure);\n      },\n\n      /**\n       * @param source\n       * @param index\n       * @param interactionMethod\n       */\n      ADD_ITEM: function ADD_ITEM(_ref7) {\n        var source = _ref7.source,\n          _ref7$index = _ref7.index,\n          index = _ref7$index === void 0 ? -1 : _ref7$index,\n          interactionMethod = _ref7.interactionMethod,\n          _ref7$success = _ref7.success,\n          success = _ref7$success === void 0 ? function() {} : _ref7$success,\n          _ref7$failure = _ref7.failure,\n          failure = _ref7$failure === void 0 ? function() {} : _ref7$failure,\n          _ref7$options = _ref7.options,\n          options = _ref7$options === void 0 ? {} : _ref7$options;\n\n        // if no source supplied\n        if (isEmpty(source)) {\n          failure({\n            error: createResponse('error', 0, 'No source'),\n\n            file: null\n          });\n\n          return;\n        }\n\n        // filter out invalid file items, used to filter dropped directory contents\n        if (\n          isFile(source) &&\n          state.options.ignoredFiles.includes(source.name.toLowerCase())\n        ) {\n          // fail silently\n          return;\n        }\n\n        // test if there's still room in the list of files\n        if (!hasRoomForItem(state)) {\n          // if multiple allowed, we can't replace\n          // or if only a single item is allowed but we're not allowed to replace it we exit\n          if (\n            state.options.allowMultiple ||\n            (!state.options.allowMultiple && !state.options.allowReplace)\n          ) {\n            var error = createResponse('warning', 0, 'Max files');\n\n            dispatch('DID_THROW_MAX_FILES', {\n              source: source,\n              error: error\n            });\n\n            failure({ error: error, file: null });\n\n            return;\n          }\n\n          // let's replace the item\n          // id of first item we're about to remove\n          var _item = getActiveItems(state.items)[0];\n\n          // if has been processed remove it from the server as well\n          if (\n            _item.status === ItemStatus.PROCESSING_COMPLETE ||\n            _item.status === ItemStatus.PROCESSING_REVERT_ERROR\n          ) {\n            var forceRevert = query('GET_FORCE_REVERT');\n            _item\n              .revert(\n                createRevertFunction(\n                  state.options.server.url,\n                  state.options.server.revert\n                ),\n                forceRevert\n              )\n              .then(function() {\n                if (!forceRevert) return;\n\n                // try to add now\n                dispatch('ADD_ITEM', {\n                  source: source,\n                  index: index,\n                  interactionMethod: interactionMethod,\n                  success: success,\n                  failure: failure,\n                  options: options\n                });\n              })\n              .catch(function() {}); // no need to handle this catch state for now\n\n            if (forceRevert) return;\n          }\n\n          // remove first item as it will be replaced by this item\n          dispatch('REMOVE_ITEM', { query: _item.id });\n        }\n\n        // where did the file originate\n        var origin =\n          options.type === 'local'\n            ? FileOrigin.LOCAL\n            : options.type === 'limbo'\n            ? FileOrigin.LIMBO\n            : FileOrigin.INPUT;\n\n        // create a new blank item\n        var item = createItem(\n          // where did this file come from\n          origin,\n\n          // an input file never has a server file reference\n          origin === FileOrigin.INPUT ? null : source,\n\n          // file mock data, if defined\n          options.file\n        );\n\n        // set initial meta data\n        Object.keys(options.metadata || {}).forEach(function(key) {\n          item.setMetadata(key, options.metadata[key]);\n        });\n\n        // created the item, let plugins add methods\n        applyFilters('DID_CREATE_ITEM', item, {\n          query: query,\n          dispatch: dispatch\n        });\n\n        // where to insert new items\n        var itemInsertLocation = query('GET_ITEM_INSERT_LOCATION');\n\n        // adjust index if is not allowed to pick location\n        if (!state.options.itemInsertLocationFreedom) {\n          index = itemInsertLocation === 'before' ? -1 : state.items.length;\n        }\n\n        // add item to list\n        insertItem(state.items, item, index);\n\n        // sort items in list\n        if (isFunction(itemInsertLocation) && source) {\n          sortItems(state, itemInsertLocation);\n        }\n\n        // get a quick reference to the item id\n        var id = item.id;\n\n        // observe item events\n        item.on('init', function() {\n          dispatch('DID_INIT_ITEM', { id: id });\n        });\n\n        item.on('load-init', function() {\n          dispatch('DID_START_ITEM_LOAD', { id: id });\n        });\n\n        item.on('load-meta', function() {\n          dispatch('DID_UPDATE_ITEM_META', { id: id });\n        });\n\n        item.on('load-progress', function(progress) {\n          dispatch('DID_UPDATE_ITEM_LOAD_PROGRESS', {\n            id: id,\n            progress: progress\n          });\n        });\n\n        item.on('load-request-error', function(error) {\n          var mainStatus = dynamicLabel(state.options.labelFileLoadError)(\n            error\n          );\n\n          // is client error, no way to recover\n          if (error.code >= 400 && error.code < 500) {\n            dispatch('DID_THROW_ITEM_INVALID', {\n              id: id,\n              error: error,\n              status: {\n                main: mainStatus,\n                sub: error.code + ' (' + error.body + ')'\n              }\n            });\n\n            // reject the file so can be dealt with through API\n            failure({ error: error, file: createItemAPI(item) });\n            return;\n          }\n\n          // is possible server error, so might be possible to retry\n          dispatch('DID_THROW_ITEM_LOAD_ERROR', {\n            id: id,\n            error: error,\n            status: {\n              main: mainStatus,\n              sub: state.options.labelTapToRetry\n            }\n          });\n        });\n\n        item.on('load-file-error', function(error) {\n          dispatch('DID_THROW_ITEM_INVALID', {\n            id: id,\n            error: error.status,\n            status: error.status\n          });\n\n          failure({ error: error.status, file: createItemAPI(item) });\n        });\n\n        item.on('load-abort', function() {\n          dispatch('REMOVE_ITEM', { query: id });\n        });\n\n        item.on('load-skip', function() {\n          dispatch('COMPLETE_LOAD_ITEM', {\n            query: id,\n            item: item,\n            data: {\n              source: source,\n              success: success\n            }\n          });\n        });\n\n        item.on('load', function() {\n          var handleAdd = function handleAdd(shouldAdd) {\n            // no should not add this file\n            if (!shouldAdd) {\n              dispatch('REMOVE_ITEM', {\n                query: id\n              });\n\n              return;\n            }\n\n            // now interested in metadata updates\n            item.on('metadata-update', function(change) {\n              dispatch('DID_UPDATE_ITEM_METADATA', { id: id, change: change });\n            });\n\n            // let plugins decide if the output data should be prepared at this point\n            // means we'll do this and wait for idle state\n            applyFilterChain('SHOULD_PREPARE_OUTPUT', false, {\n              item: item,\n              query: query\n            }).then(function(shouldPrepareOutput) {\n              var loadComplete = function loadComplete() {\n                dispatch('COMPLETE_LOAD_ITEM', {\n                  query: id,\n                  item: item,\n                  data: {\n                    source: source,\n                    success: success\n                  }\n                });\n\n                listUpdated(dispatch, state);\n              };\n\n              // exit\n              if (shouldPrepareOutput) {\n                // wait for idle state and then run PREPARE_OUTPUT\n                dispatch(\n                  'REQUEST_PREPARE_OUTPUT',\n                  {\n                    query: id,\n                    item: item,\n                    success: function success(file) {\n                      dispatch('DID_PREPARE_OUTPUT', { id: id, file: file });\n                      loadComplete();\n                    }\n                  },\n                  true\n                );\n\n                return;\n              }\n\n              loadComplete();\n            });\n          };\n\n          // item loaded, allow plugins to\n          // - read data (quickly)\n          // - add metadata\n          applyFilterChain('DID_LOAD_ITEM', item, {\n            query: query,\n            dispatch: dispatch\n          })\n            .then(function() {\n              optionalPromise(\n                query('GET_BEFORE_ADD_FILE'),\n                createItemAPI(item)\n              ).then(handleAdd);\n            })\n            .catch(function() {\n              handleAdd(false);\n            });\n        });\n\n        item.on('process-start', function() {\n          dispatch('DID_START_ITEM_PROCESSING', { id: id });\n        });\n\n        item.on('process-progress', function(progress) {\n          dispatch('DID_UPDATE_ITEM_PROCESS_PROGRESS', {\n            id: id,\n            progress: progress\n          });\n        });\n\n        item.on('process-error', function(error) {\n          dispatch('DID_THROW_ITEM_PROCESSING_ERROR', {\n            id: id,\n            error: error,\n            status: {\n              main: dynamicLabel(state.options.labelFileProcessingError)(error),\n              sub: state.options.labelTapToRetry\n            }\n          });\n        });\n\n        item.on('process-revert-error', function(error) {\n          dispatch('DID_THROW_ITEM_PROCESSING_REVERT_ERROR', {\n            id: id,\n            error: error,\n            status: {\n              main: dynamicLabel(state.options.labelFileProcessingRevertError)(\n                error\n              ),\n              sub: state.options.labelTapToRetry\n            }\n          });\n        });\n\n        item.on('process-complete', function(serverFileReference) {\n          dispatch('DID_COMPLETE_ITEM_PROCESSING', {\n            id: id,\n            error: null,\n            serverFileReference: serverFileReference\n          });\n\n          dispatch('DID_DEFINE_VALUE', { id: id, value: serverFileReference });\n        });\n\n        item.on('process-abort', function() {\n          dispatch('DID_ABORT_ITEM_PROCESSING', { id: id });\n        });\n\n        item.on('process-revert', function() {\n          dispatch('DID_REVERT_ITEM_PROCESSING', { id: id });\n          dispatch('DID_DEFINE_VALUE', { id: id, value: null });\n        });\n\n        // let view know the item has been inserted\n        dispatch('DID_ADD_ITEM', {\n          id: id,\n          index: index,\n          interactionMethod: interactionMethod\n        });\n\n        listUpdated(dispatch, state);\n\n        // start loading the source\n        var _ref8 = state.options.server || {},\n          url = _ref8.url,\n          load = _ref8.load,\n          restore = _ref8.restore,\n          fetch = _ref8.fetch;\n\n        item.load(\n          source,\n\n          // this creates a function that loads the file based on the type of file (string, base64, blob, file) and location of file (local, remote, limbo)\n          createFileLoader(\n            origin === FileOrigin.INPUT\n              ? // input, if is remote, see if should use custom fetch, else use default fetchBlob\n                isString(source) && isExternalURL(source)\n                ? fetch\n                  ? createFetchFunction(url, fetch)\n                  : fetchBlob // remote url\n                : fetchBlob // try to fetch url\n              : // limbo or local\n              origin === FileOrigin.LIMBO\n              ? createFetchFunction(url, restore) // limbo\n              : createFetchFunction(url, load) // local\n          ),\n\n          // called when the file is loaded so it can be piped through the filters\n          function(file, success, error) {\n            // let's process the file\n            applyFilterChain('LOAD_FILE', file, { query: query })\n              .then(success)\n              .catch(error);\n          }\n        );\n      },\n\n      REQUEST_PREPARE_OUTPUT: function REQUEST_PREPARE_OUTPUT(_ref9) {\n        var item = _ref9.item,\n          success = _ref9.success,\n          _ref9$failure = _ref9.failure,\n          failure = _ref9$failure === void 0 ? function() {} : _ref9$failure;\n\n        // error response if item archived\n        var err = {\n          error: createResponse('error', 0, 'Item not found'),\n\n          file: null\n        };\n\n        // don't handle archived items, an item could have been archived (load aborted) while waiting to be prepared\n        if (item.archived) return failure(err);\n\n        // allow plugins to alter the file data\n        applyFilterChain('PREPARE_OUTPUT', item.file, {\n          query: query,\n          item: item\n        }).then(function(result) {\n          applyFilterChain('COMPLETE_PREPARE_OUTPUT', result, {\n            query: query,\n            item: item\n          }).then(function(result) {\n            // don't handle archived items, an item could have been archived (load aborted) while being prepared\n            if (item.archived) return failure(err);\n\n            // we done!\n            success(result);\n          });\n        });\n      },\n\n      COMPLETE_LOAD_ITEM: function COMPLETE_LOAD_ITEM(_ref10) {\n        var item = _ref10.item,\n          data = _ref10.data;\n        var success = data.success,\n          source = data.source;\n\n        // sort items in list\n        var itemInsertLocation = query('GET_ITEM_INSERT_LOCATION');\n        if (isFunction(itemInsertLocation) && source) {\n          sortItems(state, itemInsertLocation);\n        }\n\n        // let interface know the item has loaded\n        dispatch('DID_LOAD_ITEM', {\n          id: item.id,\n          error: null,\n          serverFileReference: item.origin === FileOrigin.INPUT ? null : source\n        });\n\n        // item has been successfully loaded and added to the\n        // list of items so can now be safely returned for use\n        success(createItemAPI(item));\n\n        // if this is a local server file we need to show a different state\n        if (item.origin === FileOrigin.LOCAL) {\n          dispatch('DID_LOAD_LOCAL_ITEM', { id: item.id });\n          return;\n        }\n\n        // if is a temp server file we prevent async upload call here (as the file is already on the server)\n        if (item.origin === FileOrigin.LIMBO) {\n          dispatch('DID_COMPLETE_ITEM_PROCESSING', {\n            id: item.id,\n            error: null,\n            serverFileReference: source\n          });\n\n          dispatch('DID_DEFINE_VALUE', {\n            id: item.id,\n            value: source\n          });\n\n          return;\n        }\n\n        // id we are allowed to upload the file immediately, lets do it\n        if (query('IS_ASYNC') && state.options.instantUpload) {\n          dispatch('REQUEST_ITEM_PROCESSING', { query: item.id });\n        }\n      },\n\n      RETRY_ITEM_LOAD: getItemByQueryFromState(state, function(item) {\n        // try loading the source one more time\n        item.retryLoad();\n      }),\n\n      REQUEST_ITEM_PREPARE: getItemByQueryFromState(state, function(\n        item,\n        _success,\n        failure\n      ) {\n        dispatch(\n          'REQUEST_PREPARE_OUTPUT',\n          {\n            query: item.id,\n            item: item,\n            success: function success(file) {\n              dispatch('DID_PREPARE_OUTPUT', { id: item.id, file: file });\n              _success({\n                file: item,\n                output: file\n              });\n            },\n            failure: failure\n          },\n          true\n        );\n      }),\n\n      REQUEST_ITEM_PROCESSING: getItemByQueryFromState(state, function(\n        item,\n        success,\n        failure\n      ) {\n        // cannot be queued (or is already queued)\n        var itemCanBeQueuedForProcessing =\n          // waiting for something\n          item.status === ItemStatus.IDLE ||\n          // processing went wrong earlier\n          item.status === ItemStatus.PROCESSING_ERROR;\n\n        // not ready to be processed\n        if (!itemCanBeQueuedForProcessing) {\n          var processNow = function processNow() {\n            return dispatch('REQUEST_ITEM_PROCESSING', {\n              query: item,\n              success: success,\n              failure: failure\n            });\n          };\n\n          var process = function process() {\n            return document.hidden ? processNow() : setTimeout(processNow, 32);\n          };\n\n          // if already done processing or tried to revert but didn't work, try again\n          if (\n            item.status === ItemStatus.PROCESSING_COMPLETE ||\n            item.status === ItemStatus.PROCESSING_REVERT_ERROR\n          ) {\n            item\n              .revert(\n                createRevertFunction(\n                  state.options.server.url,\n                  state.options.server.revert\n                ),\n                query('GET_FORCE_REVERT')\n              )\n              .then(process)\n              .catch(function() {}); // don't continue with processing if something went wrong\n          } else if (item.status === ItemStatus.PROCESSING) {\n            item.abortProcessing().then(process);\n          }\n\n          return;\n        }\n\n        // already queued for processing\n        if (item.status === ItemStatus.PROCESSING_QUEUED) return;\n\n        item.requestProcessing();\n\n        dispatch('DID_REQUEST_ITEM_PROCESSING', { id: item.id });\n\n        dispatch(\n          'PROCESS_ITEM',\n          { query: item, success: success, failure: failure },\n          true\n        );\n      }),\n\n      PROCESS_ITEM: getItemByQueryFromState(state, function(\n        item,\n        success,\n        failure\n      ) {\n        var maxParallelUploads = query('GET_MAX_PARALLEL_UPLOADS');\n        var totalCurrentUploads = query(\n          'GET_ITEMS_BY_STATUS',\n          ItemStatus.PROCESSING\n        ).length;\n\n        // queue and wait till queue is freed up\n        if (totalCurrentUploads === maxParallelUploads) {\n          // queue for later processing\n          state.processingQueue.push({\n            id: item.id,\n            success: success,\n            failure: failure\n          });\n\n          // stop it!\n          return;\n        }\n\n        // if was not queued or is already processing exit here\n        if (item.status === ItemStatus.PROCESSING) return;\n\n        var processNext = function processNext() {\n          // process queueud items\n          var queueEntry = state.processingQueue.shift();\n\n          // no items left\n          if (!queueEntry) return;\n\n          // get item reference\n          var id = queueEntry.id,\n            success = queueEntry.success,\n            failure = queueEntry.failure;\n          var itemReference = getItemByQuery(state.items, id);\n\n          // if item was archived while in queue, jump to next\n          if (!itemReference || itemReference.archived) {\n            processNext();\n            return;\n          }\n\n          // process queued item\n          dispatch(\n            'PROCESS_ITEM',\n            { query: id, success: success, failure: failure },\n            true\n          );\n        };\n\n        // we done function\n        item.onOnce('process-complete', function() {\n          success(createItemAPI(item));\n          processNext();\n\n          // All items processed? No errors?\n          var allItemsProcessed =\n            query('GET_ITEMS_BY_STATUS', ItemStatus.PROCESSING_COMPLETE)\n              .length === state.items.length;\n          if (allItemsProcessed) {\n            dispatch('DID_COMPLETE_ITEM_PROCESSING_ALL');\n          }\n        });\n\n        // we error function\n        item.onOnce('process-error', function(error) {\n          failure({ error: error, file: createItemAPI(item) });\n          processNext();\n        });\n\n        // start file processing\n        var options = state.options;\n        item.process(\n          createFileProcessor(\n            createProcessorFunction(\n              options.server.url,\n              options.server.process,\n              options.name,\n              {\n                chunkTransferId: item.transferId,\n                chunkServer: options.server.patch,\n                chunkUploads: options.chunkUploads,\n                chunkForce: options.chunkForce,\n                chunkSize: options.chunkSize,\n                chunkRetryDelays: options.chunkRetryDelays\n              }\n            )\n          ),\n\n          // called when the file is about to be processed so it can be piped through the transform filters\n          function(file, success, error) {\n            // allow plugins to alter the file data\n            applyFilterChain('PREPARE_OUTPUT', file, {\n              query: query,\n              item: item\n            })\n              .then(function(file) {\n                dispatch('DID_PREPARE_OUTPUT', { id: item.id, file: file });\n\n                success(file);\n              })\n              .catch(error);\n          }\n        );\n      }),\n\n      RETRY_ITEM_PROCESSING: getItemByQueryFromState(state, function(item) {\n        dispatch('REQUEST_ITEM_PROCESSING', { query: item });\n      }),\n\n      REQUEST_REMOVE_ITEM: getItemByQueryFromState(state, function(item) {\n        optionalPromise(\n          query('GET_BEFORE_REMOVE_FILE'),\n          createItemAPI(item)\n        ).then(function(shouldRemove) {\n          if (!shouldRemove) {\n            return;\n          }\n          dispatch('REMOVE_ITEM', { query: item });\n        });\n      }),\n\n      RELEASE_ITEM: getItemByQueryFromState(state, function(item) {\n        item.release();\n      }),\n\n      REMOVE_ITEM: getItemByQueryFromState(state, function(\n        item,\n        success,\n        failure,\n        options\n      ) {\n        var removeFromView = function removeFromView() {\n          // get id reference\n          var id = item.id;\n\n          // archive the item, this does not remove it from the list\n          getItemById(state.items, id).archive();\n\n          // tell the view the item has been removed\n          dispatch('DID_REMOVE_ITEM', { error: null, id: id, item: item });\n\n          // now the list has been modified\n          listUpdated(dispatch, state);\n\n          // correctly removed\n          success(createItemAPI(item));\n        };\n\n        // if this is a local file and the server.remove function has been configured, send source there so dev can remove file from server\n        var server = state.options.server;\n        if (\n          item.origin === FileOrigin.LOCAL &&\n          server &&\n          isFunction(server.remove) &&\n          options.remove !== false\n        ) {\n          dispatch('DID_START_ITEM_REMOVE', { id: item.id });\n\n          server.remove(\n            item.source,\n            function() {\n              return removeFromView();\n            },\n            function(status) {\n              dispatch('DID_THROW_ITEM_REMOVE_ERROR', {\n                id: item.id,\n                error: createResponse('error', 0, status, null),\n                status: {\n                  main: dynamicLabel(state.options.labelFileRemoveError)(\n                    status\n                  ),\n                  sub: state.options.labelTapToRetry\n                }\n              });\n            }\n          );\n        } else {\n          // if is requesting revert and can revert need to call revert handler (not calling request_ because that would also trigger beforeRemoveHook)\n          if (\n            options.revert &&\n            item.origin !== FileOrigin.LOCAL &&\n            item.serverId !== null\n          ) {\n            item.revert(\n              createRevertFunction(\n                state.options.server.url,\n                state.options.server.revert\n              ),\n              query('GET_FORCE_REVERT')\n            );\n          }\n\n          // can now safely remove from view\n          removeFromView();\n        }\n      }),\n\n      ABORT_ITEM_LOAD: getItemByQueryFromState(state, function(item) {\n        item.abortLoad();\n      }),\n\n      ABORT_ITEM_PROCESSING: getItemByQueryFromState(state, function(item) {\n        // test if is already processed\n        if (item.serverId) {\n          dispatch('REVERT_ITEM_PROCESSING', { id: item.id });\n          return;\n        }\n\n        // abort\n        item.abortProcessing().then(function() {\n          var shouldRemove = state.options.instantUpload;\n          if (shouldRemove) {\n            dispatch('REMOVE_ITEM', { query: item.id });\n          }\n        });\n      }),\n\n      REQUEST_REVERT_ITEM_PROCESSING: getItemByQueryFromState(state, function(\n        item\n      ) {\n        // not instant uploading, revert immediately\n        if (!state.options.instantUpload) {\n          dispatch('REVERT_ITEM_PROCESSING', { query: item });\n          return;\n        }\n\n        // if we're instant uploading the file will also be removed if we revert,\n        // so if a before remove file hook is defined we need to run it now\n        var handleRevert = function handleRevert(shouldRevert) {\n          if (!shouldRevert) return;\n          dispatch('REVERT_ITEM_PROCESSING', { query: item });\n        };\n\n        var fn = query('GET_BEFORE_REMOVE_FILE');\n        if (!fn) {\n          return handleRevert(true);\n        }\n\n        var requestRemoveResult = fn(createItemAPI(item));\n        if (requestRemoveResult == null) {\n          // undefined or null\n          return handleRevert(true);\n        }\n\n        if (typeof requestRemoveResult === 'boolean') {\n          return handleRevert(requestRemoveResult);\n        }\n\n        if (typeof requestRemoveResult.then === 'function') {\n          requestRemoveResult.then(handleRevert);\n        }\n      }),\n\n      REVERT_ITEM_PROCESSING: getItemByQueryFromState(state, function(item) {\n        item\n          .revert(\n            createRevertFunction(\n              state.options.server.url,\n              state.options.server.revert\n            ),\n            query('GET_FORCE_REVERT')\n          )\n          .then(function() {\n            var shouldRemove = state.options.instantUpload || isMockItem(item);\n            if (shouldRemove) {\n              dispatch('REMOVE_ITEM', { query: item.id });\n            }\n          })\n          .catch(function() {});\n      }),\n\n      SET_OPTIONS: function SET_OPTIONS(_ref11) {\n        var options = _ref11.options;\n        forin(options, function(key, value) {\n          dispatch('SET_' + fromCamels(key, '_').toUpperCase(), {\n            value: value\n          });\n        });\n      }\n    };\n  };\n\n  var formatFilename = function formatFilename(name) {\n    return name;\n  };\n\n  var createElement$1 = function createElement(tagName) {\n    return document.createElement(tagName);\n  };\n\n  var text = function text(node, value) {\n    var textNode = node.childNodes[0];\n    if (!textNode) {\n      textNode = document.createTextNode(value);\n      node.appendChild(textNode);\n    } else if (value !== textNode.nodeValue) {\n      textNode.nodeValue = value;\n    }\n  };\n\n  var polarToCartesian = function polarToCartesian(\n    centerX,\n    centerY,\n    radius,\n    angleInDegrees\n  ) {\n    var angleInRadians = (((angleInDegrees % 360) - 90) * Math.PI) / 180.0;\n    return {\n      x: centerX + radius * Math.cos(angleInRadians),\n      y: centerY + radius * Math.sin(angleInRadians)\n    };\n  };\n\n  var describeArc = function describeArc(\n    x,\n    y,\n    radius,\n    startAngle,\n    endAngle,\n    arcSweep\n  ) {\n    var start = polarToCartesian(x, y, radius, endAngle);\n    var end = polarToCartesian(x, y, radius, startAngle);\n    return [\n      'M',\n      start.x,\n      start.y,\n      'A',\n      radius,\n      radius,\n      0,\n      arcSweep,\n      0,\n      end.x,\n      end.y\n    ].join(' ');\n  };\n\n  var percentageArc = function percentageArc(x, y, radius, from, to) {\n    var arcSweep = 1;\n    if (to > from && to - from <= 0.5) {\n      arcSweep = 0;\n    }\n    if (from > to && from - to >= 0.5) {\n      arcSweep = 0;\n    }\n    return describeArc(\n      x,\n      y,\n      radius,\n      Math.min(0.9999, from) * 360,\n      Math.min(0.9999, to) * 360,\n      arcSweep\n    );\n  };\n\n  var create = function create(_ref) {\n    var root = _ref.root,\n      props = _ref.props;\n    // start at 0\n    props.spin = false;\n    props.progress = 0;\n    props.opacity = 0;\n\n    // svg\n    var svg = createElement('svg');\n    root.ref.path = createElement('path', {\n      'stroke-width': 2,\n      'stroke-linecap': 'round'\n    });\n\n    svg.appendChild(root.ref.path);\n\n    root.ref.svg = svg;\n\n    root.appendChild(svg);\n  };\n\n  var write = function write(_ref2) {\n    var root = _ref2.root,\n      props = _ref2.props;\n\n    if (props.opacity === 0) {\n      return;\n    }\n\n    if (props.align) {\n      root.element.dataset.align = props.align;\n    }\n\n    // get width of stroke\n    var ringStrokeWidth = parseInt(attr(root.ref.path, 'stroke-width'), 10);\n\n    // calculate size of ring\n    var size = root.rect.element.width * 0.5;\n\n    // ring state\n    var ringFrom = 0;\n    var ringTo = 0;\n\n    // now in busy mode\n    if (props.spin) {\n      ringFrom = 0;\n      ringTo = 0.5;\n    } else {\n      ringFrom = 0;\n      ringTo = props.progress;\n    }\n\n    // get arc path\n    var coordinates = percentageArc(\n      size,\n      size,\n      size - ringStrokeWidth,\n      ringFrom,\n      ringTo\n    );\n\n    // update progress bar\n    attr(root.ref.path, 'd', coordinates);\n\n    // hide while contains 0 value\n    attr(\n      root.ref.path,\n      'stroke-opacity',\n      props.spin || props.progress > 0 ? 1 : 0\n    );\n  };\n\n  var progressIndicator = createView({\n    tag: 'div',\n    name: 'progress-indicator',\n    ignoreRectUpdate: true,\n    ignoreRect: true,\n    create: create,\n    write: write,\n    mixins: {\n      apis: ['progress', 'spin', 'align'],\n      styles: ['opacity'],\n      animations: {\n        opacity: { type: 'tween', duration: 500 },\n        progress: {\n          type: 'spring',\n          stiffness: 0.95,\n          damping: 0.65,\n          mass: 10\n        }\n      }\n    }\n  });\n\n  var create$1 = function create(_ref) {\n    var root = _ref.root,\n      props = _ref.props;\n    root.element.innerHTML =\n      (props.icon || '') + ('<span>' + props.label + '</span>');\n\n    props.isDisabled = false;\n  };\n\n  var write$1 = function write(_ref2) {\n    var root = _ref2.root,\n      props = _ref2.props;\n    var isDisabled = props.isDisabled;\n    var shouldDisable = root.query('GET_DISABLED') || props.opacity === 0;\n\n    if (shouldDisable && !isDisabled) {\n      props.isDisabled = true;\n      attr(root.element, 'disabled', 'disabled');\n    } else if (!shouldDisable && isDisabled) {\n      props.isDisabled = false;\n      root.element.removeAttribute('disabled');\n    }\n  };\n\n  var fileActionButton = createView({\n    tag: 'button',\n    attributes: {\n      type: 'button'\n    },\n\n    ignoreRect: true,\n    ignoreRectUpdate: true,\n    name: 'file-action-button',\n    mixins: {\n      apis: ['label'],\n      styles: ['translateX', 'translateY', 'scaleX', 'scaleY', 'opacity'],\n      animations: {\n        scaleX: 'spring',\n        scaleY: 'spring',\n        translateX: 'spring',\n        translateY: 'spring',\n        opacity: { type: 'tween', duration: 250 }\n      },\n\n      listeners: true\n    },\n\n    create: create$1,\n    write: write$1\n  });\n\n  var toNaturalFileSize = function toNaturalFileSize(bytes) {\n    var decimalSeparator =\n      arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '.';\n    var base =\n      arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1000;\n    // no negative byte sizes\n    bytes = Math.round(Math.abs(bytes));\n\n    var KB = base;\n    var MB = base * base;\n    var GB = base * base * base;\n\n    // just bytes\n    if (bytes < KB) {\n      return bytes + ' bytes';\n    }\n\n    // kilobytes\n    if (bytes < MB) {\n      return Math.floor(bytes / KB) + ' KB';\n    }\n\n    // megabytes\n    if (bytes < GB) {\n      return removeDecimalsWhenZero(bytes / MB, 1, decimalSeparator) + ' MB';\n    }\n\n    // gigabytes\n    return removeDecimalsWhenZero(bytes / GB, 2, decimalSeparator) + ' GB';\n  };\n\n  var removeDecimalsWhenZero = function removeDecimalsWhenZero(\n    value,\n    decimalCount,\n    separator\n  ) {\n    return value\n      .toFixed(decimalCount)\n      .split('.')\n      .filter(function(part) {\n        return part !== '0';\n      })\n      .join(separator);\n  };\n\n  var create$2 = function create(_ref) {\n    var root = _ref.root,\n      props = _ref.props;\n    // filename\n    var fileName = createElement$1('span');\n    fileName.className = 'filepond--file-info-main';\n    // hide for screenreaders\n    // the file is contained in a fieldset with legend that contains the filename\n    // no need to read it twice\n    attr(fileName, 'aria-hidden', 'true');\n    root.appendChild(fileName);\n    root.ref.fileName = fileName;\n\n    // filesize\n    var fileSize = createElement$1('span');\n    fileSize.className = 'filepond--file-info-sub';\n    root.appendChild(fileSize);\n    root.ref.fileSize = fileSize;\n\n    // set initial values\n    text(fileSize, root.query('GET_LABEL_FILE_WAITING_FOR_SIZE'));\n    text(fileName, formatFilename(root.query('GET_ITEM_NAME', props.id)));\n  };\n\n  var updateFile = function updateFile(_ref2) {\n    var root = _ref2.root,\n      props = _ref2.props;\n    text(\n      root.ref.fileSize,\n      toNaturalFileSize(\n        root.query('GET_ITEM_SIZE', props.id),\n        '.',\n        root.query('GET_FILE_SIZE_BASE')\n      )\n    );\n\n    text(\n      root.ref.fileName,\n      formatFilename(root.query('GET_ITEM_NAME', props.id))\n    );\n  };\n\n  var updateFileSizeOnError = function updateFileSizeOnError(_ref3) {\n    var root = _ref3.root,\n      props = _ref3.props;\n    // if size is available don't fallback to unknown size message\n    if (isInt(root.query('GET_ITEM_SIZE', props.id))) {\n      return;\n    }\n\n    text(root.ref.fileSize, root.query('GET_LABEL_FILE_SIZE_NOT_AVAILABLE'));\n  };\n\n  var fileInfo = createView({\n    name: 'file-info',\n    ignoreRect: true,\n    ignoreRectUpdate: true,\n    write: createRoute({\n      DID_LOAD_ITEM: updateFile,\n      DID_UPDATE_ITEM_META: updateFile,\n      DID_THROW_ITEM_LOAD_ERROR: updateFileSizeOnError,\n      DID_THROW_ITEM_INVALID: updateFileSizeOnError\n    }),\n\n    didCreateView: function didCreateView(root) {\n      applyFilters('CREATE_VIEW', Object.assign({}, root, { view: root }));\n    },\n    create: create$2,\n    mixins: {\n      styles: ['translateX', 'translateY'],\n      animations: {\n        translateX: 'spring',\n        translateY: 'spring'\n      }\n    }\n  });\n\n  var toPercentage = function toPercentage(value) {\n    return Math.round(value * 100);\n  };\n\n  var create$3 = function create(_ref) {\n    var root = _ref.root;\n\n    // main status\n    var main = createElement$1('span');\n    main.className = 'filepond--file-status-main';\n    root.appendChild(main);\n    root.ref.main = main;\n\n    // sub status\n    var sub = createElement$1('span');\n    sub.className = 'filepond--file-status-sub';\n    root.appendChild(sub);\n    root.ref.sub = sub;\n\n    didSetItemLoadProgress({ root: root, action: { progress: null } });\n  };\n\n  var didSetItemLoadProgress = function didSetItemLoadProgress(_ref2) {\n    var root = _ref2.root,\n      action = _ref2.action;\n    var title =\n      action.progress === null\n        ? root.query('GET_LABEL_FILE_LOADING')\n        : root.query('GET_LABEL_FILE_LOADING') +\n          ' ' +\n          toPercentage(action.progress) +\n          '%';\n\n    text(root.ref.main, title);\n    text(root.ref.sub, root.query('GET_LABEL_TAP_TO_CANCEL'));\n  };\n\n  var didSetItemProcessProgress = function didSetItemProcessProgress(_ref3) {\n    var root = _ref3.root,\n      action = _ref3.action;\n    var title =\n      action.progress === null\n        ? root.query('GET_LABEL_FILE_PROCESSING')\n        : root.query('GET_LABEL_FILE_PROCESSING') +\n          ' ' +\n          toPercentage(action.progress) +\n          '%';\n\n    text(root.ref.main, title);\n    text(root.ref.sub, root.query('GET_LABEL_TAP_TO_CANCEL'));\n  };\n\n  var didRequestItemProcessing = function didRequestItemProcessing(_ref4) {\n    var root = _ref4.root;\n    text(root.ref.main, root.query('GET_LABEL_FILE_PROCESSING'));\n    text(root.ref.sub, root.query('GET_LABEL_TAP_TO_CANCEL'));\n  };\n\n  var didAbortItemProcessing = function didAbortItemProcessing(_ref5) {\n    var root = _ref5.root;\n    text(root.ref.main, root.query('GET_LABEL_FILE_PROCESSING_ABORTED'));\n    text(root.ref.sub, root.query('GET_LABEL_TAP_TO_RETRY'));\n  };\n\n  var didCompleteItemProcessing = function didCompleteItemProcessing(_ref6) {\n    var root = _ref6.root;\n    text(root.ref.main, root.query('GET_LABEL_FILE_PROCESSING_COMPLETE'));\n    text(root.ref.sub, root.query('GET_LABEL_TAP_TO_UNDO'));\n  };\n\n  var clear = function clear(_ref7) {\n    var root = _ref7.root;\n    text(root.ref.main, '');\n    text(root.ref.sub, '');\n  };\n\n  var error = function error(_ref8) {\n    var root = _ref8.root,\n      action = _ref8.action;\n    text(root.ref.main, action.status.main);\n    text(root.ref.sub, action.status.sub);\n  };\n\n  var fileStatus = createView({\n    name: 'file-status',\n    ignoreRect: true,\n    ignoreRectUpdate: true,\n    write: createRoute({\n      DID_LOAD_ITEM: clear,\n      DID_REVERT_ITEM_PROCESSING: clear,\n      DID_REQUEST_ITEM_PROCESSING: didRequestItemProcessing,\n      DID_ABORT_ITEM_PROCESSING: didAbortItemProcessing,\n      DID_COMPLETE_ITEM_PROCESSING: didCompleteItemProcessing,\n      DID_UPDATE_ITEM_PROCESS_PROGRESS: didSetItemProcessProgress,\n      DID_UPDATE_ITEM_LOAD_PROGRESS: didSetItemLoadProgress,\n      DID_THROW_ITEM_LOAD_ERROR: error,\n      DID_THROW_ITEM_INVALID: error,\n      DID_THROW_ITEM_PROCESSING_ERROR: error,\n      DID_THROW_ITEM_PROCESSING_REVERT_ERROR: error,\n      DID_THROW_ITEM_REMOVE_ERROR: error\n    }),\n\n    didCreateView: function didCreateView(root) {\n      applyFilters('CREATE_VIEW', Object.assign({}, root, { view: root }));\n    },\n    create: create$3,\n    mixins: {\n      styles: ['translateX', 'translateY', 'opacity'],\n      animations: {\n        opacity: { type: 'tween', duration: 250 },\n        translateX: 'spring',\n        translateY: 'spring'\n      }\n    }\n  });\n\n  /**\n   * Button definitions for the file view\n   */\n\n  var Buttons = {\n    AbortItemLoad: {\n      label: 'GET_LABEL_BUTTON_ABORT_ITEM_LOAD',\n      action: 'ABORT_ITEM_LOAD',\n      className: 'filepond--action-abort-item-load',\n      align: 'LOAD_INDICATOR_POSITION' // right\n    },\n    RetryItemLoad: {\n      label: 'GET_LABEL_BUTTON_RETRY_ITEM_LOAD',\n      action: 'RETRY_ITEM_LOAD',\n      icon: 'GET_ICON_RETRY',\n      className: 'filepond--action-retry-item-load',\n      align: 'BUTTON_PROCESS_ITEM_POSITION' // right\n    },\n    RemoveItem: {\n      label: 'GET_LABEL_BUTTON_REMOVE_ITEM',\n      action: 'REQUEST_REMOVE_ITEM',\n      icon: 'GET_ICON_REMOVE',\n      className: 'filepond--action-remove-item',\n      align: 'BUTTON_REMOVE_ITEM_POSITION' // left\n    },\n    ProcessItem: {\n      label: 'GET_LABEL_BUTTON_PROCESS_ITEM',\n      action: 'REQUEST_ITEM_PROCESSING',\n      icon: 'GET_ICON_PROCESS',\n      className: 'filepond--action-process-item',\n      align: 'BUTTON_PROCESS_ITEM_POSITION' // right\n    },\n    AbortItemProcessing: {\n      label: 'GET_LABEL_BUTTON_ABORT_ITEM_PROCESSING',\n      action: 'ABORT_ITEM_PROCESSING',\n      className: 'filepond--action-abort-item-processing',\n      align: 'BUTTON_PROCESS_ITEM_POSITION' // right\n    },\n    RetryItemProcessing: {\n      label: 'GET_LABEL_BUTTON_RETRY_ITEM_PROCESSING',\n      action: 'RETRY_ITEM_PROCESSING',\n      icon: 'GET_ICON_RETRY',\n      className: 'filepond--action-retry-item-processing',\n      align: 'BUTTON_PROCESS_ITEM_POSITION' // right\n    },\n    RevertItemProcessing: {\n      label: 'GET_LABEL_BUTTON_UNDO_ITEM_PROCESSING',\n      action: 'REQUEST_REVERT_ITEM_PROCESSING',\n      icon: 'GET_ICON_UNDO',\n      className: 'filepond--action-revert-item-processing',\n      align: 'BUTTON_PROCESS_ITEM_POSITION' // right\n    }\n  };\n\n  // make a list of buttons, we can then remove buttons from this list if they're disabled\n  var ButtonKeys = [];\n  forin(Buttons, function(key) {\n    ButtonKeys.push(key);\n  });\n\n  var calculateFileInfoOffset = function calculateFileInfoOffset(root) {\n    var buttonRect = root.ref.buttonRemoveItem.rect.element;\n    return buttonRect.hidden ? null : buttonRect.width + buttonRect.left;\n  };\n\n  var calculateButtonWidth = function calculateButtonWidth(root) {\n    var buttonRect = root.ref.buttonAbortItemLoad.rect.element;\n    return buttonRect.width;\n  };\n\n  // Force on full pixels so text stays crips\n  var calculateFileVerticalCenterOffset = function calculateFileVerticalCenterOffset(\n    root\n  ) {\n    return Math.floor(root.ref.buttonRemoveItem.rect.element.height / 4);\n  };\n  var calculateFileHorizontalCenterOffset = function calculateFileHorizontalCenterOffset(\n    root\n  ) {\n    return Math.floor(root.ref.buttonRemoveItem.rect.element.left / 2);\n  };\n\n  var getLoadIndicatorAlignment = function getLoadIndicatorAlignment(root) {\n    return root.query('GET_STYLE_LOAD_INDICATOR_POSITION');\n  };\n  var getProcessIndicatorAlignment = function getProcessIndicatorAlignment(\n    root\n  ) {\n    return root.query('GET_STYLE_PROGRESS_INDICATOR_POSITION');\n  };\n  var getRemoveIndicatorAligment = function getRemoveIndicatorAligment(root) {\n    return root.query('GET_STYLE_BUTTON_REMOVE_ITEM_POSITION');\n  };\n\n  var DefaultStyle = {\n    buttonAbortItemLoad: { opacity: 0 },\n    buttonRetryItemLoad: { opacity: 0 },\n    buttonRemoveItem: { opacity: 0 },\n    buttonProcessItem: { opacity: 0 },\n    buttonAbortItemProcessing: { opacity: 0 },\n    buttonRetryItemProcessing: { opacity: 0 },\n    buttonRevertItemProcessing: { opacity: 0 },\n    loadProgressIndicator: { opacity: 0, align: getLoadIndicatorAlignment },\n    processProgressIndicator: {\n      opacity: 0,\n      align: getProcessIndicatorAlignment\n    },\n    processingCompleteIndicator: { opacity: 0, scaleX: 0.75, scaleY: 0.75 },\n    info: { translateX: 0, translateY: 0, opacity: 0 },\n    status: { translateX: 0, translateY: 0, opacity: 0 }\n  };\n\n  var IdleStyle = {\n    buttonRemoveItem: { opacity: 1 },\n    buttonProcessItem: { opacity: 1 },\n    info: { translateX: calculateFileInfoOffset },\n    status: { translateX: calculateFileInfoOffset }\n  };\n\n  var ProcessingStyle = {\n    buttonAbortItemProcessing: { opacity: 1 },\n    processProgressIndicator: { opacity: 1 },\n    status: { opacity: 1 }\n  };\n\n  var StyleMap = {\n    DID_THROW_ITEM_INVALID: {\n      buttonRemoveItem: { opacity: 1 },\n      info: { translateX: calculateFileInfoOffset },\n      status: { translateX: calculateFileInfoOffset, opacity: 1 }\n    },\n\n    DID_START_ITEM_LOAD: {\n      buttonAbortItemLoad: { opacity: 1 },\n      loadProgressIndicator: { opacity: 1 },\n      status: { opacity: 1 }\n    },\n\n    DID_THROW_ITEM_LOAD_ERROR: {\n      buttonRetryItemLoad: { opacity: 1 },\n      buttonRemoveItem: { opacity: 1 },\n      info: { translateX: calculateFileInfoOffset },\n      status: { opacity: 1 }\n    },\n\n    DID_START_ITEM_REMOVE: {\n      processProgressIndicator: {\n        opacity: 1,\n        align: getRemoveIndicatorAligment\n      },\n      info: { translateX: calculateFileInfoOffset },\n      status: { opacity: 0 }\n    },\n\n    DID_THROW_ITEM_REMOVE_ERROR: {\n      processProgressIndicator: {\n        opacity: 0,\n        align: getRemoveIndicatorAligment\n      },\n      buttonRemoveItem: { opacity: 1 },\n      info: { translateX: calculateFileInfoOffset },\n      status: { opacity: 1, translateX: calculateFileInfoOffset }\n    },\n\n    DID_LOAD_ITEM: IdleStyle,\n    DID_LOAD_LOCAL_ITEM: {\n      buttonRemoveItem: { opacity: 1 },\n      info: { translateX: calculateFileInfoOffset },\n      status: { translateX: calculateFileInfoOffset }\n    },\n\n    DID_START_ITEM_PROCESSING: ProcessingStyle,\n    DID_REQUEST_ITEM_PROCESSING: ProcessingStyle,\n    DID_UPDATE_ITEM_PROCESS_PROGRESS: ProcessingStyle,\n    DID_COMPLETE_ITEM_PROCESSING: {\n      buttonRevertItemProcessing: { opacity: 1 },\n      info: { opacity: 1 },\n      status: { opacity: 1 }\n    },\n\n    DID_THROW_ITEM_PROCESSING_ERROR: {\n      buttonRemoveItem: { opacity: 1 },\n      buttonRetryItemProcessing: { opacity: 1 },\n      status: { opacity: 1 },\n      info: { translateX: calculateFileInfoOffset }\n    },\n\n    DID_THROW_ITEM_PROCESSING_REVERT_ERROR: {\n      buttonRevertItemProcessing: { opacity: 1 },\n      status: { opacity: 1 },\n      info: { opacity: 1 }\n    },\n\n    DID_ABORT_ITEM_PROCESSING: {\n      buttonRemoveItem: { opacity: 1 },\n      buttonProcessItem: { opacity: 1 },\n      info: { translateX: calculateFileInfoOffset },\n      status: { opacity: 1 }\n    },\n\n    DID_REVERT_ITEM_PROCESSING: IdleStyle\n  };\n\n  // complete indicator view\n  var processingCompleteIndicatorView = createView({\n    create: function create(_ref) {\n      var root = _ref.root;\n      root.element.innerHTML = root.query('GET_ICON_DONE');\n    },\n    name: 'processing-complete-indicator',\n    ignoreRect: true,\n    mixins: {\n      styles: ['scaleX', 'scaleY', 'opacity'],\n      animations: {\n        scaleX: 'spring',\n        scaleY: 'spring',\n        opacity: { type: 'tween', duration: 250 }\n      }\n    }\n  });\n\n  /**\n   * Creates the file view\n   */\n  var create$4 = function create(_ref2) {\n    var root = _ref2.root,\n      props = _ref2.props;\n    var id = props.id;\n\n    // allow reverting upload\n    var allowRevert = root.query('GET_ALLOW_REVERT');\n\n    // allow remove file\n    var allowRemove = root.query('GET_ALLOW_REMOVE');\n\n    // allow processing upload\n    var allowProcess = root.query('GET_ALLOW_PROCESS');\n\n    // is instant uploading, need this to determine the icon of the undo button\n    var instantUpload = root.query('GET_INSTANT_UPLOAD');\n\n    // is async set up\n    var isAsync = root.query('IS_ASYNC');\n\n    // should align remove item buttons\n    var alignRemoveItemButton = root.query(\n      'GET_STYLE_BUTTON_REMOVE_ITEM_ALIGN'\n    );\n\n    // enabled buttons array\n    var buttonFilter;\n    if (isAsync) {\n      if (allowProcess && !allowRevert) {\n        // only remove revert button\n        buttonFilter = function buttonFilter(key) {\n          return !/RevertItemProcessing/.test(key);\n        };\n      } else if (!allowProcess && allowRevert) {\n        // only remove process button\n        buttonFilter = function buttonFilter(key) {\n          return !/ProcessItem|RetryItemProcessing|AbortItemProcessing/.test(\n            key\n          );\n        };\n      } else if (!allowProcess && !allowRevert) {\n        // remove all process buttons\n        buttonFilter = function buttonFilter(key) {\n          return !/Process/.test(key);\n        };\n      }\n    } else {\n      // no process controls available\n      buttonFilter = function buttonFilter(key) {\n        return !/Process/.test(key);\n      };\n    }\n\n    var enabledButtons = buttonFilter\n      ? ButtonKeys.filter(buttonFilter)\n      : ButtonKeys.concat();\n\n    // update icon and label for revert button when instant uploading\n    if (instantUpload && allowRevert) {\n      Buttons['RevertItemProcessing'].label = 'GET_LABEL_BUTTON_REMOVE_ITEM';\n      Buttons['RevertItemProcessing'].icon = 'GET_ICON_REMOVE';\n    }\n\n    // remove last button (revert) if not allowed\n    if (isAsync && !allowRevert) {\n      var map = StyleMap['DID_COMPLETE_ITEM_PROCESSING'];\n      map.info.translateX = calculateFileHorizontalCenterOffset;\n      map.info.translateY = calculateFileVerticalCenterOffset;\n      map.status.translateY = calculateFileVerticalCenterOffset;\n      map.processingCompleteIndicator = { opacity: 1, scaleX: 1, scaleY: 1 };\n    }\n\n    // should align center\n    if (isAsync && !allowProcess) {\n      [\n        'DID_START_ITEM_PROCESSING',\n        'DID_REQUEST_ITEM_PROCESSING',\n        'DID_UPDATE_ITEM_PROCESS_PROGRESS',\n        'DID_THROW_ITEM_PROCESSING_ERROR'\n      ].forEach(function(key) {\n        StyleMap[key].status.translateY = calculateFileVerticalCenterOffset;\n      });\n      StyleMap[\n        'DID_THROW_ITEM_PROCESSING_ERROR'\n      ].status.translateX = calculateButtonWidth;\n    }\n\n    // move remove button to right\n    if (alignRemoveItemButton && allowRevert) {\n      Buttons['RevertItemProcessing'].align = 'BUTTON_REMOVE_ITEM_POSITION';\n      var _map = StyleMap['DID_COMPLETE_ITEM_PROCESSING'];\n      _map.info.translateX = calculateFileInfoOffset;\n      _map.status.translateY = calculateFileVerticalCenterOffset;\n      _map.processingCompleteIndicator = { opacity: 1, scaleX: 1, scaleY: 1 };\n    }\n\n    if (!allowRemove) {\n      Buttons['RemoveItem'].disabled = true;\n    }\n\n    // create the button views\n    forin(Buttons, function(key, definition) {\n      // create button\n      var buttonView = root.createChildView(fileActionButton, {\n        label: root.query(definition.label),\n        icon: root.query(definition.icon),\n        opacity: 0\n      });\n\n      // should be appended?\n      if (enabledButtons.includes(key)) {\n        root.appendChildView(buttonView);\n      }\n\n      // toggle\n      if (definition.disabled) {\n        buttonView.element.setAttribute('disabled', 'disabled');\n        buttonView.element.setAttribute('hidden', 'hidden');\n      }\n\n      // add position attribute\n      buttonView.element.dataset.align = root.query(\n        'GET_STYLE_' + definition.align\n      );\n\n      // add class\n      buttonView.element.classList.add(definition.className);\n\n      // handle interactions\n      buttonView.on('click', function(e) {\n        e.stopPropagation();\n        if (definition.disabled) return;\n        root.dispatch(definition.action, { query: id });\n      });\n\n      // set reference\n      root.ref['button' + key] = buttonView;\n    });\n\n    // checkmark\n    root.ref.processingCompleteIndicator = root.appendChildView(\n      root.createChildView(processingCompleteIndicatorView)\n    );\n    root.ref.processingCompleteIndicator.element.dataset.align = root.query(\n      'GET_STYLE_BUTTON_PROCESS_ITEM_POSITION'\n    );\n\n    // create file info view\n    root.ref.info = root.appendChildView(\n      root.createChildView(fileInfo, { id: id })\n    );\n\n    // create file status view\n    root.ref.status = root.appendChildView(\n      root.createChildView(fileStatus, { id: id })\n    );\n\n    // add progress indicators\n    var loadIndicatorView = root.appendChildView(\n      root.createChildView(progressIndicator, {\n        opacity: 0,\n        align: root.query('GET_STYLE_LOAD_INDICATOR_POSITION')\n      })\n    );\n\n    loadIndicatorView.element.classList.add('filepond--load-indicator');\n    root.ref.loadProgressIndicator = loadIndicatorView;\n\n    var progressIndicatorView = root.appendChildView(\n      root.createChildView(progressIndicator, {\n        opacity: 0,\n        align: root.query('GET_STYLE_PROGRESS_INDICATOR_POSITION')\n      })\n    );\n\n    progressIndicatorView.element.classList.add('filepond--process-indicator');\n    root.ref.processProgressIndicator = progressIndicatorView;\n\n    // current active styles\n    root.ref.activeStyles = [];\n  };\n\n  var write$2 = function write(_ref3) {\n    var root = _ref3.root,\n      actions = _ref3.actions,\n      props = _ref3.props;\n\n    // route actions\n    route({ root: root, actions: actions, props: props });\n\n    // select last state change action\n    var action = actions\n      .concat()\n      .filter(function(action) {\n        return /^DID_/.test(action.type);\n      })\n      .reverse()\n      .find(function(action) {\n        return StyleMap[action.type];\n      });\n\n    // a new action happened, let's get the matching styles\n    if (action) {\n      // define new active styles\n      root.ref.activeStyles = [];\n\n      var stylesToApply = StyleMap[action.type];\n      forin(DefaultStyle, function(name, defaultStyles) {\n        // get reference to control\n        var control = root.ref[name];\n\n        // loop over all styles for this control\n        forin(defaultStyles, function(key, defaultValue) {\n          var value =\n            stylesToApply[name] &&\n            typeof stylesToApply[name][key] !== 'undefined'\n              ? stylesToApply[name][key]\n              : defaultValue;\n          root.ref.activeStyles.push({\n            control: control,\n            key: key,\n            value: value\n          });\n        });\n      });\n    }\n\n    // apply active styles to element\n    root.ref.activeStyles.forEach(function(_ref4) {\n      var control = _ref4.control,\n        key = _ref4.key,\n        value = _ref4.value;\n      control[key] = typeof value === 'function' ? value(root) : value;\n    });\n  };\n\n  var route = createRoute({\n    DID_SET_LABEL_BUTTON_ABORT_ITEM_PROCESSING: function DID_SET_LABEL_BUTTON_ABORT_ITEM_PROCESSING(\n      _ref5\n    ) {\n      var root = _ref5.root,\n        action = _ref5.action;\n      root.ref.buttonAbortItemProcessing.label = action.value;\n    },\n    DID_SET_LABEL_BUTTON_ABORT_ITEM_LOAD: function DID_SET_LABEL_BUTTON_ABORT_ITEM_LOAD(\n      _ref6\n    ) {\n      var root = _ref6.root,\n        action = _ref6.action;\n      root.ref.buttonAbortItemLoad.label = action.value;\n    },\n    DID_SET_LABEL_BUTTON_ABORT_ITEM_REMOVAL: function DID_SET_LABEL_BUTTON_ABORT_ITEM_REMOVAL(\n      _ref7\n    ) {\n      var root = _ref7.root,\n        action = _ref7.action;\n      root.ref.buttonAbortItemRemoval.label = action.value;\n    },\n    DID_REQUEST_ITEM_PROCESSING: function DID_REQUEST_ITEM_PROCESSING(_ref8) {\n      var root = _ref8.root;\n      root.ref.processProgressIndicator.spin = true;\n      root.ref.processProgressIndicator.progress = 0;\n    },\n    DID_START_ITEM_LOAD: function DID_START_ITEM_LOAD(_ref9) {\n      var root = _ref9.root;\n      root.ref.loadProgressIndicator.spin = true;\n      root.ref.loadProgressIndicator.progress = 0;\n    },\n    DID_START_ITEM_REMOVE: function DID_START_ITEM_REMOVE(_ref10) {\n      var root = _ref10.root;\n      root.ref.processProgressIndicator.spin = true;\n      root.ref.processProgressIndicator.progress = 0;\n    },\n    DID_UPDATE_ITEM_LOAD_PROGRESS: function DID_UPDATE_ITEM_LOAD_PROGRESS(\n      _ref11\n    ) {\n      var root = _ref11.root,\n        action = _ref11.action;\n      root.ref.loadProgressIndicator.spin = false;\n      root.ref.loadProgressIndicator.progress = action.progress;\n    },\n    DID_UPDATE_ITEM_PROCESS_PROGRESS: function DID_UPDATE_ITEM_PROCESS_PROGRESS(\n      _ref12\n    ) {\n      var root = _ref12.root,\n        action = _ref12.action;\n      root.ref.processProgressIndicator.spin = false;\n      root.ref.processProgressIndicator.progress = action.progress;\n    }\n  });\n\n  var file = createView({\n    create: create$4,\n    write: write$2,\n    didCreateView: function didCreateView(root) {\n      applyFilters('CREATE_VIEW', Object.assign({}, root, { view: root }));\n    },\n    name: 'file'\n  });\n\n  /**\n   * Creates the file view\n   */\n  var create$5 = function create(_ref) {\n    var root = _ref.root,\n      props = _ref.props;\n\n    // filename\n    root.ref.fileName = createElement$1('legend');\n    root.appendChild(root.ref.fileName);\n\n    // file appended\n    root.ref.file = root.appendChildView(\n      root.createChildView(file, { id: props.id })\n    );\n\n    // data has moved to data.js\n    root.ref.data = false;\n  };\n\n  /**\n   * Data storage\n   */\n  var didLoadItem = function didLoadItem(_ref2) {\n    var root = _ref2.root,\n      props = _ref2.props;\n    // updates the legend of the fieldset so screenreaders can better group buttons\n    text(\n      root.ref.fileName,\n      formatFilename(root.query('GET_ITEM_NAME', props.id))\n    );\n  };\n\n  var fileWrapper = createView({\n    create: create$5,\n    ignoreRect: true,\n    write: createRoute({\n      DID_LOAD_ITEM: didLoadItem\n    }),\n\n    didCreateView: function didCreateView(root) {\n      applyFilters('CREATE_VIEW', Object.assign({}, root, { view: root }));\n    },\n    tag: 'fieldset',\n    name: 'file-wrapper'\n  });\n\n  var PANEL_SPRING_PROPS = { type: 'spring', damping: 0.6, mass: 7 };\n\n  var create$6 = function create(_ref) {\n    var root = _ref.root,\n      props = _ref.props;\n    [\n      {\n        name: 'top'\n      },\n\n      {\n        name: 'center',\n        props: {\n          translateY: null,\n          scaleY: null\n        },\n\n        mixins: {\n          animations: {\n            scaleY: PANEL_SPRING_PROPS\n          },\n\n          styles: ['translateY', 'scaleY']\n        }\n      },\n\n      {\n        name: 'bottom',\n        props: {\n          translateY: null\n        },\n\n        mixins: {\n          animations: {\n            translateY: PANEL_SPRING_PROPS\n          },\n\n          styles: ['translateY']\n        }\n      }\n    ].forEach(function(section) {\n      createSection(root, section, props.name);\n    });\n\n    root.element.classList.add('filepond--' + props.name);\n\n    root.ref.scalable = null;\n  };\n\n  var createSection = function createSection(root, section, className) {\n    var viewConstructor = createView({\n      name: 'panel-' + section.name + ' filepond--' + className,\n      mixins: section.mixins,\n      ignoreRectUpdate: true\n    });\n\n    var view = root.createChildView(viewConstructor, section.props);\n\n    root.ref[section.name] = root.appendChildView(view);\n  };\n\n  var write$3 = function write(_ref2) {\n    var root = _ref2.root,\n      props = _ref2.props;\n\n    // update scalable state\n    if (root.ref.scalable === null || props.scalable !== root.ref.scalable) {\n      root.ref.scalable = isBoolean(props.scalable) ? props.scalable : true;\n      root.element.dataset.scalable = root.ref.scalable;\n    }\n\n    // no height, can't set\n    if (!props.height) return;\n\n    // get child rects\n    var topRect = root.ref.top.rect.element;\n    var bottomRect = root.ref.bottom.rect.element;\n\n    // make sure height never is smaller than bottom and top seciton heights combined (will probably never happen, but who knows)\n    var height = Math.max(topRect.height + bottomRect.height, props.height);\n\n    // offset center part\n    root.ref.center.translateY = topRect.height;\n\n    // scale center part\n    // use math ceil to prevent transparent lines because of rounding errors\n    root.ref.center.scaleY =\n      (height - topRect.height - bottomRect.height) / 100;\n\n    // offset bottom part\n    root.ref.bottom.translateY = height - bottomRect.height;\n  };\n\n  var panel = createView({\n    name: 'panel',\n    read: function read(_ref3) {\n      var root = _ref3.root,\n        props = _ref3.props;\n      return (props.heightCurrent = root.ref.bottom.translateY);\n    },\n    write: write$3,\n    create: create$6,\n    ignoreRect: true,\n    mixins: {\n      apis: ['height', 'heightCurrent', 'scalable']\n    }\n  });\n\n  var createDragHelper = function createDragHelper(items) {\n    var itemIds = items.map(function(item) {\n      return item.id;\n    });\n    var prevIndex = undefined;\n    return {\n      setIndex: function setIndex(index) {\n        prevIndex = index;\n      },\n      getIndex: function getIndex() {\n        return prevIndex;\n      },\n      getItemIndex: function getItemIndex(item) {\n        return itemIds.indexOf(item.id);\n      }\n    };\n  };\n\n  var ITEM_TRANSLATE_SPRING = {\n    type: 'spring',\n    stiffness: 0.75,\n    damping: 0.45,\n    mass: 10\n  };\n\n  var ITEM_SCALE_SPRING = 'spring';\n\n  var StateMap = {\n    DID_START_ITEM_LOAD: 'busy',\n    DID_UPDATE_ITEM_LOAD_PROGRESS: 'loading',\n    DID_THROW_ITEM_INVALID: 'load-invalid',\n    DID_THROW_ITEM_LOAD_ERROR: 'load-error',\n    DID_LOAD_ITEM: 'idle',\n    DID_THROW_ITEM_REMOVE_ERROR: 'remove-error',\n    DID_START_ITEM_REMOVE: 'busy',\n    DID_START_ITEM_PROCESSING: 'busy processing',\n    DID_REQUEST_ITEM_PROCESSING: 'busy processing',\n    DID_UPDATE_ITEM_PROCESS_PROGRESS: 'processing',\n    DID_COMPLETE_ITEM_PROCESSING: 'processing-complete',\n    DID_THROW_ITEM_PROCESSING_ERROR: 'processing-error',\n    DID_THROW_ITEM_PROCESSING_REVERT_ERROR: 'processing-revert-error',\n    DID_ABORT_ITEM_PROCESSING: 'cancelled',\n    DID_REVERT_ITEM_PROCESSING: 'idle'\n  };\n\n  /**\n   * Creates the file view\n   */\n  var create$7 = function create(_ref) {\n    var root = _ref.root,\n      props = _ref.props;\n\n    // select\n    root.ref.handleClick = function(e) {\n      return root.dispatch('DID_ACTIVATE_ITEM', { id: props.id });\n    };\n\n    // set id\n    root.element.id = 'filepond--item-' + props.id;\n    root.element.addEventListener('click', root.ref.handleClick);\n\n    // file view\n    root.ref.container = root.appendChildView(\n      root.createChildView(fileWrapper, { id: props.id })\n    );\n\n    // file panel\n    root.ref.panel = root.appendChildView(\n      root.createChildView(panel, { name: 'item-panel' })\n    );\n\n    // default start height\n    root.ref.panel.height = null;\n\n    // by default not marked for removal\n    props.markedForRemoval = false;\n\n    // if not allowed to reorder file items, exit here\n    if (!root.query('GET_ALLOW_REORDER')) return;\n\n    // set to idle so shows grab cursor\n    root.element.dataset.dragState = 'idle';\n\n    var grab = function grab(e) {\n      if (!e.isPrimary) return;\n\n      var removedActivateListener = false;\n\n      var origin = {\n        x: e.pageX,\n        y: e.pageY\n      };\n\n      props.dragOrigin = {\n        x: root.translateX,\n        y: root.translateY\n      };\n\n      props.dragCenter = {\n        x: e.offsetX,\n        y: e.offsetY\n      };\n\n      var dragState = createDragHelper(root.query('GET_ACTIVE_ITEMS'));\n\n      root.dispatch('DID_GRAB_ITEM', { id: props.id, dragState: dragState });\n\n      var drag = function drag(e) {\n        if (!e.isPrimary) return;\n\n        e.stopPropagation();\n        e.preventDefault();\n\n        props.dragOffset = {\n          x: e.pageX - origin.x,\n          y: e.pageY - origin.y\n        };\n\n        // if dragged stop listening to clicks, will re-add when done dragging\n        var dist =\n          props.dragOffset.x * props.dragOffset.x +\n          props.dragOffset.y * props.dragOffset.y;\n        if (dist > 16 && !removedActivateListener) {\n          removedActivateListener = true;\n          root.element.removeEventListener('click', root.ref.handleClick);\n        }\n\n        root.dispatch('DID_DRAG_ITEM', { id: props.id, dragState: dragState });\n      };\n\n      var drop = function drop(e) {\n        if (!e.isPrimary) return;\n\n        document.removeEventListener('pointermove', drag);\n        document.removeEventListener('pointerup', drop);\n\n        props.dragOffset = {\n          x: e.pageX - origin.x,\n          y: e.pageY - origin.y\n        };\n\n        root.dispatch('DID_DROP_ITEM', { id: props.id, dragState: dragState });\n\n        // start listening to clicks again\n        if (removedActivateListener) {\n          setTimeout(function() {\n            return root.element.addEventListener('click', root.ref.handleClick);\n          }, 0);\n        }\n      };\n\n      document.addEventListener('pointermove', drag);\n      document.addEventListener('pointerup', drop);\n    };\n\n    root.element.addEventListener('pointerdown', grab);\n  };\n\n  var route$1 = createRoute({\n    DID_UPDATE_PANEL_HEIGHT: function DID_UPDATE_PANEL_HEIGHT(_ref2) {\n      var root = _ref2.root,\n        action = _ref2.action;\n      root.height = action.height;\n    }\n  });\n\n  var write$4 = createRoute(\n    {\n      DID_GRAB_ITEM: function DID_GRAB_ITEM(_ref3) {\n        var root = _ref3.root,\n          props = _ref3.props;\n        props.dragOrigin = {\n          x: root.translateX,\n          y: root.translateY\n        };\n      },\n      DID_DRAG_ITEM: function DID_DRAG_ITEM(_ref4) {\n        var root = _ref4.root;\n        root.element.dataset.dragState = 'drag';\n      },\n      DID_DROP_ITEM: function DID_DROP_ITEM(_ref5) {\n        var root = _ref5.root,\n          props = _ref5.props;\n        props.dragOffset = null;\n        props.dragOrigin = null;\n        root.element.dataset.dragState = 'drop';\n      }\n    },\n    function(_ref6) {\n      var root = _ref6.root,\n        actions = _ref6.actions,\n        props = _ref6.props,\n        shouldOptimize = _ref6.shouldOptimize;\n\n      if (root.element.dataset.dragState === 'drop') {\n        if (root.scaleX <= 1) {\n          root.element.dataset.dragState = 'idle';\n        }\n      }\n\n      // select last state change action\n      var action = actions\n        .concat()\n        .filter(function(action) {\n          return /^DID_/.test(action.type);\n        })\n        .reverse()\n        .find(function(action) {\n          return StateMap[action.type];\n        });\n\n      // no need to set same state twice\n      if (action && action.type !== props.currentState) {\n        // set current state\n        props.currentState = action.type;\n\n        // set state\n        root.element.dataset.filepondItemState =\n          StateMap[props.currentState] || '';\n      }\n\n      // route actions\n      var aspectRatio =\n        root.query('GET_ITEM_PANEL_ASPECT_RATIO') ||\n        root.query('GET_PANEL_ASPECT_RATIO');\n      if (!aspectRatio) {\n        route$1({ root: root, actions: actions, props: props });\n        if (!root.height && root.ref.container.rect.element.height > 0) {\n          root.height = root.ref.container.rect.element.height;\n        }\n      } else if (!shouldOptimize) {\n        root.height = root.rect.element.width * aspectRatio;\n      }\n\n      // sync panel height with item height\n      if (shouldOptimize) {\n        root.ref.panel.height = null;\n      }\n\n      root.ref.panel.height = root.height;\n    }\n  );\n\n  var item = createView({\n    create: create$7,\n    write: write$4,\n    destroy: function destroy(_ref7) {\n      var root = _ref7.root,\n        props = _ref7.props;\n      root.element.removeEventListener('click', root.ref.handleClick);\n      root.dispatch('RELEASE_ITEM', { query: props.id });\n    },\n    tag: 'li',\n    name: 'item',\n    mixins: {\n      apis: [\n        'id',\n        'interactionMethod',\n        'markedForRemoval',\n        'spawnDate',\n        'dragCenter',\n        'dragOrigin',\n        'dragOffset'\n      ],\n      styles: [\n        'translateX',\n        'translateY',\n        'scaleX',\n        'scaleY',\n        'opacity',\n        'height'\n      ],\n\n      animations: {\n        scaleX: ITEM_SCALE_SPRING,\n        scaleY: ITEM_SCALE_SPRING,\n        translateX: ITEM_TRANSLATE_SPRING,\n        translateY: ITEM_TRANSLATE_SPRING,\n        opacity: { type: 'tween', duration: 150 }\n      }\n    }\n  });\n\n  var getItemIndexByPosition = function getItemIndexByPosition(\n    view,\n    children,\n    positionInView\n  ) {\n    if (!positionInView) return;\n\n    var horizontalSpace = view.rect.element.width;\n    // const children = view.childViews;\n    var l = children.length;\n    var last = null;\n\n    // -1, don't move items to accomodate (either add to top or bottom)\n    if (l === 0 || positionInView.top < children[0].rect.element.top) return -1;\n\n    // let's get the item width\n    var item = children[0];\n    var itemRect = item.rect.element;\n    var itemHorizontalMargin = itemRect.marginLeft + itemRect.marginRight;\n    var itemWidth = itemRect.width + itemHorizontalMargin;\n    var itemsPerRow = Math.round(horizontalSpace / itemWidth);\n\n    // stack\n    if (itemsPerRow === 1) {\n      for (var index = 0; index < l; index++) {\n        var child = children[index];\n        var childMid = child.rect.outer.top + child.rect.element.height * 0.5;\n        if (positionInView.top < childMid) {\n          return index;\n        }\n      }\n      return l;\n    }\n\n    // grid\n    var itemVerticalMargin = itemRect.marginTop + itemRect.marginBottom;\n    var itemHeight = itemRect.height + itemVerticalMargin;\n    for (var _index = 0; _index < l; _index++) {\n      var indexX = _index % itemsPerRow;\n      var indexY = Math.floor(_index / itemsPerRow);\n\n      var offsetX = indexX * itemWidth;\n      var offsetY = indexY * itemHeight;\n\n      var itemTop = offsetY - itemRect.marginTop;\n      var itemRight = offsetX + itemWidth;\n      var itemBottom = offsetY + itemHeight + itemRect.marginBottom;\n\n      if (positionInView.top < itemBottom && positionInView.top > itemTop) {\n        if (positionInView.left < itemRight) {\n          return _index;\n        } else if (_index !== l - 1) {\n          last = _index;\n        } else {\n          last = null;\n        }\n      }\n    }\n\n    if (last !== null) {\n      return last;\n    }\n\n    return l;\n  };\n\n  var dropAreaDimensions = {\n    height: 0,\n    width: 0,\n    get getHeight() {\n      return this.height;\n    },\n    set setHeight(val) {\n      if (this.height === 0 || val === 0) this.height = val;\n    },\n    get getWidth() {\n      return this.width;\n    },\n    set setWidth(val) {\n      if (this.width === 0 || val === 0) this.width = val;\n    },\n    setDimensions: function setDimensions(height, width) {\n      if (this.height === 0 || height === 0) this.height = height;\n      if (this.width === 0 || width === 0) this.width = width;\n    }\n  };\n\n  var create$8 = function create(_ref) {\n    var root = _ref.root;\n    // need to set role to list as otherwise it won't be read as a list by VoiceOver\n    attr(root.element, 'role', 'list');\n\n    root.ref.lastItemSpanwDate = Date.now();\n  };\n\n  /**\n   * Inserts a new item\n   * @param root\n   * @param action\n   */\n  var addItemView = function addItemView(_ref2) {\n    var root = _ref2.root,\n      action = _ref2.action;\n    var id = action.id,\n      index = action.index,\n      interactionMethod = action.interactionMethod;\n\n    root.ref.addIndex = index;\n\n    var now = Date.now();\n    var spawnDate = now;\n    var opacity = 1;\n\n    if (interactionMethod !== InteractionMethod.NONE) {\n      opacity = 0;\n      var cooldown = root.query('GET_ITEM_INSERT_INTERVAL');\n      var dist = now - root.ref.lastItemSpanwDate;\n      spawnDate = dist < cooldown ? now + (cooldown - dist) : now;\n    }\n\n    root.ref.lastItemSpanwDate = spawnDate;\n\n    root.appendChildView(\n      root.createChildView(\n        // view type\n        item,\n\n        // props\n        {\n          spawnDate: spawnDate,\n          id: id,\n          opacity: opacity,\n          interactionMethod: interactionMethod\n        }\n      ),\n\n      index\n    );\n  };\n\n  var moveItem = function moveItem(item, x, y) {\n    var vx =\n      arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    var vy =\n      arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;\n\n    // set to null to remove animation while dragging\n    if (item.dragOffset) {\n      item.translateX = null;\n      item.translateY = null;\n      item.translateX = item.dragOrigin.x + item.dragOffset.x;\n      item.translateY = item.dragOrigin.y + item.dragOffset.y;\n      item.scaleX = 1.025;\n      item.scaleY = 1.025;\n    } else {\n      item.translateX = x;\n      item.translateY = y;\n\n      if (Date.now() > item.spawnDate) {\n        // reveal element\n        if (item.opacity === 0) {\n          introItemView(item, x, y, vx, vy);\n        }\n\n        // make sure is default scale every frame\n        item.scaleX = 1;\n        item.scaleY = 1;\n        item.opacity = 1;\n      }\n    }\n  };\n\n  var introItemView = function introItemView(item, x, y, vx, vy) {\n    if (item.interactionMethod === InteractionMethod.NONE) {\n      item.translateX = null;\n      item.translateX = x;\n      item.translateY = null;\n      item.translateY = y;\n    } else if (item.interactionMethod === InteractionMethod.DROP) {\n      item.translateX = null;\n      item.translateX = x - vx * 20;\n\n      item.translateY = null;\n      item.translateY = y - vy * 10;\n\n      item.scaleX = 0.8;\n      item.scaleY = 0.8;\n    } else if (item.interactionMethod === InteractionMethod.BROWSE) {\n      item.translateY = null;\n      item.translateY = y - 30;\n    } else if (item.interactionMethod === InteractionMethod.API) {\n      item.translateX = null;\n      item.translateX = x - 30;\n      item.translateY = null;\n    }\n  };\n\n  /**\n   * Removes an existing item\n   * @param root\n   * @param action\n   */\n  var removeItemView = function removeItemView(_ref3) {\n    var root = _ref3.root,\n      action = _ref3.action;\n    var id = action.id;\n\n    // get the view matching the given id\n    var view = root.childViews.find(function(child) {\n      return child.id === id;\n    });\n\n    // if no view found, exit\n    if (!view) {\n      return;\n    }\n\n    // animate view out of view\n    view.scaleX = 0.9;\n    view.scaleY = 0.9;\n    view.opacity = 0;\n\n    // mark for removal\n    view.markedForRemoval = true;\n  };\n\n  var getItemHeight = function getItemHeight(child) {\n    return (\n      child.rect.element.height +\n      child.rect.element.marginBottom * 0.5 +\n      child.rect.element.marginTop * 0.5\n    );\n  };\n  var getItemWidth = function getItemWidth(child) {\n    return (\n      child.rect.element.width +\n      child.rect.element.marginLeft * 0.5 +\n      child.rect.element.marginRight * 0.5\n    );\n  };\n\n  var dragItem = function dragItem(_ref4) {\n    var root = _ref4.root,\n      action = _ref4.action;\n    var id = action.id,\n      dragState = action.dragState;\n\n    // reference to item\n    var item = root.query('GET_ITEM', { id: id });\n\n    // get the view matching the given id\n    var view = root.childViews.find(function(child) {\n      return child.id === id;\n    });\n\n    var numItems = root.childViews.length;\n    var oldIndex = dragState.getItemIndex(item);\n\n    // if no view found, exit\n    if (!view) return;\n\n    var dragPosition = {\n      x: view.dragOrigin.x + view.dragOffset.x + view.dragCenter.x,\n      y: view.dragOrigin.y + view.dragOffset.y + view.dragCenter.y\n\n      // get drag area dimensions\n    };\n    var dragHeight = getItemHeight(view);\n    var dragWidth = getItemWidth(view);\n\n    // get rows and columns (There will always be at least one row and one column if a file is present)\n    var cols = Math.floor(root.rect.outer.width / dragWidth);\n    if (cols > numItems) cols = numItems;\n\n    // rows are used to find when we have left the preview area bounding box\n    var rows = Math.floor(numItems / cols + 1);\n\n    dropAreaDimensions.setHeight = dragHeight * rows;\n    dropAreaDimensions.setWidth = dragWidth * cols;\n\n    // get new index of dragged item\n    var location = {\n      y: Math.floor(dragPosition.y / dragHeight),\n      x: Math.floor(dragPosition.x / dragWidth),\n      getGridIndex: function getGridIndex() {\n        if (\n          dragPosition.y > dropAreaDimensions.getHeight ||\n          dragPosition.y < 0 ||\n          dragPosition.x > dropAreaDimensions.getWidth ||\n          dragPosition.x < 0\n        )\n          return oldIndex;\n        return this.y * cols + this.x;\n      },\n      getColIndex: function getColIndex() {\n        var items = root.query('GET_ACTIVE_ITEMS');\n        var visibleChildren = root.childViews.filter(function(child) {\n          return child.rect.element.height;\n        });\n        var children = items.map(function(item) {\n          return visibleChildren.find(function(childView) {\n            return childView.id === item.id;\n          });\n        });\n        var currentIndex = children.findIndex(function(child) {\n          return child === view;\n        });\n        var dragHeight = getItemHeight(view);\n        var l = children.length;\n        var idx = l;\n        var childHeight = 0;\n        var childBottom = 0;\n        var childTop = 0;\n        for (var i = 0; i < l; i++) {\n          childHeight = getItemHeight(children[i]);\n          childTop = childBottom;\n          childBottom = childTop + childHeight;\n          if (dragPosition.y < childBottom) {\n            if (currentIndex > i) {\n              if (dragPosition.y < childTop + dragHeight) {\n                idx = i;\n                break;\n              }\n              continue;\n            }\n            idx = i;\n            break;\n          }\n        }\n        return idx;\n      }\n\n      // get new index\n    };\n    var index = cols > 1 ? location.getGridIndex() : location.getColIndex();\n    root.dispatch('MOVE_ITEM', { query: view, index: index });\n\n    // if the index of the item changed, dispatch reorder action\n    var currentIndex = dragState.getIndex();\n\n    if (currentIndex === undefined || currentIndex !== index) {\n      dragState.setIndex(index);\n\n      if (currentIndex === undefined) return;\n\n      root.dispatch('DID_REORDER_ITEMS', {\n        items: root.query('GET_ACTIVE_ITEMS'),\n        origin: oldIndex,\n        target: index\n      });\n    }\n  };\n\n  /**\n   * Setup action routes\n   */\n  var route$2 = createRoute({\n    DID_ADD_ITEM: addItemView,\n    DID_REMOVE_ITEM: removeItemView,\n    DID_DRAG_ITEM: dragItem\n  });\n\n  /**\n   * Write to view\n   * @param root\n   * @param actions\n   * @param props\n   */\n  var write$5 = function write(_ref5) {\n    var root = _ref5.root,\n      props = _ref5.props,\n      actions = _ref5.actions,\n      shouldOptimize = _ref5.shouldOptimize;\n\n    // route actions\n    route$2({ root: root, props: props, actions: actions });\n    var dragCoordinates = props.dragCoordinates;\n\n    // available space on horizontal axis\n    var horizontalSpace = root.rect.element.width;\n\n    // only draw children that have dimensions\n    var visibleChildren = root.childViews.filter(function(child) {\n      return child.rect.element.height;\n    });\n\n    // sort based on current active items\n    var children = root\n      .query('GET_ACTIVE_ITEMS')\n      .map(function(item) {\n        return visibleChildren.find(function(child) {\n          return child.id === item.id;\n        });\n      })\n      .filter(function(item) {\n        return item;\n      });\n\n    // get index\n    var dragIndex = dragCoordinates\n      ? getItemIndexByPosition(root, children, dragCoordinates)\n      : null;\n\n    // add index is used to reserve the dropped/added item index till the actual item is rendered\n    var addIndex = root.ref.addIndex || null;\n\n    // add index no longer needed till possibly next draw\n    root.ref.addIndex = null;\n\n    var dragIndexOffset = 0;\n    var removeIndexOffset = 0;\n    var addIndexOffset = 0;\n\n    if (children.length === 0) return;\n\n    var childRect = children[0].rect.element;\n    var itemVerticalMargin = childRect.marginTop + childRect.marginBottom;\n    var itemHorizontalMargin = childRect.marginLeft + childRect.marginRight;\n    var itemWidth = childRect.width + itemHorizontalMargin;\n    var itemHeight = childRect.height + itemVerticalMargin;\n    var itemsPerRow = Math.round(horizontalSpace / itemWidth);\n\n    // stack\n    if (itemsPerRow === 1) {\n      var offsetY = 0;\n      var dragOffset = 0;\n\n      children.forEach(function(child, index) {\n        if (dragIndex) {\n          var dist = index - dragIndex;\n          if (dist === -2) {\n            dragOffset = -itemVerticalMargin * 0.25;\n          } else if (dist === -1) {\n            dragOffset = -itemVerticalMargin * 0.75;\n          } else if (dist === 0) {\n            dragOffset = itemVerticalMargin * 0.75;\n          } else if (dist === 1) {\n            dragOffset = itemVerticalMargin * 0.25;\n          } else {\n            dragOffset = 0;\n          }\n        }\n\n        if (shouldOptimize) {\n          child.translateX = null;\n          child.translateY = null;\n        }\n\n        if (!child.markedForRemoval) {\n          moveItem(child, 0, offsetY + dragOffset);\n        }\n\n        var itemHeight = child.rect.element.height + itemVerticalMargin;\n\n        var visualHeight =\n          itemHeight * (child.markedForRemoval ? child.opacity : 1);\n\n        offsetY += visualHeight;\n      });\n    }\n    // grid\n    else {\n      var prevX = 0;\n      var prevY = 0;\n\n      children.forEach(function(child, index) {\n        if (index === dragIndex) {\n          dragIndexOffset = 1;\n        }\n\n        if (index === addIndex) {\n          addIndexOffset += 1;\n        }\n\n        if (child.markedForRemoval && child.opacity < 0.5) {\n          removeIndexOffset -= 1;\n        }\n\n        var visualIndex =\n          index + addIndexOffset + dragIndexOffset + removeIndexOffset;\n\n        var indexX = visualIndex % itemsPerRow;\n        var indexY = Math.floor(visualIndex / itemsPerRow);\n\n        var offsetX = indexX * itemWidth;\n        var offsetY = indexY * itemHeight;\n\n        var vectorX = Math.sign(offsetX - prevX);\n        var vectorY = Math.sign(offsetY - prevY);\n\n        prevX = offsetX;\n        prevY = offsetY;\n\n        if (child.markedForRemoval) return;\n\n        if (shouldOptimize) {\n          child.translateX = null;\n          child.translateY = null;\n        }\n\n        moveItem(child, offsetX, offsetY, vectorX, vectorY);\n      });\n    }\n  };\n\n  /**\n   * Filters actions that are meant specifically for a certain child of the list\n   * @param child\n   * @param actions\n   */\n  var filterSetItemActions = function filterSetItemActions(child, actions) {\n    return actions.filter(function(action) {\n      // if action has an id, filter out actions that don't have this child id\n      if (action.data && action.data.id) {\n        return child.id === action.data.id;\n      }\n\n      // allow all other actions\n      return true;\n    });\n  };\n\n  var list = createView({\n    create: create$8,\n    write: write$5,\n    tag: 'ul',\n    name: 'list',\n    didWriteView: function didWriteView(_ref6) {\n      var root = _ref6.root;\n      root.childViews\n        .filter(function(view) {\n          return view.markedForRemoval && view.opacity === 0 && view.resting;\n        })\n        .forEach(function(view) {\n          view._destroy();\n          root.removeChildView(view);\n        });\n    },\n    filterFrameActionsForChild: filterSetItemActions,\n    mixins: {\n      apis: ['dragCoordinates']\n    }\n  });\n\n  var create$9 = function create(_ref) {\n    var root = _ref.root,\n      props = _ref.props;\n    root.ref.list = root.appendChildView(root.createChildView(list));\n    props.dragCoordinates = null;\n    props.overflowing = false;\n  };\n\n  var storeDragCoordinates = function storeDragCoordinates(_ref2) {\n    var root = _ref2.root,\n      props = _ref2.props,\n      action = _ref2.action;\n    if (!root.query('GET_ITEM_INSERT_LOCATION_FREEDOM')) return;\n    props.dragCoordinates = {\n      left: action.position.scopeLeft - root.ref.list.rect.element.left,\n      top:\n        action.position.scopeTop -\n        (root.rect.outer.top +\n          root.rect.element.marginTop +\n          root.rect.element.scrollTop)\n    };\n  };\n\n  var clearDragCoordinates = function clearDragCoordinates(_ref3) {\n    var props = _ref3.props;\n    props.dragCoordinates = null;\n  };\n\n  var route$3 = createRoute({\n    DID_DRAG: storeDragCoordinates,\n    DID_END_DRAG: clearDragCoordinates\n  });\n\n  var write$6 = function write(_ref4) {\n    var root = _ref4.root,\n      props = _ref4.props,\n      actions = _ref4.actions;\n\n    // route actions\n    route$3({ root: root, props: props, actions: actions });\n\n    // current drag position\n    root.ref.list.dragCoordinates = props.dragCoordinates;\n\n    // if currently overflowing but no longer received overflow\n    if (props.overflowing && !props.overflow) {\n      props.overflowing = false;\n\n      // reset overflow state\n      root.element.dataset.state = '';\n      root.height = null;\n    }\n\n    // if is not overflowing currently but does receive overflow value\n    if (props.overflow) {\n      var newHeight = Math.round(props.overflow);\n      if (newHeight !== root.height) {\n        props.overflowing = true;\n        root.element.dataset.state = 'overflow';\n        root.height = newHeight;\n      }\n    }\n  };\n\n  var listScroller = createView({\n    create: create$9,\n    write: write$6,\n    name: 'list-scroller',\n    mixins: {\n      apis: ['overflow', 'dragCoordinates'],\n      styles: ['height', 'translateY'],\n      animations: {\n        translateY: 'spring'\n      }\n    }\n  });\n\n  var attrToggle = function attrToggle(element, name, state) {\n    var enabledValue =\n      arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';\n    if (state) {\n      attr(element, name, enabledValue);\n    } else {\n      element.removeAttribute(name);\n    }\n  };\n\n  var resetFileInput = function resetFileInput(input) {\n    // no value, no need to reset\n    if (!input || input.value === '') {\n      return;\n    }\n\n    try {\n      // for modern browsers\n      input.value = '';\n    } catch (err) {}\n\n    // for IE10\n    if (input.value) {\n      // quickly append input to temp form and reset form\n      var form = createElement$1('form');\n      var parentNode = input.parentNode;\n      var ref = input.nextSibling;\n      form.appendChild(input);\n      form.reset();\n\n      // re-inject input where it originally was\n      if (ref) {\n        parentNode.insertBefore(input, ref);\n      } else {\n        parentNode.appendChild(input);\n      }\n    }\n  };\n\n  var create$a = function create(_ref) {\n    var root = _ref.root,\n      props = _ref.props;\n\n    // set id so can be referenced from outside labels\n    root.element.id = 'filepond--browser-' + props.id;\n\n    // set name of element (is removed when a value is set)\n    attr(root.element, 'name', root.query('GET_NAME'));\n\n    // we have to link this element to the status element\n    attr(root.element, 'aria-controls', 'filepond--assistant-' + props.id);\n\n    // set label, we use labelled by as otherwise the screenreader does not read the \"browse\" text in the label (as it has tabindex: 0)\n    attr(root.element, 'aria-labelledby', 'filepond--drop-label-' + props.id);\n\n    // set configurable props\n    setAcceptedFileTypes({\n      root: root,\n      action: { value: root.query('GET_ACCEPTED_FILE_TYPES') }\n    });\n    toggleAllowMultiple({\n      root: root,\n      action: { value: root.query('GET_ALLOW_MULTIPLE') }\n    });\n    toggleDirectoryFilter({\n      root: root,\n      action: { value: root.query('GET_ALLOW_DIRECTORIES_ONLY') }\n    });\n    toggleDisabled({ root: root });\n    toggleRequired({\n      root: root,\n      action: { value: root.query('GET_REQUIRED') }\n    });\n    setCaptureMethod({\n      root: root,\n      action: { value: root.query('GET_CAPTURE_METHOD') }\n    });\n\n    // handle changes to the input field\n    root.ref.handleChange = function(e) {\n      if (!root.element.value) {\n        return;\n      }\n\n      // extract files and move value of webkitRelativePath path to _relativePath\n      var files = Array.from(root.element.files).map(function(file) {\n        file._relativePath = file.webkitRelativePath;\n        return file;\n      });\n\n      // we add a little delay so the OS file select window can move out of the way before we add our file\n      setTimeout(function() {\n        // load files\n        props.onload(files);\n\n        // reset input, it's just for exposing a method to drop files, should not retain any state\n        resetFileInput(root.element);\n      }, 250);\n    };\n\n    root.element.addEventListener('change', root.ref.handleChange);\n  };\n\n  var setAcceptedFileTypes = function setAcceptedFileTypes(_ref2) {\n    var root = _ref2.root,\n      action = _ref2.action;\n    if (!root.query('GET_ALLOW_SYNC_ACCEPT_ATTRIBUTE')) return;\n    attrToggle(\n      root.element,\n      'accept',\n      !!action.value,\n      action.value ? action.value.join(',') : ''\n    );\n  };\n\n  var toggleAllowMultiple = function toggleAllowMultiple(_ref3) {\n    var root = _ref3.root,\n      action = _ref3.action;\n    attrToggle(root.element, 'multiple', action.value);\n  };\n\n  var toggleDirectoryFilter = function toggleDirectoryFilter(_ref4) {\n    var root = _ref4.root,\n      action = _ref4.action;\n    attrToggle(root.element, 'webkitdirectory', action.value);\n  };\n\n  var toggleDisabled = function toggleDisabled(_ref5) {\n    var root = _ref5.root;\n    var isDisabled = root.query('GET_DISABLED');\n    var doesAllowBrowse = root.query('GET_ALLOW_BROWSE');\n    var disableField = isDisabled || !doesAllowBrowse;\n    attrToggle(root.element, 'disabled', disableField);\n  };\n\n  var toggleRequired = function toggleRequired(_ref6) {\n    var root = _ref6.root,\n      action = _ref6.action;\n    // want to remove required, always possible\n    if (!action.value) {\n      attrToggle(root.element, 'required', false);\n    }\n    // if want to make required, only possible when zero items\n    else if (root.query('GET_TOTAL_ITEMS') === 0) {\n      attrToggle(root.element, 'required', true);\n    }\n  };\n\n  var setCaptureMethod = function setCaptureMethod(_ref7) {\n    var root = _ref7.root,\n      action = _ref7.action;\n    attrToggle(\n      root.element,\n      'capture',\n      !!action.value,\n      action.value === true ? '' : action.value\n    );\n  };\n\n  var updateRequiredStatus = function updateRequiredStatus(_ref8) {\n    var root = _ref8.root;\n    var element = root.element;\n    // always remove the required attribute when more than zero items\n    if (root.query('GET_TOTAL_ITEMS') > 0) {\n      attrToggle(element, 'required', false);\n      attrToggle(element, 'name', false);\n    } else {\n      // add name attribute\n      attrToggle(element, 'name', true, root.query('GET_NAME'));\n\n      // remove any validation messages\n      var shouldCheckValidity = root.query('GET_CHECK_VALIDITY');\n      if (shouldCheckValidity) {\n        element.setCustomValidity('');\n      }\n\n      // we only add required if the field has been deemed required\n      if (root.query('GET_REQUIRED')) {\n        attrToggle(element, 'required', true);\n      }\n    }\n  };\n\n  var updateFieldValidityStatus = function updateFieldValidityStatus(_ref9) {\n    var root = _ref9.root;\n    var shouldCheckValidity = root.query('GET_CHECK_VALIDITY');\n    if (!shouldCheckValidity) return;\n    root.element.setCustomValidity(root.query('GET_LABEL_INVALID_FIELD'));\n  };\n\n  var browser = createView({\n    tag: 'input',\n    name: 'browser',\n    ignoreRect: true,\n    ignoreRectUpdate: true,\n    attributes: {\n      type: 'file'\n    },\n\n    create: create$a,\n    destroy: function destroy(_ref10) {\n      var root = _ref10.root;\n      root.element.removeEventListener('change', root.ref.handleChange);\n    },\n    write: createRoute({\n      DID_LOAD_ITEM: updateRequiredStatus,\n      DID_REMOVE_ITEM: updateRequiredStatus,\n      DID_THROW_ITEM_INVALID: updateFieldValidityStatus,\n\n      DID_SET_DISABLED: toggleDisabled,\n      DID_SET_ALLOW_BROWSE: toggleDisabled,\n      DID_SET_ALLOW_DIRECTORIES_ONLY: toggleDirectoryFilter,\n      DID_SET_ALLOW_MULTIPLE: toggleAllowMultiple,\n      DID_SET_ACCEPTED_FILE_TYPES: setAcceptedFileTypes,\n      DID_SET_CAPTURE_METHOD: setCaptureMethod,\n      DID_SET_REQUIRED: toggleRequired\n    })\n  });\n\n  var Key = {\n    ENTER: 13,\n    SPACE: 32\n  };\n\n  var create$b = function create(_ref) {\n    var root = _ref.root,\n      props = _ref.props;\n\n    // create the label and link it to the file browser\n    var label = createElement$1('label');\n    attr(label, 'for', 'filepond--browser-' + props.id);\n\n    // use for labeling file input (aria-labelledby on file input)\n    attr(label, 'id', 'filepond--drop-label-' + props.id);\n\n    // hide the label for screenreaders, the input element will read the contents of the label when it's focussed. If we don't set aria-hidden the screenreader will also navigate the contents of the label separately from the input.\n    attr(label, 'aria-hidden', 'true');\n\n    // handle keys\n    root.ref.handleKeyDown = function(e) {\n      var isActivationKey = e.keyCode === Key.ENTER || e.keyCode === Key.SPACE;\n      if (!isActivationKey) return;\n      // stops from triggering the element a second time\n      e.preventDefault();\n\n      // click link (will then in turn activate file input)\n      root.ref.label.click();\n    };\n\n    root.ref.handleClick = function(e) {\n      var isLabelClick = e.target === label || label.contains(e.target);\n\n      // don't want to click twice\n      if (isLabelClick) return;\n\n      // click link (will then in turn activate file input)\n      root.ref.label.click();\n    };\n\n    // attach events\n    label.addEventListener('keydown', root.ref.handleKeyDown);\n    root.element.addEventListener('click', root.ref.handleClick);\n\n    // update\n    updateLabelValue(label, props.caption);\n\n    // add!\n    root.appendChild(label);\n    root.ref.label = label;\n  };\n\n  var updateLabelValue = function updateLabelValue(label, value) {\n    label.innerHTML = value;\n    var clickable = label.querySelector('.filepond--label-action');\n    if (clickable) {\n      attr(clickable, 'tabindex', '0');\n    }\n    return value;\n  };\n\n  var dropLabel = createView({\n    name: 'drop-label',\n    ignoreRect: true,\n    create: create$b,\n    destroy: function destroy(_ref2) {\n      var root = _ref2.root;\n      root.ref.label.addEventListener('keydown', root.ref.handleKeyDown);\n      root.element.removeEventListener('click', root.ref.handleClick);\n    },\n    write: createRoute({\n      DID_SET_LABEL_IDLE: function DID_SET_LABEL_IDLE(_ref3) {\n        var root = _ref3.root,\n          action = _ref3.action;\n        updateLabelValue(root.ref.label, action.value);\n      }\n    }),\n\n    mixins: {\n      styles: ['opacity', 'translateX', 'translateY'],\n      animations: {\n        opacity: { type: 'tween', duration: 150 },\n        translateX: 'spring',\n        translateY: 'spring'\n      }\n    }\n  });\n\n  var blob = createView({\n    name: 'drip-blob',\n    ignoreRect: true,\n    mixins: {\n      styles: ['translateX', 'translateY', 'scaleX', 'scaleY', 'opacity'],\n      animations: {\n        scaleX: 'spring',\n        scaleY: 'spring',\n        translateX: 'spring',\n        translateY: 'spring',\n        opacity: { type: 'tween', duration: 250 }\n      }\n    }\n  });\n\n  var addBlob = function addBlob(_ref) {\n    var root = _ref.root;\n    var centerX = root.rect.element.width * 0.5;\n    var centerY = root.rect.element.height * 0.5;\n\n    root.ref.blob = root.appendChildView(\n      root.createChildView(blob, {\n        opacity: 0,\n        scaleX: 2.5,\n        scaleY: 2.5,\n        translateX: centerX,\n        translateY: centerY\n      })\n    );\n  };\n\n  var moveBlob = function moveBlob(_ref2) {\n    var root = _ref2.root,\n      action = _ref2.action;\n    if (!root.ref.blob) {\n      addBlob({ root: root });\n      return;\n    }\n\n    root.ref.blob.translateX = action.position.scopeLeft;\n    root.ref.blob.translateY = action.position.scopeTop;\n    root.ref.blob.scaleX = 1;\n    root.ref.blob.scaleY = 1;\n    root.ref.blob.opacity = 1;\n  };\n\n  var hideBlob = function hideBlob(_ref3) {\n    var root = _ref3.root;\n    if (!root.ref.blob) {\n      return;\n    }\n    root.ref.blob.opacity = 0;\n  };\n\n  var explodeBlob = function explodeBlob(_ref4) {\n    var root = _ref4.root;\n    if (!root.ref.blob) {\n      return;\n    }\n    root.ref.blob.scaleX = 2.5;\n    root.ref.blob.scaleY = 2.5;\n    root.ref.blob.opacity = 0;\n  };\n\n  var write$7 = function write(_ref5) {\n    var root = _ref5.root,\n      props = _ref5.props,\n      actions = _ref5.actions;\n    route$4({ root: root, props: props, actions: actions });\n    var blob = root.ref.blob;\n\n    if (actions.length === 0 && blob && blob.opacity === 0) {\n      root.removeChildView(blob);\n      root.ref.blob = null;\n    }\n  };\n\n  var route$4 = createRoute({\n    DID_DRAG: moveBlob,\n    DID_DROP: explodeBlob,\n    DID_END_DRAG: hideBlob\n  });\n\n  var drip = createView({\n    ignoreRect: true,\n    ignoreRectUpdate: true,\n    name: 'drip',\n    write: write$7\n  });\n\n  var create$c = function create(_ref) {\n    var root = _ref.root;\n    return (root.ref.fields = {});\n  };\n\n  var getField = function getField(root, id) {\n    return root.ref.fields[id];\n  };\n\n  var syncFieldPositionsWithItems = function syncFieldPositionsWithItems(root) {\n    root.query('GET_ACTIVE_ITEMS').forEach(function(item) {\n      if (!root.ref.fields[item.id]) return;\n      root.element.appendChild(root.ref.fields[item.id]);\n    });\n  };\n\n  var didReorderItems = function didReorderItems(_ref2) {\n    var root = _ref2.root;\n    return syncFieldPositionsWithItems(root);\n  };\n\n  var didAddItem = function didAddItem(_ref3) {\n    var root = _ref3.root,\n      action = _ref3.action;\n    var dataContainer = createElement$1('input');\n    dataContainer.type = 'hidden';\n    dataContainer.name = root.query('GET_NAME');\n    dataContainer.disabled = root.query('GET_DISABLED');\n    root.ref.fields[action.id] = dataContainer;\n    syncFieldPositionsWithItems(root);\n  };\n\n  var didLoadItem$1 = function didLoadItem(_ref4) {\n    var root = _ref4.root,\n      action = _ref4.action;\n    var field = getField(root, action.id);\n    if (!field || action.serverFileReference === null) return;\n    field.value = action.serverFileReference;\n  };\n\n  var didSetDisabled = function didSetDisabled(_ref5) {\n    var root = _ref5.root;\n    root.element.disabled = root.query('GET_DISABLED');\n  };\n\n  var didRemoveItem = function didRemoveItem(_ref6) {\n    var root = _ref6.root,\n      action = _ref6.action;\n    var field = getField(root, action.id);\n    if (!field) return;\n    if (field.parentNode) field.parentNode.removeChild(field);\n    delete root.ref.fields[action.id];\n  };\n\n  var didDefineValue = function didDefineValue(_ref7) {\n    var root = _ref7.root,\n      action = _ref7.action;\n    var field = getField(root, action.id);\n    if (!field) return;\n    if (action.value === null) {\n      field.removeAttribute('value');\n    } else {\n      field.value = action.value;\n    }\n    syncFieldPositionsWithItems(root);\n  };\n\n  var write$8 = createRoute({\n    DID_SET_DISABLED: didSetDisabled,\n    DID_ADD_ITEM: didAddItem,\n    DID_LOAD_ITEM: didLoadItem$1,\n    DID_REMOVE_ITEM: didRemoveItem,\n    DID_DEFINE_VALUE: didDefineValue,\n    DID_REORDER_ITEMS: didReorderItems,\n    DID_SORT_ITEMS: didReorderItems\n  });\n\n  var data = createView({\n    tag: 'fieldset',\n    name: 'data',\n    create: create$c,\n    write: write$8,\n    ignoreRect: true\n  });\n\n  var getRootNode = function getRootNode(element) {\n    return 'getRootNode' in element ? element.getRootNode() : document;\n  };\n\n  var images = ['jpg', 'jpeg', 'png', 'gif', 'bmp', 'webp', 'svg', 'tiff'];\n  var text$1 = ['css', 'csv', 'html', 'txt'];\n  var map = {\n    zip: 'zip|compressed',\n    epub: 'application/epub+zip'\n  };\n\n  var guesstimateMimeType = function guesstimateMimeType() {\n    var extension =\n      arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    extension = extension.toLowerCase();\n    if (images.includes(extension)) {\n      return (\n        'image/' +\n        (extension === 'jpg'\n          ? 'jpeg'\n          : extension === 'svg'\n          ? 'svg+xml'\n          : extension)\n      );\n    }\n    if (text$1.includes(extension)) {\n      return 'text/' + extension;\n    }\n\n    return map[extension] || '';\n  };\n\n  var requestDataTransferItems = function requestDataTransferItems(\n    dataTransfer\n  ) {\n    return new Promise(function(resolve, reject) {\n      // try to get links from transfer, if found we'll exit immediately (unless a file is in the dataTransfer as well, this is because Firefox could represent the file as a URL and a file object at the same time)\n      var links = getLinks(dataTransfer);\n      if (links.length && !hasFiles(dataTransfer)) {\n        return resolve(links);\n      }\n      // try to get files from the transfer\n      getFiles(dataTransfer).then(resolve);\n    });\n  };\n\n  /**\n   * Test if datatransfer has files\n   */\n  var hasFiles = function hasFiles(dataTransfer) {\n    if (dataTransfer.files) return dataTransfer.files.length > 0;\n    return false;\n  };\n\n  /**\n   * Extracts files from a DataTransfer object\n   */\n  var getFiles = function getFiles(dataTransfer) {\n    return new Promise(function(resolve, reject) {\n      // get the transfer items as promises\n      var promisedFiles = (dataTransfer.items\n        ? Array.from(dataTransfer.items)\n        : []\n      )\n        // only keep file system items (files and directories)\n        .filter(function(item) {\n          return isFileSystemItem(item);\n        })\n\n        // map each item to promise\n        .map(function(item) {\n          return getFilesFromItem(item);\n        });\n\n      // if is empty, see if we can extract some info from the files property as a fallback\n      if (!promisedFiles.length) {\n        // TODO: test for directories (should not be allowed)\n        // Use FileReader, problem is that the files property gets lost in the process\n        resolve(dataTransfer.files ? Array.from(dataTransfer.files) : []);\n        return;\n      }\n\n      // done!\n      Promise.all(promisedFiles)\n        .then(function(returnedFileGroups) {\n          // flatten groups\n          var files = [];\n          returnedFileGroups.forEach(function(group) {\n            files.push.apply(files, group);\n          });\n\n          // done (filter out empty files)!\n          resolve(\n            files\n              .filter(function(file) {\n                return file;\n              })\n              .map(function(file) {\n                if (!file._relativePath)\n                  file._relativePath = file.webkitRelativePath;\n                return file;\n              })\n          );\n        })\n        .catch(console.error);\n    });\n  };\n\n  var isFileSystemItem = function isFileSystemItem(item) {\n    if (isEntry(item)) {\n      var entry = getAsEntry(item);\n      if (entry) {\n        return entry.isFile || entry.isDirectory;\n      }\n    }\n    return item.kind === 'file';\n  };\n\n  var getFilesFromItem = function getFilesFromItem(item) {\n    return new Promise(function(resolve, reject) {\n      if (isDirectoryEntry(item)) {\n        getFilesInDirectory(getAsEntry(item))\n          .then(resolve)\n          .catch(reject);\n        return;\n      }\n\n      resolve([item.getAsFile()]);\n    });\n  };\n\n  var getFilesInDirectory = function getFilesInDirectory(entry) {\n    return new Promise(function(resolve, reject) {\n      var files = [];\n\n      // the total entries to read\n      var dirCounter = 0;\n      var fileCounter = 0;\n\n      var resolveIfDone = function resolveIfDone() {\n        if (fileCounter === 0 && dirCounter === 0) {\n          resolve(files);\n        }\n      };\n\n      // the recursive function\n      var readEntries = function readEntries(dirEntry) {\n        dirCounter++;\n\n        var directoryReader = dirEntry.createReader();\n\n        // directories are returned in batches, we need to process all batches before we're done\n        var readBatch = function readBatch() {\n          directoryReader.readEntries(function(entries) {\n            if (entries.length === 0) {\n              dirCounter--;\n              resolveIfDone();\n              return;\n            }\n\n            entries.forEach(function(entry) {\n              // recursively read more directories\n              if (entry.isDirectory) {\n                readEntries(entry);\n              } else {\n                // read as file\n                fileCounter++;\n\n                entry.file(function(file) {\n                  var correctedFile = correctMissingFileType(file);\n                  if (entry.fullPath)\n                    correctedFile._relativePath = entry.fullPath;\n                  files.push(correctedFile);\n                  fileCounter--;\n                  resolveIfDone();\n                });\n              }\n            });\n\n            // try to get next batch of files\n            readBatch();\n          }, reject);\n        };\n\n        // read first batch of files\n        readBatch();\n      };\n\n      // go!\n      readEntries(entry);\n    });\n  };\n\n  var correctMissingFileType = function correctMissingFileType(file) {\n    if (file.type.length) return file;\n    var date = file.lastModifiedDate;\n    var name = file.name;\n    var type = guesstimateMimeType(getExtensionFromFilename(file.name));\n    if (!type.length) return file;\n    file = file.slice(0, file.size, type);\n    file.name = name;\n    file.lastModifiedDate = date;\n    return file;\n  };\n\n  var isDirectoryEntry = function isDirectoryEntry(item) {\n    return isEntry(item) && (getAsEntry(item) || {}).isDirectory;\n  };\n\n  var isEntry = function isEntry(item) {\n    return 'webkitGetAsEntry' in item;\n  };\n\n  var getAsEntry = function getAsEntry(item) {\n    return item.webkitGetAsEntry();\n  };\n\n  /**\n   * Extracts links from a DataTransfer object\n   */\n  var getLinks = function getLinks(dataTransfer) {\n    var links = [];\n    try {\n      // look in meta data property\n      links = getLinksFromTransferMetaData(dataTransfer);\n      if (links.length) {\n        return links;\n      }\n      links = getLinksFromTransferURLData(dataTransfer);\n    } catch (e) {\n      // nope nope nope (probably IE trouble)\n    }\n    return links;\n  };\n\n  var getLinksFromTransferURLData = function getLinksFromTransferURLData(\n    dataTransfer\n  ) {\n    var data = dataTransfer.getData('url');\n    if (typeof data === 'string' && data.length) {\n      return [data];\n    }\n    return [];\n  };\n\n  var getLinksFromTransferMetaData = function getLinksFromTransferMetaData(\n    dataTransfer\n  ) {\n    var data = dataTransfer.getData('text/html');\n    if (typeof data === 'string' && data.length) {\n      var matches = data.match(/src\\s*=\\s*\"(.+?)\"/);\n      if (matches) {\n        return [matches[1]];\n      }\n    }\n    return [];\n  };\n\n  var dragNDropObservers = [];\n\n  var eventPosition = function eventPosition(e) {\n    return {\n      pageLeft: e.pageX,\n      pageTop: e.pageY,\n      scopeLeft: e.offsetX || e.layerX,\n      scopeTop: e.offsetY || e.layerY\n    };\n  };\n\n  var createDragNDropClient = function createDragNDropClient(\n    element,\n    scopeToObserve,\n    filterElement\n  ) {\n    var observer = getDragNDropObserver(scopeToObserve);\n\n    var client = {\n      element: element,\n      filterElement: filterElement,\n      state: null,\n      ondrop: function ondrop() {},\n      onenter: function onenter() {},\n      ondrag: function ondrag() {},\n      onexit: function onexit() {},\n      onload: function onload() {},\n      allowdrop: function allowdrop() {}\n    };\n\n    client.destroy = observer.addListener(client);\n\n    return client;\n  };\n\n  var getDragNDropObserver = function getDragNDropObserver(element) {\n    // see if already exists, if so, return\n    var observer = dragNDropObservers.find(function(item) {\n      return item.element === element;\n    });\n    if (observer) {\n      return observer;\n    }\n\n    // create new observer, does not yet exist for this element\n    var newObserver = createDragNDropObserver(element);\n    dragNDropObservers.push(newObserver);\n    return newObserver;\n  };\n\n  var createDragNDropObserver = function createDragNDropObserver(element) {\n    var clients = [];\n\n    var routes = {\n      dragenter: dragenter,\n      dragover: dragover,\n      dragleave: dragleave,\n      drop: drop\n    };\n\n    var handlers = {};\n\n    forin(routes, function(event, createHandler) {\n      handlers[event] = createHandler(element, clients);\n      element.addEventListener(event, handlers[event], false);\n    });\n\n    var observer = {\n      element: element,\n      addListener: function addListener(client) {\n        // add as client\n        clients.push(client);\n\n        // return removeListener function\n        return function() {\n          // remove client\n          clients.splice(clients.indexOf(client), 1);\n\n          // if no more clients, clean up observer\n          if (clients.length === 0) {\n            dragNDropObservers.splice(dragNDropObservers.indexOf(observer), 1);\n\n            forin(routes, function(event) {\n              element.removeEventListener(event, handlers[event], false);\n            });\n          }\n        };\n      }\n    };\n\n    return observer;\n  };\n\n  var elementFromPoint = function elementFromPoint(root, point) {\n    if (!('elementFromPoint' in root)) {\n      root = document;\n    }\n    return root.elementFromPoint(point.x, point.y);\n  };\n\n  var isEventTarget = function isEventTarget(e, target) {\n    // get root\n    var root = getRootNode(target);\n\n    // get element at position\n    // if root is not actual shadow DOM and does not have elementFromPoint method, use the one on document\n    var elementAtPosition = elementFromPoint(root, {\n      x: e.pageX - window.pageXOffset,\n      y: e.pageY - window.pageYOffset\n    });\n\n    // test if target is the element or if one of its children is\n    return elementAtPosition === target || target.contains(elementAtPosition);\n  };\n\n  var initialTarget = null;\n\n  var setDropEffect = function setDropEffect(dataTransfer, effect) {\n    // is in try catch as IE11 will throw error if not\n    try {\n      dataTransfer.dropEffect = effect;\n    } catch (e) {}\n  };\n\n  var dragenter = function dragenter(root, clients) {\n    return function(e) {\n      e.preventDefault();\n\n      initialTarget = e.target;\n\n      clients.forEach(function(client) {\n        var element = client.element,\n          onenter = client.onenter;\n\n        if (isEventTarget(e, element)) {\n          client.state = 'enter';\n\n          // fire enter event\n          onenter(eventPosition(e));\n        }\n      });\n    };\n  };\n\n  var dragover = function dragover(root, clients) {\n    return function(e) {\n      e.preventDefault();\n\n      var dataTransfer = e.dataTransfer;\n\n      requestDataTransferItems(dataTransfer).then(function(items) {\n        var overDropTarget = false;\n\n        clients.some(function(client) {\n          var filterElement = client.filterElement,\n            element = client.element,\n            onenter = client.onenter,\n            onexit = client.onexit,\n            ondrag = client.ondrag,\n            allowdrop = client.allowdrop;\n\n          // by default we can drop\n          setDropEffect(dataTransfer, 'copy');\n\n          // allow transfer of these items\n          var allowsTransfer = allowdrop(items);\n\n          // only used when can be dropped on page\n          if (!allowsTransfer) {\n            setDropEffect(dataTransfer, 'none');\n            return;\n          }\n\n          // targetting this client\n          if (isEventTarget(e, element)) {\n            overDropTarget = true;\n\n            // had no previous state, means we are entering this client\n            if (client.state === null) {\n              client.state = 'enter';\n              onenter(eventPosition(e));\n              return;\n            }\n\n            // now over element (no matter if it allows the drop or not)\n            client.state = 'over';\n\n            // needs to allow transfer\n            if (filterElement && !allowsTransfer) {\n              setDropEffect(dataTransfer, 'none');\n              return;\n            }\n\n            // dragging\n            ondrag(eventPosition(e));\n          } else {\n            // should be over an element to drop\n            if (filterElement && !overDropTarget) {\n              setDropEffect(dataTransfer, 'none');\n            }\n\n            // might have just left this client?\n            if (client.state) {\n              client.state = null;\n              onexit(eventPosition(e));\n            }\n          }\n        });\n      });\n    };\n  };\n\n  var drop = function drop(root, clients) {\n    return function(e) {\n      e.preventDefault();\n\n      var dataTransfer = e.dataTransfer;\n\n      requestDataTransferItems(dataTransfer).then(function(items) {\n        clients.forEach(function(client) {\n          var filterElement = client.filterElement,\n            element = client.element,\n            ondrop = client.ondrop,\n            onexit = client.onexit,\n            allowdrop = client.allowdrop;\n\n          client.state = null;\n\n          // if we're filtering on element we need to be over the element to drop\n          if (filterElement && !isEventTarget(e, element)) return;\n\n          // no transfer for this client\n          if (!allowdrop(items)) return onexit(eventPosition(e));\n\n          // we can drop these items on this client\n          ondrop(eventPosition(e), items);\n        });\n      });\n    };\n  };\n\n  var dragleave = function dragleave(root, clients) {\n    return function(e) {\n      if (initialTarget !== e.target) {\n        return;\n      }\n\n      clients.forEach(function(client) {\n        var onexit = client.onexit;\n\n        client.state = null;\n\n        onexit(eventPosition(e));\n      });\n    };\n  };\n\n  var createHopper = function createHopper(scope, validateItems, options) {\n    // is now hopper scope\n    scope.classList.add('filepond--hopper');\n\n    // shortcuts\n    var catchesDropsOnPage = options.catchesDropsOnPage,\n      requiresDropOnElement = options.requiresDropOnElement,\n      _options$filterItems = options.filterItems,\n      filterItems =\n        _options$filterItems === void 0\n          ? function(items) {\n              return items;\n            }\n          : _options$filterItems;\n\n    // create a dnd client\n    var client = createDragNDropClient(\n      scope,\n      catchesDropsOnPage ? document.documentElement : scope,\n      requiresDropOnElement\n    );\n\n    // current client state\n    var lastState = '';\n    var currentState = '';\n\n    // determines if a file may be dropped\n    client.allowdrop = function(items) {\n      // TODO: if we can, throw error to indicate the items cannot by dropped\n\n      return validateItems(filterItems(items));\n    };\n\n    client.ondrop = function(position, items) {\n      var filteredItems = filterItems(items);\n\n      if (!validateItems(filteredItems)) {\n        api.ondragend(position);\n        return;\n      }\n\n      currentState = 'drag-drop';\n\n      api.onload(filteredItems, position);\n    };\n\n    client.ondrag = function(position) {\n      api.ondrag(position);\n    };\n\n    client.onenter = function(position) {\n      currentState = 'drag-over';\n\n      api.ondragstart(position);\n    };\n\n    client.onexit = function(position) {\n      currentState = 'drag-exit';\n\n      api.ondragend(position);\n    };\n\n    var api = {\n      updateHopperState: function updateHopperState() {\n        if (lastState !== currentState) {\n          scope.dataset.hopperState = currentState;\n          lastState = currentState;\n        }\n      },\n      onload: function onload() {},\n      ondragstart: function ondragstart() {},\n      ondrag: function ondrag() {},\n      ondragend: function ondragend() {},\n      destroy: function destroy() {\n        // destroy client\n        client.destroy();\n      }\n    };\n\n    return api;\n  };\n\n  var listening = false;\n  var listeners$1 = [];\n\n  var handlePaste = function handlePaste(e) {\n    // if is pasting in input or textarea and the target is outside of a filepond scope, ignore\n    var activeEl = document.activeElement;\n    if (activeEl && /textarea|input/i.test(activeEl.nodeName)) {\n      // test textarea or input is contained in filepond root\n      var inScope = false;\n      var element = activeEl;\n      while (element !== document.body) {\n        if (element.classList.contains('filepond--root')) {\n          inScope = true;\n          break;\n        }\n        element = element.parentNode;\n      }\n\n      if (!inScope) return;\n    }\n\n    requestDataTransferItems(e.clipboardData).then(function(files) {\n      // no files received\n      if (!files.length) {\n        return;\n      }\n\n      // notify listeners of received files\n      listeners$1.forEach(function(listener) {\n        return listener(files);\n      });\n    });\n  };\n\n  var listen = function listen(cb) {\n    // can't add twice\n    if (listeners$1.includes(cb)) {\n      return;\n    }\n\n    // add initial listener\n    listeners$1.push(cb);\n\n    // setup paste listener for entire page\n    if (listening) {\n      return;\n    }\n\n    listening = true;\n    document.addEventListener('paste', handlePaste);\n  };\n\n  var unlisten = function unlisten(listener) {\n    arrayRemove(listeners$1, listeners$1.indexOf(listener));\n\n    // clean up\n    if (listeners$1.length === 0) {\n      document.removeEventListener('paste', handlePaste);\n      listening = false;\n    }\n  };\n\n  var createPaster = function createPaster() {\n    var cb = function cb(files) {\n      api.onload(files);\n    };\n\n    var api = {\n      destroy: function destroy() {\n        unlisten(cb);\n      },\n      onload: function onload() {}\n    };\n\n    listen(cb);\n\n    return api;\n  };\n\n  /**\n   * Creates the file view\n   */\n  var create$d = function create(_ref) {\n    var root = _ref.root,\n      props = _ref.props;\n    root.element.id = 'filepond--assistant-' + props.id;\n    attr(root.element, 'role', 'status');\n    attr(root.element, 'aria-live', 'polite');\n    attr(root.element, 'aria-relevant', 'additions');\n  };\n\n  var addFilesNotificationTimeout = null;\n  var notificationClearTimeout = null;\n\n  var filenames = [];\n\n  var assist = function assist(root, message) {\n    root.element.textContent = message;\n  };\n\n  var clear$1 = function clear(root) {\n    root.element.textContent = '';\n  };\n\n  var listModified = function listModified(root, filename, label) {\n    var total = root.query('GET_TOTAL_ITEMS');\n    assist(\n      root,\n      label +\n        ' ' +\n        filename +\n        ', ' +\n        total +\n        ' ' +\n        (total === 1\n          ? root.query('GET_LABEL_FILE_COUNT_SINGULAR')\n          : root.query('GET_LABEL_FILE_COUNT_PLURAL'))\n    );\n\n    // clear group after set amount of time so the status is not read twice\n    clearTimeout(notificationClearTimeout);\n    notificationClearTimeout = setTimeout(function() {\n      clear$1(root);\n    }, 1500);\n  };\n\n  var isUsingFilePond = function isUsingFilePond(root) {\n    return root.element.parentNode.contains(document.activeElement);\n  };\n\n  var itemAdded = function itemAdded(_ref2) {\n    var root = _ref2.root,\n      action = _ref2.action;\n    if (!isUsingFilePond(root)) {\n      return;\n    }\n\n    root.element.textContent = '';\n    var item = root.query('GET_ITEM', action.id);\n    filenames.push(item.filename);\n\n    clearTimeout(addFilesNotificationTimeout);\n    addFilesNotificationTimeout = setTimeout(function() {\n      listModified(\n        root,\n        filenames.join(', '),\n        root.query('GET_LABEL_FILE_ADDED')\n      );\n\n      filenames.length = 0;\n    }, 750);\n  };\n\n  var itemRemoved = function itemRemoved(_ref3) {\n    var root = _ref3.root,\n      action = _ref3.action;\n    if (!isUsingFilePond(root)) {\n      return;\n    }\n\n    var item = action.item;\n    listModified(root, item.filename, root.query('GET_LABEL_FILE_REMOVED'));\n  };\n\n  var itemProcessed = function itemProcessed(_ref4) {\n    var root = _ref4.root,\n      action = _ref4.action;\n    // will also notify the user when FilePond is not being used, as the user might be occupied with other activities while uploading a file\n\n    var item = root.query('GET_ITEM', action.id);\n    var filename = item.filename;\n    var label = root.query('GET_LABEL_FILE_PROCESSING_COMPLETE');\n\n    assist(root, filename + ' ' + label);\n  };\n\n  var itemProcessedUndo = function itemProcessedUndo(_ref5) {\n    var root = _ref5.root,\n      action = _ref5.action;\n    var item = root.query('GET_ITEM', action.id);\n    var filename = item.filename;\n    var label = root.query('GET_LABEL_FILE_PROCESSING_ABORTED');\n\n    assist(root, filename + ' ' + label);\n  };\n\n  var itemError = function itemError(_ref6) {\n    var root = _ref6.root,\n      action = _ref6.action;\n    var item = root.query('GET_ITEM', action.id);\n    var filename = item.filename;\n\n    // will also notify the user when FilePond is not being used, as the user might be occupied with other activities while uploading a file\n\n    assist(root, action.status.main + ' ' + filename + ' ' + action.status.sub);\n  };\n\n  var assistant = createView({\n    create: create$d,\n    ignoreRect: true,\n    ignoreRectUpdate: true,\n    write: createRoute({\n      DID_LOAD_ITEM: itemAdded,\n      DID_REMOVE_ITEM: itemRemoved,\n      DID_COMPLETE_ITEM_PROCESSING: itemProcessed,\n\n      DID_ABORT_ITEM_PROCESSING: itemProcessedUndo,\n      DID_REVERT_ITEM_PROCESSING: itemProcessedUndo,\n\n      DID_THROW_ITEM_REMOVE_ERROR: itemError,\n      DID_THROW_ITEM_LOAD_ERROR: itemError,\n      DID_THROW_ITEM_INVALID: itemError,\n      DID_THROW_ITEM_PROCESSING_ERROR: itemError\n    }),\n\n    tag: 'span',\n    name: 'assistant'\n  });\n\n  var toCamels = function toCamels(string) {\n    var separator =\n      arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '-';\n    return string.replace(new RegExp(separator + '.', 'g'), function(sub) {\n      return sub.charAt(1).toUpperCase();\n    });\n  };\n\n  var debounce = function debounce(func) {\n    var interval =\n      arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 16;\n    var immidiateOnly =\n      arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    var last = Date.now();\n    var timeout = null;\n\n    return function() {\n      for (\n        var _len = arguments.length, args = new Array(_len), _key = 0;\n        _key < _len;\n        _key++\n      ) {\n        args[_key] = arguments[_key];\n      }\n      clearTimeout(timeout);\n\n      var dist = Date.now() - last;\n\n      var fn = function fn() {\n        last = Date.now();\n        func.apply(void 0, args);\n      };\n\n      if (dist < interval) {\n        // we need to delay by the difference between interval and dist\n        // for example: if distance is 10 ms and interval is 16 ms,\n        // we need to wait an additional 6ms before calling the function)\n        if (!immidiateOnly) {\n          timeout = setTimeout(fn, interval - dist);\n        }\n      } else {\n        // go!\n        fn();\n      }\n    };\n  };\n\n  var MAX_FILES_LIMIT = 1000000;\n\n  var prevent = function prevent(e) {\n    return e.preventDefault();\n  };\n\n  var create$e = function create(_ref) {\n    var root = _ref.root,\n      props = _ref.props;\n\n    // Add id\n    var id = root.query('GET_ID');\n    if (id) {\n      root.element.id = id;\n    }\n\n    // Add className\n    var className = root.query('GET_CLASS_NAME');\n    if (className) {\n      className\n        .split(' ')\n        .filter(function(name) {\n          return name.length;\n        })\n        .forEach(function(name) {\n          root.element.classList.add(name);\n        });\n    }\n\n    // Field label\n    root.ref.label = root.appendChildView(\n      root.createChildView(\n        dropLabel,\n        Object.assign({}, props, {\n          translateY: null,\n          caption: root.query('GET_LABEL_IDLE')\n        })\n      )\n    );\n\n    // List of items\n    root.ref.list = root.appendChildView(\n      root.createChildView(listScroller, { translateY: null })\n    );\n\n    // Background panel\n    root.ref.panel = root.appendChildView(\n      root.createChildView(panel, { name: 'panel-root' })\n    );\n\n    // Assistant notifies assistive tech when content changes\n    root.ref.assistant = root.appendChildView(\n      root.createChildView(assistant, Object.assign({}, props))\n    );\n\n    // Data\n    root.ref.data = root.appendChildView(\n      root.createChildView(data, Object.assign({}, props))\n    );\n\n    // Measure (tests if fixed height was set)\n    // DOCTYPE needs to be set for this to work\n    root.ref.measure = createElement$1('div');\n    root.ref.measure.style.height = '100%';\n    root.element.appendChild(root.ref.measure);\n\n    // information on the root height or fixed height status\n    root.ref.bounds = null;\n\n    // apply initial style properties\n    root\n      .query('GET_STYLES')\n      .filter(function(style) {\n        return !isEmpty(style.value);\n      })\n      .map(function(_ref2) {\n        var name = _ref2.name,\n          value = _ref2.value;\n        root.element.dataset[name] = value;\n      });\n\n    // determine if width changed\n    root.ref.widthPrevious = null;\n    root.ref.widthUpdated = debounce(function() {\n      root.ref.updateHistory = [];\n      root.dispatch('DID_RESIZE_ROOT');\n    }, 250);\n\n    // history of updates\n    root.ref.previousAspectRatio = null;\n    root.ref.updateHistory = [];\n\n    // prevent scrolling and zooming on iOS (only if supports pointer events, for then we can enable reorder)\n    var canHover = window.matchMedia('(pointer: fine) and (hover: hover)')\n      .matches;\n    var hasPointerEvents = 'PointerEvent' in window;\n    if (root.query('GET_ALLOW_REORDER') && hasPointerEvents && !canHover) {\n      root.element.addEventListener('touchmove', prevent, { passive: false });\n      root.element.addEventListener('gesturestart', prevent);\n    }\n\n    // add credits\n    var credits = root.query('GET_CREDITS');\n    var hasCredits = credits.length === 2;\n    if (hasCredits) {\n      var frag = document.createElement('a');\n      frag.className = 'filepond--credits';\n      frag.setAttribute('aria-hidden', 'true');\n      frag.href = credits[0];\n      frag.tabindex = -1;\n      frag.target = '_blank';\n      frag.rel = 'noopener noreferrer';\n      frag.textContent = credits[1];\n      root.element.appendChild(frag);\n      root.ref.credits = frag;\n    }\n  };\n\n  var write$9 = function write(_ref3) {\n    var root = _ref3.root,\n      props = _ref3.props,\n      actions = _ref3.actions;\n\n    // route actions\n    route$5({ root: root, props: props, actions: actions });\n\n    // apply style properties\n    actions\n      .filter(function(action) {\n        return /^DID_SET_STYLE_/.test(action.type);\n      })\n      .filter(function(action) {\n        return !isEmpty(action.data.value);\n      })\n      .map(function(_ref4) {\n        var type = _ref4.type,\n          data = _ref4.data;\n        var name = toCamels(type.substr(8).toLowerCase(), '_');\n        root.element.dataset[name] = data.value;\n        root.invalidateLayout();\n      });\n\n    if (root.rect.element.hidden) return;\n\n    if (root.rect.element.width !== root.ref.widthPrevious) {\n      root.ref.widthPrevious = root.rect.element.width;\n      root.ref.widthUpdated();\n    }\n\n    // get box bounds, we do this only once\n    var bounds = root.ref.bounds;\n    if (!bounds) {\n      bounds = root.ref.bounds = calculateRootBoundingBoxHeight(root);\n\n      // destroy measure element\n      root.element.removeChild(root.ref.measure);\n      root.ref.measure = null;\n    }\n\n    // get quick references to various high level parts of the upload tool\n    var _root$ref = root.ref,\n      hopper = _root$ref.hopper,\n      label = _root$ref.label,\n      list = _root$ref.list,\n      panel = _root$ref.panel;\n\n    // sets correct state to hopper scope\n    if (hopper) {\n      hopper.updateHopperState();\n    }\n\n    // bool to indicate if we're full or not\n    var aspectRatio = root.query('GET_PANEL_ASPECT_RATIO');\n    var isMultiItem = root.query('GET_ALLOW_MULTIPLE');\n    var totalItems = root.query('GET_TOTAL_ITEMS');\n    var maxItems = isMultiItem\n      ? root.query('GET_MAX_FILES') || MAX_FILES_LIMIT\n      : 1;\n    var atMaxCapacity = totalItems === maxItems;\n\n    // action used to add item\n    var addAction = actions.find(function(action) {\n      return action.type === 'DID_ADD_ITEM';\n    });\n\n    // if reached max capacity and we've just reached it\n    if (atMaxCapacity && addAction) {\n      // get interaction type\n      var interactionMethod = addAction.data.interactionMethod;\n\n      // hide label\n      label.opacity = 0;\n\n      if (isMultiItem) {\n        label.translateY = -40;\n      } else {\n        if (interactionMethod === InteractionMethod.API) {\n          label.translateX = 40;\n        } else if (interactionMethod === InteractionMethod.BROWSE) {\n          label.translateY = 40;\n        } else {\n          label.translateY = 30;\n        }\n      }\n    } else if (!atMaxCapacity) {\n      label.opacity = 1;\n      label.translateX = 0;\n      label.translateY = 0;\n    }\n\n    var listItemMargin = calculateListItemMargin(root);\n\n    var listHeight = calculateListHeight(root);\n\n    var labelHeight = label.rect.element.height;\n    var currentLabelHeight = !isMultiItem || atMaxCapacity ? 0 : labelHeight;\n\n    var listMarginTop = atMaxCapacity ? list.rect.element.marginTop : 0;\n    var listMarginBottom =\n      totalItems === 0 ? 0 : list.rect.element.marginBottom;\n\n    var visualHeight =\n      currentLabelHeight + listMarginTop + listHeight.visual + listMarginBottom;\n    var boundsHeight =\n      currentLabelHeight + listMarginTop + listHeight.bounds + listMarginBottom;\n\n    // link list to label bottom position\n    list.translateY =\n      Math.max(0, currentLabelHeight - list.rect.element.marginTop) -\n      listItemMargin.top;\n\n    if (aspectRatio) {\n      // fixed aspect ratio\n\n      // calculate height based on width\n      var width = root.rect.element.width;\n      var height = width * aspectRatio;\n\n      // clear history if aspect ratio has changed\n      if (aspectRatio !== root.ref.previousAspectRatio) {\n        root.ref.previousAspectRatio = aspectRatio;\n        root.ref.updateHistory = [];\n      }\n\n      // remember this width\n      var history = root.ref.updateHistory;\n      history.push(width);\n\n      var MAX_BOUNCES = 2;\n      if (history.length > MAX_BOUNCES * 2) {\n        var l = history.length;\n        var bottom = l - 10;\n        var bounces = 0;\n        for (var i = l; i >= bottom; i--) {\n          if (history[i] === history[i - 2]) {\n            bounces++;\n          }\n\n          if (bounces >= MAX_BOUNCES) {\n            // dont adjust height\n            return;\n          }\n        }\n      }\n\n      // fix height of panel so it adheres to aspect ratio\n      panel.scalable = false;\n      panel.height = height;\n\n      // available height for list\n      var listAvailableHeight =\n        // the height of the panel minus the label height\n        height -\n        currentLabelHeight -\n        // the room we leave open between the end of the list and the panel bottom\n        (listMarginBottom - listItemMargin.bottom) -\n        // if we're full we need to leave some room between the top of the panel and the list\n        (atMaxCapacity ? listMarginTop : 0);\n\n      if (listHeight.visual > listAvailableHeight) {\n        list.overflow = listAvailableHeight;\n      } else {\n        list.overflow = null;\n      }\n\n      // set container bounds (so pushes siblings downwards)\n      root.height = height;\n    } else if (bounds.fixedHeight) {\n      // fixed height\n\n      // fix height of panel\n      panel.scalable = false;\n\n      // available height for list\n      var _listAvailableHeight =\n        // the height of the panel minus the label height\n        bounds.fixedHeight -\n        currentLabelHeight -\n        // the room we leave open between the end of the list and the panel bottom\n        (listMarginBottom - listItemMargin.bottom) -\n        // if we're full we need to leave some room between the top of the panel and the list\n        (atMaxCapacity ? listMarginTop : 0);\n\n      // set list height\n      if (listHeight.visual > _listAvailableHeight) {\n        list.overflow = _listAvailableHeight;\n      } else {\n        list.overflow = null;\n      }\n\n      // no need to set container bounds as these are handles by CSS fixed height\n    } else if (bounds.cappedHeight) {\n      // max-height\n\n      // not a fixed height panel\n      var isCappedHeight = visualHeight >= bounds.cappedHeight;\n      var panelHeight = Math.min(bounds.cappedHeight, visualHeight);\n      panel.scalable = true;\n      panel.height = isCappedHeight\n        ? panelHeight\n        : panelHeight - listItemMargin.top - listItemMargin.bottom;\n\n      // available height for list\n      var _listAvailableHeight2 =\n        // the height of the panel minus the label height\n        panelHeight -\n        currentLabelHeight -\n        // the room we leave open between the end of the list and the panel bottom\n        (listMarginBottom - listItemMargin.bottom) -\n        // if we're full we need to leave some room between the top of the panel and the list\n        (atMaxCapacity ? listMarginTop : 0);\n\n      // set list height (if is overflowing)\n      if (\n        visualHeight > bounds.cappedHeight &&\n        listHeight.visual > _listAvailableHeight2\n      ) {\n        list.overflow = _listAvailableHeight2;\n      } else {\n        list.overflow = null;\n      }\n\n      // set container bounds (so pushes siblings downwards)\n      root.height = Math.min(\n        bounds.cappedHeight,\n        boundsHeight - listItemMargin.top - listItemMargin.bottom\n      );\n    } else {\n      // flexible height\n\n      // not a fixed height panel\n      var itemMargin =\n        totalItems > 0 ? listItemMargin.top + listItemMargin.bottom : 0;\n      panel.scalable = true;\n      panel.height = Math.max(labelHeight, visualHeight - itemMargin);\n\n      // set container bounds (so pushes siblings downwards)\n      root.height = Math.max(labelHeight, boundsHeight - itemMargin);\n    }\n\n    // move credits to bottom\n    if (root.ref.credits && panel.heightCurrent)\n      root.ref.credits.style.transform =\n        'translateY(' + panel.heightCurrent + 'px)';\n  };\n\n  var calculateListItemMargin = function calculateListItemMargin(root) {\n    var item = root.ref.list.childViews[0].childViews[0];\n    return item\n      ? {\n          top: item.rect.element.marginTop,\n          bottom: item.rect.element.marginBottom\n        }\n      : {\n          top: 0,\n          bottom: 0\n        };\n  };\n\n  var calculateListHeight = function calculateListHeight(root) {\n    var visual = 0;\n    var bounds = 0;\n\n    // get file list reference\n    var scrollList = root.ref.list;\n    var itemList = scrollList.childViews[0];\n    var visibleChildren = itemList.childViews.filter(function(child) {\n      return child.rect.element.height;\n    });\n    var children = root\n      .query('GET_ACTIVE_ITEMS')\n      .map(function(item) {\n        return visibleChildren.find(function(child) {\n          return child.id === item.id;\n        });\n      })\n      .filter(function(item) {\n        return item;\n      });\n\n    // no children, done!\n    if (children.length === 0) return { visual: visual, bounds: bounds };\n\n    var horizontalSpace = itemList.rect.element.width;\n    var dragIndex = getItemIndexByPosition(\n      itemList,\n      children,\n      scrollList.dragCoordinates\n    );\n\n    var childRect = children[0].rect.element;\n\n    var itemVerticalMargin = childRect.marginTop + childRect.marginBottom;\n    var itemHorizontalMargin = childRect.marginLeft + childRect.marginRight;\n\n    var itemWidth = childRect.width + itemHorizontalMargin;\n    var itemHeight = childRect.height + itemVerticalMargin;\n\n    var newItem = typeof dragIndex !== 'undefined' && dragIndex >= 0 ? 1 : 0;\n    var removedItem = children.find(function(child) {\n      return child.markedForRemoval && child.opacity < 0.45;\n    })\n      ? -1\n      : 0;\n    var verticalItemCount = children.length + newItem + removedItem;\n    var itemsPerRow = Math.round(horizontalSpace / itemWidth);\n\n    // stack\n    if (itemsPerRow === 1) {\n      children.forEach(function(item) {\n        var height = item.rect.element.height + itemVerticalMargin;\n        bounds += height;\n        visual += height * item.opacity;\n      });\n    }\n    // grid\n    else {\n      bounds = Math.ceil(verticalItemCount / itemsPerRow) * itemHeight;\n      visual = bounds;\n    }\n\n    return { visual: visual, bounds: bounds };\n  };\n\n  var calculateRootBoundingBoxHeight = function calculateRootBoundingBoxHeight(\n    root\n  ) {\n    var height = root.ref.measureHeight || null;\n    var cappedHeight = parseInt(root.style.maxHeight, 10) || null;\n    var fixedHeight = height === 0 ? null : height;\n\n    return {\n      cappedHeight: cappedHeight,\n      fixedHeight: fixedHeight\n    };\n  };\n\n  var exceedsMaxFiles = function exceedsMaxFiles(root, items) {\n    var allowReplace = root.query('GET_ALLOW_REPLACE');\n    var allowMultiple = root.query('GET_ALLOW_MULTIPLE');\n    var totalItems = root.query('GET_TOTAL_ITEMS');\n    var maxItems = root.query('GET_MAX_FILES');\n\n    // total amount of items being dragged\n    var totalBrowseItems = items.length;\n\n    // if does not allow multiple items and dragging more than one item\n    if (!allowMultiple && totalBrowseItems > 1) {\n      return true;\n    }\n\n    // limit max items to one if not allowed to drop multiple items\n    maxItems = allowMultiple ? maxItems : allowReplace ? maxItems : 1;\n\n    // no more room?\n    var hasMaxItems = isInt(maxItems);\n    if (hasMaxItems && totalItems + totalBrowseItems > maxItems) {\n      root.dispatch('DID_THROW_MAX_FILES', {\n        source: items,\n        error: createResponse('warning', 0, 'Max files')\n      });\n\n      return true;\n    }\n\n    return false;\n  };\n\n  var getDragIndex = function getDragIndex(list, children, position) {\n    var itemList = list.childViews[0];\n    return getItemIndexByPosition(itemList, children, {\n      left: position.scopeLeft - itemList.rect.element.left,\n      top:\n        position.scopeTop -\n        (list.rect.outer.top +\n          list.rect.element.marginTop +\n          list.rect.element.scrollTop)\n    });\n  };\n\n  /**\n   * Enable or disable file drop functionality\n   */\n  var toggleDrop = function toggleDrop(root) {\n    var isAllowed = root.query('GET_ALLOW_DROP');\n    var isDisabled = root.query('GET_DISABLED');\n    var enabled = isAllowed && !isDisabled;\n    if (enabled && !root.ref.hopper) {\n      var hopper = createHopper(\n        root.element,\n        function(items) {\n          // allow quick validation of dropped items\n          var beforeDropFile =\n            root.query('GET_BEFORE_DROP_FILE') ||\n            function() {\n              return true;\n            };\n\n          // all items should be validated by all filters as valid\n          var dropValidation = root.query('GET_DROP_VALIDATION');\n          return dropValidation\n            ? items.every(function(item) {\n                return (\n                  applyFilters('ALLOW_HOPPER_ITEM', item, {\n                    query: root.query\n                  }).every(function(result) {\n                    return result === true;\n                  }) && beforeDropFile(item)\n                );\n              })\n            : true;\n        },\n        {\n          filterItems: function filterItems(items) {\n            var ignoredFiles = root.query('GET_IGNORED_FILES');\n            return items.filter(function(item) {\n              if (isFile(item)) {\n                return !ignoredFiles.includes(item.name.toLowerCase());\n              }\n              return true;\n            });\n          },\n          catchesDropsOnPage: root.query('GET_DROP_ON_PAGE'),\n          requiresDropOnElement: root.query('GET_DROP_ON_ELEMENT')\n        }\n      );\n\n      hopper.onload = function(items, position) {\n        // get item children elements and sort based on list sort\n        var list = root.ref.list.childViews[0];\n        var visibleChildren = list.childViews.filter(function(child) {\n          return child.rect.element.height;\n        });\n        var children = root\n          .query('GET_ACTIVE_ITEMS')\n          .map(function(item) {\n            return visibleChildren.find(function(child) {\n              return child.id === item.id;\n            });\n          })\n          .filter(function(item) {\n            return item;\n          });\n\n        applyFilterChain('ADD_ITEMS', items, { dispatch: root.dispatch }).then(\n          function(queue) {\n            // these files don't fit so stop here\n            if (exceedsMaxFiles(root, queue)) return false;\n\n            // go\n            root.dispatch('ADD_ITEMS', {\n              items: queue,\n              index: getDragIndex(root.ref.list, children, position),\n              interactionMethod: InteractionMethod.DROP\n            });\n          }\n        );\n\n        root.dispatch('DID_DROP', { position: position });\n\n        root.dispatch('DID_END_DRAG', { position: position });\n      };\n\n      hopper.ondragstart = function(position) {\n        root.dispatch('DID_START_DRAG', { position: position });\n      };\n\n      hopper.ondrag = debounce(function(position) {\n        root.dispatch('DID_DRAG', { position: position });\n      });\n\n      hopper.ondragend = function(position) {\n        root.dispatch('DID_END_DRAG', { position: position });\n      };\n\n      root.ref.hopper = hopper;\n\n      root.ref.drip = root.appendChildView(root.createChildView(drip));\n    } else if (!enabled && root.ref.hopper) {\n      root.ref.hopper.destroy();\n      root.ref.hopper = null;\n      root.removeChildView(root.ref.drip);\n    }\n  };\n\n  /**\n   * Enable or disable browse functionality\n   */\n  var toggleBrowse = function toggleBrowse(root, props) {\n    var isAllowed = root.query('GET_ALLOW_BROWSE');\n    var isDisabled = root.query('GET_DISABLED');\n    var enabled = isAllowed && !isDisabled;\n    if (enabled && !root.ref.browser) {\n      root.ref.browser = root.appendChildView(\n        root.createChildView(\n          browser,\n          Object.assign({}, props, {\n            onload: function onload(items) {\n              applyFilterChain('ADD_ITEMS', items, {\n                dispatch: root.dispatch\n              }).then(function(queue) {\n                // these files don't fit so stop here\n                if (exceedsMaxFiles(root, queue)) return false;\n\n                // add items!\n                root.dispatch('ADD_ITEMS', {\n                  items: queue,\n                  index: -1,\n                  interactionMethod: InteractionMethod.BROWSE\n                });\n              });\n            }\n          })\n        ),\n\n        0\n      );\n    } else if (!enabled && root.ref.browser) {\n      root.removeChildView(root.ref.browser);\n      root.ref.browser = null;\n    }\n  };\n\n  /**\n   * Enable or disable paste functionality\n   */\n  var togglePaste = function togglePaste(root) {\n    var isAllowed = root.query('GET_ALLOW_PASTE');\n    var isDisabled = root.query('GET_DISABLED');\n    var enabled = isAllowed && !isDisabled;\n    if (enabled && !root.ref.paster) {\n      root.ref.paster = createPaster();\n      root.ref.paster.onload = function(items) {\n        applyFilterChain('ADD_ITEMS', items, { dispatch: root.dispatch }).then(\n          function(queue) {\n            // these files don't fit so stop here\n            if (exceedsMaxFiles(root, queue)) return false;\n\n            // add items!\n            root.dispatch('ADD_ITEMS', {\n              items: queue,\n              index: -1,\n              interactionMethod: InteractionMethod.PASTE\n            });\n          }\n        );\n      };\n    } else if (!enabled && root.ref.paster) {\n      root.ref.paster.destroy();\n      root.ref.paster = null;\n    }\n  };\n\n  /**\n   * Route actions\n   */\n  var route$5 = createRoute({\n    DID_SET_ALLOW_BROWSE: function DID_SET_ALLOW_BROWSE(_ref5) {\n      var root = _ref5.root,\n        props = _ref5.props;\n      toggleBrowse(root, props);\n    },\n    DID_SET_ALLOW_DROP: function DID_SET_ALLOW_DROP(_ref6) {\n      var root = _ref6.root;\n      toggleDrop(root);\n    },\n    DID_SET_ALLOW_PASTE: function DID_SET_ALLOW_PASTE(_ref7) {\n      var root = _ref7.root;\n      togglePaste(root);\n    },\n    DID_SET_DISABLED: function DID_SET_DISABLED(_ref8) {\n      var root = _ref8.root,\n        props = _ref8.props;\n      toggleDrop(root);\n      togglePaste(root);\n      toggleBrowse(root, props);\n      var isDisabled = root.query('GET_DISABLED');\n      if (isDisabled) {\n        root.element.dataset.disabled = 'disabled';\n      } else {\n        // delete root.element.dataset.disabled; <= this does not work on iOS 10\n        root.element.removeAttribute('data-disabled');\n      }\n    }\n  });\n\n  var root = createView({\n    name: 'root',\n    read: function read(_ref9) {\n      var root = _ref9.root;\n      if (root.ref.measure) {\n        root.ref.measureHeight = root.ref.measure.offsetHeight;\n      }\n    },\n    create: create$e,\n    write: write$9,\n    destroy: function destroy(_ref10) {\n      var root = _ref10.root;\n      if (root.ref.paster) {\n        root.ref.paster.destroy();\n      }\n      if (root.ref.hopper) {\n        root.ref.hopper.destroy();\n      }\n      root.element.removeEventListener('touchmove', prevent);\n      root.element.removeEventListener('gesturestart', prevent);\n    },\n    mixins: {\n      styles: ['height']\n    }\n  });\n\n  // creates the app\n  var createApp = function createApp() {\n    var initialOptions =\n      arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    // let element\n    var originalElement = null;\n\n    // get default options\n    var defaultOptions = getOptions();\n\n    // create the data store, this will contain all our app info\n    var store = createStore(\n      // initial state (should be serializable)\n      createInitialState(defaultOptions),\n\n      // queries\n      [queries, createOptionQueries(defaultOptions)],\n\n      // action handlers\n      [actions, createOptionActions(defaultOptions)]\n    );\n\n    // set initial options\n    store.dispatch('SET_OPTIONS', { options: initialOptions });\n\n    // kick thread if visibility changes\n    var visibilityHandler = function visibilityHandler() {\n      if (document.hidden) return;\n      store.dispatch('KICK');\n    };\n    document.addEventListener('visibilitychange', visibilityHandler);\n\n    // re-render on window resize start and finish\n    var resizeDoneTimer = null;\n    var isResizing = false;\n    var isResizingHorizontally = false;\n    var initialWindowWidth = null;\n    var currentWindowWidth = null;\n    var resizeHandler = function resizeHandler() {\n      if (!isResizing) {\n        isResizing = true;\n      }\n      clearTimeout(resizeDoneTimer);\n      resizeDoneTimer = setTimeout(function() {\n        isResizing = false;\n        initialWindowWidth = null;\n        currentWindowWidth = null;\n        if (isResizingHorizontally) {\n          isResizingHorizontally = false;\n          store.dispatch('DID_STOP_RESIZE');\n        }\n      }, 500);\n    };\n    window.addEventListener('resize', resizeHandler);\n\n    // render initial view\n    var view = root(store, { id: getUniqueId() });\n\n    //\n    // PRIVATE API -------------------------------------------------------------------------------------\n    //\n    var isResting = false;\n    var isHidden = false;\n\n    var readWriteApi = {\n      // necessary for update loop\n\n      /**\n       * Reads from dom (never call manually)\n       * @private\n       */\n      _read: function _read() {\n        // test if we're resizing horizontally\n        // TODO: see if we can optimize this by measuring root rect\n        if (isResizing) {\n          currentWindowWidth = window.innerWidth;\n          if (!initialWindowWidth) {\n            initialWindowWidth = currentWindowWidth;\n          }\n\n          if (\n            !isResizingHorizontally &&\n            currentWindowWidth !== initialWindowWidth\n          ) {\n            store.dispatch('DID_START_RESIZE');\n            isResizingHorizontally = true;\n          }\n        }\n\n        if (isHidden && isResting) {\n          // test if is no longer hidden\n          isResting = view.element.offsetParent === null;\n        }\n\n        // if resting, no need to read as numbers will still all be correct\n        if (isResting) return;\n\n        // read view data\n        view._read();\n\n        // if is hidden we need to know so we exit rest mode when revealed\n        isHidden = view.rect.element.hidden;\n      },\n\n      /**\n       * Writes to dom (never call manually)\n       * @private\n       */\n      _write: function _write(ts) {\n        // get all actions from store\n        var actions = store\n          .processActionQueue()\n\n          // filter out set actions (these will automatically trigger DID_SET)\n          .filter(function(action) {\n            return !/^SET_/.test(action.type);\n          });\n\n        // if was idling and no actions stop here\n        if (isResting && !actions.length) return;\n\n        // some actions might trigger events\n        routeActionsToEvents(actions);\n\n        // update the view\n        isResting = view._write(ts, actions, isResizingHorizontally);\n\n        // will clean up all archived items\n        removeReleasedItems(store.query('GET_ITEMS'));\n\n        // now idling\n        if (isResting) {\n          store.processDispatchQueue();\n        }\n      }\n    };\n\n    //\n    // EXPOSE EVENTS -------------------------------------------------------------------------------------\n    //\n    var createEvent = function createEvent(name) {\n      return function(data) {\n        // create default event\n        var event = {\n          type: name\n        };\n\n        // no data to add\n        if (!data) {\n          return event;\n        }\n\n        // copy relevant props\n        if (data.hasOwnProperty('error')) {\n          event.error = data.error ? Object.assign({}, data.error) : null;\n        }\n\n        if (data.status) {\n          event.status = Object.assign({}, data.status);\n        }\n\n        if (data.file) {\n          event.output = data.file;\n        }\n\n        // only source is available, else add item if possible\n        if (data.source) {\n          event.file = data.source;\n        } else if (data.item || data.id) {\n          var item = data.item ? data.item : store.query('GET_ITEM', data.id);\n          event.file = item ? createItemAPI(item) : null;\n        }\n\n        // map all items in a possible items array\n        if (data.items) {\n          event.items = data.items.map(createItemAPI);\n        }\n\n        // if this is a progress event add the progress amount\n        if (/progress/.test(name)) {\n          event.progress = data.progress;\n        }\n\n        // copy relevant props\n        if (data.hasOwnProperty('origin') && data.hasOwnProperty('target')) {\n          event.origin = data.origin;\n          event.target = data.target;\n        }\n\n        return event;\n      };\n    };\n\n    var eventRoutes = {\n      DID_DESTROY: createEvent('destroy'),\n\n      DID_INIT: createEvent('init'),\n\n      DID_THROW_MAX_FILES: createEvent('warning'),\n\n      DID_INIT_ITEM: createEvent('initfile'),\n      DID_START_ITEM_LOAD: createEvent('addfilestart'),\n      DID_UPDATE_ITEM_LOAD_PROGRESS: createEvent('addfileprogress'),\n      DID_LOAD_ITEM: createEvent('addfile'),\n\n      DID_THROW_ITEM_INVALID: [createEvent('error'), createEvent('addfile')],\n\n      DID_THROW_ITEM_LOAD_ERROR: [createEvent('error'), createEvent('addfile')],\n\n      DID_THROW_ITEM_REMOVE_ERROR: [\n        createEvent('error'),\n        createEvent('removefile')\n      ],\n\n      DID_PREPARE_OUTPUT: createEvent('preparefile'),\n\n      DID_START_ITEM_PROCESSING: createEvent('processfilestart'),\n      DID_UPDATE_ITEM_PROCESS_PROGRESS: createEvent('processfileprogress'),\n      DID_ABORT_ITEM_PROCESSING: createEvent('processfileabort'),\n      DID_COMPLETE_ITEM_PROCESSING: createEvent('processfile'),\n      DID_COMPLETE_ITEM_PROCESSING_ALL: createEvent('processfiles'),\n      DID_REVERT_ITEM_PROCESSING: createEvent('processfilerevert'),\n\n      DID_THROW_ITEM_PROCESSING_ERROR: [\n        createEvent('error'),\n        createEvent('processfile')\n      ],\n\n      DID_REMOVE_ITEM: createEvent('removefile'),\n\n      DID_UPDATE_ITEMS: createEvent('updatefiles'),\n\n      DID_ACTIVATE_ITEM: createEvent('activatefile'),\n\n      DID_REORDER_ITEMS: createEvent('reorderfiles')\n    };\n\n    var exposeEvent = function exposeEvent(event) {\n      // create event object to be dispatched\n      var detail = Object.assign({ pond: exports }, event);\n      delete detail.type;\n      view.element.dispatchEvent(\n        new CustomEvent('FilePond:' + event.type, {\n          // event info\n          detail: detail,\n\n          // event behaviour\n          bubbles: true,\n          cancelable: true,\n          composed: true // triggers listeners outside of shadow root\n        })\n      );\n\n      // event object to params used for `on()` event handlers and callbacks `oninit()`\n      var params = [];\n\n      // if is possible error event, make it the first param\n      if (event.hasOwnProperty('error')) {\n        params.push(event.error);\n      }\n\n      // file is always section\n      if (event.hasOwnProperty('file')) {\n        params.push(event.file);\n      }\n\n      // append other props\n      var filtered = ['type', 'error', 'file'];\n      Object.keys(event)\n        .filter(function(key) {\n          return !filtered.includes(key);\n        })\n        .forEach(function(key) {\n          return params.push(event[key]);\n        });\n\n      // on(type, () => { })\n      exports.fire.apply(exports, [event.type].concat(params));\n\n      // oninit = () => {}\n      var handler = store.query('GET_ON' + event.type.toUpperCase());\n      if (handler) {\n        handler.apply(void 0, params);\n      }\n    };\n\n    var routeActionsToEvents = function routeActionsToEvents(actions) {\n      if (!actions.length) return;\n      actions\n        .filter(function(action) {\n          return eventRoutes[action.type];\n        })\n        .forEach(function(action) {\n          var routes = eventRoutes[action.type];\n          (Array.isArray(routes) ? routes : [routes]).forEach(function(route) {\n            // this isn't fantastic, but because of the stacking of settimeouts plugins can handle the did_load before the did_init\n            if (action.type === 'DID_INIT_ITEM') {\n              exposeEvent(route(action.data));\n            } else {\n              setTimeout(function() {\n                exposeEvent(route(action.data));\n              }, 0);\n            }\n          });\n        });\n    };\n\n    //\n    // PUBLIC API -------------------------------------------------------------------------------------\n    //\n    var setOptions = function setOptions(options) {\n      return store.dispatch('SET_OPTIONS', { options: options });\n    };\n\n    var getFile = function getFile(query) {\n      return store.query('GET_ACTIVE_ITEM', query);\n    };\n\n    var prepareFile = function prepareFile(query) {\n      return new Promise(function(resolve, reject) {\n        store.dispatch('REQUEST_ITEM_PREPARE', {\n          query: query,\n          success: function success(item) {\n            resolve(item);\n          },\n          failure: function failure(error) {\n            reject(error);\n          }\n        });\n      });\n    };\n\n    var addFile = function addFile(source) {\n      var options =\n        arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return new Promise(function(resolve, reject) {\n        addFiles([{ source: source, options: options }], {\n          index: options.index\n        })\n          .then(function(items) {\n            return resolve(items && items[0]);\n          })\n          .catch(reject);\n      });\n    };\n\n    var isFilePondFile = function isFilePondFile(obj) {\n      return obj.file && obj.id;\n    };\n\n    var removeFile = function removeFile(query, options) {\n      // if only passed options\n      if (typeof query === 'object' && !isFilePondFile(query) && !options) {\n        options = query;\n        query = undefined;\n      }\n\n      // request item removal\n      store.dispatch(\n        'REMOVE_ITEM',\n        Object.assign({}, options, { query: query })\n      );\n\n      // see if item has been removed\n      return store.query('GET_ACTIVE_ITEM', query) === null;\n    };\n\n    var addFiles = function addFiles() {\n      for (\n        var _len = arguments.length, args = new Array(_len), _key = 0;\n        _key < _len;\n        _key++\n      ) {\n        args[_key] = arguments[_key];\n      }\n      return new Promise(function(resolve, reject) {\n        var sources = [];\n        var options = {};\n\n        // user passed a sources array\n        if (isArray(args[0])) {\n          sources.push.apply(sources, args[0]);\n          Object.assign(options, args[1] || {});\n        } else {\n          // user passed sources as arguments, last one might be options object\n          var lastArgument = args[args.length - 1];\n          if (\n            typeof lastArgument === 'object' &&\n            !(lastArgument instanceof Blob)\n          ) {\n            Object.assign(options, args.pop());\n          }\n\n          // add rest to sources\n          sources.push.apply(sources, args);\n        }\n\n        store.dispatch('ADD_ITEMS', {\n          items: sources,\n          index: options.index,\n          interactionMethod: InteractionMethod.API,\n          success: resolve,\n          failure: reject\n        });\n      });\n    };\n\n    var getFiles = function getFiles() {\n      return store.query('GET_ACTIVE_ITEMS');\n    };\n\n    var processFile = function processFile(query) {\n      return new Promise(function(resolve, reject) {\n        store.dispatch('REQUEST_ITEM_PROCESSING', {\n          query: query,\n          success: function success(item) {\n            resolve(item);\n          },\n          failure: function failure(error) {\n            reject(error);\n          }\n        });\n      });\n    };\n\n    var prepareFiles = function prepareFiles() {\n      for (\n        var _len2 = arguments.length, args = new Array(_len2), _key2 = 0;\n        _key2 < _len2;\n        _key2++\n      ) {\n        args[_key2] = arguments[_key2];\n      }\n      var queries = Array.isArray(args[0]) ? args[0] : args;\n      var items = queries.length ? queries : getFiles();\n      return Promise.all(items.map(prepareFile));\n    };\n\n    var processFiles = function processFiles() {\n      for (\n        var _len3 = arguments.length, args = new Array(_len3), _key3 = 0;\n        _key3 < _len3;\n        _key3++\n      ) {\n        args[_key3] = arguments[_key3];\n      }\n      var queries = Array.isArray(args[0]) ? args[0] : args;\n      if (!queries.length) {\n        var files = getFiles().filter(function(item) {\n          return (\n            !(\n              item.status === ItemStatus.IDLE &&\n              item.origin === FileOrigin.LOCAL\n            ) &&\n            item.status !== ItemStatus.PROCESSING &&\n            item.status !== ItemStatus.PROCESSING_COMPLETE &&\n            item.status !== ItemStatus.PROCESSING_REVERT_ERROR\n          );\n        });\n\n        return Promise.all(files.map(processFile));\n      }\n      return Promise.all(queries.map(processFile));\n    };\n\n    var removeFiles = function removeFiles() {\n      for (\n        var _len4 = arguments.length, args = new Array(_len4), _key4 = 0;\n        _key4 < _len4;\n        _key4++\n      ) {\n        args[_key4] = arguments[_key4];\n      }\n\n      var queries = Array.isArray(args[0]) ? args[0] : args;\n\n      var options;\n      if (typeof queries[queries.length - 1] === 'object') {\n        options = queries.pop();\n      } else if (Array.isArray(args[0])) {\n        options = args[1];\n      }\n\n      var files = getFiles();\n\n      if (!queries.length)\n        return Promise.all(\n          files.map(function(file) {\n            return removeFile(file, options);\n          })\n        );\n\n      // when removing by index the indexes shift after each file removal so we need to convert indexes to ids\n      var mappedQueries = queries\n        .map(function(query) {\n          return isNumber(query)\n            ? files[query]\n              ? files[query].id\n              : null\n            : query;\n        })\n        .filter(function(query) {\n          return query;\n        });\n\n      return mappedQueries.map(function(q) {\n        return removeFile(q, options);\n      });\n    };\n\n    var exports = Object.assign(\n      {},\n\n      on(),\n      {},\n\n      readWriteApi,\n      {},\n\n      createOptionAPI(store, defaultOptions),\n      {\n        /**\n         * Override options defined in options object\n         * @param options\n         */\n        setOptions: setOptions,\n\n        /**\n         * Load the given file\n         * @param source - the source of the file (either a File, base64 data uri or url)\n         * @param options - object, { index: 0 }\n         */\n        addFile: addFile,\n\n        /**\n         * Load the given files\n         * @param sources - the sources of the files to load\n         * @param options - object, { index: 0 }\n         */\n        addFiles: addFiles,\n\n        /**\n         * Returns the file objects matching the given query\n         * @param query { string, number, null }\n         */\n        getFile: getFile,\n\n        /**\n         * Upload file with given name\n         * @param query { string, number, null  }\n         */\n        processFile: processFile,\n\n        /**\n         * Request prepare output for file with given name\n         * @param query { string, number, null  }\n         */\n        prepareFile: prepareFile,\n\n        /**\n         * Removes a file by its name\n         * @param query { string, number, null  }\n         */\n        removeFile: removeFile,\n\n        /**\n         * Moves a file to a new location in the files list\n         */\n        moveFile: function moveFile(query, index) {\n          return store.dispatch('MOVE_ITEM', { query: query, index: index });\n        },\n\n        /**\n         * Returns all files (wrapped in public api)\n         */\n        getFiles: getFiles,\n\n        /**\n         * Starts uploading all files\n         */\n        processFiles: processFiles,\n\n        /**\n         * Clears all files from the files list\n         */\n        removeFiles: removeFiles,\n\n        /**\n         * Starts preparing output of all files\n         */\n        prepareFiles: prepareFiles,\n\n        /**\n         * Sort list of files\n         */\n        sort: function sort(compare) {\n          return store.dispatch('SORT', { compare: compare });\n        },\n\n        /**\n         * Browse the file system for a file\n         */\n        browse: function browse() {\n          // needs to be trigger directly as user action needs to be traceable (is not traceable in requestAnimationFrame)\n          var input = view.element.querySelector('input[type=file]');\n          if (input) {\n            input.click();\n          }\n        },\n\n        /**\n         * Destroys the app\n         */\n        destroy: function destroy() {\n          // request destruction\n          exports.fire('destroy', view.element);\n\n          // stop active processes (file uploads, fetches, stuff like that)\n          // loop over items and depending on states call abort for ongoing processes\n          store.dispatch('ABORT_ALL');\n\n          // destroy view\n          view._destroy();\n\n          // stop listening to resize\n          window.removeEventListener('resize', resizeHandler);\n\n          // stop listening to the visiblitychange event\n          document.removeEventListener('visibilitychange', visibilityHandler);\n\n          // dispatch destroy\n          store.dispatch('DID_DESTROY');\n        },\n\n        /**\n         * Inserts the plugin before the target element\n         */\n        insertBefore: function insertBefore$1(element) {\n          return insertBefore(view.element, element);\n        },\n\n        /**\n         * Inserts the plugin after the target element\n         */\n        insertAfter: function insertAfter$1(element) {\n          return insertAfter(view.element, element);\n        },\n\n        /**\n         * Appends the plugin to the target element\n         */\n        appendTo: function appendTo(element) {\n          return element.appendChild(view.element);\n        },\n\n        /**\n         * Replaces an element with the app\n         */\n        replaceElement: function replaceElement(element) {\n          // insert the app before the element\n          insertBefore(view.element, element);\n\n          // remove the original element\n          element.parentNode.removeChild(element);\n\n          // remember original element\n          originalElement = element;\n        },\n\n        /**\n         * Restores the original element\n         */\n        restoreElement: function restoreElement() {\n          if (!originalElement) {\n            return; // no element to restore\n          }\n\n          // restore original element\n          insertAfter(originalElement, view.element);\n\n          // remove our element\n          view.element.parentNode.removeChild(view.element);\n\n          // remove reference\n          originalElement = null;\n        },\n\n        /**\n         * Returns true if the app root is attached to given element\n         * @param element\n         */\n        isAttachedTo: function isAttachedTo(element) {\n          return view.element === element || originalElement === element;\n        },\n\n        /**\n         * Returns the root element\n         */\n        element: {\n          get: function get() {\n            return view.element;\n          }\n        },\n\n        /**\n         * Returns the current pond status\n         */\n        status: {\n          get: function get() {\n            return store.query('GET_STATUS');\n          }\n        }\n      }\n    );\n\n    // Done!\n    store.dispatch('DID_INIT');\n\n    // create actual api object\n    return createObject(exports);\n  };\n\n  var createAppObject = function createAppObject() {\n    var customOptions =\n      arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    // default options\n    var defaultOptions = {};\n    forin(getOptions(), function(key, value) {\n      defaultOptions[key] = value[0];\n    });\n\n    // set app options\n    var app = createApp(\n      Object.assign(\n        {},\n\n        defaultOptions,\n        {},\n\n        customOptions\n      )\n    );\n\n    // return the plugin instance\n    return app;\n  };\n\n  var lowerCaseFirstLetter = function lowerCaseFirstLetter(string) {\n    return string.charAt(0).toLowerCase() + string.slice(1);\n  };\n\n  var attributeNameToPropertyName = function attributeNameToPropertyName(\n    attributeName\n  ) {\n    return toCamels(attributeName.replace(/^data-/, ''));\n  };\n\n  var mapObject = function mapObject(object, propertyMap) {\n    // remove unwanted\n    forin(propertyMap, function(selector, mapping) {\n      forin(object, function(property, value) {\n        // create regexp shortcut\n        var selectorRegExp = new RegExp(selector);\n\n        // tests if\n        var matches = selectorRegExp.test(property);\n\n        // no match, skip\n        if (!matches) {\n          return;\n        }\n\n        // if there's a mapping, the original property is always removed\n        delete object[property];\n\n        // should only remove, we done!\n        if (mapping === false) {\n          return;\n        }\n\n        // move value to new property\n        if (isString(mapping)) {\n          object[mapping] = value;\n          return;\n        }\n\n        // move to group\n        var group = mapping.group;\n        if (isObject(mapping) && !object[group]) {\n          object[group] = {};\n        }\n\n        object[group][\n          lowerCaseFirstLetter(property.replace(selectorRegExp, ''))\n        ] = value;\n      });\n\n      // do submapping\n      if (mapping.mapping) {\n        mapObject(object[mapping.group], mapping.mapping);\n      }\n    });\n  };\n\n  var getAttributesAsObject = function getAttributesAsObject(node) {\n    var attributeMapping =\n      arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    // turn attributes into object\n    var attributes = [];\n    forin(node.attributes, function(index) {\n      attributes.push(node.attributes[index]);\n    });\n\n    var output = attributes\n      .filter(function(attribute) {\n        return attribute.name;\n      })\n      .reduce(function(obj, attribute) {\n        var value = attr(node, attribute.name);\n\n        obj[attributeNameToPropertyName(attribute.name)] =\n          value === attribute.name ? true : value;\n        return obj;\n      }, {});\n\n    // do mapping of object properties\n    mapObject(output, attributeMapping);\n\n    return output;\n  };\n\n  var createAppAtElement = function createAppAtElement(element) {\n    var options =\n      arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    // how attributes of the input element are mapped to the options for the plugin\n    var attributeMapping = {\n      // translate to other name\n      '^class$': 'className',\n      '^multiple$': 'allowMultiple',\n      '^capture$': 'captureMethod',\n      '^webkitdirectory$': 'allowDirectoriesOnly',\n\n      // group under single property\n      '^server': {\n        group: 'server',\n        mapping: {\n          '^process': {\n            group: 'process'\n          },\n\n          '^revert': {\n            group: 'revert'\n          },\n\n          '^fetch': {\n            group: 'fetch'\n          },\n\n          '^restore': {\n            group: 'restore'\n          },\n\n          '^load': {\n            group: 'load'\n          }\n        }\n      },\n\n      // don't include in object\n      '^type$': false,\n      '^files$': false\n    };\n\n    // add additional option translators\n    applyFilters('SET_ATTRIBUTE_TO_OPTION_MAP', attributeMapping);\n\n    // create final options object by setting options object and then overriding options supplied on element\n    var mergedOptions = Object.assign({}, options);\n\n    var attributeOptions = getAttributesAsObject(\n      element.nodeName === 'FIELDSET'\n        ? element.querySelector('input[type=file]')\n        : element,\n      attributeMapping\n    );\n\n    // merge with options object\n    Object.keys(attributeOptions).forEach(function(key) {\n      if (isObject(attributeOptions[key])) {\n        if (!isObject(mergedOptions[key])) {\n          mergedOptions[key] = {};\n        }\n        Object.assign(mergedOptions[key], attributeOptions[key]);\n      } else {\n        mergedOptions[key] = attributeOptions[key];\n      }\n    });\n\n    // if parent is a fieldset, get files from parent by selecting all input fields that are not file upload fields\n    // these will then be automatically set to the initial files\n    mergedOptions.files = (options.files || []).concat(\n      Array.from(element.querySelectorAll('input:not([type=file])')).map(\n        function(input) {\n          return {\n            source: input.value,\n            options: {\n              type: input.dataset.type\n            }\n          };\n        }\n      )\n    );\n\n    // build plugin\n    var app = createAppObject(mergedOptions);\n\n    // add already selected files\n    if (element.files) {\n      Array.from(element.files).forEach(function(file) {\n        app.addFile(file);\n      });\n    }\n\n    // replace the target element\n    app.replaceElement(element);\n\n    // expose\n    return app;\n  };\n\n  // if an element is passed, we create the instance at that element, if not, we just create an up object\n  var createApp$1 = function createApp() {\n    return isNode(arguments.length <= 0 ? undefined : arguments[0])\n      ? createAppAtElement.apply(void 0, arguments)\n      : createAppObject.apply(void 0, arguments);\n  };\n\n  var PRIVATE_METHODS = ['fire', '_read', '_write'];\n\n  var createAppAPI = function createAppAPI(app) {\n    var api = {};\n\n    copyObjectPropertiesToObject(app, api, PRIVATE_METHODS);\n\n    return api;\n  };\n\n  /**\n   * Replaces placeholders in given string with replacements\n   * @param string - \"Foo {bar}\"\"\n   * @param replacements - { \"bar\": 10 }\n   */\n  var replaceInString = function replaceInString(string, replacements) {\n    return string.replace(/(?:{([a-zA-Z]+)})/g, function(match, group) {\n      return replacements[group];\n    });\n  };\n\n  var createWorker = function createWorker(fn) {\n    var workerBlob = new Blob(['(', fn.toString(), ')()'], {\n      type: 'application/javascript'\n    });\n\n    var workerURL = URL.createObjectURL(workerBlob);\n    var worker = new Worker(workerURL);\n\n    return {\n      transfer: function transfer(message, cb) {},\n      post: function post(message, cb, transferList) {\n        var id = getUniqueId();\n\n        worker.onmessage = function(e) {\n          if (e.data.id === id) {\n            cb(e.data.message);\n          }\n        };\n\n        worker.postMessage(\n          {\n            id: id,\n            message: message\n          },\n\n          transferList\n        );\n      },\n      terminate: function terminate() {\n        worker.terminate();\n        URL.revokeObjectURL(workerURL);\n      }\n    };\n  };\n\n  var loadImage = function loadImage(url) {\n    return new Promise(function(resolve, reject) {\n      var img = new Image();\n      img.onload = function() {\n        resolve(img);\n      };\n      img.onerror = function(e) {\n        reject(e);\n      };\n      img.src = url;\n    });\n  };\n\n  var renameFile = function renameFile(file, name) {\n    var renamedFile = file.slice(0, file.size, file.type);\n    renamedFile.lastModifiedDate = file.lastModifiedDate;\n    renamedFile.name = name;\n    return renamedFile;\n  };\n\n  var copyFile = function copyFile(file) {\n    return renameFile(file, file.name);\n  };\n\n  // already registered plugins (can't register twice)\n  var registeredPlugins = [];\n\n  // pass utils to plugin\n  var createAppPlugin = function createAppPlugin(plugin) {\n    // already registered\n    if (registeredPlugins.includes(plugin)) {\n      return;\n    }\n\n    // remember this plugin\n    registeredPlugins.push(plugin);\n\n    // setup!\n    var pluginOutline = plugin({\n      addFilter: addFilter,\n      utils: {\n        Type: Type,\n        forin: forin,\n        isString: isString,\n        isFile: isFile,\n        toNaturalFileSize: toNaturalFileSize,\n        replaceInString: replaceInString,\n        getExtensionFromFilename: getExtensionFromFilename,\n        getFilenameWithoutExtension: getFilenameWithoutExtension,\n        guesstimateMimeType: guesstimateMimeType,\n        getFileFromBlob: getFileFromBlob,\n        getFilenameFromURL: getFilenameFromURL,\n        createRoute: createRoute,\n        createWorker: createWorker,\n        createView: createView,\n        createItemAPI: createItemAPI,\n        loadImage: loadImage,\n        copyFile: copyFile,\n        renameFile: renameFile,\n        createBlob: createBlob,\n        applyFilterChain: applyFilterChain,\n        text: text,\n        getNumericAspectRatioFromString: getNumericAspectRatioFromString\n      },\n\n      views: {\n        fileActionButton: fileActionButton\n      }\n    });\n\n    // add plugin options to default options\n    extendDefaultOptions(pluginOutline.options);\n  };\n\n  // feature detection used by supported() method\n  var isOperaMini = function isOperaMini() {\n    return (\n      Object.prototype.toString.call(window.operamini) === '[object OperaMini]'\n    );\n  };\n  var hasPromises = function hasPromises() {\n    return 'Promise' in window;\n  };\n  var hasBlobSlice = function hasBlobSlice() {\n    return 'slice' in Blob.prototype;\n  };\n  var hasCreateObjectURL = function hasCreateObjectURL() {\n    return 'URL' in window && 'createObjectURL' in window.URL;\n  };\n  var hasVisibility = function hasVisibility() {\n    return 'visibilityState' in document;\n  };\n  var hasTiming = function hasTiming() {\n    return 'performance' in window;\n  }; // iOS 8.x\n  var hasCSSSupports = function hasCSSSupports() {\n    return 'supports' in (window.CSS || {});\n  }; // use to detect Safari 9+\n  var isIE11 = function isIE11() {\n    return /MSIE|Trident/.test(window.navigator.userAgent);\n  };\n\n  var supported = (function() {\n    // Runs immediately and then remembers result for subsequent calls\n    var isSupported =\n      // Has to be a browser\n      isBrowser() &&\n      // Can't run on Opera Mini due to lack of everything\n      !isOperaMini() &&\n      // Require these APIs to feature detect a modern browser\n      hasVisibility() &&\n      hasPromises() &&\n      hasBlobSlice() &&\n      hasCreateObjectURL() &&\n      hasTiming() &&\n      // doesn't need CSSSupports but is a good way to detect Safari 9+ (we do want to support IE11 though)\n      (hasCSSSupports() || isIE11());\n\n    return function() {\n      return isSupported;\n    };\n  })();\n\n  /**\n   * Plugin internal state (over all instances)\n   */\n  var state = {\n    // active app instances, used to redraw the apps and to find the later\n    apps: []\n  };\n\n  // plugin name\n  var name = 'filepond';\n\n  /**\n   * Public Plugin methods\n   */\n  var fn = function fn() {};\n  exports.Status = {};\n  exports.FileStatus = {};\n  exports.FileOrigin = {};\n  exports.OptionTypes = {};\n  exports.create = fn;\n  exports.destroy = fn;\n  exports.parse = fn;\n  exports.find = fn;\n  exports.registerPlugin = fn;\n  exports.getOptions = fn;\n  exports.setOptions = fn;\n\n  // if not supported, no API\n  if (supported()) {\n    // start painter and fire load event\n    createPainter(\n      function() {\n        state.apps.forEach(function(app) {\n          return app._read();\n        });\n      },\n      function(ts) {\n        state.apps.forEach(function(app) {\n          return app._write(ts);\n        });\n      }\n    );\n\n    // fire loaded event so we know when FilePond is available\n    var dispatch = function dispatch() {\n      // let others know we have area ready\n      document.dispatchEvent(\n        new CustomEvent('FilePond:loaded', {\n          detail: {\n            supported: supported,\n            create: exports.create,\n            destroy: exports.destroy,\n            parse: exports.parse,\n            find: exports.find,\n            registerPlugin: exports.registerPlugin,\n            setOptions: exports.setOptions\n          }\n        })\n      );\n\n      // clean up event\n      document.removeEventListener('DOMContentLoaded', dispatch);\n    };\n\n    if (document.readyState !== 'loading') {\n      // move to back of execution queue, FilePond should have been exported by then\n      setTimeout(function() {\n        return dispatch();\n      }, 0);\n    } else {\n      document.addEventListener('DOMContentLoaded', dispatch);\n    }\n\n    // updates the OptionTypes object based on the current options\n    var updateOptionTypes = function updateOptionTypes() {\n      return forin(getOptions(), function(key, value) {\n        exports.OptionTypes[key] = value[1];\n      });\n    };\n\n    exports.Status = Object.assign({}, Status);\n    exports.FileOrigin = Object.assign({}, FileOrigin);\n    exports.FileStatus = Object.assign({}, ItemStatus);\n\n    exports.OptionTypes = {};\n    updateOptionTypes();\n\n    // create method, creates apps and adds them to the app array\n    exports.create = function create() {\n      var app = createApp$1.apply(void 0, arguments);\n      app.on('destroy', exports.destroy);\n      state.apps.push(app);\n      return createAppAPI(app);\n    };\n\n    // destroys apps and removes them from the app array\n    exports.destroy = function destroy(hook) {\n      // returns true if the app was destroyed successfully\n      var indexToRemove = state.apps.findIndex(function(app) {\n        return app.isAttachedTo(hook);\n      });\n      if (indexToRemove >= 0) {\n        // remove from apps\n        var app = state.apps.splice(indexToRemove, 1)[0];\n\n        // restore original dom element\n        app.restoreElement();\n\n        return true;\n      }\n\n      return false;\n    };\n\n    // parses the given context for plugins (does not include the context element itself)\n    exports.parse = function parse(context) {\n      // get all possible hooks\n      var matchedHooks = Array.from(context.querySelectorAll('.' + name));\n\n      // filter out already active hooks\n      var newHooks = matchedHooks.filter(function(newHook) {\n        return !state.apps.find(function(app) {\n          return app.isAttachedTo(newHook);\n        });\n      });\n\n      // create new instance for each hook\n      return newHooks.map(function(hook) {\n        return exports.create(hook);\n      });\n    };\n\n    // returns an app based on the given element hook\n    exports.find = function find(hook) {\n      var app = state.apps.find(function(app) {\n        return app.isAttachedTo(hook);\n      });\n      if (!app) {\n        return null;\n      }\n      return createAppAPI(app);\n    };\n\n    // adds a plugin extension\n    exports.registerPlugin = function registerPlugin() {\n      for (\n        var _len = arguments.length, plugins = new Array(_len), _key = 0;\n        _key < _len;\n        _key++\n      ) {\n        plugins[_key] = arguments[_key];\n      }\n\n      // register plugins\n      plugins.forEach(createAppPlugin);\n\n      // update OptionTypes, each plugin might have extended the default options\n      updateOptionTypes();\n    };\n\n    exports.getOptions = function getOptions$1() {\n      var opts = {};\n      forin(getOptions(), function(key, value) {\n        opts[key] = value[0];\n      });\n      return opts;\n    };\n\n    exports.setOptions = function setOptions$1(opts) {\n      if (isObject(opts)) {\n        // update existing plugins\n        state.apps.forEach(function(app) {\n          app.setOptions(opts);\n        });\n\n        // override defaults\n        setOptions(opts);\n      }\n\n      // return new options\n      return exports.getOptions();\n    };\n  }\n\n  exports.supported = supported;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmlsZXBvbmQvZGlzdC9maWxlcG9uZC5qcz9jMDYyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxFQUFFLEtBQTREO0FBQzlEO0FBQ0EsTUFBTSxTQUU0RDtBQUNsRSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQzs7QUFFaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix5QkFBeUI7QUFDckQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFDQUFxQyxrQkFBa0I7QUFDdkQsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQzs7QUFFcEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0JBQStCOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsK0NBQStDO0FBQy9DLCtDQUErQztBQUMvQyxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVCw2Q0FBNkM7QUFDN0M7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVCw2Q0FBNkM7QUFDN0M7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0I7QUFDeEIsd0JBQXdCLGVBQWUsc0JBQXNCO0FBQzdELHdCQUF3QixlQUFlLEtBQUssc0JBQXNCLEVBQUU7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBEQUEwRDs7QUFFMUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qzs7QUFFdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDOztBQUV2QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1Qiw0QkFBNEI7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG9EQUFvRDs7QUFFcEQ7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFO0FBQzdFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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OztBQUVYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixVQUFVO0FBQzNCLHFCQUFxQixPQUFPO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTs7QUFFeEI7QUFDQSx1Q0FBdUMsNEJBQTRCO0FBQ25FO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUEscUJBQXFCLG9CQUFvQjtBQUN6QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxxQkFBcUIsMEJBQTBCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRFQUE0RTtBQUM1RTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsdUJBQXVCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQiw2QkFBNkI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbURBQW1ELGdCQUFnQjtBQUNuRTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsbUJBQW1CO0FBQ3hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDJCQUEyQixzQkFBc0I7QUFDakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBLDJDQUEyQyxRQUFRO0FBQ25EO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDJCQUEyQix5QkFBeUI7QUFDcEQsaUNBQWlDLHFCQUFxQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIscUJBQXFCO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0MsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVzs7QUFFWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBLHlCQUF5QixtQkFBbUI7QUFDNUM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCO0FBQzNCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPOztBQUVQO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNENBQTRDLHdCQUF3QiwyQkFBMkI7QUFDL0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQix1QkFBdUI7QUFDMUM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxJQUFJLElBQUk7QUFDcEQsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdDQUF3QztBQUN4QywwQ0FBMEM7QUFDMUMsa0NBQWtDO0FBQ2xDLHdDQUF3QztBQUN4QyxvQ0FBb0M7QUFDcEMsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQSxhQUFhOztBQUViLDBDQUEwQztBQUMxQztBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCOztBQUU1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLHFCQUFxQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdDQUFnQyx5QkFBeUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNGQUFzRjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0RBQWdEO0FBQ2hEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsd0JBQXdCLHdCQUF3QjtBQUNoRCxtQkFBbUIsbUJBQW1CO0FBQ3RDLG1CQUFtQixtQkFBbUI7QUFDdEMsZUFBZSxlQUFlO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHFDQUFxQztBQUN6RSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0Esa0RBQWtELFNBQVMsYUFBYTtBQUN4RSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUE0QixzQkFBc0IsaUJBQWlCLEVBQUU7QUFDckU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLGtEQUFrRCxTQUFTLGFBQWE7QUFDeEUsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLCtCQUErQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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UDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFlBQVk7QUFDdEQsT0FBTzs7QUFFUDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0NBQXNDLFNBQVM7QUFDL0M7O0FBRUE7QUFDQTtBQUNBLHdDQUF3QyxTQUFTO0FBQ2pEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsNkNBQTZDOztBQUV4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFD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QUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5QkFBeUIsV0FBVztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVDQUF1QyxTQUFTOztBQUVoRDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLE9BQU87QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsNEJBQTRCOztBQUU1RDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsNkNBQTZDO0FBQzFEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSw2Q0FBNkM7O0FBRTFEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsS0FBSztBQUNMO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsS0FBSztBQUNMO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsS0FBSztBQUNMLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsS0FBSztBQUNMO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsK0JBQStCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsNkNBQTZDO0FBQzFEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtREFBbUQ7QUFDbkQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQyxvQ0FBb0M7QUFDcEMsa0NBQWtDO0FBQ2xDLGtDQUFrQztBQUNsQyxrQ0FBa0M7QUFDbEM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxrQ0FBa0M7QUFDbEMsNENBQTRDO0FBQzVDLGtDQUFrQztBQUNsQyx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQ0FBMEMsbUJBQW1CO0FBQzdEOztBQUVBO0FBQ0E7QUFDQSxtQ0FBbUMscUJBQXFCO0FBQ3hEOztBQUVBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7O0FBRUE7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsaUJBQWlCO0FBQzVFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLDZDQUE2Qzs7QUFFMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsYUFBYTtBQUNwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQSx1Q0FBdUM7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTyxJQUFJOztBQUVYO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHdDQUF3Qzs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQkFBMkIsSUFBSTtBQUMvQiw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBLCtCQUErQixZQUFZO0FBQzNDO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsMENBQTBDO0FBQzFDLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBLHFDQUFxQztBQUNyQyx5Q0FBeUM7QUFDekMseUNBQXlDOztBQUV6QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGdEQUFnRCxjQUFjO0FBQzlELENBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmlsZXBvbmQvZGlzdC9maWxlcG9uZC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogRmlsZVBvbmQgNC4yMy4xXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQsIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUL1xuICogUGxlYXNlIHZpc2l0IGh0dHBzOi8vcHFpbmEubmwvZmlsZXBvbmQvIGZvciBkZXRhaWxzLlxuICovXG5cbi8qIGVzbGludC1kaXNhYmxlICovXG5cbihmdW5jdGlvbihnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXG4gICAgPyBmYWN0b3J5KGV4cG9ydHMpXG4gICAgOiB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWRcbiAgICA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSlcbiAgICA6ICgoZ2xvYmFsID0gZ2xvYmFsIHx8IHNlbGYpLCBmYWN0b3J5KChnbG9iYWwuRmlsZVBvbmQgPSB7fSkpKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBpc05vZGUgPSBmdW5jdGlvbiBpc05vZGUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudDtcbiAgfTtcblxuICB2YXIgY3JlYXRlU3RvcmUgPSBmdW5jdGlvbiBjcmVhdGVTdG9yZShpbml0aWFsU3RhdGUpIHtcbiAgICB2YXIgcXVlcmllcyA9XG4gICAgICBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFtdO1xuICAgIHZhciBhY3Rpb25zID1cbiAgICAgIGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogW107XG4gICAgLy8gaW50ZXJuYWwgc3RhdGVcbiAgICB2YXIgc3RhdGUgPSBPYmplY3QuYXNzaWduKHt9LCBpbml0aWFsU3RhdGUpO1xuXG4gICAgLy8gY29udGFpbnMgYWxsIGFjdGlvbnMgZm9yIG5leHQgZnJhbWUsIGlzIGNsZWFyIHdoZW4gYWN0aW9ucyBhcmUgcmVxdWVzdGVkXG4gICAgdmFyIGFjdGlvblF1ZXVlID0gW107XG4gICAgdmFyIGRpc3BhdGNoUXVldWUgPSBbXTtcblxuICAgIC8vIHJldHVybnMgYSBkdXBsaWNhdGUgb2YgdGhlIGN1cnJlbnQgc3RhdGVcbiAgICB2YXIgZ2V0U3RhdGUgPSBmdW5jdGlvbiBnZXRTdGF0ZSgpIHtcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSk7XG4gICAgfTtcblxuICAgIC8vIHJldHVybnMgYSBkdXBsaWNhdGUgb2YgdGhlIGFjdGlvbnMgYXJyYXkgYW5kIGNsZWFycyB0aGUgYWN0aW9ucyBhcnJheVxuICAgIHZhciBwcm9jZXNzQWN0aW9uUXVldWUgPSBmdW5jdGlvbiBwcm9jZXNzQWN0aW9uUXVldWUoKSB7XG4gICAgICAvLyBjcmVhdGUgY29weSBvZiBhY3Rpb25zIHF1ZXVlXG4gICAgICB2YXIgcXVldWUgPSBbXS5jb25jYXQoYWN0aW9uUXVldWUpO1xuXG4gICAgICAvLyBjbGVhciBhY3Rpb25zIHF1ZXVlICh3ZSBkb24ndCB3YW50IG5vIGRvdWJsZSBhY3Rpb25zKVxuICAgICAgYWN0aW9uUXVldWUubGVuZ3RoID0gMDtcblxuICAgICAgcmV0dXJuIHF1ZXVlO1xuICAgIH07XG5cbiAgICAvLyBwcm9jZXNzZXMgYWN0aW9ucyB0aGF0IG1pZ2h0IGJsb2NrIHRoZSBtYWluIFVJIHRocmVhZFxuICAgIHZhciBwcm9jZXNzRGlzcGF0Y2hRdWV1ZSA9IGZ1bmN0aW9uIHByb2Nlc3NEaXNwYXRjaFF1ZXVlKCkge1xuICAgICAgLy8gY3JlYXRlIGNvcHkgb2YgYWN0aW9ucyBxdWV1ZVxuICAgICAgdmFyIHF1ZXVlID0gW10uY29uY2F0KGRpc3BhdGNoUXVldWUpO1xuXG4gICAgICAvLyBjbGVhciBhY3Rpb25zIHF1ZXVlICh3ZSBkb24ndCB3YW50IG5vIGRvdWJsZSBhY3Rpb25zKVxuICAgICAgZGlzcGF0Y2hRdWV1ZS5sZW5ndGggPSAwO1xuXG4gICAgICAvLyBub3cgZGlzcGF0Y2ggdGhlc2UgYWN0aW9uc1xuICAgICAgcXVldWUuZm9yRWFjaChmdW5jdGlvbihfcmVmKSB7XG4gICAgICAgIHZhciB0eXBlID0gX3JlZi50eXBlLFxuICAgICAgICAgIGRhdGEgPSBfcmVmLmRhdGE7XG4gICAgICAgIGRpc3BhdGNoKHR5cGUsIGRhdGEpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIGFkZHMgYSBuZXcgYWN0aW9uLCBjYWxscyBpdHMgaGFuZGxlciBhbmRcbiAgICB2YXIgZGlzcGF0Y2ggPSBmdW5jdGlvbiBkaXNwYXRjaCh0eXBlLCBkYXRhLCBpc0Jsb2NraW5nKSB7XG4gICAgICAvLyBpcyBibG9ja2luZyBhY3Rpb24gKHNob3VsZCBuZXZlciBibG9jayBpZiBkb2N1bWVudCBpcyBoaWRkZW4pXG4gICAgICBpZiAoaXNCbG9ja2luZyAmJiAhZG9jdW1lbnQuaGlkZGVuKSB7XG4gICAgICAgIGRpc3BhdGNoUXVldWUucHVzaCh7IHR5cGU6IHR5cGUsIGRhdGE6IGRhdGEgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gaWYgdGhpcyBhY3Rpb24gaGFzIGEgaGFuZGxlciwgaGFuZGxlIHRoZSBhY3Rpb25cbiAgICAgIGlmIChhY3Rpb25IYW5kbGVyc1t0eXBlXSkge1xuICAgICAgICBhY3Rpb25IYW5kbGVyc1t0eXBlXShkYXRhKTtcbiAgICAgIH1cblxuICAgICAgLy8gbm93IGFkZCBhY3Rpb25cbiAgICAgIGFjdGlvblF1ZXVlLnB1c2goe1xuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICBkYXRhOiBkYXRhXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyIHF1ZXJ5ID0gZnVuY3Rpb24gcXVlcnkoc3RyKSB7XG4gICAgICB2YXIgX3F1ZXJ5SGFuZGxlcztcbiAgICAgIGZvciAoXG4gICAgICAgIHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCxcbiAgICAgICAgICBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSxcbiAgICAgICAgICBfa2V5ID0gMTtcbiAgICAgICAgX2tleSA8IF9sZW47XG4gICAgICAgIF9rZXkrK1xuICAgICAgKSB7XG4gICAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHF1ZXJ5SGFuZGxlc1tzdHJdXG4gICAgICAgID8gKF9xdWVyeUhhbmRsZXMgPSBxdWVyeUhhbmRsZXMpW3N0cl0uYXBwbHkoX3F1ZXJ5SGFuZGxlcywgYXJncylcbiAgICAgICAgOiBudWxsO1xuICAgIH07XG5cbiAgICB2YXIgYXBpID0ge1xuICAgICAgZ2V0U3RhdGU6IGdldFN0YXRlLFxuICAgICAgcHJvY2Vzc0FjdGlvblF1ZXVlOiBwcm9jZXNzQWN0aW9uUXVldWUsXG4gICAgICBwcm9jZXNzRGlzcGF0Y2hRdWV1ZTogcHJvY2Vzc0Rpc3BhdGNoUXVldWUsXG4gICAgICBkaXNwYXRjaDogZGlzcGF0Y2gsXG4gICAgICBxdWVyeTogcXVlcnlcbiAgICB9O1xuXG4gICAgdmFyIHF1ZXJ5SGFuZGxlcyA9IHt9O1xuICAgIHF1ZXJpZXMuZm9yRWFjaChmdW5jdGlvbihxdWVyeSkge1xuICAgICAgcXVlcnlIYW5kbGVzID0gT2JqZWN0LmFzc2lnbih7fSwgcXVlcnkoc3RhdGUpLCB7fSwgcXVlcnlIYW5kbGVzKTtcbiAgICB9KTtcblxuICAgIHZhciBhY3Rpb25IYW5kbGVycyA9IHt9O1xuICAgIGFjdGlvbnMuZm9yRWFjaChmdW5jdGlvbihhY3Rpb24pIHtcbiAgICAgIGFjdGlvbkhhbmRsZXJzID0gT2JqZWN0LmFzc2lnbihcbiAgICAgICAge30sXG4gICAgICAgIGFjdGlvbihkaXNwYXRjaCwgcXVlcnksIHN0YXRlKSxcbiAgICAgICAge30sXG4gICAgICAgIGFjdGlvbkhhbmRsZXJzXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGFwaTtcbiAgfTtcblxuICB2YXIgZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShvYmosIHByb3BlcnR5LCBkZWZpbml0aW9uKSB7XG4gICAgaWYgKHR5cGVvZiBkZWZpbml0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBvYmpbcHJvcGVydHldID0gZGVmaW5pdGlvbjtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgcHJvcGVydHksIE9iamVjdC5hc3NpZ24oe30sIGRlZmluaXRpb24pKTtcbiAgfTtcblxuICB2YXIgZm9yaW4gPSBmdW5jdGlvbiBmb3JpbihvYmosIGNiKSB7XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgaWYgKCFvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgY2Ioa2V5LCBvYmpba2V5XSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBjcmVhdGVPYmplY3QgPSBmdW5jdGlvbiBjcmVhdGVPYmplY3QoZGVmaW5pdGlvbikge1xuICAgIHZhciBvYmogPSB7fTtcbiAgICBmb3JpbihkZWZpbml0aW9uLCBmdW5jdGlvbihwcm9wZXJ0eSkge1xuICAgICAgZGVmaW5lUHJvcGVydHkob2JqLCBwcm9wZXJ0eSwgZGVmaW5pdGlvbltwcm9wZXJ0eV0pO1xuICAgIH0pO1xuICAgIHJldHVybiBvYmo7XG4gIH07XG5cbiAgdmFyIGF0dHIgPSBmdW5jdGlvbiBhdHRyKG5vZGUsIG5hbWUpIHtcbiAgICB2YXIgdmFsdWUgPVxuICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBudWxsO1xuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG5vZGUuZ2V0QXR0cmlidXRlKG5hbWUpIHx8IG5vZGUuaGFzQXR0cmlidXRlKG5hbWUpO1xuICAgIH1cbiAgICBub2RlLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG4gIH07XG5cbiAgdmFyIG5zID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcbiAgdmFyIHN2Z0VsZW1lbnRzID0gWydzdmcnLCAncGF0aCddOyAvLyBvbmx5IHN2ZyBlbGVtZW50cyB1c2VkXG5cbiAgdmFyIGlzU1ZHRWxlbWVudCA9IGZ1bmN0aW9uIGlzU1ZHRWxlbWVudCh0YWcpIHtcbiAgICByZXR1cm4gc3ZnRWxlbWVudHMuaW5jbHVkZXModGFnKTtcbiAgfTtcblxuICB2YXIgY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQodGFnLCBjbGFzc05hbWUpIHtcbiAgICB2YXIgYXR0cmlidXRlcyA9XG4gICAgICBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIGlmICh0eXBlb2YgY2xhc3NOYW1lID09PSAnb2JqZWN0Jykge1xuICAgICAgYXR0cmlidXRlcyA9IGNsYXNzTmFtZTtcbiAgICAgIGNsYXNzTmFtZSA9IG51bGw7XG4gICAgfVxuICAgIHZhciBlbGVtZW50ID0gaXNTVkdFbGVtZW50KHRhZylcbiAgICAgID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5zLCB0YWcpXG4gICAgICA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICBpZiAoY2xhc3NOYW1lKSB7XG4gICAgICBpZiAoaXNTVkdFbGVtZW50KHRhZykpIHtcbiAgICAgICAgYXR0cihlbGVtZW50LCAnY2xhc3MnLCBjbGFzc05hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbWVudC5jbGFzc05hbWUgPSBjbGFzc05hbWU7XG4gICAgICB9XG4gICAgfVxuICAgIGZvcmluKGF0dHJpYnV0ZXMsIGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgICBhdHRyKGVsZW1lbnQsIG5hbWUsIHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfTtcblxuICB2YXIgYXBwZW5kQ2hpbGQgPSBmdW5jdGlvbiBhcHBlbmRDaGlsZChwYXJlbnQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oY2hpbGQsIGluZGV4KSB7XG4gICAgICBpZiAodHlwZW9mIGluZGV4ICE9PSAndW5kZWZpbmVkJyAmJiBwYXJlbnQuY2hpbGRyZW5baW5kZXhdKSB7XG4gICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoY2hpbGQsIHBhcmVudC5jaGlsZHJlbltpbmRleF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyZW50LmFwcGVuZENoaWxkKGNoaWxkKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIHZhciBhcHBlbmRDaGlsZFZpZXcgPSBmdW5jdGlvbiBhcHBlbmRDaGlsZFZpZXcocGFyZW50LCBjaGlsZFZpZXdzKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHZpZXcsIGluZGV4KSB7XG4gICAgICBpZiAodHlwZW9mIGluZGV4ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjaGlsZFZpZXdzLnNwbGljZShpbmRleCwgMCwgdmlldyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaGlsZFZpZXdzLnB1c2godmlldyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB2aWV3O1xuICAgIH07XG4gIH07XG5cbiAgdmFyIHJlbW92ZUNoaWxkVmlldyA9IGZ1bmN0aW9uIHJlbW92ZUNoaWxkVmlldyhwYXJlbnQsIGNoaWxkVmlld3MpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odmlldykge1xuICAgICAgLy8gcmVtb3ZlIGZyb20gY2hpbGQgdmlld3NcbiAgICAgIGNoaWxkVmlld3Muc3BsaWNlKGNoaWxkVmlld3MuaW5kZXhPZih2aWV3KSwgMSk7XG5cbiAgICAgIC8vIHJlbW92ZSB0aGUgZWxlbWVudFxuICAgICAgaWYgKHZpZXcuZWxlbWVudC5wYXJlbnROb2RlKSB7XG4gICAgICAgIHBhcmVudC5yZW1vdmVDaGlsZCh2aWV3LmVsZW1lbnQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmlldztcbiAgICB9O1xuICB9O1xuXG4gIHZhciBJU19CUk9XU0VSID0gKGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAoXG4gICAgICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50ICE9PSAndW5kZWZpbmVkJ1xuICAgICk7XG4gIH0pKCk7XG4gIHZhciBpc0Jyb3dzZXIgPSBmdW5jdGlvbiBpc0Jyb3dzZXIoKSB7XG4gICAgcmV0dXJuIElTX0JST1dTRVI7XG4gIH07XG5cbiAgdmFyIHRlc3RFbGVtZW50ID0gaXNCcm93c2VyKCkgPyBjcmVhdGVFbGVtZW50KCdzdmcnKSA6IHt9O1xuICB2YXIgZ2V0Q2hpbGRDb3VudCA9XG4gICAgJ2NoaWxkcmVuJyBpbiB0ZXN0RWxlbWVudFxuICAgICAgPyBmdW5jdGlvbihlbCkge1xuICAgICAgICAgIHJldHVybiBlbC5jaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIDogZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgICByZXR1cm4gZWwuY2hpbGROb2Rlcy5sZW5ndGg7XG4gICAgICAgIH07XG5cbiAgdmFyIGdldFZpZXdSZWN0ID0gZnVuY3Rpb24gZ2V0Vmlld1JlY3QoXG4gICAgZWxlbWVudFJlY3QsXG4gICAgY2hpbGRWaWV3cyxcbiAgICBvZmZzZXQsXG4gICAgc2NhbGVcbiAgKSB7XG4gICAgdmFyIGxlZnQgPSBvZmZzZXRbMF0gfHwgZWxlbWVudFJlY3QubGVmdDtcbiAgICB2YXIgdG9wID0gb2Zmc2V0WzFdIHx8IGVsZW1lbnRSZWN0LnRvcDtcbiAgICB2YXIgcmlnaHQgPSBsZWZ0ICsgZWxlbWVudFJlY3Qud2lkdGg7XG4gICAgdmFyIGJvdHRvbSA9IHRvcCArIGVsZW1lbnRSZWN0LmhlaWdodCAqIChzY2FsZVsxXSB8fCAxKTtcblxuICAgIHZhciByZWN0ID0ge1xuICAgICAgLy8gdGhlIHJlY3RhbmdsZSBvZiB0aGUgZWxlbWVudCBpdHNlbGZcbiAgICAgIGVsZW1lbnQ6IE9iamVjdC5hc3NpZ24oe30sIGVsZW1lbnRSZWN0KSxcblxuICAgICAgLy8gdGhlIHJlY3RhbmdsZSBvZiB0aGUgZWxlbWVudCBleHBhbmRlZCB0byBjb250YWluIGl0cyBjaGlsZHJlbiwgZG9lcyBub3QgaW5jbHVkZSBhbnkgbWFyZ2luc1xuICAgICAgaW5uZXI6IHtcbiAgICAgICAgbGVmdDogZWxlbWVudFJlY3QubGVmdCxcbiAgICAgICAgdG9wOiBlbGVtZW50UmVjdC50b3AsXG4gICAgICAgIHJpZ2h0OiBlbGVtZW50UmVjdC5yaWdodCxcbiAgICAgICAgYm90dG9tOiBlbGVtZW50UmVjdC5ib3R0b21cbiAgICAgIH0sXG5cbiAgICAgIC8vIHRoZSByZWN0YW5nbGUgb2YgdGhlIGVsZW1lbnQgZXhwYW5kZWQgdG8gY29udGFpbiBpdHMgY2hpbGRyZW4gaW5jbHVkaW5nIG93biBtYXJnaW4gYW5kIGNoaWxkIG1hcmdpbnNcbiAgICAgIC8vIG1hcmdpbnMgd2lsbCBiZSBhZGRlZCBhZnRlciB3ZSd2ZSByZWNhbGN1bGF0ZWQgdGhlIHNpemVcbiAgICAgIG91dGVyOiB7XG4gICAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICAgIHRvcDogdG9wLFxuICAgICAgICByaWdodDogcmlnaHQsXG4gICAgICAgIGJvdHRvbTogYm90dG9tXG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIGV4cGFuZCByZWN0IHRvIGZpdCBhbGwgY2hpbGQgcmVjdGFuZ2xlc1xuICAgIGNoaWxkVmlld3NcbiAgICAgIC5maWx0ZXIoZnVuY3Rpb24oY2hpbGRWaWV3KSB7XG4gICAgICAgIHJldHVybiAhY2hpbGRWaWV3LmlzUmVjdElnbm9yZWQoKTtcbiAgICAgIH0pXG4gICAgICAubWFwKGZ1bmN0aW9uKGNoaWxkVmlldykge1xuICAgICAgICByZXR1cm4gY2hpbGRWaWV3LnJlY3Q7XG4gICAgICB9KVxuICAgICAgLmZvckVhY2goZnVuY3Rpb24oY2hpbGRWaWV3UmVjdCkge1xuICAgICAgICBleHBhbmRSZWN0KHJlY3QuaW5uZXIsIE9iamVjdC5hc3NpZ24oe30sIGNoaWxkVmlld1JlY3QuaW5uZXIpKTtcbiAgICAgICAgZXhwYW5kUmVjdChyZWN0Lm91dGVyLCBPYmplY3QuYXNzaWduKHt9LCBjaGlsZFZpZXdSZWN0Lm91dGVyKSk7XG4gICAgICB9KTtcblxuICAgIC8vIGNhbGN1bGF0ZSBpbm5lciB3aWR0aCBhbmQgaGVpZ2h0XG4gICAgY2FsY3VsYXRlUmVjdFNpemUocmVjdC5pbm5lcik7XG5cbiAgICAvLyBhcHBlbmQgYWRkaXRpb25hbCBtYXJnaW4gKHRvcCBhbmQgbGVmdCBtYXJnaW5zIGFyZSBpbmNsdWRlZCBpbiB0b3AgYW5kIGxlZnQgYXV0b21hdGljYWxseSlcbiAgICByZWN0Lm91dGVyLmJvdHRvbSArPSByZWN0LmVsZW1lbnQubWFyZ2luQm90dG9tO1xuICAgIHJlY3Qub3V0ZXIucmlnaHQgKz0gcmVjdC5lbGVtZW50Lm1hcmdpblJpZ2h0O1xuXG4gICAgLy8gY2FsY3VsYXRlIG91dGVyIHdpZHRoIGFuZCBoZWlnaHRcbiAgICBjYWxjdWxhdGVSZWN0U2l6ZShyZWN0Lm91dGVyKTtcblxuICAgIHJldHVybiByZWN0O1xuICB9O1xuXG4gIHZhciBleHBhbmRSZWN0ID0gZnVuY3Rpb24gZXhwYW5kUmVjdChwYXJlbnQsIGNoaWxkKSB7XG4gICAgLy8gYWRqdXN0IGZvciBwYXJlbnQgb2Zmc2V0XG4gICAgY2hpbGQudG9wICs9IHBhcmVudC50b3A7XG4gICAgY2hpbGQucmlnaHQgKz0gcGFyZW50LmxlZnQ7XG4gICAgY2hpbGQuYm90dG9tICs9IHBhcmVudC50b3A7XG4gICAgY2hpbGQubGVmdCArPSBwYXJlbnQubGVmdDtcblxuICAgIGlmIChjaGlsZC5ib3R0b20gPiBwYXJlbnQuYm90dG9tKSB7XG4gICAgICBwYXJlbnQuYm90dG9tID0gY2hpbGQuYm90dG9tO1xuICAgIH1cblxuICAgIGlmIChjaGlsZC5yaWdodCA+IHBhcmVudC5yaWdodCkge1xuICAgICAgcGFyZW50LnJpZ2h0ID0gY2hpbGQucmlnaHQ7XG4gICAgfVxuICB9O1xuXG4gIHZhciBjYWxjdWxhdGVSZWN0U2l6ZSA9IGZ1bmN0aW9uIGNhbGN1bGF0ZVJlY3RTaXplKHJlY3QpIHtcbiAgICByZWN0LndpZHRoID0gcmVjdC5yaWdodCAtIHJlY3QubGVmdDtcbiAgICByZWN0LmhlaWdodCA9IHJlY3QuYm90dG9tIC0gcmVjdC50b3A7XG4gIH07XG5cbiAgdmFyIGlzTnVtYmVyID0gZnVuY3Rpb24gaXNOdW1iZXIodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJztcbiAgfTtcblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyBpZiBwb3NpdGlvbiBpcyBhdCBkZXN0aW5hdGlvblxuICAgKiBAcGFyYW0gcG9zaXRpb25cbiAgICogQHBhcmFtIGRlc3RpbmF0aW9uXG4gICAqIEBwYXJhbSB2ZWxvY2l0eVxuICAgKiBAcGFyYW0gZXJyb3JNYXJnaW5cbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICB2YXIgdGhlcmVZZXQgPSBmdW5jdGlvbiB0aGVyZVlldChwb3NpdGlvbiwgZGVzdGluYXRpb24sIHZlbG9jaXR5KSB7XG4gICAgdmFyIGVycm9yTWFyZ2luID1cbiAgICAgIGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogMC4wMDE7XG4gICAgcmV0dXJuIChcbiAgICAgIE1hdGguYWJzKHBvc2l0aW9uIC0gZGVzdGluYXRpb24pIDwgZXJyb3JNYXJnaW4gJiZcbiAgICAgIE1hdGguYWJzKHZlbG9jaXR5KSA8IGVycm9yTWFyZ2luXG4gICAgKTtcbiAgfTtcblxuICAvKipcbiAgICogU3ByaW5nIGFuaW1hdGlvblxuICAgKi9cbiAgdmFyIHNwcmluZyA9XG4gICAgLy8gZGVmYXVsdCBvcHRpb25zXG4gICAgZnVuY3Rpb24gc3ByaW5nKCkgLy8gbWV0aG9kIGRlZmluaXRpb25cbiAgICB7XG4gICAgICB2YXIgX3JlZiA9XG4gICAgICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gYXJndW1lbnRzWzBdXG4gICAgICAgICAgICA6IHt9LFxuICAgICAgICBfcmVmJHN0aWZmbmVzcyA9IF9yZWYuc3RpZmZuZXNzLFxuICAgICAgICBzdGlmZm5lc3MgPSBfcmVmJHN0aWZmbmVzcyA9PT0gdm9pZCAwID8gMC41IDogX3JlZiRzdGlmZm5lc3MsXG4gICAgICAgIF9yZWYkZGFtcGluZyA9IF9yZWYuZGFtcGluZyxcbiAgICAgICAgZGFtcGluZyA9IF9yZWYkZGFtcGluZyA9PT0gdm9pZCAwID8gMC43NSA6IF9yZWYkZGFtcGluZyxcbiAgICAgICAgX3JlZiRtYXNzID0gX3JlZi5tYXNzLFxuICAgICAgICBtYXNzID0gX3JlZiRtYXNzID09PSB2b2lkIDAgPyAxMCA6IF9yZWYkbWFzcztcbiAgICAgIHZhciB0YXJnZXQgPSBudWxsO1xuICAgICAgdmFyIHBvc2l0aW9uID0gbnVsbDtcbiAgICAgIHZhciB2ZWxvY2l0eSA9IDA7XG4gICAgICB2YXIgcmVzdGluZyA9IGZhbHNlO1xuXG4gICAgICAvLyB1cGRhdGVzIHNwcmluZyBzdGF0ZVxuICAgICAgdmFyIGludGVycG9sYXRlID0gZnVuY3Rpb24gaW50ZXJwb2xhdGUodHMsIHNraXBUb0VuZFN0YXRlKSB7XG4gICAgICAgIC8vIGluIHJlc3QsIGRvbid0IGFuaW1hdGVcbiAgICAgICAgaWYgKHJlc3RpbmcpIHJldHVybjtcblxuICAgICAgICAvLyBuZWVkIGF0IGxlYXN0IGEgdGFyZ2V0IG9yIHBvc2l0aW9uIHRvIGRvIHNwcmluZ3kgdGhpbmdzXG4gICAgICAgIGlmICghKGlzTnVtYmVyKHRhcmdldCkgJiYgaXNOdW1iZXIocG9zaXRpb24pKSkge1xuICAgICAgICAgIHJlc3RpbmcgPSB0cnVlO1xuICAgICAgICAgIHZlbG9jaXR5ID0gMDtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjYWxjdWxhdGUgc3ByaW5nIGZvcmNlXG4gICAgICAgIHZhciBmID0gLShwb3NpdGlvbiAtIHRhcmdldCkgKiBzdGlmZm5lc3M7XG5cbiAgICAgICAgLy8gdXBkYXRlIHZlbG9jaXR5IGJ5IGFkZGluZyBmb3JjZSBiYXNlZCBvbiBtYXNzXG4gICAgICAgIHZlbG9jaXR5ICs9IGYgLyBtYXNzO1xuXG4gICAgICAgIC8vIHVwZGF0ZSBwb3NpdGlvbiBieSBhZGRpbmcgdmVsb2NpdHlcbiAgICAgICAgcG9zaXRpb24gKz0gdmVsb2NpdHk7XG5cbiAgICAgICAgLy8gc2xvdyBkb3duIGJhc2VkIG9uIGFtb3VudCBvZiBkYW1waW5nXG4gICAgICAgIHZlbG9jaXR5ICo9IGRhbXBpbmc7XG5cbiAgICAgICAgLy8gd2UndmUgYXJyaXZlZCBpZiB3ZSdyZSBuZWFyIHRhcmdldCBhbmQgb3VyIHZlbG9jaXR5IGlzIG5lYXIgemVyb1xuICAgICAgICBpZiAodGhlcmVZZXQocG9zaXRpb24sIHRhcmdldCwgdmVsb2NpdHkpIHx8IHNraXBUb0VuZFN0YXRlKSB7XG4gICAgICAgICAgcG9zaXRpb24gPSB0YXJnZXQ7XG4gICAgICAgICAgdmVsb2NpdHkgPSAwO1xuICAgICAgICAgIHJlc3RpbmcgPSB0cnVlO1xuXG4gICAgICAgICAgLy8gd2UgZG9uZVxuICAgICAgICAgIGFwaS5vbnVwZGF0ZShwb3NpdGlvbik7XG4gICAgICAgICAgYXBpLm9uY29tcGxldGUocG9zaXRpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHByb2dyZXNzIHVwZGF0ZVxuICAgICAgICAgIGFwaS5vbnVwZGF0ZShwb3NpdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogU2V0IG5ldyB0YXJnZXQgdmFsdWVcbiAgICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAgICovXG4gICAgICB2YXIgc2V0VGFyZ2V0ID0gZnVuY3Rpb24gc2V0VGFyZ2V0KHZhbHVlKSB7XG4gICAgICAgIC8vIGlmIGN1cnJlbnRseSBoYXMgbm8gcG9zaXRpb24sIHNldCB0YXJnZXQgYW5kIHBvc2l0aW9uIHRvIHRoaXMgdmFsdWVcbiAgICAgICAgaWYgKGlzTnVtYmVyKHZhbHVlKSAmJiAhaXNOdW1iZXIocG9zaXRpb24pKSB7XG4gICAgICAgICAgcG9zaXRpb24gPSB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG5leHQgdGFyZ2V0IHZhbHVlIHdpbGwgbm90IGJlIGFuaW1hdGVkIHRvXG4gICAgICAgIGlmICh0YXJnZXQgPT09IG51bGwpIHtcbiAgICAgICAgICB0YXJnZXQgPSB2YWx1ZTtcbiAgICAgICAgICBwb3NpdGlvbiA9IHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbGV0IHN0YXJ0IG1vdmluZyB0byB0YXJnZXRcbiAgICAgICAgdGFyZ2V0ID0gdmFsdWU7XG5cbiAgICAgICAgLy8gYWxyZWFkeSBhdCB0YXJnZXRcbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSB0YXJnZXQgfHwgdHlwZW9mIHRhcmdldCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAvLyBub3cgcmVzdGluZyBhcyB0YXJnZXQgaXMgY3VycmVudCBwb3NpdGlvbiwgc3RvcCBtb3ZpbmdcbiAgICAgICAgICByZXN0aW5nID0gdHJ1ZTtcbiAgICAgICAgICB2ZWxvY2l0eSA9IDA7XG5cbiAgICAgICAgICAvLyBkb25lIVxuICAgICAgICAgIGFwaS5vbnVwZGF0ZShwb3NpdGlvbik7XG4gICAgICAgICAgYXBpLm9uY29tcGxldGUocG9zaXRpb24pO1xuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdGluZyA9IGZhbHNlO1xuICAgICAgfTtcblxuICAgICAgLy8gbmVlZCAnYXBpJyB0byBjYWxsIG9udXBkYXRlIGNhbGxiYWNrXG4gICAgICB2YXIgYXBpID0gY3JlYXRlT2JqZWN0KHtcbiAgICAgICAgaW50ZXJwb2xhdGU6IGludGVycG9sYXRlLFxuICAgICAgICB0YXJnZXQ6IHtcbiAgICAgICAgICBzZXQ6IHNldFRhcmdldCxcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHJlc3Rpbmc6IHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN0aW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBvbnVwZGF0ZTogZnVuY3Rpb24gb251cGRhdGUodmFsdWUpIHt9LFxuICAgICAgICBvbmNvbXBsZXRlOiBmdW5jdGlvbiBvbmNvbXBsZXRlKHZhbHVlKSB7fVxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBhcGk7XG4gICAgfTtcblxuICB2YXIgZWFzZUxpbmVhciA9IGZ1bmN0aW9uIGVhc2VMaW5lYXIodCkge1xuICAgIHJldHVybiB0O1xuICB9O1xuICB2YXIgZWFzZUluT3V0UXVhZCA9IGZ1bmN0aW9uIGVhc2VJbk91dFF1YWQodCkge1xuICAgIHJldHVybiB0IDwgMC41ID8gMiAqIHQgKiB0IDogLTEgKyAoNCAtIDIgKiB0KSAqIHQ7XG4gIH07XG5cbiAgdmFyIHR3ZWVuID1cbiAgICAvLyBkZWZhdWx0IHZhbHVlc1xuICAgIGZ1bmN0aW9uIHR3ZWVuKCkgLy8gbWV0aG9kIGRlZmluaXRpb25cbiAgICB7XG4gICAgICB2YXIgX3JlZiA9XG4gICAgICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gYXJndW1lbnRzWzBdXG4gICAgICAgICAgICA6IHt9LFxuICAgICAgICBfcmVmJGR1cmF0aW9uID0gX3JlZi5kdXJhdGlvbixcbiAgICAgICAgZHVyYXRpb24gPSBfcmVmJGR1cmF0aW9uID09PSB2b2lkIDAgPyA1MDAgOiBfcmVmJGR1cmF0aW9uLFxuICAgICAgICBfcmVmJGVhc2luZyA9IF9yZWYuZWFzaW5nLFxuICAgICAgICBlYXNpbmcgPSBfcmVmJGVhc2luZyA9PT0gdm9pZCAwID8gZWFzZUluT3V0UXVhZCA6IF9yZWYkZWFzaW5nLFxuICAgICAgICBfcmVmJGRlbGF5ID0gX3JlZi5kZWxheSxcbiAgICAgICAgZGVsYXkgPSBfcmVmJGRlbGF5ID09PSB2b2lkIDAgPyAwIDogX3JlZiRkZWxheTtcbiAgICAgIHZhciBzdGFydCA9IG51bGw7XG4gICAgICB2YXIgdDtcbiAgICAgIHZhciBwO1xuICAgICAgdmFyIHJlc3RpbmcgPSB0cnVlO1xuICAgICAgdmFyIHJldmVyc2UgPSBmYWxzZTtcbiAgICAgIHZhciB0YXJnZXQgPSBudWxsO1xuXG4gICAgICB2YXIgaW50ZXJwb2xhdGUgPSBmdW5jdGlvbiBpbnRlcnBvbGF0ZSh0cywgc2tpcFRvRW5kU3RhdGUpIHtcbiAgICAgICAgaWYgKHJlc3RpbmcgfHwgdGFyZ2V0ID09PSBudWxsKSByZXR1cm47XG5cbiAgICAgICAgaWYgKHN0YXJ0ID09PSBudWxsKSB7XG4gICAgICAgICAgc3RhcnQgPSB0cztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0cyAtIHN0YXJ0IDwgZGVsYXkpIHJldHVybjtcblxuICAgICAgICB0ID0gdHMgLSBzdGFydCAtIGRlbGF5O1xuXG4gICAgICAgIGlmICh0ID49IGR1cmF0aW9uIHx8IHNraXBUb0VuZFN0YXRlKSB7XG4gICAgICAgICAgdCA9IDE7XG4gICAgICAgICAgcCA9IHJldmVyc2UgPyAwIDogMTtcbiAgICAgICAgICBhcGkub251cGRhdGUocCAqIHRhcmdldCk7XG4gICAgICAgICAgYXBpLm9uY29tcGxldGUocCAqIHRhcmdldCk7XG4gICAgICAgICAgcmVzdGluZyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcCA9IHQgLyBkdXJhdGlvbjtcbiAgICAgICAgICBhcGkub251cGRhdGUoKHQgPj0gMCA/IGVhc2luZyhyZXZlcnNlID8gMSAtIHAgOiBwKSA6IDApICogdGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLy8gbmVlZCAnYXBpJyB0byBjYWxsIG9udXBkYXRlIGNhbGxiYWNrXG4gICAgICB2YXIgYXBpID0gY3JlYXRlT2JqZWN0KHtcbiAgICAgICAgaW50ZXJwb2xhdGU6IGludGVycG9sYXRlLFxuICAgICAgICB0YXJnZXQ6IHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiByZXZlcnNlID8gMCA6IHRhcmdldDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgICAgICAvLyBpcyBpbml0aWFsIHZhbHVlXG4gICAgICAgICAgICBpZiAodGFyZ2V0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIHRhcmdldCA9IHZhbHVlO1xuICAgICAgICAgICAgICBhcGkub251cGRhdGUodmFsdWUpO1xuICAgICAgICAgICAgICBhcGkub25jb21wbGV0ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gd2FudCB0byB0d2VlbiB0byBhIHNtYWxsZXIgdmFsdWUgYW5kIGhhdmUgYSBjdXJyZW50IHZhbHVlXG4gICAgICAgICAgICBpZiAodmFsdWUgPCB0YXJnZXQpIHtcbiAgICAgICAgICAgICAgdGFyZ2V0ID0gMTtcbiAgICAgICAgICAgICAgcmV2ZXJzZSA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBub3QgdHdlZW5pbmcgdG8gYSBzbWFsbGVyIHZhbHVlXG4gICAgICAgICAgICAgIHJldmVyc2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgdGFyZ2V0ID0gdmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGxldCdzIGdvIVxuICAgICAgICAgICAgcmVzdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgc3RhcnQgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICByZXN0aW5nOiB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdGluZztcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgb251cGRhdGU6IGZ1bmN0aW9uIG9udXBkYXRlKHZhbHVlKSB7fSxcbiAgICAgICAgb25jb21wbGV0ZTogZnVuY3Rpb24gb25jb21wbGV0ZSh2YWx1ZSkge31cbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gYXBpO1xuICAgIH07XG5cbiAgdmFyIGFuaW1hdG9yID0ge1xuICAgIHNwcmluZzogc3ByaW5nLFxuICAgIHR3ZWVuOiB0d2VlblxuICB9O1xuXG4gIC8qXG4gICAgICAgICAgICAgICAgICAgICAgIHsgdHlwZTogJ3NwcmluZycsIHN0aWZmbmVzczogLjUsIGRhbXBpbmc6IC43NSwgbWFzczogMTAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgeyB0cmFuc2xhdGlvbjogeyB0eXBlOiAnc3ByaW5nJywgLi4uIH0sIC4uLiB9XG4gICAgICAgICAgICAgICAgICAgICAgIHsgdHJhbnNsYXRpb246IHsgeDogeyB0eXBlOiAnc3ByaW5nJywgLi4uIH0gfSB9XG4gICAgICAgICAgICAgICAgICAgICAgKi9cbiAgdmFyIGNyZWF0ZUFuaW1hdG9yID0gZnVuY3Rpb24gY3JlYXRlQW5pbWF0b3IoZGVmaW5pdGlvbiwgY2F0ZWdvcnksIHByb3BlcnR5KSB7XG4gICAgLy8gZGVmYXVsdCBpcyBzaW5nbGUgZGVmaW5pdGlvblxuICAgIC8vIHdlIGNoZWNrIGlmIHRyYW5zZm9ybSBpcyBzZXQsIGlmIHNvLCB3ZSBjaGVjayBpZiBwcm9wZXJ0eSBpcyBzZXRcbiAgICB2YXIgZGVmID1cbiAgICAgIGRlZmluaXRpb25bY2F0ZWdvcnldICYmIHR5cGVvZiBkZWZpbml0aW9uW2NhdGVnb3J5XVtwcm9wZXJ0eV0gPT09ICdvYmplY3QnXG4gICAgICAgID8gZGVmaW5pdGlvbltjYXRlZ29yeV1bcHJvcGVydHldXG4gICAgICAgIDogZGVmaW5pdGlvbltjYXRlZ29yeV0gfHwgZGVmaW5pdGlvbjtcblxuICAgIHZhciB0eXBlID0gdHlwZW9mIGRlZiA9PT0gJ3N0cmluZycgPyBkZWYgOiBkZWYudHlwZTtcbiAgICB2YXIgcHJvcHMgPSB0eXBlb2YgZGVmID09PSAnb2JqZWN0JyA/IE9iamVjdC5hc3NpZ24oe30sIGRlZikgOiB7fTtcblxuICAgIHJldHVybiBhbmltYXRvclt0eXBlXSA/IGFuaW1hdG9yW3R5cGVdKHByb3BzKSA6IG51bGw7XG4gIH07XG5cbiAgdmFyIGFkZEdldFNldCA9IGZ1bmN0aW9uIGFkZEdldFNldChrZXlzLCBvYmosIHByb3BzKSB7XG4gICAgdmFyIG92ZXJ3cml0ZSA9XG4gICAgICBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IGZhbHNlO1xuICAgIG9iaiA9IEFycmF5LmlzQXJyYXkob2JqKSA/IG9iaiA6IFtvYmpdO1xuICAgIG9iai5mb3JFYWNoKGZ1bmN0aW9uKG8pIHtcbiAgICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgdmFyIG5hbWUgPSBrZXk7XG4gICAgICAgIHZhciBnZXR0ZXIgPSBmdW5jdGlvbiBnZXR0ZXIoKSB7XG4gICAgICAgICAgcmV0dXJuIHByb3BzW2tleV07XG4gICAgICAgIH07XG4gICAgICAgIHZhciBzZXR0ZXIgPSBmdW5jdGlvbiBzZXR0ZXIodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gKHByb3BzW2tleV0gPSB2YWx1ZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgbmFtZSA9IGtleS5rZXk7XG4gICAgICAgICAgZ2V0dGVyID0ga2V5LmdldHRlciB8fCBnZXR0ZXI7XG4gICAgICAgICAgc2V0dGVyID0ga2V5LnNldHRlciB8fCBzZXR0ZXI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob1tuYW1lXSAmJiAhb3ZlcndyaXRlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgb1tuYW1lXSA9IHtcbiAgICAgICAgICBnZXQ6IGdldHRlcixcbiAgICAgICAgICBzZXQ6IHNldHRlclxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gYWRkIHRvIHN0YXRlLFxuICAvLyBhZGQgZ2V0dGVycyBhbmQgc2V0dGVycyB0byBpbnRlcm5hbCBhbmQgZXh0ZXJuYWwgYXBpIChpZiBub3Qgc2V0KVxuICAvLyBzZXR1cCBhbmltYXRvcnNcblxuICB2YXIgYW5pbWF0aW9ucyA9IGZ1bmN0aW9uIGFuaW1hdGlvbnMoX3JlZikge1xuICAgIHZhciBtaXhpbkNvbmZpZyA9IF9yZWYubWl4aW5Db25maWcsXG4gICAgICB2aWV3UHJvcHMgPSBfcmVmLnZpZXdQcm9wcyxcbiAgICAgIHZpZXdJbnRlcm5hbEFQSSA9IF9yZWYudmlld0ludGVybmFsQVBJLFxuICAgICAgdmlld0V4dGVybmFsQVBJID0gX3JlZi52aWV3RXh0ZXJuYWxBUEk7XG4gICAgLy8gaW5pdGlhbCBwcm9wZXJ0aWVzXG4gICAgdmFyIGluaXRpYWxQcm9wcyA9IE9iamVjdC5hc3NpZ24oe30sIHZpZXdQcm9wcyk7XG5cbiAgICAvLyBsaXN0IG9mIGFsbCBhY3RpdmUgYW5pbWF0aW9uc1xuICAgIHZhciBhbmltYXRpb25zID0gW107XG5cbiAgICAvLyBzZXR1cCBhbmltYXRvcnNcbiAgICBmb3JpbihtaXhpbkNvbmZpZywgZnVuY3Rpb24ocHJvcGVydHksIGFuaW1hdGlvbikge1xuICAgICAgdmFyIGFuaW1hdG9yID0gY3JlYXRlQW5pbWF0b3IoYW5pbWF0aW9uKTtcbiAgICAgIGlmICghYW5pbWF0b3IpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyB3aGVuIHRoZSBhbmltYXRvciB1cGRhdGVzLCB1cGRhdGUgdGhlIHZpZXcgc3RhdGUgdmFsdWVcbiAgICAgIGFuaW1hdG9yLm9udXBkYXRlID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdmlld1Byb3BzW3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgICAgfTtcblxuICAgICAgLy8gc2V0IGFuaW1hdG9yIHRhcmdldFxuICAgICAgYW5pbWF0b3IudGFyZ2V0ID0gaW5pdGlhbFByb3BzW3Byb3BlcnR5XTtcblxuICAgICAgLy8gd2hlbiB2YWx1ZSBpcyBzZXQsIHNldCB0aGUgYW5pbWF0b3IgdGFyZ2V0IHZhbHVlXG4gICAgICB2YXIgcHJvcCA9IHtcbiAgICAgICAga2V5OiBwcm9wZXJ0eSxcbiAgICAgICAgc2V0dGVyOiBmdW5jdGlvbiBzZXR0ZXIodmFsdWUpIHtcbiAgICAgICAgICAvLyBpZiBhbHJlYWR5IGF0IHRhcmdldCwgd2UgZG9uZSFcbiAgICAgICAgICBpZiAoYW5pbWF0b3IudGFyZ2V0ID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGFuaW1hdG9yLnRhcmdldCA9IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBnZXR0ZXI6IGZ1bmN0aW9uIGdldHRlcigpIHtcbiAgICAgICAgICByZXR1cm4gdmlld1Byb3BzW3Byb3BlcnR5XTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLy8gYWRkIGdldHRlcnMgYW5kIHNldHRlcnNcbiAgICAgIGFkZEdldFNldChbcHJvcF0sIFt2aWV3SW50ZXJuYWxBUEksIHZpZXdFeHRlcm5hbEFQSV0sIHZpZXdQcm9wcywgdHJ1ZSk7XG5cbiAgICAgIC8vIGFkZCBpdCB0byB0aGUgbGlzdCBmb3IgZWFzeSB1cGRhdGluZyBmcm9tIHRoZSBfd3JpdGUgbWV0aG9kXG4gICAgICBhbmltYXRpb25zLnB1c2goYW5pbWF0b3IpO1xuICAgIH0pO1xuXG4gICAgLy8gZXhwb3NlIGludGVybmFsIHdyaXRlIGFwaVxuICAgIHJldHVybiB7XG4gICAgICB3cml0ZTogZnVuY3Rpb24gd3JpdGUodHMpIHtcbiAgICAgICAgdmFyIHNraXBUb0VuZFN0YXRlID0gZG9jdW1lbnQuaGlkZGVuO1xuICAgICAgICB2YXIgcmVzdGluZyA9IHRydWU7XG4gICAgICAgIGFuaW1hdGlvbnMuZm9yRWFjaChmdW5jdGlvbihhbmltYXRpb24pIHtcbiAgICAgICAgICBpZiAoIWFuaW1hdGlvbi5yZXN0aW5nKSByZXN0aW5nID0gZmFsc2U7XG4gICAgICAgICAgYW5pbWF0aW9uLmludGVycG9sYXRlKHRzLCBza2lwVG9FbmRTdGF0ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdGluZztcbiAgICAgIH0sXG4gICAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge31cbiAgICB9O1xuICB9O1xuXG4gIHZhciBhZGRFdmVudCA9IGZ1bmN0aW9uIGFkZEV2ZW50KGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odHlwZSwgZm4pIHtcbiAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBmbik7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgcmVtb3ZlRXZlbnQgPSBmdW5jdGlvbiByZW1vdmVFdmVudChlbGVtZW50KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHR5cGUsIGZuKSB7XG4gICAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgZm4pO1xuICAgIH07XG4gIH07XG5cbiAgLy8gbWl4aW5cbiAgdmFyIGxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyhfcmVmKSB7XG4gICAgdmFyIG1peGluQ29uZmlnID0gX3JlZi5taXhpbkNvbmZpZyxcbiAgICAgIHZpZXdQcm9wcyA9IF9yZWYudmlld1Byb3BzLFxuICAgICAgdmlld0ludGVybmFsQVBJID0gX3JlZi52aWV3SW50ZXJuYWxBUEksXG4gICAgICB2aWV3RXh0ZXJuYWxBUEkgPSBfcmVmLnZpZXdFeHRlcm5hbEFQSSxcbiAgICAgIHZpZXdTdGF0ZSA9IF9yZWYudmlld1N0YXRlLFxuICAgICAgdmlldyA9IF9yZWYudmlldztcbiAgICB2YXIgZXZlbnRzID0gW107XG5cbiAgICB2YXIgYWRkID0gYWRkRXZlbnQodmlldy5lbGVtZW50KTtcbiAgICB2YXIgcmVtb3ZlID0gcmVtb3ZlRXZlbnQodmlldy5lbGVtZW50KTtcblxuICAgIHZpZXdFeHRlcm5hbEFQSS5vbiA9IGZ1bmN0aW9uKHR5cGUsIGZuKSB7XG4gICAgICBldmVudHMucHVzaCh7XG4gICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgIGZuOiBmblxuICAgICAgfSk7XG5cbiAgICAgIGFkZCh0eXBlLCBmbik7XG4gICAgfTtcblxuICAgIHZpZXdFeHRlcm5hbEFQSS5vZmYgPSBmdW5jdGlvbih0eXBlLCBmbikge1xuICAgICAgZXZlbnRzLnNwbGljZShcbiAgICAgICAgZXZlbnRzLmZpbmRJbmRleChmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgIHJldHVybiBldmVudC50eXBlID09PSB0eXBlICYmIGV2ZW50LmZuID09PSBmbjtcbiAgICAgICAgfSksXG4gICAgICAgIDFcbiAgICAgICk7XG5cbiAgICAgIHJlbW92ZSh0eXBlLCBmbik7XG4gICAgfTtcblxuICAgIHJldHVybiB7XG4gICAgICB3cml0ZTogZnVuY3Rpb24gd3JpdGUoKSB7XG4gICAgICAgIC8vIG5vdCBidXN5XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSxcbiAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIGV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgcmVtb3ZlKGV2ZW50LnR5cGUsIGV2ZW50LmZuKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICAvLyBhZGQgdG8gZXh0ZXJuYWwgYXBpIGFuZCBsaW5rIHRvIHByb3BzXG5cbiAgdmFyIGFwaXMgPSBmdW5jdGlvbiBhcGlzKF9yZWYpIHtcbiAgICB2YXIgbWl4aW5Db25maWcgPSBfcmVmLm1peGluQ29uZmlnLFxuICAgICAgdmlld1Byb3BzID0gX3JlZi52aWV3UHJvcHMsXG4gICAgICB2aWV3RXh0ZXJuYWxBUEkgPSBfcmVmLnZpZXdFeHRlcm5hbEFQSTtcbiAgICBhZGRHZXRTZXQobWl4aW5Db25maWcsIHZpZXdFeHRlcm5hbEFQSSwgdmlld1Byb3BzKTtcbiAgfTtcblxuICB2YXIgaXNEZWZpbmVkID0gZnVuY3Rpb24gaXNEZWZpbmVkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9IG51bGw7XG4gIH07XG5cbiAgLy8gYWRkIHRvIHN0YXRlLFxuICAvLyBhZGQgZ2V0dGVycyBhbmQgc2V0dGVycyB0byBpbnRlcm5hbCBhbmQgZXh0ZXJuYWwgYXBpIChpZiBub3Qgc2V0KVxuICAvLyBzZXQgaW5pdGlhbCBzdGF0ZSBiYXNlZCBvbiBwcm9wcyBpbiB2aWV3UHJvcHNcbiAgLy8gYXBwbHkgYXMgdHJhbnNmb3JtcyBlYWNoIGZyYW1lXG5cbiAgdmFyIGRlZmF1bHRzID0ge1xuICAgIG9wYWNpdHk6IDEsXG4gICAgc2NhbGVYOiAxLFxuICAgIHNjYWxlWTogMSxcbiAgICB0cmFuc2xhdGVYOiAwLFxuICAgIHRyYW5zbGF0ZVk6IDAsXG4gICAgcm90YXRlWDogMCxcbiAgICByb3RhdGVZOiAwLFxuICAgIHJvdGF0ZVo6IDAsXG4gICAgb3JpZ2luWDogMCxcbiAgICBvcmlnaW5ZOiAwXG4gIH07XG5cbiAgdmFyIHN0eWxlcyA9IGZ1bmN0aW9uIHN0eWxlcyhfcmVmKSB7XG4gICAgdmFyIG1peGluQ29uZmlnID0gX3JlZi5taXhpbkNvbmZpZyxcbiAgICAgIHZpZXdQcm9wcyA9IF9yZWYudmlld1Byb3BzLFxuICAgICAgdmlld0ludGVybmFsQVBJID0gX3JlZi52aWV3SW50ZXJuYWxBUEksXG4gICAgICB2aWV3RXh0ZXJuYWxBUEkgPSBfcmVmLnZpZXdFeHRlcm5hbEFQSSxcbiAgICAgIHZpZXcgPSBfcmVmLnZpZXc7XG4gICAgLy8gaW5pdGlhbCBwcm9wc1xuICAgIHZhciBpbml0aWFsUHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCB2aWV3UHJvcHMpO1xuXG4gICAgLy8gY3VycmVudCBwcm9wc1xuICAgIHZhciBjdXJyZW50UHJvcHMgPSB7fTtcblxuICAgIC8vIHdlIHdpbGwgYWRkIHRob3NlIHByb3BlcnRpZXMgdG8gdGhlIGV4dGVybmFsIEFQSSBhbmQgbGluayB0aGVtIHRvIHRoZSB2aWV3U3RhdGVcbiAgICBhZGRHZXRTZXQobWl4aW5Db25maWcsIFt2aWV3SW50ZXJuYWxBUEksIHZpZXdFeHRlcm5hbEFQSV0sIHZpZXdQcm9wcyk7XG5cbiAgICAvLyBvdmVycmlkZSByZWN0IG9uIGludGVybmFsIGFuZCBleHRlcm5hbCByZWN0IGdldHRlciBzbyBpdCB0YWtlcyBpbiBhY2NvdW50IHRyYW5zZm9ybXNcbiAgICB2YXIgZ2V0T2Zmc2V0ID0gZnVuY3Rpb24gZ2V0T2Zmc2V0KCkge1xuICAgICAgcmV0dXJuIFt2aWV3UHJvcHNbJ3RyYW5zbGF0ZVgnXSB8fCAwLCB2aWV3UHJvcHNbJ3RyYW5zbGF0ZVknXSB8fCAwXTtcbiAgICB9O1xuXG4gICAgdmFyIGdldFNjYWxlID0gZnVuY3Rpb24gZ2V0U2NhbGUoKSB7XG4gICAgICByZXR1cm4gW3ZpZXdQcm9wc1snc2NhbGVYJ10gfHwgMCwgdmlld1Byb3BzWydzY2FsZVknXSB8fCAwXTtcbiAgICB9O1xuICAgIHZhciBnZXRSZWN0ID0gZnVuY3Rpb24gZ2V0UmVjdCgpIHtcbiAgICAgIHJldHVybiB2aWV3LnJlY3RcbiAgICAgICAgPyBnZXRWaWV3UmVjdCh2aWV3LnJlY3QsIHZpZXcuY2hpbGRWaWV3cywgZ2V0T2Zmc2V0KCksIGdldFNjYWxlKCkpXG4gICAgICAgIDogbnVsbDtcbiAgICB9O1xuICAgIHZpZXdJbnRlcm5hbEFQSS5yZWN0ID0geyBnZXQ6IGdldFJlY3QgfTtcbiAgICB2aWV3RXh0ZXJuYWxBUEkucmVjdCA9IHsgZ2V0OiBnZXRSZWN0IH07XG5cbiAgICAvLyBhcHBseSB2aWV3IHByb3BzXG4gICAgbWl4aW5Db25maWcuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgIHZpZXdQcm9wc1trZXldID1cbiAgICAgICAgdHlwZW9mIGluaXRpYWxQcm9wc1trZXldID09PSAndW5kZWZpbmVkJ1xuICAgICAgICAgID8gZGVmYXVsdHNba2V5XVxuICAgICAgICAgIDogaW5pdGlhbFByb3BzW2tleV07XG4gICAgfSk7XG5cbiAgICAvLyBleHBvc2UgYXBpXG4gICAgcmV0dXJuIHtcbiAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZSgpIHtcbiAgICAgICAgLy8gc2VlIGlmIHByb3BzIGhhdmUgY2hhbmdlZFxuICAgICAgICBpZiAoIXByb3BzSGF2ZUNoYW5nZWQoY3VycmVudFByb3BzLCB2aWV3UHJvcHMpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbW92ZXMgZWxlbWVudCB0byBjb3JyZWN0IHBvc2l0aW9uIG9uIHNjcmVlblxuICAgICAgICBhcHBseVN0eWxlcyh2aWV3LmVsZW1lbnQsIHZpZXdQcm9wcyk7XG5cbiAgICAgICAgLy8gc3RvcmUgbmV3IHRyYW5zZm9ybXNcbiAgICAgICAgT2JqZWN0LmFzc2lnbihjdXJyZW50UHJvcHMsIE9iamVjdC5hc3NpZ24oe30sIHZpZXdQcm9wcykpO1xuXG4gICAgICAgIC8vIG5vIGxvbmdlciBidXN5XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSxcbiAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7fVxuICAgIH07XG4gIH07XG5cbiAgdmFyIHByb3BzSGF2ZUNoYW5nZWQgPSBmdW5jdGlvbiBwcm9wc0hhdmVDaGFuZ2VkKGN1cnJlbnRQcm9wcywgbmV3UHJvcHMpIHtcbiAgICAvLyBkaWZmZXJlbnQgYW1vdW50IG9mIGtleXNcbiAgICBpZiAoT2JqZWN0LmtleXMoY3VycmVudFByb3BzKS5sZW5ndGggIT09IE9iamVjdC5rZXlzKG5ld1Byb3BzKS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIGxldHMgYW5hbHl6ZSB0aGUgaW5kaXZpZHVhbCBwcm9wc1xuICAgIGZvciAodmFyIHByb3AgaW4gbmV3UHJvcHMpIHtcbiAgICAgIGlmIChuZXdQcm9wc1twcm9wXSAhPT0gY3VycmVudFByb3BzW3Byb3BdKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICB2YXIgYXBwbHlTdHlsZXMgPSBmdW5jdGlvbiBhcHBseVN0eWxlcyhlbGVtZW50LCBfcmVmMikge1xuICAgIHZhciBvcGFjaXR5ID0gX3JlZjIub3BhY2l0eSxcbiAgICAgIHBlcnNwZWN0aXZlID0gX3JlZjIucGVyc3BlY3RpdmUsXG4gICAgICB0cmFuc2xhdGVYID0gX3JlZjIudHJhbnNsYXRlWCxcbiAgICAgIHRyYW5zbGF0ZVkgPSBfcmVmMi50cmFuc2xhdGVZLFxuICAgICAgc2NhbGVYID0gX3JlZjIuc2NhbGVYLFxuICAgICAgc2NhbGVZID0gX3JlZjIuc2NhbGVZLFxuICAgICAgcm90YXRlWCA9IF9yZWYyLnJvdGF0ZVgsXG4gICAgICByb3RhdGVZID0gX3JlZjIucm90YXRlWSxcbiAgICAgIHJvdGF0ZVogPSBfcmVmMi5yb3RhdGVaLFxuICAgICAgb3JpZ2luWCA9IF9yZWYyLm9yaWdpblgsXG4gICAgICBvcmlnaW5ZID0gX3JlZjIub3JpZ2luWSxcbiAgICAgIHdpZHRoID0gX3JlZjIud2lkdGgsXG4gICAgICBoZWlnaHQgPSBfcmVmMi5oZWlnaHQ7XG5cbiAgICB2YXIgdHJhbnNmb3JtcyA9ICcnO1xuICAgIHZhciBzdHlsZXMgPSAnJztcblxuICAgIC8vIGhhbmRsZSB0cmFuc2Zvcm0gb3JpZ2luXG4gICAgaWYgKGlzRGVmaW5lZChvcmlnaW5YKSB8fCBpc0RlZmluZWQob3JpZ2luWSkpIHtcbiAgICAgIHN0eWxlcyArPVxuICAgICAgICAndHJhbnNmb3JtLW9yaWdpbjogJyArIChvcmlnaW5YIHx8IDApICsgJ3B4ICcgKyAob3JpZ2luWSB8fCAwKSArICdweDsnO1xuICAgIH1cblxuICAgIC8vIHRyYW5zZm9ybSBvcmRlciBpcyByZWxldmFudFxuICAgIC8vIDAuIHBlcnNwZWN0aXZlXG4gICAgaWYgKGlzRGVmaW5lZChwZXJzcGVjdGl2ZSkpIHtcbiAgICAgIHRyYW5zZm9ybXMgKz0gJ3BlcnNwZWN0aXZlKCcgKyBwZXJzcGVjdGl2ZSArICdweCkgJztcbiAgICB9XG5cbiAgICAvLyAxLiB0cmFuc2xhdGVcbiAgICBpZiAoaXNEZWZpbmVkKHRyYW5zbGF0ZVgpIHx8IGlzRGVmaW5lZCh0cmFuc2xhdGVZKSkge1xuICAgICAgdHJhbnNmb3JtcyArPVxuICAgICAgICAndHJhbnNsYXRlM2QoJyArXG4gICAgICAgICh0cmFuc2xhdGVYIHx8IDApICtcbiAgICAgICAgJ3B4LCAnICtcbiAgICAgICAgKHRyYW5zbGF0ZVkgfHwgMCkgK1xuICAgICAgICAncHgsIDApICc7XG4gICAgfVxuXG4gICAgLy8gMi4gc2NhbGVcbiAgICBpZiAoaXNEZWZpbmVkKHNjYWxlWCkgfHwgaXNEZWZpbmVkKHNjYWxlWSkpIHtcbiAgICAgIHRyYW5zZm9ybXMgKz1cbiAgICAgICAgJ3NjYWxlM2QoJyArXG4gICAgICAgIChpc0RlZmluZWQoc2NhbGVYKSA/IHNjYWxlWCA6IDEpICtcbiAgICAgICAgJywgJyArXG4gICAgICAgIChpc0RlZmluZWQoc2NhbGVZKSA/IHNjYWxlWSA6IDEpICtcbiAgICAgICAgJywgMSkgJztcbiAgICB9XG5cbiAgICAvLyAzLiByb3RhdGVcbiAgICBpZiAoaXNEZWZpbmVkKHJvdGF0ZVopKSB7XG4gICAgICB0cmFuc2Zvcm1zICs9ICdyb3RhdGVaKCcgKyByb3RhdGVaICsgJ3JhZCkgJztcbiAgICB9XG5cbiAgICBpZiAoaXNEZWZpbmVkKHJvdGF0ZVgpKSB7XG4gICAgICB0cmFuc2Zvcm1zICs9ICdyb3RhdGVYKCcgKyByb3RhdGVYICsgJ3JhZCkgJztcbiAgICB9XG5cbiAgICBpZiAoaXNEZWZpbmVkKHJvdGF0ZVkpKSB7XG4gICAgICB0cmFuc2Zvcm1zICs9ICdyb3RhdGVZKCcgKyByb3RhdGVZICsgJ3JhZCkgJztcbiAgICB9XG5cbiAgICAvLyBhZGQgdHJhbnNmb3Jtc1xuICAgIGlmICh0cmFuc2Zvcm1zLmxlbmd0aCkge1xuICAgICAgc3R5bGVzICs9ICd0cmFuc2Zvcm06JyArIHRyYW5zZm9ybXMgKyAnOyc7XG4gICAgfVxuXG4gICAgLy8gYWRkIG9wYWNpdHlcbiAgICBpZiAoaXNEZWZpbmVkKG9wYWNpdHkpKSB7XG4gICAgICBzdHlsZXMgKz0gJ29wYWNpdHk6JyArIG9wYWNpdHkgKyAnOyc7XG5cbiAgICAgIC8vIGlmIHdlIHJlYWNoIHplcm8sIHdlIG1ha2UgdGhlIGVsZW1lbnQgaW5hY2Nlc3NpYmxlXG4gICAgICBpZiAob3BhY2l0eSA9PT0gMCkge1xuICAgICAgICBzdHlsZXMgKz0gJ3Zpc2liaWxpdHk6aGlkZGVuOyc7XG4gICAgICB9XG5cbiAgICAgIC8vIGlmIHdlJ3JlIGJlbG93IDEwMCUgb3BhY2l0eSB0aGlzIGVsZW1lbnQgY2FuJ3QgYmUgY2xpY2tlZFxuICAgICAgaWYgKG9wYWNpdHkgPCAxKSB7XG4gICAgICAgIHN0eWxlcyArPSAncG9pbnRlci1ldmVudHM6bm9uZTsnO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGFkZCBoZWlnaHRcbiAgICBpZiAoaXNEZWZpbmVkKGhlaWdodCkpIHtcbiAgICAgIHN0eWxlcyArPSAnaGVpZ2h0OicgKyBoZWlnaHQgKyAncHg7JztcbiAgICB9XG5cbiAgICAvLyBhZGQgd2lkdGhcbiAgICBpZiAoaXNEZWZpbmVkKHdpZHRoKSkge1xuICAgICAgc3R5bGVzICs9ICd3aWR0aDonICsgd2lkdGggKyAncHg7JztcbiAgICB9XG5cbiAgICAvLyBhcHBseSBzdHlsZXNcbiAgICB2YXIgZWxlbWVudEN1cnJlbnRTdHlsZSA9IGVsZW1lbnQuZWxlbWVudEN1cnJlbnRTdHlsZSB8fCAnJztcblxuICAgIC8vIGlmIG5ldyBzdHlsZXMgZG9lcyBub3QgbWF0Y2ggY3VycmVudCBzdHlsZXMsIGxldHMgdXBkYXRlIVxuICAgIGlmIChcbiAgICAgIHN0eWxlcy5sZW5ndGggIT09IGVsZW1lbnRDdXJyZW50U3R5bGUubGVuZ3RoIHx8XG4gICAgICBzdHlsZXMgIT09IGVsZW1lbnRDdXJyZW50U3R5bGVcbiAgICApIHtcbiAgICAgIGVsZW1lbnQuc3R5bGUuY3NzVGV4dCA9IHN0eWxlcztcbiAgICAgIC8vIHN0b3JlIGN1cnJlbnQgc3R5bGVzIHNvIHdlIGNhbiBjb21wYXJlIHRoZW0gdG8gbmV3IHN0eWxlcyBsYXRlciBvblxuICAgICAgLy8gX25vdF8gZ2V0dGluZyB0aGUgc3R5bGUgdmFsdWUgaXMgZmFzdGVyXG4gICAgICBlbGVtZW50LmVsZW1lbnRDdXJyZW50U3R5bGUgPSBzdHlsZXM7XG4gICAgfVxuICB9O1xuXG4gIHZhciBNaXhpbnMgPSB7XG4gICAgc3R5bGVzOiBzdHlsZXMsXG4gICAgbGlzdGVuZXJzOiBsaXN0ZW5lcnMsXG4gICAgYW5pbWF0aW9uczogYW5pbWF0aW9ucyxcbiAgICBhcGlzOiBhcGlzXG4gIH07XG5cbiAgdmFyIHVwZGF0ZVJlY3QgPSBmdW5jdGlvbiB1cGRhdGVSZWN0KCkge1xuICAgIHZhciByZWN0ID1cbiAgICAgIGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgdmFyIGVsZW1lbnQgPVxuICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIgc3R5bGUgPVxuICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcblxuICAgIGlmICghZWxlbWVudC5sYXlvdXRDYWxjdWxhdGVkKSB7XG4gICAgICByZWN0LnBhZGRpbmdUb3AgPSBwYXJzZUludChzdHlsZS5wYWRkaW5nVG9wLCAxMCkgfHwgMDtcbiAgICAgIHJlY3QubWFyZ2luVG9wID0gcGFyc2VJbnQoc3R5bGUubWFyZ2luVG9wLCAxMCkgfHwgMDtcbiAgICAgIHJlY3QubWFyZ2luUmlnaHQgPSBwYXJzZUludChzdHlsZS5tYXJnaW5SaWdodCwgMTApIHx8IDA7XG4gICAgICByZWN0Lm1hcmdpbkJvdHRvbSA9IHBhcnNlSW50KHN0eWxlLm1hcmdpbkJvdHRvbSwgMTApIHx8IDA7XG4gICAgICByZWN0Lm1hcmdpbkxlZnQgPSBwYXJzZUludChzdHlsZS5tYXJnaW5MZWZ0LCAxMCkgfHwgMDtcbiAgICAgIGVsZW1lbnQubGF5b3V0Q2FsY3VsYXRlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgcmVjdC5sZWZ0ID0gZWxlbWVudC5vZmZzZXRMZWZ0IHx8IDA7XG4gICAgcmVjdC50b3AgPSBlbGVtZW50Lm9mZnNldFRvcCB8fCAwO1xuICAgIHJlY3Qud2lkdGggPSBlbGVtZW50Lm9mZnNldFdpZHRoIHx8IDA7XG4gICAgcmVjdC5oZWlnaHQgPSBlbGVtZW50Lm9mZnNldEhlaWdodCB8fCAwO1xuXG4gICAgcmVjdC5yaWdodCA9IHJlY3QubGVmdCArIHJlY3Qud2lkdGg7XG4gICAgcmVjdC5ib3R0b20gPSByZWN0LnRvcCArIHJlY3QuaGVpZ2h0O1xuXG4gICAgcmVjdC5zY3JvbGxUb3AgPSBlbGVtZW50LnNjcm9sbFRvcDtcblxuICAgIHJlY3QuaGlkZGVuID0gZWxlbWVudC5vZmZzZXRQYXJlbnQgPT09IG51bGw7XG5cbiAgICByZXR1cm4gcmVjdDtcbiAgfTtcblxuICB2YXIgY3JlYXRlVmlldyA9XG4gICAgLy8gZGVmYXVsdCB2aWV3IGRlZmluaXRpb25cbiAgICBmdW5jdGlvbiBjcmVhdGVWaWV3KCkge1xuICAgICAgdmFyIF9yZWYgPVxuICAgICAgICAgIGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IGFyZ3VtZW50c1swXVxuICAgICAgICAgICAgOiB7fSxcbiAgICAgICAgX3JlZiR0YWcgPSBfcmVmLnRhZyxcbiAgICAgICAgdGFnID0gX3JlZiR0YWcgPT09IHZvaWQgMCA/ICdkaXYnIDogX3JlZiR0YWcsXG4gICAgICAgIF9yZWYkbmFtZSA9IF9yZWYubmFtZSxcbiAgICAgICAgbmFtZSA9IF9yZWYkbmFtZSA9PT0gdm9pZCAwID8gbnVsbCA6IF9yZWYkbmFtZSxcbiAgICAgICAgX3JlZiRhdHRyaWJ1dGVzID0gX3JlZi5hdHRyaWJ1dGVzLFxuICAgICAgICBhdHRyaWJ1dGVzID0gX3JlZiRhdHRyaWJ1dGVzID09PSB2b2lkIDAgPyB7fSA6IF9yZWYkYXR0cmlidXRlcyxcbiAgICAgICAgX3JlZiRyZWFkID0gX3JlZi5yZWFkLFxuICAgICAgICByZWFkID0gX3JlZiRyZWFkID09PSB2b2lkIDAgPyBmdW5jdGlvbigpIHt9IDogX3JlZiRyZWFkLFxuICAgICAgICBfcmVmJHdyaXRlID0gX3JlZi53cml0ZSxcbiAgICAgICAgd3JpdGUgPSBfcmVmJHdyaXRlID09PSB2b2lkIDAgPyBmdW5jdGlvbigpIHt9IDogX3JlZiR3cml0ZSxcbiAgICAgICAgX3JlZiRjcmVhdGUgPSBfcmVmLmNyZWF0ZSxcbiAgICAgICAgY3JlYXRlID0gX3JlZiRjcmVhdGUgPT09IHZvaWQgMCA/IGZ1bmN0aW9uKCkge30gOiBfcmVmJGNyZWF0ZSxcbiAgICAgICAgX3JlZiRkZXN0cm95ID0gX3JlZi5kZXN0cm95LFxuICAgICAgICBkZXN0cm95ID0gX3JlZiRkZXN0cm95ID09PSB2b2lkIDAgPyBmdW5jdGlvbigpIHt9IDogX3JlZiRkZXN0cm95LFxuICAgICAgICBfcmVmJGZpbHRlckZyYW1lQWN0aW8gPSBfcmVmLmZpbHRlckZyYW1lQWN0aW9uc0ZvckNoaWxkLFxuICAgICAgICBmaWx0ZXJGcmFtZUFjdGlvbnNGb3JDaGlsZCA9XG4gICAgICAgICAgX3JlZiRmaWx0ZXJGcmFtZUFjdGlvID09PSB2b2lkIDBcbiAgICAgICAgICAgID8gZnVuY3Rpb24oY2hpbGQsIGFjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWN0aW9ucztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiBfcmVmJGZpbHRlckZyYW1lQWN0aW8sXG4gICAgICAgIF9yZWYkZGlkQ3JlYXRlVmlldyA9IF9yZWYuZGlkQ3JlYXRlVmlldyxcbiAgICAgICAgZGlkQ3JlYXRlVmlldyA9XG4gICAgICAgICAgX3JlZiRkaWRDcmVhdGVWaWV3ID09PSB2b2lkIDAgPyBmdW5jdGlvbigpIHt9IDogX3JlZiRkaWRDcmVhdGVWaWV3LFxuICAgICAgICBfcmVmJGRpZFdyaXRlVmlldyA9IF9yZWYuZGlkV3JpdGVWaWV3LFxuICAgICAgICBkaWRXcml0ZVZpZXcgPVxuICAgICAgICAgIF9yZWYkZGlkV3JpdGVWaWV3ID09PSB2b2lkIDAgPyBmdW5jdGlvbigpIHt9IDogX3JlZiRkaWRXcml0ZVZpZXcsXG4gICAgICAgIF9yZWYkaWdub3JlUmVjdCA9IF9yZWYuaWdub3JlUmVjdCxcbiAgICAgICAgaWdub3JlUmVjdCA9IF9yZWYkaWdub3JlUmVjdCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmJGlnbm9yZVJlY3QsXG4gICAgICAgIF9yZWYkaWdub3JlUmVjdFVwZGF0ZSA9IF9yZWYuaWdub3JlUmVjdFVwZGF0ZSxcbiAgICAgICAgaWdub3JlUmVjdFVwZGF0ZSA9XG4gICAgICAgICAgX3JlZiRpZ25vcmVSZWN0VXBkYXRlID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYkaWdub3JlUmVjdFVwZGF0ZSxcbiAgICAgICAgX3JlZiRtaXhpbnMgPSBfcmVmLm1peGlucyxcbiAgICAgICAgbWl4aW5zID0gX3JlZiRtaXhpbnMgPT09IHZvaWQgMCA/IFtdIDogX3JlZiRtaXhpbnM7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oXG4gICAgICAgIC8vIGVhY2ggdmlldyByZXF1aXJlcyByZWZlcmVuY2UgdG8gc3RvcmVcbiAgICAgICAgc3RvcmVcbiAgICAgICkge1xuICAgICAgICB2YXIgcHJvcHMgPVxuICAgICAgICAgIGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IGFyZ3VtZW50c1sxXVxuICAgICAgICAgICAgOiB7fTtcbiAgICAgICAgLy8gcm9vdCBlbGVtZW50IHNob3VsZCBub3QgYmUgY2hhbmdlZFxuICAgICAgICB2YXIgZWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQodGFnLCAnZmlsZXBvbmQtLScgKyBuYW1lLCBhdHRyaWJ1dGVzKTtcblxuICAgICAgICAvLyBzdHlsZSByZWZlcmVuY2Ugc2hvdWxkIGFsc28gbm90IGJlIGNoYW5nZWRcbiAgICAgICAgdmFyIHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCwgbnVsbCk7XG5cbiAgICAgICAgLy8gZWxlbWVudCByZWN0YW5nbGVcbiAgICAgICAgdmFyIHJlY3QgPSB1cGRhdGVSZWN0KCk7XG4gICAgICAgIHZhciBmcmFtZVJlY3QgPSBudWxsO1xuXG4gICAgICAgIC8vIHJlc3Qgc3RhdGVcbiAgICAgICAgdmFyIGlzUmVzdGluZyA9IGZhbHNlO1xuXG4gICAgICAgIC8vIHByZXR0eSBzZWxmIGV4cGxhbmF0b3J5XG4gICAgICAgIHZhciBjaGlsZFZpZXdzID0gW107XG5cbiAgICAgICAgLy8gbG9hZGVkIG1peGluc1xuICAgICAgICB2YXIgYWN0aXZlTWl4aW5zID0gW107XG5cbiAgICAgICAgLy8gcmVmZXJlbmNlcyB0byBjcmVhdGVkIGNoaWxkcmVuXG4gICAgICAgIHZhciByZWYgPSB7fTtcblxuICAgICAgICAvLyBzdGF0ZSB1c2VkIGZvciBlYWNoIGluc3RhbmNlXG4gICAgICAgIHZhciBzdGF0ZSA9IHt9O1xuXG4gICAgICAgIC8vIGxpc3Qgb2Ygd3JpdGVycyB0aGF0IHdpbGwgYmUgY2FsbGVkIHRvIHVwZGF0ZSB0aGlzIHZpZXdcbiAgICAgICAgdmFyIHdyaXRlcnMgPSBbXG4gICAgICAgICAgd3JpdGUgLy8gZGVmYXVsdCB3cml0ZXJcbiAgICAgICAgXTtcblxuICAgICAgICB2YXIgcmVhZGVycyA9IFtcbiAgICAgICAgICByZWFkIC8vIGRlZmF1bHQgcmVhZGVyXG4gICAgICAgIF07XG5cbiAgICAgICAgdmFyIGRlc3Ryb3llcnMgPSBbXG4gICAgICAgICAgZGVzdHJveSAvLyBkZWZhdWx0IGRlc3Ryb3lcbiAgICAgICAgXTtcblxuICAgICAgICAvLyBjb3JlIHZpZXcgbWV0aG9kc1xuICAgICAgICB2YXIgZ2V0RWxlbWVudCA9IGZ1bmN0aW9uIGdldEVsZW1lbnQoKSB7XG4gICAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBnZXRDaGlsZFZpZXdzID0gZnVuY3Rpb24gZ2V0Q2hpbGRWaWV3cygpIHtcbiAgICAgICAgICByZXR1cm4gY2hpbGRWaWV3cy5jb25jYXQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGdldFJlZmVyZW5jZSA9IGZ1bmN0aW9uIGdldFJlZmVyZW5jZSgpIHtcbiAgICAgICAgICByZXR1cm4gcmVmO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgY3JlYXRlQ2hpbGRWaWV3ID0gZnVuY3Rpb24gY3JlYXRlQ2hpbGRWaWV3KHN0b3JlKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHZpZXcsIHByb3BzKSB7XG4gICAgICAgICAgICByZXR1cm4gdmlldyhzdG9yZSwgcHJvcHMpO1xuICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIHZhciBnZXRSZWN0ID0gZnVuY3Rpb24gZ2V0UmVjdCgpIHtcbiAgICAgICAgICBpZiAoZnJhbWVSZWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gZnJhbWVSZWN0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBmcmFtZVJlY3QgPSBnZXRWaWV3UmVjdChyZWN0LCBjaGlsZFZpZXdzLCBbMCwgMF0sIFsxLCAxXSk7XG4gICAgICAgICAgcmV0dXJuIGZyYW1lUmVjdDtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGdldFN0eWxlID0gZnVuY3Rpb24gZ2V0U3R5bGUoKSB7XG4gICAgICAgICAgcmV0dXJuIHN0eWxlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWFkIGRhdGEgZnJvbSBET01cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHZhciBfcmVhZCA9IGZ1bmN0aW9uIF9yZWFkKCkge1xuICAgICAgICAgIGZyYW1lUmVjdCA9IG51bGw7XG5cbiAgICAgICAgICAvLyByZWFkIGNoaWxkIHZpZXdzXG4gICAgICAgICAgY2hpbGRWaWV3cy5mb3JFYWNoKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgICAgICByZXR1cm4gY2hpbGQuX3JlYWQoKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBzaG91bGRVcGRhdGUgPSAhKGlnbm9yZVJlY3RVcGRhdGUgJiYgcmVjdC53aWR0aCAmJiByZWN0LmhlaWdodCk7XG4gICAgICAgICAgaWYgKHNob3VsZFVwZGF0ZSkge1xuICAgICAgICAgICAgdXBkYXRlUmVjdChyZWN0LCBlbGVtZW50LCBzdHlsZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gcmVhZGVyc1xuICAgICAgICAgIHZhciBhcGkgPSB7IHJvb3Q6IGludGVybmFsQVBJLCBwcm9wczogcHJvcHMsIHJlY3Q6IHJlY3QgfTtcbiAgICAgICAgICByZWFkZXJzLmZvckVhY2goZnVuY3Rpb24ocmVhZGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVhZGVyKGFwaSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdyaXRlIGRhdGEgdG8gRE9NXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgX3dyaXRlID0gZnVuY3Rpb24gX3dyaXRlKHRzLCBmcmFtZUFjdGlvbnMsIHNob3VsZE9wdGltaXplKSB7XG4gICAgICAgICAgLy8gaWYgbm8gYWN0aW9ucywgd2UgYXNzdW1lIHRoYXQgdGhlIHZpZXcgaXMgcmVzdGluZ1xuICAgICAgICAgIHZhciByZXN0aW5nID0gZnJhbWVBY3Rpb25zLmxlbmd0aCA9PT0gMDtcblxuICAgICAgICAgIC8vIHdyaXRlcnNcbiAgICAgICAgICB3cml0ZXJzLmZvckVhY2goZnVuY3Rpb24od3JpdGVyKSB7XG4gICAgICAgICAgICB2YXIgd3JpdGVyUmVzdGluZyA9IHdyaXRlcih7XG4gICAgICAgICAgICAgIHByb3BzOiBwcm9wcyxcbiAgICAgICAgICAgICAgcm9vdDogaW50ZXJuYWxBUEksXG4gICAgICAgICAgICAgIGFjdGlvbnM6IGZyYW1lQWN0aW9ucyxcbiAgICAgICAgICAgICAgdGltZXN0YW1wOiB0cyxcbiAgICAgICAgICAgICAgc2hvdWxkT3B0aW1pemU6IHNob3VsZE9wdGltaXplXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKHdyaXRlclJlc3RpbmcgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIHJlc3RpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIC8vIHJ1biBtaXhpbnNcbiAgICAgICAgICBhY3RpdmVNaXhpbnMuZm9yRWFjaChmdW5jdGlvbihtaXhpbikge1xuICAgICAgICAgICAgLy8gaWYgb25lIG9mIHRoZSBtaXhpbnMgaXMgc3RpbGwgYnVzeSBhZnRlciB3cml0ZSBvcGVyYXRpb24sIHdlIGFyZSBub3QgcmVzdGluZ1xuICAgICAgICAgICAgdmFyIG1peGluUmVzdGluZyA9IG1peGluLndyaXRlKHRzKTtcbiAgICAgICAgICAgIGlmIChtaXhpblJlc3RpbmcgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIHJlc3RpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIC8vIHVwZGF0ZXMgY2hpbGQgdmlld3MgdGhhdCBhcmUgY3VycmVudGx5IGF0dGFjaGVkIHRvIHRoZSBET01cbiAgICAgICAgICBjaGlsZFZpZXdzXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgICAgICAgIHJldHVybiAhIWNoaWxkLmVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICAgICAgICAvLyBpZiBhIGNoaWxkIHZpZXcgaXMgbm90IHJlc3RpbmcsIHdlIGFyZSBub3QgcmVzdGluZ1xuICAgICAgICAgICAgICB2YXIgY2hpbGRSZXN0aW5nID0gY2hpbGQuX3dyaXRlKFxuICAgICAgICAgICAgICAgIHRzLFxuICAgICAgICAgICAgICAgIGZpbHRlckZyYW1lQWN0aW9uc0ZvckNoaWxkKGNoaWxkLCBmcmFtZUFjdGlvbnMpLFxuICAgICAgICAgICAgICAgIHNob3VsZE9wdGltaXplXG4gICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgaWYgKCFjaGlsZFJlc3RpbmcpIHtcbiAgICAgICAgICAgICAgICByZXN0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gYXBwZW5kIG5ldyBlbGVtZW50cyB0byBET00gYW5kIHVwZGF0ZSB0aG9zZVxuICAgICAgICAgIGNoaWxkVmlld3NcbiAgICAgICAgICAgIC8vLmZpbHRlcihjaGlsZCA9PiAhY2hpbGQuZWxlbWVudC5wYXJlbnROb2RlKVxuICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24oY2hpbGQsIGluZGV4KSB7XG4gICAgICAgICAgICAgIC8vIHNraXBcbiAgICAgICAgICAgICAgaWYgKGNoaWxkLmVsZW1lbnQucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIGFwcGVuZCB0byBET01cbiAgICAgICAgICAgICAgaW50ZXJuYWxBUEkuYXBwZW5kQ2hpbGQoY2hpbGQuZWxlbWVudCwgaW5kZXgpO1xuXG4gICAgICAgICAgICAgIC8vIGNhbGwgcmVhZCAobmVlZCB0byBrbm93IHRoZSBzaXplIG9mIHRoZXNlIGVsZW1lbnRzKVxuICAgICAgICAgICAgICBjaGlsZC5fcmVhZCgpO1xuXG4gICAgICAgICAgICAgIC8vIHJlLWNhbGwgd3JpdGVcbiAgICAgICAgICAgICAgY2hpbGQuX3dyaXRlKFxuICAgICAgICAgICAgICAgIHRzLFxuICAgICAgICAgICAgICAgIGZpbHRlckZyYW1lQWN0aW9uc0ZvckNoaWxkKGNoaWxkLCBmcmFtZUFjdGlvbnMpLFxuICAgICAgICAgICAgICAgIHNob3VsZE9wdGltaXplXG4gICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgLy8gd2UganVzdCBhZGRlZCBzb210aGluZyB0byB0aGUgZG9tLCBubyByZXN0XG4gICAgICAgICAgICAgIHJlc3RpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gdXBkYXRlIHJlc3Rpbmcgc3RhdGVcbiAgICAgICAgICBpc1Jlc3RpbmcgPSByZXN0aW5nO1xuXG4gICAgICAgICAgZGlkV3JpdGVWaWV3KHtcbiAgICAgICAgICAgIHByb3BzOiBwcm9wcyxcbiAgICAgICAgICAgIHJvb3Q6IGludGVybmFsQVBJLFxuICAgICAgICAgICAgYWN0aW9uczogZnJhbWVBY3Rpb25zLFxuICAgICAgICAgICAgdGltZXN0YW1wOiB0c1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gbGV0IHBhcmVudCBrbm93IGlmIHdlIGFyZSByZXN0aW5nXG4gICAgICAgICAgcmV0dXJuIHJlc3Rpbmc7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIF9kZXN0cm95ID0gZnVuY3Rpb24gX2Rlc3Ryb3koKSB7XG4gICAgICAgICAgYWN0aXZlTWl4aW5zLmZvckVhY2goZnVuY3Rpb24obWl4aW4pIHtcbiAgICAgICAgICAgIHJldHVybiBtaXhpbi5kZXN0cm95KCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZGVzdHJveWVycy5mb3JFYWNoKGZ1bmN0aW9uKGRlc3Ryb3llcikge1xuICAgICAgICAgICAgZGVzdHJveWVyKHsgcm9vdDogaW50ZXJuYWxBUEksIHByb3BzOiBwcm9wcyB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjaGlsZFZpZXdzLmZvckVhY2goZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGlsZC5fZGVzdHJveSgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHNoYXJlZEFQSVxuICAgICAgICB2YXIgc2hhcmVkQVBJRGVmaW5pdGlvbiA9IHtcbiAgICAgICAgICBlbGVtZW50OiB7XG4gICAgICAgICAgICBnZXQ6IGdldEVsZW1lbnRcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIGdldDogZ2V0U3R5bGVcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgY2hpbGRWaWV3czoge1xuICAgICAgICAgICAgZ2V0OiBnZXRDaGlsZFZpZXdzXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHByaXZhdGUgQVBJIGRlZmluaXRpb25cbiAgICAgICAgdmFyIGludGVybmFsQVBJRGVmaW5pdGlvbiA9IE9iamVjdC5hc3NpZ24oe30sIHNoYXJlZEFQSURlZmluaXRpb24sIHtcbiAgICAgICAgICByZWN0OiB7XG4gICAgICAgICAgICBnZXQ6IGdldFJlY3RcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgLy8gYWNjZXNzIHRvIGN1c3RvbSBjaGlsZHJlbiByZWZlcmVuY2VzXG4gICAgICAgICAgcmVmOiB7XG4gICAgICAgICAgICBnZXQ6IGdldFJlZmVyZW5jZVxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICAvLyBkb20gbW9kaWZpZXJzXG4gICAgICAgICAgaXM6IGZ1bmN0aW9uIGlzKG5lZWRsZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5hbWUgPT09IG5lZWRsZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGFwcGVuZENoaWxkOiBhcHBlbmRDaGlsZChlbGVtZW50KSxcbiAgICAgICAgICBjcmVhdGVDaGlsZFZpZXc6IGNyZWF0ZUNoaWxkVmlldyhzdG9yZSksXG4gICAgICAgICAgbGlua1ZpZXc6IGZ1bmN0aW9uIGxpbmtWaWV3KHZpZXcpIHtcbiAgICAgICAgICAgIGNoaWxkVmlld3MucHVzaCh2aWV3KTtcbiAgICAgICAgICAgIHJldHVybiB2aWV3O1xuICAgICAgICAgIH0sXG4gICAgICAgICAgdW5saW5rVmlldzogZnVuY3Rpb24gdW5saW5rVmlldyh2aWV3KSB7XG4gICAgICAgICAgICBjaGlsZFZpZXdzLnNwbGljZShjaGlsZFZpZXdzLmluZGV4T2YodmlldyksIDEpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgYXBwZW5kQ2hpbGRWaWV3OiBhcHBlbmRDaGlsZFZpZXcoZWxlbWVudCwgY2hpbGRWaWV3cyksXG4gICAgICAgICAgcmVtb3ZlQ2hpbGRWaWV3OiByZW1vdmVDaGlsZFZpZXcoZWxlbWVudCwgY2hpbGRWaWV3cyksXG4gICAgICAgICAgcmVnaXN0ZXJXcml0ZXI6IGZ1bmN0aW9uIHJlZ2lzdGVyV3JpdGVyKHdyaXRlcikge1xuICAgICAgICAgICAgcmV0dXJuIHdyaXRlcnMucHVzaCh3cml0ZXIpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVnaXN0ZXJSZWFkZXI6IGZ1bmN0aW9uIHJlZ2lzdGVyUmVhZGVyKHJlYWRlcikge1xuICAgICAgICAgICAgcmV0dXJuIHJlYWRlcnMucHVzaChyZWFkZXIpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVnaXN0ZXJEZXN0cm95ZXI6IGZ1bmN0aW9uIHJlZ2lzdGVyRGVzdHJveWVyKGRlc3Ryb3llcikge1xuICAgICAgICAgICAgcmV0dXJuIGRlc3Ryb3llcnMucHVzaChkZXN0cm95ZXIpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgaW52YWxpZGF0ZUxheW91dDogZnVuY3Rpb24gaW52YWxpZGF0ZUxheW91dCgpIHtcbiAgICAgICAgICAgIHJldHVybiAoZWxlbWVudC5sYXlvdXRDYWxjdWxhdGVkID0gZmFsc2UpO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICAvLyBhY2Nlc3MgdG8gZGF0YSBzdG9yZVxuICAgICAgICAgIGRpc3BhdGNoOiBzdG9yZS5kaXNwYXRjaCxcbiAgICAgICAgICBxdWVyeTogc3RvcmUucXVlcnlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gcHVibGljIHZpZXcgQVBJIG1ldGhvZHNcbiAgICAgICAgdmFyIGV4dGVybmFsQVBJRGVmaW5pdGlvbiA9IHtcbiAgICAgICAgICBlbGVtZW50OiB7XG4gICAgICAgICAgICBnZXQ6IGdldEVsZW1lbnRcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgY2hpbGRWaWV3czoge1xuICAgICAgICAgICAgZ2V0OiBnZXRDaGlsZFZpZXdzXG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHJlY3Q6IHtcbiAgICAgICAgICAgIGdldDogZ2V0UmVjdFxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICByZXN0aW5nOiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGlzUmVzdGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgaXNSZWN0SWdub3JlZDogZnVuY3Rpb24gaXNSZWN0SWdub3JlZCgpIHtcbiAgICAgICAgICAgIHJldHVybiBpZ25vcmVSZWN0O1xuICAgICAgICAgIH0sXG4gICAgICAgICAgX3JlYWQ6IF9yZWFkLFxuICAgICAgICAgIF93cml0ZTogX3dyaXRlLFxuICAgICAgICAgIF9kZXN0cm95OiBfZGVzdHJveVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIG1peGluIEFQSSBtZXRob2RzXG4gICAgICAgIHZhciBtaXhpbkFQSURlZmluaXRpb24gPSBPYmplY3QuYXNzaWduKHt9LCBzaGFyZWRBUElEZWZpbml0aW9uLCB7XG4gICAgICAgICAgcmVjdDoge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgIHJldHVybiByZWN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gYWRkIG1peGluIGZ1bmN0aW9uYWxpdHlcbiAgICAgICAgT2JqZWN0LmtleXMobWl4aW5zKVxuICAgICAgICAgIC5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgIC8vIG1vdmUgc3R5bGVzIHRvIHRoZSBiYWNrIG9mIHRoZSBtaXhpbiBsaXN0IChzbyBhZGp1c3RtZW50cyBvZiBvdGhlciBtaXhpbnMgYXJlIGFwcGxpZWQgdG8gdGhlIHByb3BzIGNvcnJlY3RseSlcbiAgICAgICAgICAgIGlmIChhID09PSAnc3R5bGVzJykge1xuICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYiA9PT0gJ3N0eWxlcycpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgfSlcbiAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIHZhciBtaXhpbkFQSSA9IE1peGluc1trZXldKHtcbiAgICAgICAgICAgICAgbWl4aW5Db25maWc6IG1peGluc1trZXldLFxuICAgICAgICAgICAgICB2aWV3UHJvcHM6IHByb3BzLFxuICAgICAgICAgICAgICB2aWV3U3RhdGU6IHN0YXRlLFxuICAgICAgICAgICAgICB2aWV3SW50ZXJuYWxBUEk6IGludGVybmFsQVBJRGVmaW5pdGlvbixcbiAgICAgICAgICAgICAgdmlld0V4dGVybmFsQVBJOiBleHRlcm5hbEFQSURlZmluaXRpb24sXG4gICAgICAgICAgICAgIHZpZXc6IGNyZWF0ZU9iamVjdChtaXhpbkFQSURlZmluaXRpb24pXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKG1peGluQVBJKSB7XG4gICAgICAgICAgICAgIGFjdGl2ZU1peGlucy5wdXNoKG1peGluQVBJKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAvLyBjb25zdHJ1Y3QgcHJpdmF0ZSBhcGlcbiAgICAgICAgdmFyIGludGVybmFsQVBJID0gY3JlYXRlT2JqZWN0KGludGVybmFsQVBJRGVmaW5pdGlvbik7XG5cbiAgICAgICAgLy8gY3JlYXRlIHRoZSB2aWV3XG4gICAgICAgIGNyZWF0ZSh7XG4gICAgICAgICAgcm9vdDogaW50ZXJuYWxBUEksXG4gICAgICAgICAgcHJvcHM6IHByb3BzXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGFwcGVuZCBjcmVhdGVkIGNoaWxkIHZpZXdzIHRvIHJvb3Qgbm9kZVxuICAgICAgICB2YXIgY2hpbGRDb3VudCA9IGdldENoaWxkQ291bnQoZWxlbWVudCk7IC8vIG5lZWQgdG8ga25vdyB0aGUgY3VycmVudCBjaGlsZCBjb3VudCBzbyBhcHBlbmRpbmcgaGFwcGVucyBpbiBjb3JyZWN0IG9yZGVyXG4gICAgICAgIGNoaWxkVmlld3MuZm9yRWFjaChmdW5jdGlvbihjaGlsZCwgaW5kZXgpIHtcbiAgICAgICAgICBpbnRlcm5hbEFQSS5hcHBlbmRDaGlsZChjaGlsZC5lbGVtZW50LCBjaGlsZENvdW50ICsgaW5kZXgpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBjYWxsIGRpZCBjcmVhdGVcbiAgICAgICAgZGlkQ3JlYXRlVmlldyhpbnRlcm5hbEFQSSk7XG5cbiAgICAgICAgLy8gZXhwb3NlIHB1YmxpYyBhcGlcbiAgICAgICAgcmV0dXJuIGNyZWF0ZU9iamVjdChleHRlcm5hbEFQSURlZmluaXRpb24pO1xuICAgICAgfTtcbiAgICB9O1xuXG4gIHZhciBjcmVhdGVQYWludGVyID0gZnVuY3Rpb24gY3JlYXRlUGFpbnRlcihyZWFkLCB3cml0ZSkge1xuICAgIHZhciBmcHMgPVxuICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiA2MDtcblxuICAgIHZhciBuYW1lID0gJ19fZnJhbWVQYWludGVyJztcblxuICAgIC8vIHNldCBnbG9iYWwgcGFpbnRlclxuICAgIGlmICh3aW5kb3dbbmFtZV0pIHtcbiAgICAgIHdpbmRvd1tuYW1lXS5yZWFkZXJzLnB1c2gocmVhZCk7XG4gICAgICB3aW5kb3dbbmFtZV0ud3JpdGVycy5wdXNoKHdyaXRlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3aW5kb3dbbmFtZV0gPSB7XG4gICAgICByZWFkZXJzOiBbcmVhZF0sXG4gICAgICB3cml0ZXJzOiBbd3JpdGVdXG4gICAgfTtcblxuICAgIHZhciBwYWludGVyID0gd2luZG93W25hbWVdO1xuXG4gICAgdmFyIGludGVydmFsID0gMTAwMCAvIGZwcztcbiAgICB2YXIgbGFzdCA9IG51bGw7XG4gICAgdmFyIGlkID0gbnVsbDtcbiAgICB2YXIgcmVxdWVzdFRpY2sgPSBudWxsO1xuICAgIHZhciBjYW5jZWxUaWNrID0gbnVsbDtcblxuICAgIHZhciBzZXRUaW1lclR5cGUgPSBmdW5jdGlvbiBzZXRUaW1lclR5cGUoKSB7XG4gICAgICBpZiAoZG9jdW1lbnQuaGlkZGVuKSB7XG4gICAgICAgIHJlcXVlc3RUaWNrID0gZnVuY3Rpb24gcmVxdWVzdFRpY2soKSB7XG4gICAgICAgICAgcmV0dXJuIHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRpY2socGVyZm9ybWFuY2Uubm93KCkpO1xuICAgICAgICAgIH0sIGludGVydmFsKTtcbiAgICAgICAgfTtcbiAgICAgICAgY2FuY2VsVGljayA9IGZ1bmN0aW9uIGNhbmNlbFRpY2soKSB7XG4gICAgICAgICAgcmV0dXJuIHdpbmRvdy5jbGVhclRpbWVvdXQoaWQpO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVxdWVzdFRpY2sgPSBmdW5jdGlvbiByZXF1ZXN0VGljaygpIHtcbiAgICAgICAgICByZXR1cm4gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSh0aWNrKTtcbiAgICAgICAgfTtcbiAgICAgICAgY2FuY2VsVGljayA9IGZ1bmN0aW9uIGNhbmNlbFRpY2soKSB7XG4gICAgICAgICAgcmV0dXJuIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZShpZCk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcblxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Zpc2liaWxpdHljaGFuZ2UnLCBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChjYW5jZWxUaWNrKSBjYW5jZWxUaWNrKCk7XG4gICAgICBzZXRUaW1lclR5cGUoKTtcbiAgICAgIHRpY2socGVyZm9ybWFuY2Uubm93KCkpO1xuICAgIH0pO1xuXG4gICAgdmFyIHRpY2sgPSBmdW5jdGlvbiB0aWNrKHRzKSB7XG4gICAgICAvLyBxdWV1ZSBuZXh0IHRpY2tcbiAgICAgIGlkID0gcmVxdWVzdFRpY2sodGljayk7XG5cbiAgICAgIC8vIGxpbWl0IGZwc1xuICAgICAgaWYgKCFsYXN0KSB7XG4gICAgICAgIGxhc3QgPSB0cztcbiAgICAgIH1cblxuICAgICAgdmFyIGRlbHRhID0gdHMgLSBsYXN0O1xuXG4gICAgICBpZiAoZGVsdGEgPD0gaW50ZXJ2YWwpIHtcbiAgICAgICAgLy8gc2tpcCBmcmFtZVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIGFsaWduIG5leHQgZnJhbWVcbiAgICAgIGxhc3QgPSB0cyAtIChkZWx0YSAlIGludGVydmFsKTtcblxuICAgICAgLy8gdXBkYXRlIHZpZXdcbiAgICAgIHBhaW50ZXIucmVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKHJlYWQpIHtcbiAgICAgICAgcmV0dXJuIHJlYWQoKTtcbiAgICAgIH0pO1xuICAgICAgcGFpbnRlci53cml0ZXJzLmZvckVhY2goZnVuY3Rpb24od3JpdGUpIHtcbiAgICAgICAgcmV0dXJuIHdyaXRlKHRzKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBzZXRUaW1lclR5cGUoKTtcbiAgICB0aWNrKHBlcmZvcm1hbmNlLm5vdygpKTtcblxuICAgIHJldHVybiB7XG4gICAgICBwYXVzZTogZnVuY3Rpb24gcGF1c2UoKSB7XG4gICAgICAgIGNhbmNlbFRpY2soaWQpO1xuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgdmFyIGNyZWF0ZVJvdXRlID0gZnVuY3Rpb24gY3JlYXRlUm91dGUocm91dGVzLCBmbikge1xuICAgIHJldHVybiBmdW5jdGlvbihfcmVmKSB7XG4gICAgICB2YXIgcm9vdCA9IF9yZWYucm9vdCxcbiAgICAgICAgcHJvcHMgPSBfcmVmLnByb3BzLFxuICAgICAgICBfcmVmJGFjdGlvbnMgPSBfcmVmLmFjdGlvbnMsXG4gICAgICAgIGFjdGlvbnMgPSBfcmVmJGFjdGlvbnMgPT09IHZvaWQgMCA/IFtdIDogX3JlZiRhY3Rpb25zLFxuICAgICAgICB0aW1lc3RhbXAgPSBfcmVmLnRpbWVzdGFtcCxcbiAgICAgICAgc2hvdWxkT3B0aW1pemUgPSBfcmVmLnNob3VsZE9wdGltaXplO1xuICAgICAgYWN0aW9uc1xuICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKGFjdGlvbikge1xuICAgICAgICAgIHJldHVybiByb3V0ZXNbYWN0aW9uLnR5cGVdO1xuICAgICAgICB9KVxuICAgICAgICAuZm9yRWFjaChmdW5jdGlvbihhY3Rpb24pIHtcbiAgICAgICAgICByZXR1cm4gcm91dGVzW2FjdGlvbi50eXBlXSh7XG4gICAgICAgICAgICByb290OiByb290LFxuICAgICAgICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgICAgICAgYWN0aW9uOiBhY3Rpb24uZGF0YSxcbiAgICAgICAgICAgIHRpbWVzdGFtcDogdGltZXN0YW1wLFxuICAgICAgICAgICAgc2hvdWxkT3B0aW1pemU6IHNob3VsZE9wdGltaXplXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICBpZiAoZm4pIHtcbiAgICAgICAgZm4oe1xuICAgICAgICAgIHJvb3Q6IHJvb3QsXG4gICAgICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgICAgIGFjdGlvbnM6IGFjdGlvbnMsXG4gICAgICAgICAgdGltZXN0YW1wOiB0aW1lc3RhbXAsXG4gICAgICAgICAgc2hvdWxkT3B0aW1pemU6IHNob3VsZE9wdGltaXplXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgdmFyIGluc2VydEJlZm9yZSA9IGZ1bmN0aW9uIGluc2VydEJlZm9yZShuZXdOb2RlLCByZWZlcmVuY2VOb2RlKSB7XG4gICAgcmV0dXJuIHJlZmVyZW5jZU5vZGUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobmV3Tm9kZSwgcmVmZXJlbmNlTm9kZSk7XG4gIH07XG5cbiAgdmFyIGluc2VydEFmdGVyID0gZnVuY3Rpb24gaW5zZXJ0QWZ0ZXIobmV3Tm9kZSwgcmVmZXJlbmNlTm9kZSkge1xuICAgIHJldHVybiByZWZlcmVuY2VOb2RlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKFxuICAgICAgbmV3Tm9kZSxcbiAgICAgIHJlZmVyZW5jZU5vZGUubmV4dFNpYmxpbmdcbiAgICApO1xuICB9O1xuXG4gIHZhciBpc0FycmF5ID0gZnVuY3Rpb24gaXNBcnJheSh2YWx1ZSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKTtcbiAgfTtcblxuICB2YXIgaXNFbXB0eSA9IGZ1bmN0aW9uIGlzRW1wdHkodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT0gbnVsbDtcbiAgfTtcblxuICB2YXIgdHJpbSA9IGZ1bmN0aW9uIHRyaW0oc3RyKSB7XG4gICAgcmV0dXJuIHN0ci50cmltKCk7XG4gIH07XG5cbiAgdmFyIHRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcodmFsdWUpIHtcbiAgICByZXR1cm4gJycgKyB2YWx1ZTtcbiAgfTtcblxuICB2YXIgdG9BcnJheSA9IGZ1bmN0aW9uIHRvQXJyYXkodmFsdWUpIHtcbiAgICB2YXIgc3BsaXR0ZXIgPVxuICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAnLCc7XG4gICAgaWYgKGlzRW1wdHkodmFsdWUpKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gdG9TdHJpbmcodmFsdWUpXG4gICAgICAuc3BsaXQoc3BsaXR0ZXIpXG4gICAgICAubWFwKHRyaW0pXG4gICAgICAuZmlsdGVyKGZ1bmN0aW9uKHN0cikge1xuICAgICAgICByZXR1cm4gc3RyLmxlbmd0aDtcbiAgICAgIH0pO1xuICB9O1xuXG4gIHZhciBpc0Jvb2xlYW4gPSBmdW5jdGlvbiBpc0Jvb2xlYW4odmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbic7XG4gIH07XG5cbiAgdmFyIHRvQm9vbGVhbiA9IGZ1bmN0aW9uIHRvQm9vbGVhbih2YWx1ZSkge1xuICAgIHJldHVybiBpc0Jvb2xlYW4odmFsdWUpID8gdmFsdWUgOiB2YWx1ZSA9PT0gJ3RydWUnO1xuICB9O1xuXG4gIHZhciBpc1N0cmluZyA9IGZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZyc7XG4gIH07XG5cbiAgdmFyIHRvTnVtYmVyID0gZnVuY3Rpb24gdG9OdW1iZXIodmFsdWUpIHtcbiAgICByZXR1cm4gaXNOdW1iZXIodmFsdWUpXG4gICAgICA/IHZhbHVlXG4gICAgICA6IGlzU3RyaW5nKHZhbHVlKVxuICAgICAgPyB0b1N0cmluZyh2YWx1ZSkucmVwbGFjZSgvW2Etel0rL2dpLCAnJylcbiAgICAgIDogMDtcbiAgfTtcblxuICB2YXIgdG9JbnQgPSBmdW5jdGlvbiB0b0ludCh2YWx1ZSkge1xuICAgIHJldHVybiBwYXJzZUludCh0b051bWJlcih2YWx1ZSksIDEwKTtcbiAgfTtcblxuICB2YXIgdG9GbG9hdCA9IGZ1bmN0aW9uIHRvRmxvYXQodmFsdWUpIHtcbiAgICByZXR1cm4gcGFyc2VGbG9hdCh0b051bWJlcih2YWx1ZSkpO1xuICB9O1xuXG4gIHZhciBpc0ludCA9IGZ1bmN0aW9uIGlzSW50KHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzTnVtYmVyKHZhbHVlKSAmJiBpc0Zpbml0ZSh2YWx1ZSkgJiYgTWF0aC5mbG9vcih2YWx1ZSkgPT09IHZhbHVlO1xuICB9O1xuXG4gIHZhciB0b0J5dGVzID0gZnVuY3Rpb24gdG9CeXRlcyh2YWx1ZSkge1xuICAgIHZhciBiYXNlID1cbiAgICAgIGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMTAwMDtcbiAgICAvLyBpcyBpbiBieXRlc1xuICAgIGlmIChpc0ludCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvLyBpcyBuYXR1cmFsIGZpbGUgc2l6ZVxuICAgIHZhciBuYXR1cmFsRmlsZVNpemUgPSB0b1N0cmluZyh2YWx1ZSkudHJpbSgpO1xuXG4gICAgLy8gaWYgaXMgdmFsdWUgaW4gbWVnYWJ5dGVzXG4gICAgaWYgKC9NQiQvaS50ZXN0KG5hdHVyYWxGaWxlU2l6ZSkpIHtcbiAgICAgIG5hdHVyYWxGaWxlU2l6ZSA9IG5hdHVyYWxGaWxlU2l6ZS5yZXBsYWNlKC9NQiRpLywgJycpLnRyaW0oKTtcbiAgICAgIHJldHVybiB0b0ludChuYXR1cmFsRmlsZVNpemUpICogYmFzZSAqIGJhc2U7XG4gICAgfVxuXG4gICAgLy8gaWYgaXMgdmFsdWUgaW4ga2lsb2J5dGVzXG4gICAgaWYgKC9LQi9pLnRlc3QobmF0dXJhbEZpbGVTaXplKSkge1xuICAgICAgbmF0dXJhbEZpbGVTaXplID0gbmF0dXJhbEZpbGVTaXplLnJlcGxhY2UoL0tCJGkvLCAnJykudHJpbSgpO1xuICAgICAgcmV0dXJuIHRvSW50KG5hdHVyYWxGaWxlU2l6ZSkgKiBiYXNlO1xuICAgIH1cblxuICAgIHJldHVybiB0b0ludChuYXR1cmFsRmlsZVNpemUpO1xuICB9O1xuXG4gIHZhciBpc0Z1bmN0aW9uID0gZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbic7XG4gIH07XG5cbiAgdmFyIHRvRnVuY3Rpb25SZWZlcmVuY2UgPSBmdW5jdGlvbiB0b0Z1bmN0aW9uUmVmZXJlbmNlKHN0cmluZykge1xuICAgIHZhciByZWYgPSBzZWxmO1xuICAgIHZhciBsZXZlbHMgPSBzdHJpbmcuc3BsaXQoJy4nKTtcbiAgICB2YXIgbGV2ZWwgPSBudWxsO1xuICAgIHdoaWxlICgobGV2ZWwgPSBsZXZlbHMuc2hpZnQoKSkpIHtcbiAgICAgIHJlZiA9IHJlZltsZXZlbF07XG4gICAgICBpZiAoIXJlZikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlZjtcbiAgfTtcblxuICB2YXIgbWV0aG9kcyA9IHtcbiAgICBwcm9jZXNzOiAnUE9TVCcsXG4gICAgcGF0Y2g6ICdQQVRDSCcsXG4gICAgcmV2ZXJ0OiAnREVMRVRFJyxcbiAgICBmZXRjaDogJ0dFVCcsXG4gICAgcmVzdG9yZTogJ0dFVCcsXG4gICAgbG9hZDogJ0dFVCdcbiAgfTtcblxuICB2YXIgY3JlYXRlU2VydmVyQVBJID0gZnVuY3Rpb24gY3JlYXRlU2VydmVyQVBJKG91dGxpbmUpIHtcbiAgICB2YXIgYXBpID0ge307XG5cbiAgICBhcGkudXJsID0gaXNTdHJpbmcob3V0bGluZSkgPyBvdXRsaW5lIDogb3V0bGluZS51cmwgfHwgJyc7XG4gICAgYXBpLnRpbWVvdXQgPSBvdXRsaW5lLnRpbWVvdXQgPyBwYXJzZUludChvdXRsaW5lLnRpbWVvdXQsIDEwKSA6IDA7XG4gICAgYXBpLmhlYWRlcnMgPSBvdXRsaW5lLmhlYWRlcnMgPyBvdXRsaW5lLmhlYWRlcnMgOiB7fTtcblxuICAgIGZvcmluKG1ldGhvZHMsIGZ1bmN0aW9uKGtleSkge1xuICAgICAgYXBpW2tleV0gPSBjcmVhdGVBY3Rpb24oXG4gICAgICAgIGtleSxcbiAgICAgICAgb3V0bGluZVtrZXldLFxuICAgICAgICBtZXRob2RzW2tleV0sXG4gICAgICAgIGFwaS50aW1lb3V0LFxuICAgICAgICBhcGkuaGVhZGVyc1xuICAgICAgKTtcbiAgICB9KTtcblxuICAgIC8vIHNwZWNpYWwgdHJlYXRtZW50IGZvciByZW1vdmVcbiAgICBhcGkucmVtb3ZlID0gb3V0bGluZS5yZW1vdmUgfHwgbnVsbDtcblxuICAgIC8vIHJlbW92ZSBnZW5lcmljIGhlYWRlcnMgZnJvbSBhcGkgb2JqZWN0XG4gICAgZGVsZXRlIGFwaS5oZWFkZXJzO1xuXG4gICAgcmV0dXJuIGFwaTtcbiAgfTtcblxuICB2YXIgY3JlYXRlQWN0aW9uID0gZnVuY3Rpb24gY3JlYXRlQWN0aW9uKFxuICAgIG5hbWUsXG4gICAgb3V0bGluZSxcbiAgICBtZXRob2QsXG4gICAgdGltZW91dCxcbiAgICBoZWFkZXJzXG4gICkge1xuICAgIC8vIGlzIGV4cGxpY2l0ZWx5IHNldCB0byBudWxsIHNvIGRpc2FibGVcbiAgICBpZiAob3V0bGluZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gaWYgaXMgY3VzdG9tIGZ1bmN0aW9uLCBkb25lISBEZXYgaGFuZGxlcyBldmVyeXRoaW5nLlxuICAgIGlmICh0eXBlb2Ygb3V0bGluZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIG91dGxpbmU7XG4gICAgfVxuXG4gICAgLy8gYnVpbGQgYWN0aW9uIG9iamVjdFxuICAgIHZhciBhY3Rpb24gPSB7XG4gICAgICB1cmw6IG1ldGhvZCA9PT0gJ0dFVCcgfHwgbWV0aG9kID09PSAnUEFUQ0gnID8gJz8nICsgbmFtZSArICc9JyA6ICcnLFxuICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICBoZWFkZXJzOiBoZWFkZXJzLFxuICAgICAgd2l0aENyZWRlbnRpYWxzOiBmYWxzZSxcbiAgICAgIHRpbWVvdXQ6IHRpbWVvdXQsXG4gICAgICBvbmxvYWQ6IG51bGwsXG4gICAgICBvbmRhdGE6IG51bGwsXG4gICAgICBvbmVycm9yOiBudWxsXG4gICAgfTtcblxuICAgIC8vIGlzIGEgc2luZ2xlIHVybFxuICAgIGlmIChpc1N0cmluZyhvdXRsaW5lKSkge1xuICAgICAgYWN0aW9uLnVybCA9IG91dGxpbmU7XG4gICAgICByZXR1cm4gYWN0aW9uO1xuICAgIH1cblxuICAgIC8vIG92ZXJ3cml0ZVxuICAgIE9iamVjdC5hc3NpZ24oYWN0aW9uLCBvdXRsaW5lKTtcblxuICAgIC8vIHNlZSBpZiBzaG91bGQgcmVmb3JtYXQgaGVhZGVycztcbiAgICBpZiAoaXNTdHJpbmcoYWN0aW9uLmhlYWRlcnMpKSB7XG4gICAgICB2YXIgcGFydHMgPSBhY3Rpb24uaGVhZGVycy5zcGxpdCgvOiguKykvKTtcbiAgICAgIGFjdGlvbi5oZWFkZXJzID0ge1xuICAgICAgICBoZWFkZXI6IHBhcnRzWzBdLFxuICAgICAgICB2YWx1ZTogcGFydHNbMV1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gaWYgaXMgYm9vbCB3aXRoQ3JlZGVudGlhbHNcbiAgICBhY3Rpb24ud2l0aENyZWRlbnRpYWxzID0gdG9Cb29sZWFuKGFjdGlvbi53aXRoQ3JlZGVudGlhbHMpO1xuXG4gICAgcmV0dXJuIGFjdGlvbjtcbiAgfTtcblxuICB2YXIgdG9TZXJ2ZXJBUEkgPSBmdW5jdGlvbiB0b1NlcnZlckFQSSh2YWx1ZSkge1xuICAgIHJldHVybiBjcmVhdGVTZXJ2ZXJBUEkodmFsdWUpO1xuICB9O1xuXG4gIHZhciBpc051bGwgPSBmdW5jdGlvbiBpc051bGwodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IG51bGw7XG4gIH07XG5cbiAgdmFyIGlzT2JqZWN0ID0gZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbDtcbiAgfTtcblxuICB2YXIgaXNBUEkgPSBmdW5jdGlvbiBpc0FQSSh2YWx1ZSkge1xuICAgIHJldHVybiAoXG4gICAgICBpc09iamVjdCh2YWx1ZSkgJiZcbiAgICAgIGlzU3RyaW5nKHZhbHVlLnVybCkgJiZcbiAgICAgIGlzT2JqZWN0KHZhbHVlLnByb2Nlc3MpICYmXG4gICAgICBpc09iamVjdCh2YWx1ZS5yZXZlcnQpICYmXG4gICAgICBpc09iamVjdCh2YWx1ZS5yZXN0b3JlKSAmJlxuICAgICAgaXNPYmplY3QodmFsdWUuZmV0Y2gpXG4gICAgKTtcbiAgfTtcblxuICB2YXIgZ2V0VHlwZSA9IGZ1bmN0aW9uIGdldFR5cGUodmFsdWUpIHtcbiAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiAnYXJyYXknO1xuICAgIH1cblxuICAgIGlmIChpc051bGwodmFsdWUpKSB7XG4gICAgICByZXR1cm4gJ251bGwnO1xuICAgIH1cblxuICAgIGlmIChpc0ludCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiAnaW50JztcbiAgICB9XG5cbiAgICBpZiAoL15bMC05XSsgPyg/OkdCfE1CfEtCKSQvZ2kudGVzdCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiAnYnl0ZXMnO1xuICAgIH1cblxuICAgIGlmIChpc0FQSSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiAnYXBpJztcbiAgICB9XG5cbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlO1xuICB9O1xuXG4gIHZhciByZXBsYWNlU2luZ2xlUXVvdGVzID0gZnVuY3Rpb24gcmVwbGFjZVNpbmdsZVF1b3RlcyhzdHIpIHtcbiAgICByZXR1cm4gc3RyXG4gICAgICAucmVwbGFjZSgve1xccyonL2csICd7XCInKVxuICAgICAgLnJlcGxhY2UoLydcXHMqfS9nLCAnXCJ9JylcbiAgICAgIC5yZXBsYWNlKC8nXFxzKjovZywgJ1wiOicpXG4gICAgICAucmVwbGFjZSgvOlxccyonL2csICc6XCInKVxuICAgICAgLnJlcGxhY2UoLyxcXHMqJy9nLCAnLFwiJylcbiAgICAgIC5yZXBsYWNlKC8nXFxzKiwvZywgJ1wiLCcpO1xuICB9O1xuXG4gIHZhciBjb252ZXJzaW9uVGFibGUgPSB7XG4gICAgYXJyYXk6IHRvQXJyYXksXG4gICAgYm9vbGVhbjogdG9Cb29sZWFuLFxuICAgIGludDogZnVuY3Rpb24gaW50KHZhbHVlKSB7XG4gICAgICByZXR1cm4gZ2V0VHlwZSh2YWx1ZSkgPT09ICdieXRlcycgPyB0b0J5dGVzKHZhbHVlKSA6IHRvSW50KHZhbHVlKTtcbiAgICB9LFxuICAgIG51bWJlcjogdG9GbG9hdCxcbiAgICBmbG9hdDogdG9GbG9hdCxcbiAgICBieXRlczogdG9CeXRlcyxcbiAgICBzdHJpbmc6IGZ1bmN0aW9uIHN0cmluZyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzRnVuY3Rpb24odmFsdWUpID8gdmFsdWUgOiB0b1N0cmluZyh2YWx1ZSk7XG4gICAgfSxcbiAgICBmdW5jdGlvbjogZnVuY3Rpb24gX2Z1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdG9GdW5jdGlvblJlZmVyZW5jZSh2YWx1ZSk7XG4gICAgfSxcbiAgICBzZXJ2ZXJhcGk6IHRvU2VydmVyQVBJLFxuICAgIG9iamVjdDogZnVuY3Rpb24gb2JqZWN0KHZhbHVlKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShyZXBsYWNlU2luZ2xlUXVvdGVzKHZhbHVlKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgY29udmVydFRvID0gZnVuY3Rpb24gY29udmVydFRvKHZhbHVlLCB0eXBlKSB7XG4gICAgcmV0dXJuIGNvbnZlcnNpb25UYWJsZVt0eXBlXSh2YWx1ZSk7XG4gIH07XG5cbiAgdmFyIGdldFZhbHVlQnlUeXBlID0gZnVuY3Rpb24gZ2V0VmFsdWVCeVR5cGUoXG4gICAgbmV3VmFsdWUsXG4gICAgZGVmYXVsdFZhbHVlLFxuICAgIHZhbHVlVHlwZVxuICApIHtcbiAgICAvLyBjYW4gYWx3YXlzIGFzc2lnbiBkZWZhdWx0IHZhbHVlXG4gICAgaWYgKG5ld1ZhbHVlID09PSBkZWZhdWx0VmFsdWUpIHtcbiAgICAgIHJldHVybiBuZXdWYWx1ZTtcbiAgICB9XG5cbiAgICAvLyBnZXQgdGhlIHR5cGUgb2YgdGhlIG5ldyB2YWx1ZVxuICAgIHZhciBuZXdWYWx1ZVR5cGUgPSBnZXRUeXBlKG5ld1ZhbHVlKTtcblxuICAgIC8vIGlzIHZhbGlkIHR5cGU/XG4gICAgaWYgKG5ld1ZhbHVlVHlwZSAhPT0gdmFsdWVUeXBlKSB7XG4gICAgICAvLyBpcyBzdHJpbmcgaW5wdXQsIGxldCdzIGF0dGVtcHQgdG8gY29udmVydFxuICAgICAgdmFyIGNvbnZlcnRlZFZhbHVlID0gY29udmVydFRvKG5ld1ZhbHVlLCB2YWx1ZVR5cGUpO1xuXG4gICAgICAvLyB3aGF0IGlzIHRoZSB0eXBlIG5vd1xuICAgICAgbmV3VmFsdWVUeXBlID0gZ2V0VHlwZShjb252ZXJ0ZWRWYWx1ZSk7XG5cbiAgICAgIC8vIG5vIHZhbGlkIGNvbnZlcnNpb25zIGZvdW5kXG4gICAgICBpZiAoY29udmVydGVkVmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgJ1RyeWluZyB0byBhc3NpZ24gdmFsdWUgd2l0aCBpbmNvcnJlY3QgdHlwZSB0byBcIicgK1xuICAgICAgICAgIG9wdGlvbiArXG4gICAgICAgICAgJ1wiLCBhbGxvd2VkIHR5cGU6IFwiJyArXG4gICAgICAgICAgdmFsdWVUeXBlICtcbiAgICAgICAgICAnXCInO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3VmFsdWUgPSBjb252ZXJ0ZWRWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhc3NpZ24gbmV3IHZhbHVlXG4gICAgcmV0dXJuIG5ld1ZhbHVlO1xuICB9O1xuXG4gIHZhciBjcmVhdGVPcHRpb24gPSBmdW5jdGlvbiBjcmVhdGVPcHRpb24oZGVmYXVsdFZhbHVlLCB2YWx1ZVR5cGUpIHtcbiAgICB2YXIgY3VycmVudFZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICAgIHJldHVybiB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBjdXJyZW50VmFsdWU7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQobmV3VmFsdWUpIHtcbiAgICAgICAgY3VycmVudFZhbHVlID0gZ2V0VmFsdWVCeVR5cGUobmV3VmFsdWUsIGRlZmF1bHRWYWx1ZSwgdmFsdWVUeXBlKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIHZhciBjcmVhdGVPcHRpb25zID0gZnVuY3Rpb24gY3JlYXRlT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgdmFyIG9iaiA9IHt9O1xuICAgIGZvcmluKG9wdGlvbnMsIGZ1bmN0aW9uKHByb3ApIHtcbiAgICAgIHZhciBvcHRpb25EZWZpbml0aW9uID0gb3B0aW9uc1twcm9wXTtcbiAgICAgIG9ialtwcm9wXSA9IGNyZWF0ZU9wdGlvbihvcHRpb25EZWZpbml0aW9uWzBdLCBvcHRpb25EZWZpbml0aW9uWzFdKTtcbiAgICB9KTtcbiAgICByZXR1cm4gY3JlYXRlT2JqZWN0KG9iaik7XG4gIH07XG5cbiAgdmFyIGNyZWF0ZUluaXRpYWxTdGF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZUluaXRpYWxTdGF0ZShvcHRpb25zKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC8vIG1vZGVsXG4gICAgICBpdGVtczogW10sXG5cbiAgICAgIC8vIHRpbWVvdXQgdXNlZCBmb3IgY2FsbGluZyB1cGRhdGUgaXRlbXNcbiAgICAgIGxpc3RVcGRhdGVUaW1lb3V0OiBudWxsLFxuXG4gICAgICAvLyB0aW1lb3V0IHVzZWQgZm9yIHN0YWNraW5nIG1ldGFkYXRhIHVwZGF0ZXNcbiAgICAgIGl0ZW1VcGRhdGVUaW1lb3V0OiBudWxsLFxuXG4gICAgICAvLyBxdWV1ZSBvZiBpdGVtcyB3YWl0aW5nIHRvIGJlIHByb2Nlc3NlZFxuICAgICAgcHJvY2Vzc2luZ1F1ZXVlOiBbXSxcblxuICAgICAgLy8gb3B0aW9uc1xuICAgICAgb3B0aW9uczogY3JlYXRlT3B0aW9ucyhvcHRpb25zKVxuICAgIH07XG4gIH07XG5cbiAgdmFyIGZyb21DYW1lbHMgPSBmdW5jdGlvbiBmcm9tQ2FtZWxzKHN0cmluZykge1xuICAgIHZhciBzZXBhcmF0b3IgPVxuICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAnLSc7XG4gICAgcmV0dXJuIHN0cmluZ1xuICAgICAgLnNwbGl0KC8oPz1bQS1aXSkvKVxuICAgICAgLm1hcChmdW5jdGlvbihwYXJ0KSB7XG4gICAgICAgIHJldHVybiBwYXJ0LnRvTG93ZXJDYXNlKCk7XG4gICAgICB9KVxuICAgICAgLmpvaW4oc2VwYXJhdG9yKTtcbiAgfTtcblxuICB2YXIgY3JlYXRlT3B0aW9uQVBJID0gZnVuY3Rpb24gY3JlYXRlT3B0aW9uQVBJKHN0b3JlLCBvcHRpb25zKSB7XG4gICAgdmFyIG9iaiA9IHt9O1xuICAgIGZvcmluKG9wdGlvbnMsIGZ1bmN0aW9uKGtleSkge1xuICAgICAgb2JqW2tleV0gPSB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHJldHVybiBzdG9yZS5nZXRTdGF0ZSgpLm9wdGlvbnNba2V5XTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgICBzdG9yZS5kaXNwYXRjaCgnU0VUXycgKyBmcm9tQ2FtZWxzKGtleSwgJ18nKS50b1VwcGVyQ2FzZSgpLCB7XG4gICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gb2JqO1xuICB9O1xuXG4gIHZhciBjcmVhdGVPcHRpb25BY3Rpb25zID0gZnVuY3Rpb24gY3JlYXRlT3B0aW9uQWN0aW9ucyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGRpc3BhdGNoLCBxdWVyeSwgc3RhdGUpIHtcbiAgICAgIHZhciBvYmogPSB7fTtcbiAgICAgIGZvcmluKG9wdGlvbnMsIGZ1bmN0aW9uKGtleSkge1xuICAgICAgICB2YXIgbmFtZSA9IGZyb21DYW1lbHMoa2V5LCAnXycpLnRvVXBwZXJDYXNlKCk7XG5cbiAgICAgICAgb2JqWydTRVRfJyArIG5hbWVdID0gZnVuY3Rpb24oYWN0aW9uKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHN0YXRlLm9wdGlvbnNba2V5XSA9IGFjdGlvbi52YWx1ZTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7fSAvLyBub3BlLCBmYWlsZWRcblxuICAgICAgICAgIC8vIHdlIHN1Y2Nlc3NmdWxseSBzZXQgdGhlIHZhbHVlIG9mIHRoaXMgb3B0aW9uXG4gICAgICAgICAgZGlzcGF0Y2goJ0RJRF9TRVRfJyArIG5hbWUsIHsgdmFsdWU6IHN0YXRlLm9wdGlvbnNba2V5XSB9KTtcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBjcmVhdGVPcHRpb25RdWVyaWVzID0gZnVuY3Rpb24gY3JlYXRlT3B0aW9uUXVlcmllcyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgICB2YXIgb2JqID0ge307XG4gICAgICBmb3JpbihvcHRpb25zLCBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgb2JqWydHRVRfJyArIGZyb21DYW1lbHMoa2V5LCAnXycpLnRvVXBwZXJDYXNlKCldID0gZnVuY3Rpb24oYWN0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIHN0YXRlLm9wdGlvbnNba2V5XTtcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBJbnRlcmFjdGlvbk1ldGhvZCA9IHtcbiAgICBBUEk6IDEsXG4gICAgRFJPUDogMixcbiAgICBCUk9XU0U6IDMsXG4gICAgUEFTVEU6IDQsXG4gICAgTk9ORTogNVxuICB9O1xuXG4gIHZhciBnZXRVbmlxdWVJZCA9IGZ1bmN0aW9uIGdldFVuaXF1ZUlkKCkge1xuICAgIHJldHVybiBNYXRoLnJhbmRvbSgpXG4gICAgICAudG9TdHJpbmcoMzYpXG4gICAgICAuc3Vic3RyKDIsIDkpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgIF90eXBlb2YgPSBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBfdHlwZW9mID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogJiZcbiAgICAgICAgICB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICAgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiZcbiAgICAgICAgICBvYmogIT09IFN5bWJvbC5wcm90b3R5cGVcbiAgICAgICAgICA/ICdzeW1ib2wnXG4gICAgICAgICAgOiB0eXBlb2Ygb2JqO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3R5cGVvZihvYmopO1xuICB9XG5cbiAgdmFyIFJFQUNUX0VMRU1FTlRfVFlQRTtcblxuICBmdW5jdGlvbiBfanN4KHR5cGUsIHByb3BzLCBrZXksIGNoaWxkcmVuKSB7XG4gICAgaWYgKCFSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgIFJFQUNUX0VMRU1FTlRfVFlQRSA9XG4gICAgICAgICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICAgU3ltYm9sWydmb3InXSAmJlxuICAgICAgICAgIFN5bWJvbFsnZm9yJ10oJ3JlYWN0LmVsZW1lbnQnKSkgfHxcbiAgICAgICAgMHhlYWM3O1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0UHJvcHMgPSB0eXBlICYmIHR5cGUuZGVmYXVsdFByb3BzO1xuICAgIHZhciBjaGlsZHJlbkxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggLSAzO1xuXG4gICAgaWYgKCFwcm9wcyAmJiBjaGlsZHJlbkxlbmd0aCAhPT0gMCkge1xuICAgICAgcHJvcHMgPSB7XG4gICAgICAgIGNoaWxkcmVuOiB2b2lkIDBcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKHByb3BzICYmIGRlZmF1bHRQcm9wcykge1xuICAgICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gZGVmYXVsdFByb3BzKSB7XG4gICAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IHZvaWQgMCkge1xuICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFwcm9wcykge1xuICAgICAgcHJvcHMgPSBkZWZhdWx0UHJvcHMgfHwge307XG4gICAgfVxuXG4gICAgaWYgKGNoaWxkcmVuTGVuZ3RoID09PSAxKSB7XG4gICAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgIH0gZWxzZSBpZiAoY2hpbGRyZW5MZW5ndGggPiAxKSB7XG4gICAgICB2YXIgY2hpbGRBcnJheSA9IG5ldyBBcnJheShjaGlsZHJlbkxlbmd0aCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW5MZW5ndGg7IGkrKykge1xuICAgICAgICBjaGlsZEFycmF5W2ldID0gYXJndW1lbnRzW2kgKyAzXTtcbiAgICAgIH1cblxuICAgICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZEFycmF5O1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAkJHR5cGVvZjogUkVBQ1RfRUxFTUVOVF9UWVBFLFxuICAgICAgdHlwZTogdHlwZSxcbiAgICAgIGtleToga2V5ID09PSB1bmRlZmluZWQgPyBudWxsIDogJycgKyBrZXksXG4gICAgICByZWY6IG51bGwsXG4gICAgICBwcm9wczogcHJvcHMsXG4gICAgICBfb3duZXI6IG51bGxcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gX2FzeW5jSXRlcmF0b3IoaXRlcmFibGUpIHtcbiAgICB2YXIgbWV0aG9kO1xuXG4gICAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBpZiAoU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHtcbiAgICAgICAgbWV0aG9kID0gaXRlcmFibGVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdO1xuICAgICAgICBpZiAobWV0aG9kICE9IG51bGwpIHJldHVybiBtZXRob2QuY2FsbChpdGVyYWJsZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChTeW1ib2wuaXRlcmF0b3IpIHtcbiAgICAgICAgbWV0aG9kID0gaXRlcmFibGVbU3ltYm9sLml0ZXJhdG9yXTtcbiAgICAgICAgaWYgKG1ldGhvZCAhPSBudWxsKSByZXR1cm4gbWV0aG9kLmNhbGwoaXRlcmFibGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdCBpcyBub3QgYXN5bmMgaXRlcmFibGUnKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9Bd2FpdFZhbHVlKHZhbHVlKSB7XG4gICAgdGhpcy53cmFwcGVkID0gdmFsdWU7XG4gIH1cblxuICBmdW5jdGlvbiBfQXN5bmNHZW5lcmF0b3IoZ2VuKSB7XG4gICAgdmFyIGZyb250LCBiYWNrO1xuXG4gICAgZnVuY3Rpb24gc2VuZChrZXksIGFyZykge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB2YXIgcmVxdWVzdCA9IHtcbiAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICBhcmc6IGFyZyxcbiAgICAgICAgICByZXNvbHZlOiByZXNvbHZlLFxuICAgICAgICAgIHJlamVjdDogcmVqZWN0LFxuICAgICAgICAgIG5leHQ6IG51bGxcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoYmFjaykge1xuICAgICAgICAgIGJhY2sgPSBiYWNrLm5leHQgPSByZXF1ZXN0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZyb250ID0gYmFjayA9IHJlcXVlc3Q7XG4gICAgICAgICAgcmVzdW1lKGtleSwgYXJnKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVzdW1lKGtleSwgYXJnKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gZ2VuW2tleV0oYXJnKTtcbiAgICAgICAgdmFyIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICB2YXIgd3JhcHBlZEF3YWl0ID0gdmFsdWUgaW5zdGFuY2VvZiBfQXdhaXRWYWx1ZTtcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKHdyYXBwZWRBd2FpdCA/IHZhbHVlLndyYXBwZWQgOiB2YWx1ZSkudGhlbihcbiAgICAgICAgICBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgICAgIGlmICh3cmFwcGVkQXdhaXQpIHtcbiAgICAgICAgICAgICAgcmVzdW1lKCduZXh0JywgYXJnKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZXR0bGUocmVzdWx0LmRvbmUgPyAncmV0dXJuJyA6ICdub3JtYWwnLCBhcmcpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICByZXN1bWUoJ3Rocm93JywgZXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgc2V0dGxlKCd0aHJvdycsIGVycik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0dGxlKHR5cGUsIHZhbHVlKSB7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAncmV0dXJuJzpcbiAgICAgICAgICBmcm9udC5yZXNvbHZlKHtcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIGRvbmU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICd0aHJvdyc6XG4gICAgICAgICAgZnJvbnQucmVqZWN0KHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGZyb250LnJlc29sdmUoe1xuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgZnJvbnQgPSBmcm9udC5uZXh0O1xuXG4gICAgICBpZiAoZnJvbnQpIHtcbiAgICAgICAgcmVzdW1lKGZyb250LmtleSwgZnJvbnQuYXJnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJhY2sgPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX2ludm9rZSA9IHNlbmQ7XG5cbiAgICBpZiAodHlwZW9mIGdlbi5yZXR1cm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMucmV0dXJuID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5hc3luY0l0ZXJhdG9yKSB7XG4gICAgX0FzeW5jR2VuZXJhdG9yLnByb3RvdHlwZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gIH1cblxuICBfQXN5bmNHZW5lcmF0b3IucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gdGhpcy5faW52b2tlKCduZXh0JywgYXJnKTtcbiAgfTtcblxuICBfQXN5bmNHZW5lcmF0b3IucHJvdG90eXBlLnRocm93ID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ludm9rZSgndGhyb3cnLCBhcmcpO1xuICB9O1xuXG4gIF9Bc3luY0dlbmVyYXRvci5wcm90b3R5cGUucmV0dXJuID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ludm9rZSgncmV0dXJuJywgYXJnKTtcbiAgfTtcblxuICBmdW5jdGlvbiBfd3JhcEFzeW5jR2VuZXJhdG9yKGZuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG5ldyBfQXN5bmNHZW5lcmF0b3IoZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9hd2FpdEFzeW5jR2VuZXJhdG9yKHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBfQXdhaXRWYWx1ZSh2YWx1ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBfYXN5bmNHZW5lcmF0b3JEZWxlZ2F0ZShpbm5lciwgYXdhaXRXcmFwKSB7XG4gICAgdmFyIGl0ZXIgPSB7fSxcbiAgICAgIHdhaXRpbmcgPSBmYWxzZTtcblxuICAgIGZ1bmN0aW9uIHB1bXAoa2V5LCB2YWx1ZSkge1xuICAgICAgd2FpdGluZyA9IHRydWU7XG4gICAgICB2YWx1ZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICAgICAgcmVzb2x2ZShpbm5lcltrZXldKHZhbHVlKSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICB2YWx1ZTogYXdhaXRXcmFwKHZhbHVlKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3IpIHtcbiAgICAgIGl0ZXJbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaXRlci5uZXh0ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIGlmICh3YWl0aW5nKSB7XG4gICAgICAgIHdhaXRpbmcgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHVtcCgnbmV4dCcsIHZhbHVlKTtcbiAgICB9O1xuXG4gICAgaWYgKHR5cGVvZiBpbm5lci50aHJvdyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaXRlci50aHJvdyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGlmICh3YWl0aW5nKSB7XG4gICAgICAgICAgd2FpdGluZyA9IGZhbHNlO1xuICAgICAgICAgIHRocm93IHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHB1bXAoJ3Rocm93JywgdmFsdWUpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGlubmVyLnJldHVybiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaXRlci5yZXR1cm4gPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gcHVtcCgncmV0dXJuJywgdmFsdWUpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gaXRlcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywga2V5LCBhcmcpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpO1xuICAgICAgdmFyIHZhbHVlID0gaW5mby52YWx1ZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoaW5mby5kb25lKSB7XG4gICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKF9uZXh0LCBfdGhyb3cpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKGZuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB2YXIgZ2VuID0gZm4uYXBwbHkoc2VsZiwgYXJncyk7XG5cbiAgICAgICAgZnVuY3Rpb24gX25leHQodmFsdWUpIHtcbiAgICAgICAgICBhc3luY0dlbmVyYXRvclN0ZXAoXG4gICAgICAgICAgICBnZW4sXG4gICAgICAgICAgICByZXNvbHZlLFxuICAgICAgICAgICAgcmVqZWN0LFxuICAgICAgICAgICAgX25leHQsXG4gICAgICAgICAgICBfdGhyb3csXG4gICAgICAgICAgICAnbmV4dCcsXG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBfdGhyb3coZXJyKSB7XG4gICAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCAndGhyb3cnLCBlcnIpO1xuICAgICAgICB9XG5cbiAgICAgICAgX25leHQodW5kZWZpbmVkKTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gICAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgaWYgKCd2YWx1ZScgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gIH1cblxuICBmdW5jdGlvbiBfZGVmaW5lRW51bWVyYWJsZVByb3BlcnRpZXMob2JqLCBkZXNjcykge1xuICAgIGZvciAodmFyIGtleSBpbiBkZXNjcykge1xuICAgICAgdmFyIGRlc2MgPSBkZXNjc1trZXldO1xuICAgICAgZGVzYy5jb25maWd1cmFibGUgPSBkZXNjLmVudW1lcmFibGUgPSB0cnVlO1xuICAgICAgaWYgKCd2YWx1ZScgaW4gZGVzYykgZGVzYy53cml0YWJsZSA9IHRydWU7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIGRlc2MpO1xuICAgIH1cblxuICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgICB2YXIgb2JqZWN0U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZGVzY3MpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdFN5bWJvbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHN5bSA9IG9iamVjdFN5bWJvbHNbaV07XG4gICAgICAgIHZhciBkZXNjID0gZGVzY3Nbc3ltXTtcbiAgICAgICAgZGVzYy5jb25maWd1cmFibGUgPSBkZXNjLmVudW1lcmFibGUgPSB0cnVlO1xuICAgICAgICBpZiAoJ3ZhbHVlJyBpbiBkZXNjKSBkZXNjLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgc3ltLCBkZXNjKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgZnVuY3Rpb24gX2RlZmF1bHRzKG9iaiwgZGVmYXVsdHMpIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGRlZmF1bHRzKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICB2YXIgdmFsdWUgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGRlZmF1bHRzLCBrZXkpO1xuXG4gICAgICBpZiAodmFsdWUgJiYgdmFsdWUuY29uZmlndXJhYmxlICYmIG9ialtrZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgICBpZiAoa2V5IGluIG9iaikge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ialtrZXldID0gdmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICAgIF9leHRlbmRzID1cbiAgICAgIE9iamVjdC5hc3NpZ24gfHxcbiAgICAgIGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICB9O1xuXG4gICAgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBmdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTtcbiAgICAgIHZhciBvd25LZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcblxuICAgICAgaWYgKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG93bktleXMgPSBvd25LZXlzLmNvbmNhdChcbiAgICAgICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSkuZmlsdGVyKGZ1bmN0aW9uKHN5bSkge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBzeW0pLmVudW1lcmFibGU7XG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgb3duS2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cblxuICBmdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG5cbiAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgICAgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7XG4gICAgICBpZiAoZW51bWVyYWJsZU9ubHkpXG4gICAgICAgIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbihzeW0pIHtcbiAgICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTtcbiAgICAgICAgfSk7XG4gICAgICBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGtleXM7XG4gIH1cblxuICBmdW5jdGlvbiBfb2JqZWN0U3ByZWFkMih0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307XG5cbiAgICAgIGlmIChpICUgMikge1xuICAgICAgICBvd25LZXlzKHNvdXJjZSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFxuICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvd25LZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoXG4gICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KVxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cblxuICBmdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICdmdW5jdGlvbicgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24nKTtcbiAgICB9XG5cbiAgICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xuICB9XG5cbiAgZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTtcbiAgICBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzcztcbiAgICBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzO1xuICB9XG5cbiAgZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2ZcbiAgICAgID8gT2JqZWN0LmdldFByb3RvdHlwZU9mXG4gICAgICA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgICAgICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgICAgICAgfTtcbiAgICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xuICB9XG5cbiAgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBfc2V0UHJvdG90eXBlT2YgPVxuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgICAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgICAgIHJldHVybiBvO1xuICAgICAgfTtcblxuICAgIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG4gIH1cblxuICBmdW5jdGlvbiBpc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSAndW5kZWZpbmVkJyB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0eXBlb2YgUHJveHkgPT09ICdmdW5jdGlvbicpIHJldHVybiB0cnVlO1xuXG4gICAgdHJ5IHtcbiAgICAgIERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoRGF0ZSwgW10sIGZ1bmN0aW9uKCkge30pKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHtcbiAgICBpZiAoaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkpIHtcbiAgICAgIF9jb25zdHJ1Y3QgPSBSZWZsZWN0LmNvbnN0cnVjdDtcbiAgICB9IGVsc2Uge1xuICAgICAgX2NvbnN0cnVjdCA9IGZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykge1xuICAgICAgICB2YXIgYSA9IFtudWxsXTtcbiAgICAgICAgYS5wdXNoLmFwcGx5KGEsIGFyZ3MpO1xuICAgICAgICB2YXIgQ29uc3RydWN0b3IgPSBGdW5jdGlvbi5iaW5kLmFwcGx5KFBhcmVudCwgYSk7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IG5ldyBDb25zdHJ1Y3RvcigpO1xuICAgICAgICBpZiAoQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihpbnN0YW5jZSwgQ2xhc3MucHJvdG90eXBlKTtcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gX2NvbnN0cnVjdC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgZnVuY3Rpb24gX2lzTmF0aXZlRnVuY3Rpb24oZm4pIHtcbiAgICByZXR1cm4gRnVuY3Rpb24udG9TdHJpbmcuY2FsbChmbikuaW5kZXhPZignW25hdGl2ZSBjb2RlXScpICE9PSAtMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHtcbiAgICB2YXIgX2NhY2hlID0gdHlwZW9mIE1hcCA9PT0gJ2Z1bmN0aW9uJyA/IG5ldyBNYXAoKSA6IHVuZGVmaW5lZDtcblxuICAgIF93cmFwTmF0aXZlU3VwZXIgPSBmdW5jdGlvbiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKSB7XG4gICAgICBpZiAoQ2xhc3MgPT09IG51bGwgfHwgIV9pc05hdGl2ZUZ1bmN0aW9uKENsYXNzKSkgcmV0dXJuIENsYXNzO1xuXG4gICAgICBpZiAodHlwZW9mIENsYXNzICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uJ1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIF9jYWNoZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaWYgKF9jYWNoZS5oYXMoQ2xhc3MpKSByZXR1cm4gX2NhY2hlLmdldChDbGFzcyk7XG5cbiAgICAgICAgX2NhY2hlLnNldChDbGFzcywgV3JhcHBlcik7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIFdyYXBwZXIoKSB7XG4gICAgICAgIHJldHVybiBfY29uc3RydWN0KENsYXNzLCBhcmd1bWVudHMsIF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3Rvcik7XG4gICAgICB9XG5cbiAgICAgIFdyYXBwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDbGFzcy5wcm90b3R5cGUsIHtcbiAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICB2YWx1ZTogV3JhcHBlcixcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gX3NldFByb3RvdHlwZU9mKFdyYXBwZXIsIENsYXNzKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpO1xuICB9XG5cbiAgZnVuY3Rpb24gX2luc3RhbmNlb2YobGVmdCwgcmlnaHQpIHtcbiAgICBpZiAoXG4gICAgICByaWdodCAhPSBudWxsICYmXG4gICAgICB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgcmlnaHRbU3ltYm9sLmhhc0luc3RhbmNlXVxuICAgICkge1xuICAgICAgcmV0dXJuICEhcmlnaHRbU3ltYm9sLmhhc0luc3RhbmNlXShsZWZ0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGxlZnQgaW5zdGFuY2VvZiByaWdodDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICAgIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGVcbiAgICAgID8gb2JqXG4gICAgICA6IHtcbiAgICAgICAgICBkZWZhdWx0OiBvYmpcbiAgICAgICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikge1xuICAgIGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHtcbiAgICAgIHJldHVybiBvYmo7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBuZXdPYmogPSB7fTtcblxuICAgICAgaWYgKG9iaiAhPSBudWxsKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICAgICAgdmFyIGRlc2MgPVxuICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvclxuICAgICAgICAgICAgICAgID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSlcbiAgICAgICAgICAgICAgICA6IHt9O1xuXG4gICAgICAgICAgICBpZiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpIHtcbiAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5ld09ialtrZXldID0gb2JqW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG5ld09iai5kZWZhdWx0ID0gb2JqO1xuICAgICAgcmV0dXJuIG5ld09iajtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBfbmV3QXJyb3dDaGVjayhpbm5lclRoaXMsIGJvdW5kVGhpcykge1xuICAgIGlmIChpbm5lclRoaXMgIT09IGJvdW5kVGhpcykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGluc3RhbnRpYXRlIGFuIGFycm93IGZ1bmN0aW9uJyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX29iamVjdERlc3RydWN0dXJpbmdFbXB0eShvYmopIHtcbiAgICBpZiAob2JqID09IG51bGwpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBkZXN0cnVjdHVyZSB1bmRlZmluZWQnKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgICB2YXIgdGFyZ2V0ID0ge307XG4gICAgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICAgIHZhciBrZXksIGk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAga2V5ID0gc291cmNlS2V5c1tpXTtcbiAgICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cblxuICBmdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkge1xuICAgIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuXG4gICAgdmFyIHRhcmdldCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpO1xuXG4gICAgdmFyIGtleSwgaTtcblxuICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgICB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTtcbiAgICAgICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG5cbiAgZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gICAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFxuICAgICAgICBcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBzZWxmO1xuICB9XG5cbiAgZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICAgIGlmIChjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIGNhbGwgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgICByZXR1cm4gY2FsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9zdXBlclByb3BCYXNlKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgICB3aGlsZSAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkge1xuICAgICAgb2JqZWN0ID0gX2dldFByb3RvdHlwZU9mKG9iamVjdCk7XG4gICAgICBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9XG5cbiAgZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gJ3VuZGVmaW5lZCcgJiYgUmVmbGVjdC5nZXQpIHtcbiAgICAgIF9nZXQgPSBSZWZsZWN0LmdldDtcbiAgICB9IGVsc2Uge1xuICAgICAgX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHtcbiAgICAgICAgdmFyIGJhc2UgPSBfc3VwZXJQcm9wQmFzZSh0YXJnZXQsIHByb3BlcnR5KTtcblxuICAgICAgICBpZiAoIWJhc2UpIHJldHVybjtcbiAgICAgICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2UsIHByb3BlcnR5KTtcblxuICAgICAgICBpZiAoZGVzYy5nZXQpIHtcbiAgICAgICAgICByZXR1cm4gZGVzYy5nZXQuY2FsbChyZWNlaXZlcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGVzYy52YWx1ZTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIgfHwgdGFyZ2V0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldCh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSwgcmVjZWl2ZXIpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgIT09ICd1bmRlZmluZWQnICYmIFJlZmxlY3Quc2V0KSB7XG4gICAgICBzZXQgPSBSZWZsZWN0LnNldDtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0ID0gZnVuY3Rpb24gc2V0KHRhcmdldCwgcHJvcGVydHksIHZhbHVlLCByZWNlaXZlcikge1xuICAgICAgICB2YXIgYmFzZSA9IF9zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpO1xuXG4gICAgICAgIHZhciBkZXNjO1xuXG4gICAgICAgIGlmIChiYXNlKSB7XG4gICAgICAgICAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpO1xuXG4gICAgICAgICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICAgICAgICBkZXNjLnNldC5jYWxsKHJlY2VpdmVyLCB2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFkZXNjLndyaXRhYmxlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocmVjZWl2ZXIsIHByb3BlcnR5KTtcblxuICAgICAgICBpZiAoZGVzYykge1xuICAgICAgICAgIGlmICghZGVzYy53cml0YWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRlc2MudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVjZWl2ZXIsIHByb3BlcnR5LCBkZXNjKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfZGVmaW5lUHJvcGVydHkocmVjZWl2ZXIsIHByb3BlcnR5LCB2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHNldCh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSwgcmVjZWl2ZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gX3NldCh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSwgcmVjZWl2ZXIsIGlzU3RyaWN0KSB7XG4gICAgdmFyIHMgPSBzZXQodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUsIHJlY2VpdmVyIHx8IHRhcmdldCk7XG5cbiAgICBpZiAoIXMgJiYgaXNTdHJpY3QpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZmFpbGVkIHRvIHNldCBwcm9wZXJ0eScpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF90YWdnZWRUZW1wbGF0ZUxpdGVyYWwoc3RyaW5ncywgcmF3KSB7XG4gICAgaWYgKCFyYXcpIHtcbiAgICAgIHJhdyA9IHN0cmluZ3Muc2xpY2UoMCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhzdHJpbmdzLCB7XG4gICAgICAgIHJhdzoge1xuICAgICAgICAgIHZhbHVlOiBPYmplY3QuZnJlZXplKHJhdylcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gX3RhZ2dlZFRlbXBsYXRlTGl0ZXJhbExvb3NlKHN0cmluZ3MsIHJhdykge1xuICAgIGlmICghcmF3KSB7XG4gICAgICByYXcgPSBzdHJpbmdzLnNsaWNlKDApO1xuICAgIH1cblxuICAgIHN0cmluZ3MucmF3ID0gcmF3O1xuICAgIHJldHVybiBzdHJpbmdzO1xuICB9XG5cbiAgZnVuY3Rpb24gX3RlbXBvcmFsUmVmKHZhbCwgbmFtZSkge1xuICAgIGlmICh2YWwgPT09IF90ZW1wb3JhbFVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKG5hbWUgKyAnIGlzIG5vdCBkZWZpbmVkIC0gdGVtcG9yYWwgZGVhZCB6b25lJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX3JlYWRPbmx5RXJyb3IobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignXCInICsgbmFtZSArICdcIiBpcyByZWFkLW9ubHknKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9jbGFzc05hbWVURFpFcnJvcihuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0NsYXNzIFwiJyArIG5hbWUgKyAnXCIgY2Fubm90IGJlIHJlZmVyZW5jZWQgaW4gY29tcHV0ZWQgcHJvcGVydHkga2V5cy4nXG4gICAgKTtcbiAgfVxuXG4gIHZhciBfdGVtcG9yYWxVbmRlZmluZWQgPSB7fTtcblxuICBmdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHtcbiAgICByZXR1cm4gKFxuICAgICAgX2FycmF5V2l0aEhvbGVzKGFycikgfHxcbiAgICAgIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8XG4gICAgICBfbm9uSXRlcmFibGVSZXN0KClcbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXlMb29zZShhcnIsIGkpIHtcbiAgICByZXR1cm4gKFxuICAgICAgX2FycmF5V2l0aEhvbGVzKGFycikgfHxcbiAgICAgIF9pdGVyYWJsZVRvQXJyYXlMaW1pdExvb3NlKGFyciwgaSkgfHxcbiAgICAgIF9ub25JdGVyYWJsZVJlc3QoKVxuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiBfdG9BcnJheShhcnIpIHtcbiAgICByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHtcbiAgICByZXR1cm4gKFxuICAgICAgX2FycmF5V2l0aG91dEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF9ub25JdGVyYWJsZVNwcmVhZCgpXG4gICAgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTsgaSA8IGFyci5sZW5ndGg7IGkrKylcbiAgICAgICAgYXJyMltpXSA9IGFycltpXTtcblxuICAgICAgcmV0dXJuIGFycjI7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7XG4gIH1cblxuICBmdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHtcbiAgICBpZiAoXG4gICAgICBTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGl0ZXIpIHx8XG4gICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaXRlcikgPT09ICdbb2JqZWN0IEFyZ3VtZW50c10nXG4gICAgKVxuICAgICAgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7XG4gIH1cblxuICBmdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7XG4gICAgdmFyIF9hcnIgPSBbXTtcbiAgICB2YXIgX24gPSB0cnVlO1xuICAgIHZhciBfZCA9IGZhbHNlO1xuICAgIHZhciBfZSA9IHVuZGVmaW5lZDtcblxuICAgIHRyeSB7XG4gICAgICBmb3IgKFxuICAgICAgICB2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfcztcbiAgICAgICAgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7XG4gICAgICAgIF9uID0gdHJ1ZVxuICAgICAgKSB7XG4gICAgICAgIF9hcnIucHVzaChfcy52YWx1ZSk7XG5cbiAgICAgICAgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2QgPSB0cnVlO1xuICAgICAgX2UgPSBlcnI7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghX24gJiYgX2lbJ3JldHVybiddICE9IG51bGwpIF9pWydyZXR1cm4nXSgpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKF9kKSB0aHJvdyBfZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gX2FycjtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdExvb3NlKGFyciwgaSkge1xuICAgIHZhciBfYXJyID0gW107XG5cbiAgICBmb3IgKFxuICAgICAgdmFyIF9pdGVyYXRvciA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwO1xuICAgICAgIShfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmU7XG5cbiAgICApIHtcbiAgICAgIF9hcnIucHVzaChfc3RlcC52YWx1ZSk7XG5cbiAgICAgIGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gX2FycjtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZScpO1xuICB9XG5cbiAgZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlJyk7XG4gIH1cblxuICBmdW5jdGlvbiBfc2tpcEZpcnN0R2VuZXJhdG9yTmV4dChmbikge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpdCA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICBpdC5uZXh0KCk7XG4gICAgICByZXR1cm4gaXQ7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF90b1ByaW1pdGl2ZShpbnB1dCwgaGludCkge1xuICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdvYmplY3QnIHx8IGlucHV0ID09PSBudWxsKSByZXR1cm4gaW5wdXQ7XG4gICAgdmFyIHByaW0gPSBpbnB1dFtTeW1ib2wudG9QcmltaXRpdmVdO1xuXG4gICAgaWYgKHByaW0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIHJlcyA9IHByaW0uY2FsbChpbnB1dCwgaGludCB8fCAnZGVmYXVsdCcpO1xuICAgICAgaWYgKHR5cGVvZiByZXMgIT09ICdvYmplY3QnKSByZXR1cm4gcmVzO1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gKGhpbnQgPT09ICdzdHJpbmcnID8gU3RyaW5nIDogTnVtYmVyKShpbnB1dCk7XG4gIH1cblxuICBmdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleShhcmcpIHtcbiAgICB2YXIga2V5ID0gX3RvUHJpbWl0aXZlKGFyZywgJ3N0cmluZycpO1xuXG4gICAgcmV0dXJuIHR5cGVvZiBrZXkgPT09ICdzeW1ib2wnID8ga2V5IDogU3RyaW5nKGtleSk7XG4gIH1cblxuICBmdW5jdGlvbiBfaW5pdGlhbGl6ZXJXYXJuaW5nSGVscGVyKGRlc2NyaXB0b3IsIGNvbnRleHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnRGVjb3JhdGluZyBjbGFzcyBwcm9wZXJ0eSBmYWlsZWQuIFBsZWFzZSBlbnN1cmUgdGhhdCAnICtcbiAgICAgICAgJ3Byb3Bvc2FsLWNsYXNzLXByb3BlcnRpZXMgaXMgZW5hYmxlZCBhbmQgc2V0IHRvIHVzZSBsb29zZSBtb2RlLiAnICtcbiAgICAgICAgJ1RvIHVzZSBwcm9wb3NhbC1jbGFzcy1wcm9wZXJ0aWVzIGluIHNwZWMgbW9kZSB3aXRoIGRlY29yYXRvcnMsIHdhaXQgZm9yICcgK1xuICAgICAgICAndGhlIG5leHQgbWFqb3IgdmVyc2lvbiBvZiBkZWNvcmF0b3JzIGluIHN0YWdlIDIuJ1xuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5LCBkZXNjcmlwdG9yLCBjb250ZXh0KSB7XG4gICAgaWYgKCFkZXNjcmlwdG9yKSByZXR1cm47XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHksIHtcbiAgICAgIGVudW1lcmFibGU6IGRlc2NyaXB0b3IuZW51bWVyYWJsZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogZGVzY3JpcHRvci5jb25maWd1cmFibGUsXG4gICAgICB3cml0YWJsZTogZGVzY3JpcHRvci53cml0YWJsZSxcbiAgICAgIHZhbHVlOiBkZXNjcmlwdG9yLmluaXRpYWxpemVyXG4gICAgICAgID8gZGVzY3JpcHRvci5pbml0aWFsaXplci5jYWxsKGNvbnRleHQpXG4gICAgICAgIDogdm9pZCAwXG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKFxuICAgIHRhcmdldCxcbiAgICBwcm9wZXJ0eSxcbiAgICBkZWNvcmF0b3JzLFxuICAgIGRlc2NyaXB0b3IsXG4gICAgY29udGV4dFxuICApIHtcbiAgICB2YXIgZGVzYyA9IHt9O1xuICAgIE9iamVjdC5rZXlzKGRlc2NyaXB0b3IpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICBkZXNjW2tleV0gPSBkZXNjcmlwdG9yW2tleV07XG4gICAgfSk7XG4gICAgZGVzYy5lbnVtZXJhYmxlID0gISFkZXNjLmVudW1lcmFibGU7XG4gICAgZGVzYy5jb25maWd1cmFibGUgPSAhIWRlc2MuY29uZmlndXJhYmxlO1xuXG4gICAgaWYgKCd2YWx1ZScgaW4gZGVzYyB8fCBkZXNjLmluaXRpYWxpemVyKSB7XG4gICAgICBkZXNjLndyaXRhYmxlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBkZXNjID0gZGVjb3JhdG9yc1xuICAgICAgLnNsaWNlKClcbiAgICAgIC5yZXZlcnNlKClcbiAgICAgIC5yZWR1Y2UoZnVuY3Rpb24oZGVzYywgZGVjb3JhdG9yKSB7XG4gICAgICAgIHJldHVybiBkZWNvcmF0b3IodGFyZ2V0LCBwcm9wZXJ0eSwgZGVzYykgfHwgZGVzYztcbiAgICAgIH0sIGRlc2MpO1xuXG4gICAgaWYgKGNvbnRleHQgJiYgZGVzYy5pbml0aWFsaXplciAhPT0gdm9pZCAwKSB7XG4gICAgICBkZXNjLnZhbHVlID0gZGVzYy5pbml0aWFsaXplciA/IGRlc2MuaW5pdGlhbGl6ZXIuY2FsbChjb250ZXh0KSA6IHZvaWQgMDtcbiAgICAgIGRlc2MuaW5pdGlhbGl6ZXIgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKGRlc2MuaW5pdGlhbGl6ZXIgPT09IHZvaWQgMCkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHksIGRlc2MpO1xuICAgICAgZGVzYyA9IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlc2M7XG4gIH1cblxuICB2YXIgaWQgPSAwO1xuXG4gIGZ1bmN0aW9uIF9jbGFzc1ByaXZhdGVGaWVsZExvb3NlS2V5KG5hbWUpIHtcbiAgICByZXR1cm4gJ19fcHJpdmF0ZV8nICsgaWQrKyArICdfJyArIG5hbWU7XG4gIH1cblxuICBmdW5jdGlvbiBfY2xhc3NQcml2YXRlRmllbGRMb29zZUJhc2UocmVjZWl2ZXIsIHByaXZhdGVLZXkpIHtcbiAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChyZWNlaXZlciwgcHJpdmF0ZUtleSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2F0dGVtcHRlZCB0byB1c2UgcHJpdmF0ZSBmaWVsZCBvbiBub24taW5zdGFuY2UnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVjZWl2ZXI7XG4gIH1cblxuICBmdW5jdGlvbiBfY2xhc3NQcml2YXRlRmllbGRHZXQocmVjZWl2ZXIsIHByaXZhdGVNYXApIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByaXZhdGVNYXAuZ2V0KHJlY2VpdmVyKTtcblxuICAgIGlmICghZGVzY3JpcHRvcikge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXR0ZW1wdGVkIHRvIGdldCBwcml2YXRlIGZpZWxkIG9uIG5vbi1pbnN0YW5jZScpO1xuICAgIH1cblxuICAgIGlmIChkZXNjcmlwdG9yLmdldCkge1xuICAgICAgcmV0dXJuIGRlc2NyaXB0b3IuZ2V0LmNhbGwocmVjZWl2ZXIpO1xuICAgIH1cblxuICAgIHJldHVybiBkZXNjcmlwdG9yLnZhbHVlO1xuICB9XG5cbiAgZnVuY3Rpb24gX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHJlY2VpdmVyLCBwcml2YXRlTWFwLCB2YWx1ZSkge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJpdmF0ZU1hcC5nZXQocmVjZWl2ZXIpO1xuXG4gICAgaWYgKCFkZXNjcmlwdG9yKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhdHRlbXB0ZWQgdG8gc2V0IHByaXZhdGUgZmllbGQgb24gbm9uLWluc3RhbmNlJyk7XG4gICAgfVxuXG4gICAgaWYgKGRlc2NyaXB0b3Iuc2V0KSB7XG4gICAgICBkZXNjcmlwdG9yLnNldC5jYWxsKHJlY2VpdmVyLCB2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghZGVzY3JpcHRvci53cml0YWJsZSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhdHRlbXB0ZWQgdG8gc2V0IHJlYWQgb25seSBwcml2YXRlIGZpZWxkJyk7XG4gICAgICB9XG5cbiAgICAgIGRlc2NyaXB0b3IudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBmdW5jdGlvbiBfY2xhc3NQcml2YXRlRmllbGREZXN0cnVjdHVyZVNldChyZWNlaXZlciwgcHJpdmF0ZU1hcCkge1xuICAgIGlmICghcHJpdmF0ZU1hcC5oYXMocmVjZWl2ZXIpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhdHRlbXB0ZWQgdG8gc2V0IHByaXZhdGUgZmllbGQgb24gbm9uLWluc3RhbmNlJyk7XG4gICAgfVxuXG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcml2YXRlTWFwLmdldChyZWNlaXZlcik7XG5cbiAgICBpZiAoZGVzY3JpcHRvci5zZXQpIHtcbiAgICAgIGlmICghKCdfX2Rlc3RyT2JqJyBpbiBkZXNjcmlwdG9yKSkge1xuICAgICAgICBkZXNjcmlwdG9yLl9fZGVzdHJPYmogPSB7XG4gICAgICAgICAgc2V0IHZhbHVlKHYpIHtcbiAgICAgICAgICAgIGRlc2NyaXB0b3Iuc2V0LmNhbGwocmVjZWl2ZXIsIHYpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRlc2NyaXB0b3IuX19kZXN0ck9iajtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFkZXNjcmlwdG9yLndyaXRhYmxlKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2F0dGVtcHRlZCB0byBzZXQgcmVhZCBvbmx5IHByaXZhdGUgZmllbGQnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRlc2NyaXB0b3I7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX2NsYXNzU3RhdGljUHJpdmF0ZUZpZWxkU3BlY0dldChcbiAgICByZWNlaXZlcixcbiAgICBjbGFzc0NvbnN0cnVjdG9yLFxuICAgIGRlc2NyaXB0b3JcbiAgKSB7XG4gICAgaWYgKHJlY2VpdmVyICE9PSBjbGFzc0NvbnN0cnVjdG9yKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQcml2YXRlIHN0YXRpYyBhY2Nlc3Mgb2Ygd3JvbmcgcHJvdmVuYW5jZScpO1xuICAgIH1cblxuICAgIHJldHVybiBkZXNjcmlwdG9yLnZhbHVlO1xuICB9XG5cbiAgZnVuY3Rpb24gX2NsYXNzU3RhdGljUHJpdmF0ZUZpZWxkU3BlY1NldChcbiAgICByZWNlaXZlcixcbiAgICBjbGFzc0NvbnN0cnVjdG9yLFxuICAgIGRlc2NyaXB0b3IsXG4gICAgdmFsdWVcbiAgKSB7XG4gICAgaWYgKHJlY2VpdmVyICE9PSBjbGFzc0NvbnN0cnVjdG9yKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQcml2YXRlIHN0YXRpYyBhY2Nlc3Mgb2Ygd3JvbmcgcHJvdmVuYW5jZScpO1xuICAgIH1cblxuICAgIGlmICghZGVzY3JpcHRvci53cml0YWJsZSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXR0ZW1wdGVkIHRvIHNldCByZWFkIG9ubHkgcHJpdmF0ZSBmaWVsZCcpO1xuICAgIH1cblxuICAgIGRlc2NyaXB0b3IudmFsdWUgPSB2YWx1ZTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBmdW5jdGlvbiBfY2xhc3NTdGF0aWNQcml2YXRlTWV0aG9kR2V0KHJlY2VpdmVyLCBjbGFzc0NvbnN0cnVjdG9yLCBtZXRob2QpIHtcbiAgICBpZiAocmVjZWl2ZXIgIT09IGNsYXNzQ29uc3RydWN0b3IpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1ByaXZhdGUgc3RhdGljIGFjY2VzcyBvZiB3cm9uZyBwcm92ZW5hbmNlJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1ldGhvZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9jbGFzc1N0YXRpY1ByaXZhdGVNZXRob2RTZXQoKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXR0ZW1wdGVkIHRvIHNldCByZWFkIG9ubHkgc3RhdGljIHByaXZhdGUgZmllbGQnKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9kZWNvcmF0ZShkZWNvcmF0b3JzLCBmYWN0b3J5LCBzdXBlckNsYXNzLCBtaXhpbnMpIHtcbiAgICB2YXIgYXBpID0gX2dldERlY29yYXRvcnNBcGkoKTtcblxuICAgIGlmIChtaXhpbnMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWl4aW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFwaSA9IG1peGluc1tpXShhcGkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByID0gZmFjdG9yeShmdW5jdGlvbiBpbml0aWFsaXplKE8pIHtcbiAgICAgIGFwaS5pbml0aWFsaXplSW5zdGFuY2VFbGVtZW50cyhPLCBkZWNvcmF0ZWQuZWxlbWVudHMpO1xuICAgIH0sIHN1cGVyQ2xhc3MpO1xuICAgIHZhciBkZWNvcmF0ZWQgPSBhcGkuZGVjb3JhdGVDbGFzcyhcbiAgICAgIF9jb2FsZXNjZUNsYXNzRWxlbWVudHMoci5kLm1hcChfY3JlYXRlRWxlbWVudERlc2NyaXB0b3IpKSxcbiAgICAgIGRlY29yYXRvcnNcbiAgICApO1xuICAgIGFwaS5pbml0aWFsaXplQ2xhc3NFbGVtZW50cyhyLkYsIGRlY29yYXRlZC5lbGVtZW50cyk7XG4gICAgcmV0dXJuIGFwaS5ydW5DbGFzc0ZpbmlzaGVycyhyLkYsIGRlY29yYXRlZC5maW5pc2hlcnMpO1xuICB9XG5cbiAgZnVuY3Rpb24gX2dldERlY29yYXRvcnNBcGkoKSB7XG4gICAgX2dldERlY29yYXRvcnNBcGkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBhcGk7XG4gICAgfTtcblxuICAgIHZhciBhcGkgPSB7XG4gICAgICBlbGVtZW50c0RlZmluaXRpb25PcmRlcjogW1snbWV0aG9kJ10sIFsnZmllbGQnXV0sXG4gICAgICBpbml0aWFsaXplSW5zdGFuY2VFbGVtZW50czogZnVuY3Rpb24oTywgZWxlbWVudHMpIHtcbiAgICAgICAgWydtZXRob2QnLCAnZmllbGQnXS5mb3JFYWNoKGZ1bmN0aW9uKGtpbmQpIHtcbiAgICAgICAgICBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIGlmIChlbGVtZW50LmtpbmQgPT09IGtpbmQgJiYgZWxlbWVudC5wbGFjZW1lbnQgPT09ICdvd24nKSB7XG4gICAgICAgICAgICAgIHRoaXMuZGVmaW5lQ2xhc3NFbGVtZW50KE8sIGVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICAgIH0sXG4gICAgICBpbml0aWFsaXplQ2xhc3NFbGVtZW50czogZnVuY3Rpb24oRiwgZWxlbWVudHMpIHtcbiAgICAgICAgdmFyIHByb3RvID0gRi5wcm90b3R5cGU7XG4gICAgICAgIFsnbWV0aG9kJywgJ2ZpZWxkJ10uZm9yRWFjaChmdW5jdGlvbihraW5kKSB7XG4gICAgICAgICAgZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgICB2YXIgcGxhY2VtZW50ID0gZWxlbWVudC5wbGFjZW1lbnQ7XG5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgZWxlbWVudC5raW5kID09PSBraW5kICYmXG4gICAgICAgICAgICAgIChwbGFjZW1lbnQgPT09ICdzdGF0aWMnIHx8IHBsYWNlbWVudCA9PT0gJ3Byb3RvdHlwZScpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgdmFyIHJlY2VpdmVyID0gcGxhY2VtZW50ID09PSAnc3RhdGljJyA/IEYgOiBwcm90bztcbiAgICAgICAgICAgICAgdGhpcy5kZWZpbmVDbGFzc0VsZW1lbnQocmVjZWl2ZXIsIGVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICAgIH0sXG4gICAgICBkZWZpbmVDbGFzc0VsZW1lbnQ6IGZ1bmN0aW9uKHJlY2VpdmVyLCBlbGVtZW50KSB7XG4gICAgICAgIHZhciBkZXNjcmlwdG9yID0gZWxlbWVudC5kZXNjcmlwdG9yO1xuXG4gICAgICAgIGlmIChlbGVtZW50LmtpbmQgPT09ICdmaWVsZCcpIHtcbiAgICAgICAgICB2YXIgaW5pdGlhbGl6ZXIgPSBlbGVtZW50LmluaXRpYWxpemVyO1xuICAgICAgICAgIGRlc2NyaXB0b3IgPSB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBkZXNjcmlwdG9yLmVudW1lcmFibGUsXG4gICAgICAgICAgICB3cml0YWJsZTogZGVzY3JpcHRvci53cml0YWJsZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogZGVzY3JpcHRvci5jb25maWd1cmFibGUsXG4gICAgICAgICAgICB2YWx1ZTogaW5pdGlhbGl6ZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGluaXRpYWxpemVyLmNhbGwocmVjZWl2ZXIpXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZWNlaXZlciwgZWxlbWVudC5rZXksIGRlc2NyaXB0b3IpO1xuICAgICAgfSxcbiAgICAgIGRlY29yYXRlQ2xhc3M6IGZ1bmN0aW9uKGVsZW1lbnRzLCBkZWNvcmF0b3JzKSB7XG4gICAgICAgIHZhciBuZXdFbGVtZW50cyA9IFtdO1xuICAgICAgICB2YXIgZmluaXNoZXJzID0gW107XG4gICAgICAgIHZhciBwbGFjZW1lbnRzID0ge1xuICAgICAgICAgIHN0YXRpYzogW10sXG4gICAgICAgICAgcHJvdG90eXBlOiBbXSxcbiAgICAgICAgICBvd246IFtdXG4gICAgICAgIH07XG4gICAgICAgIGVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgIHRoaXMuYWRkRWxlbWVudFBsYWNlbWVudChlbGVtZW50LCBwbGFjZW1lbnRzKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIGVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgIGlmICghX2hhc0RlY29yYXRvcnMoZWxlbWVudCkpIHJldHVybiBuZXdFbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xuICAgICAgICAgIHZhciBlbGVtZW50RmluaXNoZXJzRXh0cmFzID0gdGhpcy5kZWNvcmF0ZUVsZW1lbnQoXG4gICAgICAgICAgICBlbGVtZW50LFxuICAgICAgICAgICAgcGxhY2VtZW50c1xuICAgICAgICAgICk7XG4gICAgICAgICAgbmV3RWxlbWVudHMucHVzaChlbGVtZW50RmluaXNoZXJzRXh0cmFzLmVsZW1lbnQpO1xuICAgICAgICAgIG5ld0VsZW1lbnRzLnB1c2guYXBwbHkobmV3RWxlbWVudHMsIGVsZW1lbnRGaW5pc2hlcnNFeHRyYXMuZXh0cmFzKTtcbiAgICAgICAgICBmaW5pc2hlcnMucHVzaC5hcHBseShmaW5pc2hlcnMsIGVsZW1lbnRGaW5pc2hlcnNFeHRyYXMuZmluaXNoZXJzKTtcbiAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgaWYgKCFkZWNvcmF0b3JzKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVsZW1lbnRzOiBuZXdFbGVtZW50cyxcbiAgICAgICAgICAgIGZpbmlzaGVyczogZmluaXNoZXJzXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmRlY29yYXRlQ29uc3RydWN0b3IobmV3RWxlbWVudHMsIGRlY29yYXRvcnMpO1xuICAgICAgICBmaW5pc2hlcnMucHVzaC5hcHBseShmaW5pc2hlcnMsIHJlc3VsdC5maW5pc2hlcnMpO1xuICAgICAgICByZXN1bHQuZmluaXNoZXJzID0gZmluaXNoZXJzO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSxcbiAgICAgIGFkZEVsZW1lbnRQbGFjZW1lbnQ6IGZ1bmN0aW9uKGVsZW1lbnQsIHBsYWNlbWVudHMsIHNpbGVudCkge1xuICAgICAgICB2YXIga2V5cyA9IHBsYWNlbWVudHNbZWxlbWVudC5wbGFjZW1lbnRdO1xuXG4gICAgICAgIGlmICghc2lsZW50ICYmIGtleXMuaW5kZXhPZihlbGVtZW50LmtleSkgIT09IC0xKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRHVwbGljYXRlZCBlbGVtZW50ICgnICsgZWxlbWVudC5rZXkgKyAnKScpO1xuICAgICAgICB9XG5cbiAgICAgICAga2V5cy5wdXNoKGVsZW1lbnQua2V5KTtcbiAgICAgIH0sXG4gICAgICBkZWNvcmF0ZUVsZW1lbnQ6IGZ1bmN0aW9uKGVsZW1lbnQsIHBsYWNlbWVudHMpIHtcbiAgICAgICAgdmFyIGV4dHJhcyA9IFtdO1xuICAgICAgICB2YXIgZmluaXNoZXJzID0gW107XG5cbiAgICAgICAgZm9yIChcbiAgICAgICAgICB2YXIgZGVjb3JhdG9ycyA9IGVsZW1lbnQuZGVjb3JhdG9ycywgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTtcbiAgICAgICAgICBpID49IDA7XG4gICAgICAgICAgaS0tXG4gICAgICAgICkge1xuICAgICAgICAgIHZhciBrZXlzID0gcGxhY2VtZW50c1tlbGVtZW50LnBsYWNlbWVudF07XG4gICAgICAgICAga2V5cy5zcGxpY2Uoa2V5cy5pbmRleE9mKGVsZW1lbnQua2V5KSwgMSk7XG4gICAgICAgICAgdmFyIGVsZW1lbnRPYmplY3QgPSB0aGlzLmZyb21FbGVtZW50RGVzY3JpcHRvcihlbGVtZW50KTtcbiAgICAgICAgICB2YXIgZWxlbWVudEZpbmlzaGVyRXh0cmFzID0gdGhpcy50b0VsZW1lbnRGaW5pc2hlckV4dHJhcyhcbiAgICAgICAgICAgICgwLCBkZWNvcmF0b3JzW2ldKShlbGVtZW50T2JqZWN0KSB8fCBlbGVtZW50T2JqZWN0XG4gICAgICAgICAgKTtcbiAgICAgICAgICBlbGVtZW50ID0gZWxlbWVudEZpbmlzaGVyRXh0cmFzLmVsZW1lbnQ7XG4gICAgICAgICAgdGhpcy5hZGRFbGVtZW50UGxhY2VtZW50KGVsZW1lbnQsIHBsYWNlbWVudHMpO1xuXG4gICAgICAgICAgaWYgKGVsZW1lbnRGaW5pc2hlckV4dHJhcy5maW5pc2hlcikge1xuICAgICAgICAgICAgZmluaXNoZXJzLnB1c2goZWxlbWVudEZpbmlzaGVyRXh0cmFzLmZpbmlzaGVyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgbmV3RXh0cmFzID0gZWxlbWVudEZpbmlzaGVyRXh0cmFzLmV4dHJhcztcblxuICAgICAgICAgIGlmIChuZXdFeHRyYXMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbmV3RXh0cmFzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgIHRoaXMuYWRkRWxlbWVudFBsYWNlbWVudChuZXdFeHRyYXNbal0sIHBsYWNlbWVudHMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBleHRyYXMucHVzaC5hcHBseShleHRyYXMsIG5ld0V4dHJhcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgICAgICAgIGZpbmlzaGVyczogZmluaXNoZXJzLFxuICAgICAgICAgIGV4dHJhczogZXh0cmFzXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgZGVjb3JhdGVDb25zdHJ1Y3RvcjogZnVuY3Rpb24oZWxlbWVudHMsIGRlY29yYXRvcnMpIHtcbiAgICAgICAgdmFyIGZpbmlzaGVycyA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgdmFyIG9iaiA9IHRoaXMuZnJvbUNsYXNzRGVzY3JpcHRvcihlbGVtZW50cyk7XG4gICAgICAgICAgdmFyIGVsZW1lbnRzQW5kRmluaXNoZXIgPSB0aGlzLnRvQ2xhc3NEZXNjcmlwdG9yKFxuICAgICAgICAgICAgKDAsIGRlY29yYXRvcnNbaV0pKG9iaikgfHwgb2JqXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGlmIChlbGVtZW50c0FuZEZpbmlzaGVyLmZpbmlzaGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZpbmlzaGVycy5wdXNoKGVsZW1lbnRzQW5kRmluaXNoZXIuZmluaXNoZXIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChlbGVtZW50c0FuZEZpbmlzaGVyLmVsZW1lbnRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGVsZW1lbnRzID0gZWxlbWVudHNBbmRGaW5pc2hlci5lbGVtZW50cztcblxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBlbGVtZW50cy5sZW5ndGggLSAxOyBqKyspIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgayA9IGogKyAxOyBrIDwgZWxlbWVudHMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICBlbGVtZW50c1tqXS5rZXkgPT09IGVsZW1lbnRzW2tdLmtleSAmJlxuICAgICAgICAgICAgICAgICAgZWxlbWVudHNbal0ucGxhY2VtZW50ID09PSBlbGVtZW50c1trXS5wbGFjZW1lbnRcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICdEdXBsaWNhdGVkIGVsZW1lbnQgKCcgKyBlbGVtZW50c1tqXS5rZXkgKyAnKSdcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBlbGVtZW50czogZWxlbWVudHMsXG4gICAgICAgICAgZmluaXNoZXJzOiBmaW5pc2hlcnNcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBmcm9tRWxlbWVudERlc2NyaXB0b3I6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIG9iaiA9IHtcbiAgICAgICAgICBraW5kOiBlbGVtZW50LmtpbmQsXG4gICAgICAgICAga2V5OiBlbGVtZW50LmtleSxcbiAgICAgICAgICBwbGFjZW1lbnQ6IGVsZW1lbnQucGxhY2VtZW50LFxuICAgICAgICAgIGRlc2NyaXB0b3I6IGVsZW1lbnQuZGVzY3JpcHRvclxuICAgICAgICB9O1xuICAgICAgICB2YXIgZGVzYyA9IHtcbiAgICAgICAgICB2YWx1ZTogJ0Rlc2NyaXB0b3InLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBTeW1ib2wudG9TdHJpbmdUYWcsIGRlc2MpO1xuICAgICAgICBpZiAoZWxlbWVudC5raW5kID09PSAnZmllbGQnKSBvYmouaW5pdGlhbGl6ZXIgPSBlbGVtZW50LmluaXRpYWxpemVyO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgfSxcbiAgICAgIHRvRWxlbWVudERlc2NyaXB0b3JzOiBmdW5jdGlvbihlbGVtZW50T2JqZWN0cykge1xuICAgICAgICBpZiAoZWxlbWVudE9iamVjdHMgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuICAgICAgICByZXR1cm4gX3RvQXJyYXkoZWxlbWVudE9iamVjdHMpLm1hcChmdW5jdGlvbihlbGVtZW50T2JqZWN0KSB7XG4gICAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLnRvRWxlbWVudERlc2NyaXB0b3IoZWxlbWVudE9iamVjdCk7XG4gICAgICAgICAgdGhpcy5kaXNhbGxvd1Byb3BlcnR5KFxuICAgICAgICAgICAgZWxlbWVudE9iamVjdCxcbiAgICAgICAgICAgICdmaW5pc2hlcicsXG4gICAgICAgICAgICAnQW4gZWxlbWVudCBkZXNjcmlwdG9yJ1xuICAgICAgICAgICk7XG4gICAgICAgICAgdGhpcy5kaXNhbGxvd1Byb3BlcnR5KFxuICAgICAgICAgICAgZWxlbWVudE9iamVjdCxcbiAgICAgICAgICAgICdleHRyYXMnLFxuICAgICAgICAgICAgJ0FuIGVsZW1lbnQgZGVzY3JpcHRvcidcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgICB9LCB0aGlzKTtcbiAgICAgIH0sXG4gICAgICB0b0VsZW1lbnREZXNjcmlwdG9yOiBmdW5jdGlvbihlbGVtZW50T2JqZWN0KSB7XG4gICAgICAgIHZhciBraW5kID0gU3RyaW5nKGVsZW1lbnRPYmplY3Qua2luZCk7XG5cbiAgICAgICAgaWYgKGtpbmQgIT09ICdtZXRob2QnICYmIGtpbmQgIT09ICdmaWVsZCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgJ0FuIGVsZW1lbnQgZGVzY3JpcHRvclxcJ3MgLmtpbmQgcHJvcGVydHkgbXVzdCBiZSBlaXRoZXIgXCJtZXRob2RcIiBvcicgK1xuICAgICAgICAgICAgICAnIFwiZmllbGRcIiwgYnV0IGEgZGVjb3JhdG9yIGNyZWF0ZWQgYW4gZWxlbWVudCBkZXNjcmlwdG9yIHdpdGgnICtcbiAgICAgICAgICAgICAgJyAua2luZCBcIicgK1xuICAgICAgICAgICAgICBraW5kICtcbiAgICAgICAgICAgICAgJ1wiJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIga2V5ID0gX3RvUHJvcGVydHlLZXkoZWxlbWVudE9iamVjdC5rZXkpO1xuXG4gICAgICAgIHZhciBwbGFjZW1lbnQgPSBTdHJpbmcoZWxlbWVudE9iamVjdC5wbGFjZW1lbnQpO1xuXG4gICAgICAgIGlmIChcbiAgICAgICAgICBwbGFjZW1lbnQgIT09ICdzdGF0aWMnICYmXG4gICAgICAgICAgcGxhY2VtZW50ICE9PSAncHJvdG90eXBlJyAmJlxuICAgICAgICAgIHBsYWNlbWVudCAhPT0gJ293bidcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICdBbiBlbGVtZW50IGRlc2NyaXB0b3JcXCdzIC5wbGFjZW1lbnQgcHJvcGVydHkgbXVzdCBiZSBvbmUgb2YgXCJzdGF0aWNcIiwnICtcbiAgICAgICAgICAgICAgJyBcInByb3RvdHlwZVwiIG9yIFwib3duXCIsIGJ1dCBhIGRlY29yYXRvciBjcmVhdGVkIGFuIGVsZW1lbnQgZGVzY3JpcHRvcicgK1xuICAgICAgICAgICAgICAnIHdpdGggLnBsYWNlbWVudCBcIicgK1xuICAgICAgICAgICAgICBwbGFjZW1lbnQgK1xuICAgICAgICAgICAgICAnXCInXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkZXNjcmlwdG9yID0gZWxlbWVudE9iamVjdC5kZXNjcmlwdG9yO1xuICAgICAgICB0aGlzLmRpc2FsbG93UHJvcGVydHkoXG4gICAgICAgICAgZWxlbWVudE9iamVjdCxcbiAgICAgICAgICAnZWxlbWVudHMnLFxuICAgICAgICAgICdBbiBlbGVtZW50IGRlc2NyaXB0b3InXG4gICAgICAgICk7XG4gICAgICAgIHZhciBlbGVtZW50ID0ge1xuICAgICAgICAgIGtpbmQ6IGtpbmQsXG4gICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgcGxhY2VtZW50OiBwbGFjZW1lbnQsXG4gICAgICAgICAgZGVzY3JpcHRvcjogT2JqZWN0LmFzc2lnbih7fSwgZGVzY3JpcHRvcilcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoa2luZCAhPT0gJ2ZpZWxkJykge1xuICAgICAgICAgIHRoaXMuZGlzYWxsb3dQcm9wZXJ0eShcbiAgICAgICAgICAgIGVsZW1lbnRPYmplY3QsXG4gICAgICAgICAgICAnaW5pdGlhbGl6ZXInLFxuICAgICAgICAgICAgJ0EgbWV0aG9kIGRlc2NyaXB0b3InXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmRpc2FsbG93UHJvcGVydHkoXG4gICAgICAgICAgICBkZXNjcmlwdG9yLFxuICAgICAgICAgICAgJ2dldCcsXG4gICAgICAgICAgICAnVGhlIHByb3BlcnR5IGRlc2NyaXB0b3Igb2YgYSBmaWVsZCBkZXNjcmlwdG9yJ1xuICAgICAgICAgICk7XG4gICAgICAgICAgdGhpcy5kaXNhbGxvd1Byb3BlcnR5KFxuICAgICAgICAgICAgZGVzY3JpcHRvcixcbiAgICAgICAgICAgICdzZXQnLFxuICAgICAgICAgICAgJ1RoZSBwcm9wZXJ0eSBkZXNjcmlwdG9yIG9mIGEgZmllbGQgZGVzY3JpcHRvcidcbiAgICAgICAgICApO1xuICAgICAgICAgIHRoaXMuZGlzYWxsb3dQcm9wZXJ0eShcbiAgICAgICAgICAgIGRlc2NyaXB0b3IsXG4gICAgICAgICAgICAndmFsdWUnLFxuICAgICAgICAgICAgJ1RoZSBwcm9wZXJ0eSBkZXNjcmlwdG9yIG9mIGEgZmllbGQgZGVzY3JpcHRvcidcbiAgICAgICAgICApO1xuICAgICAgICAgIGVsZW1lbnQuaW5pdGlhbGl6ZXIgPSBlbGVtZW50T2JqZWN0LmluaXRpYWxpemVyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICB9LFxuICAgICAgdG9FbGVtZW50RmluaXNoZXJFeHRyYXM6IGZ1bmN0aW9uKGVsZW1lbnRPYmplY3QpIHtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLnRvRWxlbWVudERlc2NyaXB0b3IoZWxlbWVudE9iamVjdCk7XG5cbiAgICAgICAgdmFyIGZpbmlzaGVyID0gX29wdGlvbmFsQ2FsbGFibGVQcm9wZXJ0eShlbGVtZW50T2JqZWN0LCAnZmluaXNoZXInKTtcblxuICAgICAgICB2YXIgZXh0cmFzID0gdGhpcy50b0VsZW1lbnREZXNjcmlwdG9ycyhlbGVtZW50T2JqZWN0LmV4dHJhcyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZWxlbWVudDogZWxlbWVudCxcbiAgICAgICAgICBmaW5pc2hlcjogZmluaXNoZXIsXG4gICAgICAgICAgZXh0cmFzOiBleHRyYXNcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBmcm9tQ2xhc3NEZXNjcmlwdG9yOiBmdW5jdGlvbihlbGVtZW50cykge1xuICAgICAgICB2YXIgb2JqID0ge1xuICAgICAgICAgIGtpbmQ6ICdjbGFzcycsXG4gICAgICAgICAgZWxlbWVudHM6IGVsZW1lbnRzLm1hcCh0aGlzLmZyb21FbGVtZW50RGVzY3JpcHRvciwgdGhpcylcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGRlc2MgPSB7XG4gICAgICAgICAgdmFsdWU6ICdEZXNjcmlwdG9yJyxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgU3ltYm9sLnRvU3RyaW5nVGFnLCBkZXNjKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgIH0sXG4gICAgICB0b0NsYXNzRGVzY3JpcHRvcjogZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgIHZhciBraW5kID0gU3RyaW5nKG9iai5raW5kKTtcblxuICAgICAgICBpZiAoa2luZCAhPT0gJ2NsYXNzJykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAnQSBjbGFzcyBkZXNjcmlwdG9yXFwncyAua2luZCBwcm9wZXJ0eSBtdXN0IGJlIFwiY2xhc3NcIiwgYnV0IGEgZGVjb3JhdG9yJyArXG4gICAgICAgICAgICAgICcgY3JlYXRlZCBhIGNsYXNzIGRlc2NyaXB0b3Igd2l0aCAua2luZCBcIicgK1xuICAgICAgICAgICAgICBraW5kICtcbiAgICAgICAgICAgICAgJ1wiJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRpc2FsbG93UHJvcGVydHkob2JqLCAna2V5JywgJ0EgY2xhc3MgZGVzY3JpcHRvcicpO1xuICAgICAgICB0aGlzLmRpc2FsbG93UHJvcGVydHkob2JqLCAncGxhY2VtZW50JywgJ0EgY2xhc3MgZGVzY3JpcHRvcicpO1xuICAgICAgICB0aGlzLmRpc2FsbG93UHJvcGVydHkob2JqLCAnZGVzY3JpcHRvcicsICdBIGNsYXNzIGRlc2NyaXB0b3InKTtcbiAgICAgICAgdGhpcy5kaXNhbGxvd1Byb3BlcnR5KG9iaiwgJ2luaXRpYWxpemVyJywgJ0EgY2xhc3MgZGVzY3JpcHRvcicpO1xuICAgICAgICB0aGlzLmRpc2FsbG93UHJvcGVydHkob2JqLCAnZXh0cmFzJywgJ0EgY2xhc3MgZGVzY3JpcHRvcicpO1xuXG4gICAgICAgIHZhciBmaW5pc2hlciA9IF9vcHRpb25hbENhbGxhYmxlUHJvcGVydHkob2JqLCAnZmluaXNoZXInKTtcblxuICAgICAgICB2YXIgZWxlbWVudHMgPSB0aGlzLnRvRWxlbWVudERlc2NyaXB0b3JzKG9iai5lbGVtZW50cyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZWxlbWVudHM6IGVsZW1lbnRzLFxuICAgICAgICAgIGZpbmlzaGVyOiBmaW5pc2hlclxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHJ1bkNsYXNzRmluaXNoZXJzOiBmdW5jdGlvbihjb25zdHJ1Y3RvciwgZmluaXNoZXJzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmluaXNoZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIG5ld0NvbnN0cnVjdG9yID0gKDAsIGZpbmlzaGVyc1tpXSkoY29uc3RydWN0b3IpO1xuXG4gICAgICAgICAgaWYgKG5ld0NvbnN0cnVjdG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbmV3Q29uc3RydWN0b3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmluaXNoZXJzIG11c3QgcmV0dXJuIGEgY29uc3RydWN0b3IuJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0cnVjdG9yID0gbmV3Q29uc3RydWN0b3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbnN0cnVjdG9yO1xuICAgICAgfSxcbiAgICAgIGRpc2FsbG93UHJvcGVydHk6IGZ1bmN0aW9uKG9iaiwgbmFtZSwgb2JqZWN0VHlwZSkge1xuICAgICAgICBpZiAob2JqW25hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgb2JqZWN0VHlwZSArIFwiIGNhbid0IGhhdmUgYSAuXCIgKyBuYW1lICsgJyBwcm9wZXJ0eS4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIGFwaTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9jcmVhdGVFbGVtZW50RGVzY3JpcHRvcihkZWYpIHtcbiAgICB2YXIga2V5ID0gX3RvUHJvcGVydHlLZXkoZGVmLmtleSk7XG5cbiAgICB2YXIgZGVzY3JpcHRvcjtcblxuICAgIGlmIChkZWYua2luZCA9PT0gJ21ldGhvZCcpIHtcbiAgICAgIGRlc2NyaXB0b3IgPSB7XG4gICAgICAgIHZhbHVlOiBkZWYudmFsdWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoZGVmLmtpbmQgPT09ICdnZXQnKSB7XG4gICAgICBkZXNjcmlwdG9yID0ge1xuICAgICAgICBnZXQ6IGRlZi52YWx1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGRlZi5raW5kID09PSAnc2V0Jykge1xuICAgICAgZGVzY3JpcHRvciA9IHtcbiAgICAgICAgc2V0OiBkZWYudmFsdWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChkZWYua2luZCA9PT0gJ2ZpZWxkJykge1xuICAgICAgZGVzY3JpcHRvciA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgZWxlbWVudCA9IHtcbiAgICAgIGtpbmQ6IGRlZi5raW5kID09PSAnZmllbGQnID8gJ2ZpZWxkJyA6ICdtZXRob2QnLFxuICAgICAga2V5OiBrZXksXG4gICAgICBwbGFjZW1lbnQ6IGRlZi5zdGF0aWNcbiAgICAgICAgPyAnc3RhdGljJ1xuICAgICAgICA6IGRlZi5raW5kID09PSAnZmllbGQnXG4gICAgICAgID8gJ293bidcbiAgICAgICAgOiAncHJvdG90eXBlJyxcbiAgICAgIGRlc2NyaXB0b3I6IGRlc2NyaXB0b3JcbiAgICB9O1xuICAgIGlmIChkZWYuZGVjb3JhdG9ycykgZWxlbWVudC5kZWNvcmF0b3JzID0gZGVmLmRlY29yYXRvcnM7XG4gICAgaWYgKGRlZi5raW5kID09PSAnZmllbGQnKSBlbGVtZW50LmluaXRpYWxpemVyID0gZGVmLnZhbHVlO1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG5cbiAgZnVuY3Rpb24gX2NvYWxlc2NlR2V0dGVyU2V0dGVyKGVsZW1lbnQsIG90aGVyKSB7XG4gICAgaWYgKGVsZW1lbnQuZGVzY3JpcHRvci5nZXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgb3RoZXIuZGVzY3JpcHRvci5nZXQgPSBlbGVtZW50LmRlc2NyaXB0b3IuZ2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICBvdGhlci5kZXNjcmlwdG9yLnNldCA9IGVsZW1lbnQuZGVzY3JpcHRvci5zZXQ7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX2NvYWxlc2NlQ2xhc3NFbGVtZW50cyhlbGVtZW50cykge1xuICAgIHZhciBuZXdFbGVtZW50cyA9IFtdO1xuXG4gICAgdmFyIGlzU2FtZUVsZW1lbnQgPSBmdW5jdGlvbihvdGhlcikge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgb3RoZXIua2luZCA9PT0gJ21ldGhvZCcgJiZcbiAgICAgICAgb3RoZXIua2V5ID09PSBlbGVtZW50LmtleSAmJlxuICAgICAgICBvdGhlci5wbGFjZW1lbnQgPT09IGVsZW1lbnQucGxhY2VtZW50XG4gICAgICApO1xuICAgIH07XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWxlbWVudCA9IGVsZW1lbnRzW2ldO1xuICAgICAgdmFyIG90aGVyO1xuXG4gICAgICBpZiAoXG4gICAgICAgIGVsZW1lbnQua2luZCA9PT0gJ21ldGhvZCcgJiZcbiAgICAgICAgKG90aGVyID0gbmV3RWxlbWVudHMuZmluZChpc1NhbWVFbGVtZW50KSlcbiAgICAgICkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgX2lzRGF0YURlc2NyaXB0b3IoZWxlbWVudC5kZXNjcmlwdG9yKSB8fFxuICAgICAgICAgIF9pc0RhdGFEZXNjcmlwdG9yKG90aGVyLmRlc2NyaXB0b3IpXG4gICAgICAgICkge1xuICAgICAgICAgIGlmIChfaGFzRGVjb3JhdG9ycyhlbGVtZW50KSB8fCBfaGFzRGVjb3JhdG9ycyhvdGhlcikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcbiAgICAgICAgICAgICAgJ0R1cGxpY2F0ZWQgbWV0aG9kcyAoJyArIGVsZW1lbnQua2V5ICsgXCIpIGNhbid0IGJlIGRlY29yYXRlZC5cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBvdGhlci5kZXNjcmlwdG9yID0gZWxlbWVudC5kZXNjcmlwdG9yO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChfaGFzRGVjb3JhdG9ycyhlbGVtZW50KSkge1xuICAgICAgICAgICAgaWYgKF9oYXNEZWNvcmF0b3JzKG90aGVyKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJEZWNvcmF0b3JzIGNhbid0IGJlIHBsYWNlZCBvbiBkaWZmZXJlbnQgYWNjZXNzb3JzIHdpdGggZm9yIFwiICtcbiAgICAgICAgICAgICAgICAgICd0aGUgc2FtZSBwcm9wZXJ0eSAoJyArXG4gICAgICAgICAgICAgICAgICBlbGVtZW50LmtleSArXG4gICAgICAgICAgICAgICAgICAnKS4nXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG90aGVyLmRlY29yYXRvcnMgPSBlbGVtZW50LmRlY29yYXRvcnM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX2NvYWxlc2NlR2V0dGVyU2V0dGVyKGVsZW1lbnQsIG90aGVyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3RWxlbWVudHMucHVzaChlbGVtZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmV3RWxlbWVudHM7XG4gIH1cblxuICBmdW5jdGlvbiBfaGFzRGVjb3JhdG9ycyhlbGVtZW50KSB7XG4gICAgcmV0dXJuIGVsZW1lbnQuZGVjb3JhdG9ycyAmJiBlbGVtZW50LmRlY29yYXRvcnMubGVuZ3RoO1xuICB9XG5cbiAgZnVuY3Rpb24gX2lzRGF0YURlc2NyaXB0b3IoZGVzYykge1xuICAgIHJldHVybiAoXG4gICAgICBkZXNjICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICEoZGVzYy52YWx1ZSA9PT0gdW5kZWZpbmVkICYmIGRlc2Mud3JpdGFibGUgPT09IHVuZGVmaW5lZClcbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gX29wdGlvbmFsQ2FsbGFibGVQcm9wZXJ0eShvYmosIG5hbWUpIHtcbiAgICB2YXIgdmFsdWUgPSBvYmpbbmFtZV07XG5cbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCAnXCIgKyBuYW1lICsgXCInIHRvIGJlIGEgZnVuY3Rpb25cIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgZnVuY3Rpb24gX2NsYXNzUHJpdmF0ZU1ldGhvZEdldChyZWNlaXZlciwgcHJpdmF0ZVNldCwgZm4pIHtcbiAgICBpZiAoIXByaXZhdGVTZXQuaGFzKHJlY2VpdmVyKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXR0ZW1wdGVkIHRvIGdldCBwcml2YXRlIGZpZWxkIG9uIG5vbi1pbnN0YW5jZScpO1xuICAgIH1cblxuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9jbGFzc1ByaXZhdGVNZXRob2RTZXQoKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXR0ZW1wdGVkIHRvIHJlYXNzaWduIHByaXZhdGUgbWV0aG9kJyk7XG4gIH1cblxuICBmdW5jdGlvbiBfd3JhcFJlZ0V4cChyZSwgZ3JvdXBzKSB7XG4gICAgX3dyYXBSZWdFeHAgPSBmdW5jdGlvbihyZSwgZ3JvdXBzKSB7XG4gICAgICByZXR1cm4gbmV3IEJhYmVsUmVnRXhwKHJlLCBncm91cHMpO1xuICAgIH07XG5cbiAgICB2YXIgX1JlZ0V4cCA9IF93cmFwTmF0aXZlU3VwZXIoUmVnRXhwKTtcblxuICAgIHZhciBfc3VwZXIgPSBSZWdFeHAucHJvdG90eXBlO1xuXG4gICAgdmFyIF9ncm91cHMgPSBuZXcgV2Vha01hcCgpO1xuXG4gICAgZnVuY3Rpb24gQmFiZWxSZWdFeHAocmUsIGdyb3Vwcykge1xuICAgICAgdmFyIF90aGlzID0gX1JlZ0V4cC5jYWxsKHRoaXMsIHJlKTtcblxuICAgICAgX2dyb3Vwcy5zZXQoX3RoaXMsIGdyb3Vwcyk7XG5cbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICBfaW5oZXJpdHMoQmFiZWxSZWdFeHAsIF9SZWdFeHApO1xuXG4gICAgQmFiZWxSZWdFeHAucHJvdG90eXBlLmV4ZWMgPSBmdW5jdGlvbihzdHIpIHtcbiAgICAgIHZhciByZXN1bHQgPSBfc3VwZXIuZXhlYy5jYWxsKHRoaXMsIHN0cik7XG5cbiAgICAgIGlmIChyZXN1bHQpIHJlc3VsdC5ncm91cHMgPSBidWlsZEdyb3VwcyhyZXN1bHQsIHRoaXMpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgQmFiZWxSZWdFeHAucHJvdG90eXBlW1N5bWJvbC5yZXBsYWNlXSA9IGZ1bmN0aW9uKHN0ciwgc3Vic3RpdHV0aW9uKSB7XG4gICAgICBpZiAodHlwZW9mIHN1YnN0aXR1dGlvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFyIGdyb3VwcyA9IF9ncm91cHMuZ2V0KHRoaXMpO1xuXG4gICAgICAgIHJldHVybiBfc3VwZXJbU3ltYm9sLnJlcGxhY2VdLmNhbGwoXG4gICAgICAgICAgdGhpcyxcbiAgICAgICAgICBzdHIsXG4gICAgICAgICAgc3Vic3RpdHV0aW9uLnJlcGxhY2UoL1xcJDwoW14+XSspPi9nLCBmdW5jdGlvbihfLCBuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyQnICsgZ3JvdXBzW25hbWVdO1xuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzdWJzdGl0dXRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICByZXR1cm4gX3N1cGVyW1N5bWJvbC5yZXBsYWNlXS5jYWxsKHRoaXMsIHN0ciwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICBhcmdzLnB1c2guYXBwbHkoYXJncywgYXJndW1lbnRzKTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgYXJnc1thcmdzLmxlbmd0aCAtIDFdICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgYXJncy5wdXNoKGJ1aWxkR3JvdXBzKGFyZ3MsIF90aGlzKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHN1YnN0aXR1dGlvbi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gX3N1cGVyW1N5bWJvbC5yZXBsYWNlXS5jYWxsKHRoaXMsIHN0ciwgc3Vic3RpdHV0aW9uKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gYnVpbGRHcm91cHMocmVzdWx0LCByZSkge1xuICAgICAgdmFyIGcgPSBfZ3JvdXBzLmdldChyZSk7XG5cbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyhnKS5yZWR1Y2UoZnVuY3Rpb24oZ3JvdXBzLCBuYW1lKSB7XG4gICAgICAgIGdyb3Vwc1tuYW1lXSA9IHJlc3VsdFtnW25hbWVdXTtcbiAgICAgICAgcmV0dXJuIGdyb3VwcztcbiAgICAgIH0sIE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICAgIH1cblxuICAgIHJldHVybiBfd3JhcFJlZ0V4cC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgdmFyIGFycmF5UmVtb3ZlID0gZnVuY3Rpb24gYXJyYXlSZW1vdmUoYXJyLCBpbmRleCkge1xuICAgIHJldHVybiBhcnIuc3BsaWNlKGluZGV4LCAxKTtcbiAgfTtcblxuICB2YXIgcnVuID0gZnVuY3Rpb24gcnVuKGNiLCBzeW5jKSB7XG4gICAgaWYgKHN5bmMpIHtcbiAgICAgIGNiKCk7XG4gICAgfSBlbHNlIGlmIChkb2N1bWVudC5oaWRkZW4pIHtcbiAgICAgIFByb21pc2UucmVzb2x2ZSgxKS50aGVuKGNiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0VGltZW91dChjYiwgMCk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBvbiA9IGZ1bmN0aW9uIG9uKCkge1xuICAgIHZhciBsaXN0ZW5lcnMgPSBbXTtcbiAgICB2YXIgb2ZmID0gZnVuY3Rpb24gb2ZmKGV2ZW50LCBjYikge1xuICAgICAgYXJyYXlSZW1vdmUoXG4gICAgICAgIGxpc3RlbmVycyxcbiAgICAgICAgbGlzdGVuZXJzLmZpbmRJbmRleChmdW5jdGlvbihsaXN0ZW5lcikge1xuICAgICAgICAgIHJldHVybiBsaXN0ZW5lci5ldmVudCA9PT0gZXZlbnQgJiYgKGxpc3RlbmVyLmNiID09PSBjYiB8fCAhY2IpO1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9O1xuICAgIHZhciBfZmlyZSA9IGZ1bmN0aW9uIGZpcmUoZXZlbnQsIGFyZ3MsIHN5bmMpIHtcbiAgICAgIGxpc3RlbmVyc1xuICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKGxpc3RlbmVyKSB7XG4gICAgICAgICAgcmV0dXJuIGxpc3RlbmVyLmV2ZW50ID09PSBldmVudDtcbiAgICAgICAgfSlcbiAgICAgICAgLm1hcChmdW5jdGlvbihsaXN0ZW5lcikge1xuICAgICAgICAgIHJldHVybiBsaXN0ZW5lci5jYjtcbiAgICAgICAgfSlcbiAgICAgICAgLmZvckVhY2goZnVuY3Rpb24oY2IpIHtcbiAgICAgICAgICByZXR1cm4gcnVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGNiLmFwcGx5KHZvaWQgMCwgX3RvQ29uc3VtYWJsZUFycmF5KGFyZ3MpKTtcbiAgICAgICAgICB9LCBzeW5jKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgZmlyZVN5bmM6IGZ1bmN0aW9uIGZpcmVTeW5jKGV2ZW50KSB7XG4gICAgICAgIGZvciAoXG4gICAgICAgICAgdmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICAgICAgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksXG4gICAgICAgICAgICBfa2V5ID0gMTtcbiAgICAgICAgICBfa2V5IDwgX2xlbjtcbiAgICAgICAgICBfa2V5KytcbiAgICAgICAgKSB7XG4gICAgICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgIH1cbiAgICAgICAgX2ZpcmUoZXZlbnQsIGFyZ3MsIHRydWUpO1xuICAgICAgfSxcbiAgICAgIGZpcmU6IGZ1bmN0aW9uIGZpcmUoZXZlbnQpIHtcbiAgICAgICAgZm9yIChcbiAgICAgICAgICB2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICAgICAgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSxcbiAgICAgICAgICAgIF9rZXkyID0gMTtcbiAgICAgICAgICBfa2V5MiA8IF9sZW4yO1xuICAgICAgICAgIF9rZXkyKytcbiAgICAgICAgKSB7XG4gICAgICAgICAgYXJnc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgICAgfVxuICAgICAgICBfZmlyZShldmVudCwgYXJncywgZmFsc2UpO1xuICAgICAgfSxcbiAgICAgIG9uOiBmdW5jdGlvbiBvbihldmVudCwgY2IpIHtcbiAgICAgICAgbGlzdGVuZXJzLnB1c2goeyBldmVudDogZXZlbnQsIGNiOiBjYiB9KTtcbiAgICAgIH0sXG4gICAgICBvbk9uY2U6IGZ1bmN0aW9uIG9uT25jZShldmVudCwgX2NiKSB7XG4gICAgICAgIGxpc3RlbmVycy5wdXNoKHtcbiAgICAgICAgICBldmVudDogZXZlbnQsXG4gICAgICAgICAgY2I6IGZ1bmN0aW9uIGNiKCkge1xuICAgICAgICAgICAgb2ZmKGV2ZW50LCBfY2IpO1xuICAgICAgICAgICAgX2NiLmFwcGx5KHZvaWQgMCwgYXJndW1lbnRzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIG9mZjogb2ZmXG4gICAgfTtcbiAgfTtcblxuICB2YXIgY29weU9iamVjdFByb3BlcnRpZXNUb09iamVjdCA9IGZ1bmN0aW9uIGNvcHlPYmplY3RQcm9wZXJ0aWVzVG9PYmplY3QoXG4gICAgc3JjLFxuICAgIHRhcmdldCxcbiAgICBleGNsdWRlZFxuICApIHtcbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhzcmMpXG4gICAgICAuZmlsdGVyKGZ1bmN0aW9uKHByb3BlcnR5KSB7XG4gICAgICAgIHJldHVybiAhZXhjbHVkZWQuaW5jbHVkZXMocHJvcGVydHkpO1xuICAgICAgfSlcbiAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KFxuICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICBrZXksXG4gICAgICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzcmMsIGtleSlcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICB9O1xuXG4gIHZhciBQUklWQVRFID0gW1xuICAgICdmaXJlJyxcbiAgICAncHJvY2VzcycsXG4gICAgJ3JldmVydCcsXG4gICAgJ2xvYWQnLFxuICAgICdvbicsXG4gICAgJ29mZicsXG4gICAgJ29uT25jZScsXG4gICAgJ3JldHJ5TG9hZCcsXG4gICAgJ2V4dGVuZCcsXG4gICAgJ2FyY2hpdmUnLFxuICAgICdhcmNoaXZlZCcsXG4gICAgJ3JlbGVhc2UnLFxuICAgICdyZWxlYXNlZCcsXG4gICAgJ3JlcXVlc3RQcm9jZXNzaW5nJyxcbiAgICAnZnJlZXplJ1xuICBdO1xuXG4gIHZhciBjcmVhdGVJdGVtQVBJID0gZnVuY3Rpb24gY3JlYXRlSXRlbUFQSShpdGVtKSB7XG4gICAgdmFyIGFwaSA9IHt9O1xuICAgIGNvcHlPYmplY3RQcm9wZXJ0aWVzVG9PYmplY3QoaXRlbSwgYXBpLCBQUklWQVRFKTtcbiAgICByZXR1cm4gYXBpO1xuICB9O1xuXG4gIHZhciByZW1vdmVSZWxlYXNlZEl0ZW1zID0gZnVuY3Rpb24gcmVtb3ZlUmVsZWFzZWRJdGVtcyhpdGVtcykge1xuICAgIGl0ZW1zLmZvckVhY2goZnVuY3Rpb24oaXRlbSwgaW5kZXgpIHtcbiAgICAgIGlmIChpdGVtLnJlbGVhc2VkKSB7XG4gICAgICAgIGFycmF5UmVtb3ZlKGl0ZW1zLCBpbmRleCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIEl0ZW1TdGF0dXMgPSB7XG4gICAgSU5JVDogMSxcbiAgICBJRExFOiAyLFxuICAgIFBST0NFU1NJTkdfUVVFVUVEOiA5LFxuICAgIFBST0NFU1NJTkc6IDMsXG4gICAgUFJPQ0VTU0lOR19DT01QTEVURTogNSxcbiAgICBQUk9DRVNTSU5HX0VSUk9SOiA2LFxuICAgIFBST0NFU1NJTkdfUkVWRVJUX0VSUk9SOiAxMCxcbiAgICBMT0FESU5HOiA3LFxuICAgIExPQURfRVJST1I6IDhcbiAgfTtcblxuICB2YXIgRmlsZU9yaWdpbiA9IHtcbiAgICBJTlBVVDogMSxcbiAgICBMSU1CTzogMixcbiAgICBMT0NBTDogM1xuICB9O1xuXG4gIHZhciBnZXROb25OdW1lcmljID0gZnVuY3Rpb24gZ2V0Tm9uTnVtZXJpYyhzdHIpIHtcbiAgICByZXR1cm4gL1teMC05XSsvLmV4ZWMoc3RyKTtcbiAgfTtcblxuICB2YXIgZ2V0RGVjaW1hbFNlcGFyYXRvciA9IGZ1bmN0aW9uIGdldERlY2ltYWxTZXBhcmF0b3IoKSB7XG4gICAgcmV0dXJuIGdldE5vbk51bWVyaWMoKDEuMSkudG9Mb2NhbGVTdHJpbmcoKSlbMF07XG4gIH07XG5cbiAgdmFyIGdldFRob3VzYW5kc1NlcGFyYXRvciA9IGZ1bmN0aW9uIGdldFRob3VzYW5kc1NlcGFyYXRvcigpIHtcbiAgICAvLyBBZGRlZCBmb3IgYnJvd3NlcnMgdGhhdCBkbyBub3QgcmV0dXJuIHRoZSB0aG91c2FuZHMgc2VwYXJhdG9yIChoYXBwZW5kIG9uIG5hdGl2ZSBicm93c2VyIEFuZHJvaWQgNC40LjQpXG4gICAgLy8gV2UgY2hlY2sgYWdhaW5zdCB0aGUgbm9ybWFsIHRvU3RyaW5nIG91dHB1dCBhbmQgaWYgdGhleSdyZSB0aGUgc2FtZSByZXR1cm4gYSBjb21tYSB3aGVuIGRlY2ltYWwgc2VwYXJhdG9yIGlzIGEgZG90XG4gICAgdmFyIGRlY2ltYWxTZXBhcmF0b3IgPSBnZXREZWNpbWFsU2VwYXJhdG9yKCk7XG4gICAgdmFyIHRob3VzYW5kc1N0cmluZ1dpdGhTZXBhcmF0b3IgPSAoMTAwMC4wKS50b0xvY2FsZVN0cmluZygpO1xuICAgIHZhciB0aG91c2FuZHNTdHJpbmdXaXRob3V0U2VwYXJhdG9yID0gKDEwMDAuMCkudG9TdHJpbmcoKTtcbiAgICBpZiAodGhvdXNhbmRzU3RyaW5nV2l0aFNlcGFyYXRvciAhPT0gdGhvdXNhbmRzU3RyaW5nV2l0aG91dFNlcGFyYXRvcikge1xuICAgICAgcmV0dXJuIGdldE5vbk51bWVyaWModGhvdXNhbmRzU3RyaW5nV2l0aFNlcGFyYXRvcilbMF07XG4gICAgfVxuICAgIHJldHVybiBkZWNpbWFsU2VwYXJhdG9yID09PSAnLicgPyAnLCcgOiAnLic7XG4gIH07XG5cbiAgdmFyIFR5cGUgPSB7XG4gICAgQk9PTEVBTjogJ2Jvb2xlYW4nLFxuICAgIElOVDogJ2ludCcsXG4gICAgTlVNQkVSOiAnbnVtYmVyJyxcbiAgICBTVFJJTkc6ICdzdHJpbmcnLFxuICAgIEFSUkFZOiAnYXJyYXknLFxuICAgIE9CSkVDVDogJ29iamVjdCcsXG4gICAgRlVOQ1RJT046ICdmdW5jdGlvbicsXG4gICAgQUNUSU9OOiAnYWN0aW9uJyxcbiAgICBTRVJWRVJfQVBJOiAnc2VydmVyYXBpJyxcbiAgICBSRUdFWDogJ3JlZ2V4J1xuICB9O1xuXG4gIC8vIGFsbCByZWdpc3RlcmVkIGZpbHRlcnNcbiAgdmFyIGZpbHRlcnMgPSBbXTtcblxuICAvLyBsb29wcyBvdmVyIG1hdGNoaW5nIGZpbHRlcnMgYW5kIHBhc3NlcyBvcHRpb25zIHRvIGVhY2ggZmlsdGVyLCByZXR1cm5pbmcgdGhlIG1hcHBlZCByZXN1bHRzXG4gIHZhciBhcHBseUZpbHRlckNoYWluID0gZnVuY3Rpb24gYXBwbHlGaWx0ZXJDaGFpbihrZXksIHZhbHVlLCB1dGlscykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIC8vIGZpbmQgbWF0Y2hpbmcgZmlsdGVycyBmb3IgdGhpcyBrZXlcbiAgICAgIHZhciBtYXRjaGluZ0ZpbHRlcnMgPSBmaWx0ZXJzXG4gICAgICAgIC5maWx0ZXIoZnVuY3Rpb24oZikge1xuICAgICAgICAgIHJldHVybiBmLmtleSA9PT0ga2V5O1xuICAgICAgICB9KVxuICAgICAgICAubWFwKGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgICByZXR1cm4gZi5jYjtcbiAgICAgICAgfSk7XG5cbiAgICAgIC8vIHJlc29sdmUgbm93XG4gICAgICBpZiAobWF0Y2hpbmdGaWx0ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBmaXJzdCBmaWx0ZXIgdG8ga2ljayB0aGluZ3Mgb2ZcbiAgICAgIHZhciBpbml0aWFsRmlsdGVyID0gbWF0Y2hpbmdGaWx0ZXJzLnNoaWZ0KCk7XG5cbiAgICAgIC8vIGNoYWluIGZpbHRlcnNcbiAgICAgIG1hdGNoaW5nRmlsdGVyc1xuICAgICAgICAucmVkdWNlKFxuICAgICAgICAgIC8vIGxvb3Agb3ZlciBwcm9taXNlcyBwYXNzaW5nIHZhbHVlIHRvIG5leHQgcHJvbWlzZVxuICAgICAgICAgIGZ1bmN0aW9uKGN1cnJlbnQsIG5leHQpIHtcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50LnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5leHQodmFsdWUsIHV0aWxzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICAvLyBjYWxsIGluaXRpYWwgZmlsdGVyLCB3aWxsIHJldHVybiBhIHByb21pc2VcbiAgICAgICAgICBpbml0aWFsRmlsdGVyKHZhbHVlLCB1dGlscylcblxuICAgICAgICAgIC8vIGFsbCBleGVjdXRlZFxuICAgICAgICApXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc29sdmUodmFsdWUpO1xuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIGFwcGx5RmlsdGVycyA9IGZ1bmN0aW9uIGFwcGx5RmlsdGVycyhrZXksIHZhbHVlLCB1dGlscykge1xuICAgIHJldHVybiBmaWx0ZXJzXG4gICAgICAuZmlsdGVyKGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgcmV0dXJuIGYua2V5ID09PSBrZXk7XG4gICAgICB9KVxuICAgICAgLm1hcChmdW5jdGlvbihmKSB7XG4gICAgICAgIHJldHVybiBmLmNiKHZhbHVlLCB1dGlscyk7XG4gICAgICB9KTtcbiAgfTtcblxuICAvLyBhZGRzIGEgbmV3IGZpbHRlciB0byB0aGUgbGlzdFxuICB2YXIgYWRkRmlsdGVyID0gZnVuY3Rpb24gYWRkRmlsdGVyKGtleSwgY2IpIHtcbiAgICByZXR1cm4gZmlsdGVycy5wdXNoKHsga2V5OiBrZXksIGNiOiBjYiB9KTtcbiAgfTtcblxuICB2YXIgZXh0ZW5kRGVmYXVsdE9wdGlvbnMgPSBmdW5jdGlvbiBleHRlbmREZWZhdWx0T3B0aW9ucyhhZGRpdGlvbmFsT3B0aW9ucykge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKGRlZmF1bHRPcHRpb25zLCBhZGRpdGlvbmFsT3B0aW9ucyk7XG4gIH07XG5cbiAgdmFyIGdldE9wdGlvbnMgPSBmdW5jdGlvbiBnZXRPcHRpb25zKCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0T3B0aW9ucyk7XG4gIH07XG5cbiAgdmFyIHNldE9wdGlvbnMgPSBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdHMpIHtcbiAgICBmb3JpbihvcHRzLCBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAvLyBrZXkgZG9lcyBub3QgZXhpc3QsIHNvIHRoaXMgb3B0aW9uIGNhbm5vdCBiZSBzZXRcbiAgICAgIGlmICghZGVmYXVsdE9wdGlvbnNba2V5XSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBkZWZhdWx0T3B0aW9uc1trZXldWzBdID0gZ2V0VmFsdWVCeVR5cGUoXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBkZWZhdWx0T3B0aW9uc1trZXldWzBdLFxuICAgICAgICBkZWZhdWx0T3B0aW9uc1trZXldWzFdXG4gICAgICApO1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIGRlZmF1bHQgb3B0aW9ucyBvbiBhcHBcbiAgdmFyIGRlZmF1bHRPcHRpb25zID0ge1xuICAgIC8vIHRoZSBpZCB0byBhZGQgdG8gdGhlIHJvb3QgZWxlbWVudFxuICAgIGlkOiBbbnVsbCwgVHlwZS5TVFJJTkddLFxuXG4gICAgLy8gaW5wdXQgZmllbGQgbmFtZSB0byB1c2VcbiAgICBuYW1lOiBbJ2ZpbGVwb25kJywgVHlwZS5TVFJJTkddLFxuXG4gICAgLy8gZGlzYWJsZSB0aGUgZmllbGRcbiAgICBkaXNhYmxlZDogW2ZhbHNlLCBUeXBlLkJPT0xFQU5dLFxuXG4gICAgLy8gY2xhc3NuYW1lIHRvIHB1dCBvbiB3cmFwcGVyXG4gICAgY2xhc3NOYW1lOiBbbnVsbCwgVHlwZS5TVFJJTkddLFxuXG4gICAgLy8gaXMgdGhlIGZpZWxkIHJlcXVpcmVkXG4gICAgcmVxdWlyZWQ6IFtmYWxzZSwgVHlwZS5CT09MRUFOXSxcblxuICAgIC8vIEFsbG93IG1lZGlhIGNhcHR1cmUgd2hlbiB2YWx1ZSBpcyBzZXRcbiAgICBjYXB0dXJlTWV0aG9kOiBbbnVsbCwgVHlwZS5TVFJJTkddLFxuICAgIC8vIC0gXCJjYW1lcmFcIiwgXCJtaWNyb3Bob25lXCIgb3IgXCJjYW1jb3JkZXJcIixcbiAgICAvLyAtIERvZXMgbm90IHdvcmsgd2l0aCBtdWx0aXBsZSBvbiBhcHBsZSBkZXZpY2VzXG4gICAgLy8gLSBJZiBzZXQsIGFjY2VwdGVkRmlsZVR5cGVzIG11c3QgYmUgbWFkZSB0byBtYXRjaCB3aXRoIG1lZGlhIHdpbGRjYXJkIFwiaW1hZ2UvKlwiLCBcImF1ZGlvLypcIiBvciBcInZpZGVvLypcIlxuXG4gICAgLy8gc3luYyBgYWNjZXB0ZWRGaWxlVHlwZXNgIHByb3BlcnR5IHdpdGggYGFjY2VwdGAgYXR0cmlidXRlXG4gICAgYWxsb3dTeW5jQWNjZXB0QXR0cmlidXRlOiBbdHJ1ZSwgVHlwZS5CT09MRUFOXSxcblxuICAgIC8vIEZlYXR1cmUgdG9nZ2xlc1xuICAgIGFsbG93RHJvcDogW3RydWUsIFR5cGUuQk9PTEVBTl0sIC8vIEFsbG93IGRyb3BwaW5nIG9mIGZpbGVzXG4gICAgYWxsb3dCcm93c2U6IFt0cnVlLCBUeXBlLkJPT0xFQU5dLCAvLyBBbGxvdyBicm93c2luZyB0aGUgZmlsZSBzeXN0ZW1cbiAgICBhbGxvd1Bhc3RlOiBbdHJ1ZSwgVHlwZS5CT09MRUFOXSwgLy8gQWxsb3cgcGFzdGluZyBmaWxlc1xuICAgIGFsbG93TXVsdGlwbGU6IFtmYWxzZSwgVHlwZS5CT09MRUFOXSwgLy8gQWxsb3cgbXVsdGlwbGUgZmlsZXMgKGRpc2FibGVkIGJ5IGRlZmF1bHQsIGFzIG11bHRpcGxlIGF0dHJpYnV0ZSBpcyBhbHNvIHJlcXVpcmVkIG9uIGlucHV0IHRvIGFsbG93IG11bHRpcGxlKVxuICAgIGFsbG93UmVwbGFjZTogW3RydWUsIFR5cGUuQk9PTEVBTl0sIC8vIEFsbG93IGRyb3BwaW5nIGEgZmlsZSBvbiBvdGhlciBmaWxlIHRvIHJlcGxhY2UgaXQgKG9ubHkgd29ya3Mgd2hlbiBtdWx0aXBsZSBpcyBzZXQgdG8gZmFsc2UpXG4gICAgYWxsb3dSZXZlcnQ6IFt0cnVlLCBUeXBlLkJPT0xFQU5dLCAvLyBBbGxvd3MgdXNlciB0byByZXZlcnQgZmlsZSB1cGxvYWRcbiAgICBhbGxvd1JlbW92ZTogW3RydWUsIFR5cGUuQk9PTEVBTl0sIC8vIEFsbG93IHVzZXIgdG8gcmVtb3ZlIGEgZmlsZVxuICAgIGFsbG93UHJvY2VzczogW3RydWUsIFR5cGUuQk9PTEVBTl0sIC8vIEFsbG93cyB1c2VyIHRvIHByb2Nlc3MgYSBmaWxlLCB3aGVuIHNldCB0byBmYWxzZSwgdGhpcyByZW1vdmVzIHRoZSBmaWxlIHVwbG9hZCBidXR0b25cbiAgICBhbGxvd1Jlb3JkZXI6IFtmYWxzZSwgVHlwZS5CT09MRUFOXSwgLy8gQWxsb3cgcmVvcmRlcmluZyBvZiBmaWxlc1xuICAgIGFsbG93RGlyZWN0b3JpZXNPbmx5OiBbZmFsc2UsIFR5cGUuQk9PTEVBTl0sIC8vIEFsbG93IG9ubHkgc2VsZWN0aW5nIGRpcmVjdG9yaWVzIHdpdGggYnJvd3NlIChubyBzdXBwb3J0IGZvciBmaWx0ZXJpbmcgZG5kIGF0IHRoaXMgcG9pbnQpXG5cbiAgICAvLyBSZXZlcnQgbW9kZVxuICAgIGZvcmNlUmV2ZXJ0OiBbZmFsc2UsIFR5cGUuQk9PTEVBTl0sIC8vIFNldCB0byAnZm9yY2UnIHRvIHJlcXVpcmUgdGhlIGZpbGUgdG8gYmUgcmV2ZXJ0ZWQgYmVmb3JlIHJlbW92YWxcblxuICAgIC8vIElucHV0IHJlcXVpcmVtZW50c1xuICAgIG1heEZpbGVzOiBbbnVsbCwgVHlwZS5JTlRdLCAvLyBNYXggbnVtYmVyIG9mIGZpbGVzXG4gICAgY2hlY2tWYWxpZGl0eTogW2ZhbHNlLCBUeXBlLkJPT0xFQU5dLCAvLyBFbmFibGVzIGN1c3RvbSB2YWxpZGl0eSBtZXNzYWdlc1xuXG4gICAgLy8gV2hlcmUgdG8gcHV0IGZpbGVcbiAgICBpdGVtSW5zZXJ0TG9jYXRpb25GcmVlZG9tOiBbdHJ1ZSwgVHlwZS5CT09MRUFOXSwgLy8gU2V0IHRvIGZhbHNlIHRvIGFsd2F5cyBhZGQgaXRlbXMgdG8gYmVnaW4gb3IgZW5kIG9mIGxpc3RcbiAgICBpdGVtSW5zZXJ0TG9jYXRpb246IFsnYmVmb3JlJywgVHlwZS5TVFJJTkddLCAvLyBEZWZhdWx0IGluZGV4IGluIGxpc3QgdG8gYWRkIGl0ZW1zIHRoYXQgaGF2ZSBiZWVuIGRyb3BwZWQgYXQgdGhlIHRvcCBvZiB0aGUgbGlzdFxuICAgIGl0ZW1JbnNlcnRJbnRlcnZhbDogWzc1LCBUeXBlLklOVF0sXG5cbiAgICAvLyBEcmFnICduIERyb3AgcmVsYXRlZFxuICAgIGRyb3BPblBhZ2U6IFtmYWxzZSwgVHlwZS5CT09MRUFOXSwgLy8gQWxsb3cgZHJvcHBpbmcgb2YgZmlsZXMgYW55d2hlcmUgb24gcGFnZSAocHJldmVudHMgYnJvd3NlciBmcm9tIG9wZW5pbmcgZmlsZSBpZiBkcm9wcGVkIG91dHNpZGUgb2YgVXApXG4gICAgZHJvcE9uRWxlbWVudDogW3RydWUsIFR5cGUuQk9PTEVBTl0sIC8vIERyb3AgbmVlZHMgdG8gaGFwcGVuIG9uIGVsZW1lbnQgKHNldCB0byBmYWxzZSB0byBhbHNvIGxvYWQgZHJvcHMgb3V0c2lkZSBvZiBVcClcbiAgICBkcm9wVmFsaWRhdGlvbjogW2ZhbHNlLCBUeXBlLkJPT0xFQU5dLCAvLyBFbmFibGUgb3IgZGlzYWJsZSB2YWxpZGF0aW5nIGZpbGVzIG9uIGRyb3BcbiAgICBpZ25vcmVkRmlsZXM6IFtbJy5kc19zdG9yZScsICd0aHVtYnMuZGInLCAnZGVza3RvcC5pbmknXSwgVHlwZS5BUlJBWV0sXG5cbiAgICAvLyBVcGxvYWQgcmVsYXRlZFxuICAgIGluc3RhbnRVcGxvYWQ6IFt0cnVlLCBUeXBlLkJPT0xFQU5dLCAvLyBTaG91bGQgdXBsb2FkIGZpbGVzIGltbWVkaWF0ZWx5IG9uIGRyb3BcbiAgICBtYXhQYXJhbGxlbFVwbG9hZHM6IFsyLCBUeXBlLklOVF0sIC8vIE1heGltdW0gZmlsZXMgdG8gdXBsb2FkIGluIHBhcmFsbGVsXG5cbiAgICAvLyBDaHVua3NcbiAgICBjaHVua1VwbG9hZHM6IFtmYWxzZSwgVHlwZS5CT09MRUFOXSwgLy8gRW5hYmxlIGNodW5rZWQgdXBsb2Fkc1xuICAgIGNodW5rRm9yY2U6IFtmYWxzZSwgVHlwZS5CT09MRUFOXSwgLy8gRm9yY2UgdXNlIG9mIGNodW5rIHVwbG9hZHMgZXZlbiBmb3IgZmlsZXMgc21hbGxlciB0aGFuIGNodW5rIHNpemVcbiAgICBjaHVua1NpemU6IFs1MDAwMDAwLCBUeXBlLklOVF0sIC8vIFNpemUgb2YgY2h1bmtzICg1TUIgZGVmYXVsdClcbiAgICBjaHVua1JldHJ5RGVsYXlzOiBbWzUwMCwgMTAwMCwgMzAwMF0sIFR5cGUuQXJyYXldLCAvLyBBbW91bnQgb2YgdGltZXMgdG8gcmV0cnkgdXBsb2FkIG9mIGEgY2h1bmsgd2hlbiBpdCBmYWlsc1xuXG4gICAgLy8gVGhlIHNlcnZlciBhcGkgZW5kIHBvaW50cyB0byB1c2UgZm9yIHVwbG9hZGluZyAoc2VlIGRvY3MpXG4gICAgc2VydmVyOiBbbnVsbCwgVHlwZS5TRVJWRVJfQVBJXSxcblxuICAgIC8vIEZpbGUgc2l6ZSBjYWxjdWxhdGlvbnMsIGNhbiBzZXQgdG8gMTAyNCwgdGhpcyBpcyBvbmx5IHVzZWQgZm9yIGRpc3BsYXksIHByb3BlcnRpZXMgdXNlIGZpbGUgc2l6ZSBiYXNlIDEwMDBcbiAgICBmaWxlU2l6ZUJhc2U6IFsxMDAwLCBUeXBlLklOVF0sXG5cbiAgICAvLyBMYWJlbHMgYW5kIHN0YXR1cyBtZXNzYWdlc1xuICAgIGxhYmVsRGVjaW1hbFNlcGFyYXRvcjogW2dldERlY2ltYWxTZXBhcmF0b3IoKSwgVHlwZS5TVFJJTkddLCAvLyBEZWZhdWx0IGlzIGxvY2FsZSBzZXBhcmF0b3JcbiAgICBsYWJlbFRob3VzYW5kc1NlcGFyYXRvcjogW2dldFRob3VzYW5kc1NlcGFyYXRvcigpLCBUeXBlLlNUUklOR10sIC8vIERlZmF1bHQgaXMgbG9jYWxlIHNlcGFyYXRvclxuXG4gICAgbGFiZWxJZGxlOiBbXG4gICAgICAnRHJhZyAmIERyb3AgeW91ciBmaWxlcyBvciA8c3BhbiBjbGFzcz1cImZpbGVwb25kLS1sYWJlbC1hY3Rpb25cIj5Ccm93c2U8L3NwYW4+JyxcbiAgICAgIFR5cGUuU1RSSU5HXG4gICAgXSxcbiAgICBsYWJlbEludmFsaWRGaWVsZDogWydGaWVsZCBjb250YWlucyBpbnZhbGlkIGZpbGVzJywgVHlwZS5TVFJJTkddLFxuICAgIGxhYmVsRmlsZVdhaXRpbmdGb3JTaXplOiBbJ1dhaXRpbmcgZm9yIHNpemUnLCBUeXBlLlNUUklOR10sXG4gICAgbGFiZWxGaWxlU2l6ZU5vdEF2YWlsYWJsZTogWydTaXplIG5vdCBhdmFpbGFibGUnLCBUeXBlLlNUUklOR10sXG4gICAgbGFiZWxGaWxlQ291bnRTaW5ndWxhcjogWydmaWxlIGluIGxpc3QnLCBUeXBlLlNUUklOR10sXG4gICAgbGFiZWxGaWxlQ291bnRQbHVyYWw6IFsnZmlsZXMgaW4gbGlzdCcsIFR5cGUuU1RSSU5HXSxcbiAgICBsYWJlbEZpbGVMb2FkaW5nOiBbJ0xvYWRpbmcnLCBUeXBlLlNUUklOR10sXG4gICAgbGFiZWxGaWxlQWRkZWQ6IFsnQWRkZWQnLCBUeXBlLlNUUklOR10sIC8vIGFzc2lzdGl2ZSBvbmx5XG4gICAgbGFiZWxGaWxlTG9hZEVycm9yOiBbJ0Vycm9yIGR1cmluZyBsb2FkJywgVHlwZS5TVFJJTkddLFxuICAgIGxhYmVsRmlsZVJlbW92ZWQ6IFsnUmVtb3ZlZCcsIFR5cGUuU1RSSU5HXSwgLy8gYXNzaXN0aXZlIG9ubHlcbiAgICBsYWJlbEZpbGVSZW1vdmVFcnJvcjogWydFcnJvciBkdXJpbmcgcmVtb3ZlJywgVHlwZS5TVFJJTkddLFxuICAgIGxhYmVsRmlsZVByb2Nlc3Npbmc6IFsnVXBsb2FkaW5nJywgVHlwZS5TVFJJTkddLFxuICAgIGxhYmVsRmlsZVByb2Nlc3NpbmdDb21wbGV0ZTogWydVcGxvYWQgY29tcGxldGUnLCBUeXBlLlNUUklOR10sXG4gICAgbGFiZWxGaWxlUHJvY2Vzc2luZ0Fib3J0ZWQ6IFsnVXBsb2FkIGNhbmNlbGxlZCcsIFR5cGUuU1RSSU5HXSxcbiAgICBsYWJlbEZpbGVQcm9jZXNzaW5nRXJyb3I6IFsnRXJyb3IgZHVyaW5nIHVwbG9hZCcsIFR5cGUuU1RSSU5HXSxcbiAgICBsYWJlbEZpbGVQcm9jZXNzaW5nUmV2ZXJ0RXJyb3I6IFsnRXJyb3IgZHVyaW5nIHJldmVydCcsIFR5cGUuU1RSSU5HXSxcblxuICAgIGxhYmVsVGFwVG9DYW5jZWw6IFsndGFwIHRvIGNhbmNlbCcsIFR5cGUuU1RSSU5HXSxcbiAgICBsYWJlbFRhcFRvUmV0cnk6IFsndGFwIHRvIHJldHJ5JywgVHlwZS5TVFJJTkddLFxuICAgIGxhYmVsVGFwVG9VbmRvOiBbJ3RhcCB0byB1bmRvJywgVHlwZS5TVFJJTkddLFxuXG4gICAgbGFiZWxCdXR0b25SZW1vdmVJdGVtOiBbJ1JlbW92ZScsIFR5cGUuU1RSSU5HXSxcbiAgICBsYWJlbEJ1dHRvbkFib3J0SXRlbUxvYWQ6IFsnQWJvcnQnLCBUeXBlLlNUUklOR10sXG4gICAgbGFiZWxCdXR0b25SZXRyeUl0ZW1Mb2FkOiBbJ1JldHJ5JywgVHlwZS5TVFJJTkddLFxuICAgIGxhYmVsQnV0dG9uQWJvcnRJdGVtUHJvY2Vzc2luZzogWydDYW5jZWwnLCBUeXBlLlNUUklOR10sXG4gICAgbGFiZWxCdXR0b25VbmRvSXRlbVByb2Nlc3Npbmc6IFsnVW5kbycsIFR5cGUuU1RSSU5HXSxcbiAgICBsYWJlbEJ1dHRvblJldHJ5SXRlbVByb2Nlc3Npbmc6IFsnUmV0cnknLCBUeXBlLlNUUklOR10sXG4gICAgbGFiZWxCdXR0b25Qcm9jZXNzSXRlbTogWydVcGxvYWQnLCBUeXBlLlNUUklOR10sXG5cbiAgICAvLyBtYWtlIHN1cmUgd2lkdGggYW5kIGhlaWdodCBwbHVzIHZpZXdwb3ggYXJlIGV2ZW4gbnVtYmVycyBzbyBpY29ucyBhcmUgbmljZWx5IGNlbnRlcmVkXG4gICAgaWNvblJlbW92ZTogW1xuICAgICAgJzxzdmcgd2lkdGg9XCIyNlwiIGhlaWdodD1cIjI2XCIgdmlld0JveD1cIjAgMCAyNiAyNlwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj48cGF0aCBkPVwiTTExLjU4NiAxM2wtMi4yOTMgMi4yOTNhMSAxIDAgMCAwIDEuNDE0IDEuNDE0TDEzIDE0LjQxNGwyLjI5MyAyLjI5M2ExIDEgMCAwIDAgMS40MTQtMS40MTRMMTQuNDE0IDEzbDIuMjkzLTIuMjkzYTEgMSAwIDAgMC0xLjQxNC0xLjQxNEwxMyAxMS41ODZsLTIuMjkzLTIuMjkzYTEgMSAwIDAgMC0xLjQxNCAxLjQxNEwxMS41ODYgMTN6XCIgZmlsbD1cImN1cnJlbnRDb2xvclwiIGZpbGwtcnVsZT1cIm5vbnplcm9cIi8+PC9zdmc+JyxcbiAgICAgIFR5cGUuU1RSSU5HXG4gICAgXSxcblxuICAgIGljb25Qcm9jZXNzOiBbXG4gICAgICAnPHN2ZyB3aWR0aD1cIjI2XCIgaGVpZ2h0PVwiMjZcIiB2aWV3Qm94PVwiMCAwIDI2IDI2XCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPjxwYXRoIGQ9XCJNMTQgMTAuNDE0djMuNTg1YTEgMSAwIDAgMS0yIDB2LTMuNTg1bC0xLjI5MyAxLjI5M2ExIDEgMCAwIDEtMS40MTQtMS40MTVsMy0zYTEgMSAwIDAgMSAxLjQxNCAwbDMgM2ExIDEgMCAwIDEtMS40MTQgMS40MTVMMTQgMTAuNDE0ek05IDE4YTEgMSAwIDAgMSAwLTJoOGExIDEgMCAwIDEgMCAySDl6XCIgZmlsbD1cImN1cnJlbnRDb2xvclwiIGZpbGwtcnVsZT1cImV2ZW5vZGRcIi8+PC9zdmc+JyxcbiAgICAgIFR5cGUuU1RSSU5HXG4gICAgXSxcblxuICAgIGljb25SZXRyeTogW1xuICAgICAgJzxzdmcgd2lkdGg9XCIyNlwiIGhlaWdodD1cIjI2XCIgdmlld0JveD1cIjAgMCAyNiAyNlwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj48cGF0aCBkPVwiTTEwLjgxIDkuMTg1bC0uMDM4LjAyQTQuOTk3IDQuOTk3IDAgMCAwIDggMTMuNjgzYTUgNSAwIDAgMCA1IDUgNSA1IDAgMCAwIDUtNSAxIDEgMCAwIDEgMiAwQTcgNyAwIDEgMSA5LjcyMiA3LjQ5NmwtLjg0Mi0uMjFhLjk5OS45OTkgMCAxIDEgLjQ4NC0xLjk0bDMuMjMuODA2Yy41MzUuMTMzLjg2LjY3NS43MyAxLjIxbC0uODA0IDMuMjMzYS45OTcuOTk3IDAgMCAxLTEuMjEuNzMuOTk3Ljk5NyAwIDAgMS0uNzMtMS4yMWwuMjMtLjkyOHYtLjAwMnpcIiBmaWxsPVwiY3VycmVudENvbG9yXCIgZmlsbC1ydWxlPVwibm9uemVyb1wiLz48L3N2Zz4nLFxuICAgICAgVHlwZS5TVFJJTkdcbiAgICBdLFxuXG4gICAgaWNvblVuZG86IFtcbiAgICAgICc8c3ZnIHdpZHRoPVwiMjZcIiBoZWlnaHQ9XCIyNlwiIHZpZXdCb3g9XCIwIDAgMjYgMjZcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI+PHBhdGggZD1cIk05LjE4NSAxMC44MWwuMDItLjAzOEE0Ljk5NyA0Ljk5NyAwIDAgMSAxMy42ODMgOGE1IDUgMCAwIDEgNSA1IDUgNSAwIDAgMS01IDUgMSAxIDAgMCAwIDAgMkE3IDcgMCAxIDAgNy40OTYgOS43MjJsLS4yMS0uODQyYS45OTkuOTk5IDAgMSAwLTEuOTQuNDg0bC44MDYgMy4yM2MuMTMzLjUzNS42NzUuODYgMS4yMS43M2wzLjIzMy0uODAzYS45OTcuOTk3IDAgMCAwIC43My0xLjIxLjk5Ny45OTcgMCAwIDAtMS4yMS0uNzNsLS45MjguMjMtLjAwMi0uMDAxelwiIGZpbGw9XCJjdXJyZW50Q29sb3JcIiBmaWxsLXJ1bGU9XCJub256ZXJvXCIvPjwvc3ZnPicsXG4gICAgICBUeXBlLlNUUklOR1xuICAgIF0sXG5cbiAgICBpY29uRG9uZTogW1xuICAgICAgJzxzdmcgd2lkdGg9XCIyNlwiIGhlaWdodD1cIjI2XCIgdmlld0JveD1cIjAgMCAyNiAyNlwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj48cGF0aCBkPVwiTTE4LjI5MyA5LjI5M2ExIDEgMCAwIDEgMS40MTQgMS40MTRsLTcuMDAyIDdhMSAxIDAgMCAxLTEuNDE0IDBsLTMuOTk4LTRhMSAxIDAgMSAxIDEuNDE0LTEuNDE0TDEyIDE1LjU4Nmw2LjI5NC02LjI5M3pcIiBmaWxsPVwiY3VycmVudENvbG9yXCIgZmlsbC1ydWxlPVwibm9uemVyb1wiLz48L3N2Zz4nLFxuICAgICAgVHlwZS5TVFJJTkdcbiAgICBdLFxuXG4gICAgLy8gZXZlbnQgaGFuZGxlcnNcbiAgICBvbmluaXQ6IFtudWxsLCBUeXBlLkZVTkNUSU9OXSxcbiAgICBvbndhcm5pbmc6IFtudWxsLCBUeXBlLkZVTkNUSU9OXSxcbiAgICBvbmVycm9yOiBbbnVsbCwgVHlwZS5GVU5DVElPTl0sXG4gICAgb25hY3RpdmF0ZWZpbGU6IFtudWxsLCBUeXBlLkZVTkNUSU9OXSxcbiAgICBvbmluaXRmaWxlOiBbbnVsbCwgVHlwZS5GVU5DVElPTl0sXG4gICAgb25hZGRmaWxlc3RhcnQ6IFtudWxsLCBUeXBlLkZVTkNUSU9OXSxcbiAgICBvbmFkZGZpbGVwcm9ncmVzczogW251bGwsIFR5cGUuRlVOQ1RJT05dLFxuICAgIG9uYWRkZmlsZTogW251bGwsIFR5cGUuRlVOQ1RJT05dLFxuICAgIG9ucHJvY2Vzc2ZpbGVzdGFydDogW251bGwsIFR5cGUuRlVOQ1RJT05dLFxuICAgIG9ucHJvY2Vzc2ZpbGVwcm9ncmVzczogW251bGwsIFR5cGUuRlVOQ1RJT05dLFxuICAgIG9ucHJvY2Vzc2ZpbGVhYm9ydDogW251bGwsIFR5cGUuRlVOQ1RJT05dLFxuICAgIG9ucHJvY2Vzc2ZpbGVyZXZlcnQ6IFtudWxsLCBUeXBlLkZVTkNUSU9OXSxcbiAgICBvbnByb2Nlc3NmaWxlOiBbbnVsbCwgVHlwZS5GVU5DVElPTl0sXG4gICAgb25wcm9jZXNzZmlsZXM6IFtudWxsLCBUeXBlLkZVTkNUSU9OXSxcbiAgICBvbnJlbW92ZWZpbGU6IFtudWxsLCBUeXBlLkZVTkNUSU9OXSxcbiAgICBvbnByZXBhcmVmaWxlOiBbbnVsbCwgVHlwZS5GVU5DVElPTl0sXG4gICAgb251cGRhdGVmaWxlczogW251bGwsIFR5cGUuRlVOQ1RJT05dLFxuICAgIG9ucmVvcmRlcmZpbGVzOiBbbnVsbCwgVHlwZS5GVU5DVElPTl0sXG5cbiAgICAvLyBob29rc1xuICAgIGJlZm9yZURyb3BGaWxlOiBbbnVsbCwgVHlwZS5GVU5DVElPTl0sXG4gICAgYmVmb3JlQWRkRmlsZTogW251bGwsIFR5cGUuRlVOQ1RJT05dLFxuICAgIGJlZm9yZVJlbW92ZUZpbGU6IFtudWxsLCBUeXBlLkZVTkNUSU9OXSxcblxuICAgIC8vIHN0eWxlc1xuICAgIHN0eWxlUGFuZWxMYXlvdXQ6IFtudWxsLCBUeXBlLlNUUklOR10sIC8vIG51bGwgJ2ludGVncmF0ZWQnLCAnY29tcGFjdCcsICdjaXJjbGUnXG4gICAgc3R5bGVQYW5lbEFzcGVjdFJhdGlvOiBbbnVsbCwgVHlwZS5TVFJJTkddLCAvLyBudWxsIG9yICczOjInIG9yIDFcbiAgICBzdHlsZUl0ZW1QYW5lbEFzcGVjdFJhdGlvOiBbbnVsbCwgVHlwZS5TVFJJTkddLFxuICAgIHN0eWxlQnV0dG9uUmVtb3ZlSXRlbVBvc2l0aW9uOiBbJ2xlZnQnLCBUeXBlLlNUUklOR10sXG4gICAgc3R5bGVCdXR0b25Qcm9jZXNzSXRlbVBvc2l0aW9uOiBbJ3JpZ2h0JywgVHlwZS5TVFJJTkddLFxuICAgIHN0eWxlTG9hZEluZGljYXRvclBvc2l0aW9uOiBbJ3JpZ2h0JywgVHlwZS5TVFJJTkddLFxuICAgIHN0eWxlUHJvZ3Jlc3NJbmRpY2F0b3JQb3NpdGlvbjogWydyaWdodCcsIFR5cGUuU1RSSU5HXSxcbiAgICBzdHlsZUJ1dHRvblJlbW92ZUl0ZW1BbGlnbjogW2ZhbHNlLCBUeXBlLkJPT0xFQU5dLFxuXG4gICAgLy8gY3VzdG9tIGluaXRpYWwgZmlsZXMgYXJyYXlcbiAgICBmaWxlczogW1tdLCBUeXBlLkFSUkFZXSxcblxuICAgIC8vIHNob3cgc3VwcG9ydCBieSBkaXNwbGF5aW5nIGNyZWRpdHNcbiAgICBjcmVkaXRzOiBbWydodHRwczovL3BxaW5hLm5sLycsICdQb3dlcmVkIGJ5IFBRSU5BJ10sIFR5cGUuQVJSQVldXG4gIH07XG5cbiAgdmFyIGdldEl0ZW1CeVF1ZXJ5ID0gZnVuY3Rpb24gZ2V0SXRlbUJ5UXVlcnkoaXRlbXMsIHF1ZXJ5KSB7XG4gICAgLy8ganVzdCByZXR1cm4gZmlyc3QgaW5kZXhcbiAgICBpZiAoaXNFbXB0eShxdWVyeSkpIHtcbiAgICAgIHJldHVybiBpdGVtc1swXSB8fCBudWxsO1xuICAgIH1cblxuICAgIC8vIHF1ZXJ5IGlzIGluZGV4XG4gICAgaWYgKGlzSW50KHF1ZXJ5KSkge1xuICAgICAgcmV0dXJuIGl0ZW1zW3F1ZXJ5XSB8fCBudWxsO1xuICAgIH1cblxuICAgIC8vIGlmIHF1ZXJ5IGlzIGl0ZW0sIGdldCB0aGUgaWRcbiAgICBpZiAodHlwZW9mIHF1ZXJ5ID09PSAnb2JqZWN0Jykge1xuICAgICAgcXVlcnkgPSBxdWVyeS5pZDtcbiAgICB9XG5cbiAgICAvLyBhc3N1bWUgcXVlcnkgaXMgYSBzdHJpbmcgYW5kIHJldHVybiBpdGVtIGJ5IGlkXG4gICAgcmV0dXJuIChcbiAgICAgIGl0ZW1zLmZpbmQoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICByZXR1cm4gaXRlbS5pZCA9PT0gcXVlcnk7XG4gICAgICB9KSB8fCBudWxsXG4gICAgKTtcbiAgfTtcblxuICB2YXIgZ2V0TnVtZXJpY0FzcGVjdFJhdGlvRnJvbVN0cmluZyA9IGZ1bmN0aW9uIGdldE51bWVyaWNBc3BlY3RSYXRpb0Zyb21TdHJpbmcoXG4gICAgYXNwZWN0UmF0aW9cbiAgKSB7XG4gICAgaWYgKGlzRW1wdHkoYXNwZWN0UmF0aW8pKSB7XG4gICAgICByZXR1cm4gYXNwZWN0UmF0aW87XG4gICAgfVxuICAgIGlmICgvOi8udGVzdChhc3BlY3RSYXRpbykpIHtcbiAgICAgIHZhciBwYXJ0cyA9IGFzcGVjdFJhdGlvLnNwbGl0KCc6Jyk7XG4gICAgICByZXR1cm4gcGFydHNbMV0gLyBwYXJ0c1swXTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQoYXNwZWN0UmF0aW8pO1xuICB9O1xuXG4gIHZhciBnZXRBY3RpdmVJdGVtcyA9IGZ1bmN0aW9uIGdldEFjdGl2ZUl0ZW1zKGl0ZW1zKSB7XG4gICAgcmV0dXJuIGl0ZW1zLmZpbHRlcihmdW5jdGlvbihpdGVtKSB7XG4gICAgICByZXR1cm4gIWl0ZW0uYXJjaGl2ZWQ7XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIFN0YXR1cyA9IHtcbiAgICBFTVBUWTogMCxcbiAgICBJRExFOiAxLCAvLyB3YWl0aW5nXG4gICAgRVJST1I6IDIsIC8vIGEgZmlsZSBpcyBpbiBlcnJvciBzdGF0ZVxuICAgIEJVU1k6IDMsIC8vIGJ1c3kgcHJvY2Vzc2luZyBvciBsb2FkaW5nXG4gICAgUkVBRFk6IDQgLy8gYWxsIGZpbGVzIHVwbG9hZGVkXG4gIH07XG5cbiAgdmFyIElURU1fRVJST1IgPSBbXG4gICAgSXRlbVN0YXR1cy5MT0FEX0VSUk9SLFxuICAgIEl0ZW1TdGF0dXMuUFJPQ0VTU0lOR19FUlJPUixcbiAgICBJdGVtU3RhdHVzLlBST0NFU1NJTkdfUkVWRVJUX0VSUk9SXG4gIF07XG4gIHZhciBJVEVNX0JVU1kgPSBbXG4gICAgSXRlbVN0YXR1cy5MT0FESU5HLFxuICAgIEl0ZW1TdGF0dXMuUFJPQ0VTU0lORyxcbiAgICBJdGVtU3RhdHVzLlBST0NFU1NJTkdfUVVFVUVELFxuICAgIEl0ZW1TdGF0dXMuSU5JVFxuICBdO1xuICB2YXIgSVRFTV9SRUFEWSA9IFtJdGVtU3RhdHVzLlBST0NFU1NJTkdfQ09NUExFVEVdO1xuXG4gIHZhciBpc0l0ZW1JbkVycm9yU3RhdGUgPSBmdW5jdGlvbiBpc0l0ZW1JbkVycm9yU3RhdGUoaXRlbSkge1xuICAgIHJldHVybiBJVEVNX0VSUk9SLmluY2x1ZGVzKGl0ZW0uc3RhdHVzKTtcbiAgfTtcbiAgdmFyIGlzSXRlbUluQnVzeVN0YXRlID0gZnVuY3Rpb24gaXNJdGVtSW5CdXN5U3RhdGUoaXRlbSkge1xuICAgIHJldHVybiBJVEVNX0JVU1kuaW5jbHVkZXMoaXRlbS5zdGF0dXMpO1xuICB9O1xuICB2YXIgaXNJdGVtSW5SZWFkeVN0YXRlID0gZnVuY3Rpb24gaXNJdGVtSW5SZWFkeVN0YXRlKGl0ZW0pIHtcbiAgICByZXR1cm4gSVRFTV9SRUFEWS5pbmNsdWRlcyhpdGVtLnN0YXR1cyk7XG4gIH07XG5cbiAgdmFyIHF1ZXJpZXMgPSBmdW5jdGlvbiBxdWVyaWVzKHN0YXRlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIEdFVF9TVEFUVVM6IGZ1bmN0aW9uIEdFVF9TVEFUVVMoKSB7XG4gICAgICAgIHZhciBpdGVtcyA9IGdldEFjdGl2ZUl0ZW1zKHN0YXRlLml0ZW1zKTtcbiAgICAgICAgdmFyIEVNUFRZID0gU3RhdHVzLkVNUFRZLFxuICAgICAgICAgIEVSUk9SID0gU3RhdHVzLkVSUk9SLFxuICAgICAgICAgIEJVU1kgPSBTdGF0dXMuQlVTWSxcbiAgICAgICAgICBJRExFID0gU3RhdHVzLklETEUsXG4gICAgICAgICAgUkVBRFkgPSBTdGF0dXMuUkVBRFk7XG5cbiAgICAgICAgaWYgKGl0ZW1zLmxlbmd0aCA9PT0gMCkgcmV0dXJuIEVNUFRZO1xuXG4gICAgICAgIGlmIChpdGVtcy5zb21lKGlzSXRlbUluRXJyb3JTdGF0ZSkpIHJldHVybiBFUlJPUjtcblxuICAgICAgICBpZiAoaXRlbXMuc29tZShpc0l0ZW1JbkJ1c3lTdGF0ZSkpIHJldHVybiBCVVNZO1xuXG4gICAgICAgIGlmIChpdGVtcy5zb21lKGlzSXRlbUluUmVhZHlTdGF0ZSkpIHJldHVybiBSRUFEWTtcblxuICAgICAgICByZXR1cm4gSURMRTtcbiAgICAgIH0sXG5cbiAgICAgIEdFVF9JVEVNOiBmdW5jdGlvbiBHRVRfSVRFTShxdWVyeSkge1xuICAgICAgICByZXR1cm4gZ2V0SXRlbUJ5UXVlcnkoc3RhdGUuaXRlbXMsIHF1ZXJ5KTtcbiAgICAgIH0sXG5cbiAgICAgIEdFVF9BQ1RJVkVfSVRFTTogZnVuY3Rpb24gR0VUX0FDVElWRV9JVEVNKHF1ZXJ5KSB7XG4gICAgICAgIHJldHVybiBnZXRJdGVtQnlRdWVyeShnZXRBY3RpdmVJdGVtcyhzdGF0ZS5pdGVtcyksIHF1ZXJ5KTtcbiAgICAgIH0sXG5cbiAgICAgIEdFVF9BQ1RJVkVfSVRFTVM6IGZ1bmN0aW9uIEdFVF9BQ1RJVkVfSVRFTVMoKSB7XG4gICAgICAgIHJldHVybiBnZXRBY3RpdmVJdGVtcyhzdGF0ZS5pdGVtcyk7XG4gICAgICB9LFxuXG4gICAgICBHRVRfSVRFTVM6IGZ1bmN0aW9uIEdFVF9JVEVNUygpIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlLml0ZW1zO1xuICAgICAgfSxcblxuICAgICAgR0VUX0lURU1fTkFNRTogZnVuY3Rpb24gR0VUX0lURU1fTkFNRShxdWVyeSkge1xuICAgICAgICB2YXIgaXRlbSA9IGdldEl0ZW1CeVF1ZXJ5KHN0YXRlLml0ZW1zLCBxdWVyeSk7XG4gICAgICAgIHJldHVybiBpdGVtID8gaXRlbS5maWxlbmFtZSA6IG51bGw7XG4gICAgICB9LFxuXG4gICAgICBHRVRfSVRFTV9TSVpFOiBmdW5jdGlvbiBHRVRfSVRFTV9TSVpFKHF1ZXJ5KSB7XG4gICAgICAgIHZhciBpdGVtID0gZ2V0SXRlbUJ5UXVlcnkoc3RhdGUuaXRlbXMsIHF1ZXJ5KTtcbiAgICAgICAgcmV0dXJuIGl0ZW0gPyBpdGVtLmZpbGVTaXplIDogbnVsbDtcbiAgICAgIH0sXG5cbiAgICAgIEdFVF9TVFlMRVM6IGZ1bmN0aW9uIEdFVF9TVFlMRVMoKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhzdGF0ZS5vcHRpb25zKVxuICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gL15zdHlsZS8udGVzdChrZXkpO1xuICAgICAgICAgIH0pXG4gICAgICAgICAgLm1hcChmdW5jdGlvbihvcHRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIG5hbWU6IG9wdGlvbixcbiAgICAgICAgICAgICAgdmFsdWU6IHN0YXRlLm9wdGlvbnNbb3B0aW9uXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KTtcbiAgICAgIH0sXG5cbiAgICAgIEdFVF9QQU5FTF9BU1BFQ1RfUkFUSU86IGZ1bmN0aW9uIEdFVF9QQU5FTF9BU1BFQ1RfUkFUSU8oKSB7XG4gICAgICAgIHZhciBpc1NoYXBlQ2lyY2xlID0gL2NpcmNsZS8udGVzdChzdGF0ZS5vcHRpb25zLnN0eWxlUGFuZWxMYXlvdXQpO1xuICAgICAgICB2YXIgYXNwZWN0UmF0aW8gPSBpc1NoYXBlQ2lyY2xlXG4gICAgICAgICAgPyAxXG4gICAgICAgICAgOiBnZXROdW1lcmljQXNwZWN0UmF0aW9Gcm9tU3RyaW5nKFxuICAgICAgICAgICAgICBzdGF0ZS5vcHRpb25zLnN0eWxlUGFuZWxBc3BlY3RSYXRpb1xuICAgICAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIGFzcGVjdFJhdGlvO1xuICAgICAgfSxcblxuICAgICAgR0VUX0lURU1fUEFORUxfQVNQRUNUX1JBVElPOiBmdW5jdGlvbiBHRVRfSVRFTV9QQU5FTF9BU1BFQ1RfUkFUSU8oKSB7XG4gICAgICAgIHJldHVybiBzdGF0ZS5vcHRpb25zLnN0eWxlSXRlbVBhbmVsQXNwZWN0UmF0aW87XG4gICAgICB9LFxuXG4gICAgICBHRVRfSVRFTVNfQllfU1RBVFVTOiBmdW5jdGlvbiBHRVRfSVRFTVNfQllfU1RBVFVTKHN0YXR1cykge1xuICAgICAgICByZXR1cm4gZ2V0QWN0aXZlSXRlbXMoc3RhdGUuaXRlbXMpLmZpbHRlcihmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgcmV0dXJuIGl0ZW0uc3RhdHVzID09PSBzdGF0dXM7XG4gICAgICAgIH0pO1xuICAgICAgfSxcblxuICAgICAgR0VUX1RPVEFMX0lURU1TOiBmdW5jdGlvbiBHRVRfVE9UQUxfSVRFTVMoKSB7XG4gICAgICAgIHJldHVybiBnZXRBY3RpdmVJdGVtcyhzdGF0ZS5pdGVtcykubGVuZ3RoO1xuICAgICAgfSxcblxuICAgICAgSVNfQVNZTkM6IGZ1bmN0aW9uIElTX0FTWU5DKCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGlzT2JqZWN0KHN0YXRlLm9wdGlvbnMuc2VydmVyKSAmJlxuICAgICAgICAgIChpc09iamVjdChzdGF0ZS5vcHRpb25zLnNlcnZlci5wcm9jZXNzKSB8fFxuICAgICAgICAgICAgaXNGdW5jdGlvbihzdGF0ZS5vcHRpb25zLnNlcnZlci5wcm9jZXNzKSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIHZhciBoYXNSb29tRm9ySXRlbSA9IGZ1bmN0aW9uIGhhc1Jvb21Gb3JJdGVtKHN0YXRlKSB7XG4gICAgdmFyIGNvdW50ID0gZ2V0QWN0aXZlSXRlbXMoc3RhdGUuaXRlbXMpLmxlbmd0aDtcblxuICAgIC8vIGlmIGNhbm5vdCBoYXZlIG11bHRpcGxlIGl0ZW1zLCB0byBhZGQgb25lIGl0ZW0gaXQgc2hvdWxkIGN1cnJlbnRseSBub3QgY29udGFpbiBpdGVtc1xuICAgIGlmICghc3RhdGUub3B0aW9ucy5hbGxvd011bHRpcGxlKSB7XG4gICAgICByZXR1cm4gY291bnQgPT09IDA7XG4gICAgfVxuXG4gICAgLy8gaWYgYWxsb3dzIG11bHRpcGxlIGl0ZW1zLCB3ZSBjaGVjayBpZiBhIG1heCBpdGVtIGNvdW50IGhhcyBiZWVuIHNldCwgaWYgbm90LCB0aGVyZSdzIG5vIGxpbWl0XG4gICAgdmFyIG1heEZpbGVDb3VudCA9IHN0YXRlLm9wdGlvbnMubWF4RmlsZXM7XG4gICAgaWYgKG1heEZpbGVDb3VudCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gd2UgY2hlY2sgaWYgdGhlIGN1cnJlbnQgY291bnQgaXMgc21hbGxlciB0aGFuIHRoZSBtYXggY291bnQsIGlmIHNvLCBhbm90aGVyIGZpbGUgY2FuIHN0aWxsIGJlIGFkZGVkXG4gICAgaWYgKGNvdW50IDwgbWF4RmlsZUNvdW50KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBubyBtb3JlIHJvb20gZm9yIGFub3RoZXIgZmlsZVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICB2YXIgbGltaXQgPSBmdW5jdGlvbiBsaW1pdCh2YWx1ZSwgbWluLCBtYXgpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgoTWF0aC5taW4obWF4LCB2YWx1ZSksIG1pbik7XG4gIH07XG5cbiAgdmFyIGFycmF5SW5zZXJ0ID0gZnVuY3Rpb24gYXJyYXlJbnNlcnQoYXJyLCBpbmRleCwgaXRlbSkge1xuICAgIHJldHVybiBhcnIuc3BsaWNlKGluZGV4LCAwLCBpdGVtKTtcbiAgfTtcblxuICB2YXIgaW5zZXJ0SXRlbSA9IGZ1bmN0aW9uIGluc2VydEl0ZW0oaXRlbXMsIGl0ZW0sIGluZGV4KSB7XG4gICAgaWYgKGlzRW1wdHkoaXRlbSkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIGlmIGluZGV4IGlzIHVuZGVmaW5lZCwgYXBwZW5kXG4gICAgaWYgKHR5cGVvZiBpbmRleCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGl0ZW1zLnB1c2goaXRlbSk7XG4gICAgICByZXR1cm4gaXRlbTtcbiAgICB9XG5cbiAgICAvLyBsaW1pdCB0aGUgaW5kZXggdG8gdGhlIHNpemUgb2YgdGhlIGl0ZW1zIGFycmF5XG4gICAgaW5kZXggPSBsaW1pdChpbmRleCwgMCwgaXRlbXMubGVuZ3RoKTtcblxuICAgIC8vIGFkZCBpdGVtIHRvIGFycmF5XG4gICAgYXJyYXlJbnNlcnQoaXRlbXMsIGluZGV4LCBpdGVtKTtcblxuICAgIC8vIGV4cG9zZVxuICAgIHJldHVybiBpdGVtO1xuICB9O1xuXG4gIHZhciBpc0Jhc2U2NERhdGFVUkkgPSBmdW5jdGlvbiBpc0Jhc2U2NERhdGFVUkkoc3RyKSB7XG4gICAgcmV0dXJuIC9eXFxzKmRhdGE6KFthLXpdK1xcL1thLXowLTktKy5dKyg7W2Etei1dKz1bYS16MC05LV0rKT8pPyg7YmFzZTY0KT8sKFthLXowLTkhJCYnLCgpKis7PVxcLS5ffjpAXFwvPyVcXHNdKilcXHMqJC9pLnRlc3QoXG4gICAgICBzdHJcbiAgICApO1xuICB9O1xuXG4gIHZhciBnZXRGaWxlbmFtZUZyb21VUkwgPSBmdW5jdGlvbiBnZXRGaWxlbmFtZUZyb21VUkwodXJsKSB7XG4gICAgcmV0dXJuIHVybFxuICAgICAgLnNwbGl0KCcvJylcbiAgICAgIC5wb3AoKVxuICAgICAgLnNwbGl0KCc/JylcbiAgICAgIC5zaGlmdCgpO1xuICB9O1xuXG4gIHZhciBnZXRFeHRlbnNpb25Gcm9tRmlsZW5hbWUgPSBmdW5jdGlvbiBnZXRFeHRlbnNpb25Gcm9tRmlsZW5hbWUobmFtZSkge1xuICAgIHJldHVybiBuYW1lLnNwbGl0KCcuJykucG9wKCk7XG4gIH07XG5cbiAgdmFyIGd1ZXNzdGltYXRlRXh0ZW5zaW9uID0gZnVuY3Rpb24gZ3Vlc3N0aW1hdGVFeHRlbnNpb24odHlwZSkge1xuICAgIC8vIGlmIG5vIGV4dGVuc2lvbiBzdXBwbGllZCwgZXhpdCBoZXJlXG4gICAgaWYgKHR5cGVvZiB0eXBlICE9PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIC8vIGdldCBzdWJ0eXBlXG4gICAgdmFyIHN1YnR5cGUgPSB0eXBlLnNwbGl0KCcvJykucG9wKCk7XG5cbiAgICAvLyBpcyBzdmcgc3VidHlwZVxuICAgIGlmICgvc3ZnLy50ZXN0KHN1YnR5cGUpKSB7XG4gICAgICByZXR1cm4gJ3N2Zyc7XG4gICAgfVxuXG4gICAgaWYgKC96aXB8Y29tcHJlc3NlZC8udGVzdChzdWJ0eXBlKSkge1xuICAgICAgcmV0dXJuICd6aXAnO1xuICAgIH1cblxuICAgIGlmICgvcGxhaW4vLnRlc3Qoc3VidHlwZSkpIHtcbiAgICAgIHJldHVybiAndHh0JztcbiAgICB9XG5cbiAgICBpZiAoL21zd29yZC8udGVzdChzdWJ0eXBlKSkge1xuICAgICAgcmV0dXJuICdkb2MnO1xuICAgIH1cblxuICAgIC8vIGlmIGlzIHZhbGlkIHN1YnR5cGVcbiAgICBpZiAoL1thLXpdKy8udGVzdChzdWJ0eXBlKSkge1xuICAgICAgLy8gYWx3YXlzIHVzZSBqcGcgZXh0ZW5zaW9uXG4gICAgICBpZiAoc3VidHlwZSA9PT0gJ2pwZWcnKSB7XG4gICAgICAgIHJldHVybiAnanBnJztcbiAgICAgIH1cblxuICAgICAgLy8gcmV0dXJuIHN1YnR5cGVcbiAgICAgIHJldHVybiBzdWJ0eXBlO1xuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfTtcblxuICB2YXIgbGVmdFBhZCA9IGZ1bmN0aW9uIGxlZnRQYWQodmFsdWUpIHtcbiAgICB2YXIgcGFkZGluZyA9XG4gICAgICBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICcnO1xuICAgIHJldHVybiAocGFkZGluZyArIHZhbHVlKS5zbGljZSgtcGFkZGluZy5sZW5ndGgpO1xuICB9O1xuXG4gIHZhciBnZXREYXRlU3RyaW5nID0gZnVuY3Rpb24gZ2V0RGF0ZVN0cmluZygpIHtcbiAgICB2YXIgZGF0ZSA9XG4gICAgICBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZFxuICAgICAgICA/IGFyZ3VtZW50c1swXVxuICAgICAgICA6IG5ldyBEYXRlKCk7XG4gICAgcmV0dXJuIChcbiAgICAgIGRhdGUuZ2V0RnVsbFllYXIoKSArXG4gICAgICAnLScgK1xuICAgICAgbGVmdFBhZChkYXRlLmdldE1vbnRoKCkgKyAxLCAnMDAnKSArXG4gICAgICAnLScgK1xuICAgICAgbGVmdFBhZChkYXRlLmdldERhdGUoKSwgJzAwJykgK1xuICAgICAgJ18nICtcbiAgICAgIGxlZnRQYWQoZGF0ZS5nZXRIb3VycygpLCAnMDAnKSArXG4gICAgICAnLScgK1xuICAgICAgbGVmdFBhZChkYXRlLmdldE1pbnV0ZXMoKSwgJzAwJykgK1xuICAgICAgJy0nICtcbiAgICAgIGxlZnRQYWQoZGF0ZS5nZXRTZWNvbmRzKCksICcwMCcpXG4gICAgKTtcbiAgfTtcblxuICB2YXIgZ2V0RmlsZUZyb21CbG9iID0gZnVuY3Rpb24gZ2V0RmlsZUZyb21CbG9iKGJsb2IsIGZpbGVuYW1lKSB7XG4gICAgdmFyIHR5cGUgPVxuICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBudWxsO1xuICAgIHZhciBleHRlbnNpb24gPVxuICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBudWxsO1xuICAgIHZhciBmaWxlID1cbiAgICAgIHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJ1xuICAgICAgICA/IGJsb2Iuc2xpY2UoMCwgYmxvYi5zaXplLCB0eXBlKVxuICAgICAgICA6IGJsb2Iuc2xpY2UoMCwgYmxvYi5zaXplLCBibG9iLnR5cGUpO1xuICAgIGZpbGUubGFzdE1vZGlmaWVkRGF0ZSA9IG5ldyBEYXRlKCk7XG5cbiAgICAvLyBjb3B5IHJlbGF0aXZlIHBhdGhcbiAgICBpZiAoYmxvYi5fcmVsYXRpdmVQYXRoKSBmaWxlLl9yZWxhdGl2ZVBhdGggPSBibG9iLl9yZWxhdGl2ZVBhdGg7XG5cbiAgICAvLyBpZiBibG9iIGhhcyBuYW1lIHByb3BlcnR5LCB1c2UgYXMgZmlsZW5hbWUgaWYgbm8gZmlsZW5hbWUgc3VwcGxpZWRcbiAgICBpZiAoIWlzU3RyaW5nKGZpbGVuYW1lKSkge1xuICAgICAgZmlsZW5hbWUgPSBnZXREYXRlU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgLy8gaWYgZmlsZW5hbWUgc3VwcGxpZWQgYnV0IG5vIGV4dGVuc2lvbiBhbmQgZmlsZW5hbWUgaGFzIGV4dGVuc2lvblxuICAgIGlmIChmaWxlbmFtZSAmJiBleHRlbnNpb24gPT09IG51bGwgJiYgZ2V0RXh0ZW5zaW9uRnJvbUZpbGVuYW1lKGZpbGVuYW1lKSkge1xuICAgICAgZmlsZS5uYW1lID0gZmlsZW5hbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4dGVuc2lvbiA9IGV4dGVuc2lvbiB8fCBndWVzc3RpbWF0ZUV4dGVuc2lvbihmaWxlLnR5cGUpO1xuICAgICAgZmlsZS5uYW1lID0gZmlsZW5hbWUgKyAoZXh0ZW5zaW9uID8gJy4nICsgZXh0ZW5zaW9uIDogJycpO1xuICAgIH1cblxuICAgIHJldHVybiBmaWxlO1xuICB9O1xuXG4gIHZhciBnZXRCbG9iQnVpbGRlciA9IGZ1bmN0aW9uIGdldEJsb2JCdWlsZGVyKCkge1xuICAgIHJldHVybiAod2luZG93LkJsb2JCdWlsZGVyID1cbiAgICAgIHdpbmRvdy5CbG9iQnVpbGRlciB8fFxuICAgICAgd2luZG93LldlYktpdEJsb2JCdWlsZGVyIHx8XG4gICAgICB3aW5kb3cuTW96QmxvYkJ1aWxkZXIgfHxcbiAgICAgIHdpbmRvdy5NU0Jsb2JCdWlsZGVyKTtcbiAgfTtcblxuICB2YXIgY3JlYXRlQmxvYiA9IGZ1bmN0aW9uIGNyZWF0ZUJsb2IoYXJyYXlCdWZmZXIsIG1pbWVUeXBlKSB7XG4gICAgdmFyIEJCID0gZ2V0QmxvYkJ1aWxkZXIoKTtcblxuICAgIGlmIChCQikge1xuICAgICAgdmFyIGJiID0gbmV3IEJCKCk7XG4gICAgICBiYi5hcHBlbmQoYXJyYXlCdWZmZXIpO1xuICAgICAgcmV0dXJuIGJiLmdldEJsb2IobWltZVR5cGUpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgQmxvYihbYXJyYXlCdWZmZXJdLCB7XG4gICAgICB0eXBlOiBtaW1lVHlwZVxuICAgIH0pO1xuICB9O1xuXG4gIHZhciBnZXRCbG9iRnJvbUJ5dGVTdHJpbmdXaXRoTWltZVR5cGUgPSBmdW5jdGlvbiBnZXRCbG9iRnJvbUJ5dGVTdHJpbmdXaXRoTWltZVR5cGUoXG4gICAgYnl0ZVN0cmluZyxcbiAgICBtaW1lVHlwZVxuICApIHtcbiAgICB2YXIgYWIgPSBuZXcgQXJyYXlCdWZmZXIoYnl0ZVN0cmluZy5sZW5ndGgpO1xuICAgIHZhciBpYSA9IG5ldyBVaW50OEFycmF5KGFiKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZVN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgaWFbaV0gPSBieXRlU3RyaW5nLmNoYXJDb2RlQXQoaSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNyZWF0ZUJsb2IoYWIsIG1pbWVUeXBlKTtcbiAgfTtcblxuICB2YXIgZ2V0TWltZVR5cGVGcm9tQmFzZTY0RGF0YVVSSSA9IGZ1bmN0aW9uIGdldE1pbWVUeXBlRnJvbUJhc2U2NERhdGFVUkkoXG4gICAgZGF0YVVSSVxuICApIHtcbiAgICByZXR1cm4gKC9eZGF0YTooLispOy8uZXhlYyhkYXRhVVJJKSB8fCBbXSlbMV0gfHwgbnVsbDtcbiAgfTtcblxuICB2YXIgZ2V0QmFzZTY0RGF0YUZyb21CYXNlNjREYXRhVVJJID0gZnVuY3Rpb24gZ2V0QmFzZTY0RGF0YUZyb21CYXNlNjREYXRhVVJJKFxuICAgIGRhdGFVUklcbiAgKSB7XG4gICAgLy8gZ2V0IGRhdGEgcGFydCBvZiBzdHJpbmcgKHJlbW92ZSBkYXRhOmltYWdlL2pwZWcuLi4sKVxuICAgIHZhciBkYXRhID0gZGF0YVVSSS5zcGxpdCgnLCcpWzFdO1xuXG4gICAgLy8gcmVtb3ZlIGFueSB3aGl0ZXNwYWNlIGFzIHRoYXQgY2F1c2VzIEludmFsaWRDaGFyYWN0ZXJFcnJvciBpbiBJRVxuICAgIHJldHVybiBkYXRhLnJlcGxhY2UoL1xccy9nLCAnJyk7XG4gIH07XG5cbiAgdmFyIGdldEJ5dGVTdHJpbmdGcm9tQmFzZTY0RGF0YVVSSSA9IGZ1bmN0aW9uIGdldEJ5dGVTdHJpbmdGcm9tQmFzZTY0RGF0YVVSSShcbiAgICBkYXRhVVJJXG4gICkge1xuICAgIHJldHVybiBhdG9iKGdldEJhc2U2NERhdGFGcm9tQmFzZTY0RGF0YVVSSShkYXRhVVJJKSk7XG4gIH07XG5cbiAgdmFyIGdldEJsb2JGcm9tQmFzZTY0RGF0YVVSSSA9IGZ1bmN0aW9uIGdldEJsb2JGcm9tQmFzZTY0RGF0YVVSSShkYXRhVVJJKSB7XG4gICAgdmFyIG1pbWVUeXBlID0gZ2V0TWltZVR5cGVGcm9tQmFzZTY0RGF0YVVSSShkYXRhVVJJKTtcbiAgICB2YXIgYnl0ZVN0cmluZyA9IGdldEJ5dGVTdHJpbmdGcm9tQmFzZTY0RGF0YVVSSShkYXRhVVJJKTtcblxuICAgIHJldHVybiBnZXRCbG9iRnJvbUJ5dGVTdHJpbmdXaXRoTWltZVR5cGUoYnl0ZVN0cmluZywgbWltZVR5cGUpO1xuICB9O1xuXG4gIHZhciBnZXRGaWxlRnJvbUJhc2U2NERhdGFVUkkgPSBmdW5jdGlvbiBnZXRGaWxlRnJvbUJhc2U2NERhdGFVUkkoXG4gICAgZGF0YVVSSSxcbiAgICBmaWxlbmFtZSxcbiAgICBleHRlbnNpb25cbiAgKSB7XG4gICAgcmV0dXJuIGdldEZpbGVGcm9tQmxvYihcbiAgICAgIGdldEJsb2JGcm9tQmFzZTY0RGF0YVVSSShkYXRhVVJJKSxcbiAgICAgIGZpbGVuYW1lLFxuICAgICAgbnVsbCxcbiAgICAgIGV4dGVuc2lvblxuICAgICk7XG4gIH07XG5cbiAgdmFyIGdldEZpbGVOYW1lRnJvbUhlYWRlciA9IGZ1bmN0aW9uIGdldEZpbGVOYW1lRnJvbUhlYWRlcihoZWFkZXIpIHtcbiAgICAvLyB0ZXN0IGlmIGlzIGNvbnRlbnQgZGlzcG9zaXRpb24gaGVhZGVyLCBpZiBub3QgZXhpdFxuICAgIGlmICghL15jb250ZW50LWRpc3Bvc2l0aW9uOi9pLnRlc3QoaGVhZGVyKSkgcmV0dXJuIG51bGw7XG5cbiAgICAvLyBnZXQgZmlsZW5hbWUgcGFydHNcbiAgICB2YXIgbWF0Y2hlcyA9IGhlYWRlclxuICAgICAgLnNwbGl0KC9maWxlbmFtZT18ZmlsZW5hbWVcXCo9LisnJy8pXG4gICAgICAuc3BsaWNlKDEpXG4gICAgICAubWFwKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG5hbWUudHJpbSgpLnJlcGxhY2UoL15bXCInXXxbO1wiJ117MCwyfSQvZywgJycpO1xuICAgICAgfSlcbiAgICAgIC5maWx0ZXIoZnVuY3Rpb24obmFtZSkge1xuICAgICAgICByZXR1cm4gbmFtZS5sZW5ndGg7XG4gICAgICB9KTtcblxuICAgIHJldHVybiBtYXRjaGVzLmxlbmd0aCA/IGRlY29kZVVSSShtYXRjaGVzW21hdGNoZXMubGVuZ3RoIC0gMV0pIDogbnVsbDtcbiAgfTtcblxuICB2YXIgZ2V0RmlsZVNpemVGcm9tSGVhZGVyID0gZnVuY3Rpb24gZ2V0RmlsZVNpemVGcm9tSGVhZGVyKGhlYWRlcikge1xuICAgIGlmICgvY29udGVudC1sZW5ndGg6L2kudGVzdChoZWFkZXIpKSB7XG4gICAgICB2YXIgc2l6ZSA9IGhlYWRlci5tYXRjaCgvWzAtOV0rLylbMF07XG4gICAgICByZXR1cm4gc2l6ZSA/IHBhcnNlSW50KHNpemUsIDEwKSA6IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIHZhciBnZXRUcmFuZnNlcklkRnJvbUhlYWRlciA9IGZ1bmN0aW9uIGdldFRyYW5mc2VySWRGcm9tSGVhZGVyKGhlYWRlcikge1xuICAgIGlmICgveC1jb250ZW50LXRyYW5zZmVyLWlkOi9pLnRlc3QoaGVhZGVyKSkge1xuICAgICAgdmFyIGlkID0gKGhlYWRlci5zcGxpdCgnOicpWzFdIHx8ICcnKS50cmltKCk7XG4gICAgICByZXR1cm4gaWQgfHwgbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgdmFyIGdldEZpbGVJbmZvRnJvbUhlYWRlcnMgPSBmdW5jdGlvbiBnZXRGaWxlSW5mb0Zyb21IZWFkZXJzKGhlYWRlcnMpIHtcbiAgICB2YXIgaW5mbyA9IHtcbiAgICAgIHNvdXJjZTogbnVsbCxcbiAgICAgIG5hbWU6IG51bGwsXG4gICAgICBzaXplOiBudWxsXG4gICAgfTtcblxuICAgIHZhciByb3dzID0gaGVhZGVycy5zcGxpdCgnXFxuJyk7XG4gICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlO1xuICAgIHZhciBfaXRlcmF0b3JFcnJvciA9IHVuZGVmaW5lZDtcbiAgICB0cnkge1xuICAgICAgZm9yIChcbiAgICAgICAgdmFyIF9pdGVyYXRvciA9IHJvd3NbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDtcbiAgICAgICAgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7XG4gICAgICAgIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlXG4gICAgICApIHtcbiAgICAgICAgdmFyIGhlYWRlciA9IF9zdGVwLnZhbHVlO1xuXG4gICAgICAgIHZhciBuYW1lID0gZ2V0RmlsZU5hbWVGcm9tSGVhZGVyKGhlYWRlcik7XG4gICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgaW5mby5uYW1lID0gbmFtZTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzaXplID0gZ2V0RmlsZVNpemVGcm9tSGVhZGVyKGhlYWRlcik7XG4gICAgICAgIGlmIChzaXplKSB7XG4gICAgICAgICAgaW5mby5zaXplID0gc2l6ZTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzb3VyY2UgPSBnZXRUcmFuZnNlcklkRnJvbUhlYWRlcihoZWFkZXIpO1xuICAgICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgICAgaW5mby5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTtcbiAgICAgIF9pdGVyYXRvckVycm9yID0gZXJyO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybiAhPSBudWxsKSB7XG4gICAgICAgICAgX2l0ZXJhdG9yLnJldHVybigpO1xuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IpIHtcbiAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBpbmZvO1xuICB9O1xuXG4gIHZhciBjcmVhdGVGaWxlTG9hZGVyID0gZnVuY3Rpb24gY3JlYXRlRmlsZUxvYWRlcihmZXRjaEZuKSB7XG4gICAgdmFyIHN0YXRlID0ge1xuICAgICAgc291cmNlOiBudWxsLFxuICAgICAgY29tcGxldGU6IGZhbHNlLFxuICAgICAgcHJvZ3Jlc3M6IDAsXG4gICAgICBzaXplOiBudWxsLFxuICAgICAgdGltZXN0YW1wOiBudWxsLFxuICAgICAgZHVyYXRpb246IDAsXG4gICAgICByZXF1ZXN0OiBudWxsXG4gICAgfTtcblxuICAgIHZhciBnZXRQcm9ncmVzcyA9IGZ1bmN0aW9uIGdldFByb2dyZXNzKCkge1xuICAgICAgcmV0dXJuIHN0YXRlLnByb2dyZXNzO1xuICAgIH07XG4gICAgdmFyIGFib3J0ID0gZnVuY3Rpb24gYWJvcnQoKSB7XG4gICAgICBpZiAoc3RhdGUucmVxdWVzdCAmJiBzdGF0ZS5yZXF1ZXN0LmFib3J0KSB7XG4gICAgICAgIHN0YXRlLnJlcXVlc3QuYWJvcnQoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gbG9hZCBzb3VyY2VcbiAgICB2YXIgbG9hZCA9IGZ1bmN0aW9uIGxvYWQoKSB7XG4gICAgICAvLyBnZXQgcXVpY2sgcmVmZXJlbmNlXG4gICAgICB2YXIgc291cmNlID0gc3RhdGUuc291cmNlO1xuXG4gICAgICBhcGkuZmlyZSgnaW5pdCcsIHNvdXJjZSk7XG5cbiAgICAgIC8vIExvYWQgRmlsZXNcbiAgICAgIGlmIChzb3VyY2UgaW5zdGFuY2VvZiBGaWxlKSB7XG4gICAgICAgIGFwaS5maXJlKCdsb2FkJywgc291cmNlKTtcbiAgICAgIH0gZWxzZSBpZiAoc291cmNlIGluc3RhbmNlb2YgQmxvYikge1xuICAgICAgICAvLyBMb2FkIGJsb2JzLCBzZXQgZGVmYXVsdCBuYW1lIHRvIGN1cnJlbnQgZGF0ZVxuICAgICAgICBhcGkuZmlyZSgnbG9hZCcsIGdldEZpbGVGcm9tQmxvYihzb3VyY2UsIHNvdXJjZS5uYW1lKSk7XG4gICAgICB9IGVsc2UgaWYgKGlzQmFzZTY0RGF0YVVSSShzb3VyY2UpKSB7XG4gICAgICAgIC8vIExvYWQgYmFzZSA2NCwgc2V0IGRlZmF1bHQgbmFtZSB0byBjdXJyZW50IGRhdGVcbiAgICAgICAgYXBpLmZpcmUoJ2xvYWQnLCBnZXRGaWxlRnJvbUJhc2U2NERhdGFVUkkoc291cmNlKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBEZWFsIGFzIGlmIGlzIGV4dGVybmFsIFVSTCwgbGV0J3MgbG9hZCBpdCFcbiAgICAgICAgbG9hZFVSTChzb3VyY2UpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBsb2FkcyBhIHVybFxuICAgIHZhciBsb2FkVVJMID0gZnVuY3Rpb24gbG9hZFVSTCh1cmwpIHtcbiAgICAgIC8vIGlzIHJlbW90ZSB1cmwgYW5kIG5vIGZldGNoIG1ldGhvZCBzdXBwbGllZFxuICAgICAgaWYgKCFmZXRjaEZuKSB7XG4gICAgICAgIGFwaS5maXJlKCdlcnJvcicsIHtcbiAgICAgICAgICB0eXBlOiAnZXJyb3InLFxuICAgICAgICAgIGJvZHk6IFwiQ2FuJ3QgbG9hZCBVUkxcIixcbiAgICAgICAgICBjb2RlOiA0MDBcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBzZXQgcmVxdWVzdCBzdGFydFxuICAgICAgc3RhdGUudGltZXN0YW1wID0gRGF0ZS5ub3coKTtcblxuICAgICAgLy8gbG9hZCBmaWxlXG4gICAgICBzdGF0ZS5yZXF1ZXN0ID0gZmV0Y2hGbihcbiAgICAgICAgdXJsLFxuICAgICAgICBmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgIC8vIHVwZGF0ZSBkdXJhdGlvblxuICAgICAgICAgIHN0YXRlLmR1cmF0aW9uID0gRGF0ZS5ub3coKSAtIHN0YXRlLnRpbWVzdGFtcDtcblxuICAgICAgICAgIC8vIGRvbmUhXG4gICAgICAgICAgc3RhdGUuY29tcGxldGUgPSB0cnVlO1xuXG4gICAgICAgICAgLy8gdHVybiBibG9iIHJlc3BvbnNlIGludG8gYSBmaWxlXG4gICAgICAgICAgaWYgKHJlc3BvbnNlIGluc3RhbmNlb2YgQmxvYikge1xuICAgICAgICAgICAgcmVzcG9uc2UgPSBnZXRGaWxlRnJvbUJsb2IoXG4gICAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgICByZXNwb25zZS5uYW1lIHx8IGdldEZpbGVuYW1lRnJvbVVSTCh1cmwpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGFwaS5maXJlKFxuICAgICAgICAgICAgJ2xvYWQnLFxuICAgICAgICAgICAgLy8gaWYgaGFzIHJlY2VpdmVkIGJsb2IsIHdlIGdvIHdpdGggYmxvYiwgaWYgbm8gcmVzcG9uc2UsIHdlIHJldHVybiBudWxsXG4gICAgICAgICAgICByZXNwb25zZSBpbnN0YW5jZW9mIEJsb2JcbiAgICAgICAgICAgICAgPyByZXNwb25zZVxuICAgICAgICAgICAgICA6IHJlc3BvbnNlXG4gICAgICAgICAgICAgID8gcmVzcG9uc2UuYm9keVxuICAgICAgICAgICAgICA6IG51bGxcbiAgICAgICAgICApO1xuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgIGFwaS5maXJlKFxuICAgICAgICAgICAgJ2Vycm9yJyxcbiAgICAgICAgICAgIHR5cGVvZiBlcnJvciA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiAnZXJyb3InLFxuICAgICAgICAgICAgICAgICAgY29kZTogMCxcbiAgICAgICAgICAgICAgICAgIGJvZHk6IGVycm9yXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICA6IGVycm9yXG4gICAgICAgICAgKTtcbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24oY29tcHV0YWJsZSwgY3VycmVudCwgdG90YWwpIHtcbiAgICAgICAgICAvLyBjb2xsZWN0ZWQgc29tZSBtZXRhIGRhdGEgYWxyZWFkeVxuICAgICAgICAgIGlmICh0b3RhbCkge1xuICAgICAgICAgICAgc3RhdGUuc2l6ZSA9IHRvdGFsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHVwZGF0ZSBkdXJhdGlvblxuICAgICAgICAgIHN0YXRlLmR1cmF0aW9uID0gRGF0ZS5ub3coKSAtIHN0YXRlLnRpbWVzdGFtcDtcblxuICAgICAgICAgIC8vIGlmIHdlIGNhbid0IGNvbXB1dGUgcHJvZ3Jlc3MsIHdlJ3JlIG5vdCBnb2luZyB0byBmaXJlIHByb2dyZXNzIGV2ZW50c1xuICAgICAgICAgIGlmICghY29tcHV0YWJsZSkge1xuICAgICAgICAgICAgc3RhdGUucHJvZ3Jlc3MgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHVwZGF0ZSBwcm9ncmVzcyBwZXJjZW50YWdlXG4gICAgICAgICAgc3RhdGUucHJvZ3Jlc3MgPSBjdXJyZW50IC8gdG90YWw7XG5cbiAgICAgICAgICAvLyBleHBvc2VcbiAgICAgICAgICBhcGkuZmlyZSgncHJvZ3Jlc3MnLCBzdGF0ZS5wcm9ncmVzcyk7XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGFwaS5maXJlKCdhYm9ydCcpO1xuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgIHZhciBmaWxlaW5mbyA9IGdldEZpbGVJbmZvRnJvbUhlYWRlcnMoXG4gICAgICAgICAgICB0eXBlb2YgcmVzcG9uc2UgPT09ICdzdHJpbmcnID8gcmVzcG9uc2UgOiByZXNwb25zZS5oZWFkZXJzXG4gICAgICAgICAgKTtcbiAgICAgICAgICBhcGkuZmlyZSgnbWV0YScsIHtcbiAgICAgICAgICAgIHNpemU6IHN0YXRlLnNpemUgfHwgZmlsZWluZm8uc2l6ZSxcbiAgICAgICAgICAgIGZpbGVuYW1lOiBmaWxlaW5mby5uYW1lLFxuICAgICAgICAgICAgc291cmNlOiBmaWxlaW5mby5zb3VyY2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9O1xuXG4gICAgdmFyIGFwaSA9IE9iamVjdC5hc3NpZ24oe30sIG9uKCksIHtcbiAgICAgIHNldFNvdXJjZTogZnVuY3Rpb24gc2V0U291cmNlKHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gKHN0YXRlLnNvdXJjZSA9IHNvdXJjZSk7XG4gICAgICB9LFxuICAgICAgZ2V0UHJvZ3Jlc3M6IGdldFByb2dyZXNzLCAvLyBmaWxlIGxvYWQgcHJvZ3Jlc3NcbiAgICAgIGFib3J0OiBhYm9ydCwgLy8gYWJvcnQgZmlsZSBsb2FkXG4gICAgICBsb2FkOiBsb2FkIC8vIHN0YXJ0IGxvYWRcbiAgICB9KTtcblxuICAgIHJldHVybiBhcGk7XG4gIH07XG5cbiAgdmFyIGlzR2V0ID0gZnVuY3Rpb24gaXNHZXQobWV0aG9kKSB7XG4gICAgcmV0dXJuIC9HRVR8SEVBRC8udGVzdChtZXRob2QpO1xuICB9O1xuXG4gIHZhciBzZW5kUmVxdWVzdCA9IGZ1bmN0aW9uIHNlbmRSZXF1ZXN0KGRhdGEsIHVybCwgb3B0aW9ucykge1xuICAgIHZhciBhcGkgPSB7XG4gICAgICBvbmhlYWRlcnM6IGZ1bmN0aW9uIG9uaGVhZGVycygpIHt9LFxuICAgICAgb25wcm9ncmVzczogZnVuY3Rpb24gb25wcm9ncmVzcygpIHt9LFxuICAgICAgb25sb2FkOiBmdW5jdGlvbiBvbmxvYWQoKSB7fSxcbiAgICAgIG9udGltZW91dDogZnVuY3Rpb24gb250aW1lb3V0KCkge30sXG4gICAgICBvbmVycm9yOiBmdW5jdGlvbiBvbmVycm9yKCkge30sXG4gICAgICBvbmFib3J0OiBmdW5jdGlvbiBvbmFib3J0KCkge30sXG4gICAgICBhYm9ydDogZnVuY3Rpb24gYWJvcnQoKSB7XG4gICAgICAgIGFib3J0ZWQgPSB0cnVlO1xuICAgICAgICB4aHIuYWJvcnQoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gdGltZW91dCBpZGVudGlmaWVyLCBvbmx5IHVzZWQgd2hlbiB0aW1lb3V0IGlzIGRlZmluZWRcbiAgICB2YXIgYWJvcnRlZCA9IGZhbHNlO1xuICAgIHZhciBoZWFkZXJzUmVjZWl2ZWQgPSBmYWxzZTtcblxuICAgIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbihcbiAgICAgIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHt9LFxuICAgICAgICB3aXRoQ3JlZGVudGlhbHM6IGZhbHNlXG4gICAgICB9LFxuICAgICAgb3B0aW9uc1xuICAgICk7XG5cbiAgICAvLyBlbmNvZGUgdXJsXG4gICAgdXJsID0gZW5jb2RlVVJJKHVybCk7XG5cbiAgICAvLyBpZiBtZXRob2QgaXMgR0VULCBhZGQgYW55IHJlY2VpdmVkIGRhdGEgdG8gdXJsXG5cbiAgICBpZiAoaXNHZXQob3B0aW9ucy5tZXRob2QpICYmIGRhdGEpIHtcbiAgICAgIHVybCA9XG4gICAgICAgICcnICtcbiAgICAgICAgdXJsICtcbiAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KFxuICAgICAgICAgIHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJyA/IGRhdGEgOiBKU09OLnN0cmluZ2lmeShkYXRhKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8vIGNyZWF0ZSByZXF1ZXN0XG4gICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXG4gICAgLy8gcHJvZ3Jlc3Mgb2YgbG9hZFxuICAgIHZhciBwcm9jZXNzID0gaXNHZXQob3B0aW9ucy5tZXRob2QpID8geGhyIDogeGhyLnVwbG9hZDtcbiAgICBwcm9jZXNzLm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbihlKSB7XG4gICAgICAvLyBubyBwcm9ncmVzcyBldmVudCB3aGVuIGFib3J0ZWQgKCBvbnByb2dyZXNzIGlzIGNhbGxlZCBvbmNlIGFmdGVyIGFib3J0KCkgKVxuICAgICAgaWYgKGFib3J0ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBhcGkub25wcm9ncmVzcyhlLmxlbmd0aENvbXB1dGFibGUsIGUubG9hZGVkLCBlLnRvdGFsKTtcbiAgICB9O1xuXG4gICAgLy8gdHJpZXMgdG8gZ2V0IGhlYWRlciBpbmZvIHRvIHRoZSBhcHAgYXMgZmFzdCBhcyBwb3NzaWJsZVxuICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgIC8vIG5vdCBpbnRlcmVzdGluZyBpbiB0aGVzZSBzdGF0ZXMgKCd1bnNlbnQnIGFuZCAnb3BlbmVuZCcgYXMgdGhleSBkb24ndCBnaXZlIHVzIGFueSBhZGRpdGlvbmFsIGluZm8pXG4gICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPCAyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gbm8gc2VydmVyIHJlc3BvbnNlXG4gICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDQgJiYgeGhyLnN0YXR1cyA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChoZWFkZXJzUmVjZWl2ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBoZWFkZXJzUmVjZWl2ZWQgPSB0cnVlO1xuXG4gICAgICAvLyB3ZSd2ZSBwcm9iYWJseSByZWNlaXZlZCBzb21lIHVzZWZ1bCBkYXRhIGluIHJlc3BvbnNlIGhlYWRlcnNcbiAgICAgIGFwaS5vbmhlYWRlcnMoeGhyKTtcbiAgICB9O1xuXG4gICAgLy8gbG9hZCBzdWNjZXNzZnVsXG4gICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gaXMgY2xhc3NpZmllZCBhcyB2YWxpZCByZXNwb25zZVxuICAgICAgaWYgKHhoci5zdGF0dXMgPj0gMjAwICYmIHhoci5zdGF0dXMgPCAzMDApIHtcbiAgICAgICAgYXBpLm9ubG9hZCh4aHIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXBpLm9uZXJyb3IoeGhyKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gZXJyb3IgZHVyaW5nIGxvYWRcbiAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGFwaS5vbmVycm9yKHhocik7XG4gICAgfTtcblxuICAgIC8vIHJlcXVlc3QgYWJvcnRlZFxuICAgIHhoci5vbmFib3J0ID0gZnVuY3Rpb24oKSB7XG4gICAgICBhYm9ydGVkID0gdHJ1ZTtcbiAgICAgIGFwaS5vbmFib3J0KCk7XG4gICAgfTtcblxuICAgIC8vIHJlcXVlc3QgdGltZW91dFxuICAgIHhoci5vbnRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBhcGkub250aW1lb3V0KHhocik7XG4gICAgfTtcblxuICAgIC8vIG9wZW4gdXAgb3BlbiB1cCFcbiAgICB4aHIub3BlbihvcHRpb25zLm1ldGhvZCwgdXJsLCB0cnVlKTtcblxuICAgIC8vIHNldCB0aW1lb3V0IGlmIGRlZmluZWQgKGRvIGl0IGFmdGVyIG9wZW4gc28gSUUxMSBwbGF5cyBiYWxsKVxuICAgIGlmIChpc0ludChvcHRpb25zLnRpbWVvdXQpKSB7XG4gICAgICB4aHIudGltZW91dCA9IG9wdGlvbnMudGltZW91dDtcbiAgICB9XG5cbiAgICAvLyBhZGQgaGVhZGVyc1xuICAgIE9iamVjdC5rZXlzKG9wdGlvbnMuaGVhZGVycykuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChvcHRpb25zLmhlYWRlcnNba2V5XSkpO1xuICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoa2V5LCB2YWx1ZSk7XG4gICAgfSk7XG5cbiAgICAvLyBzZXQgdHlwZSBvZiByZXNwb25zZVxuICAgIGlmIChvcHRpb25zLnJlc3BvbnNlVHlwZSkge1xuICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9IG9wdGlvbnMucmVzcG9uc2VUeXBlO1xuICAgIH1cblxuICAgIC8vIHNldCBjcmVkZW50aWFsc1xuICAgIGlmIChvcHRpb25zLndpdGhDcmVkZW50aWFscykge1xuICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gbGV0J3Mgc2VuZCBvdXIgZGF0YVxuICAgIHhoci5zZW5kKGRhdGEpO1xuXG4gICAgcmV0dXJuIGFwaTtcbiAgfTtcblxuICB2YXIgY3JlYXRlUmVzcG9uc2UgPSBmdW5jdGlvbiBjcmVhdGVSZXNwb25zZSh0eXBlLCBjb2RlLCBib2R5LCBoZWFkZXJzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICBjb2RlOiBjb2RlLFxuICAgICAgYm9keTogYm9keSxcbiAgICAgIGhlYWRlcnM6IGhlYWRlcnNcbiAgICB9O1xuICB9O1xuXG4gIHZhciBjcmVhdGVUaW1lb3V0UmVzcG9uc2UgPSBmdW5jdGlvbiBjcmVhdGVUaW1lb3V0UmVzcG9uc2UoY2IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oeGhyKSB7XG4gICAgICBjYihjcmVhdGVSZXNwb25zZSgnZXJyb3InLCAwLCAnVGltZW91dCcsIHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSkpO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIGhhc1FTID0gZnVuY3Rpb24gaGFzUVMoc3RyKSB7XG4gICAgcmV0dXJuIC9cXD8vLnRlc3Qoc3RyKTtcbiAgfTtcbiAgdmFyIGJ1aWxkVVJMID0gZnVuY3Rpb24gYnVpbGRVUkwoKSB7XG4gICAgdmFyIHVybCA9ICcnO1xuICAgIGZvciAoXG4gICAgICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHBhcnRzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDtcbiAgICAgIF9rZXkgPCBfbGVuO1xuICAgICAgX2tleSsrXG4gICAgKSB7XG4gICAgICBwYXJ0c1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG4gICAgcGFydHMuZm9yRWFjaChmdW5jdGlvbihwYXJ0KSB7XG4gICAgICB1cmwgKz0gaGFzUVModXJsKSAmJiBoYXNRUyhwYXJ0KSA/IHBhcnQucmVwbGFjZSgvXFw/LywgJyYnKSA6IHBhcnQ7XG4gICAgfSk7XG4gICAgcmV0dXJuIHVybDtcbiAgfTtcblxuICB2YXIgY3JlYXRlRmV0Y2hGdW5jdGlvbiA9IGZ1bmN0aW9uIGNyZWF0ZUZldGNoRnVuY3Rpb24oKSB7XG4gICAgdmFyIGFwaVVybCA9XG4gICAgICBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6ICcnO1xuICAgIHZhciBhY3Rpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgICAvLyBjdXN0b20gaGFuZGxlciAoc2hvdWxkIGFsc28gaGFuZGxlIGZpbGUsIGxvYWQsIGVycm9yLCBwcm9ncmVzcyBhbmQgYWJvcnQpXG4gICAgaWYgKHR5cGVvZiBhY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBhY3Rpb247XG4gICAgfVxuXG4gICAgLy8gbm8gYWN0aW9uIHN1cHBsaWVkXG4gICAgaWYgKCFhY3Rpb24gfHwgIWlzU3RyaW5nKGFjdGlvbi51cmwpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBzZXQgb25sb2FkIGhhbmxkZXJcbiAgICB2YXIgb25sb2FkID1cbiAgICAgIGFjdGlvbi5vbmxvYWQgfHxcbiAgICAgIGZ1bmN0aW9uKHJlcykge1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfTtcbiAgICB2YXIgb25lcnJvciA9XG4gICAgICBhY3Rpb24ub25lcnJvciB8fFxuICAgICAgZnVuY3Rpb24ocmVzKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcblxuICAgIC8vIGludGVybmFsIGhhbmRsZXJcbiAgICByZXR1cm4gZnVuY3Rpb24odXJsLCBsb2FkLCBlcnJvciwgcHJvZ3Jlc3MsIGFib3J0LCBoZWFkZXJzKSB7XG4gICAgICAvLyBkbyBsb2NhbCBvciByZW1vdGUgcmVxdWVzdCBiYXNlZCBvbiBpZiB0aGUgdXJsIGlzIGV4dGVybmFsXG4gICAgICB2YXIgcmVxdWVzdCA9IHNlbmRSZXF1ZXN0KFxuICAgICAgICB1cmwsXG4gICAgICAgIGJ1aWxkVVJMKGFwaVVybCwgYWN0aW9uLnVybCksXG4gICAgICAgIE9iamVjdC5hc3NpZ24oe30sIGFjdGlvbiwge1xuICAgICAgICAgIHJlc3BvbnNlVHlwZTogJ2Jsb2InXG4gICAgICAgIH0pXG4gICAgICApO1xuXG4gICAgICByZXF1ZXN0Lm9ubG9hZCA9IGZ1bmN0aW9uKHhocikge1xuICAgICAgICAvLyBnZXQgaGVhZGVyc1xuICAgICAgICB2YXIgaGVhZGVycyA9IHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKTtcblxuICAgICAgICAvLyBnZXQgZmlsZW5hbWVcbiAgICAgICAgdmFyIGZpbGVuYW1lID1cbiAgICAgICAgICBnZXRGaWxlSW5mb0Zyb21IZWFkZXJzKGhlYWRlcnMpLm5hbWUgfHwgZ2V0RmlsZW5hbWVGcm9tVVJMKHVybCk7XG5cbiAgICAgICAgLy8gY3JlYXRlIHJlc3BvbnNlXG4gICAgICAgIGxvYWQoXG4gICAgICAgICAgY3JlYXRlUmVzcG9uc2UoXG4gICAgICAgICAgICAnbG9hZCcsXG4gICAgICAgICAgICB4aHIuc3RhdHVzLFxuICAgICAgICAgICAgYWN0aW9uLm1ldGhvZCA9PT0gJ0hFQUQnXG4gICAgICAgICAgICAgID8gbnVsbFxuICAgICAgICAgICAgICA6IGdldEZpbGVGcm9tQmxvYihvbmxvYWQoeGhyLnJlc3BvbnNlKSwgZmlsZW5hbWUpLFxuICAgICAgICAgICAgaGVhZGVyc1xuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH07XG5cbiAgICAgIHJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uKHhocikge1xuICAgICAgICBlcnJvcihcbiAgICAgICAgICBjcmVhdGVSZXNwb25zZShcbiAgICAgICAgICAgICdlcnJvcicsXG4gICAgICAgICAgICB4aHIuc3RhdHVzLFxuICAgICAgICAgICAgb25lcnJvcih4aHIucmVzcG9uc2UpIHx8IHhoci5zdGF0dXNUZXh0LFxuICAgICAgICAgICAgeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfTtcblxuICAgICAgcmVxdWVzdC5vbmhlYWRlcnMgPSBmdW5jdGlvbih4aHIpIHtcbiAgICAgICAgaGVhZGVycyhcbiAgICAgICAgICBjcmVhdGVSZXNwb25zZShcbiAgICAgICAgICAgICdoZWFkZXJzJyxcbiAgICAgICAgICAgIHhoci5zdGF0dXMsXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfTtcblxuICAgICAgcmVxdWVzdC5vbnRpbWVvdXQgPSBjcmVhdGVUaW1lb3V0UmVzcG9uc2UoZXJyb3IpO1xuICAgICAgcmVxdWVzdC5vbnByb2dyZXNzID0gcHJvZ3Jlc3M7XG4gICAgICByZXF1ZXN0Lm9uYWJvcnQgPSBhYm9ydDtcblxuICAgICAgLy8gc2hvdWxkIHJldHVybiByZXF1ZXN0XG4gICAgICByZXR1cm4gcmVxdWVzdDtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBDaHVua1N0YXR1cyA9IHtcbiAgICBRVUVVRUQ6IDAsXG4gICAgQ09NUExFVEU6IDEsXG4gICAgUFJPQ0VTU0lORzogMixcbiAgICBFUlJPUjogMyxcbiAgICBXQUlUSU5HOiA0XG4gIH07XG5cbiAgLypcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBzaWduYXR1cmU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZmlsZSwgbWV0YWRhdGEsIGxvYWQsIGVycm9yLCBwcm9ncmVzcywgYWJvcnQsIHRyYW5zZmVyLCBvcHRpb25zKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFib3J0OigpID0+IHt9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG5cbiAgLy8gYXBpVXJsLCBhY3Rpb24sIG5hbWUsIGZpbGUsIG1ldGFkYXRhLCBsb2FkLCBlcnJvciwgcHJvZ3Jlc3MsIGFib3J0LCB0cmFuc2Zlciwgb3B0aW9uc1xuICB2YXIgcHJvY2Vzc0ZpbGVDaHVua2VkID0gZnVuY3Rpb24gcHJvY2Vzc0ZpbGVDaHVua2VkKFxuICAgIGFwaVVybCxcbiAgICBhY3Rpb24sXG4gICAgbmFtZSxcbiAgICBmaWxlLFxuICAgIG1ldGFkYXRhLFxuICAgIGxvYWQsXG4gICAgZXJyb3IsXG4gICAgcHJvZ3Jlc3MsXG4gICAgYWJvcnQsXG4gICAgdHJhbnNmZXIsXG4gICAgb3B0aW9uc1xuICApIHtcbiAgICAvLyBhbGwgY2h1bmtzXG4gICAgdmFyIGNodW5rcyA9IFtdO1xuICAgIHZhciBjaHVua1RyYW5zZmVySWQgPSBvcHRpb25zLmNodW5rVHJhbnNmZXJJZCxcbiAgICAgIGNodW5rU2VydmVyID0gb3B0aW9ucy5jaHVua1NlcnZlcixcbiAgICAgIGNodW5rU2l6ZSA9IG9wdGlvbnMuY2h1bmtTaXplLFxuICAgICAgY2h1bmtSZXRyeURlbGF5cyA9IG9wdGlvbnMuY2h1bmtSZXRyeURlbGF5cztcblxuICAgIC8vIGRlZmF1bHQgc3RhdGVcbiAgICB2YXIgc3RhdGUgPSB7XG4gICAgICBzZXJ2ZXJJZDogY2h1bmtUcmFuc2ZlcklkLFxuICAgICAgYWJvcnRlZDogZmFsc2VcbiAgICB9O1xuXG4gICAgLy8gc2V0IG9ubG9hZCBoYW5kbGVyc1xuICAgIHZhciBvbmRhdGEgPVxuICAgICAgYWN0aW9uLm9uZGF0YSB8fFxuICAgICAgZnVuY3Rpb24oZmQpIHtcbiAgICAgICAgcmV0dXJuIGZkO1xuICAgICAgfTtcbiAgICB2YXIgb25sb2FkID1cbiAgICAgIGFjdGlvbi5vbmxvYWQgfHxcbiAgICAgIGZ1bmN0aW9uKHhociwgbWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBtZXRob2QgPT09ICdIRUFEJ1xuICAgICAgICAgID8geGhyLmdldFJlc3BvbnNlSGVhZGVyKCdVcGxvYWQtT2Zmc2V0JylcbiAgICAgICAgICA6IHhoci5yZXNwb25zZTtcbiAgICAgIH07XG4gICAgdmFyIG9uZXJyb3IgPVxuICAgICAgYWN0aW9uLm9uZXJyb3IgfHxcbiAgICAgIGZ1bmN0aW9uKHJlcykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG5cbiAgICAvLyBjcmVhdGUgc2VydmVyIGhvb2tcbiAgICB2YXIgcmVxdWVzdFRyYW5zZmVySWQgPSBmdW5jdGlvbiByZXF1ZXN0VHJhbnNmZXJJZChjYikge1xuICAgICAgdmFyIGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XG5cbiAgICAgIC8vIGFkZCBtZXRhZGF0YSB1bmRlciBzYW1lIG5hbWVcbiAgICAgIGlmIChpc09iamVjdChtZXRhZGF0YSkpIGZvcm1EYXRhLmFwcGVuZChuYW1lLCBKU09OLnN0cmluZ2lmeShtZXRhZGF0YSkpO1xuXG4gICAgICB2YXIgaGVhZGVycyA9XG4gICAgICAgIHR5cGVvZiBhY3Rpb24uaGVhZGVycyA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgID8gYWN0aW9uLmhlYWRlcnMoZmlsZSwgbWV0YWRhdGEpXG4gICAgICAgICAgOiBPYmplY3QuYXNzaWduKHt9LCBhY3Rpb24uaGVhZGVycywge1xuICAgICAgICAgICAgICAnVXBsb2FkLUxlbmd0aCc6IGZpbGUuc2l6ZVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgIHZhciByZXF1ZXN0UGFyYW1zID0gT2JqZWN0LmFzc2lnbih7fSwgYWN0aW9uLCB7XG4gICAgICAgIGhlYWRlcnM6IGhlYWRlcnNcbiAgICAgIH0pO1xuXG4gICAgICAvLyBzZW5kIHJlcXVlc3Qgb2JqZWN0XG4gICAgICB2YXIgcmVxdWVzdCA9IHNlbmRSZXF1ZXN0KFxuICAgICAgICBvbmRhdGEoZm9ybURhdGEpLFxuICAgICAgICBidWlsZFVSTChhcGlVcmwsIGFjdGlvbi51cmwpLFxuICAgICAgICByZXF1ZXN0UGFyYW1zXG4gICAgICApO1xuXG4gICAgICByZXF1ZXN0Lm9ubG9hZCA9IGZ1bmN0aW9uKHhocikge1xuICAgICAgICByZXR1cm4gY2Iob25sb2FkKHhociwgcmVxdWVzdFBhcmFtcy5tZXRob2QpKTtcbiAgICAgIH07XG5cbiAgICAgIHJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uKHhocikge1xuICAgICAgICByZXR1cm4gZXJyb3IoXG4gICAgICAgICAgY3JlYXRlUmVzcG9uc2UoXG4gICAgICAgICAgICAnZXJyb3InLFxuICAgICAgICAgICAgeGhyLnN0YXR1cyxcbiAgICAgICAgICAgIG9uZXJyb3IoeGhyLnJlc3BvbnNlKSB8fCB4aHIuc3RhdHVzVGV4dCxcbiAgICAgICAgICAgIHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKVxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH07XG5cbiAgICAgIHJlcXVlc3Qub250aW1lb3V0ID0gY3JlYXRlVGltZW91dFJlc3BvbnNlKGVycm9yKTtcbiAgICB9O1xuXG4gICAgdmFyIHJlcXVlc3RUcmFuc2Zlck9mZnNldCA9IGZ1bmN0aW9uIHJlcXVlc3RUcmFuc2Zlck9mZnNldChjYikge1xuICAgICAgdmFyIHJlcXVlc3RVcmwgPSBidWlsZFVSTChhcGlVcmwsIGNodW5rU2VydmVyLnVybCwgc3RhdGUuc2VydmVySWQpO1xuXG4gICAgICB2YXIgaGVhZGVycyA9XG4gICAgICAgIHR5cGVvZiBhY3Rpb24uaGVhZGVycyA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgID8gYWN0aW9uLmhlYWRlcnMoc3RhdGUuc2VydmVySWQpXG4gICAgICAgICAgOiBPYmplY3QuYXNzaWduKHt9LCBhY3Rpb24uaGVhZGVycyk7XG5cbiAgICAgIHZhciByZXF1ZXN0UGFyYW1zID0ge1xuICAgICAgICBoZWFkZXJzOiBoZWFkZXJzLFxuICAgICAgICBtZXRob2Q6ICdIRUFEJ1xuICAgICAgfTtcblxuICAgICAgdmFyIHJlcXVlc3QgPSBzZW5kUmVxdWVzdChudWxsLCByZXF1ZXN0VXJsLCByZXF1ZXN0UGFyYW1zKTtcblxuICAgICAgcmVxdWVzdC5vbmxvYWQgPSBmdW5jdGlvbih4aHIpIHtcbiAgICAgICAgcmV0dXJuIGNiKG9ubG9hZCh4aHIsIHJlcXVlc3RQYXJhbXMubWV0aG9kKSk7XG4gICAgICB9O1xuXG4gICAgICByZXF1ZXN0Lm9uZXJyb3IgPSBmdW5jdGlvbih4aHIpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yKFxuICAgICAgICAgIGNyZWF0ZVJlc3BvbnNlKFxuICAgICAgICAgICAgJ2Vycm9yJyxcbiAgICAgICAgICAgIHhoci5zdGF0dXMsXG4gICAgICAgICAgICBvbmVycm9yKHhoci5yZXNwb25zZSkgfHwgeGhyLnN0YXR1c1RleHQsXG4gICAgICAgICAgICB4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKClcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9O1xuXG4gICAgICByZXF1ZXN0Lm9udGltZW91dCA9IGNyZWF0ZVRpbWVvdXRSZXNwb25zZShlcnJvcik7XG4gICAgfTtcblxuICAgIC8vIGNyZWF0ZSBjaHVua3NcbiAgICB2YXIgbGFzdENodW5rSW5kZXggPSBNYXRoLmZsb29yKGZpbGUuc2l6ZSAvIGNodW5rU2l6ZSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gbGFzdENodW5rSW5kZXg7IGkrKykge1xuICAgICAgdmFyIG9mZnNldCA9IGkgKiBjaHVua1NpemU7XG4gICAgICB2YXIgZGF0YSA9IGZpbGUuc2xpY2UoXG4gICAgICAgIG9mZnNldCxcbiAgICAgICAgb2Zmc2V0ICsgY2h1bmtTaXplLFxuICAgICAgICAnYXBwbGljYXRpb24vb2Zmc2V0K29jdGV0LXN0cmVhbSdcbiAgICAgICk7XG4gICAgICBjaHVua3NbaV0gPSB7XG4gICAgICAgIGluZGV4OiBpLFxuICAgICAgICBzaXplOiBkYXRhLnNpemUsXG4gICAgICAgIG9mZnNldDogb2Zmc2V0LFxuICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICBmaWxlOiBmaWxlLFxuICAgICAgICBwcm9ncmVzczogMCxcbiAgICAgICAgcmV0cmllczogX3RvQ29uc3VtYWJsZUFycmF5KGNodW5rUmV0cnlEZWxheXMpLFxuICAgICAgICBzdGF0dXM6IENodW5rU3RhdHVzLlFVRVVFRCxcbiAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgIHJlcXVlc3Q6IG51bGwsXG4gICAgICAgIHRpbWVvdXQ6IG51bGxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIGNvbXBsZXRlUHJvY2Vzc2luZ0NodW5rcyA9IGZ1bmN0aW9uIGNvbXBsZXRlUHJvY2Vzc2luZ0NodW5rcygpIHtcbiAgICAgIHJldHVybiBsb2FkKHN0YXRlLnNlcnZlcklkKTtcbiAgICB9O1xuXG4gICAgdmFyIGNhblByb2Nlc3NDaHVuayA9IGZ1bmN0aW9uIGNhblByb2Nlc3NDaHVuayhjaHVuaykge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgY2h1bmsuc3RhdHVzID09PSBDaHVua1N0YXR1cy5RVUVVRUQgfHxcbiAgICAgICAgY2h1bmsuc3RhdHVzID09PSBDaHVua1N0YXR1cy5FUlJPUlxuICAgICAgKTtcbiAgICB9O1xuXG4gICAgdmFyIHByb2Nlc3NDaHVuayA9IGZ1bmN0aW9uIHByb2Nlc3NDaHVuayhjaHVuaykge1xuICAgICAgLy8gcHJvY2Vzc2luZyBpcyBwYXVzZWQsIHdhaXQgaGVyZVxuICAgICAgaWYgKHN0YXRlLmFib3J0ZWQpIHJldHVybjtcblxuICAgICAgLy8gZ2V0IG5leHQgY2h1bmsgdG8gcHJvY2Vzc1xuICAgICAgY2h1bmsgPSBjaHVuayB8fCBjaHVua3MuZmluZChjYW5Qcm9jZXNzQ2h1bmspO1xuXG4gICAgICAvLyBubyBtb3JlIGNodW5rcyB0byBwcm9jZXNzXG4gICAgICBpZiAoIWNodW5rKSB7XG4gICAgICAgIC8vIGFsbCBkb25lP1xuICAgICAgICBpZiAoXG4gICAgICAgICAgY2h1bmtzLmV2ZXJ5KGZ1bmN0aW9uKGNodW5rKSB7XG4gICAgICAgICAgICByZXR1cm4gY2h1bmsuc3RhdHVzID09PSBDaHVua1N0YXR1cy5DT01QTEVURTtcbiAgICAgICAgICB9KVxuICAgICAgICApIHtcbiAgICAgICAgICBjb21wbGV0ZVByb2Nlc3NpbmdDaHVua3MoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG5vIGNodW5rIHRvIGhhbmRsZVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIG5vdyBwcm9jZXNzaW5nIHRoaXMgY2h1bmtcbiAgICAgIGNodW5rLnN0YXR1cyA9IENodW5rU3RhdHVzLlBST0NFU1NJTkc7XG4gICAgICBjaHVuay5wcm9ncmVzcyA9IG51bGw7XG5cbiAgICAgIC8vIGFsbG93IHBhcnNpbmcgb2YgZm9ybWRhdGFcbiAgICAgIHZhciBvbmRhdGEgPVxuICAgICAgICBjaHVua1NlcnZlci5vbmRhdGEgfHxcbiAgICAgICAgZnVuY3Rpb24oZmQpIHtcbiAgICAgICAgICByZXR1cm4gZmQ7XG4gICAgICAgIH07XG4gICAgICB2YXIgb25lcnJvciA9XG4gICAgICAgIGNodW5rU2VydmVyLm9uZXJyb3IgfHxcbiAgICAgICAgZnVuY3Rpb24ocmVzKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG5cbiAgICAgIC8vIHNlbmQgcmVxdWVzdCBvYmplY3RcbiAgICAgIHZhciByZXF1ZXN0VXJsID0gYnVpbGRVUkwoYXBpVXJsLCBjaHVua1NlcnZlci51cmwsIHN0YXRlLnNlcnZlcklkKTtcblxuICAgICAgdmFyIGhlYWRlcnMgPVxuICAgICAgICB0eXBlb2YgY2h1bmtTZXJ2ZXIuaGVhZGVycyA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgID8gY2h1bmtTZXJ2ZXIuaGVhZGVycyhjaHVuaylcbiAgICAgICAgICA6IE9iamVjdC5hc3NpZ24oe30sIGNodW5rU2VydmVyLmhlYWRlcnMsIHtcbiAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9vZmZzZXQrb2N0ZXQtc3RyZWFtJyxcbiAgICAgICAgICAgICAgJ1VwbG9hZC1PZmZzZXQnOiBjaHVuay5vZmZzZXQsXG4gICAgICAgICAgICAgICdVcGxvYWQtTGVuZ3RoJzogZmlsZS5zaXplLFxuICAgICAgICAgICAgICAnVXBsb2FkLU5hbWUnOiBmaWxlLm5hbWVcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICB2YXIgcmVxdWVzdCA9IChjaHVuay5yZXF1ZXN0ID0gc2VuZFJlcXVlc3QoXG4gICAgICAgIG9uZGF0YShjaHVuay5kYXRhKSxcbiAgICAgICAgcmVxdWVzdFVybCxcbiAgICAgICAgT2JqZWN0LmFzc2lnbih7fSwgY2h1bmtTZXJ2ZXIsIHtcbiAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJzXG4gICAgICAgIH0pXG4gICAgICApKTtcblxuICAgICAgcmVxdWVzdC5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gZG9uZSFcbiAgICAgICAgY2h1bmsuc3RhdHVzID0gQ2h1bmtTdGF0dXMuQ09NUExFVEU7XG5cbiAgICAgICAgLy8gcmVtb3ZlIHJlcXVlc3QgcmVmZXJlbmNlXG4gICAgICAgIGNodW5rLnJlcXVlc3QgPSBudWxsO1xuXG4gICAgICAgIC8vIHN0YXJ0IHByb2Nlc3NpbmcgbW9yZSBjaHVua3NcbiAgICAgICAgcHJvY2Vzc0NodW5rcygpO1xuICAgICAgfTtcblxuICAgICAgcmVxdWVzdC5vbnByb2dyZXNzID0gZnVuY3Rpb24obGVuZ3RoQ29tcHV0YWJsZSwgbG9hZGVkLCB0b3RhbCkge1xuICAgICAgICBjaHVuay5wcm9ncmVzcyA9IGxlbmd0aENvbXB1dGFibGUgPyBsb2FkZWQgOiBudWxsO1xuICAgICAgICB1cGRhdGVUb3RhbFByb2dyZXNzKCk7XG4gICAgICB9O1xuXG4gICAgICByZXF1ZXN0Lm9uZXJyb3IgPSBmdW5jdGlvbih4aHIpIHtcbiAgICAgICAgY2h1bmsuc3RhdHVzID0gQ2h1bmtTdGF0dXMuRVJST1I7XG4gICAgICAgIGNodW5rLnJlcXVlc3QgPSBudWxsO1xuICAgICAgICBjaHVuay5lcnJvciA9IG9uZXJyb3IoeGhyLnJlc3BvbnNlKSB8fCB4aHIuc3RhdHVzVGV4dDtcbiAgICAgICAgaWYgKCFyZXRyeVByb2Nlc3NDaHVuayhjaHVuaykpIHtcbiAgICAgICAgICBlcnJvcihcbiAgICAgICAgICAgIGNyZWF0ZVJlc3BvbnNlKFxuICAgICAgICAgICAgICAnZXJyb3InLFxuICAgICAgICAgICAgICB4aHIuc3RhdHVzLFxuICAgICAgICAgICAgICBvbmVycm9yKHhoci5yZXNwb25zZSkgfHwgeGhyLnN0YXR1c1RleHQsXG4gICAgICAgICAgICAgIHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKVxuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHJlcXVlc3Qub250aW1lb3V0ID0gZnVuY3Rpb24oeGhyKSB7XG4gICAgICAgIGNodW5rLnN0YXR1cyA9IENodW5rU3RhdHVzLkVSUk9SO1xuICAgICAgICBjaHVuay5yZXF1ZXN0ID0gbnVsbDtcbiAgICAgICAgaWYgKCFyZXRyeVByb2Nlc3NDaHVuayhjaHVuaykpIHtcbiAgICAgICAgICBjcmVhdGVUaW1lb3V0UmVzcG9uc2UoZXJyb3IpKHhocik7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHJlcXVlc3Qub25hYm9ydCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjaHVuay5zdGF0dXMgPSBDaHVua1N0YXR1cy5RVUVVRUQ7XG4gICAgICAgIGNodW5rLnJlcXVlc3QgPSBudWxsO1xuICAgICAgICBhYm9ydCgpO1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIHJldHJ5UHJvY2Vzc0NodW5rID0gZnVuY3Rpb24gcmV0cnlQcm9jZXNzQ2h1bmsoY2h1bmspIHtcbiAgICAgIC8vIG5vIG1vcmUgcmV0cmllcyBsZWZ0XG4gICAgICBpZiAoY2h1bmsucmV0cmllcy5sZW5ndGggPT09IDApIHJldHVybiBmYWxzZTtcblxuICAgICAgLy8gbmV3IHJldHJ5XG4gICAgICBjaHVuay5zdGF0dXMgPSBDaHVua1N0YXR1cy5XQUlUSU5HO1xuICAgICAgY2xlYXJUaW1lb3V0KGNodW5rLnRpbWVvdXQpO1xuICAgICAgY2h1bmsudGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHByb2Nlc3NDaHVuayhjaHVuayk7XG4gICAgICB9LCBjaHVuay5yZXRyaWVzLnNoaWZ0KCkpO1xuXG4gICAgICAvLyB3ZSdyZSBnb2luZyB0byByZXRyeVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuICAgIHZhciB1cGRhdGVUb3RhbFByb2dyZXNzID0gZnVuY3Rpb24gdXBkYXRlVG90YWxQcm9ncmVzcygpIHtcbiAgICAgIC8vIGNhbGN1bGF0ZSB0b3RhbCBwcm9ncmVzcyBmcmFjdGlvblxuICAgICAgdmFyIHRvdGFsQnl0ZXNUcmFuc2ZlcmVkID0gY2h1bmtzLnJlZHVjZShmdW5jdGlvbihwLCBjaHVuaykge1xuICAgICAgICBpZiAocCA9PT0gbnVsbCB8fCBjaHVuay5wcm9ncmVzcyA9PT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiBwICsgY2h1bmsucHJvZ3Jlc3M7XG4gICAgICB9LCAwKTtcblxuICAgICAgLy8gY2FuJ3QgY29tcHV0ZSBwcm9ncmVzc1xuICAgICAgaWYgKHRvdGFsQnl0ZXNUcmFuc2ZlcmVkID09PSBudWxsKSByZXR1cm4gcHJvZ3Jlc3MoZmFsc2UsIDAsIDApO1xuXG4gICAgICAvLyBjYWxjdWxhdGUgcHJvZ3Jlc3MgdmFsdWVzXG4gICAgICB2YXIgdG90YWxTaXplID0gY2h1bmtzLnJlZHVjZShmdW5jdGlvbih0b3RhbCwgY2h1bmspIHtcbiAgICAgICAgcmV0dXJuIHRvdGFsICsgY2h1bmsuc2l6ZTtcbiAgICAgIH0sIDApO1xuXG4gICAgICAvLyBjYW4gdXBkYXRlIHByb2dyZXNzIGluZGljYXRvclxuICAgICAgcHJvZ3Jlc3ModHJ1ZSwgdG90YWxCeXRlc1RyYW5zZmVyZWQsIHRvdGFsU2l6ZSk7XG4gICAgfTtcblxuICAgIC8vIHByb2Nlc3MgbmV3IGNodW5rc1xuICAgIHZhciBwcm9jZXNzQ2h1bmtzID0gZnVuY3Rpb24gcHJvY2Vzc0NodW5rcygpIHtcbiAgICAgIHZhciB0b3RhbFByb2Nlc3NpbmcgPSBjaHVua3MuZmlsdGVyKGZ1bmN0aW9uKGNodW5rKSB7XG4gICAgICAgIHJldHVybiBjaHVuay5zdGF0dXMgPT09IENodW5rU3RhdHVzLlBST0NFU1NJTkc7XG4gICAgICB9KS5sZW5ndGg7XG4gICAgICBpZiAodG90YWxQcm9jZXNzaW5nID49IDEpIHJldHVybjtcbiAgICAgIHByb2Nlc3NDaHVuaygpO1xuICAgIH07XG5cbiAgICB2YXIgYWJvcnRDaHVua3MgPSBmdW5jdGlvbiBhYm9ydENodW5rcygpIHtcbiAgICAgIGNodW5rcy5mb3JFYWNoKGZ1bmN0aW9uKGNodW5rKSB7XG4gICAgICAgIGNsZWFyVGltZW91dChjaHVuay50aW1lb3V0KTtcbiAgICAgICAgaWYgKGNodW5rLnJlcXVlc3QpIHtcbiAgICAgICAgICBjaHVuay5yZXF1ZXN0LmFib3J0KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyBsZXQncyBnbyFcbiAgICBpZiAoIXN0YXRlLnNlcnZlcklkKSB7XG4gICAgICByZXF1ZXN0VHJhbnNmZXJJZChmdW5jdGlvbihzZXJ2ZXJJZCkge1xuICAgICAgICAvLyBzdG9wIGhlcmUgaWYgYWJvcnRlZCwgbWlnaHQgaGF2ZSBoYXBwZW5lZCBpbiBiZXR3ZWVuIHJlcXVlc3QgYW5kIGNhbGxiYWNrXG4gICAgICAgIGlmIChzdGF0ZS5hYm9ydGVkKSByZXR1cm47XG5cbiAgICAgICAgLy8gcGFzcyBiYWNrIHRvIGl0ZW0gc28gd2UgY2FuIHVzZSBpdCBpZiBzb21ldGhpbmcgZ29lcyB3cm9uZ1xuICAgICAgICB0cmFuc2ZlcihzZXJ2ZXJJZCk7XG5cbiAgICAgICAgLy8gc3RvcmUgaW50ZXJuYWxseVxuICAgICAgICBzdGF0ZS5zZXJ2ZXJJZCA9IHNlcnZlcklkO1xuICAgICAgICBwcm9jZXNzQ2h1bmtzKCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVxdWVzdFRyYW5zZmVyT2Zmc2V0KGZ1bmN0aW9uKG9mZnNldCkge1xuICAgICAgICAvLyBzdG9wIGhlcmUgaWYgYWJvcnRlZCwgbWlnaHQgaGF2ZSBoYXBwZW5lZCBpbiBiZXR3ZWVuIHJlcXVlc3QgYW5kIGNhbGxiYWNrXG4gICAgICAgIGlmIChzdGF0ZS5hYm9ydGVkKSByZXR1cm47XG5cbiAgICAgICAgLy8gbWFyayBjaHVua3Mgd2l0aCBsb3dlciBvZmZzZXQgYXMgY29tcGxldGVcbiAgICAgICAgY2h1bmtzXG4gICAgICAgICAgLmZpbHRlcihmdW5jdGlvbihjaHVuaykge1xuICAgICAgICAgICAgcmV0dXJuIGNodW5rLm9mZnNldCA8IG9mZnNldDtcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uKGNodW5rKSB7XG4gICAgICAgICAgICBjaHVuay5zdGF0dXMgPSBDaHVua1N0YXR1cy5DT01QTEVURTtcbiAgICAgICAgICAgIGNodW5rLnByb2dyZXNzID0gY2h1bmsuc2l6ZTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAvLyBjb250aW51ZSBwcm9jZXNzaW5nXG4gICAgICAgIHByb2Nlc3NDaHVua3MoKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBhYm9ydDogZnVuY3Rpb24gYWJvcnQoKSB7XG4gICAgICAgIHN0YXRlLmFib3J0ZWQgPSB0cnVlO1xuICAgICAgICBhYm9ydENodW5rcygpO1xuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgLypcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHNpZ25hdHVyZTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGZpbGUsIG1ldGFkYXRhLCBsb2FkLCBlcnJvciwgcHJvZ3Jlc3MsIGFib3J0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhYm9ydDooKSA9PiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICB2YXIgY3JlYXRlRmlsZVByb2Nlc3NvckZ1bmN0aW9uID0gZnVuY3Rpb24gY3JlYXRlRmlsZVByb2Nlc3NvckZ1bmN0aW9uKFxuICAgIGFwaVVybCxcbiAgICBhY3Rpb24sXG4gICAgbmFtZSxcbiAgICBvcHRpb25zXG4gICkge1xuICAgIHJldHVybiBmdW5jdGlvbihmaWxlLCBtZXRhZGF0YSwgbG9hZCwgZXJyb3IsIHByb2dyZXNzLCBhYm9ydCwgdHJhbnNmZXIpIHtcbiAgICAgIC8vIG5vIGZpbGUgcmVjZWl2ZWRcbiAgICAgIGlmICghZmlsZSkgcmV0dXJuO1xuXG4gICAgICAvLyBpZiB3YXMgcGFzc2VkIGEgZmlsZSwgYW5kIHdlIGNhbiBjaHVuayBpdCwgZXhpdCBoZXJlXG4gICAgICB2YXIgY2FuQ2h1bmtVcGxvYWQgPSBvcHRpb25zLmNodW5rVXBsb2FkcztcbiAgICAgIHZhciBzaG91bGRDaHVua1VwbG9hZCA9IGNhbkNodW5rVXBsb2FkICYmIGZpbGUuc2l6ZSA+IG9wdGlvbnMuY2h1bmtTaXplO1xuICAgICAgdmFyIHdpbGxDaHVua1VwbG9hZCA9XG4gICAgICAgIGNhbkNodW5rVXBsb2FkICYmIChzaG91bGRDaHVua1VwbG9hZCB8fCBvcHRpb25zLmNodW5rRm9yY2UpO1xuICAgICAgaWYgKGZpbGUgaW5zdGFuY2VvZiBCbG9iICYmIHdpbGxDaHVua1VwbG9hZClcbiAgICAgICAgcmV0dXJuIHByb2Nlc3NGaWxlQ2h1bmtlZChcbiAgICAgICAgICBhcGlVcmwsXG4gICAgICAgICAgYWN0aW9uLFxuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgZmlsZSxcbiAgICAgICAgICBtZXRhZGF0YSxcbiAgICAgICAgICBsb2FkLFxuICAgICAgICAgIGVycm9yLFxuICAgICAgICAgIHByb2dyZXNzLFxuICAgICAgICAgIGFib3J0LFxuICAgICAgICAgIHRyYW5zZmVyLFxuICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgKTtcblxuICAgICAgLy8gc2V0IGhhbmRsZXJzXG4gICAgICB2YXIgb25kYXRhID1cbiAgICAgICAgYWN0aW9uLm9uZGF0YSB8fFxuICAgICAgICBmdW5jdGlvbihmZCkge1xuICAgICAgICAgIHJldHVybiBmZDtcbiAgICAgICAgfTtcbiAgICAgIHZhciBvbmxvYWQgPVxuICAgICAgICBhY3Rpb24ub25sb2FkIHx8XG4gICAgICAgIGZ1bmN0aW9uKHJlcykge1xuICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH07XG4gICAgICB2YXIgb25lcnJvciA9XG4gICAgICAgIGFjdGlvbi5vbmVycm9yIHx8XG4gICAgICAgIGZ1bmN0aW9uKHJlcykge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuXG4gICAgICAvLyBjcmVhdGUgZm9ybWRhdGEgb2JqZWN0XG4gICAgICB2YXIgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcblxuICAgICAgLy8gYWRkIG1ldGFkYXRhIHVuZGVyIHNhbWUgbmFtZVxuICAgICAgaWYgKGlzT2JqZWN0KG1ldGFkYXRhKSkge1xuICAgICAgICBmb3JtRGF0YS5hcHBlbmQobmFtZSwgSlNPTi5zdHJpbmdpZnkobWV0YWRhdGEpKTtcbiAgICAgIH1cblxuICAgICAgLy8gVHVybiBpbnRvIGFuIGFycmF5IG9mIG9iamVjdHMgc28gbm8gbWF0dGVyIHdoYXQgdGhlIGlucHV0LCB3ZSBjYW4gaGFuZGxlIGl0IHRoZSBzYW1lIHdheVxuICAgICAgKGZpbGUgaW5zdGFuY2VvZiBCbG9iID8gW3sgbmFtZTogbnVsbCwgZmlsZTogZmlsZSB9XSA6IGZpbGUpLmZvckVhY2goXG4gICAgICAgIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoXG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgaXRlbS5maWxlLFxuICAgICAgICAgICAgaXRlbS5uYW1lID09PSBudWxsXG4gICAgICAgICAgICAgID8gaXRlbS5maWxlLm5hbWVcbiAgICAgICAgICAgICAgOiAnJyArIGl0ZW0ubmFtZSArIGl0ZW0uZmlsZS5uYW1lXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgKTtcblxuICAgICAgLy8gc2VuZCByZXF1ZXN0IG9iamVjdFxuICAgICAgdmFyIHJlcXVlc3QgPSBzZW5kUmVxdWVzdChcbiAgICAgICAgb25kYXRhKGZvcm1EYXRhKSxcbiAgICAgICAgYnVpbGRVUkwoYXBpVXJsLCBhY3Rpb24udXJsKSxcbiAgICAgICAgYWN0aW9uXG4gICAgICApO1xuICAgICAgcmVxdWVzdC5vbmxvYWQgPSBmdW5jdGlvbih4aHIpIHtcbiAgICAgICAgbG9hZChcbiAgICAgICAgICBjcmVhdGVSZXNwb25zZShcbiAgICAgICAgICAgICdsb2FkJyxcbiAgICAgICAgICAgIHhoci5zdGF0dXMsXG4gICAgICAgICAgICBvbmxvYWQoeGhyLnJlc3BvbnNlKSxcbiAgICAgICAgICAgIHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKVxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH07XG5cbiAgICAgIHJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uKHhocikge1xuICAgICAgICBlcnJvcihcbiAgICAgICAgICBjcmVhdGVSZXNwb25zZShcbiAgICAgICAgICAgICdlcnJvcicsXG4gICAgICAgICAgICB4aHIuc3RhdHVzLFxuICAgICAgICAgICAgb25lcnJvcih4aHIucmVzcG9uc2UpIHx8IHhoci5zdGF0dXNUZXh0LFxuICAgICAgICAgICAgeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfTtcblxuICAgICAgcmVxdWVzdC5vbnRpbWVvdXQgPSBjcmVhdGVUaW1lb3V0UmVzcG9uc2UoZXJyb3IpO1xuICAgICAgcmVxdWVzdC5vbnByb2dyZXNzID0gcHJvZ3Jlc3M7XG4gICAgICByZXF1ZXN0Lm9uYWJvcnQgPSBhYm9ydDtcblxuICAgICAgLy8gc2hvdWxkIHJldHVybiByZXF1ZXN0XG4gICAgICByZXR1cm4gcmVxdWVzdDtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBjcmVhdGVQcm9jZXNzb3JGdW5jdGlvbiA9IGZ1bmN0aW9uIGNyZWF0ZVByb2Nlc3NvckZ1bmN0aW9uKCkge1xuICAgIHZhciBhcGlVcmwgPVxuICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAnJztcbiAgICB2YXIgYWN0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG4gICAgdmFyIG5hbWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzID8gYXJndW1lbnRzWzNdIDogdW5kZWZpbmVkO1xuXG4gICAgLy8gY3VzdG9tIGhhbmRsZXIgKHNob3VsZCBhbHNvIGhhbmRsZSBmaWxlLCBsb2FkLCBlcnJvciwgcHJvZ3Jlc3MgYW5kIGFib3J0KVxuICAgIGlmICh0eXBlb2YgYWN0aW9uID09PSAnZnVuY3Rpb24nKVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBmb3IgKFxuICAgICAgICAgIHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcGFyYW1zID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDtcbiAgICAgICAgICBfa2V5IDwgX2xlbjtcbiAgICAgICAgICBfa2V5KytcbiAgICAgICAgKSB7XG4gICAgICAgICAgcGFyYW1zW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY3Rpb24uYXBwbHkodm9pZCAwLCBbbmFtZV0uY29uY2F0KHBhcmFtcywgW29wdGlvbnNdKSk7XG4gICAgICB9O1xuXG4gICAgLy8gbm8gYWN0aW9uIHN1cHBsaWVkXG4gICAgaWYgKCFhY3Rpb24gfHwgIWlzU3RyaW5nKGFjdGlvbi51cmwpKSByZXR1cm4gbnVsbDtcblxuICAgIC8vIGludGVybmFsIGhhbmRsZXJcbiAgICByZXR1cm4gY3JlYXRlRmlsZVByb2Nlc3NvckZ1bmN0aW9uKGFwaVVybCwgYWN0aW9uLCBuYW1lLCBvcHRpb25zKTtcbiAgfTtcblxuICAvKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gc2lnbmF0dXJlOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHVuaXF1ZUZpbGVJZCwgbG9hZCwgZXJyb3IpID0+IHsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgdmFyIGNyZWF0ZVJldmVydEZ1bmN0aW9uID0gZnVuY3Rpb24gY3JlYXRlUmV2ZXJ0RnVuY3Rpb24oKSB7XG4gICAgdmFyIGFwaVVybCA9XG4gICAgICBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6ICcnO1xuICAgIHZhciBhY3Rpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgICAvLyBpcyBjdXN0b20gaW1wbGVtZW50YXRpb25cbiAgICBpZiAodHlwZW9mIGFjdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGFjdGlvbjtcbiAgICB9XG5cbiAgICAvLyBubyBhY3Rpb24gc3VwcGxpZWQsIHJldHVybiBzdHViIGZ1bmN0aW9uLCBpbnRlcmZhY2Ugd2lsbCB3b3JrLCBidXQgZmlsZSB3b24ndCBiZSByZW1vdmVkXG4gICAgaWYgKCFhY3Rpb24gfHwgIWlzU3RyaW5nKGFjdGlvbi51cmwpKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24odW5pcXVlRmlsZUlkLCBsb2FkKSB7XG4gICAgICAgIHJldHVybiBsb2FkKCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIHNldCBvbmxvYWQgaGFubGRlclxuICAgIHZhciBvbmxvYWQgPVxuICAgICAgYWN0aW9uLm9ubG9hZCB8fFxuICAgICAgZnVuY3Rpb24ocmVzKSB7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9O1xuICAgIHZhciBvbmVycm9yID1cbiAgICAgIGFjdGlvbi5vbmVycm9yIHx8XG4gICAgICBmdW5jdGlvbihyZXMpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuXG4gICAgLy8gaW50ZXJuYWwgaW1wbGVtZW50YXRpb25cbiAgICByZXR1cm4gZnVuY3Rpb24odW5pcXVlRmlsZUlkLCBsb2FkLCBlcnJvcikge1xuICAgICAgdmFyIHJlcXVlc3QgPSBzZW5kUmVxdWVzdChcbiAgICAgICAgdW5pcXVlRmlsZUlkLFxuICAgICAgICBhcGlVcmwgKyBhY3Rpb24udXJsLFxuICAgICAgICBhY3Rpb24gLy8gY29udGFpbnMgbWV0aG9kLCBoZWFkZXJzIGFuZCB3aXRoQ3JlZGVudGlhbHMgcHJvcGVydGllc1xuICAgICAgKTtcbiAgICAgIHJlcXVlc3Qub25sb2FkID0gZnVuY3Rpb24oeGhyKSB7XG4gICAgICAgIGxvYWQoXG4gICAgICAgICAgY3JlYXRlUmVzcG9uc2UoXG4gICAgICAgICAgICAnbG9hZCcsXG4gICAgICAgICAgICB4aHIuc3RhdHVzLFxuICAgICAgICAgICAgb25sb2FkKHhoci5yZXNwb25zZSksXG4gICAgICAgICAgICB4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKClcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9O1xuXG4gICAgICByZXF1ZXN0Lm9uZXJyb3IgPSBmdW5jdGlvbih4aHIpIHtcbiAgICAgICAgZXJyb3IoXG4gICAgICAgICAgY3JlYXRlUmVzcG9uc2UoXG4gICAgICAgICAgICAnZXJyb3InLFxuICAgICAgICAgICAgeGhyLnN0YXR1cyxcbiAgICAgICAgICAgIG9uZXJyb3IoeGhyLnJlc3BvbnNlKSB8fCB4aHIuc3RhdHVzVGV4dCxcbiAgICAgICAgICAgIHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKVxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH07XG5cbiAgICAgIHJlcXVlc3Qub250aW1lb3V0ID0gY3JlYXRlVGltZW91dFJlc3BvbnNlKGVycm9yKTtcblxuICAgICAgcmV0dXJuIHJlcXVlc3Q7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgZ2V0UmFuZG9tTnVtYmVyID0gZnVuY3Rpb24gZ2V0UmFuZG9tTnVtYmVyKCkge1xuICAgIHZhciBtaW4gPVxuICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAwO1xuICAgIHZhciBtYXggPVxuICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAxO1xuICAgIHJldHVybiBtaW4gKyBNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbik7XG4gIH07XG5cbiAgdmFyIGNyZWF0ZVBlcmNlaXZlZFBlcmZvcm1hbmNlVXBkYXRlciA9IGZ1bmN0aW9uIGNyZWF0ZVBlcmNlaXZlZFBlcmZvcm1hbmNlVXBkYXRlcihcbiAgICBjYlxuICApIHtcbiAgICB2YXIgZHVyYXRpb24gPVxuICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAxMDAwO1xuICAgIHZhciBvZmZzZXQgPVxuICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAwO1xuICAgIHZhciB0aWNrTWluID1cbiAgICAgIGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogMjU7XG4gICAgdmFyIHRpY2tNYXggPVxuICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiAyNTA7XG4gICAgdmFyIHRpbWVvdXQgPSBudWxsO1xuICAgIHZhciBzdGFydCA9IERhdGUubm93KCk7XG5cbiAgICB2YXIgdGljayA9IGZ1bmN0aW9uIHRpY2soKSB7XG4gICAgICB2YXIgcnVudGltZSA9IERhdGUubm93KCkgLSBzdGFydDtcbiAgICAgIHZhciBkZWxheSA9IGdldFJhbmRvbU51bWJlcih0aWNrTWluLCB0aWNrTWF4KTtcblxuICAgICAgaWYgKHJ1bnRpbWUgKyBkZWxheSA+IGR1cmF0aW9uKSB7XG4gICAgICAgIGRlbGF5ID0gcnVudGltZSArIGRlbGF5IC0gZHVyYXRpb247XG4gICAgICB9XG5cbiAgICAgIHZhciBwcm9ncmVzcyA9IHJ1bnRpbWUgLyBkdXJhdGlvbjtcbiAgICAgIGlmIChwcm9ncmVzcyA+PSAxIHx8IGRvY3VtZW50LmhpZGRlbikge1xuICAgICAgICBjYigxKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjYihwcm9ncmVzcyk7XG5cbiAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KHRpY2ssIGRlbGF5KTtcbiAgICB9O1xuXG4gICAgdGljaygpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGNsZWFyOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgdmFyIGNyZWF0ZUZpbGVQcm9jZXNzb3IgPSBmdW5jdGlvbiBjcmVhdGVGaWxlUHJvY2Vzc29yKHByb2Nlc3NGbikge1xuICAgIHZhciBzdGF0ZSA9IHtcbiAgICAgIGNvbXBsZXRlOiBmYWxzZSxcbiAgICAgIHBlcmNlaXZlZFByb2dyZXNzOiAwLFxuICAgICAgcGVyY2VpdmVkUGVyZm9ybWFuY2VVcGRhdGVyOiBudWxsLFxuICAgICAgcHJvZ3Jlc3M6IG51bGwsXG4gICAgICB0aW1lc3RhbXA6IG51bGwsXG4gICAgICBwZXJjZWl2ZWREdXJhdGlvbjogMCxcbiAgICAgIGR1cmF0aW9uOiAwLFxuICAgICAgcmVxdWVzdDogbnVsbCxcbiAgICAgIHJlc3BvbnNlOiBudWxsXG4gICAgfTtcblxuICAgIHZhciBwcm9jZXNzID0gZnVuY3Rpb24gcHJvY2VzcyhmaWxlLCBtZXRhZGF0YSkge1xuICAgICAgdmFyIHByb2dyZXNzRm4gPSBmdW5jdGlvbiBwcm9ncmVzc0ZuKCkge1xuICAgICAgICAvLyB3ZSd2ZSBub3QgeWV0IHN0YXJ0ZWQgdGhlIHJlYWwgZG93bmxvYWQsIHN0b3AgaGVyZVxuICAgICAgICAvLyB0aGUgcmVxdWVzdCBtaWdodCBub3QgZ28gdGhyb3VnaCwgZm9yIGluc3RhbmNlLCB0aGVyZSBtaWdodCBiZSBzb21lIHNlcnZlciB0cm91YmxlXG4gICAgICAgIC8vIGlmIHN0YXRlLnByb2dyZXNzIGlzIG51bGwsIHRoZSBzZXJ2ZXIgZG9lcyBub3QgYWxsb3cgY29tcHV0aW5nIHByb2dyZXNzIGFuZCB3ZSBzaG93IHRoZSBzcGlubmVyIGluc3RlYWRcbiAgICAgICAgaWYgKHN0YXRlLmR1cmF0aW9uID09PSAwIHx8IHN0YXRlLnByb2dyZXNzID09PSBudWxsKSByZXR1cm47XG5cbiAgICAgICAgLy8gYXMgd2UncmUgbm93IHByb2Nlc3NpbmcsIGZpcmUgdGhlIHByb2dyZXNzIGV2ZW50XG4gICAgICAgIGFwaS5maXJlKCdwcm9ncmVzcycsIGFwaS5nZXRQcm9ncmVzcygpKTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBjb21wbGV0ZUZuID0gZnVuY3Rpb24gY29tcGxldGVGbigpIHtcbiAgICAgICAgc3RhdGUuY29tcGxldGUgPSB0cnVlO1xuICAgICAgICBhcGkuZmlyZSgnbG9hZC1wZXJjZWl2ZWQnLCBzdGF0ZS5yZXNwb25zZS5ib2R5KTtcbiAgICAgIH07XG5cbiAgICAgIC8vIGxldCdzIHN0YXJ0IHByb2Nlc3NpbmdcbiAgICAgIGFwaS5maXJlKCdzdGFydCcpO1xuXG4gICAgICAvLyBzZXQgcmVxdWVzdCBzdGFydFxuICAgICAgc3RhdGUudGltZXN0YW1wID0gRGF0ZS5ub3coKTtcblxuICAgICAgLy8gY3JlYXRlIHBlcmNlaXZlZCBwZXJmb3JtYW5jZSBwcm9ncmVzcyBpbmRpY2F0b3JcbiAgICAgIHN0YXRlLnBlcmNlaXZlZFBlcmZvcm1hbmNlVXBkYXRlciA9IGNyZWF0ZVBlcmNlaXZlZFBlcmZvcm1hbmNlVXBkYXRlcihcbiAgICAgICAgZnVuY3Rpb24ocHJvZ3Jlc3MpIHtcbiAgICAgICAgICBzdGF0ZS5wZXJjZWl2ZWRQcm9ncmVzcyA9IHByb2dyZXNzO1xuICAgICAgICAgIHN0YXRlLnBlcmNlaXZlZER1cmF0aW9uID0gRGF0ZS5ub3coKSAtIHN0YXRlLnRpbWVzdGFtcDtcblxuICAgICAgICAgIHByb2dyZXNzRm4oKTtcblxuICAgICAgICAgIC8vIGlmIGZha2UgcHJvZ3Jlc3MgaXMgZG9uZSwgYW5kIGEgcmVzcG9uc2UgaGFzIGJlZW4gcmVjZWl2ZWQsXG4gICAgICAgICAgLy8gYW5kIHdlJ3ZlIG5vdCB5ZXQgY2FsbGVkIHRoZSBjb21wbGV0ZSBtZXRob2RcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBzdGF0ZS5yZXNwb25zZSAmJlxuICAgICAgICAgICAgc3RhdGUucGVyY2VpdmVkUHJvZ3Jlc3MgPT09IDEgJiZcbiAgICAgICAgICAgICFzdGF0ZS5jb21wbGV0ZVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgLy8gd2UgZG9uZSFcbiAgICAgICAgICAgIGNvbXBsZXRlRm4oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8vIHJhbmRvbSBkZWxheSBhcyBpbiBhIGxpc3Qgb2YgZmlsZXMgeW91IHN0YXJ0IG5vdGljaW5nXG4gICAgICAgIC8vIGZpbGVzIHVwbG9hZGluZyBhdCB0aGUgZXhhY3Qgc2FtZSBzcGVlZFxuICAgICAgICBnZXRSYW5kb21OdW1iZXIoNzUwLCAxNTAwKVxuICAgICAgKTtcblxuICAgICAgLy8gcmVtZW1iZXIgcmVxdWVzdCBzbyB3ZSBjYW4gYWJvcnQgaXQgbGF0ZXJcbiAgICAgIHN0YXRlLnJlcXVlc3QgPSBwcm9jZXNzRm4oXG4gICAgICAgIC8vIHRoZSBmaWxlIHRvIHByb2Nlc3NcbiAgICAgICAgZmlsZSxcblxuICAgICAgICAvLyB0aGUgbWV0YWRhdGEgdG8gc2VuZCBhbG9uZ1xuICAgICAgICBtZXRhZGF0YSxcblxuICAgICAgICAvLyBjYWxsYmFja3MgKGxvYWQsIGVycm9yLCBwcm9ncmVzcywgYWJvcnQsIHRyYW5zZmVyKVxuICAgICAgICAvLyBsb2FkIGV4cGVjdHMgdGhlIGJvZHkgdG8gYmUgYSBzZXJ2ZXIgaWQgaWZcbiAgICAgICAgLy8geW91IHdhbnQgdG8gbWFrZSB1c2Ugb2YgcmV2ZXJ0XG4gICAgICAgIGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgLy8gd2UgcHV0IHRoZSByZXNwb25zZSBpbiBzdGF0ZSBzbyB3ZSBjYW4gYWNjZXNzXG4gICAgICAgICAgLy8gaXQgb3V0c2lkZSBvZiB0aGlzIG1ldGhvZFxuICAgICAgICAgIHN0YXRlLnJlc3BvbnNlID0gaXNPYmplY3QocmVzcG9uc2UpXG4gICAgICAgICAgICA/IHJlc3BvbnNlXG4gICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnbG9hZCcsXG4gICAgICAgICAgICAgICAgY29kZTogMjAwLFxuICAgICAgICAgICAgICAgIGJvZHk6ICcnICsgcmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge31cbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgIC8vIHVwZGF0ZSBkdXJhdGlvblxuICAgICAgICAgIHN0YXRlLmR1cmF0aW9uID0gRGF0ZS5ub3coKSAtIHN0YXRlLnRpbWVzdGFtcDtcblxuICAgICAgICAgIC8vIGZvcmNlIHByb2dyZXNzIHRvIDEgYXMgd2UncmUgbm93IGRvbmVcbiAgICAgICAgICBzdGF0ZS5wcm9ncmVzcyA9IDE7XG5cbiAgICAgICAgICAvLyBhY3R1YWwgbG9hZCBpcyBkb25lIGxldCdzIHNoYXJlIHJlc3VsdHNcbiAgICAgICAgICBhcGkuZmlyZSgnbG9hZCcsIHN0YXRlLnJlc3BvbnNlLmJvZHkpO1xuXG4gICAgICAgICAgLy8gd2UgYXJlIHJlYWxseSBkb25lXG4gICAgICAgICAgLy8gaWYgcGVyY2VpdmVkIHByb2dyZXNzIGlzIDEgKCB3YWl0IGZvciBwZXJjZWl2ZWQgcHJvZ3Jlc3MgdG8gY29tcGxldGUgKVxuICAgICAgICAgIC8vIG9yIGlmIHNlcnZlciBkb2VzIG5vdCBzdXBwb3J0IHByb2dyZXNzICggbnVsbCApXG4gICAgICAgICAgaWYgKHN0YXRlLnBlcmNlaXZlZFByb2dyZXNzID09PSAxKSB7XG4gICAgICAgICAgICBjb21wbGV0ZUZuKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIGVycm9yIGlzIGV4cGVjdGVkIHRvIGJlIGFuIG9iamVjdCB3aXRoIHR5cGUsIGNvZGUsIGJvZHlcbiAgICAgICAgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAvLyBjYW5jZWwgdXBkYXRlclxuICAgICAgICAgIHN0YXRlLnBlcmNlaXZlZFBlcmZvcm1hbmNlVXBkYXRlci5jbGVhcigpO1xuXG4gICAgICAgICAgLy8gdXBkYXRlIG90aGVycyBhYm91dCB0aGlzIGVycm9yXG4gICAgICAgICAgYXBpLmZpcmUoXG4gICAgICAgICAgICAnZXJyb3InLFxuICAgICAgICAgICAgaXNPYmplY3QoZXJyb3IpXG4gICAgICAgICAgICAgID8gZXJyb3JcbiAgICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiAnZXJyb3InLFxuICAgICAgICAgICAgICAgICAgY29kZTogMCxcbiAgICAgICAgICAgICAgICAgIGJvZHk6ICcnICsgZXJyb3JcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBhY3R1YWwgcHJvY2Vzc2luZyBwcm9ncmVzc1xuICAgICAgICBmdW5jdGlvbihjb21wdXRhYmxlLCBjdXJyZW50LCB0b3RhbCkge1xuICAgICAgICAgIC8vIHVwZGF0ZSBhY3R1YWwgZHVyYXRpb25cbiAgICAgICAgICBzdGF0ZS5kdXJhdGlvbiA9IERhdGUubm93KCkgLSBzdGF0ZS50aW1lc3RhbXA7XG5cbiAgICAgICAgICAvLyB1cGRhdGUgYWN0dWFsIHByb2dyZXNzXG4gICAgICAgICAgc3RhdGUucHJvZ3Jlc3MgPSBjb21wdXRhYmxlID8gY3VycmVudCAvIHRvdGFsIDogbnVsbDtcblxuICAgICAgICAgIHByb2dyZXNzRm4oKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBhYm9ydCBkb2VzIG5vdCBleHBlY3QgYSB2YWx1ZVxuICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAvLyBzdG9wIHVwZGF0ZXJcbiAgICAgICAgICBzdGF0ZS5wZXJjZWl2ZWRQZXJmb3JtYW5jZVVwZGF0ZXIuY2xlYXIoKTtcblxuICAgICAgICAgIC8vIGZpcmUgdGhlIGFib3J0IGV2ZW50IHNvIHdlIGNhbiBzd2l0Y2ggdmlzdWFsc1xuICAgICAgICAgIGFwaS5maXJlKCdhYm9ydCcsIHN0YXRlLnJlc3BvbnNlID8gc3RhdGUucmVzcG9uc2UuYm9keSA6IG51bGwpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIHJlZ2lzdGVyIHRoZSBpZCBmb3IgdGhpcyB0cmFuc2ZlclxuICAgICAgICBmdW5jdGlvbih0cmFuc2ZlcklkKSB7XG4gICAgICAgICAgYXBpLmZpcmUoJ3RyYW5zZmVyJywgdHJhbnNmZXJJZCk7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfTtcblxuICAgIHZhciBhYm9ydCA9IGZ1bmN0aW9uIGFib3J0KCkge1xuICAgICAgLy8gbm8gcmVxdWVzdCBydW5uaW5nLCBjYW4ndCBhYm9ydFxuICAgICAgaWYgKCFzdGF0ZS5yZXF1ZXN0KSByZXR1cm47XG5cbiAgICAgIC8vIHN0b3AgdXBkYXRlclxuICAgICAgc3RhdGUucGVyY2VpdmVkUGVyZm9ybWFuY2VVcGRhdGVyLmNsZWFyKCk7XG5cbiAgICAgIC8vIGFib3J0IGFjdHVhbCByZXF1ZXN0XG4gICAgICBpZiAoc3RhdGUucmVxdWVzdC5hYm9ydCkgc3RhdGUucmVxdWVzdC5hYm9ydCgpO1xuXG4gICAgICAvLyBpZiBoYXMgcmVzcG9uc2Ugb2JqZWN0LCB3ZSd2ZSBjb21wbGV0ZWQgdGhlIHJlcXVlc3RcbiAgICAgIHN0YXRlLmNvbXBsZXRlID0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgdmFyIHJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICBhYm9ydCgpO1xuICAgICAgc3RhdGUuY29tcGxldGUgPSBmYWxzZTtcbiAgICAgIHN0YXRlLnBlcmNlaXZlZFByb2dyZXNzID0gMDtcbiAgICAgIHN0YXRlLnByb2dyZXNzID0gMDtcbiAgICAgIHN0YXRlLnRpbWVzdGFtcCA9IG51bGw7XG4gICAgICBzdGF0ZS5wZXJjZWl2ZWREdXJhdGlvbiA9IDA7XG4gICAgICBzdGF0ZS5kdXJhdGlvbiA9IDA7XG4gICAgICBzdGF0ZS5yZXF1ZXN0ID0gbnVsbDtcbiAgICAgIHN0YXRlLnJlc3BvbnNlID0gbnVsbDtcbiAgICB9O1xuXG4gICAgdmFyIGdldFByb2dyZXNzID0gZnVuY3Rpb24gZ2V0UHJvZ3Jlc3MoKSB7XG4gICAgICByZXR1cm4gc3RhdGUucHJvZ3Jlc3NcbiAgICAgICAgPyBNYXRoLm1pbihzdGF0ZS5wcm9ncmVzcywgc3RhdGUucGVyY2VpdmVkUHJvZ3Jlc3MpXG4gICAgICAgIDogbnVsbDtcbiAgICB9O1xuICAgIHZhciBnZXREdXJhdGlvbiA9IGZ1bmN0aW9uIGdldER1cmF0aW9uKCkge1xuICAgICAgcmV0dXJuIE1hdGgubWluKHN0YXRlLmR1cmF0aW9uLCBzdGF0ZS5wZXJjZWl2ZWREdXJhdGlvbik7XG4gICAgfTtcblxuICAgIHZhciBhcGkgPSBPYmplY3QuYXNzaWduKHt9LCBvbigpLCB7XG4gICAgICBwcm9jZXNzOiBwcm9jZXNzLCAvLyBzdGFydCBwcm9jZXNzaW5nIGZpbGVcbiAgICAgIGFib3J0OiBhYm9ydCwgLy8gYWJvcnQgYWN0aXZlIHByb2Nlc3MgcmVxdWVzdFxuICAgICAgZ2V0UHJvZ3Jlc3M6IGdldFByb2dyZXNzLFxuICAgICAgZ2V0RHVyYXRpb246IGdldER1cmF0aW9uLFxuICAgICAgcmVzZXQ6IHJlc2V0XG4gICAgfSk7XG5cbiAgICByZXR1cm4gYXBpO1xuICB9O1xuXG4gIHZhciBnZXRGaWxlbmFtZVdpdGhvdXRFeHRlbnNpb24gPSBmdW5jdGlvbiBnZXRGaWxlbmFtZVdpdGhvdXRFeHRlbnNpb24obmFtZSkge1xuICAgIHJldHVybiBuYW1lLnN1YnN0cigwLCBuYW1lLmxhc3RJbmRleE9mKCcuJykpIHx8IG5hbWU7XG4gIH07XG5cbiAgdmFyIGNyZWF0ZUZpbGVTdHViID0gZnVuY3Rpb24gY3JlYXRlRmlsZVN0dWIoc291cmNlKSB7XG4gICAgdmFyIGRhdGEgPSBbc291cmNlLm5hbWUsIHNvdXJjZS5zaXplLCBzb3VyY2UudHlwZV07XG5cbiAgICAvLyBpcyBibG9iIG9yIGJhc2U2NCwgdGhlbiB3ZSBuZWVkIHRvIHNldCB0aGUgbmFtZVxuICAgIGlmIChzb3VyY2UgaW5zdGFuY2VvZiBCbG9iIHx8IGlzQmFzZTY0RGF0YVVSSShzb3VyY2UpKSB7XG4gICAgICBkYXRhWzBdID0gc291cmNlLm5hbWUgfHwgZ2V0RGF0ZVN0cmluZygpO1xuICAgIH0gZWxzZSBpZiAoaXNCYXNlNjREYXRhVVJJKHNvdXJjZSkpIHtcbiAgICAgIC8vIGlmIGlzIGJhc2U2NCBkYXRhIHVyaSB3ZSBuZWVkIHRvIGRldGVybWluZSB0aGUgYXZlcmFnZSBzaXplIGFuZCB0eXBlXG4gICAgICBkYXRhWzFdID0gc291cmNlLmxlbmd0aDtcbiAgICAgIGRhdGFbMl0gPSBnZXRNaW1lVHlwZUZyb21CYXNlNjREYXRhVVJJKHNvdXJjZSk7XG4gICAgfSBlbHNlIGlmIChpc1N0cmluZyhzb3VyY2UpKSB7XG4gICAgICAvLyB1cmxcbiAgICAgIGRhdGFbMF0gPSBnZXRGaWxlbmFtZUZyb21VUkwoc291cmNlKTtcbiAgICAgIGRhdGFbMV0gPSAwO1xuICAgICAgZGF0YVsyXSA9ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiBkYXRhWzBdLFxuICAgICAgc2l6ZTogZGF0YVsxXSxcbiAgICAgIHR5cGU6IGRhdGFbMl1cbiAgICB9O1xuICB9O1xuXG4gIHZhciBpc0ZpbGUgPSBmdW5jdGlvbiBpc0ZpbGUodmFsdWUpIHtcbiAgICByZXR1cm4gISEodmFsdWUgaW5zdGFuY2VvZiBGaWxlIHx8ICh2YWx1ZSBpbnN0YW5jZW9mIEJsb2IgJiYgdmFsdWUubmFtZSkpO1xuICB9O1xuXG4gIHZhciBkZWVwQ2xvbmVPYmplY3QgPSBmdW5jdGlvbiBkZWVwQ2xvbmVPYmplY3Qoc3JjKSB7XG4gICAgaWYgKCFpc09iamVjdChzcmMpKSByZXR1cm4gc3JjO1xuICAgIHZhciB0YXJnZXQgPSBpc0FycmF5KHNyYykgPyBbXSA6IHt9O1xuICAgIGZvciAodmFyIGtleSBpbiBzcmMpIHtcbiAgICAgIGlmICghc3JjLmhhc093blByb3BlcnR5KGtleSkpIGNvbnRpbnVlO1xuICAgICAgdmFyIHYgPSBzcmNba2V5XTtcbiAgICAgIHRhcmdldFtrZXldID0gdiAmJiBpc09iamVjdCh2KSA/IGRlZXBDbG9uZU9iamVjdCh2KSA6IHY7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG5cbiAgdmFyIGNyZWF0ZUl0ZW0gPSBmdW5jdGlvbiBjcmVhdGVJdGVtKCkge1xuICAgIHZhciBvcmlnaW4gPVxuICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBudWxsO1xuICAgIHZhciBzZXJ2ZXJGaWxlUmVmZXJlbmNlID1cbiAgICAgIGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbnVsbDtcbiAgICB2YXIgZmlsZSA9XG4gICAgICBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IG51bGw7XG4gICAgLy8gdW5pcXVlIGlkIGZvciB0aGlzIGl0ZW0sIGlzIHVzZWQgdG8gaWRlbnRpZnkgdGhlIGl0ZW0gYWNyb3NzIHZpZXdzXG4gICAgdmFyIGlkID0gZ2V0VW5pcXVlSWQoKTtcblxuICAgIC8qKlxuICAgICAqIEludGVybmFsIGl0ZW0gc3RhdGVcbiAgICAgKi9cbiAgICB2YXIgc3RhdGUgPSB7XG4gICAgICAvLyBpcyBhcmNoaXZlZFxuICAgICAgYXJjaGl2ZWQ6IGZhbHNlLFxuXG4gICAgICAvLyBpZiBpcyBmcm96ZW4sIG5vIGxvbmdlciBmaXJlcyBldmVudHNcbiAgICAgIGZyb3plbjogZmFsc2UsXG5cbiAgICAgIC8vIHJlbW92ZWQgZnJvbSB2aWV3XG4gICAgICByZWxlYXNlZDogZmFsc2UsXG5cbiAgICAgIC8vIG9yaWdpbmFsIHNvdXJjZVxuICAgICAgc291cmNlOiBudWxsLFxuXG4gICAgICAvLyBmaWxlIG1vZGVsIHJlZmVyZW5jZVxuICAgICAgZmlsZTogZmlsZSxcblxuICAgICAgLy8gaWQgb2YgZmlsZSBvbiBzZXJ2ZXJcbiAgICAgIHNlcnZlckZpbGVSZWZlcmVuY2U6IHNlcnZlckZpbGVSZWZlcmVuY2UsXG5cbiAgICAgIC8vIGlkIG9mIGZpbGUgdHJhbnNmZXIgb24gc2VydmVyXG4gICAgICB0cmFuc2ZlcklkOiBudWxsLFxuXG4gICAgICAvLyBpcyBhYm9ydGVkXG4gICAgICBwcm9jZXNzaW5nQWJvcnRlZDogZmFsc2UsXG5cbiAgICAgIC8vIGN1cnJlbnQgaXRlbSBzdGF0dXNcbiAgICAgIHN0YXR1czogc2VydmVyRmlsZVJlZmVyZW5jZVxuICAgICAgICA/IEl0ZW1TdGF0dXMuUFJPQ0VTU0lOR19DT01QTEVURVxuICAgICAgICA6IEl0ZW1TdGF0dXMuSU5JVCxcblxuICAgICAgLy8gYWN0aXZlIHByb2Nlc3Nlc1xuICAgICAgYWN0aXZlTG9hZGVyOiBudWxsLFxuICAgICAgYWN0aXZlUHJvY2Vzc29yOiBudWxsXG4gICAgfTtcblxuICAgIC8vIGNhbGxiYWNrIHVzZWQgd2hlbiBhYm9ydCBwcm9jZXNzaW5nIGlzIGNhbGxlZCB0byBsaW5rIGJhY2sgdG8gdGhlIHJlc29sdmUgbWV0aG9kXG4gICAgdmFyIGFib3J0UHJvY2Vzc2luZ1JlcXVlc3RDb21wbGV0ZSA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBFeHRlcm5hbGx5IGFkZGVkIGl0ZW0gbWV0YWRhdGFcbiAgICAgKi9cbiAgICB2YXIgbWV0YWRhdGEgPSB7fTtcblxuICAgIC8vIGl0ZW0gZGF0YVxuICAgIHZhciBzZXRTdGF0dXMgPSBmdW5jdGlvbiBzZXRTdGF0dXMoc3RhdHVzKSB7XG4gICAgICByZXR1cm4gKHN0YXRlLnN0YXR1cyA9IHN0YXR1cyk7XG4gICAgfTtcblxuICAgIC8vIGZpcmUgZXZlbnQgdW5sZXNzIHRoZSBpdGVtIGhhcyBiZWVuIGFyY2hpdmVkXG4gICAgdmFyIGZpcmUgPSBmdW5jdGlvbiBmaXJlKGV2ZW50KSB7XG4gICAgICBpZiAoc3RhdGUucmVsZWFzZWQgfHwgc3RhdGUuZnJvemVuKSByZXR1cm47XG4gICAgICBmb3IgKFxuICAgICAgICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsXG4gICAgICAgICAgcGFyYW1zID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSxcbiAgICAgICAgICBfa2V5ID0gMTtcbiAgICAgICAgX2tleSA8IF9sZW47XG4gICAgICAgIF9rZXkrK1xuICAgICAgKSB7XG4gICAgICAgIHBhcmFtc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG4gICAgICBhcGkuZmlyZS5hcHBseShhcGksIFtldmVudF0uY29uY2F0KHBhcmFtcykpO1xuICAgIH07XG5cbiAgICAvLyBmaWxlIGRhdGFcbiAgICB2YXIgZ2V0RmlsZUV4dGVuc2lvbiA9IGZ1bmN0aW9uIGdldEZpbGVFeHRlbnNpb24oKSB7XG4gICAgICByZXR1cm4gZ2V0RXh0ZW5zaW9uRnJvbUZpbGVuYW1lKHN0YXRlLmZpbGUubmFtZSk7XG4gICAgfTtcbiAgICB2YXIgZ2V0RmlsZVR5cGUgPSBmdW5jdGlvbiBnZXRGaWxlVHlwZSgpIHtcbiAgICAgIHJldHVybiBzdGF0ZS5maWxlLnR5cGU7XG4gICAgfTtcbiAgICB2YXIgZ2V0RmlsZVNpemUgPSBmdW5jdGlvbiBnZXRGaWxlU2l6ZSgpIHtcbiAgICAgIHJldHVybiBzdGF0ZS5maWxlLnNpemU7XG4gICAgfTtcbiAgICB2YXIgZ2V0RmlsZSA9IGZ1bmN0aW9uIGdldEZpbGUoKSB7XG4gICAgICByZXR1cm4gc3RhdGUuZmlsZTtcbiAgICB9O1xuXG4gICAgLy9cbiAgICAvLyBsb2dpYyB0byBsb2FkIGEgZmlsZVxuICAgIC8vXG4gICAgdmFyIGxvYWQgPSBmdW5jdGlvbiBsb2FkKHNvdXJjZSwgbG9hZGVyLCBvbmxvYWQpIHtcbiAgICAgIC8vIHJlbWVtYmVyIHRoZSBvcmlnaW5hbCBpdGVtIHNvdXJjZVxuICAgICAgc3RhdGUuc291cmNlID0gc291cmNlO1xuXG4gICAgICAvLyBzb3VyY2UgaXMga25vd25cbiAgICAgIGFwaS5maXJlU3luYygnaW5pdCcpO1xuXG4gICAgICAvLyBmaWxlIHN0dWIgaXMgYWxyZWFkeSB0aGVyZVxuICAgICAgaWYgKHN0YXRlLmZpbGUpIHtcbiAgICAgICAgYXBpLmZpcmVTeW5jKCdsb2FkLXNraXAnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBzZXQgYSBzdHViIGZpbGUgb2JqZWN0IHdoaWxlIGxvYWRpbmcgdGhlIGFjdHVhbCBkYXRhXG4gICAgICBzdGF0ZS5maWxlID0gY3JlYXRlRmlsZVN0dWIoc291cmNlKTtcblxuICAgICAgLy8gc3RhcnRzIGxvYWRpbmdcbiAgICAgIGxvYWRlci5vbignaW5pdCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICBmaXJlKCdsb2FkLWluaXQnKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyB3ZSdldmUgcmVjZWl2ZWQgYSBzaXplIGluZGljYXRpb24sIGxldCdzIHVwZGF0ZSB0aGUgc3R1YlxuICAgICAgbG9hZGVyLm9uKCdtZXRhJywgZnVuY3Rpb24obWV0YSkge1xuICAgICAgICAvLyBzZXQgc2l6ZSBvZiBmaWxlIHN0dWJcbiAgICAgICAgc3RhdGUuZmlsZS5zaXplID0gbWV0YS5zaXplO1xuXG4gICAgICAgIC8vIHNldCBuYW1lIG9mIGZpbGUgc3R1YlxuICAgICAgICBzdGF0ZS5maWxlLmZpbGVuYW1lID0gbWV0YS5maWxlbmFtZTtcblxuICAgICAgICAvLyBpZiBoYXMgcmVjZWl2ZWQgc291cmNlLCB3ZSBkb25lXG4gICAgICAgIGlmIChtZXRhLnNvdXJjZSkge1xuICAgICAgICAgIG9yaWdpbiA9IEZpbGVPcmlnaW4uTElNQk87XG4gICAgICAgICAgc3RhdGUuc2VydmVyRmlsZVJlZmVyZW5jZSA9IG1ldGEuc291cmNlO1xuICAgICAgICAgIHN0YXRlLnN0YXR1cyA9IEl0ZW1TdGF0dXMuUFJPQ0VTU0lOR19DT01QTEVURTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNpemUgaGFzIGJlZW4gdXBkYXRlZFxuICAgICAgICBmaXJlKCdsb2FkLW1ldGEnKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyB0aGUgZmlsZSBpcyBub3cgbG9hZGluZyB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGUgcHJvZ3Jlc3MgaW5kaWNhdG9yc1xuICAgICAgbG9hZGVyLm9uKCdwcm9ncmVzcycsIGZ1bmN0aW9uKHByb2dyZXNzKSB7XG4gICAgICAgIHNldFN0YXR1cyhJdGVtU3RhdHVzLkxPQURJTkcpO1xuXG4gICAgICAgIGZpcmUoJ2xvYWQtcHJvZ3Jlc3MnLCBwcm9ncmVzcyk7XG4gICAgICB9KTtcblxuICAgICAgLy8gYW4gZXJyb3Igd2FzIHRocm93biB3aGlsZSBsb2FkaW5nIHRoZSBmaWxlLCB3ZSBuZWVkIHRvIHN3aXRjaCB0byBlcnJvciBzdGF0ZVxuICAgICAgbG9hZGVyLm9uKCdlcnJvcicsIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgIHNldFN0YXR1cyhJdGVtU3RhdHVzLkxPQURfRVJST1IpO1xuXG4gICAgICAgIGZpcmUoJ2xvYWQtcmVxdWVzdC1lcnJvcicsIGVycm9yKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyB1c2VyIG9yIGFub3RoZXIgcHJvY2VzcyBhYm9ydGVkIHRoZSBmaWxlIGxvYWQgKGNhbm5vdCByZXRyeSlcbiAgICAgIGxvYWRlci5vbignYWJvcnQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgc2V0U3RhdHVzKEl0ZW1TdGF0dXMuSU5JVCk7XG4gICAgICAgIGZpcmUoJ2xvYWQtYWJvcnQnKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBkb25lIGxvYWRpbmdcbiAgICAgIGxvYWRlci5vbignbG9hZCcsIGZ1bmN0aW9uKGZpbGUpIHtcbiAgICAgICAgLy8gYXMgd2UndmUgbm93IGxvYWRlZCB0aGUgZmlsZSB0aGUgbG9hZGVyIGlzIG5vIGxvbmdlciByZXF1aXJlZFxuICAgICAgICBzdGF0ZS5hY3RpdmVMb2FkZXIgPSBudWxsO1xuXG4gICAgICAgIC8vIGNhbGxlZCB3aGVuIGZpbGUgaGFzIGxvYWRlZCBzdWNjZXNmdWxseVxuICAgICAgICB2YXIgc3VjY2VzcyA9IGZ1bmN0aW9uIHN1Y2Nlc3MocmVzdWx0KSB7XG4gICAgICAgICAgLy8gc2V0IChwb3NzaWJseSkgdHJhbnNmb3JtZWQgZmlsZVxuICAgICAgICAgIHN0YXRlLmZpbGUgPSBpc0ZpbGUocmVzdWx0KSA/IHJlc3VsdCA6IHN0YXRlLmZpbGU7XG5cbiAgICAgICAgICAvLyBmaWxlIHJlY2VpdmVkXG4gICAgICAgICAgaWYgKG9yaWdpbiA9PT0gRmlsZU9yaWdpbi5MSU1CTyAmJiBzdGF0ZS5zZXJ2ZXJGaWxlUmVmZXJlbmNlKSB7XG4gICAgICAgICAgICBzZXRTdGF0dXMoSXRlbVN0YXR1cy5QUk9DRVNTSU5HX0NPTVBMRVRFKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2V0U3RhdHVzKEl0ZW1TdGF0dXMuSURMRSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZmlyZSgnbG9hZCcpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBlcnJvciA9IGZ1bmN0aW9uIGVycm9yKHJlc3VsdCkge1xuICAgICAgICAgIC8vIHNldCBvcmlnaW5hbCBmaWxlXG4gICAgICAgICAgc3RhdGUuZmlsZSA9IGZpbGU7XG4gICAgICAgICAgZmlyZSgnbG9hZC1tZXRhJyk7XG5cbiAgICAgICAgICBzZXRTdGF0dXMoSXRlbVN0YXR1cy5MT0FEX0VSUk9SKTtcbiAgICAgICAgICBmaXJlKCdsb2FkLWZpbGUtZXJyb3InLCByZXN1bHQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGlmIHdlIGFscmVhZHkgaGF2ZSBhIHNlcnZlciBmaWxlIHJlZmVyZW5jZSwgd2UgZG9uJ3QgbmVlZCB0byBjYWxsIHRoZSBvbmxvYWQgbWV0aG9kXG4gICAgICAgIGlmIChzdGF0ZS5zZXJ2ZXJGaWxlUmVmZXJlbmNlKSB7XG4gICAgICAgICAgc3VjY2VzcyhmaWxlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBubyBzZXJ2ZXIgaWQsIGxldCdzIGdpdmUgdGhpcyBmaWxlIHRoZSBmdWxsIHRyZWF0bWVudFxuICAgICAgICBvbmxvYWQoZmlsZSwgc3VjY2VzcywgZXJyb3IpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIHNldCBsb2FkZXIgc291cmNlIGRhdGFcbiAgICAgIGxvYWRlci5zZXRTb3VyY2Uoc291cmNlKTtcblxuICAgICAgLy8gc2V0IGFzIGFjdGl2ZSBsb2FkZXJcbiAgICAgIHN0YXRlLmFjdGl2ZUxvYWRlciA9IGxvYWRlcjtcblxuICAgICAgLy8gbG9hZCB0aGUgc291cmNlIGRhdGFcbiAgICAgIGxvYWRlci5sb2FkKCk7XG4gICAgfTtcblxuICAgIHZhciByZXRyeUxvYWQgPSBmdW5jdGlvbiByZXRyeUxvYWQoKSB7XG4gICAgICBpZiAoIXN0YXRlLmFjdGl2ZUxvYWRlcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzdGF0ZS5hY3RpdmVMb2FkZXIubG9hZCgpO1xuICAgIH07XG5cbiAgICB2YXIgYWJvcnRMb2FkID0gZnVuY3Rpb24gYWJvcnRMb2FkKCkge1xuICAgICAgaWYgKHN0YXRlLmFjdGl2ZUxvYWRlcikge1xuICAgICAgICBzdGF0ZS5hY3RpdmVMb2FkZXIuYWJvcnQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc2V0U3RhdHVzKEl0ZW1TdGF0dXMuSU5JVCk7XG4gICAgICBmaXJlKCdsb2FkLWFib3J0Jyk7XG4gICAgfTtcblxuICAgIC8vXG4gICAgLy8gbG9naWMgdG8gcHJvY2VzcyBhIGZpbGVcbiAgICAvL1xuICAgIHZhciBwcm9jZXNzID0gZnVuY3Rpb24gcHJvY2Vzcyhwcm9jZXNzb3IsIG9ucHJvY2Vzcykge1xuICAgICAgLy8gcHJvY2Vzc2luZyB3YXMgYWJvcnRlZFxuICAgICAgaWYgKHN0YXRlLnByb2Nlc3NpbmdBYm9ydGVkKSB7XG4gICAgICAgIHN0YXRlLnByb2Nlc3NpbmdBYm9ydGVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gbm93IHByb2Nlc3NpbmdcbiAgICAgIHNldFN0YXR1cyhJdGVtU3RhdHVzLlBST0NFU1NJTkcpO1xuXG4gICAgICAvLyByZXNldCBhYm9ydCBjYWxsYmFja1xuICAgICAgYWJvcnRQcm9jZXNzaW5nUmVxdWVzdENvbXBsZXRlID0gbnVsbDtcblxuICAgICAgLy8gaWYgbm8gZmlsZSBsb2FkZWQgd2UnbGwgd2FpdCBmb3IgdGhlIGxvYWQgZXZlbnRcbiAgICAgIGlmICghKHN0YXRlLmZpbGUgaW5zdGFuY2VvZiBCbG9iKSkge1xuICAgICAgICBhcGkub24oJ2xvYWQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICBwcm9jZXNzKHByb2Nlc3Nvciwgb25wcm9jZXNzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gc2V0dXAgcHJvY2Vzc29yXG4gICAgICBwcm9jZXNzb3Iub24oJ2xvYWQnLCBmdW5jdGlvbihzZXJ2ZXJGaWxlUmVmZXJlbmNlKSB7XG4gICAgICAgIC8vIG5lZWQgdGhpcyBpZCB0byBiZSBhYmxlIHRvIHJldmVydCB0aGUgdXBsb2FkXG4gICAgICAgIHN0YXRlLnRyYW5zZmVySWQgPSBudWxsO1xuICAgICAgICBzdGF0ZS5zZXJ2ZXJGaWxlUmVmZXJlbmNlID0gc2VydmVyRmlsZVJlZmVyZW5jZTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyByZWdpc3RlciB0cmFuc2ZlciBpZFxuICAgICAgcHJvY2Vzc29yLm9uKCd0cmFuc2ZlcicsIGZ1bmN0aW9uKHRyYW5zZmVySWQpIHtcbiAgICAgICAgLy8gbmVlZCB0aGlzIGlkIHRvIGJlIGFibGUgdG8gcmV2ZXJ0IHRoZSB1cGxvYWRcbiAgICAgICAgc3RhdGUudHJhbnNmZXJJZCA9IHRyYW5zZmVySWQ7XG4gICAgICB9KTtcblxuICAgICAgcHJvY2Vzc29yLm9uKCdsb2FkLXBlcmNlaXZlZCcsIGZ1bmN0aW9uKHNlcnZlckZpbGVSZWZlcmVuY2UpIHtcbiAgICAgICAgLy8gbm8gbG9uZ2VyIHJlcXVpcmVkXG4gICAgICAgIHN0YXRlLmFjdGl2ZVByb2Nlc3NvciA9IG51bGw7XG5cbiAgICAgICAgLy8gbmVlZCB0aGlzIGlkIHRvIGJlIGFibGUgdG8gcmV2ZXIgdGhlIHVwbG9hZFxuICAgICAgICBzdGF0ZS50cmFuc2ZlcklkID0gbnVsbDtcbiAgICAgICAgc3RhdGUuc2VydmVyRmlsZVJlZmVyZW5jZSA9IHNlcnZlckZpbGVSZWZlcmVuY2U7XG5cbiAgICAgICAgc2V0U3RhdHVzKEl0ZW1TdGF0dXMuUFJPQ0VTU0lOR19DT01QTEVURSk7XG4gICAgICAgIGZpcmUoJ3Byb2Nlc3MtY29tcGxldGUnLCBzZXJ2ZXJGaWxlUmVmZXJlbmNlKTtcbiAgICAgIH0pO1xuXG4gICAgICBwcm9jZXNzb3Iub24oJ3N0YXJ0JywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGZpcmUoJ3Byb2Nlc3Mtc3RhcnQnKTtcbiAgICAgIH0pO1xuXG4gICAgICBwcm9jZXNzb3Iub24oJ2Vycm9yJywgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgc3RhdGUuYWN0aXZlUHJvY2Vzc29yID0gbnVsbDtcbiAgICAgICAgc2V0U3RhdHVzKEl0ZW1TdGF0dXMuUFJPQ0VTU0lOR19FUlJPUik7XG4gICAgICAgIGZpcmUoJ3Byb2Nlc3MtZXJyb3InLCBlcnJvcik7XG4gICAgICB9KTtcblxuICAgICAgcHJvY2Vzc29yLm9uKCdhYm9ydCcsIGZ1bmN0aW9uKHNlcnZlckZpbGVSZWZlcmVuY2UpIHtcbiAgICAgICAgc3RhdGUuYWN0aXZlUHJvY2Vzc29yID0gbnVsbDtcblxuICAgICAgICAvLyBpZiBmaWxlIHdhcyB1cGxvYWRlZCBidXQgcHJvY2Vzc2luZyB3YXMgY2FuY2VsbGVkIGR1cmluZyBwZXJjZWl2ZWQgcHJvY2Vzc29yIHRpbWUgc3RvcmUgZmlsZSByZWZlcmVuY2VcbiAgICAgICAgc3RhdGUudHJhbnNmZXJJZCA9IG51bGw7XG4gICAgICAgIHN0YXRlLnNlcnZlckZpbGVSZWZlcmVuY2UgPSBzZXJ2ZXJGaWxlUmVmZXJlbmNlO1xuXG4gICAgICAgIHNldFN0YXR1cyhJdGVtU3RhdHVzLklETEUpO1xuICAgICAgICBmaXJlKCdwcm9jZXNzLWFib3J0Jyk7XG5cbiAgICAgICAgLy8gaGFzIHRpbWVvdXQgc28gZG9lc24ndCBpbnRlcmZlcmUgd2l0aCByZW1vdmUgYWN0aW9uXG4gICAgICAgIGlmIChhYm9ydFByb2Nlc3NpbmdSZXF1ZXN0Q29tcGxldGUpIHtcbiAgICAgICAgICBhYm9ydFByb2Nlc3NpbmdSZXF1ZXN0Q29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHByb2Nlc3Nvci5vbigncHJvZ3Jlc3MnLCBmdW5jdGlvbihwcm9ncmVzcykge1xuICAgICAgICBmaXJlKCdwcm9jZXNzLXByb2dyZXNzJywgcHJvZ3Jlc3MpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIHdoZW4gc3VjY2Vzc2Z1bGx5IHRyYW5zZm9ybWVkXG4gICAgICB2YXIgc3VjY2VzcyA9IGZ1bmN0aW9uIHN1Y2Nlc3MoZmlsZSkge1xuICAgICAgICAvLyBpZiB3YXMgYXJjaGl2ZWQgaW4gdGhlIG1lYW4gdGltZSwgZG9uJ3QgcHJvY2Vzc1xuICAgICAgICBpZiAoc3RhdGUuYXJjaGl2ZWQpIHJldHVybjtcblxuICAgICAgICAvLyBwcm9jZXNzIGZpbGUhXG4gICAgICAgIHByb2Nlc3Nvci5wcm9jZXNzKGZpbGUsIE9iamVjdC5hc3NpZ24oe30sIG1ldGFkYXRhKSk7XG4gICAgICB9O1xuXG4gICAgICAvLyBzb21ldGhpbmcgd2VudCB3cm9uZyBkdXJpbmcgdHJhbnNmb3JtIHBoYXNlXG4gICAgICB2YXIgZXJyb3IgPSBjb25zb2xlLmVycm9yO1xuXG4gICAgICAvLyBzdGFydCBwcm9jZXNzaW5nIHRoZSBmaWxlXG4gICAgICBvbnByb2Nlc3Moc3RhdGUuZmlsZSwgc3VjY2VzcywgZXJyb3IpO1xuXG4gICAgICAvLyBzZXQgYXMgYWN0aXZlIHByb2Nlc3NvclxuICAgICAgc3RhdGUuYWN0aXZlUHJvY2Vzc29yID0gcHJvY2Vzc29yO1xuICAgIH07XG5cbiAgICB2YXIgcmVxdWVzdFByb2Nlc3NpbmcgPSBmdW5jdGlvbiByZXF1ZXN0UHJvY2Vzc2luZygpIHtcbiAgICAgIHN0YXRlLnByb2Nlc3NpbmdBYm9ydGVkID0gZmFsc2U7XG4gICAgICBzZXRTdGF0dXMoSXRlbVN0YXR1cy5QUk9DRVNTSU5HX1FVRVVFRCk7XG4gICAgfTtcblxuICAgIHZhciBhYm9ydFByb2Nlc3NpbmcgPSBmdW5jdGlvbiBhYm9ydFByb2Nlc3NpbmcoKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSkge1xuICAgICAgICBpZiAoIXN0YXRlLmFjdGl2ZVByb2Nlc3Nvcikge1xuICAgICAgICAgIHN0YXRlLnByb2Nlc3NpbmdBYm9ydGVkID0gdHJ1ZTtcblxuICAgICAgICAgIHNldFN0YXR1cyhJdGVtU3RhdHVzLklETEUpO1xuICAgICAgICAgIGZpcmUoJ3Byb2Nlc3MtYWJvcnQnKTtcblxuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBhYm9ydFByb2Nlc3NpbmdSZXF1ZXN0Q29tcGxldGUgPSBmdW5jdGlvbiBhYm9ydFByb2Nlc3NpbmdSZXF1ZXN0Q29tcGxldGUoKSB7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHN0YXRlLmFjdGl2ZVByb2Nlc3Nvci5hYm9ydCgpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vXG4gICAgLy8gbG9naWMgdG8gcmV2ZXJ0IGEgcHJvY2Vzc2VkIGZpbGVcbiAgICAvL1xuICAgIHZhciByZXZlcnQgPSBmdW5jdGlvbiByZXZlcnQocmV2ZXJ0RmlsZVVwbG9hZCwgZm9yY2VSZXZlcnQpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgLy8gY2Fubm90IHJldmVydCB3aXRob3V0IGEgc2VydmVyIGlkIGZvciB0aGlzIHByb2Nlc3NcbiAgICAgICAgaWYgKHN0YXRlLnNlcnZlckZpbGVSZWZlcmVuY2UgPT09IG51bGwpIHtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmV2ZXJ0IHRoZSB1cGxvYWQgKGZpcmUgYW5kIGZvcmdldClcbiAgICAgICAgcmV2ZXJ0RmlsZVVwbG9hZChcbiAgICAgICAgICBzdGF0ZS5zZXJ2ZXJGaWxlUmVmZXJlbmNlLFxuICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gcmVzZXQgZmlsZSBzZXJ2ZXIgaWQgYXMgbm93IGl0J3Mgbm8gYXZhaWxhYmxlIG9uIHRoZSBzZXJ2ZXJcbiAgICAgICAgICAgIHN0YXRlLnNlcnZlckZpbGVSZWZlcmVuY2UgPSBudWxsO1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIGRvbid0IHNldCBlcnJvciBzdGF0ZSB3aGVuIHJldmVydGluZyBpcyBvcHRpb25hbCwgaXQgd2lsbCBhbHdheXMgcmVzb2x2ZVxuICAgICAgICAgICAgaWYgKCFmb3JjZVJldmVydCkge1xuICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gb2ggbm8gZXJyb3JzXG4gICAgICAgICAgICBzZXRTdGF0dXMoSXRlbVN0YXR1cy5QUk9DRVNTSU5HX1JFVkVSVF9FUlJPUik7XG4gICAgICAgICAgICBmaXJlKCdwcm9jZXNzLXJldmVydC1lcnJvcicpO1xuICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gZmlyZSBldmVudFxuICAgICAgICBzZXRTdGF0dXMoSXRlbVN0YXR1cy5JRExFKTtcbiAgICAgICAgZmlyZSgncHJvY2Vzcy1yZXZlcnQnKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyBleHBvc2VkIG1ldGhvZHNcbiAgICB2YXIgX3NldE1ldGFkYXRhID0gZnVuY3Rpb24gc2V0TWV0YWRhdGEoa2V5LCB2YWx1ZSwgc2lsZW50KSB7XG4gICAgICB2YXIga2V5cyA9IGtleS5zcGxpdCgnLicpO1xuICAgICAgdmFyIHJvb3QgPSBrZXlzWzBdO1xuICAgICAgdmFyIGxhc3QgPSBrZXlzLnBvcCgpO1xuICAgICAgdmFyIGRhdGEgPSBtZXRhZGF0YTtcbiAgICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgcmV0dXJuIChkYXRhID0gZGF0YVtrZXldKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBjb21wYXJlIG9sZCB2YWx1ZSBhZ2FpbnN0IG5ldyB2YWx1ZSwgaWYgdGhleSdyZSB0aGUgc2FtZSwgd2UncmUgbm90IHVwZGF0aW5nXG4gICAgICBpZiAoSlNPTi5zdHJpbmdpZnkoZGF0YVtsYXN0XSkgPT09IEpTT04uc3RyaW5naWZ5KHZhbHVlKSkgcmV0dXJuO1xuXG4gICAgICAvLyB1cGRhdGUgdmFsdWVcbiAgICAgIGRhdGFbbGFzdF0gPSB2YWx1ZTtcblxuICAgICAgLy8gZG9uJ3QgZmlyZSB1cGRhdGVcbiAgICAgIGlmIChzaWxlbnQpIHJldHVybjtcblxuICAgICAgLy8gZmlyZSB1cGRhdGVcbiAgICAgIGZpcmUoJ21ldGFkYXRhLXVwZGF0ZScsIHtcbiAgICAgICAga2V5OiByb290LFxuICAgICAgICB2YWx1ZTogbWV0YWRhdGFbcm9vdF1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICB2YXIgZ2V0TWV0YWRhdGEgPSBmdW5jdGlvbiBnZXRNZXRhZGF0YShrZXkpIHtcbiAgICAgIHJldHVybiBkZWVwQ2xvbmVPYmplY3Qoa2V5ID8gbWV0YWRhdGFba2V5XSA6IG1ldGFkYXRhKTtcbiAgICB9O1xuXG4gICAgdmFyIGFwaSA9IE9iamVjdC5hc3NpZ24oXG4gICAgICB7XG4gICAgICAgIGlkOiB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gaWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvcmlnaW46IHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiBvcmlnaW47XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzZXJ2ZXJJZDoge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXRlLnNlcnZlckZpbGVSZWZlcmVuY2U7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB0cmFuc2ZlcklkOiB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhdGUudHJhbnNmZXJJZDtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHN0YXR1czoge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXRlLnN0YXR1cztcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGZpbGVuYW1lOiB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhdGUuZmlsZS5uYW1lO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZmlsZW5hbWVXaXRob3V0RXh0ZW5zaW9uOiB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0RmlsZW5hbWVXaXRob3V0RXh0ZW5zaW9uKHN0YXRlLmZpbGUubmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBmaWxlRXh0ZW5zaW9uOiB7IGdldDogZ2V0RmlsZUV4dGVuc2lvbiB9LFxuICAgICAgICBmaWxlVHlwZTogeyBnZXQ6IGdldEZpbGVUeXBlIH0sXG4gICAgICAgIGZpbGVTaXplOiB7IGdldDogZ2V0RmlsZVNpemUgfSxcbiAgICAgICAgZmlsZTogeyBnZXQ6IGdldEZpbGUgfSxcbiAgICAgICAgcmVsYXRpdmVQYXRoOiB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhdGUuZmlsZS5fcmVsYXRpdmVQYXRoO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBzb3VyY2U6IHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZS5zb3VyY2U7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGdldE1ldGFkYXRhOiBnZXRNZXRhZGF0YSxcbiAgICAgICAgc2V0TWV0YWRhdGE6IGZ1bmN0aW9uIHNldE1ldGFkYXRhKGtleSwgdmFsdWUsIHNpbGVudCkge1xuICAgICAgICAgIGlmIChpc09iamVjdChrZXkpKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IGtleTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGRhdGEpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgIF9zZXRNZXRhZGF0YShrZXksIGRhdGFba2V5XSwgdmFsdWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgICAgIH1cbiAgICAgICAgICBfc2V0TWV0YWRhdGEoa2V5LCB2YWx1ZSwgc2lsZW50KTtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZXh0ZW5kOiBmdW5jdGlvbiBleHRlbmQobmFtZSwgaGFuZGxlcikge1xuICAgICAgICAgIHJldHVybiAoaXRlbUFQSVtuYW1lXSA9IGhhbmRsZXIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGFib3J0TG9hZDogYWJvcnRMb2FkLFxuICAgICAgICByZXRyeUxvYWQ6IHJldHJ5TG9hZCxcbiAgICAgICAgcmVxdWVzdFByb2Nlc3Npbmc6IHJlcXVlc3RQcm9jZXNzaW5nLFxuICAgICAgICBhYm9ydFByb2Nlc3Npbmc6IGFib3J0UHJvY2Vzc2luZyxcblxuICAgICAgICBsb2FkOiBsb2FkLFxuICAgICAgICBwcm9jZXNzOiBwcm9jZXNzLFxuICAgICAgICByZXZlcnQ6IHJldmVydFxuICAgICAgfSxcblxuICAgICAgb24oKSxcbiAgICAgIHtcbiAgICAgICAgZnJlZXplOiBmdW5jdGlvbiBmcmVlemUoKSB7XG4gICAgICAgICAgcmV0dXJuIChzdGF0ZS5mcm96ZW4gPSB0cnVlKTtcbiAgICAgICAgfSxcblxuICAgICAgICByZWxlYXNlOiBmdW5jdGlvbiByZWxlYXNlKCkge1xuICAgICAgICAgIHJldHVybiAoc3RhdGUucmVsZWFzZWQgPSB0cnVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVsZWFzZWQ6IHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZS5yZWxlYXNlZDtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgYXJjaGl2ZTogZnVuY3Rpb24gYXJjaGl2ZSgpIHtcbiAgICAgICAgICByZXR1cm4gKHN0YXRlLmFyY2hpdmVkID0gdHJ1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGFyY2hpdmVkOiB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhdGUuYXJjaGl2ZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgKTtcblxuICAgIC8vIGNyZWF0ZSBpdCBoZXJlIGluc3RlYWQgb2YgcmV0dXJuaW5nIGl0IGluc3RhbnRseSBzbyB3ZSBjYW4gZXh0ZW5kIGl0IGxhdGVyXG4gICAgdmFyIGl0ZW1BUEkgPSBjcmVhdGVPYmplY3QoYXBpKTtcblxuICAgIHJldHVybiBpdGVtQVBJO1xuICB9O1xuXG4gIHZhciBnZXRJdGVtSW5kZXhCeVF1ZXJ5ID0gZnVuY3Rpb24gZ2V0SXRlbUluZGV4QnlRdWVyeShpdGVtcywgcXVlcnkpIHtcbiAgICAvLyBqdXN0IHJldHVybiBmaXJzdCBpbmRleFxuICAgIGlmIChpc0VtcHR5KHF1ZXJ5KSkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgLy8gaW52YWxpZCBxdWVyaWVzXG4gICAgaWYgKCFpc1N0cmluZyhxdWVyeSkpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICAvLyByZXR1cm4gaXRlbSBieSBpZCAob3IgLTEgaWYgbm90IGZvdW5kKVxuICAgIHJldHVybiBpdGVtcy5maW5kSW5kZXgoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgcmV0dXJuIGl0ZW0uaWQgPT09IHF1ZXJ5O1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciBnZXRJdGVtQnlJZCA9IGZ1bmN0aW9uIGdldEl0ZW1CeUlkKGl0ZW1zLCBpdGVtSWQpIHtcbiAgICB2YXIgaW5kZXggPSBnZXRJdGVtSW5kZXhCeVF1ZXJ5KGl0ZW1zLCBpdGVtSWQpO1xuICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIGl0ZW1zW2luZGV4XSB8fCBudWxsO1xuICB9O1xuXG4gIHZhciBmZXRjaEJsb2IgPSBmdW5jdGlvbiBmZXRjaEJsb2IoXG4gICAgdXJsLFxuICAgIGxvYWQsXG4gICAgZXJyb3IsXG4gICAgcHJvZ3Jlc3MsXG4gICAgYWJvcnQsXG4gICAgaGVhZGVyc1xuICApIHtcbiAgICB2YXIgcmVxdWVzdCA9IHNlbmRSZXF1ZXN0KG51bGwsIHVybCwge1xuICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgIHJlc3BvbnNlVHlwZTogJ2Jsb2InXG4gICAgfSk7XG5cbiAgICByZXF1ZXN0Lm9ubG9hZCA9IGZ1bmN0aW9uKHhocikge1xuICAgICAgLy8gZ2V0IGhlYWRlcnNcbiAgICAgIHZhciBoZWFkZXJzID0geGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpO1xuXG4gICAgICAvLyBnZXQgZmlsZW5hbWVcbiAgICAgIHZhciBmaWxlbmFtZSA9XG4gICAgICAgIGdldEZpbGVJbmZvRnJvbUhlYWRlcnMoaGVhZGVycykubmFtZSB8fCBnZXRGaWxlbmFtZUZyb21VUkwodXJsKTtcblxuICAgICAgLy8gY3JlYXRlIHJlc3BvbnNlXG4gICAgICBsb2FkKFxuICAgICAgICBjcmVhdGVSZXNwb25zZShcbiAgICAgICAgICAnbG9hZCcsXG4gICAgICAgICAgeGhyLnN0YXR1cyxcbiAgICAgICAgICBnZXRGaWxlRnJvbUJsb2IoeGhyLnJlc3BvbnNlLCBmaWxlbmFtZSksXG4gICAgICAgICAgaGVhZGVyc1xuICAgICAgICApXG4gICAgICApO1xuICAgIH07XG5cbiAgICByZXF1ZXN0Lm9uZXJyb3IgPSBmdW5jdGlvbih4aHIpIHtcbiAgICAgIGVycm9yKFxuICAgICAgICBjcmVhdGVSZXNwb25zZShcbiAgICAgICAgICAnZXJyb3InLFxuICAgICAgICAgIHhoci5zdGF0dXMsXG4gICAgICAgICAgeGhyLnN0YXR1c1RleHQsXG4gICAgICAgICAgeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfTtcblxuICAgIHJlcXVlc3Qub25oZWFkZXJzID0gZnVuY3Rpb24oeGhyKSB7XG4gICAgICBoZWFkZXJzKFxuICAgICAgICBjcmVhdGVSZXNwb25zZSgnaGVhZGVycycsIHhoci5zdGF0dXMsIG51bGwsIHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSlcbiAgICAgICk7XG4gICAgfTtcblxuICAgIHJlcXVlc3Qub250aW1lb3V0ID0gY3JlYXRlVGltZW91dFJlc3BvbnNlKGVycm9yKTtcbiAgICByZXF1ZXN0Lm9ucHJvZ3Jlc3MgPSBwcm9ncmVzcztcbiAgICByZXF1ZXN0Lm9uYWJvcnQgPSBhYm9ydDtcblxuICAgIC8vIHNob3VsZCByZXR1cm4gcmVxdWVzdFxuICAgIHJldHVybiByZXF1ZXN0O1xuICB9O1xuXG4gIHZhciBnZXREb21haW5Gcm9tVVJMID0gZnVuY3Rpb24gZ2V0RG9tYWluRnJvbVVSTCh1cmwpIHtcbiAgICBpZiAodXJsLmluZGV4T2YoJy8vJykgPT09IDApIHtcbiAgICAgIHVybCA9IGxvY2F0aW9uLnByb3RvY29sICsgdXJsO1xuICAgIH1cbiAgICByZXR1cm4gdXJsXG4gICAgICAudG9Mb3dlckNhc2UoKVxuICAgICAgLnJlcGxhY2UoJ2Jsb2I6JywgJycpXG4gICAgICAucmVwbGFjZSgvKFthLXpdKT86XFwvXFwvLywgJyQxJylcbiAgICAgIC5zcGxpdCgnLycpWzBdO1xuICB9O1xuXG4gIHZhciBpc0V4dGVybmFsVVJMID0gZnVuY3Rpb24gaXNFeHRlcm5hbFVSTCh1cmwpIHtcbiAgICByZXR1cm4gKFxuICAgICAgKHVybC5pbmRleE9mKCc6JykgPiAtMSB8fCB1cmwuaW5kZXhPZignLy8nKSA+IC0xKSAmJlxuICAgICAgZ2V0RG9tYWluRnJvbVVSTChsb2NhdGlvbi5ocmVmKSAhPT0gZ2V0RG9tYWluRnJvbVVSTCh1cmwpXG4gICAgKTtcbiAgfTtcblxuICB2YXIgZHluYW1pY0xhYmVsID0gZnVuY3Rpb24gZHluYW1pY0xhYmVsKGxhYmVsKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGlzRnVuY3Rpb24obGFiZWwpID8gbGFiZWwuYXBwbHkodm9pZCAwLCBhcmd1bWVudHMpIDogbGFiZWw7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgaXNNb2NrSXRlbSA9IGZ1bmN0aW9uIGlzTW9ja0l0ZW0oaXRlbSkge1xuICAgIHJldHVybiAhaXNGaWxlKGl0ZW0uZmlsZSk7XG4gIH07XG5cbiAgdmFyIGxpc3RVcGRhdGVkID0gZnVuY3Rpb24gbGlzdFVwZGF0ZWQoZGlzcGF0Y2gsIHN0YXRlKSB7XG4gICAgY2xlYXJUaW1lb3V0KHN0YXRlLmxpc3RVcGRhdGVUaW1lb3V0KTtcbiAgICBzdGF0ZS5saXN0VXBkYXRlVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBkaXNwYXRjaCgnRElEX1VQREFURV9JVEVNUycsIHsgaXRlbXM6IGdldEFjdGl2ZUl0ZW1zKHN0YXRlLml0ZW1zKSB9KTtcbiAgICB9LCAwKTtcbiAgfTtcblxuICB2YXIgb3B0aW9uYWxQcm9taXNlID0gZnVuY3Rpb24gb3B0aW9uYWxQcm9taXNlKGZuKSB7XG4gICAgZm9yIChcbiAgICAgIHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCxcbiAgICAgICAgcGFyYW1zID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSxcbiAgICAgICAgX2tleSA9IDE7XG4gICAgICBfa2V5IDwgX2xlbjtcbiAgICAgIF9rZXkrK1xuICAgICkge1xuICAgICAgcGFyYW1zW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICAgIGlmICghZm4pIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmUodHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciByZXN1bHQgPSBmbi5hcHBseSh2b2lkIDAsIHBhcmFtcyk7XG5cbiAgICAgIGlmIChyZXN1bHQgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZSh0cnVlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiByZXN1bHQgPT09ICdib29sZWFuJykge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHJlc3VsdC50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJlc3VsdC50aGVuKHJlc29sdmUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIHZhciBzb3J0SXRlbXMgPSBmdW5jdGlvbiBzb3J0SXRlbXMoc3RhdGUsIGNvbXBhcmUpIHtcbiAgICBzdGF0ZS5pdGVtcy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgIHJldHVybiBjb21wYXJlKGNyZWF0ZUl0ZW1BUEkoYSksIGNyZWF0ZUl0ZW1BUEkoYikpO1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIHJldHVybnMgaXRlbSBiYXNlZCBvbiBzdGF0ZVxuICB2YXIgZ2V0SXRlbUJ5UXVlcnlGcm9tU3RhdGUgPSBmdW5jdGlvbiBnZXRJdGVtQnlRdWVyeUZyb21TdGF0ZShcbiAgICBzdGF0ZSxcbiAgICBpdGVtSGFuZGxlclxuICApIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgX3JlZiA9XG4gICAgICAgIGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgICB2YXIgcXVlcnkgPSBfcmVmLnF1ZXJ5LFxuICAgICAgICBfcmVmJHN1Y2Nlc3MgPSBfcmVmLnN1Y2Nlc3MsXG4gICAgICAgIHN1Y2Nlc3MgPSBfcmVmJHN1Y2Nlc3MgPT09IHZvaWQgMCA/IGZ1bmN0aW9uKCkge30gOiBfcmVmJHN1Y2Nlc3MsXG4gICAgICAgIF9yZWYkZmFpbHVyZSA9IF9yZWYuZmFpbHVyZSxcbiAgICAgICAgZmFpbHVyZSA9IF9yZWYkZmFpbHVyZSA9PT0gdm9pZCAwID8gZnVuY3Rpb24oKSB7fSA6IF9yZWYkZmFpbHVyZSxcbiAgICAgICAgb3B0aW9ucyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbXG4gICAgICAgICAgJ3F1ZXJ5JyxcbiAgICAgICAgICAnc3VjY2VzcycsXG4gICAgICAgICAgJ2ZhaWx1cmUnXG4gICAgICAgIF0pO1xuICAgICAgdmFyIGl0ZW0gPSBnZXRJdGVtQnlRdWVyeShzdGF0ZS5pdGVtcywgcXVlcnkpO1xuICAgICAgaWYgKCFpdGVtKSB7XG4gICAgICAgIGZhaWx1cmUoe1xuICAgICAgICAgIGVycm9yOiBjcmVhdGVSZXNwb25zZSgnZXJyb3InLCAwLCAnSXRlbSBub3QgZm91bmQnKSxcblxuICAgICAgICAgIGZpbGU6IG51bGxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaXRlbUhhbmRsZXIoaXRlbSwgc3VjY2VzcywgZmFpbHVyZSwgb3B0aW9ucyB8fCB7fSk7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgYWN0aW9ucyA9IGZ1bmN0aW9uIGFjdGlvbnMoZGlzcGF0Y2gsIHF1ZXJ5LCBzdGF0ZSkge1xuICAgIHJldHVybiB7XG4gICAgICAvKipcbiAgICAgICAqIEFib3J0cyBhbGwgb25nb2luZyBwcm9jZXNzZXNcbiAgICAgICAqL1xuICAgICAgQUJPUlRfQUxMOiBmdW5jdGlvbiBBQk9SVF9BTEwoKSB7XG4gICAgICAgIGdldEFjdGl2ZUl0ZW1zKHN0YXRlLml0ZW1zKS5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICBpdGVtLmZyZWV6ZSgpO1xuICAgICAgICAgIGl0ZW0uYWJvcnRMb2FkKCk7XG4gICAgICAgICAgaXRlbS5hYm9ydFByb2Nlc3NpbmcoKTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFNldHMgaW5pdGlhbCBmaWxlc1xuICAgICAgICovXG4gICAgICBESURfU0VUX0ZJTEVTOiBmdW5jdGlvbiBESURfU0VUX0ZJTEVTKF9yZWYyKSB7XG4gICAgICAgIHZhciBfcmVmMiR2YWx1ZSA9IF9yZWYyLnZhbHVlLFxuICAgICAgICAgIHZhbHVlID0gX3JlZjIkdmFsdWUgPT09IHZvaWQgMCA/IFtdIDogX3JlZjIkdmFsdWU7XG5cbiAgICAgICAgLy8gbWFwIHZhbHVlcyB0byBmaWxlIG9iamVjdHNcbiAgICAgICAgdmFyIGZpbGVzID0gdmFsdWUubWFwKGZ1bmN0aW9uKGZpbGUpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc291cmNlOiBmaWxlLnNvdXJjZSA/IGZpbGUuc291cmNlIDogZmlsZSxcbiAgICAgICAgICAgIG9wdGlvbnM6IGZpbGUub3B0aW9uc1xuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGxvb3Agb3ZlciBmaWxlcywgaWYgZmlsZSBpcyBpbiBsaXN0LCBsZWF2ZSBpdCBiZSwgaWYgbm90LCByZW1vdmVcbiAgICAgICAgLy8gdGVzdCBpZiBpdGVtcyBzaG91bGQgYmUgbW92ZWRcbiAgICAgICAgdmFyIGFjdGl2ZUl0ZW1zID0gZ2V0QWN0aXZlSXRlbXMoc3RhdGUuaXRlbXMpO1xuXG4gICAgICAgIGFjdGl2ZUl0ZW1zLmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgIC8vIGlmIGl0ZW0gbm90IGlzIGluIG5ldyB2YWx1ZSwgcmVtb3ZlXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgIWZpbGVzLmZpbmQoZnVuY3Rpb24oZmlsZSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmlsZS5zb3VyY2UgPT09IGl0ZW0uc291cmNlIHx8IGZpbGUuc291cmNlID09PSBpdGVtLmZpbGU7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgZGlzcGF0Y2goJ1JFTU9WRV9JVEVNJywgeyBxdWVyeTogaXRlbSwgcmVtb3ZlOiBmYWxzZSB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGFkZCBuZXcgZmlsZXNcbiAgICAgICAgYWN0aXZlSXRlbXMgPSBnZXRBY3RpdmVJdGVtcyhzdGF0ZS5pdGVtcyk7XG4gICAgICAgIGZpbGVzLmZvckVhY2goZnVuY3Rpb24oZmlsZSwgaW5kZXgpIHtcbiAgICAgICAgICAvLyBpZiBmaWxlIGlzIGFscmVhZHkgaW4gbGlzdFxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGFjdGl2ZUl0ZW1zLmZpbmQoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICByZXR1cm4gaXRlbS5zb3VyY2UgPT09IGZpbGUuc291cmNlIHx8IGl0ZW0uZmlsZSA9PT0gZmlsZS5zb3VyY2U7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgIClcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgIC8vIG5vdCBpbiBsaXN0LCBhZGRcbiAgICAgICAgICBkaXNwYXRjaChcbiAgICAgICAgICAgICdBRERfSVRFTScsXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHt9LCBmaWxlLCB7XG4gICAgICAgICAgICAgIGludGVyYWN0aW9uTWV0aG9kOiBJbnRlcmFjdGlvbk1ldGhvZC5OT05FLFxuICAgICAgICAgICAgICBpbmRleDogaW5kZXhcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuXG4gICAgICBESURfVVBEQVRFX0lURU1fTUVUQURBVEE6IGZ1bmN0aW9uIERJRF9VUERBVEVfSVRFTV9NRVRBREFUQShfcmVmMykge1xuICAgICAgICB2YXIgaWQgPSBfcmVmMy5pZDtcblxuICAgICAgICAvLyBpZiBpcyBjYWxsZWQgbXVsdGlwbGUgdGltZXMgaW4gY2xvc2Ugc3VjY2Vzc2lvbiB3ZSBjb21iaW5lZCBhbGwgY2FsbHMgdG9nZXRoZXIgdG8gc2F2ZSByZXNvdXJjZXNcbiAgICAgICAgY2xlYXJUaW1lb3V0KHN0YXRlLml0ZW1VcGRhdGVUaW1lb3V0KTtcbiAgICAgICAgc3RhdGUuaXRlbVVwZGF0ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBpdGVtID0gZ2V0SXRlbUJ5SWQoc3RhdGUuaXRlbXMsIGlkKTtcblxuICAgICAgICAgIC8vIG9ubHkgcmV2ZXJ0IGFuZCBhdHRlbXB0IHRvIHVwbG9hZCB3aGVuIHdlJ3JlIHVwbG9hZGluZyB0byBhIHNlcnZlclxuICAgICAgICAgIGlmICghcXVlcnkoJ0lTX0FTWU5DJykpIHtcbiAgICAgICAgICAgIC8vIHNob3VsZCB3ZSB1cGRhdGUgdGhlIG91dHB1dCBkYXRhXG4gICAgICAgICAgICBhcHBseUZpbHRlckNoYWluKCdTSE9VTERfUFJFUEFSRV9PVVRQVVQnLCBmYWxzZSwge1xuICAgICAgICAgICAgICBpdGVtOiBpdGVtLFxuICAgICAgICAgICAgICBxdWVyeTogcXVlcnlcbiAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24oc2hvdWxkUHJlcGFyZU91dHB1dCkge1xuICAgICAgICAgICAgICBpZiAoIXNob3VsZFByZXBhcmVPdXRwdXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGlzcGF0Y2goXG4gICAgICAgICAgICAgICAgJ1JFUVVFU1RfUFJFUEFSRV9PVVRQVVQnLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHF1ZXJ5OiBpZCxcbiAgICAgICAgICAgICAgICAgIGl0ZW06IGl0ZW0sXG4gICAgICAgICAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiBzdWNjZXNzKGZpbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goJ0RJRF9QUkVQQVJFX09VVFBVVCcsIHsgaWQ6IGlkLCBmaWxlOiBmaWxlIH0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBmb3IgYXN5bmMgc2NlbmFyaW9zXG4gICAgICAgICAgdmFyIHVwbG9hZCA9IGZ1bmN0aW9uIHVwbG9hZCgpIHtcbiAgICAgICAgICAgIC8vIHdlIHB1c2ggdGhpcyBmb3J3YXJkIGEgYml0IHNvIHRoZSBpbnRlcmZhY2UgaXMgdXBkYXRlZCBjb3JyZWN0bHlcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIGRpc3BhdGNoKCdSRVFVRVNUX0lURU1fUFJPQ0VTU0lORycsIHsgcXVlcnk6IGlkIH0pO1xuICAgICAgICAgICAgfSwgMzIpO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICB2YXIgcmV2ZXJ0ID0gZnVuY3Rpb24gcmV2ZXJ0KGRvVXBsb2FkKSB7XG4gICAgICAgICAgICBpdGVtXG4gICAgICAgICAgICAgIC5yZXZlcnQoXG4gICAgICAgICAgICAgICAgY3JlYXRlUmV2ZXJ0RnVuY3Rpb24oXG4gICAgICAgICAgICAgICAgICBzdGF0ZS5vcHRpb25zLnNlcnZlci51cmwsXG4gICAgICAgICAgICAgICAgICBzdGF0ZS5vcHRpb25zLnNlcnZlci5yZXZlcnRcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIHF1ZXJ5KCdHRVRfRk9SQ0VfUkVWRVJUJylcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAudGhlbihkb1VwbG9hZCA/IHVwbG9hZCA6IGZ1bmN0aW9uKCkge30pXG4gICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbigpIHt9KTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgdmFyIGFib3J0ID0gZnVuY3Rpb24gYWJvcnQoZG9VcGxvYWQpIHtcbiAgICAgICAgICAgIGl0ZW0uYWJvcnRQcm9jZXNzaW5nKCkudGhlbihkb1VwbG9hZCA/IHVwbG9hZCA6IGZ1bmN0aW9uKCkge30pO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICAvLyBpZiB3ZSBzaG91bGQgcmUtdXBsb2FkIHRoZSBmaWxlIGltbWVkaWF0ZWx5XG4gICAgICAgICAgaWYgKGl0ZW0uc3RhdHVzID09PSBJdGVtU3RhdHVzLlBST0NFU1NJTkdfQ09NUExFVEUpIHtcbiAgICAgICAgICAgIHJldHVybiByZXZlcnQoc3RhdGUub3B0aW9ucy5pbnN0YW50VXBsb2FkKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBpZiBjdXJyZW50bHkgdXBsb2FkaW5nLCBjYW5jZWwgdXBsb2FkXG4gICAgICAgICAgaWYgKGl0ZW0uc3RhdHVzID09PSBJdGVtU3RhdHVzLlBST0NFU1NJTkcpIHtcbiAgICAgICAgICAgIHJldHVybiBhYm9ydChzdGF0ZS5vcHRpb25zLmluc3RhbnRVcGxvYWQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzdGF0ZS5vcHRpb25zLmluc3RhbnRVcGxvYWQpIHtcbiAgICAgICAgICAgIHVwbG9hZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgMCk7XG4gICAgICB9LFxuXG4gICAgICBNT1ZFX0lURU06IGZ1bmN0aW9uIE1PVkVfSVRFTShfcmVmNCkge1xuICAgICAgICB2YXIgcXVlcnkgPSBfcmVmNC5xdWVyeSxcbiAgICAgICAgICBpbmRleCA9IF9yZWY0LmluZGV4O1xuICAgICAgICB2YXIgaXRlbSA9IGdldEl0ZW1CeVF1ZXJ5KHN0YXRlLml0ZW1zLCBxdWVyeSk7XG4gICAgICAgIGlmICghaXRlbSkgcmV0dXJuO1xuICAgICAgICB2YXIgY3VycmVudEluZGV4ID0gc3RhdGUuaXRlbXMuaW5kZXhPZihpdGVtKTtcbiAgICAgICAgaW5kZXggPSBsaW1pdChpbmRleCwgMCwgc3RhdGUuaXRlbXMubGVuZ3RoIC0gMSk7XG4gICAgICAgIGlmIChjdXJyZW50SW5kZXggPT09IGluZGV4KSByZXR1cm47XG4gICAgICAgIHN0YXRlLml0ZW1zLnNwbGljZShpbmRleCwgMCwgc3RhdGUuaXRlbXMuc3BsaWNlKGN1cnJlbnRJbmRleCwgMSlbMF0pO1xuICAgICAgfSxcblxuICAgICAgU09SVDogZnVuY3Rpb24gU09SVChfcmVmNSkge1xuICAgICAgICB2YXIgY29tcGFyZSA9IF9yZWY1LmNvbXBhcmU7XG4gICAgICAgIHNvcnRJdGVtcyhzdGF0ZSwgY29tcGFyZSk7XG4gICAgICAgIGRpc3BhdGNoKCdESURfU09SVF9JVEVNUycsIHtcbiAgICAgICAgICBpdGVtczogcXVlcnkoJ0dFVF9BQ1RJVkVfSVRFTVMnKVxuICAgICAgICB9KTtcbiAgICAgIH0sXG5cbiAgICAgIEFERF9JVEVNUzogZnVuY3Rpb24gQUREX0lURU1TKF9yZWY2KSB7XG4gICAgICAgIHZhciBpdGVtcyA9IF9yZWY2Lml0ZW1zLFxuICAgICAgICAgIGluZGV4ID0gX3JlZjYuaW5kZXgsXG4gICAgICAgICAgaW50ZXJhY3Rpb25NZXRob2QgPSBfcmVmNi5pbnRlcmFjdGlvbk1ldGhvZCxcbiAgICAgICAgICBfcmVmNiRzdWNjZXNzID0gX3JlZjYuc3VjY2VzcyxcbiAgICAgICAgICBzdWNjZXNzID0gX3JlZjYkc3VjY2VzcyA9PT0gdm9pZCAwID8gZnVuY3Rpb24oKSB7fSA6IF9yZWY2JHN1Y2Nlc3MsXG4gICAgICAgICAgX3JlZjYkZmFpbHVyZSA9IF9yZWY2LmZhaWx1cmUsXG4gICAgICAgICAgZmFpbHVyZSA9IF9yZWY2JGZhaWx1cmUgPT09IHZvaWQgMCA/IGZ1bmN0aW9uKCkge30gOiBfcmVmNiRmYWlsdXJlO1xuXG4gICAgICAgIHZhciBjdXJyZW50SW5kZXggPSBpbmRleDtcblxuICAgICAgICBpZiAoaW5kZXggPT09IC0xIHx8IHR5cGVvZiBpbmRleCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB2YXIgaW5zZXJ0TG9jYXRpb24gPSBxdWVyeSgnR0VUX0lURU1fSU5TRVJUX0xPQ0FUSU9OJyk7XG4gICAgICAgICAgdmFyIHRvdGFsSXRlbXMgPSBxdWVyeSgnR0VUX1RPVEFMX0lURU1TJyk7XG4gICAgICAgICAgY3VycmVudEluZGV4ID0gaW5zZXJ0TG9jYXRpb24gPT09ICdiZWZvcmUnID8gMCA6IHRvdGFsSXRlbXM7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaWdub3JlZEZpbGVzID0gcXVlcnkoJ0dFVF9JR05PUkVEX0ZJTEVTJyk7XG4gICAgICAgIHZhciBpc1ZhbGlkRmlsZSA9IGZ1bmN0aW9uIGlzVmFsaWRGaWxlKHNvdXJjZSkge1xuICAgICAgICAgIHJldHVybiBpc0ZpbGUoc291cmNlKVxuICAgICAgICAgICAgPyAhaWdub3JlZEZpbGVzLmluY2x1ZGVzKHNvdXJjZS5uYW1lLnRvTG93ZXJDYXNlKCkpXG4gICAgICAgICAgICA6ICFpc0VtcHR5KHNvdXJjZSk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciB2YWxpZEl0ZW1zID0gaXRlbXMuZmlsdGVyKGlzVmFsaWRGaWxlKTtcblxuICAgICAgICB2YXIgcHJvbWlzZXMgPSB2YWxpZEl0ZW1zLm1hcChmdW5jdGlvbihzb3VyY2UpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBkaXNwYXRjaCgnQUREX0lURU0nLCB7XG4gICAgICAgICAgICAgIGludGVyYWN0aW9uTWV0aG9kOiBpbnRlcmFjdGlvbk1ldGhvZCxcbiAgICAgICAgICAgICAgc291cmNlOiBzb3VyY2Uuc291cmNlIHx8IHNvdXJjZSxcbiAgICAgICAgICAgICAgc3VjY2VzczogcmVzb2x2ZSxcbiAgICAgICAgICAgICAgZmFpbHVyZTogcmVqZWN0LFxuICAgICAgICAgICAgICBpbmRleDogY3VycmVudEluZGV4KyssXG4gICAgICAgICAgICAgIG9wdGlvbnM6IHNvdXJjZS5vcHRpb25zIHx8IHt9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgUHJvbWlzZS5hbGwocHJvbWlzZXMpXG4gICAgICAgICAgLnRoZW4oc3VjY2VzcylcbiAgICAgICAgICAuY2F0Y2goZmFpbHVyZSk7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSBzb3VyY2VcbiAgICAgICAqIEBwYXJhbSBpbmRleFxuICAgICAgICogQHBhcmFtIGludGVyYWN0aW9uTWV0aG9kXG4gICAgICAgKi9cbiAgICAgIEFERF9JVEVNOiBmdW5jdGlvbiBBRERfSVRFTShfcmVmNykge1xuICAgICAgICB2YXIgc291cmNlID0gX3JlZjcuc291cmNlLFxuICAgICAgICAgIF9yZWY3JGluZGV4ID0gX3JlZjcuaW5kZXgsXG4gICAgICAgICAgaW5kZXggPSBfcmVmNyRpbmRleCA9PT0gdm9pZCAwID8gLTEgOiBfcmVmNyRpbmRleCxcbiAgICAgICAgICBpbnRlcmFjdGlvbk1ldGhvZCA9IF9yZWY3LmludGVyYWN0aW9uTWV0aG9kLFxuICAgICAgICAgIF9yZWY3JHN1Y2Nlc3MgPSBfcmVmNy5zdWNjZXNzLFxuICAgICAgICAgIHN1Y2Nlc3MgPSBfcmVmNyRzdWNjZXNzID09PSB2b2lkIDAgPyBmdW5jdGlvbigpIHt9IDogX3JlZjckc3VjY2VzcyxcbiAgICAgICAgICBfcmVmNyRmYWlsdXJlID0gX3JlZjcuZmFpbHVyZSxcbiAgICAgICAgICBmYWlsdXJlID0gX3JlZjckZmFpbHVyZSA9PT0gdm9pZCAwID8gZnVuY3Rpb24oKSB7fSA6IF9yZWY3JGZhaWx1cmUsXG4gICAgICAgICAgX3JlZjckb3B0aW9ucyA9IF9yZWY3Lm9wdGlvbnMsXG4gICAgICAgICAgb3B0aW9ucyA9IF9yZWY3JG9wdGlvbnMgPT09IHZvaWQgMCA/IHt9IDogX3JlZjckb3B0aW9ucztcblxuICAgICAgICAvLyBpZiBubyBzb3VyY2Ugc3VwcGxpZWRcbiAgICAgICAgaWYgKGlzRW1wdHkoc291cmNlKSkge1xuICAgICAgICAgIGZhaWx1cmUoe1xuICAgICAgICAgICAgZXJyb3I6IGNyZWF0ZVJlc3BvbnNlKCdlcnJvcicsIDAsICdObyBzb3VyY2UnKSxcblxuICAgICAgICAgICAgZmlsZTogbnVsbFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmlsdGVyIG91dCBpbnZhbGlkIGZpbGUgaXRlbXMsIHVzZWQgdG8gZmlsdGVyIGRyb3BwZWQgZGlyZWN0b3J5IGNvbnRlbnRzXG4gICAgICAgIGlmIChcbiAgICAgICAgICBpc0ZpbGUoc291cmNlKSAmJlxuICAgICAgICAgIHN0YXRlLm9wdGlvbnMuaWdub3JlZEZpbGVzLmluY2x1ZGVzKHNvdXJjZS5uYW1lLnRvTG93ZXJDYXNlKCkpXG4gICAgICAgICkge1xuICAgICAgICAgIC8vIGZhaWwgc2lsZW50bHlcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0ZXN0IGlmIHRoZXJlJ3Mgc3RpbGwgcm9vbSBpbiB0aGUgbGlzdCBvZiBmaWxlc1xuICAgICAgICBpZiAoIWhhc1Jvb21Gb3JJdGVtKHN0YXRlKSkge1xuICAgICAgICAgIC8vIGlmIG11bHRpcGxlIGFsbG93ZWQsIHdlIGNhbid0IHJlcGxhY2VcbiAgICAgICAgICAvLyBvciBpZiBvbmx5IGEgc2luZ2xlIGl0ZW0gaXMgYWxsb3dlZCBidXQgd2UncmUgbm90IGFsbG93ZWQgdG8gcmVwbGFjZSBpdCB3ZSBleGl0XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgc3RhdGUub3B0aW9ucy5hbGxvd011bHRpcGxlIHx8XG4gICAgICAgICAgICAoIXN0YXRlLm9wdGlvbnMuYWxsb3dNdWx0aXBsZSAmJiAhc3RhdGUub3B0aW9ucy5hbGxvd1JlcGxhY2UpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB2YXIgZXJyb3IgPSBjcmVhdGVSZXNwb25zZSgnd2FybmluZycsIDAsICdNYXggZmlsZXMnKTtcblxuICAgICAgICAgICAgZGlzcGF0Y2goJ0RJRF9USFJPV19NQVhfRklMRVMnLCB7XG4gICAgICAgICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICAgICAgICBlcnJvcjogZXJyb3JcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBmYWlsdXJlKHsgZXJyb3I6IGVycm9yLCBmaWxlOiBudWxsIH0pO1xuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gbGV0J3MgcmVwbGFjZSB0aGUgaXRlbVxuICAgICAgICAgIC8vIGlkIG9mIGZpcnN0IGl0ZW0gd2UncmUgYWJvdXQgdG8gcmVtb3ZlXG4gICAgICAgICAgdmFyIF9pdGVtID0gZ2V0QWN0aXZlSXRlbXMoc3RhdGUuaXRlbXMpWzBdO1xuXG4gICAgICAgICAgLy8gaWYgaGFzIGJlZW4gcHJvY2Vzc2VkIHJlbW92ZSBpdCBmcm9tIHRoZSBzZXJ2ZXIgYXMgd2VsbFxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIF9pdGVtLnN0YXR1cyA9PT0gSXRlbVN0YXR1cy5QUk9DRVNTSU5HX0NPTVBMRVRFIHx8XG4gICAgICAgICAgICBfaXRlbS5zdGF0dXMgPT09IEl0ZW1TdGF0dXMuUFJPQ0VTU0lOR19SRVZFUlRfRVJST1JcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHZhciBmb3JjZVJldmVydCA9IHF1ZXJ5KCdHRVRfRk9SQ0VfUkVWRVJUJyk7XG4gICAgICAgICAgICBfaXRlbVxuICAgICAgICAgICAgICAucmV2ZXJ0KFxuICAgICAgICAgICAgICAgIGNyZWF0ZVJldmVydEZ1bmN0aW9uKFxuICAgICAgICAgICAgICAgICAgc3RhdGUub3B0aW9ucy5zZXJ2ZXIudXJsLFxuICAgICAgICAgICAgICAgICAgc3RhdGUub3B0aW9ucy5zZXJ2ZXIucmV2ZXJ0XG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBmb3JjZVJldmVydFxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmICghZm9yY2VSZXZlcnQpIHJldHVybjtcblxuICAgICAgICAgICAgICAgIC8vIHRyeSB0byBhZGQgbm93XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2goJ0FERF9JVEVNJywge1xuICAgICAgICAgICAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgICAgICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgICAgICAgICAgICBpbnRlcmFjdGlvbk1ldGhvZDogaW50ZXJhY3Rpb25NZXRob2QsXG4gICAgICAgICAgICAgICAgICBzdWNjZXNzOiBzdWNjZXNzLFxuICAgICAgICAgICAgICAgICAgZmFpbHVyZTogZmFpbHVyZSxcbiAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uKCkge30pOyAvLyBubyBuZWVkIHRvIGhhbmRsZSB0aGlzIGNhdGNoIHN0YXRlIGZvciBub3dcblxuICAgICAgICAgICAgaWYgKGZvcmNlUmV2ZXJ0KSByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gcmVtb3ZlIGZpcnN0IGl0ZW0gYXMgaXQgd2lsbCBiZSByZXBsYWNlZCBieSB0aGlzIGl0ZW1cbiAgICAgICAgICBkaXNwYXRjaCgnUkVNT1ZFX0lURU0nLCB7IHF1ZXJ5OiBfaXRlbS5pZCB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHdoZXJlIGRpZCB0aGUgZmlsZSBvcmlnaW5hdGVcbiAgICAgICAgdmFyIG9yaWdpbiA9XG4gICAgICAgICAgb3B0aW9ucy50eXBlID09PSAnbG9jYWwnXG4gICAgICAgICAgICA/IEZpbGVPcmlnaW4uTE9DQUxcbiAgICAgICAgICAgIDogb3B0aW9ucy50eXBlID09PSAnbGltYm8nXG4gICAgICAgICAgICA/IEZpbGVPcmlnaW4uTElNQk9cbiAgICAgICAgICAgIDogRmlsZU9yaWdpbi5JTlBVVDtcblxuICAgICAgICAvLyBjcmVhdGUgYSBuZXcgYmxhbmsgaXRlbVxuICAgICAgICB2YXIgaXRlbSA9IGNyZWF0ZUl0ZW0oXG4gICAgICAgICAgLy8gd2hlcmUgZGlkIHRoaXMgZmlsZSBjb21lIGZyb21cbiAgICAgICAgICBvcmlnaW4sXG5cbiAgICAgICAgICAvLyBhbiBpbnB1dCBmaWxlIG5ldmVyIGhhcyBhIHNlcnZlciBmaWxlIHJlZmVyZW5jZVxuICAgICAgICAgIG9yaWdpbiA9PT0gRmlsZU9yaWdpbi5JTlBVVCA/IG51bGwgOiBzb3VyY2UsXG5cbiAgICAgICAgICAvLyBmaWxlIG1vY2sgZGF0YSwgaWYgZGVmaW5lZFxuICAgICAgICAgIG9wdGlvbnMuZmlsZVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIHNldCBpbml0aWFsIG1ldGEgZGF0YVxuICAgICAgICBPYmplY3Qua2V5cyhvcHRpb25zLm1ldGFkYXRhIHx8IHt9KS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgIGl0ZW0uc2V0TWV0YWRhdGEoa2V5LCBvcHRpb25zLm1ldGFkYXRhW2tleV0pO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBjcmVhdGVkIHRoZSBpdGVtLCBsZXQgcGx1Z2lucyBhZGQgbWV0aG9kc1xuICAgICAgICBhcHBseUZpbHRlcnMoJ0RJRF9DUkVBVEVfSVRFTScsIGl0ZW0sIHtcbiAgICAgICAgICBxdWVyeTogcXVlcnksXG4gICAgICAgICAgZGlzcGF0Y2g6IGRpc3BhdGNoXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHdoZXJlIHRvIGluc2VydCBuZXcgaXRlbXNcbiAgICAgICAgdmFyIGl0ZW1JbnNlcnRMb2NhdGlvbiA9IHF1ZXJ5KCdHRVRfSVRFTV9JTlNFUlRfTE9DQVRJT04nKTtcblxuICAgICAgICAvLyBhZGp1c3QgaW5kZXggaWYgaXMgbm90IGFsbG93ZWQgdG8gcGljayBsb2NhdGlvblxuICAgICAgICBpZiAoIXN0YXRlLm9wdGlvbnMuaXRlbUluc2VydExvY2F0aW9uRnJlZWRvbSkge1xuICAgICAgICAgIGluZGV4ID0gaXRlbUluc2VydExvY2F0aW9uID09PSAnYmVmb3JlJyA/IC0xIDogc3RhdGUuaXRlbXMubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRkIGl0ZW0gdG8gbGlzdFxuICAgICAgICBpbnNlcnRJdGVtKHN0YXRlLml0ZW1zLCBpdGVtLCBpbmRleCk7XG5cbiAgICAgICAgLy8gc29ydCBpdGVtcyBpbiBsaXN0XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKGl0ZW1JbnNlcnRMb2NhdGlvbikgJiYgc291cmNlKSB7XG4gICAgICAgICAgc29ydEl0ZW1zKHN0YXRlLCBpdGVtSW5zZXJ0TG9jYXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZ2V0IGEgcXVpY2sgcmVmZXJlbmNlIHRvIHRoZSBpdGVtIGlkXG4gICAgICAgIHZhciBpZCA9IGl0ZW0uaWQ7XG5cbiAgICAgICAgLy8gb2JzZXJ2ZSBpdGVtIGV2ZW50c1xuICAgICAgICBpdGVtLm9uKCdpbml0JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZGlzcGF0Y2goJ0RJRF9JTklUX0lURU0nLCB7IGlkOiBpZCB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXRlbS5vbignbG9hZC1pbml0JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZGlzcGF0Y2goJ0RJRF9TVEFSVF9JVEVNX0xPQUQnLCB7IGlkOiBpZCB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXRlbS5vbignbG9hZC1tZXRhJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZGlzcGF0Y2goJ0RJRF9VUERBVEVfSVRFTV9NRVRBJywgeyBpZDogaWQgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0ZW0ub24oJ2xvYWQtcHJvZ3Jlc3MnLCBmdW5jdGlvbihwcm9ncmVzcykge1xuICAgICAgICAgIGRpc3BhdGNoKCdESURfVVBEQVRFX0lURU1fTE9BRF9QUk9HUkVTUycsIHtcbiAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgIHByb2dyZXNzOiBwcm9ncmVzc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdGVtLm9uKCdsb2FkLXJlcXVlc3QtZXJyb3InLCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgIHZhciBtYWluU3RhdHVzID0gZHluYW1pY0xhYmVsKHN0YXRlLm9wdGlvbnMubGFiZWxGaWxlTG9hZEVycm9yKShcbiAgICAgICAgICAgIGVycm9yXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIC8vIGlzIGNsaWVudCBlcnJvciwgbm8gd2F5IHRvIHJlY292ZXJcbiAgICAgICAgICBpZiAoZXJyb3IuY29kZSA+PSA0MDAgJiYgZXJyb3IuY29kZSA8IDUwMCkge1xuICAgICAgICAgICAgZGlzcGF0Y2goJ0RJRF9USFJPV19JVEVNX0lOVkFMSUQnLCB7XG4gICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgICBzdGF0dXM6IHtcbiAgICAgICAgICAgICAgICBtYWluOiBtYWluU3RhdHVzLFxuICAgICAgICAgICAgICAgIHN1YjogZXJyb3IuY29kZSArICcgKCcgKyBlcnJvci5ib2R5ICsgJyknXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyByZWplY3QgdGhlIGZpbGUgc28gY2FuIGJlIGRlYWx0IHdpdGggdGhyb3VnaCBBUElcbiAgICAgICAgICAgIGZhaWx1cmUoeyBlcnJvcjogZXJyb3IsIGZpbGU6IGNyZWF0ZUl0ZW1BUEkoaXRlbSkgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gaXMgcG9zc2libGUgc2VydmVyIGVycm9yLCBzbyBtaWdodCBiZSBwb3NzaWJsZSB0byByZXRyeVxuICAgICAgICAgIGRpc3BhdGNoKCdESURfVEhST1dfSVRFTV9MT0FEX0VSUk9SJywge1xuICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgc3RhdHVzOiB7XG4gICAgICAgICAgICAgIG1haW46IG1haW5TdGF0dXMsXG4gICAgICAgICAgICAgIHN1Yjogc3RhdGUub3B0aW9ucy5sYWJlbFRhcFRvUmV0cnlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXRlbS5vbignbG9hZC1maWxlLWVycm9yJywgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICBkaXNwYXRjaCgnRElEX1RIUk9XX0lURU1fSU5WQUxJRCcsIHtcbiAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgIGVycm9yOiBlcnJvci5zdGF0dXMsXG4gICAgICAgICAgICBzdGF0dXM6IGVycm9yLnN0YXR1c1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgZmFpbHVyZSh7IGVycm9yOiBlcnJvci5zdGF0dXMsIGZpbGU6IGNyZWF0ZUl0ZW1BUEkoaXRlbSkgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0ZW0ub24oJ2xvYWQtYWJvcnQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICBkaXNwYXRjaCgnUkVNT1ZFX0lURU0nLCB7IHF1ZXJ5OiBpZCB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXRlbS5vbignbG9hZC1za2lwJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZGlzcGF0Y2goJ0NPTVBMRVRFX0xPQURfSVRFTScsIHtcbiAgICAgICAgICAgIHF1ZXJ5OiBpZCxcbiAgICAgICAgICAgIGl0ZW06IGl0ZW0sXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICAgICAgICBzdWNjZXNzOiBzdWNjZXNzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0ZW0ub24oJ2xvYWQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgaGFuZGxlQWRkID0gZnVuY3Rpb24gaGFuZGxlQWRkKHNob3VsZEFkZCkge1xuICAgICAgICAgICAgLy8gbm8gc2hvdWxkIG5vdCBhZGQgdGhpcyBmaWxlXG4gICAgICAgICAgICBpZiAoIXNob3VsZEFkZCkge1xuICAgICAgICAgICAgICBkaXNwYXRjaCgnUkVNT1ZFX0lURU0nLCB7XG4gICAgICAgICAgICAgICAgcXVlcnk6IGlkXG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gbm93IGludGVyZXN0ZWQgaW4gbWV0YWRhdGEgdXBkYXRlc1xuICAgICAgICAgICAgaXRlbS5vbignbWV0YWRhdGEtdXBkYXRlJywgZnVuY3Rpb24oY2hhbmdlKSB7XG4gICAgICAgICAgICAgIGRpc3BhdGNoKCdESURfVVBEQVRFX0lURU1fTUVUQURBVEEnLCB7IGlkOiBpZCwgY2hhbmdlOiBjaGFuZ2UgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gbGV0IHBsdWdpbnMgZGVjaWRlIGlmIHRoZSBvdXRwdXQgZGF0YSBzaG91bGQgYmUgcHJlcGFyZWQgYXQgdGhpcyBwb2ludFxuICAgICAgICAgICAgLy8gbWVhbnMgd2UnbGwgZG8gdGhpcyBhbmQgd2FpdCBmb3IgaWRsZSBzdGF0ZVxuICAgICAgICAgICAgYXBwbHlGaWx0ZXJDaGFpbignU0hPVUxEX1BSRVBBUkVfT1VUUFVUJywgZmFsc2UsIHtcbiAgICAgICAgICAgICAgaXRlbTogaXRlbSxcbiAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5XG4gICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKHNob3VsZFByZXBhcmVPdXRwdXQpIHtcbiAgICAgICAgICAgICAgdmFyIGxvYWRDb21wbGV0ZSA9IGZ1bmN0aW9uIGxvYWRDb21wbGV0ZSgpIHtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaCgnQ09NUExFVEVfTE9BRF9JVEVNJywge1xuICAgICAgICAgICAgICAgICAgcXVlcnk6IGlkLFxuICAgICAgICAgICAgICAgICAgaXRlbTogaXRlbSxcbiAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHN1Y2Nlc3NcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGxpc3RVcGRhdGVkKGRpc3BhdGNoLCBzdGF0ZSk7XG4gICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgLy8gZXhpdFxuICAgICAgICAgICAgICBpZiAoc2hvdWxkUHJlcGFyZU91dHB1dCkge1xuICAgICAgICAgICAgICAgIC8vIHdhaXQgZm9yIGlkbGUgc3RhdGUgYW5kIHRoZW4gcnVuIFBSRVBBUkVfT1VUUFVUXG4gICAgICAgICAgICAgICAgZGlzcGF0Y2goXG4gICAgICAgICAgICAgICAgICAnUkVRVUVTVF9QUkVQQVJFX09VVFBVVCcsXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiBpZCxcbiAgICAgICAgICAgICAgICAgICAgaXRlbTogaXRlbSxcbiAgICAgICAgICAgICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24gc3VjY2VzcyhmaWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goJ0RJRF9QUkVQQVJFX09VVFBVVCcsIHsgaWQ6IGlkLCBmaWxlOiBmaWxlIH0pO1xuICAgICAgICAgICAgICAgICAgICAgIGxvYWRDb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBsb2FkQ29tcGxldGUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICAvLyBpdGVtIGxvYWRlZCwgYWxsb3cgcGx1Z2lucyB0b1xuICAgICAgICAgIC8vIC0gcmVhZCBkYXRhIChxdWlja2x5KVxuICAgICAgICAgIC8vIC0gYWRkIG1ldGFkYXRhXG4gICAgICAgICAgYXBwbHlGaWx0ZXJDaGFpbignRElEX0xPQURfSVRFTScsIGl0ZW0sIHtcbiAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeSxcbiAgICAgICAgICAgIGRpc3BhdGNoOiBkaXNwYXRjaFxuICAgICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgb3B0aW9uYWxQcm9taXNlKFxuICAgICAgICAgICAgICAgIHF1ZXJ5KCdHRVRfQkVGT1JFX0FERF9GSUxFJyksXG4gICAgICAgICAgICAgICAgY3JlYXRlSXRlbUFQSShpdGVtKVxuICAgICAgICAgICAgICApLnRoZW4oaGFuZGxlQWRkKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIGhhbmRsZUFkZChmYWxzZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXRlbS5vbigncHJvY2Vzcy1zdGFydCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGRpc3BhdGNoKCdESURfU1RBUlRfSVRFTV9QUk9DRVNTSU5HJywgeyBpZDogaWQgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0ZW0ub24oJ3Byb2Nlc3MtcHJvZ3Jlc3MnLCBmdW5jdGlvbihwcm9ncmVzcykge1xuICAgICAgICAgIGRpc3BhdGNoKCdESURfVVBEQVRFX0lURU1fUFJPQ0VTU19QUk9HUkVTUycsIHtcbiAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgIHByb2dyZXNzOiBwcm9ncmVzc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdGVtLm9uKCdwcm9jZXNzLWVycm9yJywgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICBkaXNwYXRjaCgnRElEX1RIUk9XX0lURU1fUFJPQ0VTU0lOR19FUlJPUicsIHtcbiAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICAgIHN0YXR1czoge1xuICAgICAgICAgICAgICBtYWluOiBkeW5hbWljTGFiZWwoc3RhdGUub3B0aW9ucy5sYWJlbEZpbGVQcm9jZXNzaW5nRXJyb3IpKGVycm9yKSxcbiAgICAgICAgICAgICAgc3ViOiBzdGF0ZS5vcHRpb25zLmxhYmVsVGFwVG9SZXRyeVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdGVtLm9uKCdwcm9jZXNzLXJldmVydC1lcnJvcicsIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgZGlzcGF0Y2goJ0RJRF9USFJPV19JVEVNX1BST0NFU1NJTkdfUkVWRVJUX0VSUk9SJywge1xuICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgc3RhdHVzOiB7XG4gICAgICAgICAgICAgIG1haW46IGR5bmFtaWNMYWJlbChzdGF0ZS5vcHRpb25zLmxhYmVsRmlsZVByb2Nlc3NpbmdSZXZlcnRFcnJvcikoXG4gICAgICAgICAgICAgICAgZXJyb3JcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgc3ViOiBzdGF0ZS5vcHRpb25zLmxhYmVsVGFwVG9SZXRyeVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdGVtLm9uKCdwcm9jZXNzLWNvbXBsZXRlJywgZnVuY3Rpb24oc2VydmVyRmlsZVJlZmVyZW5jZSkge1xuICAgICAgICAgIGRpc3BhdGNoKCdESURfQ09NUExFVEVfSVRFTV9QUk9DRVNTSU5HJywge1xuICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgICBzZXJ2ZXJGaWxlUmVmZXJlbmNlOiBzZXJ2ZXJGaWxlUmVmZXJlbmNlXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBkaXNwYXRjaCgnRElEX0RFRklORV9WQUxVRScsIHsgaWQ6IGlkLCB2YWx1ZTogc2VydmVyRmlsZVJlZmVyZW5jZSB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXRlbS5vbigncHJvY2Vzcy1hYm9ydCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGRpc3BhdGNoKCdESURfQUJPUlRfSVRFTV9QUk9DRVNTSU5HJywgeyBpZDogaWQgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0ZW0ub24oJ3Byb2Nlc3MtcmV2ZXJ0JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZGlzcGF0Y2goJ0RJRF9SRVZFUlRfSVRFTV9QUk9DRVNTSU5HJywgeyBpZDogaWQgfSk7XG4gICAgICAgICAgZGlzcGF0Y2goJ0RJRF9ERUZJTkVfVkFMVUUnLCB7IGlkOiBpZCwgdmFsdWU6IG51bGwgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGxldCB2aWV3IGtub3cgdGhlIGl0ZW0gaGFzIGJlZW4gaW5zZXJ0ZWRcbiAgICAgICAgZGlzcGF0Y2goJ0RJRF9BRERfSVRFTScsIHtcbiAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICAgIGludGVyYWN0aW9uTWV0aG9kOiBpbnRlcmFjdGlvbk1ldGhvZFxuICAgICAgICB9KTtcblxuICAgICAgICBsaXN0VXBkYXRlZChkaXNwYXRjaCwgc3RhdGUpO1xuXG4gICAgICAgIC8vIHN0YXJ0IGxvYWRpbmcgdGhlIHNvdXJjZVxuICAgICAgICB2YXIgX3JlZjggPSBzdGF0ZS5vcHRpb25zLnNlcnZlciB8fCB7fSxcbiAgICAgICAgICB1cmwgPSBfcmVmOC51cmwsXG4gICAgICAgICAgbG9hZCA9IF9yZWY4LmxvYWQsXG4gICAgICAgICAgcmVzdG9yZSA9IF9yZWY4LnJlc3RvcmUsXG4gICAgICAgICAgZmV0Y2ggPSBfcmVmOC5mZXRjaDtcblxuICAgICAgICBpdGVtLmxvYWQoXG4gICAgICAgICAgc291cmNlLFxuXG4gICAgICAgICAgLy8gdGhpcyBjcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBsb2FkcyB0aGUgZmlsZSBiYXNlZCBvbiB0aGUgdHlwZSBvZiBmaWxlIChzdHJpbmcsIGJhc2U2NCwgYmxvYiwgZmlsZSkgYW5kIGxvY2F0aW9uIG9mIGZpbGUgKGxvY2FsLCByZW1vdGUsIGxpbWJvKVxuICAgICAgICAgIGNyZWF0ZUZpbGVMb2FkZXIoXG4gICAgICAgICAgICBvcmlnaW4gPT09IEZpbGVPcmlnaW4uSU5QVVRcbiAgICAgICAgICAgICAgPyAvLyBpbnB1dCwgaWYgaXMgcmVtb3RlLCBzZWUgaWYgc2hvdWxkIHVzZSBjdXN0b20gZmV0Y2gsIGVsc2UgdXNlIGRlZmF1bHQgZmV0Y2hCbG9iXG4gICAgICAgICAgICAgICAgaXNTdHJpbmcoc291cmNlKSAmJiBpc0V4dGVybmFsVVJMKHNvdXJjZSlcbiAgICAgICAgICAgICAgICA/IGZldGNoXG4gICAgICAgICAgICAgICAgICA/IGNyZWF0ZUZldGNoRnVuY3Rpb24odXJsLCBmZXRjaClcbiAgICAgICAgICAgICAgICAgIDogZmV0Y2hCbG9iIC8vIHJlbW90ZSB1cmxcbiAgICAgICAgICAgICAgICA6IGZldGNoQmxvYiAvLyB0cnkgdG8gZmV0Y2ggdXJsXG4gICAgICAgICAgICAgIDogLy8gbGltYm8gb3IgbG9jYWxcbiAgICAgICAgICAgICAgb3JpZ2luID09PSBGaWxlT3JpZ2luLkxJTUJPXG4gICAgICAgICAgICAgID8gY3JlYXRlRmV0Y2hGdW5jdGlvbih1cmwsIHJlc3RvcmUpIC8vIGxpbWJvXG4gICAgICAgICAgICAgIDogY3JlYXRlRmV0Y2hGdW5jdGlvbih1cmwsIGxvYWQpIC8vIGxvY2FsXG4gICAgICAgICAgKSxcblxuICAgICAgICAgIC8vIGNhbGxlZCB3aGVuIHRoZSBmaWxlIGlzIGxvYWRlZCBzbyBpdCBjYW4gYmUgcGlwZWQgdGhyb3VnaCB0aGUgZmlsdGVyc1xuICAgICAgICAgIGZ1bmN0aW9uKGZpbGUsIHN1Y2Nlc3MsIGVycm9yKSB7XG4gICAgICAgICAgICAvLyBsZXQncyBwcm9jZXNzIHRoZSBmaWxlXG4gICAgICAgICAgICBhcHBseUZpbHRlckNoYWluKCdMT0FEX0ZJTEUnLCBmaWxlLCB7IHF1ZXJ5OiBxdWVyeSB9KVxuICAgICAgICAgICAgICAudGhlbihzdWNjZXNzKVxuICAgICAgICAgICAgICAuY2F0Y2goZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICAgIH0sXG5cbiAgICAgIFJFUVVFU1RfUFJFUEFSRV9PVVRQVVQ6IGZ1bmN0aW9uIFJFUVVFU1RfUFJFUEFSRV9PVVRQVVQoX3JlZjkpIHtcbiAgICAgICAgdmFyIGl0ZW0gPSBfcmVmOS5pdGVtLFxuICAgICAgICAgIHN1Y2Nlc3MgPSBfcmVmOS5zdWNjZXNzLFxuICAgICAgICAgIF9yZWY5JGZhaWx1cmUgPSBfcmVmOS5mYWlsdXJlLFxuICAgICAgICAgIGZhaWx1cmUgPSBfcmVmOSRmYWlsdXJlID09PSB2b2lkIDAgPyBmdW5jdGlvbigpIHt9IDogX3JlZjkkZmFpbHVyZTtcblxuICAgICAgICAvLyBlcnJvciByZXNwb25zZSBpZiBpdGVtIGFyY2hpdmVkXG4gICAgICAgIHZhciBlcnIgPSB7XG4gICAgICAgICAgZXJyb3I6IGNyZWF0ZVJlc3BvbnNlKCdlcnJvcicsIDAsICdJdGVtIG5vdCBmb3VuZCcpLFxuXG4gICAgICAgICAgZmlsZTogbnVsbFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGRvbid0IGhhbmRsZSBhcmNoaXZlZCBpdGVtcywgYW4gaXRlbSBjb3VsZCBoYXZlIGJlZW4gYXJjaGl2ZWQgKGxvYWQgYWJvcnRlZCkgd2hpbGUgd2FpdGluZyB0byBiZSBwcmVwYXJlZFxuICAgICAgICBpZiAoaXRlbS5hcmNoaXZlZCkgcmV0dXJuIGZhaWx1cmUoZXJyKTtcblxuICAgICAgICAvLyBhbGxvdyBwbHVnaW5zIHRvIGFsdGVyIHRoZSBmaWxlIGRhdGFcbiAgICAgICAgYXBwbHlGaWx0ZXJDaGFpbignUFJFUEFSRV9PVVRQVVQnLCBpdGVtLmZpbGUsIHtcbiAgICAgICAgICBxdWVyeTogcXVlcnksXG4gICAgICAgICAgaXRlbTogaXRlbVxuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgIGFwcGx5RmlsdGVyQ2hhaW4oJ0NPTVBMRVRFX1BSRVBBUkVfT1VUUFVUJywgcmVzdWx0LCB7XG4gICAgICAgICAgICBxdWVyeTogcXVlcnksXG4gICAgICAgICAgICBpdGVtOiBpdGVtXG4gICAgICAgICAgfSkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICAgIC8vIGRvbid0IGhhbmRsZSBhcmNoaXZlZCBpdGVtcywgYW4gaXRlbSBjb3VsZCBoYXZlIGJlZW4gYXJjaGl2ZWQgKGxvYWQgYWJvcnRlZCkgd2hpbGUgYmVpbmcgcHJlcGFyZWRcbiAgICAgICAgICAgIGlmIChpdGVtLmFyY2hpdmVkKSByZXR1cm4gZmFpbHVyZShlcnIpO1xuXG4gICAgICAgICAgICAvLyB3ZSBkb25lIVxuICAgICAgICAgICAgc3VjY2VzcyhyZXN1bHQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG5cbiAgICAgIENPTVBMRVRFX0xPQURfSVRFTTogZnVuY3Rpb24gQ09NUExFVEVfTE9BRF9JVEVNKF9yZWYxMCkge1xuICAgICAgICB2YXIgaXRlbSA9IF9yZWYxMC5pdGVtLFxuICAgICAgICAgIGRhdGEgPSBfcmVmMTAuZGF0YTtcbiAgICAgICAgdmFyIHN1Y2Nlc3MgPSBkYXRhLnN1Y2Nlc3MsXG4gICAgICAgICAgc291cmNlID0gZGF0YS5zb3VyY2U7XG5cbiAgICAgICAgLy8gc29ydCBpdGVtcyBpbiBsaXN0XG4gICAgICAgIHZhciBpdGVtSW5zZXJ0TG9jYXRpb24gPSBxdWVyeSgnR0VUX0lURU1fSU5TRVJUX0xPQ0FUSU9OJyk7XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKGl0ZW1JbnNlcnRMb2NhdGlvbikgJiYgc291cmNlKSB7XG4gICAgICAgICAgc29ydEl0ZW1zKHN0YXRlLCBpdGVtSW5zZXJ0TG9jYXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbGV0IGludGVyZmFjZSBrbm93IHRoZSBpdGVtIGhhcyBsb2FkZWRcbiAgICAgICAgZGlzcGF0Y2goJ0RJRF9MT0FEX0lURU0nLCB7XG4gICAgICAgICAgaWQ6IGl0ZW0uaWQsXG4gICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgc2VydmVyRmlsZVJlZmVyZW5jZTogaXRlbS5vcmlnaW4gPT09IEZpbGVPcmlnaW4uSU5QVVQgPyBudWxsIDogc291cmNlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGl0ZW0gaGFzIGJlZW4gc3VjY2Vzc2Z1bGx5IGxvYWRlZCBhbmQgYWRkZWQgdG8gdGhlXG4gICAgICAgIC8vIGxpc3Qgb2YgaXRlbXMgc28gY2FuIG5vdyBiZSBzYWZlbHkgcmV0dXJuZWQgZm9yIHVzZVxuICAgICAgICBzdWNjZXNzKGNyZWF0ZUl0ZW1BUEkoaXRlbSkpO1xuXG4gICAgICAgIC8vIGlmIHRoaXMgaXMgYSBsb2NhbCBzZXJ2ZXIgZmlsZSB3ZSBuZWVkIHRvIHNob3cgYSBkaWZmZXJlbnQgc3RhdGVcbiAgICAgICAgaWYgKGl0ZW0ub3JpZ2luID09PSBGaWxlT3JpZ2luLkxPQ0FMKSB7XG4gICAgICAgICAgZGlzcGF0Y2goJ0RJRF9MT0FEX0xPQ0FMX0lURU0nLCB7IGlkOiBpdGVtLmlkIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIGlzIGEgdGVtcCBzZXJ2ZXIgZmlsZSB3ZSBwcmV2ZW50IGFzeW5jIHVwbG9hZCBjYWxsIGhlcmUgKGFzIHRoZSBmaWxlIGlzIGFscmVhZHkgb24gdGhlIHNlcnZlcilcbiAgICAgICAgaWYgKGl0ZW0ub3JpZ2luID09PSBGaWxlT3JpZ2luLkxJTUJPKSB7XG4gICAgICAgICAgZGlzcGF0Y2goJ0RJRF9DT01QTEVURV9JVEVNX1BST0NFU1NJTkcnLCB7XG4gICAgICAgICAgICBpZDogaXRlbS5pZCxcbiAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgICAgc2VydmVyRmlsZVJlZmVyZW5jZTogc291cmNlXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBkaXNwYXRjaCgnRElEX0RFRklORV9WQUxVRScsIHtcbiAgICAgICAgICAgIGlkOiBpdGVtLmlkLFxuICAgICAgICAgICAgdmFsdWU6IHNvdXJjZVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWQgd2UgYXJlIGFsbG93ZWQgdG8gdXBsb2FkIHRoZSBmaWxlIGltbWVkaWF0ZWx5LCBsZXRzIGRvIGl0XG4gICAgICAgIGlmIChxdWVyeSgnSVNfQVNZTkMnKSAmJiBzdGF0ZS5vcHRpb25zLmluc3RhbnRVcGxvYWQpIHtcbiAgICAgICAgICBkaXNwYXRjaCgnUkVRVUVTVF9JVEVNX1BST0NFU1NJTkcnLCB7IHF1ZXJ5OiBpdGVtLmlkIH0pO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBSRVRSWV9JVEVNX0xPQUQ6IGdldEl0ZW1CeVF1ZXJ5RnJvbVN0YXRlKHN0YXRlLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgIC8vIHRyeSBsb2FkaW5nIHRoZSBzb3VyY2Ugb25lIG1vcmUgdGltZVxuICAgICAgICBpdGVtLnJldHJ5TG9hZCgpO1xuICAgICAgfSksXG5cbiAgICAgIFJFUVVFU1RfSVRFTV9QUkVQQVJFOiBnZXRJdGVtQnlRdWVyeUZyb21TdGF0ZShzdGF0ZSwgZnVuY3Rpb24oXG4gICAgICAgIGl0ZW0sXG4gICAgICAgIF9zdWNjZXNzLFxuICAgICAgICBmYWlsdXJlXG4gICAgICApIHtcbiAgICAgICAgZGlzcGF0Y2goXG4gICAgICAgICAgJ1JFUVVFU1RfUFJFUEFSRV9PVVRQVVQnLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHF1ZXJ5OiBpdGVtLmlkLFxuICAgICAgICAgICAgaXRlbTogaXRlbSxcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIHN1Y2Nlc3MoZmlsZSkge1xuICAgICAgICAgICAgICBkaXNwYXRjaCgnRElEX1BSRVBBUkVfT1VUUFVUJywgeyBpZDogaXRlbS5pZCwgZmlsZTogZmlsZSB9KTtcbiAgICAgICAgICAgICAgX3N1Y2Nlc3Moe1xuICAgICAgICAgICAgICAgIGZpbGU6IGl0ZW0sXG4gICAgICAgICAgICAgICAgb3V0cHV0OiBmaWxlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZhaWx1cmU6IGZhaWx1cmVcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRydWVcbiAgICAgICAgKTtcbiAgICAgIH0pLFxuXG4gICAgICBSRVFVRVNUX0lURU1fUFJPQ0VTU0lORzogZ2V0SXRlbUJ5UXVlcnlGcm9tU3RhdGUoc3RhdGUsIGZ1bmN0aW9uKFxuICAgICAgICBpdGVtLFxuICAgICAgICBzdWNjZXNzLFxuICAgICAgICBmYWlsdXJlXG4gICAgICApIHtcbiAgICAgICAgLy8gY2Fubm90IGJlIHF1ZXVlZCAob3IgaXMgYWxyZWFkeSBxdWV1ZWQpXG4gICAgICAgIHZhciBpdGVtQ2FuQmVRdWV1ZWRGb3JQcm9jZXNzaW5nID1cbiAgICAgICAgICAvLyB3YWl0aW5nIGZvciBzb21ldGhpbmdcbiAgICAgICAgICBpdGVtLnN0YXR1cyA9PT0gSXRlbVN0YXR1cy5JRExFIHx8XG4gICAgICAgICAgLy8gcHJvY2Vzc2luZyB3ZW50IHdyb25nIGVhcmxpZXJcbiAgICAgICAgICBpdGVtLnN0YXR1cyA9PT0gSXRlbVN0YXR1cy5QUk9DRVNTSU5HX0VSUk9SO1xuXG4gICAgICAgIC8vIG5vdCByZWFkeSB0byBiZSBwcm9jZXNzZWRcbiAgICAgICAgaWYgKCFpdGVtQ2FuQmVRdWV1ZWRGb3JQcm9jZXNzaW5nKSB7XG4gICAgICAgICAgdmFyIHByb2Nlc3NOb3cgPSBmdW5jdGlvbiBwcm9jZXNzTm93KCkge1xuICAgICAgICAgICAgcmV0dXJuIGRpc3BhdGNoKCdSRVFVRVNUX0lURU1fUFJPQ0VTU0lORycsIHtcbiAgICAgICAgICAgICAgcXVlcnk6IGl0ZW0sXG4gICAgICAgICAgICAgIHN1Y2Nlc3M6IHN1Y2Nlc3MsXG4gICAgICAgICAgICAgIGZhaWx1cmU6IGZhaWx1cmVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICB2YXIgcHJvY2VzcyA9IGZ1bmN0aW9uIHByb2Nlc3MoKSB7XG4gICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQuaGlkZGVuID8gcHJvY2Vzc05vdygpIDogc2V0VGltZW91dChwcm9jZXNzTm93LCAzMik7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIC8vIGlmIGFscmVhZHkgZG9uZSBwcm9jZXNzaW5nIG9yIHRyaWVkIHRvIHJldmVydCBidXQgZGlkbid0IHdvcmssIHRyeSBhZ2FpblxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGl0ZW0uc3RhdHVzID09PSBJdGVtU3RhdHVzLlBST0NFU1NJTkdfQ09NUExFVEUgfHxcbiAgICAgICAgICAgIGl0ZW0uc3RhdHVzID09PSBJdGVtU3RhdHVzLlBST0NFU1NJTkdfUkVWRVJUX0VSUk9SXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBpdGVtXG4gICAgICAgICAgICAgIC5yZXZlcnQoXG4gICAgICAgICAgICAgICAgY3JlYXRlUmV2ZXJ0RnVuY3Rpb24oXG4gICAgICAgICAgICAgICAgICBzdGF0ZS5vcHRpb25zLnNlcnZlci51cmwsXG4gICAgICAgICAgICAgICAgICBzdGF0ZS5vcHRpb25zLnNlcnZlci5yZXZlcnRcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIHF1ZXJ5KCdHRVRfRk9SQ0VfUkVWRVJUJylcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAudGhlbihwcm9jZXNzKVxuICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24oKSB7fSk7IC8vIGRvbid0IGNvbnRpbnVlIHdpdGggcHJvY2Vzc2luZyBpZiBzb21ldGhpbmcgd2VudCB3cm9uZ1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXRlbS5zdGF0dXMgPT09IEl0ZW1TdGF0dXMuUFJPQ0VTU0lORykge1xuICAgICAgICAgICAgaXRlbS5hYm9ydFByb2Nlc3NpbmcoKS50aGVuKHByb2Nlc3MpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFscmVhZHkgcXVldWVkIGZvciBwcm9jZXNzaW5nXG4gICAgICAgIGlmIChpdGVtLnN0YXR1cyA9PT0gSXRlbVN0YXR1cy5QUk9DRVNTSU5HX1FVRVVFRCkgcmV0dXJuO1xuXG4gICAgICAgIGl0ZW0ucmVxdWVzdFByb2Nlc3NpbmcoKTtcblxuICAgICAgICBkaXNwYXRjaCgnRElEX1JFUVVFU1RfSVRFTV9QUk9DRVNTSU5HJywgeyBpZDogaXRlbS5pZCB9KTtcblxuICAgICAgICBkaXNwYXRjaChcbiAgICAgICAgICAnUFJPQ0VTU19JVEVNJyxcbiAgICAgICAgICB7IHF1ZXJ5OiBpdGVtLCBzdWNjZXNzOiBzdWNjZXNzLCBmYWlsdXJlOiBmYWlsdXJlIH0sXG4gICAgICAgICAgdHJ1ZVxuICAgICAgICApO1xuICAgICAgfSksXG5cbiAgICAgIFBST0NFU1NfSVRFTTogZ2V0SXRlbUJ5UXVlcnlGcm9tU3RhdGUoc3RhdGUsIGZ1bmN0aW9uKFxuICAgICAgICBpdGVtLFxuICAgICAgICBzdWNjZXNzLFxuICAgICAgICBmYWlsdXJlXG4gICAgICApIHtcbiAgICAgICAgdmFyIG1heFBhcmFsbGVsVXBsb2FkcyA9IHF1ZXJ5KCdHRVRfTUFYX1BBUkFMTEVMX1VQTE9BRFMnKTtcbiAgICAgICAgdmFyIHRvdGFsQ3VycmVudFVwbG9hZHMgPSBxdWVyeShcbiAgICAgICAgICAnR0VUX0lURU1TX0JZX1NUQVRVUycsXG4gICAgICAgICAgSXRlbVN0YXR1cy5QUk9DRVNTSU5HXG4gICAgICAgICkubGVuZ3RoO1xuXG4gICAgICAgIC8vIHF1ZXVlIGFuZCB3YWl0IHRpbGwgcXVldWUgaXMgZnJlZWQgdXBcbiAgICAgICAgaWYgKHRvdGFsQ3VycmVudFVwbG9hZHMgPT09IG1heFBhcmFsbGVsVXBsb2Fkcykge1xuICAgICAgICAgIC8vIHF1ZXVlIGZvciBsYXRlciBwcm9jZXNzaW5nXG4gICAgICAgICAgc3RhdGUucHJvY2Vzc2luZ1F1ZXVlLnB1c2goe1xuICAgICAgICAgICAgaWQ6IGl0ZW0uaWQsXG4gICAgICAgICAgICBzdWNjZXNzOiBzdWNjZXNzLFxuICAgICAgICAgICAgZmFpbHVyZTogZmFpbHVyZVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gc3RvcCBpdCFcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB3YXMgbm90IHF1ZXVlZCBvciBpcyBhbHJlYWR5IHByb2Nlc3NpbmcgZXhpdCBoZXJlXG4gICAgICAgIGlmIChpdGVtLnN0YXR1cyA9PT0gSXRlbVN0YXR1cy5QUk9DRVNTSU5HKSByZXR1cm47XG5cbiAgICAgICAgdmFyIHByb2Nlc3NOZXh0ID0gZnVuY3Rpb24gcHJvY2Vzc05leHQoKSB7XG4gICAgICAgICAgLy8gcHJvY2VzcyBxdWV1ZXVkIGl0ZW1zXG4gICAgICAgICAgdmFyIHF1ZXVlRW50cnkgPSBzdGF0ZS5wcm9jZXNzaW5nUXVldWUuc2hpZnQoKTtcblxuICAgICAgICAgIC8vIG5vIGl0ZW1zIGxlZnRcbiAgICAgICAgICBpZiAoIXF1ZXVlRW50cnkpIHJldHVybjtcblxuICAgICAgICAgIC8vIGdldCBpdGVtIHJlZmVyZW5jZVxuICAgICAgICAgIHZhciBpZCA9IHF1ZXVlRW50cnkuaWQsXG4gICAgICAgICAgICBzdWNjZXNzID0gcXVldWVFbnRyeS5zdWNjZXNzLFxuICAgICAgICAgICAgZmFpbHVyZSA9IHF1ZXVlRW50cnkuZmFpbHVyZTtcbiAgICAgICAgICB2YXIgaXRlbVJlZmVyZW5jZSA9IGdldEl0ZW1CeVF1ZXJ5KHN0YXRlLml0ZW1zLCBpZCk7XG5cbiAgICAgICAgICAvLyBpZiBpdGVtIHdhcyBhcmNoaXZlZCB3aGlsZSBpbiBxdWV1ZSwganVtcCB0byBuZXh0XG4gICAgICAgICAgaWYgKCFpdGVtUmVmZXJlbmNlIHx8IGl0ZW1SZWZlcmVuY2UuYXJjaGl2ZWQpIHtcbiAgICAgICAgICAgIHByb2Nlc3NOZXh0KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gcHJvY2VzcyBxdWV1ZWQgaXRlbVxuICAgICAgICAgIGRpc3BhdGNoKFxuICAgICAgICAgICAgJ1BST0NFU1NfSVRFTScsXG4gICAgICAgICAgICB7IHF1ZXJ5OiBpZCwgc3VjY2Vzczogc3VjY2VzcywgZmFpbHVyZTogZmFpbHVyZSB9LFxuICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gd2UgZG9uZSBmdW5jdGlvblxuICAgICAgICBpdGVtLm9uT25jZSgncHJvY2Vzcy1jb21wbGV0ZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHN1Y2Nlc3MoY3JlYXRlSXRlbUFQSShpdGVtKSk7XG4gICAgICAgICAgcHJvY2Vzc05leHQoKTtcblxuICAgICAgICAgIC8vIEFsbCBpdGVtcyBwcm9jZXNzZWQ/IE5vIGVycm9ycz9cbiAgICAgICAgICB2YXIgYWxsSXRlbXNQcm9jZXNzZWQgPVxuICAgICAgICAgICAgcXVlcnkoJ0dFVF9JVEVNU19CWV9TVEFUVVMnLCBJdGVtU3RhdHVzLlBST0NFU1NJTkdfQ09NUExFVEUpXG4gICAgICAgICAgICAgIC5sZW5ndGggPT09IHN0YXRlLml0ZW1zLmxlbmd0aDtcbiAgICAgICAgICBpZiAoYWxsSXRlbXNQcm9jZXNzZWQpIHtcbiAgICAgICAgICAgIGRpc3BhdGNoKCdESURfQ09NUExFVEVfSVRFTV9QUk9DRVNTSU5HX0FMTCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gd2UgZXJyb3IgZnVuY3Rpb25cbiAgICAgICAgaXRlbS5vbk9uY2UoJ3Byb2Nlc3MtZXJyb3InLCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgIGZhaWx1cmUoeyBlcnJvcjogZXJyb3IsIGZpbGU6IGNyZWF0ZUl0ZW1BUEkoaXRlbSkgfSk7XG4gICAgICAgICAgcHJvY2Vzc05leHQoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gc3RhcnQgZmlsZSBwcm9jZXNzaW5nXG4gICAgICAgIHZhciBvcHRpb25zID0gc3RhdGUub3B0aW9ucztcbiAgICAgICAgaXRlbS5wcm9jZXNzKFxuICAgICAgICAgIGNyZWF0ZUZpbGVQcm9jZXNzb3IoXG4gICAgICAgICAgICBjcmVhdGVQcm9jZXNzb3JGdW5jdGlvbihcbiAgICAgICAgICAgICAgb3B0aW9ucy5zZXJ2ZXIudXJsLFxuICAgICAgICAgICAgICBvcHRpb25zLnNlcnZlci5wcm9jZXNzLFxuICAgICAgICAgICAgICBvcHRpb25zLm5hbWUsXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjaHVua1RyYW5zZmVySWQ6IGl0ZW0udHJhbnNmZXJJZCxcbiAgICAgICAgICAgICAgICBjaHVua1NlcnZlcjogb3B0aW9ucy5zZXJ2ZXIucGF0Y2gsXG4gICAgICAgICAgICAgICAgY2h1bmtVcGxvYWRzOiBvcHRpb25zLmNodW5rVXBsb2FkcyxcbiAgICAgICAgICAgICAgICBjaHVua0ZvcmNlOiBvcHRpb25zLmNodW5rRm9yY2UsXG4gICAgICAgICAgICAgICAgY2h1bmtTaXplOiBvcHRpb25zLmNodW5rU2l6ZSxcbiAgICAgICAgICAgICAgICBjaHVua1JldHJ5RGVsYXlzOiBvcHRpb25zLmNodW5rUmV0cnlEZWxheXNcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKVxuICAgICAgICAgICksXG5cbiAgICAgICAgICAvLyBjYWxsZWQgd2hlbiB0aGUgZmlsZSBpcyBhYm91dCB0byBiZSBwcm9jZXNzZWQgc28gaXQgY2FuIGJlIHBpcGVkIHRocm91Z2ggdGhlIHRyYW5zZm9ybSBmaWx0ZXJzXG4gICAgICAgICAgZnVuY3Rpb24oZmlsZSwgc3VjY2VzcywgZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIGFsbG93IHBsdWdpbnMgdG8gYWx0ZXIgdGhlIGZpbGUgZGF0YVxuICAgICAgICAgICAgYXBwbHlGaWx0ZXJDaGFpbignUFJFUEFSRV9PVVRQVVQnLCBmaWxlLCB7XG4gICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeSxcbiAgICAgICAgICAgICAgaXRlbTogaXRlbVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oZmlsZSkge1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdESURfUFJFUEFSRV9PVVRQVVQnLCB7IGlkOiBpdGVtLmlkLCBmaWxlOiBmaWxlIH0pO1xuXG4gICAgICAgICAgICAgICAgc3VjY2VzcyhmaWxlKTtcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgLmNhdGNoKGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICB9KSxcblxuICAgICAgUkVUUllfSVRFTV9QUk9DRVNTSU5HOiBnZXRJdGVtQnlRdWVyeUZyb21TdGF0ZShzdGF0ZSwgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICBkaXNwYXRjaCgnUkVRVUVTVF9JVEVNX1BST0NFU1NJTkcnLCB7IHF1ZXJ5OiBpdGVtIH0pO1xuICAgICAgfSksXG5cbiAgICAgIFJFUVVFU1RfUkVNT1ZFX0lURU06IGdldEl0ZW1CeVF1ZXJ5RnJvbVN0YXRlKHN0YXRlLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgIG9wdGlvbmFsUHJvbWlzZShcbiAgICAgICAgICBxdWVyeSgnR0VUX0JFRk9SRV9SRU1PVkVfRklMRScpLFxuICAgICAgICAgIGNyZWF0ZUl0ZW1BUEkoaXRlbSlcbiAgICAgICAgKS50aGVuKGZ1bmN0aW9uKHNob3VsZFJlbW92ZSkge1xuICAgICAgICAgIGlmICghc2hvdWxkUmVtb3ZlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGRpc3BhdGNoKCdSRU1PVkVfSVRFTScsIHsgcXVlcnk6IGl0ZW0gfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSksXG5cbiAgICAgIFJFTEVBU0VfSVRFTTogZ2V0SXRlbUJ5UXVlcnlGcm9tU3RhdGUoc3RhdGUsIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgaXRlbS5yZWxlYXNlKCk7XG4gICAgICB9KSxcblxuICAgICAgUkVNT1ZFX0lURU06IGdldEl0ZW1CeVF1ZXJ5RnJvbVN0YXRlKHN0YXRlLCBmdW5jdGlvbihcbiAgICAgICAgaXRlbSxcbiAgICAgICAgc3VjY2VzcyxcbiAgICAgICAgZmFpbHVyZSxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgKSB7XG4gICAgICAgIHZhciByZW1vdmVGcm9tVmlldyA9IGZ1bmN0aW9uIHJlbW92ZUZyb21WaWV3KCkge1xuICAgICAgICAgIC8vIGdldCBpZCByZWZlcmVuY2VcbiAgICAgICAgICB2YXIgaWQgPSBpdGVtLmlkO1xuXG4gICAgICAgICAgLy8gYXJjaGl2ZSB0aGUgaXRlbSwgdGhpcyBkb2VzIG5vdCByZW1vdmUgaXQgZnJvbSB0aGUgbGlzdFxuICAgICAgICAgIGdldEl0ZW1CeUlkKHN0YXRlLml0ZW1zLCBpZCkuYXJjaGl2ZSgpO1xuXG4gICAgICAgICAgLy8gdGVsbCB0aGUgdmlldyB0aGUgaXRlbSBoYXMgYmVlbiByZW1vdmVkXG4gICAgICAgICAgZGlzcGF0Y2goJ0RJRF9SRU1PVkVfSVRFTScsIHsgZXJyb3I6IG51bGwsIGlkOiBpZCwgaXRlbTogaXRlbSB9KTtcblxuICAgICAgICAgIC8vIG5vdyB0aGUgbGlzdCBoYXMgYmVlbiBtb2RpZmllZFxuICAgICAgICAgIGxpc3RVcGRhdGVkKGRpc3BhdGNoLCBzdGF0ZSk7XG5cbiAgICAgICAgICAvLyBjb3JyZWN0bHkgcmVtb3ZlZFxuICAgICAgICAgIHN1Y2Nlc3MoY3JlYXRlSXRlbUFQSShpdGVtKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gaWYgdGhpcyBpcyBhIGxvY2FsIGZpbGUgYW5kIHRoZSBzZXJ2ZXIucmVtb3ZlIGZ1bmN0aW9uIGhhcyBiZWVuIGNvbmZpZ3VyZWQsIHNlbmQgc291cmNlIHRoZXJlIHNvIGRldiBjYW4gcmVtb3ZlIGZpbGUgZnJvbSBzZXJ2ZXJcbiAgICAgICAgdmFyIHNlcnZlciA9IHN0YXRlLm9wdGlvbnMuc2VydmVyO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgaXRlbS5vcmlnaW4gPT09IEZpbGVPcmlnaW4uTE9DQUwgJiZcbiAgICAgICAgICBzZXJ2ZXIgJiZcbiAgICAgICAgICBpc0Z1bmN0aW9uKHNlcnZlci5yZW1vdmUpICYmXG4gICAgICAgICAgb3B0aW9ucy5yZW1vdmUgIT09IGZhbHNlXG4gICAgICAgICkge1xuICAgICAgICAgIGRpc3BhdGNoKCdESURfU1RBUlRfSVRFTV9SRU1PVkUnLCB7IGlkOiBpdGVtLmlkIH0pO1xuXG4gICAgICAgICAgc2VydmVyLnJlbW92ZShcbiAgICAgICAgICAgIGl0ZW0uc291cmNlLFxuICAgICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHJldHVybiByZW1vdmVGcm9tVmlldygpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZ1bmN0aW9uKHN0YXR1cykge1xuICAgICAgICAgICAgICBkaXNwYXRjaCgnRElEX1RIUk9XX0lURU1fUkVNT1ZFX0VSUk9SJywge1xuICAgICAgICAgICAgICAgIGlkOiBpdGVtLmlkLFxuICAgICAgICAgICAgICAgIGVycm9yOiBjcmVhdGVSZXNwb25zZSgnZXJyb3InLCAwLCBzdGF0dXMsIG51bGwpLFxuICAgICAgICAgICAgICAgIHN0YXR1czoge1xuICAgICAgICAgICAgICAgICAgbWFpbjogZHluYW1pY0xhYmVsKHN0YXRlLm9wdGlvbnMubGFiZWxGaWxlUmVtb3ZlRXJyb3IpKFxuICAgICAgICAgICAgICAgICAgICBzdGF0dXNcbiAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICBzdWI6IHN0YXRlLm9wdGlvbnMubGFiZWxUYXBUb1JldHJ5XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGlmIGlzIHJlcXVlc3RpbmcgcmV2ZXJ0IGFuZCBjYW4gcmV2ZXJ0IG5lZWQgdG8gY2FsbCByZXZlcnQgaGFuZGxlciAobm90IGNhbGxpbmcgcmVxdWVzdF8gYmVjYXVzZSB0aGF0IHdvdWxkIGFsc28gdHJpZ2dlciBiZWZvcmVSZW1vdmVIb29rKVxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIG9wdGlvbnMucmV2ZXJ0ICYmXG4gICAgICAgICAgICBpdGVtLm9yaWdpbiAhPT0gRmlsZU9yaWdpbi5MT0NBTCAmJlxuICAgICAgICAgICAgaXRlbS5zZXJ2ZXJJZCAhPT0gbnVsbFxuICAgICAgICAgICkge1xuICAgICAgICAgICAgaXRlbS5yZXZlcnQoXG4gICAgICAgICAgICAgIGNyZWF0ZVJldmVydEZ1bmN0aW9uKFxuICAgICAgICAgICAgICAgIHN0YXRlLm9wdGlvbnMuc2VydmVyLnVybCxcbiAgICAgICAgICAgICAgICBzdGF0ZS5vcHRpb25zLnNlcnZlci5yZXZlcnRcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgcXVlcnkoJ0dFVF9GT1JDRV9SRVZFUlQnKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBjYW4gbm93IHNhZmVseSByZW1vdmUgZnJvbSB2aWV3XG4gICAgICAgICAgcmVtb3ZlRnJvbVZpZXcoKTtcbiAgICAgICAgfVxuICAgICAgfSksXG5cbiAgICAgIEFCT1JUX0lURU1fTE9BRDogZ2V0SXRlbUJ5UXVlcnlGcm9tU3RhdGUoc3RhdGUsIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgaXRlbS5hYm9ydExvYWQoKTtcbiAgICAgIH0pLFxuXG4gICAgICBBQk9SVF9JVEVNX1BST0NFU1NJTkc6IGdldEl0ZW1CeVF1ZXJ5RnJvbVN0YXRlKHN0YXRlLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgIC8vIHRlc3QgaWYgaXMgYWxyZWFkeSBwcm9jZXNzZWRcbiAgICAgICAgaWYgKGl0ZW0uc2VydmVySWQpIHtcbiAgICAgICAgICBkaXNwYXRjaCgnUkVWRVJUX0lURU1fUFJPQ0VTU0lORycsIHsgaWQ6IGl0ZW0uaWQgfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWJvcnRcbiAgICAgICAgaXRlbS5hYm9ydFByb2Nlc3NpbmcoKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBzaG91bGRSZW1vdmUgPSBzdGF0ZS5vcHRpb25zLmluc3RhbnRVcGxvYWQ7XG4gICAgICAgICAgaWYgKHNob3VsZFJlbW92ZSkge1xuICAgICAgICAgICAgZGlzcGF0Y2goJ1JFTU9WRV9JVEVNJywgeyBxdWVyeTogaXRlbS5pZCB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSksXG5cbiAgICAgIFJFUVVFU1RfUkVWRVJUX0lURU1fUFJPQ0VTU0lORzogZ2V0SXRlbUJ5UXVlcnlGcm9tU3RhdGUoc3RhdGUsIGZ1bmN0aW9uKFxuICAgICAgICBpdGVtXG4gICAgICApIHtcbiAgICAgICAgLy8gbm90IGluc3RhbnQgdXBsb2FkaW5nLCByZXZlcnQgaW1tZWRpYXRlbHlcbiAgICAgICAgaWYgKCFzdGF0ZS5vcHRpb25zLmluc3RhbnRVcGxvYWQpIHtcbiAgICAgICAgICBkaXNwYXRjaCgnUkVWRVJUX0lURU1fUFJPQ0VTU0lORycsIHsgcXVlcnk6IGl0ZW0gfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgd2UncmUgaW5zdGFudCB1cGxvYWRpbmcgdGhlIGZpbGUgd2lsbCBhbHNvIGJlIHJlbW92ZWQgaWYgd2UgcmV2ZXJ0LFxuICAgICAgICAvLyBzbyBpZiBhIGJlZm9yZSByZW1vdmUgZmlsZSBob29rIGlzIGRlZmluZWQgd2UgbmVlZCB0byBydW4gaXQgbm93XG4gICAgICAgIHZhciBoYW5kbGVSZXZlcnQgPSBmdW5jdGlvbiBoYW5kbGVSZXZlcnQoc2hvdWxkUmV2ZXJ0KSB7XG4gICAgICAgICAgaWYgKCFzaG91bGRSZXZlcnQpIHJldHVybjtcbiAgICAgICAgICBkaXNwYXRjaCgnUkVWRVJUX0lURU1fUFJPQ0VTU0lORycsIHsgcXVlcnk6IGl0ZW0gfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGZuID0gcXVlcnkoJ0dFVF9CRUZPUkVfUkVNT1ZFX0ZJTEUnKTtcbiAgICAgICAgaWYgKCFmbikge1xuICAgICAgICAgIHJldHVybiBoYW5kbGVSZXZlcnQodHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVxdWVzdFJlbW92ZVJlc3VsdCA9IGZuKGNyZWF0ZUl0ZW1BUEkoaXRlbSkpO1xuICAgICAgICBpZiAocmVxdWVzdFJlbW92ZVJlc3VsdCA9PSBudWxsKSB7XG4gICAgICAgICAgLy8gdW5kZWZpbmVkIG9yIG51bGxcbiAgICAgICAgICByZXR1cm4gaGFuZGxlUmV2ZXJ0KHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiByZXF1ZXN0UmVtb3ZlUmVzdWx0ID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICByZXR1cm4gaGFuZGxlUmV2ZXJ0KHJlcXVlc3RSZW1vdmVSZXN1bHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiByZXF1ZXN0UmVtb3ZlUmVzdWx0LnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICByZXF1ZXN0UmVtb3ZlUmVzdWx0LnRoZW4oaGFuZGxlUmV2ZXJ0KTtcbiAgICAgICAgfVxuICAgICAgfSksXG5cbiAgICAgIFJFVkVSVF9JVEVNX1BST0NFU1NJTkc6IGdldEl0ZW1CeVF1ZXJ5RnJvbVN0YXRlKHN0YXRlLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgIGl0ZW1cbiAgICAgICAgICAucmV2ZXJ0KFxuICAgICAgICAgICAgY3JlYXRlUmV2ZXJ0RnVuY3Rpb24oXG4gICAgICAgICAgICAgIHN0YXRlLm9wdGlvbnMuc2VydmVyLnVybCxcbiAgICAgICAgICAgICAgc3RhdGUub3B0aW9ucy5zZXJ2ZXIucmV2ZXJ0XG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgcXVlcnkoJ0dFVF9GT1JDRV9SRVZFUlQnKVxuICAgICAgICAgIClcbiAgICAgICAgICAudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBzaG91bGRSZW1vdmUgPSBzdGF0ZS5vcHRpb25zLmluc3RhbnRVcGxvYWQgfHwgaXNNb2NrSXRlbShpdGVtKTtcbiAgICAgICAgICAgIGlmIChzaG91bGRSZW1vdmUpIHtcbiAgICAgICAgICAgICAgZGlzcGF0Y2goJ1JFTU9WRV9JVEVNJywgeyBxdWVyeTogaXRlbS5pZCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICAgIC5jYXRjaChmdW5jdGlvbigpIHt9KTtcbiAgICAgIH0pLFxuXG4gICAgICBTRVRfT1BUSU9OUzogZnVuY3Rpb24gU0VUX09QVElPTlMoX3JlZjExKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gX3JlZjExLm9wdGlvbnM7XG4gICAgICAgIGZvcmluKG9wdGlvbnMsIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICBkaXNwYXRjaCgnU0VUXycgKyBmcm9tQ2FtZWxzKGtleSwgJ18nKS50b1VwcGVyQ2FzZSgpLCB7XG4gICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICB2YXIgZm9ybWF0RmlsZW5hbWUgPSBmdW5jdGlvbiBmb3JtYXRGaWxlbmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIG5hbWU7XG4gIH07XG5cbiAgdmFyIGNyZWF0ZUVsZW1lbnQkMSA9IGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQodGFnTmFtZSkge1xuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xuICB9O1xuXG4gIHZhciB0ZXh0ID0gZnVuY3Rpb24gdGV4dChub2RlLCB2YWx1ZSkge1xuICAgIHZhciB0ZXh0Tm9kZSA9IG5vZGUuY2hpbGROb2Rlc1swXTtcbiAgICBpZiAoIXRleHROb2RlKSB7XG4gICAgICB0ZXh0Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHZhbHVlKTtcbiAgICAgIG5vZGUuYXBwZW5kQ2hpbGQodGV4dE5vZGUpO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgIT09IHRleHROb2RlLm5vZGVWYWx1ZSkge1xuICAgICAgdGV4dE5vZGUubm9kZVZhbHVlID0gdmFsdWU7XG4gICAgfVxuICB9O1xuXG4gIHZhciBwb2xhclRvQ2FydGVzaWFuID0gZnVuY3Rpb24gcG9sYXJUb0NhcnRlc2lhbihcbiAgICBjZW50ZXJYLFxuICAgIGNlbnRlclksXG4gICAgcmFkaXVzLFxuICAgIGFuZ2xlSW5EZWdyZWVzXG4gICkge1xuICAgIHZhciBhbmdsZUluUmFkaWFucyA9ICgoKGFuZ2xlSW5EZWdyZWVzICUgMzYwKSAtIDkwKSAqIE1hdGguUEkpIC8gMTgwLjA7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IGNlbnRlclggKyByYWRpdXMgKiBNYXRoLmNvcyhhbmdsZUluUmFkaWFucyksXG4gICAgICB5OiBjZW50ZXJZICsgcmFkaXVzICogTWF0aC5zaW4oYW5nbGVJblJhZGlhbnMpXG4gICAgfTtcbiAgfTtcblxuICB2YXIgZGVzY3JpYmVBcmMgPSBmdW5jdGlvbiBkZXNjcmliZUFyYyhcbiAgICB4LFxuICAgIHksXG4gICAgcmFkaXVzLFxuICAgIHN0YXJ0QW5nbGUsXG4gICAgZW5kQW5nbGUsXG4gICAgYXJjU3dlZXBcbiAgKSB7XG4gICAgdmFyIHN0YXJ0ID0gcG9sYXJUb0NhcnRlc2lhbih4LCB5LCByYWRpdXMsIGVuZEFuZ2xlKTtcbiAgICB2YXIgZW5kID0gcG9sYXJUb0NhcnRlc2lhbih4LCB5LCByYWRpdXMsIHN0YXJ0QW5nbGUpO1xuICAgIHJldHVybiBbXG4gICAgICAnTScsXG4gICAgICBzdGFydC54LFxuICAgICAgc3RhcnQueSxcbiAgICAgICdBJyxcbiAgICAgIHJhZGl1cyxcbiAgICAgIHJhZGl1cyxcbiAgICAgIDAsXG4gICAgICBhcmNTd2VlcCxcbiAgICAgIDAsXG4gICAgICBlbmQueCxcbiAgICAgIGVuZC55XG4gICAgXS5qb2luKCcgJyk7XG4gIH07XG5cbiAgdmFyIHBlcmNlbnRhZ2VBcmMgPSBmdW5jdGlvbiBwZXJjZW50YWdlQXJjKHgsIHksIHJhZGl1cywgZnJvbSwgdG8pIHtcbiAgICB2YXIgYXJjU3dlZXAgPSAxO1xuICAgIGlmICh0byA+IGZyb20gJiYgdG8gLSBmcm9tIDw9IDAuNSkge1xuICAgICAgYXJjU3dlZXAgPSAwO1xuICAgIH1cbiAgICBpZiAoZnJvbSA+IHRvICYmIGZyb20gLSB0byA+PSAwLjUpIHtcbiAgICAgIGFyY1N3ZWVwID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIGRlc2NyaWJlQXJjKFxuICAgICAgeCxcbiAgICAgIHksXG4gICAgICByYWRpdXMsXG4gICAgICBNYXRoLm1pbigwLjk5OTksIGZyb20pICogMzYwLFxuICAgICAgTWF0aC5taW4oMC45OTk5LCB0bykgKiAzNjAsXG4gICAgICBhcmNTd2VlcFxuICAgICk7XG4gIH07XG5cbiAgdmFyIGNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShfcmVmKSB7XG4gICAgdmFyIHJvb3QgPSBfcmVmLnJvb3QsXG4gICAgICBwcm9wcyA9IF9yZWYucHJvcHM7XG4gICAgLy8gc3RhcnQgYXQgMFxuICAgIHByb3BzLnNwaW4gPSBmYWxzZTtcbiAgICBwcm9wcy5wcm9ncmVzcyA9IDA7XG4gICAgcHJvcHMub3BhY2l0eSA9IDA7XG5cbiAgICAvLyBzdmdcbiAgICB2YXIgc3ZnID0gY3JlYXRlRWxlbWVudCgnc3ZnJyk7XG4gICAgcm9vdC5yZWYucGF0aCA9IGNyZWF0ZUVsZW1lbnQoJ3BhdGgnLCB7XG4gICAgICAnc3Ryb2tlLXdpZHRoJzogMixcbiAgICAgICdzdHJva2UtbGluZWNhcCc6ICdyb3VuZCdcbiAgICB9KTtcblxuICAgIHN2Zy5hcHBlbmRDaGlsZChyb290LnJlZi5wYXRoKTtcblxuICAgIHJvb3QucmVmLnN2ZyA9IHN2ZztcblxuICAgIHJvb3QuYXBwZW5kQ2hpbGQoc3ZnKTtcbiAgfTtcblxuICB2YXIgd3JpdGUgPSBmdW5jdGlvbiB3cml0ZShfcmVmMikge1xuICAgIHZhciByb290ID0gX3JlZjIucm9vdCxcbiAgICAgIHByb3BzID0gX3JlZjIucHJvcHM7XG5cbiAgICBpZiAocHJvcHMub3BhY2l0eSA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChwcm9wcy5hbGlnbikge1xuICAgICAgcm9vdC5lbGVtZW50LmRhdGFzZXQuYWxpZ24gPSBwcm9wcy5hbGlnbjtcbiAgICB9XG5cbiAgICAvLyBnZXQgd2lkdGggb2Ygc3Ryb2tlXG4gICAgdmFyIHJpbmdTdHJva2VXaWR0aCA9IHBhcnNlSW50KGF0dHIocm9vdC5yZWYucGF0aCwgJ3N0cm9rZS13aWR0aCcpLCAxMCk7XG5cbiAgICAvLyBjYWxjdWxhdGUgc2l6ZSBvZiByaW5nXG4gICAgdmFyIHNpemUgPSByb290LnJlY3QuZWxlbWVudC53aWR0aCAqIDAuNTtcblxuICAgIC8vIHJpbmcgc3RhdGVcbiAgICB2YXIgcmluZ0Zyb20gPSAwO1xuICAgIHZhciByaW5nVG8gPSAwO1xuXG4gICAgLy8gbm93IGluIGJ1c3kgbW9kZVxuICAgIGlmIChwcm9wcy5zcGluKSB7XG4gICAgICByaW5nRnJvbSA9IDA7XG4gICAgICByaW5nVG8gPSAwLjU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJpbmdGcm9tID0gMDtcbiAgICAgIHJpbmdUbyA9IHByb3BzLnByb2dyZXNzO1xuICAgIH1cblxuICAgIC8vIGdldCBhcmMgcGF0aFxuICAgIHZhciBjb29yZGluYXRlcyA9IHBlcmNlbnRhZ2VBcmMoXG4gICAgICBzaXplLFxuICAgICAgc2l6ZSxcbiAgICAgIHNpemUgLSByaW5nU3Ryb2tlV2lkdGgsXG4gICAgICByaW5nRnJvbSxcbiAgICAgIHJpbmdUb1xuICAgICk7XG5cbiAgICAvLyB1cGRhdGUgcHJvZ3Jlc3MgYmFyXG4gICAgYXR0cihyb290LnJlZi5wYXRoLCAnZCcsIGNvb3JkaW5hdGVzKTtcblxuICAgIC8vIGhpZGUgd2hpbGUgY29udGFpbnMgMCB2YWx1ZVxuICAgIGF0dHIoXG4gICAgICByb290LnJlZi5wYXRoLFxuICAgICAgJ3N0cm9rZS1vcGFjaXR5JyxcbiAgICAgIHByb3BzLnNwaW4gfHwgcHJvcHMucHJvZ3Jlc3MgPiAwID8gMSA6IDBcbiAgICApO1xuICB9O1xuXG4gIHZhciBwcm9ncmVzc0luZGljYXRvciA9IGNyZWF0ZVZpZXcoe1xuICAgIHRhZzogJ2RpdicsXG4gICAgbmFtZTogJ3Byb2dyZXNzLWluZGljYXRvcicsXG4gICAgaWdub3JlUmVjdFVwZGF0ZTogdHJ1ZSxcbiAgICBpZ25vcmVSZWN0OiB0cnVlLFxuICAgIGNyZWF0ZTogY3JlYXRlLFxuICAgIHdyaXRlOiB3cml0ZSxcbiAgICBtaXhpbnM6IHtcbiAgICAgIGFwaXM6IFsncHJvZ3Jlc3MnLCAnc3BpbicsICdhbGlnbiddLFxuICAgICAgc3R5bGVzOiBbJ29wYWNpdHknXSxcbiAgICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgICAgb3BhY2l0eTogeyB0eXBlOiAndHdlZW4nLCBkdXJhdGlvbjogNTAwIH0sXG4gICAgICAgIHByb2dyZXNzOiB7XG4gICAgICAgICAgdHlwZTogJ3NwcmluZycsXG4gICAgICAgICAgc3RpZmZuZXNzOiAwLjk1LFxuICAgICAgICAgIGRhbXBpbmc6IDAuNjUsXG4gICAgICAgICAgbWFzczogMTBcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgdmFyIGNyZWF0ZSQxID0gZnVuY3Rpb24gY3JlYXRlKF9yZWYpIHtcbiAgICB2YXIgcm9vdCA9IF9yZWYucm9vdCxcbiAgICAgIHByb3BzID0gX3JlZi5wcm9wcztcbiAgICByb290LmVsZW1lbnQuaW5uZXJIVE1MID1cbiAgICAgIChwcm9wcy5pY29uIHx8ICcnKSArICgnPHNwYW4+JyArIHByb3BzLmxhYmVsICsgJzwvc3Bhbj4nKTtcblxuICAgIHByb3BzLmlzRGlzYWJsZWQgPSBmYWxzZTtcbiAgfTtcblxuICB2YXIgd3JpdGUkMSA9IGZ1bmN0aW9uIHdyaXRlKF9yZWYyKSB7XG4gICAgdmFyIHJvb3QgPSBfcmVmMi5yb290LFxuICAgICAgcHJvcHMgPSBfcmVmMi5wcm9wcztcbiAgICB2YXIgaXNEaXNhYmxlZCA9IHByb3BzLmlzRGlzYWJsZWQ7XG4gICAgdmFyIHNob3VsZERpc2FibGUgPSByb290LnF1ZXJ5KCdHRVRfRElTQUJMRUQnKSB8fCBwcm9wcy5vcGFjaXR5ID09PSAwO1xuXG4gICAgaWYgKHNob3VsZERpc2FibGUgJiYgIWlzRGlzYWJsZWQpIHtcbiAgICAgIHByb3BzLmlzRGlzYWJsZWQgPSB0cnVlO1xuICAgICAgYXR0cihyb290LmVsZW1lbnQsICdkaXNhYmxlZCcsICdkaXNhYmxlZCcpO1xuICAgIH0gZWxzZSBpZiAoIXNob3VsZERpc2FibGUgJiYgaXNEaXNhYmxlZCkge1xuICAgICAgcHJvcHMuaXNEaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgcm9vdC5lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnZGlzYWJsZWQnKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGZpbGVBY3Rpb25CdXR0b24gPSBjcmVhdGVWaWV3KHtcbiAgICB0YWc6ICdidXR0b24nLFxuICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgIHR5cGU6ICdidXR0b24nXG4gICAgfSxcblxuICAgIGlnbm9yZVJlY3Q6IHRydWUsXG4gICAgaWdub3JlUmVjdFVwZGF0ZTogdHJ1ZSxcbiAgICBuYW1lOiAnZmlsZS1hY3Rpb24tYnV0dG9uJyxcbiAgICBtaXhpbnM6IHtcbiAgICAgIGFwaXM6IFsnbGFiZWwnXSxcbiAgICAgIHN0eWxlczogWyd0cmFuc2xhdGVYJywgJ3RyYW5zbGF0ZVknLCAnc2NhbGVYJywgJ3NjYWxlWScsICdvcGFjaXR5J10sXG4gICAgICBhbmltYXRpb25zOiB7XG4gICAgICAgIHNjYWxlWDogJ3NwcmluZycsXG4gICAgICAgIHNjYWxlWTogJ3NwcmluZycsXG4gICAgICAgIHRyYW5zbGF0ZVg6ICdzcHJpbmcnLFxuICAgICAgICB0cmFuc2xhdGVZOiAnc3ByaW5nJyxcbiAgICAgICAgb3BhY2l0eTogeyB0eXBlOiAndHdlZW4nLCBkdXJhdGlvbjogMjUwIH1cbiAgICAgIH0sXG5cbiAgICAgIGxpc3RlbmVyczogdHJ1ZVxuICAgIH0sXG5cbiAgICBjcmVhdGU6IGNyZWF0ZSQxLFxuICAgIHdyaXRlOiB3cml0ZSQxXG4gIH0pO1xuXG4gIHZhciB0b05hdHVyYWxGaWxlU2l6ZSA9IGZ1bmN0aW9uIHRvTmF0dXJhbEZpbGVTaXplKGJ5dGVzKSB7XG4gICAgdmFyIGRlY2ltYWxTZXBhcmF0b3IgPVxuICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAnLic7XG4gICAgdmFyIGJhc2UgPVxuICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAxMDAwO1xuICAgIC8vIG5vIG5lZ2F0aXZlIGJ5dGUgc2l6ZXNcbiAgICBieXRlcyA9IE1hdGgucm91bmQoTWF0aC5hYnMoYnl0ZXMpKTtcblxuICAgIHZhciBLQiA9IGJhc2U7XG4gICAgdmFyIE1CID0gYmFzZSAqIGJhc2U7XG4gICAgdmFyIEdCID0gYmFzZSAqIGJhc2UgKiBiYXNlO1xuXG4gICAgLy8ganVzdCBieXRlc1xuICAgIGlmIChieXRlcyA8IEtCKSB7XG4gICAgICByZXR1cm4gYnl0ZXMgKyAnIGJ5dGVzJztcbiAgICB9XG5cbiAgICAvLyBraWxvYnl0ZXNcbiAgICBpZiAoYnl0ZXMgPCBNQikge1xuICAgICAgcmV0dXJuIE1hdGguZmxvb3IoYnl0ZXMgLyBLQikgKyAnIEtCJztcbiAgICB9XG5cbiAgICAvLyBtZWdhYnl0ZXNcbiAgICBpZiAoYnl0ZXMgPCBHQikge1xuICAgICAgcmV0dXJuIHJlbW92ZURlY2ltYWxzV2hlblplcm8oYnl0ZXMgLyBNQiwgMSwgZGVjaW1hbFNlcGFyYXRvcikgKyAnIE1CJztcbiAgICB9XG5cbiAgICAvLyBnaWdhYnl0ZXNcbiAgICByZXR1cm4gcmVtb3ZlRGVjaW1hbHNXaGVuWmVybyhieXRlcyAvIEdCLCAyLCBkZWNpbWFsU2VwYXJhdG9yKSArICcgR0InO1xuICB9O1xuXG4gIHZhciByZW1vdmVEZWNpbWFsc1doZW5aZXJvID0gZnVuY3Rpb24gcmVtb3ZlRGVjaW1hbHNXaGVuWmVybyhcbiAgICB2YWx1ZSxcbiAgICBkZWNpbWFsQ291bnQsXG4gICAgc2VwYXJhdG9yXG4gICkge1xuICAgIHJldHVybiB2YWx1ZVxuICAgICAgLnRvRml4ZWQoZGVjaW1hbENvdW50KVxuICAgICAgLnNwbGl0KCcuJylcbiAgICAgIC5maWx0ZXIoZnVuY3Rpb24ocGFydCkge1xuICAgICAgICByZXR1cm4gcGFydCAhPT0gJzAnO1xuICAgICAgfSlcbiAgICAgIC5qb2luKHNlcGFyYXRvcik7XG4gIH07XG5cbiAgdmFyIGNyZWF0ZSQyID0gZnVuY3Rpb24gY3JlYXRlKF9yZWYpIHtcbiAgICB2YXIgcm9vdCA9IF9yZWYucm9vdCxcbiAgICAgIHByb3BzID0gX3JlZi5wcm9wcztcbiAgICAvLyBmaWxlbmFtZVxuICAgIHZhciBmaWxlTmFtZSA9IGNyZWF0ZUVsZW1lbnQkMSgnc3BhbicpO1xuICAgIGZpbGVOYW1lLmNsYXNzTmFtZSA9ICdmaWxlcG9uZC0tZmlsZS1pbmZvLW1haW4nO1xuICAgIC8vIGhpZGUgZm9yIHNjcmVlbnJlYWRlcnNcbiAgICAvLyB0aGUgZmlsZSBpcyBjb250YWluZWQgaW4gYSBmaWVsZHNldCB3aXRoIGxlZ2VuZCB0aGF0IGNvbnRhaW5zIHRoZSBmaWxlbmFtZVxuICAgIC8vIG5vIG5lZWQgdG8gcmVhZCBpdCB0d2ljZVxuICAgIGF0dHIoZmlsZU5hbWUsICdhcmlhLWhpZGRlbicsICd0cnVlJyk7XG4gICAgcm9vdC5hcHBlbmRDaGlsZChmaWxlTmFtZSk7XG4gICAgcm9vdC5yZWYuZmlsZU5hbWUgPSBmaWxlTmFtZTtcblxuICAgIC8vIGZpbGVzaXplXG4gICAgdmFyIGZpbGVTaXplID0gY3JlYXRlRWxlbWVudCQxKCdzcGFuJyk7XG4gICAgZmlsZVNpemUuY2xhc3NOYW1lID0gJ2ZpbGVwb25kLS1maWxlLWluZm8tc3ViJztcbiAgICByb290LmFwcGVuZENoaWxkKGZpbGVTaXplKTtcbiAgICByb290LnJlZi5maWxlU2l6ZSA9IGZpbGVTaXplO1xuXG4gICAgLy8gc2V0IGluaXRpYWwgdmFsdWVzXG4gICAgdGV4dChmaWxlU2l6ZSwgcm9vdC5xdWVyeSgnR0VUX0xBQkVMX0ZJTEVfV0FJVElOR19GT1JfU0laRScpKTtcbiAgICB0ZXh0KGZpbGVOYW1lLCBmb3JtYXRGaWxlbmFtZShyb290LnF1ZXJ5KCdHRVRfSVRFTV9OQU1FJywgcHJvcHMuaWQpKSk7XG4gIH07XG5cbiAgdmFyIHVwZGF0ZUZpbGUgPSBmdW5jdGlvbiB1cGRhdGVGaWxlKF9yZWYyKSB7XG4gICAgdmFyIHJvb3QgPSBfcmVmMi5yb290LFxuICAgICAgcHJvcHMgPSBfcmVmMi5wcm9wcztcbiAgICB0ZXh0KFxuICAgICAgcm9vdC5yZWYuZmlsZVNpemUsXG4gICAgICB0b05hdHVyYWxGaWxlU2l6ZShcbiAgICAgICAgcm9vdC5xdWVyeSgnR0VUX0lURU1fU0laRScsIHByb3BzLmlkKSxcbiAgICAgICAgJy4nLFxuICAgICAgICByb290LnF1ZXJ5KCdHRVRfRklMRV9TSVpFX0JBU0UnKVxuICAgICAgKVxuICAgICk7XG5cbiAgICB0ZXh0KFxuICAgICAgcm9vdC5yZWYuZmlsZU5hbWUsXG4gICAgICBmb3JtYXRGaWxlbmFtZShyb290LnF1ZXJ5KCdHRVRfSVRFTV9OQU1FJywgcHJvcHMuaWQpKVxuICAgICk7XG4gIH07XG5cbiAgdmFyIHVwZGF0ZUZpbGVTaXplT25FcnJvciA9IGZ1bmN0aW9uIHVwZGF0ZUZpbGVTaXplT25FcnJvcihfcmVmMykge1xuICAgIHZhciByb290ID0gX3JlZjMucm9vdCxcbiAgICAgIHByb3BzID0gX3JlZjMucHJvcHM7XG4gICAgLy8gaWYgc2l6ZSBpcyBhdmFpbGFibGUgZG9uJ3QgZmFsbGJhY2sgdG8gdW5rbm93biBzaXplIG1lc3NhZ2VcbiAgICBpZiAoaXNJbnQocm9vdC5xdWVyeSgnR0VUX0lURU1fU0laRScsIHByb3BzLmlkKSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0ZXh0KHJvb3QucmVmLmZpbGVTaXplLCByb290LnF1ZXJ5KCdHRVRfTEFCRUxfRklMRV9TSVpFX05PVF9BVkFJTEFCTEUnKSk7XG4gIH07XG5cbiAgdmFyIGZpbGVJbmZvID0gY3JlYXRlVmlldyh7XG4gICAgbmFtZTogJ2ZpbGUtaW5mbycsXG4gICAgaWdub3JlUmVjdDogdHJ1ZSxcbiAgICBpZ25vcmVSZWN0VXBkYXRlOiB0cnVlLFxuICAgIHdyaXRlOiBjcmVhdGVSb3V0ZSh7XG4gICAgICBESURfTE9BRF9JVEVNOiB1cGRhdGVGaWxlLFxuICAgICAgRElEX1VQREFURV9JVEVNX01FVEE6IHVwZGF0ZUZpbGUsXG4gICAgICBESURfVEhST1dfSVRFTV9MT0FEX0VSUk9SOiB1cGRhdGVGaWxlU2l6ZU9uRXJyb3IsXG4gICAgICBESURfVEhST1dfSVRFTV9JTlZBTElEOiB1cGRhdGVGaWxlU2l6ZU9uRXJyb3JcbiAgICB9KSxcblxuICAgIGRpZENyZWF0ZVZpZXc6IGZ1bmN0aW9uIGRpZENyZWF0ZVZpZXcocm9vdCkge1xuICAgICAgYXBwbHlGaWx0ZXJzKCdDUkVBVEVfVklFVycsIE9iamVjdC5hc3NpZ24oe30sIHJvb3QsIHsgdmlldzogcm9vdCB9KSk7XG4gICAgfSxcbiAgICBjcmVhdGU6IGNyZWF0ZSQyLFxuICAgIG1peGluczoge1xuICAgICAgc3R5bGVzOiBbJ3RyYW5zbGF0ZVgnLCAndHJhbnNsYXRlWSddLFxuICAgICAgYW5pbWF0aW9uczoge1xuICAgICAgICB0cmFuc2xhdGVYOiAnc3ByaW5nJyxcbiAgICAgICAgdHJhbnNsYXRlWTogJ3NwcmluZydcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHZhciB0b1BlcmNlbnRhZ2UgPSBmdW5jdGlvbiB0b1BlcmNlbnRhZ2UodmFsdWUpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZCh2YWx1ZSAqIDEwMCk7XG4gIH07XG5cbiAgdmFyIGNyZWF0ZSQzID0gZnVuY3Rpb24gY3JlYXRlKF9yZWYpIHtcbiAgICB2YXIgcm9vdCA9IF9yZWYucm9vdDtcblxuICAgIC8vIG1haW4gc3RhdHVzXG4gICAgdmFyIG1haW4gPSBjcmVhdGVFbGVtZW50JDEoJ3NwYW4nKTtcbiAgICBtYWluLmNsYXNzTmFtZSA9ICdmaWxlcG9uZC0tZmlsZS1zdGF0dXMtbWFpbic7XG4gICAgcm9vdC5hcHBlbmRDaGlsZChtYWluKTtcbiAgICByb290LnJlZi5tYWluID0gbWFpbjtcblxuICAgIC8vIHN1YiBzdGF0dXNcbiAgICB2YXIgc3ViID0gY3JlYXRlRWxlbWVudCQxKCdzcGFuJyk7XG4gICAgc3ViLmNsYXNzTmFtZSA9ICdmaWxlcG9uZC0tZmlsZS1zdGF0dXMtc3ViJztcbiAgICByb290LmFwcGVuZENoaWxkKHN1Yik7XG4gICAgcm9vdC5yZWYuc3ViID0gc3ViO1xuXG4gICAgZGlkU2V0SXRlbUxvYWRQcm9ncmVzcyh7IHJvb3Q6IHJvb3QsIGFjdGlvbjogeyBwcm9ncmVzczogbnVsbCB9IH0pO1xuICB9O1xuXG4gIHZhciBkaWRTZXRJdGVtTG9hZFByb2dyZXNzID0gZnVuY3Rpb24gZGlkU2V0SXRlbUxvYWRQcm9ncmVzcyhfcmVmMikge1xuICAgIHZhciByb290ID0gX3JlZjIucm9vdCxcbiAgICAgIGFjdGlvbiA9IF9yZWYyLmFjdGlvbjtcbiAgICB2YXIgdGl0bGUgPVxuICAgICAgYWN0aW9uLnByb2dyZXNzID09PSBudWxsXG4gICAgICAgID8gcm9vdC5xdWVyeSgnR0VUX0xBQkVMX0ZJTEVfTE9BRElORycpXG4gICAgICAgIDogcm9vdC5xdWVyeSgnR0VUX0xBQkVMX0ZJTEVfTE9BRElORycpICtcbiAgICAgICAgICAnICcgK1xuICAgICAgICAgIHRvUGVyY2VudGFnZShhY3Rpb24ucHJvZ3Jlc3MpICtcbiAgICAgICAgICAnJSc7XG5cbiAgICB0ZXh0KHJvb3QucmVmLm1haW4sIHRpdGxlKTtcbiAgICB0ZXh0KHJvb3QucmVmLnN1Yiwgcm9vdC5xdWVyeSgnR0VUX0xBQkVMX1RBUF9UT19DQU5DRUwnKSk7XG4gIH07XG5cbiAgdmFyIGRpZFNldEl0ZW1Qcm9jZXNzUHJvZ3Jlc3MgPSBmdW5jdGlvbiBkaWRTZXRJdGVtUHJvY2Vzc1Byb2dyZXNzKF9yZWYzKSB7XG4gICAgdmFyIHJvb3QgPSBfcmVmMy5yb290LFxuICAgICAgYWN0aW9uID0gX3JlZjMuYWN0aW9uO1xuICAgIHZhciB0aXRsZSA9XG4gICAgICBhY3Rpb24ucHJvZ3Jlc3MgPT09IG51bGxcbiAgICAgICAgPyByb290LnF1ZXJ5KCdHRVRfTEFCRUxfRklMRV9QUk9DRVNTSU5HJylcbiAgICAgICAgOiByb290LnF1ZXJ5KCdHRVRfTEFCRUxfRklMRV9QUk9DRVNTSU5HJykgK1xuICAgICAgICAgICcgJyArXG4gICAgICAgICAgdG9QZXJjZW50YWdlKGFjdGlvbi5wcm9ncmVzcykgK1xuICAgICAgICAgICclJztcblxuICAgIHRleHQocm9vdC5yZWYubWFpbiwgdGl0bGUpO1xuICAgIHRleHQocm9vdC5yZWYuc3ViLCByb290LnF1ZXJ5KCdHRVRfTEFCRUxfVEFQX1RPX0NBTkNFTCcpKTtcbiAgfTtcblxuICB2YXIgZGlkUmVxdWVzdEl0ZW1Qcm9jZXNzaW5nID0gZnVuY3Rpb24gZGlkUmVxdWVzdEl0ZW1Qcm9jZXNzaW5nKF9yZWY0KSB7XG4gICAgdmFyIHJvb3QgPSBfcmVmNC5yb290O1xuICAgIHRleHQocm9vdC5yZWYubWFpbiwgcm9vdC5xdWVyeSgnR0VUX0xBQkVMX0ZJTEVfUFJPQ0VTU0lORycpKTtcbiAgICB0ZXh0KHJvb3QucmVmLnN1Yiwgcm9vdC5xdWVyeSgnR0VUX0xBQkVMX1RBUF9UT19DQU5DRUwnKSk7XG4gIH07XG5cbiAgdmFyIGRpZEFib3J0SXRlbVByb2Nlc3NpbmcgPSBmdW5jdGlvbiBkaWRBYm9ydEl0ZW1Qcm9jZXNzaW5nKF9yZWY1KSB7XG4gICAgdmFyIHJvb3QgPSBfcmVmNS5yb290O1xuICAgIHRleHQocm9vdC5yZWYubWFpbiwgcm9vdC5xdWVyeSgnR0VUX0xBQkVMX0ZJTEVfUFJPQ0VTU0lOR19BQk9SVEVEJykpO1xuICAgIHRleHQocm9vdC5yZWYuc3ViLCByb290LnF1ZXJ5KCdHRVRfTEFCRUxfVEFQX1RPX1JFVFJZJykpO1xuICB9O1xuXG4gIHZhciBkaWRDb21wbGV0ZUl0ZW1Qcm9jZXNzaW5nID0gZnVuY3Rpb24gZGlkQ29tcGxldGVJdGVtUHJvY2Vzc2luZyhfcmVmNikge1xuICAgIHZhciByb290ID0gX3JlZjYucm9vdDtcbiAgICB0ZXh0KHJvb3QucmVmLm1haW4sIHJvb3QucXVlcnkoJ0dFVF9MQUJFTF9GSUxFX1BST0NFU1NJTkdfQ09NUExFVEUnKSk7XG4gICAgdGV4dChyb290LnJlZi5zdWIsIHJvb3QucXVlcnkoJ0dFVF9MQUJFTF9UQVBfVE9fVU5ETycpKTtcbiAgfTtcblxuICB2YXIgY2xlYXIgPSBmdW5jdGlvbiBjbGVhcihfcmVmNykge1xuICAgIHZhciByb290ID0gX3JlZjcucm9vdDtcbiAgICB0ZXh0KHJvb3QucmVmLm1haW4sICcnKTtcbiAgICB0ZXh0KHJvb3QucmVmLnN1YiwgJycpO1xuICB9O1xuXG4gIHZhciBlcnJvciA9IGZ1bmN0aW9uIGVycm9yKF9yZWY4KSB7XG4gICAgdmFyIHJvb3QgPSBfcmVmOC5yb290LFxuICAgICAgYWN0aW9uID0gX3JlZjguYWN0aW9uO1xuICAgIHRleHQocm9vdC5yZWYubWFpbiwgYWN0aW9uLnN0YXR1cy5tYWluKTtcbiAgICB0ZXh0KHJvb3QucmVmLnN1YiwgYWN0aW9uLnN0YXR1cy5zdWIpO1xuICB9O1xuXG4gIHZhciBmaWxlU3RhdHVzID0gY3JlYXRlVmlldyh7XG4gICAgbmFtZTogJ2ZpbGUtc3RhdHVzJyxcbiAgICBpZ25vcmVSZWN0OiB0cnVlLFxuICAgIGlnbm9yZVJlY3RVcGRhdGU6IHRydWUsXG4gICAgd3JpdGU6IGNyZWF0ZVJvdXRlKHtcbiAgICAgIERJRF9MT0FEX0lURU06IGNsZWFyLFxuICAgICAgRElEX1JFVkVSVF9JVEVNX1BST0NFU1NJTkc6IGNsZWFyLFxuICAgICAgRElEX1JFUVVFU1RfSVRFTV9QUk9DRVNTSU5HOiBkaWRSZXF1ZXN0SXRlbVByb2Nlc3NpbmcsXG4gICAgICBESURfQUJPUlRfSVRFTV9QUk9DRVNTSU5HOiBkaWRBYm9ydEl0ZW1Qcm9jZXNzaW5nLFxuICAgICAgRElEX0NPTVBMRVRFX0lURU1fUFJPQ0VTU0lORzogZGlkQ29tcGxldGVJdGVtUHJvY2Vzc2luZyxcbiAgICAgIERJRF9VUERBVEVfSVRFTV9QUk9DRVNTX1BST0dSRVNTOiBkaWRTZXRJdGVtUHJvY2Vzc1Byb2dyZXNzLFxuICAgICAgRElEX1VQREFURV9JVEVNX0xPQURfUFJPR1JFU1M6IGRpZFNldEl0ZW1Mb2FkUHJvZ3Jlc3MsXG4gICAgICBESURfVEhST1dfSVRFTV9MT0FEX0VSUk9SOiBlcnJvcixcbiAgICAgIERJRF9USFJPV19JVEVNX0lOVkFMSUQ6IGVycm9yLFxuICAgICAgRElEX1RIUk9XX0lURU1fUFJPQ0VTU0lOR19FUlJPUjogZXJyb3IsXG4gICAgICBESURfVEhST1dfSVRFTV9QUk9DRVNTSU5HX1JFVkVSVF9FUlJPUjogZXJyb3IsXG4gICAgICBESURfVEhST1dfSVRFTV9SRU1PVkVfRVJST1I6IGVycm9yXG4gICAgfSksXG5cbiAgICBkaWRDcmVhdGVWaWV3OiBmdW5jdGlvbiBkaWRDcmVhdGVWaWV3KHJvb3QpIHtcbiAgICAgIGFwcGx5RmlsdGVycygnQ1JFQVRFX1ZJRVcnLCBPYmplY3QuYXNzaWduKHt9LCByb290LCB7IHZpZXc6IHJvb3QgfSkpO1xuICAgIH0sXG4gICAgY3JlYXRlOiBjcmVhdGUkMyxcbiAgICBtaXhpbnM6IHtcbiAgICAgIHN0eWxlczogWyd0cmFuc2xhdGVYJywgJ3RyYW5zbGF0ZVknLCAnb3BhY2l0eSddLFxuICAgICAgYW5pbWF0aW9uczoge1xuICAgICAgICBvcGFjaXR5OiB7IHR5cGU6ICd0d2VlbicsIGR1cmF0aW9uOiAyNTAgfSxcbiAgICAgICAgdHJhbnNsYXRlWDogJ3NwcmluZycsXG4gICAgICAgIHRyYW5zbGF0ZVk6ICdzcHJpbmcnXG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogQnV0dG9uIGRlZmluaXRpb25zIGZvciB0aGUgZmlsZSB2aWV3XG4gICAqL1xuXG4gIHZhciBCdXR0b25zID0ge1xuICAgIEFib3J0SXRlbUxvYWQ6IHtcbiAgICAgIGxhYmVsOiAnR0VUX0xBQkVMX0JVVFRPTl9BQk9SVF9JVEVNX0xPQUQnLFxuICAgICAgYWN0aW9uOiAnQUJPUlRfSVRFTV9MT0FEJyxcbiAgICAgIGNsYXNzTmFtZTogJ2ZpbGVwb25kLS1hY3Rpb24tYWJvcnQtaXRlbS1sb2FkJyxcbiAgICAgIGFsaWduOiAnTE9BRF9JTkRJQ0FUT1JfUE9TSVRJT04nIC8vIHJpZ2h0XG4gICAgfSxcbiAgICBSZXRyeUl0ZW1Mb2FkOiB7XG4gICAgICBsYWJlbDogJ0dFVF9MQUJFTF9CVVRUT05fUkVUUllfSVRFTV9MT0FEJyxcbiAgICAgIGFjdGlvbjogJ1JFVFJZX0lURU1fTE9BRCcsXG4gICAgICBpY29uOiAnR0VUX0lDT05fUkVUUlknLFxuICAgICAgY2xhc3NOYW1lOiAnZmlsZXBvbmQtLWFjdGlvbi1yZXRyeS1pdGVtLWxvYWQnLFxuICAgICAgYWxpZ246ICdCVVRUT05fUFJPQ0VTU19JVEVNX1BPU0lUSU9OJyAvLyByaWdodFxuICAgIH0sXG4gICAgUmVtb3ZlSXRlbToge1xuICAgICAgbGFiZWw6ICdHRVRfTEFCRUxfQlVUVE9OX1JFTU9WRV9JVEVNJyxcbiAgICAgIGFjdGlvbjogJ1JFUVVFU1RfUkVNT1ZFX0lURU0nLFxuICAgICAgaWNvbjogJ0dFVF9JQ09OX1JFTU9WRScsXG4gICAgICBjbGFzc05hbWU6ICdmaWxlcG9uZC0tYWN0aW9uLXJlbW92ZS1pdGVtJyxcbiAgICAgIGFsaWduOiAnQlVUVE9OX1JFTU9WRV9JVEVNX1BPU0lUSU9OJyAvLyBsZWZ0XG4gICAgfSxcbiAgICBQcm9jZXNzSXRlbToge1xuICAgICAgbGFiZWw6ICdHRVRfTEFCRUxfQlVUVE9OX1BST0NFU1NfSVRFTScsXG4gICAgICBhY3Rpb246ICdSRVFVRVNUX0lURU1fUFJPQ0VTU0lORycsXG4gICAgICBpY29uOiAnR0VUX0lDT05fUFJPQ0VTUycsXG4gICAgICBjbGFzc05hbWU6ICdmaWxlcG9uZC0tYWN0aW9uLXByb2Nlc3MtaXRlbScsXG4gICAgICBhbGlnbjogJ0JVVFRPTl9QUk9DRVNTX0lURU1fUE9TSVRJT04nIC8vIHJpZ2h0XG4gICAgfSxcbiAgICBBYm9ydEl0ZW1Qcm9jZXNzaW5nOiB7XG4gICAgICBsYWJlbDogJ0dFVF9MQUJFTF9CVVRUT05fQUJPUlRfSVRFTV9QUk9DRVNTSU5HJyxcbiAgICAgIGFjdGlvbjogJ0FCT1JUX0lURU1fUFJPQ0VTU0lORycsXG4gICAgICBjbGFzc05hbWU6ICdmaWxlcG9uZC0tYWN0aW9uLWFib3J0LWl0ZW0tcHJvY2Vzc2luZycsXG4gICAgICBhbGlnbjogJ0JVVFRPTl9QUk9DRVNTX0lURU1fUE9TSVRJT04nIC8vIHJpZ2h0XG4gICAgfSxcbiAgICBSZXRyeUl0ZW1Qcm9jZXNzaW5nOiB7XG4gICAgICBsYWJlbDogJ0dFVF9MQUJFTF9CVVRUT05fUkVUUllfSVRFTV9QUk9DRVNTSU5HJyxcbiAgICAgIGFjdGlvbjogJ1JFVFJZX0lURU1fUFJPQ0VTU0lORycsXG4gICAgICBpY29uOiAnR0VUX0lDT05fUkVUUlknLFxuICAgICAgY2xhc3NOYW1lOiAnZmlsZXBvbmQtLWFjdGlvbi1yZXRyeS1pdGVtLXByb2Nlc3NpbmcnLFxuICAgICAgYWxpZ246ICdCVVRUT05fUFJPQ0VTU19JVEVNX1BPU0lUSU9OJyAvLyByaWdodFxuICAgIH0sXG4gICAgUmV2ZXJ0SXRlbVByb2Nlc3Npbmc6IHtcbiAgICAgIGxhYmVsOiAnR0VUX0xBQkVMX0JVVFRPTl9VTkRPX0lURU1fUFJPQ0VTU0lORycsXG4gICAgICBhY3Rpb246ICdSRVFVRVNUX1JFVkVSVF9JVEVNX1BST0NFU1NJTkcnLFxuICAgICAgaWNvbjogJ0dFVF9JQ09OX1VORE8nLFxuICAgICAgY2xhc3NOYW1lOiAnZmlsZXBvbmQtLWFjdGlvbi1yZXZlcnQtaXRlbS1wcm9jZXNzaW5nJyxcbiAgICAgIGFsaWduOiAnQlVUVE9OX1BST0NFU1NfSVRFTV9QT1NJVElPTicgLy8gcmlnaHRcbiAgICB9XG4gIH07XG5cbiAgLy8gbWFrZSBhIGxpc3Qgb2YgYnV0dG9ucywgd2UgY2FuIHRoZW4gcmVtb3ZlIGJ1dHRvbnMgZnJvbSB0aGlzIGxpc3QgaWYgdGhleSdyZSBkaXNhYmxlZFxuICB2YXIgQnV0dG9uS2V5cyA9IFtdO1xuICBmb3JpbihCdXR0b25zLCBmdW5jdGlvbihrZXkpIHtcbiAgICBCdXR0b25LZXlzLnB1c2goa2V5KTtcbiAgfSk7XG5cbiAgdmFyIGNhbGN1bGF0ZUZpbGVJbmZvT2Zmc2V0ID0gZnVuY3Rpb24gY2FsY3VsYXRlRmlsZUluZm9PZmZzZXQocm9vdCkge1xuICAgIHZhciBidXR0b25SZWN0ID0gcm9vdC5yZWYuYnV0dG9uUmVtb3ZlSXRlbS5yZWN0LmVsZW1lbnQ7XG4gICAgcmV0dXJuIGJ1dHRvblJlY3QuaGlkZGVuID8gbnVsbCA6IGJ1dHRvblJlY3Qud2lkdGggKyBidXR0b25SZWN0LmxlZnQ7XG4gIH07XG5cbiAgdmFyIGNhbGN1bGF0ZUJ1dHRvbldpZHRoID0gZnVuY3Rpb24gY2FsY3VsYXRlQnV0dG9uV2lkdGgocm9vdCkge1xuICAgIHZhciBidXR0b25SZWN0ID0gcm9vdC5yZWYuYnV0dG9uQWJvcnRJdGVtTG9hZC5yZWN0LmVsZW1lbnQ7XG4gICAgcmV0dXJuIGJ1dHRvblJlY3Qud2lkdGg7XG4gIH07XG5cbiAgLy8gRm9yY2Ugb24gZnVsbCBwaXhlbHMgc28gdGV4dCBzdGF5cyBjcmlwc1xuICB2YXIgY2FsY3VsYXRlRmlsZVZlcnRpY2FsQ2VudGVyT2Zmc2V0ID0gZnVuY3Rpb24gY2FsY3VsYXRlRmlsZVZlcnRpY2FsQ2VudGVyT2Zmc2V0KFxuICAgIHJvb3RcbiAgKSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3Iocm9vdC5yZWYuYnV0dG9uUmVtb3ZlSXRlbS5yZWN0LmVsZW1lbnQuaGVpZ2h0IC8gNCk7XG4gIH07XG4gIHZhciBjYWxjdWxhdGVGaWxlSG9yaXpvbnRhbENlbnRlck9mZnNldCA9IGZ1bmN0aW9uIGNhbGN1bGF0ZUZpbGVIb3Jpem9udGFsQ2VudGVyT2Zmc2V0KFxuICAgIHJvb3RcbiAgKSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3Iocm9vdC5yZWYuYnV0dG9uUmVtb3ZlSXRlbS5yZWN0LmVsZW1lbnQubGVmdCAvIDIpO1xuICB9O1xuXG4gIHZhciBnZXRMb2FkSW5kaWNhdG9yQWxpZ25tZW50ID0gZnVuY3Rpb24gZ2V0TG9hZEluZGljYXRvckFsaWdubWVudChyb290KSB7XG4gICAgcmV0dXJuIHJvb3QucXVlcnkoJ0dFVF9TVFlMRV9MT0FEX0lORElDQVRPUl9QT1NJVElPTicpO1xuICB9O1xuICB2YXIgZ2V0UHJvY2Vzc0luZGljYXRvckFsaWdubWVudCA9IGZ1bmN0aW9uIGdldFByb2Nlc3NJbmRpY2F0b3JBbGlnbm1lbnQoXG4gICAgcm9vdFxuICApIHtcbiAgICByZXR1cm4gcm9vdC5xdWVyeSgnR0VUX1NUWUxFX1BST0dSRVNTX0lORElDQVRPUl9QT1NJVElPTicpO1xuICB9O1xuICB2YXIgZ2V0UmVtb3ZlSW5kaWNhdG9yQWxpZ21lbnQgPSBmdW5jdGlvbiBnZXRSZW1vdmVJbmRpY2F0b3JBbGlnbWVudChyb290KSB7XG4gICAgcmV0dXJuIHJvb3QucXVlcnkoJ0dFVF9TVFlMRV9CVVRUT05fUkVNT1ZFX0lURU1fUE9TSVRJT04nKTtcbiAgfTtcblxuICB2YXIgRGVmYXVsdFN0eWxlID0ge1xuICAgIGJ1dHRvbkFib3J0SXRlbUxvYWQ6IHsgb3BhY2l0eTogMCB9LFxuICAgIGJ1dHRvblJldHJ5SXRlbUxvYWQ6IHsgb3BhY2l0eTogMCB9LFxuICAgIGJ1dHRvblJlbW92ZUl0ZW06IHsgb3BhY2l0eTogMCB9LFxuICAgIGJ1dHRvblByb2Nlc3NJdGVtOiB7IG9wYWNpdHk6IDAgfSxcbiAgICBidXR0b25BYm9ydEl0ZW1Qcm9jZXNzaW5nOiB7IG9wYWNpdHk6IDAgfSxcbiAgICBidXR0b25SZXRyeUl0ZW1Qcm9jZXNzaW5nOiB7IG9wYWNpdHk6IDAgfSxcbiAgICBidXR0b25SZXZlcnRJdGVtUHJvY2Vzc2luZzogeyBvcGFjaXR5OiAwIH0sXG4gICAgbG9hZFByb2dyZXNzSW5kaWNhdG9yOiB7IG9wYWNpdHk6IDAsIGFsaWduOiBnZXRMb2FkSW5kaWNhdG9yQWxpZ25tZW50IH0sXG4gICAgcHJvY2Vzc1Byb2dyZXNzSW5kaWNhdG9yOiB7XG4gICAgICBvcGFjaXR5OiAwLFxuICAgICAgYWxpZ246IGdldFByb2Nlc3NJbmRpY2F0b3JBbGlnbm1lbnRcbiAgICB9LFxuICAgIHByb2Nlc3NpbmdDb21wbGV0ZUluZGljYXRvcjogeyBvcGFjaXR5OiAwLCBzY2FsZVg6IDAuNzUsIHNjYWxlWTogMC43NSB9LFxuICAgIGluZm86IHsgdHJhbnNsYXRlWDogMCwgdHJhbnNsYXRlWTogMCwgb3BhY2l0eTogMCB9LFxuICAgIHN0YXR1czogeyB0cmFuc2xhdGVYOiAwLCB0cmFuc2xhdGVZOiAwLCBvcGFjaXR5OiAwIH1cbiAgfTtcblxuICB2YXIgSWRsZVN0eWxlID0ge1xuICAgIGJ1dHRvblJlbW92ZUl0ZW06IHsgb3BhY2l0eTogMSB9LFxuICAgIGJ1dHRvblByb2Nlc3NJdGVtOiB7IG9wYWNpdHk6IDEgfSxcbiAgICBpbmZvOiB7IHRyYW5zbGF0ZVg6IGNhbGN1bGF0ZUZpbGVJbmZvT2Zmc2V0IH0sXG4gICAgc3RhdHVzOiB7IHRyYW5zbGF0ZVg6IGNhbGN1bGF0ZUZpbGVJbmZvT2Zmc2V0IH1cbiAgfTtcblxuICB2YXIgUHJvY2Vzc2luZ1N0eWxlID0ge1xuICAgIGJ1dHRvbkFib3J0SXRlbVByb2Nlc3Npbmc6IHsgb3BhY2l0eTogMSB9LFxuICAgIHByb2Nlc3NQcm9ncmVzc0luZGljYXRvcjogeyBvcGFjaXR5OiAxIH0sXG4gICAgc3RhdHVzOiB7IG9wYWNpdHk6IDEgfVxuICB9O1xuXG4gIHZhciBTdHlsZU1hcCA9IHtcbiAgICBESURfVEhST1dfSVRFTV9JTlZBTElEOiB7XG4gICAgICBidXR0b25SZW1vdmVJdGVtOiB7IG9wYWNpdHk6IDEgfSxcbiAgICAgIGluZm86IHsgdHJhbnNsYXRlWDogY2FsY3VsYXRlRmlsZUluZm9PZmZzZXQgfSxcbiAgICAgIHN0YXR1czogeyB0cmFuc2xhdGVYOiBjYWxjdWxhdGVGaWxlSW5mb09mZnNldCwgb3BhY2l0eTogMSB9XG4gICAgfSxcblxuICAgIERJRF9TVEFSVF9JVEVNX0xPQUQ6IHtcbiAgICAgIGJ1dHRvbkFib3J0SXRlbUxvYWQ6IHsgb3BhY2l0eTogMSB9LFxuICAgICAgbG9hZFByb2dyZXNzSW5kaWNhdG9yOiB7IG9wYWNpdHk6IDEgfSxcbiAgICAgIHN0YXR1czogeyBvcGFjaXR5OiAxIH1cbiAgICB9LFxuXG4gICAgRElEX1RIUk9XX0lURU1fTE9BRF9FUlJPUjoge1xuICAgICAgYnV0dG9uUmV0cnlJdGVtTG9hZDogeyBvcGFjaXR5OiAxIH0sXG4gICAgICBidXR0b25SZW1vdmVJdGVtOiB7IG9wYWNpdHk6IDEgfSxcbiAgICAgIGluZm86IHsgdHJhbnNsYXRlWDogY2FsY3VsYXRlRmlsZUluZm9PZmZzZXQgfSxcbiAgICAgIHN0YXR1czogeyBvcGFjaXR5OiAxIH1cbiAgICB9LFxuXG4gICAgRElEX1NUQVJUX0lURU1fUkVNT1ZFOiB7XG4gICAgICBwcm9jZXNzUHJvZ3Jlc3NJbmRpY2F0b3I6IHtcbiAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgYWxpZ246IGdldFJlbW92ZUluZGljYXRvckFsaWdtZW50XG4gICAgICB9LFxuICAgICAgaW5mbzogeyB0cmFuc2xhdGVYOiBjYWxjdWxhdGVGaWxlSW5mb09mZnNldCB9LFxuICAgICAgc3RhdHVzOiB7IG9wYWNpdHk6IDAgfVxuICAgIH0sXG5cbiAgICBESURfVEhST1dfSVRFTV9SRU1PVkVfRVJST1I6IHtcbiAgICAgIHByb2Nlc3NQcm9ncmVzc0luZGljYXRvcjoge1xuICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgICBhbGlnbjogZ2V0UmVtb3ZlSW5kaWNhdG9yQWxpZ21lbnRcbiAgICAgIH0sXG4gICAgICBidXR0b25SZW1vdmVJdGVtOiB7IG9wYWNpdHk6IDEgfSxcbiAgICAgIGluZm86IHsgdHJhbnNsYXRlWDogY2FsY3VsYXRlRmlsZUluZm9PZmZzZXQgfSxcbiAgICAgIHN0YXR1czogeyBvcGFjaXR5OiAxLCB0cmFuc2xhdGVYOiBjYWxjdWxhdGVGaWxlSW5mb09mZnNldCB9XG4gICAgfSxcblxuICAgIERJRF9MT0FEX0lURU06IElkbGVTdHlsZSxcbiAgICBESURfTE9BRF9MT0NBTF9JVEVNOiB7XG4gICAgICBidXR0b25SZW1vdmVJdGVtOiB7IG9wYWNpdHk6IDEgfSxcbiAgICAgIGluZm86IHsgdHJhbnNsYXRlWDogY2FsY3VsYXRlRmlsZUluZm9PZmZzZXQgfSxcbiAgICAgIHN0YXR1czogeyB0cmFuc2xhdGVYOiBjYWxjdWxhdGVGaWxlSW5mb09mZnNldCB9XG4gICAgfSxcblxuICAgIERJRF9TVEFSVF9JVEVNX1BST0NFU1NJTkc6IFByb2Nlc3NpbmdTdHlsZSxcbiAgICBESURfUkVRVUVTVF9JVEVNX1BST0NFU1NJTkc6IFByb2Nlc3NpbmdTdHlsZSxcbiAgICBESURfVVBEQVRFX0lURU1fUFJPQ0VTU19QUk9HUkVTUzogUHJvY2Vzc2luZ1N0eWxlLFxuICAgIERJRF9DT01QTEVURV9JVEVNX1BST0NFU1NJTkc6IHtcbiAgICAgIGJ1dHRvblJldmVydEl0ZW1Qcm9jZXNzaW5nOiB7IG9wYWNpdHk6IDEgfSxcbiAgICAgIGluZm86IHsgb3BhY2l0eTogMSB9LFxuICAgICAgc3RhdHVzOiB7IG9wYWNpdHk6IDEgfVxuICAgIH0sXG5cbiAgICBESURfVEhST1dfSVRFTV9QUk9DRVNTSU5HX0VSUk9SOiB7XG4gICAgICBidXR0b25SZW1vdmVJdGVtOiB7IG9wYWNpdHk6IDEgfSxcbiAgICAgIGJ1dHRvblJldHJ5SXRlbVByb2Nlc3Npbmc6IHsgb3BhY2l0eTogMSB9LFxuICAgICAgc3RhdHVzOiB7IG9wYWNpdHk6IDEgfSxcbiAgICAgIGluZm86IHsgdHJhbnNsYXRlWDogY2FsY3VsYXRlRmlsZUluZm9PZmZzZXQgfVxuICAgIH0sXG5cbiAgICBESURfVEhST1dfSVRFTV9QUk9DRVNTSU5HX1JFVkVSVF9FUlJPUjoge1xuICAgICAgYnV0dG9uUmV2ZXJ0SXRlbVByb2Nlc3Npbmc6IHsgb3BhY2l0eTogMSB9LFxuICAgICAgc3RhdHVzOiB7IG9wYWNpdHk6IDEgfSxcbiAgICAgIGluZm86IHsgb3BhY2l0eTogMSB9XG4gICAgfSxcblxuICAgIERJRF9BQk9SVF9JVEVNX1BST0NFU1NJTkc6IHtcbiAgICAgIGJ1dHRvblJlbW92ZUl0ZW06IHsgb3BhY2l0eTogMSB9LFxuICAgICAgYnV0dG9uUHJvY2Vzc0l0ZW06IHsgb3BhY2l0eTogMSB9LFxuICAgICAgaW5mbzogeyB0cmFuc2xhdGVYOiBjYWxjdWxhdGVGaWxlSW5mb09mZnNldCB9LFxuICAgICAgc3RhdHVzOiB7IG9wYWNpdHk6IDEgfVxuICAgIH0sXG5cbiAgICBESURfUkVWRVJUX0lURU1fUFJPQ0VTU0lORzogSWRsZVN0eWxlXG4gIH07XG5cbiAgLy8gY29tcGxldGUgaW5kaWNhdG9yIHZpZXdcbiAgdmFyIHByb2Nlc3NpbmdDb21wbGV0ZUluZGljYXRvclZpZXcgPSBjcmVhdGVWaWV3KHtcbiAgICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZShfcmVmKSB7XG4gICAgICB2YXIgcm9vdCA9IF9yZWYucm9vdDtcbiAgICAgIHJvb3QuZWxlbWVudC5pbm5lckhUTUwgPSByb290LnF1ZXJ5KCdHRVRfSUNPTl9ET05FJyk7XG4gICAgfSxcbiAgICBuYW1lOiAncHJvY2Vzc2luZy1jb21wbGV0ZS1pbmRpY2F0b3InLFxuICAgIGlnbm9yZVJlY3Q6IHRydWUsXG4gICAgbWl4aW5zOiB7XG4gICAgICBzdHlsZXM6IFsnc2NhbGVYJywgJ3NjYWxlWScsICdvcGFjaXR5J10sXG4gICAgICBhbmltYXRpb25zOiB7XG4gICAgICAgIHNjYWxlWDogJ3NwcmluZycsXG4gICAgICAgIHNjYWxlWTogJ3NwcmluZycsXG4gICAgICAgIG9wYWNpdHk6IHsgdHlwZTogJ3R3ZWVuJywgZHVyYXRpb246IDI1MCB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogQ3JlYXRlcyB0aGUgZmlsZSB2aWV3XG4gICAqL1xuICB2YXIgY3JlYXRlJDQgPSBmdW5jdGlvbiBjcmVhdGUoX3JlZjIpIHtcbiAgICB2YXIgcm9vdCA9IF9yZWYyLnJvb3QsXG4gICAgICBwcm9wcyA9IF9yZWYyLnByb3BzO1xuICAgIHZhciBpZCA9IHByb3BzLmlkO1xuXG4gICAgLy8gYWxsb3cgcmV2ZXJ0aW5nIHVwbG9hZFxuICAgIHZhciBhbGxvd1JldmVydCA9IHJvb3QucXVlcnkoJ0dFVF9BTExPV19SRVZFUlQnKTtcblxuICAgIC8vIGFsbG93IHJlbW92ZSBmaWxlXG4gICAgdmFyIGFsbG93UmVtb3ZlID0gcm9vdC5xdWVyeSgnR0VUX0FMTE9XX1JFTU9WRScpO1xuXG4gICAgLy8gYWxsb3cgcHJvY2Vzc2luZyB1cGxvYWRcbiAgICB2YXIgYWxsb3dQcm9jZXNzID0gcm9vdC5xdWVyeSgnR0VUX0FMTE9XX1BST0NFU1MnKTtcblxuICAgIC8vIGlzIGluc3RhbnQgdXBsb2FkaW5nLCBuZWVkIHRoaXMgdG8gZGV0ZXJtaW5lIHRoZSBpY29uIG9mIHRoZSB1bmRvIGJ1dHRvblxuICAgIHZhciBpbnN0YW50VXBsb2FkID0gcm9vdC5xdWVyeSgnR0VUX0lOU1RBTlRfVVBMT0FEJyk7XG5cbiAgICAvLyBpcyBhc3luYyBzZXQgdXBcbiAgICB2YXIgaXNBc3luYyA9IHJvb3QucXVlcnkoJ0lTX0FTWU5DJyk7XG5cbiAgICAvLyBzaG91bGQgYWxpZ24gcmVtb3ZlIGl0ZW0gYnV0dG9uc1xuICAgIHZhciBhbGlnblJlbW92ZUl0ZW1CdXR0b24gPSByb290LnF1ZXJ5KFxuICAgICAgJ0dFVF9TVFlMRV9CVVRUT05fUkVNT1ZFX0lURU1fQUxJR04nXG4gICAgKTtcblxuICAgIC8vIGVuYWJsZWQgYnV0dG9ucyBhcnJheVxuICAgIHZhciBidXR0b25GaWx0ZXI7XG4gICAgaWYgKGlzQXN5bmMpIHtcbiAgICAgIGlmIChhbGxvd1Byb2Nlc3MgJiYgIWFsbG93UmV2ZXJ0KSB7XG4gICAgICAgIC8vIG9ubHkgcmVtb3ZlIHJldmVydCBidXR0b25cbiAgICAgICAgYnV0dG9uRmlsdGVyID0gZnVuY3Rpb24gYnV0dG9uRmlsdGVyKGtleSkge1xuICAgICAgICAgIHJldHVybiAhL1JldmVydEl0ZW1Qcm9jZXNzaW5nLy50ZXN0KGtleSk7XG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKCFhbGxvd1Byb2Nlc3MgJiYgYWxsb3dSZXZlcnQpIHtcbiAgICAgICAgLy8gb25seSByZW1vdmUgcHJvY2VzcyBidXR0b25cbiAgICAgICAgYnV0dG9uRmlsdGVyID0gZnVuY3Rpb24gYnV0dG9uRmlsdGVyKGtleSkge1xuICAgICAgICAgIHJldHVybiAhL1Byb2Nlc3NJdGVtfFJldHJ5SXRlbVByb2Nlc3Npbmd8QWJvcnRJdGVtUHJvY2Vzc2luZy8udGVzdChcbiAgICAgICAgICAgIGtleVxuICAgICAgICAgICk7XG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKCFhbGxvd1Byb2Nlc3MgJiYgIWFsbG93UmV2ZXJ0KSB7XG4gICAgICAgIC8vIHJlbW92ZSBhbGwgcHJvY2VzcyBidXR0b25zXG4gICAgICAgIGJ1dHRvbkZpbHRlciA9IGZ1bmN0aW9uIGJ1dHRvbkZpbHRlcihrZXkpIHtcbiAgICAgICAgICByZXR1cm4gIS9Qcm9jZXNzLy50ZXN0KGtleSk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG5vIHByb2Nlc3MgY29udHJvbHMgYXZhaWxhYmxlXG4gICAgICBidXR0b25GaWx0ZXIgPSBmdW5jdGlvbiBidXR0b25GaWx0ZXIoa2V5KSB7XG4gICAgICAgIHJldHVybiAhL1Byb2Nlc3MvLnRlc3Qoa2V5KTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIGVuYWJsZWRCdXR0b25zID0gYnV0dG9uRmlsdGVyXG4gICAgICA/IEJ1dHRvbktleXMuZmlsdGVyKGJ1dHRvbkZpbHRlcilcbiAgICAgIDogQnV0dG9uS2V5cy5jb25jYXQoKTtcblxuICAgIC8vIHVwZGF0ZSBpY29uIGFuZCBsYWJlbCBmb3IgcmV2ZXJ0IGJ1dHRvbiB3aGVuIGluc3RhbnQgdXBsb2FkaW5nXG4gICAgaWYgKGluc3RhbnRVcGxvYWQgJiYgYWxsb3dSZXZlcnQpIHtcbiAgICAgIEJ1dHRvbnNbJ1JldmVydEl0ZW1Qcm9jZXNzaW5nJ10ubGFiZWwgPSAnR0VUX0xBQkVMX0JVVFRPTl9SRU1PVkVfSVRFTSc7XG4gICAgICBCdXR0b25zWydSZXZlcnRJdGVtUHJvY2Vzc2luZyddLmljb24gPSAnR0VUX0lDT05fUkVNT1ZFJztcbiAgICB9XG5cbiAgICAvLyByZW1vdmUgbGFzdCBidXR0b24gKHJldmVydCkgaWYgbm90IGFsbG93ZWRcbiAgICBpZiAoaXNBc3luYyAmJiAhYWxsb3dSZXZlcnQpIHtcbiAgICAgIHZhciBtYXAgPSBTdHlsZU1hcFsnRElEX0NPTVBMRVRFX0lURU1fUFJPQ0VTU0lORyddO1xuICAgICAgbWFwLmluZm8udHJhbnNsYXRlWCA9IGNhbGN1bGF0ZUZpbGVIb3Jpem9udGFsQ2VudGVyT2Zmc2V0O1xuICAgICAgbWFwLmluZm8udHJhbnNsYXRlWSA9IGNhbGN1bGF0ZUZpbGVWZXJ0aWNhbENlbnRlck9mZnNldDtcbiAgICAgIG1hcC5zdGF0dXMudHJhbnNsYXRlWSA9IGNhbGN1bGF0ZUZpbGVWZXJ0aWNhbENlbnRlck9mZnNldDtcbiAgICAgIG1hcC5wcm9jZXNzaW5nQ29tcGxldGVJbmRpY2F0b3IgPSB7IG9wYWNpdHk6IDEsIHNjYWxlWDogMSwgc2NhbGVZOiAxIH07XG4gICAgfVxuXG4gICAgLy8gc2hvdWxkIGFsaWduIGNlbnRlclxuICAgIGlmIChpc0FzeW5jICYmICFhbGxvd1Byb2Nlc3MpIHtcbiAgICAgIFtcbiAgICAgICAgJ0RJRF9TVEFSVF9JVEVNX1BST0NFU1NJTkcnLFxuICAgICAgICAnRElEX1JFUVVFU1RfSVRFTV9QUk9DRVNTSU5HJyxcbiAgICAgICAgJ0RJRF9VUERBVEVfSVRFTV9QUk9DRVNTX1BST0dSRVNTJyxcbiAgICAgICAgJ0RJRF9USFJPV19JVEVNX1BST0NFU1NJTkdfRVJST1InXG4gICAgICBdLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIFN0eWxlTWFwW2tleV0uc3RhdHVzLnRyYW5zbGF0ZVkgPSBjYWxjdWxhdGVGaWxlVmVydGljYWxDZW50ZXJPZmZzZXQ7XG4gICAgICB9KTtcbiAgICAgIFN0eWxlTWFwW1xuICAgICAgICAnRElEX1RIUk9XX0lURU1fUFJPQ0VTU0lOR19FUlJPUidcbiAgICAgIF0uc3RhdHVzLnRyYW5zbGF0ZVggPSBjYWxjdWxhdGVCdXR0b25XaWR0aDtcbiAgICB9XG5cbiAgICAvLyBtb3ZlIHJlbW92ZSBidXR0b24gdG8gcmlnaHRcbiAgICBpZiAoYWxpZ25SZW1vdmVJdGVtQnV0dG9uICYmIGFsbG93UmV2ZXJ0KSB7XG4gICAgICBCdXR0b25zWydSZXZlcnRJdGVtUHJvY2Vzc2luZyddLmFsaWduID0gJ0JVVFRPTl9SRU1PVkVfSVRFTV9QT1NJVElPTic7XG4gICAgICB2YXIgX21hcCA9IFN0eWxlTWFwWydESURfQ09NUExFVEVfSVRFTV9QUk9DRVNTSU5HJ107XG4gICAgICBfbWFwLmluZm8udHJhbnNsYXRlWCA9IGNhbGN1bGF0ZUZpbGVJbmZvT2Zmc2V0O1xuICAgICAgX21hcC5zdGF0dXMudHJhbnNsYXRlWSA9IGNhbGN1bGF0ZUZpbGVWZXJ0aWNhbENlbnRlck9mZnNldDtcbiAgICAgIF9tYXAucHJvY2Vzc2luZ0NvbXBsZXRlSW5kaWNhdG9yID0geyBvcGFjaXR5OiAxLCBzY2FsZVg6IDEsIHNjYWxlWTogMSB9O1xuICAgIH1cblxuICAgIGlmICghYWxsb3dSZW1vdmUpIHtcbiAgICAgIEJ1dHRvbnNbJ1JlbW92ZUl0ZW0nXS5kaXNhYmxlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gY3JlYXRlIHRoZSBidXR0b24gdmlld3NcbiAgICBmb3JpbihCdXR0b25zLCBmdW5jdGlvbihrZXksIGRlZmluaXRpb24pIHtcbiAgICAgIC8vIGNyZWF0ZSBidXR0b25cbiAgICAgIHZhciBidXR0b25WaWV3ID0gcm9vdC5jcmVhdGVDaGlsZFZpZXcoZmlsZUFjdGlvbkJ1dHRvbiwge1xuICAgICAgICBsYWJlbDogcm9vdC5xdWVyeShkZWZpbml0aW9uLmxhYmVsKSxcbiAgICAgICAgaWNvbjogcm9vdC5xdWVyeShkZWZpbml0aW9uLmljb24pLFxuICAgICAgICBvcGFjaXR5OiAwXG4gICAgICB9KTtcblxuICAgICAgLy8gc2hvdWxkIGJlIGFwcGVuZGVkP1xuICAgICAgaWYgKGVuYWJsZWRCdXR0b25zLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgcm9vdC5hcHBlbmRDaGlsZFZpZXcoYnV0dG9uVmlldyk7XG4gICAgICB9XG5cbiAgICAgIC8vIHRvZ2dsZVxuICAgICAgaWYgKGRlZmluaXRpb24uZGlzYWJsZWQpIHtcbiAgICAgICAgYnV0dG9uVmlldy5lbGVtZW50LnNldEF0dHJpYnV0ZSgnZGlzYWJsZWQnLCAnZGlzYWJsZWQnKTtcbiAgICAgICAgYnV0dG9uVmlldy5lbGVtZW50LnNldEF0dHJpYnV0ZSgnaGlkZGVuJywgJ2hpZGRlbicpO1xuICAgICAgfVxuXG4gICAgICAvLyBhZGQgcG9zaXRpb24gYXR0cmlidXRlXG4gICAgICBidXR0b25WaWV3LmVsZW1lbnQuZGF0YXNldC5hbGlnbiA9IHJvb3QucXVlcnkoXG4gICAgICAgICdHRVRfU1RZTEVfJyArIGRlZmluaXRpb24uYWxpZ25cbiAgICAgICk7XG5cbiAgICAgIC8vIGFkZCBjbGFzc1xuICAgICAgYnV0dG9uVmlldy5lbGVtZW50LmNsYXNzTGlzdC5hZGQoZGVmaW5pdGlvbi5jbGFzc05hbWUpO1xuXG4gICAgICAvLyBoYW5kbGUgaW50ZXJhY3Rpb25zXG4gICAgICBidXR0b25WaWV3Lm9uKCdjbGljaycsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgaWYgKGRlZmluaXRpb24uZGlzYWJsZWQpIHJldHVybjtcbiAgICAgICAgcm9vdC5kaXNwYXRjaChkZWZpbml0aW9uLmFjdGlvbiwgeyBxdWVyeTogaWQgfSk7XG4gICAgICB9KTtcblxuICAgICAgLy8gc2V0IHJlZmVyZW5jZVxuICAgICAgcm9vdC5yZWZbJ2J1dHRvbicgKyBrZXldID0gYnV0dG9uVmlldztcbiAgICB9KTtcblxuICAgIC8vIGNoZWNrbWFya1xuICAgIHJvb3QucmVmLnByb2Nlc3NpbmdDb21wbGV0ZUluZGljYXRvciA9IHJvb3QuYXBwZW5kQ2hpbGRWaWV3KFxuICAgICAgcm9vdC5jcmVhdGVDaGlsZFZpZXcocHJvY2Vzc2luZ0NvbXBsZXRlSW5kaWNhdG9yVmlldylcbiAgICApO1xuICAgIHJvb3QucmVmLnByb2Nlc3NpbmdDb21wbGV0ZUluZGljYXRvci5lbGVtZW50LmRhdGFzZXQuYWxpZ24gPSByb290LnF1ZXJ5KFxuICAgICAgJ0dFVF9TVFlMRV9CVVRUT05fUFJPQ0VTU19JVEVNX1BPU0lUSU9OJ1xuICAgICk7XG5cbiAgICAvLyBjcmVhdGUgZmlsZSBpbmZvIHZpZXdcbiAgICByb290LnJlZi5pbmZvID0gcm9vdC5hcHBlbmRDaGlsZFZpZXcoXG4gICAgICByb290LmNyZWF0ZUNoaWxkVmlldyhmaWxlSW5mbywgeyBpZDogaWQgfSlcbiAgICApO1xuXG4gICAgLy8gY3JlYXRlIGZpbGUgc3RhdHVzIHZpZXdcbiAgICByb290LnJlZi5zdGF0dXMgPSByb290LmFwcGVuZENoaWxkVmlldyhcbiAgICAgIHJvb3QuY3JlYXRlQ2hpbGRWaWV3KGZpbGVTdGF0dXMsIHsgaWQ6IGlkIH0pXG4gICAgKTtcblxuICAgIC8vIGFkZCBwcm9ncmVzcyBpbmRpY2F0b3JzXG4gICAgdmFyIGxvYWRJbmRpY2F0b3JWaWV3ID0gcm9vdC5hcHBlbmRDaGlsZFZpZXcoXG4gICAgICByb290LmNyZWF0ZUNoaWxkVmlldyhwcm9ncmVzc0luZGljYXRvciwge1xuICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgICBhbGlnbjogcm9vdC5xdWVyeSgnR0VUX1NUWUxFX0xPQURfSU5ESUNBVE9SX1BPU0lUSU9OJylcbiAgICAgIH0pXG4gICAgKTtcblxuICAgIGxvYWRJbmRpY2F0b3JWaWV3LmVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnZmlsZXBvbmQtLWxvYWQtaW5kaWNhdG9yJyk7XG4gICAgcm9vdC5yZWYubG9hZFByb2dyZXNzSW5kaWNhdG9yID0gbG9hZEluZGljYXRvclZpZXc7XG5cbiAgICB2YXIgcHJvZ3Jlc3NJbmRpY2F0b3JWaWV3ID0gcm9vdC5hcHBlbmRDaGlsZFZpZXcoXG4gICAgICByb290LmNyZWF0ZUNoaWxkVmlldyhwcm9ncmVzc0luZGljYXRvciwge1xuICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgICBhbGlnbjogcm9vdC5xdWVyeSgnR0VUX1NUWUxFX1BST0dSRVNTX0lORElDQVRPUl9QT1NJVElPTicpXG4gICAgICB9KVxuICAgICk7XG5cbiAgICBwcm9ncmVzc0luZGljYXRvclZpZXcuZWxlbWVudC5jbGFzc0xpc3QuYWRkKCdmaWxlcG9uZC0tcHJvY2Vzcy1pbmRpY2F0b3InKTtcbiAgICByb290LnJlZi5wcm9jZXNzUHJvZ3Jlc3NJbmRpY2F0b3IgPSBwcm9ncmVzc0luZGljYXRvclZpZXc7XG5cbiAgICAvLyBjdXJyZW50IGFjdGl2ZSBzdHlsZXNcbiAgICByb290LnJlZi5hY3RpdmVTdHlsZXMgPSBbXTtcbiAgfTtcblxuICB2YXIgd3JpdGUkMiA9IGZ1bmN0aW9uIHdyaXRlKF9yZWYzKSB7XG4gICAgdmFyIHJvb3QgPSBfcmVmMy5yb290LFxuICAgICAgYWN0aW9ucyA9IF9yZWYzLmFjdGlvbnMsXG4gICAgICBwcm9wcyA9IF9yZWYzLnByb3BzO1xuXG4gICAgLy8gcm91dGUgYWN0aW9uc1xuICAgIHJvdXRlKHsgcm9vdDogcm9vdCwgYWN0aW9uczogYWN0aW9ucywgcHJvcHM6IHByb3BzIH0pO1xuXG4gICAgLy8gc2VsZWN0IGxhc3Qgc3RhdGUgY2hhbmdlIGFjdGlvblxuICAgIHZhciBhY3Rpb24gPSBhY3Rpb25zXG4gICAgICAuY29uY2F0KClcbiAgICAgIC5maWx0ZXIoZnVuY3Rpb24oYWN0aW9uKSB7XG4gICAgICAgIHJldHVybiAvXkRJRF8vLnRlc3QoYWN0aW9uLnR5cGUpO1xuICAgICAgfSlcbiAgICAgIC5yZXZlcnNlKClcbiAgICAgIC5maW5kKGZ1bmN0aW9uKGFjdGlvbikge1xuICAgICAgICByZXR1cm4gU3R5bGVNYXBbYWN0aW9uLnR5cGVdO1xuICAgICAgfSk7XG5cbiAgICAvLyBhIG5ldyBhY3Rpb24gaGFwcGVuZWQsIGxldCdzIGdldCB0aGUgbWF0Y2hpbmcgc3R5bGVzXG4gICAgaWYgKGFjdGlvbikge1xuICAgICAgLy8gZGVmaW5lIG5ldyBhY3RpdmUgc3R5bGVzXG4gICAgICByb290LnJlZi5hY3RpdmVTdHlsZXMgPSBbXTtcblxuICAgICAgdmFyIHN0eWxlc1RvQXBwbHkgPSBTdHlsZU1hcFthY3Rpb24udHlwZV07XG4gICAgICBmb3JpbihEZWZhdWx0U3R5bGUsIGZ1bmN0aW9uKG5hbWUsIGRlZmF1bHRTdHlsZXMpIHtcbiAgICAgICAgLy8gZ2V0IHJlZmVyZW5jZSB0byBjb250cm9sXG4gICAgICAgIHZhciBjb250cm9sID0gcm9vdC5yZWZbbmFtZV07XG5cbiAgICAgICAgLy8gbG9vcCBvdmVyIGFsbCBzdHlsZXMgZm9yIHRoaXMgY29udHJvbFxuICAgICAgICBmb3JpbihkZWZhdWx0U3R5bGVzLCBmdW5jdGlvbihrZXksIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICAgIHZhciB2YWx1ZSA9XG4gICAgICAgICAgICBzdHlsZXNUb0FwcGx5W25hbWVdICYmXG4gICAgICAgICAgICB0eXBlb2Ygc3R5bGVzVG9BcHBseVtuYW1lXVtrZXldICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgICA/IHN0eWxlc1RvQXBwbHlbbmFtZV1ba2V5XVxuICAgICAgICAgICAgICA6IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgICByb290LnJlZi5hY3RpdmVTdHlsZXMucHVzaCh7XG4gICAgICAgICAgICBjb250cm9sOiBjb250cm9sLFxuICAgICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBhcHBseSBhY3RpdmUgc3R5bGVzIHRvIGVsZW1lbnRcbiAgICByb290LnJlZi5hY3RpdmVTdHlsZXMuZm9yRWFjaChmdW5jdGlvbihfcmVmNCkge1xuICAgICAgdmFyIGNvbnRyb2wgPSBfcmVmNC5jb250cm9sLFxuICAgICAgICBrZXkgPSBfcmVmNC5rZXksXG4gICAgICAgIHZhbHVlID0gX3JlZjQudmFsdWU7XG4gICAgICBjb250cm9sW2tleV0gPSB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgPyB2YWx1ZShyb290KSA6IHZhbHVlO1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciByb3V0ZSA9IGNyZWF0ZVJvdXRlKHtcbiAgICBESURfU0VUX0xBQkVMX0JVVFRPTl9BQk9SVF9JVEVNX1BST0NFU1NJTkc6IGZ1bmN0aW9uIERJRF9TRVRfTEFCRUxfQlVUVE9OX0FCT1JUX0lURU1fUFJPQ0VTU0lORyhcbiAgICAgIF9yZWY1XG4gICAgKSB7XG4gICAgICB2YXIgcm9vdCA9IF9yZWY1LnJvb3QsXG4gICAgICAgIGFjdGlvbiA9IF9yZWY1LmFjdGlvbjtcbiAgICAgIHJvb3QucmVmLmJ1dHRvbkFib3J0SXRlbVByb2Nlc3NpbmcubGFiZWwgPSBhY3Rpb24udmFsdWU7XG4gICAgfSxcbiAgICBESURfU0VUX0xBQkVMX0JVVFRPTl9BQk9SVF9JVEVNX0xPQUQ6IGZ1bmN0aW9uIERJRF9TRVRfTEFCRUxfQlVUVE9OX0FCT1JUX0lURU1fTE9BRChcbiAgICAgIF9yZWY2XG4gICAgKSB7XG4gICAgICB2YXIgcm9vdCA9IF9yZWY2LnJvb3QsXG4gICAgICAgIGFjdGlvbiA9IF9yZWY2LmFjdGlvbjtcbiAgICAgIHJvb3QucmVmLmJ1dHRvbkFib3J0SXRlbUxvYWQubGFiZWwgPSBhY3Rpb24udmFsdWU7XG4gICAgfSxcbiAgICBESURfU0VUX0xBQkVMX0JVVFRPTl9BQk9SVF9JVEVNX1JFTU9WQUw6IGZ1bmN0aW9uIERJRF9TRVRfTEFCRUxfQlVUVE9OX0FCT1JUX0lURU1fUkVNT1ZBTChcbiAgICAgIF9yZWY3XG4gICAgKSB7XG4gICAgICB2YXIgcm9vdCA9IF9yZWY3LnJvb3QsXG4gICAgICAgIGFjdGlvbiA9IF9yZWY3LmFjdGlvbjtcbiAgICAgIHJvb3QucmVmLmJ1dHRvbkFib3J0SXRlbVJlbW92YWwubGFiZWwgPSBhY3Rpb24udmFsdWU7XG4gICAgfSxcbiAgICBESURfUkVRVUVTVF9JVEVNX1BST0NFU1NJTkc6IGZ1bmN0aW9uIERJRF9SRVFVRVNUX0lURU1fUFJPQ0VTU0lORyhfcmVmOCkge1xuICAgICAgdmFyIHJvb3QgPSBfcmVmOC5yb290O1xuICAgICAgcm9vdC5yZWYucHJvY2Vzc1Byb2dyZXNzSW5kaWNhdG9yLnNwaW4gPSB0cnVlO1xuICAgICAgcm9vdC5yZWYucHJvY2Vzc1Byb2dyZXNzSW5kaWNhdG9yLnByb2dyZXNzID0gMDtcbiAgICB9LFxuICAgIERJRF9TVEFSVF9JVEVNX0xPQUQ6IGZ1bmN0aW9uIERJRF9TVEFSVF9JVEVNX0xPQUQoX3JlZjkpIHtcbiAgICAgIHZhciByb290ID0gX3JlZjkucm9vdDtcbiAgICAgIHJvb3QucmVmLmxvYWRQcm9ncmVzc0luZGljYXRvci5zcGluID0gdHJ1ZTtcbiAgICAgIHJvb3QucmVmLmxvYWRQcm9ncmVzc0luZGljYXRvci5wcm9ncmVzcyA9IDA7XG4gICAgfSxcbiAgICBESURfU1RBUlRfSVRFTV9SRU1PVkU6IGZ1bmN0aW9uIERJRF9TVEFSVF9JVEVNX1JFTU9WRShfcmVmMTApIHtcbiAgICAgIHZhciByb290ID0gX3JlZjEwLnJvb3Q7XG4gICAgICByb290LnJlZi5wcm9jZXNzUHJvZ3Jlc3NJbmRpY2F0b3Iuc3BpbiA9IHRydWU7XG4gICAgICByb290LnJlZi5wcm9jZXNzUHJvZ3Jlc3NJbmRpY2F0b3IucHJvZ3Jlc3MgPSAwO1xuICAgIH0sXG4gICAgRElEX1VQREFURV9JVEVNX0xPQURfUFJPR1JFU1M6IGZ1bmN0aW9uIERJRF9VUERBVEVfSVRFTV9MT0FEX1BST0dSRVNTKFxuICAgICAgX3JlZjExXG4gICAgKSB7XG4gICAgICB2YXIgcm9vdCA9IF9yZWYxMS5yb290LFxuICAgICAgICBhY3Rpb24gPSBfcmVmMTEuYWN0aW9uO1xuICAgICAgcm9vdC5yZWYubG9hZFByb2dyZXNzSW5kaWNhdG9yLnNwaW4gPSBmYWxzZTtcbiAgICAgIHJvb3QucmVmLmxvYWRQcm9ncmVzc0luZGljYXRvci5wcm9ncmVzcyA9IGFjdGlvbi5wcm9ncmVzcztcbiAgICB9LFxuICAgIERJRF9VUERBVEVfSVRFTV9QUk9DRVNTX1BST0dSRVNTOiBmdW5jdGlvbiBESURfVVBEQVRFX0lURU1fUFJPQ0VTU19QUk9HUkVTUyhcbiAgICAgIF9yZWYxMlxuICAgICkge1xuICAgICAgdmFyIHJvb3QgPSBfcmVmMTIucm9vdCxcbiAgICAgICAgYWN0aW9uID0gX3JlZjEyLmFjdGlvbjtcbiAgICAgIHJvb3QucmVmLnByb2Nlc3NQcm9ncmVzc0luZGljYXRvci5zcGluID0gZmFsc2U7XG4gICAgICByb290LnJlZi5wcm9jZXNzUHJvZ3Jlc3NJbmRpY2F0b3IucHJvZ3Jlc3MgPSBhY3Rpb24ucHJvZ3Jlc3M7XG4gICAgfVxuICB9KTtcblxuICB2YXIgZmlsZSA9IGNyZWF0ZVZpZXcoe1xuICAgIGNyZWF0ZTogY3JlYXRlJDQsXG4gICAgd3JpdGU6IHdyaXRlJDIsXG4gICAgZGlkQ3JlYXRlVmlldzogZnVuY3Rpb24gZGlkQ3JlYXRlVmlldyhyb290KSB7XG4gICAgICBhcHBseUZpbHRlcnMoJ0NSRUFURV9WSUVXJywgT2JqZWN0LmFzc2lnbih7fSwgcm9vdCwgeyB2aWV3OiByb290IH0pKTtcbiAgICB9LFxuICAgIG5hbWU6ICdmaWxlJ1xuICB9KTtcblxuICAvKipcbiAgICogQ3JlYXRlcyB0aGUgZmlsZSB2aWV3XG4gICAqL1xuICB2YXIgY3JlYXRlJDUgPSBmdW5jdGlvbiBjcmVhdGUoX3JlZikge1xuICAgIHZhciByb290ID0gX3JlZi5yb290LFxuICAgICAgcHJvcHMgPSBfcmVmLnByb3BzO1xuXG4gICAgLy8gZmlsZW5hbWVcbiAgICByb290LnJlZi5maWxlTmFtZSA9IGNyZWF0ZUVsZW1lbnQkMSgnbGVnZW5kJyk7XG4gICAgcm9vdC5hcHBlbmRDaGlsZChyb290LnJlZi5maWxlTmFtZSk7XG5cbiAgICAvLyBmaWxlIGFwcGVuZGVkXG4gICAgcm9vdC5yZWYuZmlsZSA9IHJvb3QuYXBwZW5kQ2hpbGRWaWV3KFxuICAgICAgcm9vdC5jcmVhdGVDaGlsZFZpZXcoZmlsZSwgeyBpZDogcHJvcHMuaWQgfSlcbiAgICApO1xuXG4gICAgLy8gZGF0YSBoYXMgbW92ZWQgdG8gZGF0YS5qc1xuICAgIHJvb3QucmVmLmRhdGEgPSBmYWxzZTtcbiAgfTtcblxuICAvKipcbiAgICogRGF0YSBzdG9yYWdlXG4gICAqL1xuICB2YXIgZGlkTG9hZEl0ZW0gPSBmdW5jdGlvbiBkaWRMb2FkSXRlbShfcmVmMikge1xuICAgIHZhciByb290ID0gX3JlZjIucm9vdCxcbiAgICAgIHByb3BzID0gX3JlZjIucHJvcHM7XG4gICAgLy8gdXBkYXRlcyB0aGUgbGVnZW5kIG9mIHRoZSBmaWVsZHNldCBzbyBzY3JlZW5yZWFkZXJzIGNhbiBiZXR0ZXIgZ3JvdXAgYnV0dG9uc1xuICAgIHRleHQoXG4gICAgICByb290LnJlZi5maWxlTmFtZSxcbiAgICAgIGZvcm1hdEZpbGVuYW1lKHJvb3QucXVlcnkoJ0dFVF9JVEVNX05BTUUnLCBwcm9wcy5pZCkpXG4gICAgKTtcbiAgfTtcblxuICB2YXIgZmlsZVdyYXBwZXIgPSBjcmVhdGVWaWV3KHtcbiAgICBjcmVhdGU6IGNyZWF0ZSQ1LFxuICAgIGlnbm9yZVJlY3Q6IHRydWUsXG4gICAgd3JpdGU6IGNyZWF0ZVJvdXRlKHtcbiAgICAgIERJRF9MT0FEX0lURU06IGRpZExvYWRJdGVtXG4gICAgfSksXG5cbiAgICBkaWRDcmVhdGVWaWV3OiBmdW5jdGlvbiBkaWRDcmVhdGVWaWV3KHJvb3QpIHtcbiAgICAgIGFwcGx5RmlsdGVycygnQ1JFQVRFX1ZJRVcnLCBPYmplY3QuYXNzaWduKHt9LCByb290LCB7IHZpZXc6IHJvb3QgfSkpO1xuICAgIH0sXG4gICAgdGFnOiAnZmllbGRzZXQnLFxuICAgIG5hbWU6ICdmaWxlLXdyYXBwZXInXG4gIH0pO1xuXG4gIHZhciBQQU5FTF9TUFJJTkdfUFJPUFMgPSB7IHR5cGU6ICdzcHJpbmcnLCBkYW1waW5nOiAwLjYsIG1hc3M6IDcgfTtcblxuICB2YXIgY3JlYXRlJDYgPSBmdW5jdGlvbiBjcmVhdGUoX3JlZikge1xuICAgIHZhciByb290ID0gX3JlZi5yb290LFxuICAgICAgcHJvcHMgPSBfcmVmLnByb3BzO1xuICAgIFtcbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ3RvcCdcbiAgICAgIH0sXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ2NlbnRlcicsXG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgdHJhbnNsYXRlWTogbnVsbCxcbiAgICAgICAgICBzY2FsZVk6IG51bGxcbiAgICAgICAgfSxcblxuICAgICAgICBtaXhpbnM6IHtcbiAgICAgICAgICBhbmltYXRpb25zOiB7XG4gICAgICAgICAgICBzY2FsZVk6IFBBTkVMX1NQUklOR19QUk9QU1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBzdHlsZXM6IFsndHJhbnNsYXRlWScsICdzY2FsZVknXVxuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdib3R0b20nLFxuICAgICAgICBwcm9wczoge1xuICAgICAgICAgIHRyYW5zbGF0ZVk6IG51bGxcbiAgICAgICAgfSxcblxuICAgICAgICBtaXhpbnM6IHtcbiAgICAgICAgICBhbmltYXRpb25zOiB7XG4gICAgICAgICAgICB0cmFuc2xhdGVZOiBQQU5FTF9TUFJJTkdfUFJPUFNcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgc3R5bGVzOiBbJ3RyYW5zbGF0ZVknXVxuICAgICAgICB9XG4gICAgICB9XG4gICAgXS5mb3JFYWNoKGZ1bmN0aW9uKHNlY3Rpb24pIHtcbiAgICAgIGNyZWF0ZVNlY3Rpb24ocm9vdCwgc2VjdGlvbiwgcHJvcHMubmFtZSk7XG4gICAgfSk7XG5cbiAgICByb290LmVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnZmlsZXBvbmQtLScgKyBwcm9wcy5uYW1lKTtcblxuICAgIHJvb3QucmVmLnNjYWxhYmxlID0gbnVsbDtcbiAgfTtcblxuICB2YXIgY3JlYXRlU2VjdGlvbiA9IGZ1bmN0aW9uIGNyZWF0ZVNlY3Rpb24ocm9vdCwgc2VjdGlvbiwgY2xhc3NOYW1lKSB7XG4gICAgdmFyIHZpZXdDb25zdHJ1Y3RvciA9IGNyZWF0ZVZpZXcoe1xuICAgICAgbmFtZTogJ3BhbmVsLScgKyBzZWN0aW9uLm5hbWUgKyAnIGZpbGVwb25kLS0nICsgY2xhc3NOYW1lLFxuICAgICAgbWl4aW5zOiBzZWN0aW9uLm1peGlucyxcbiAgICAgIGlnbm9yZVJlY3RVcGRhdGU6IHRydWVcbiAgICB9KTtcblxuICAgIHZhciB2aWV3ID0gcm9vdC5jcmVhdGVDaGlsZFZpZXcodmlld0NvbnN0cnVjdG9yLCBzZWN0aW9uLnByb3BzKTtcblxuICAgIHJvb3QucmVmW3NlY3Rpb24ubmFtZV0gPSByb290LmFwcGVuZENoaWxkVmlldyh2aWV3KTtcbiAgfTtcblxuICB2YXIgd3JpdGUkMyA9IGZ1bmN0aW9uIHdyaXRlKF9yZWYyKSB7XG4gICAgdmFyIHJvb3QgPSBfcmVmMi5yb290LFxuICAgICAgcHJvcHMgPSBfcmVmMi5wcm9wcztcblxuICAgIC8vIHVwZGF0ZSBzY2FsYWJsZSBzdGF0ZVxuICAgIGlmIChyb290LnJlZi5zY2FsYWJsZSA9PT0gbnVsbCB8fCBwcm9wcy5zY2FsYWJsZSAhPT0gcm9vdC5yZWYuc2NhbGFibGUpIHtcbiAgICAgIHJvb3QucmVmLnNjYWxhYmxlID0gaXNCb29sZWFuKHByb3BzLnNjYWxhYmxlKSA/IHByb3BzLnNjYWxhYmxlIDogdHJ1ZTtcbiAgICAgIHJvb3QuZWxlbWVudC5kYXRhc2V0LnNjYWxhYmxlID0gcm9vdC5yZWYuc2NhbGFibGU7XG4gICAgfVxuXG4gICAgLy8gbm8gaGVpZ2h0LCBjYW4ndCBzZXRcbiAgICBpZiAoIXByb3BzLmhlaWdodCkgcmV0dXJuO1xuXG4gICAgLy8gZ2V0IGNoaWxkIHJlY3RzXG4gICAgdmFyIHRvcFJlY3QgPSByb290LnJlZi50b3AucmVjdC5lbGVtZW50O1xuICAgIHZhciBib3R0b21SZWN0ID0gcm9vdC5yZWYuYm90dG9tLnJlY3QuZWxlbWVudDtcblxuICAgIC8vIG1ha2Ugc3VyZSBoZWlnaHQgbmV2ZXIgaXMgc21hbGxlciB0aGFuIGJvdHRvbSBhbmQgdG9wIHNlY2l0b24gaGVpZ2h0cyBjb21iaW5lZCAod2lsbCBwcm9iYWJseSBuZXZlciBoYXBwZW4sIGJ1dCB3aG8ga25vd3MpXG4gICAgdmFyIGhlaWdodCA9IE1hdGgubWF4KHRvcFJlY3QuaGVpZ2h0ICsgYm90dG9tUmVjdC5oZWlnaHQsIHByb3BzLmhlaWdodCk7XG5cbiAgICAvLyBvZmZzZXQgY2VudGVyIHBhcnRcbiAgICByb290LnJlZi5jZW50ZXIudHJhbnNsYXRlWSA9IHRvcFJlY3QuaGVpZ2h0O1xuXG4gICAgLy8gc2NhbGUgY2VudGVyIHBhcnRcbiAgICAvLyB1c2UgbWF0aCBjZWlsIHRvIHByZXZlbnQgdHJhbnNwYXJlbnQgbGluZXMgYmVjYXVzZSBvZiByb3VuZGluZyBlcnJvcnNcbiAgICByb290LnJlZi5jZW50ZXIuc2NhbGVZID1cbiAgICAgIChoZWlnaHQgLSB0b3BSZWN0LmhlaWdodCAtIGJvdHRvbVJlY3QuaGVpZ2h0KSAvIDEwMDtcblxuICAgIC8vIG9mZnNldCBib3R0b20gcGFydFxuICAgIHJvb3QucmVmLmJvdHRvbS50cmFuc2xhdGVZID0gaGVpZ2h0IC0gYm90dG9tUmVjdC5oZWlnaHQ7XG4gIH07XG5cbiAgdmFyIHBhbmVsID0gY3JlYXRlVmlldyh7XG4gICAgbmFtZTogJ3BhbmVsJyxcbiAgICByZWFkOiBmdW5jdGlvbiByZWFkKF9yZWYzKSB7XG4gICAgICB2YXIgcm9vdCA9IF9yZWYzLnJvb3QsXG4gICAgICAgIHByb3BzID0gX3JlZjMucHJvcHM7XG4gICAgICByZXR1cm4gKHByb3BzLmhlaWdodEN1cnJlbnQgPSByb290LnJlZi5ib3R0b20udHJhbnNsYXRlWSk7XG4gICAgfSxcbiAgICB3cml0ZTogd3JpdGUkMyxcbiAgICBjcmVhdGU6IGNyZWF0ZSQ2LFxuICAgIGlnbm9yZVJlY3Q6IHRydWUsXG4gICAgbWl4aW5zOiB7XG4gICAgICBhcGlzOiBbJ2hlaWdodCcsICdoZWlnaHRDdXJyZW50JywgJ3NjYWxhYmxlJ11cbiAgICB9XG4gIH0pO1xuXG4gIHZhciBjcmVhdGVEcmFnSGVscGVyID0gZnVuY3Rpb24gY3JlYXRlRHJhZ0hlbHBlcihpdGVtcykge1xuICAgIHZhciBpdGVtSWRzID0gaXRlbXMubWFwKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgIHJldHVybiBpdGVtLmlkO1xuICAgIH0pO1xuICAgIHZhciBwcmV2SW5kZXggPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNldEluZGV4OiBmdW5jdGlvbiBzZXRJbmRleChpbmRleCkge1xuICAgICAgICBwcmV2SW5kZXggPSBpbmRleDtcbiAgICAgIH0sXG4gICAgICBnZXRJbmRleDogZnVuY3Rpb24gZ2V0SW5kZXgoKSB7XG4gICAgICAgIHJldHVybiBwcmV2SW5kZXg7XG4gICAgICB9LFxuICAgICAgZ2V0SXRlbUluZGV4OiBmdW5jdGlvbiBnZXRJdGVtSW5kZXgoaXRlbSkge1xuICAgICAgICByZXR1cm4gaXRlbUlkcy5pbmRleE9mKGl0ZW0uaWQpO1xuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgdmFyIElURU1fVFJBTlNMQVRFX1NQUklORyA9IHtcbiAgICB0eXBlOiAnc3ByaW5nJyxcbiAgICBzdGlmZm5lc3M6IDAuNzUsXG4gICAgZGFtcGluZzogMC40NSxcbiAgICBtYXNzOiAxMFxuICB9O1xuXG4gIHZhciBJVEVNX1NDQUxFX1NQUklORyA9ICdzcHJpbmcnO1xuXG4gIHZhciBTdGF0ZU1hcCA9IHtcbiAgICBESURfU1RBUlRfSVRFTV9MT0FEOiAnYnVzeScsXG4gICAgRElEX1VQREFURV9JVEVNX0xPQURfUFJPR1JFU1M6ICdsb2FkaW5nJyxcbiAgICBESURfVEhST1dfSVRFTV9JTlZBTElEOiAnbG9hZC1pbnZhbGlkJyxcbiAgICBESURfVEhST1dfSVRFTV9MT0FEX0VSUk9SOiAnbG9hZC1lcnJvcicsXG4gICAgRElEX0xPQURfSVRFTTogJ2lkbGUnLFxuICAgIERJRF9USFJPV19JVEVNX1JFTU9WRV9FUlJPUjogJ3JlbW92ZS1lcnJvcicsXG4gICAgRElEX1NUQVJUX0lURU1fUkVNT1ZFOiAnYnVzeScsXG4gICAgRElEX1NUQVJUX0lURU1fUFJPQ0VTU0lORzogJ2J1c3kgcHJvY2Vzc2luZycsXG4gICAgRElEX1JFUVVFU1RfSVRFTV9QUk9DRVNTSU5HOiAnYnVzeSBwcm9jZXNzaW5nJyxcbiAgICBESURfVVBEQVRFX0lURU1fUFJPQ0VTU19QUk9HUkVTUzogJ3Byb2Nlc3NpbmcnLFxuICAgIERJRF9DT01QTEVURV9JVEVNX1BST0NFU1NJTkc6ICdwcm9jZXNzaW5nLWNvbXBsZXRlJyxcbiAgICBESURfVEhST1dfSVRFTV9QUk9DRVNTSU5HX0VSUk9SOiAncHJvY2Vzc2luZy1lcnJvcicsXG4gICAgRElEX1RIUk9XX0lURU1fUFJPQ0VTU0lOR19SRVZFUlRfRVJST1I6ICdwcm9jZXNzaW5nLXJldmVydC1lcnJvcicsXG4gICAgRElEX0FCT1JUX0lURU1fUFJPQ0VTU0lORzogJ2NhbmNlbGxlZCcsXG4gICAgRElEX1JFVkVSVF9JVEVNX1BST0NFU1NJTkc6ICdpZGxlJ1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIHRoZSBmaWxlIHZpZXdcbiAgICovXG4gIHZhciBjcmVhdGUkNyA9IGZ1bmN0aW9uIGNyZWF0ZShfcmVmKSB7XG4gICAgdmFyIHJvb3QgPSBfcmVmLnJvb3QsXG4gICAgICBwcm9wcyA9IF9yZWYucHJvcHM7XG5cbiAgICAvLyBzZWxlY3RcbiAgICByb290LnJlZi5oYW5kbGVDbGljayA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgIHJldHVybiByb290LmRpc3BhdGNoKCdESURfQUNUSVZBVEVfSVRFTScsIHsgaWQ6IHByb3BzLmlkIH0pO1xuICAgIH07XG5cbiAgICAvLyBzZXQgaWRcbiAgICByb290LmVsZW1lbnQuaWQgPSAnZmlsZXBvbmQtLWl0ZW0tJyArIHByb3BzLmlkO1xuICAgIHJvb3QuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHJvb3QucmVmLmhhbmRsZUNsaWNrKTtcblxuICAgIC8vIGZpbGUgdmlld1xuICAgIHJvb3QucmVmLmNvbnRhaW5lciA9IHJvb3QuYXBwZW5kQ2hpbGRWaWV3KFxuICAgICAgcm9vdC5jcmVhdGVDaGlsZFZpZXcoZmlsZVdyYXBwZXIsIHsgaWQ6IHByb3BzLmlkIH0pXG4gICAgKTtcblxuICAgIC8vIGZpbGUgcGFuZWxcbiAgICByb290LnJlZi5wYW5lbCA9IHJvb3QuYXBwZW5kQ2hpbGRWaWV3KFxuICAgICAgcm9vdC5jcmVhdGVDaGlsZFZpZXcocGFuZWwsIHsgbmFtZTogJ2l0ZW0tcGFuZWwnIH0pXG4gICAgKTtcblxuICAgIC8vIGRlZmF1bHQgc3RhcnQgaGVpZ2h0XG4gICAgcm9vdC5yZWYucGFuZWwuaGVpZ2h0ID0gbnVsbDtcblxuICAgIC8vIGJ5IGRlZmF1bHQgbm90IG1hcmtlZCBmb3IgcmVtb3ZhbFxuICAgIHByb3BzLm1hcmtlZEZvclJlbW92YWwgPSBmYWxzZTtcblxuICAgIC8vIGlmIG5vdCBhbGxvd2VkIHRvIHJlb3JkZXIgZmlsZSBpdGVtcywgZXhpdCBoZXJlXG4gICAgaWYgKCFyb290LnF1ZXJ5KCdHRVRfQUxMT1dfUkVPUkRFUicpKSByZXR1cm47XG5cbiAgICAvLyBzZXQgdG8gaWRsZSBzbyBzaG93cyBncmFiIGN1cnNvclxuICAgIHJvb3QuZWxlbWVudC5kYXRhc2V0LmRyYWdTdGF0ZSA9ICdpZGxlJztcblxuICAgIHZhciBncmFiID0gZnVuY3Rpb24gZ3JhYihlKSB7XG4gICAgICBpZiAoIWUuaXNQcmltYXJ5KSByZXR1cm47XG5cbiAgICAgIHZhciByZW1vdmVkQWN0aXZhdGVMaXN0ZW5lciA9IGZhbHNlO1xuXG4gICAgICB2YXIgb3JpZ2luID0ge1xuICAgICAgICB4OiBlLnBhZ2VYLFxuICAgICAgICB5OiBlLnBhZ2VZXG4gICAgICB9O1xuXG4gICAgICBwcm9wcy5kcmFnT3JpZ2luID0ge1xuICAgICAgICB4OiByb290LnRyYW5zbGF0ZVgsXG4gICAgICAgIHk6IHJvb3QudHJhbnNsYXRlWVxuICAgICAgfTtcblxuICAgICAgcHJvcHMuZHJhZ0NlbnRlciA9IHtcbiAgICAgICAgeDogZS5vZmZzZXRYLFxuICAgICAgICB5OiBlLm9mZnNldFlcbiAgICAgIH07XG5cbiAgICAgIHZhciBkcmFnU3RhdGUgPSBjcmVhdGVEcmFnSGVscGVyKHJvb3QucXVlcnkoJ0dFVF9BQ1RJVkVfSVRFTVMnKSk7XG5cbiAgICAgIHJvb3QuZGlzcGF0Y2goJ0RJRF9HUkFCX0lURU0nLCB7IGlkOiBwcm9wcy5pZCwgZHJhZ1N0YXRlOiBkcmFnU3RhdGUgfSk7XG5cbiAgICAgIHZhciBkcmFnID0gZnVuY3Rpb24gZHJhZyhlKSB7XG4gICAgICAgIGlmICghZS5pc1ByaW1hcnkpIHJldHVybjtcblxuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgcHJvcHMuZHJhZ09mZnNldCA9IHtcbiAgICAgICAgICB4OiBlLnBhZ2VYIC0gb3JpZ2luLngsXG4gICAgICAgICAgeTogZS5wYWdlWSAtIG9yaWdpbi55XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gaWYgZHJhZ2dlZCBzdG9wIGxpc3RlbmluZyB0byBjbGlja3MsIHdpbGwgcmUtYWRkIHdoZW4gZG9uZSBkcmFnZ2luZ1xuICAgICAgICB2YXIgZGlzdCA9XG4gICAgICAgICAgcHJvcHMuZHJhZ09mZnNldC54ICogcHJvcHMuZHJhZ09mZnNldC54ICtcbiAgICAgICAgICBwcm9wcy5kcmFnT2Zmc2V0LnkgKiBwcm9wcy5kcmFnT2Zmc2V0Lnk7XG4gICAgICAgIGlmIChkaXN0ID4gMTYgJiYgIXJlbW92ZWRBY3RpdmF0ZUxpc3RlbmVyKSB7XG4gICAgICAgICAgcmVtb3ZlZEFjdGl2YXRlTGlzdGVuZXIgPSB0cnVlO1xuICAgICAgICAgIHJvb3QuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHJvb3QucmVmLmhhbmRsZUNsaWNrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJvb3QuZGlzcGF0Y2goJ0RJRF9EUkFHX0lURU0nLCB7IGlkOiBwcm9wcy5pZCwgZHJhZ1N0YXRlOiBkcmFnU3RhdGUgfSk7XG4gICAgICB9O1xuXG4gICAgICB2YXIgZHJvcCA9IGZ1bmN0aW9uIGRyb3AoZSkge1xuICAgICAgICBpZiAoIWUuaXNQcmltYXJ5KSByZXR1cm47XG5cbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9pbnRlcm1vdmUnLCBkcmFnKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9pbnRlcnVwJywgZHJvcCk7XG5cbiAgICAgICAgcHJvcHMuZHJhZ09mZnNldCA9IHtcbiAgICAgICAgICB4OiBlLnBhZ2VYIC0gb3JpZ2luLngsXG4gICAgICAgICAgeTogZS5wYWdlWSAtIG9yaWdpbi55XG4gICAgICAgIH07XG5cbiAgICAgICAgcm9vdC5kaXNwYXRjaCgnRElEX0RST1BfSVRFTScsIHsgaWQ6IHByb3BzLmlkLCBkcmFnU3RhdGU6IGRyYWdTdGF0ZSB9KTtcblxuICAgICAgICAvLyBzdGFydCBsaXN0ZW5pbmcgdG8gY2xpY2tzIGFnYWluXG4gICAgICAgIGlmIChyZW1vdmVkQWN0aXZhdGVMaXN0ZW5lcikge1xuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gcm9vdC5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgcm9vdC5yZWYuaGFuZGxlQ2xpY2spO1xuICAgICAgICAgIH0sIDApO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVybW92ZScsIGRyYWcpO1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcnVwJywgZHJvcCk7XG4gICAgfTtcblxuICAgIHJvb3QuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVyZG93bicsIGdyYWIpO1xuICB9O1xuXG4gIHZhciByb3V0ZSQxID0gY3JlYXRlUm91dGUoe1xuICAgIERJRF9VUERBVEVfUEFORUxfSEVJR0hUOiBmdW5jdGlvbiBESURfVVBEQVRFX1BBTkVMX0hFSUdIVChfcmVmMikge1xuICAgICAgdmFyIHJvb3QgPSBfcmVmMi5yb290LFxuICAgICAgICBhY3Rpb24gPSBfcmVmMi5hY3Rpb247XG4gICAgICByb290LmhlaWdodCA9IGFjdGlvbi5oZWlnaHQ7XG4gICAgfVxuICB9KTtcblxuICB2YXIgd3JpdGUkNCA9IGNyZWF0ZVJvdXRlKFxuICAgIHtcbiAgICAgIERJRF9HUkFCX0lURU06IGZ1bmN0aW9uIERJRF9HUkFCX0lURU0oX3JlZjMpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmMy5yb290LFxuICAgICAgICAgIHByb3BzID0gX3JlZjMucHJvcHM7XG4gICAgICAgIHByb3BzLmRyYWdPcmlnaW4gPSB7XG4gICAgICAgICAgeDogcm9vdC50cmFuc2xhdGVYLFxuICAgICAgICAgIHk6IHJvb3QudHJhbnNsYXRlWVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIERJRF9EUkFHX0lURU06IGZ1bmN0aW9uIERJRF9EUkFHX0lURU0oX3JlZjQpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmNC5yb290O1xuICAgICAgICByb290LmVsZW1lbnQuZGF0YXNldC5kcmFnU3RhdGUgPSAnZHJhZyc7XG4gICAgICB9LFxuICAgICAgRElEX0RST1BfSVRFTTogZnVuY3Rpb24gRElEX0RST1BfSVRFTShfcmVmNSkge1xuICAgICAgICB2YXIgcm9vdCA9IF9yZWY1LnJvb3QsXG4gICAgICAgICAgcHJvcHMgPSBfcmVmNS5wcm9wcztcbiAgICAgICAgcHJvcHMuZHJhZ09mZnNldCA9IG51bGw7XG4gICAgICAgIHByb3BzLmRyYWdPcmlnaW4gPSBudWxsO1xuICAgICAgICByb290LmVsZW1lbnQuZGF0YXNldC5kcmFnU3RhdGUgPSAnZHJvcCc7XG4gICAgICB9XG4gICAgfSxcbiAgICBmdW5jdGlvbihfcmVmNikge1xuICAgICAgdmFyIHJvb3QgPSBfcmVmNi5yb290LFxuICAgICAgICBhY3Rpb25zID0gX3JlZjYuYWN0aW9ucyxcbiAgICAgICAgcHJvcHMgPSBfcmVmNi5wcm9wcyxcbiAgICAgICAgc2hvdWxkT3B0aW1pemUgPSBfcmVmNi5zaG91bGRPcHRpbWl6ZTtcblxuICAgICAgaWYgKHJvb3QuZWxlbWVudC5kYXRhc2V0LmRyYWdTdGF0ZSA9PT0gJ2Ryb3AnKSB7XG4gICAgICAgIGlmIChyb290LnNjYWxlWCA8PSAxKSB7XG4gICAgICAgICAgcm9vdC5lbGVtZW50LmRhdGFzZXQuZHJhZ1N0YXRlID0gJ2lkbGUnO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHNlbGVjdCBsYXN0IHN0YXRlIGNoYW5nZSBhY3Rpb25cbiAgICAgIHZhciBhY3Rpb24gPSBhY3Rpb25zXG4gICAgICAgIC5jb25jYXQoKVxuICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKGFjdGlvbikge1xuICAgICAgICAgIHJldHVybiAvXkRJRF8vLnRlc3QoYWN0aW9uLnR5cGUpO1xuICAgICAgICB9KVxuICAgICAgICAucmV2ZXJzZSgpXG4gICAgICAgIC5maW5kKGZ1bmN0aW9uKGFjdGlvbikge1xuICAgICAgICAgIHJldHVybiBTdGF0ZU1hcFthY3Rpb24udHlwZV07XG4gICAgICAgIH0pO1xuXG4gICAgICAvLyBubyBuZWVkIHRvIHNldCBzYW1lIHN0YXRlIHR3aWNlXG4gICAgICBpZiAoYWN0aW9uICYmIGFjdGlvbi50eXBlICE9PSBwcm9wcy5jdXJyZW50U3RhdGUpIHtcbiAgICAgICAgLy8gc2V0IGN1cnJlbnQgc3RhdGVcbiAgICAgICAgcHJvcHMuY3VycmVudFN0YXRlID0gYWN0aW9uLnR5cGU7XG5cbiAgICAgICAgLy8gc2V0IHN0YXRlXG4gICAgICAgIHJvb3QuZWxlbWVudC5kYXRhc2V0LmZpbGVwb25kSXRlbVN0YXRlID1cbiAgICAgICAgICBTdGF0ZU1hcFtwcm9wcy5jdXJyZW50U3RhdGVdIHx8ICcnO1xuICAgICAgfVxuXG4gICAgICAvLyByb3V0ZSBhY3Rpb25zXG4gICAgICB2YXIgYXNwZWN0UmF0aW8gPVxuICAgICAgICByb290LnF1ZXJ5KCdHRVRfSVRFTV9QQU5FTF9BU1BFQ1RfUkFUSU8nKSB8fFxuICAgICAgICByb290LnF1ZXJ5KCdHRVRfUEFORUxfQVNQRUNUX1JBVElPJyk7XG4gICAgICBpZiAoIWFzcGVjdFJhdGlvKSB7XG4gICAgICAgIHJvdXRlJDEoeyByb290OiByb290LCBhY3Rpb25zOiBhY3Rpb25zLCBwcm9wczogcHJvcHMgfSk7XG4gICAgICAgIGlmICghcm9vdC5oZWlnaHQgJiYgcm9vdC5yZWYuY29udGFpbmVyLnJlY3QuZWxlbWVudC5oZWlnaHQgPiAwKSB7XG4gICAgICAgICAgcm9vdC5oZWlnaHQgPSByb290LnJlZi5jb250YWluZXIucmVjdC5lbGVtZW50LmhlaWdodDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghc2hvdWxkT3B0aW1pemUpIHtcbiAgICAgICAgcm9vdC5oZWlnaHQgPSByb290LnJlY3QuZWxlbWVudC53aWR0aCAqIGFzcGVjdFJhdGlvO1xuICAgICAgfVxuXG4gICAgICAvLyBzeW5jIHBhbmVsIGhlaWdodCB3aXRoIGl0ZW0gaGVpZ2h0XG4gICAgICBpZiAoc2hvdWxkT3B0aW1pemUpIHtcbiAgICAgICAgcm9vdC5yZWYucGFuZWwuaGVpZ2h0ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcm9vdC5yZWYucGFuZWwuaGVpZ2h0ID0gcm9vdC5oZWlnaHQ7XG4gICAgfVxuICApO1xuXG4gIHZhciBpdGVtID0gY3JlYXRlVmlldyh7XG4gICAgY3JlYXRlOiBjcmVhdGUkNyxcbiAgICB3cml0ZTogd3JpdGUkNCxcbiAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KF9yZWY3KSB7XG4gICAgICB2YXIgcm9vdCA9IF9yZWY3LnJvb3QsXG4gICAgICAgIHByb3BzID0gX3JlZjcucHJvcHM7XG4gICAgICByb290LmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCByb290LnJlZi5oYW5kbGVDbGljayk7XG4gICAgICByb290LmRpc3BhdGNoKCdSRUxFQVNFX0lURU0nLCB7IHF1ZXJ5OiBwcm9wcy5pZCB9KTtcbiAgICB9LFxuICAgIHRhZzogJ2xpJyxcbiAgICBuYW1lOiAnaXRlbScsXG4gICAgbWl4aW5zOiB7XG4gICAgICBhcGlzOiBbXG4gICAgICAgICdpZCcsXG4gICAgICAgICdpbnRlcmFjdGlvbk1ldGhvZCcsXG4gICAgICAgICdtYXJrZWRGb3JSZW1vdmFsJyxcbiAgICAgICAgJ3NwYXduRGF0ZScsXG4gICAgICAgICdkcmFnQ2VudGVyJyxcbiAgICAgICAgJ2RyYWdPcmlnaW4nLFxuICAgICAgICAnZHJhZ09mZnNldCdcbiAgICAgIF0sXG4gICAgICBzdHlsZXM6IFtcbiAgICAgICAgJ3RyYW5zbGF0ZVgnLFxuICAgICAgICAndHJhbnNsYXRlWScsXG4gICAgICAgICdzY2FsZVgnLFxuICAgICAgICAnc2NhbGVZJyxcbiAgICAgICAgJ29wYWNpdHknLFxuICAgICAgICAnaGVpZ2h0J1xuICAgICAgXSxcblxuICAgICAgYW5pbWF0aW9uczoge1xuICAgICAgICBzY2FsZVg6IElURU1fU0NBTEVfU1BSSU5HLFxuICAgICAgICBzY2FsZVk6IElURU1fU0NBTEVfU1BSSU5HLFxuICAgICAgICB0cmFuc2xhdGVYOiBJVEVNX1RSQU5TTEFURV9TUFJJTkcsXG4gICAgICAgIHRyYW5zbGF0ZVk6IElURU1fVFJBTlNMQVRFX1NQUklORyxcbiAgICAgICAgb3BhY2l0eTogeyB0eXBlOiAndHdlZW4nLCBkdXJhdGlvbjogMTUwIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHZhciBnZXRJdGVtSW5kZXhCeVBvc2l0aW9uID0gZnVuY3Rpb24gZ2V0SXRlbUluZGV4QnlQb3NpdGlvbihcbiAgICB2aWV3LFxuICAgIGNoaWxkcmVuLFxuICAgIHBvc2l0aW9uSW5WaWV3XG4gICkge1xuICAgIGlmICghcG9zaXRpb25JblZpZXcpIHJldHVybjtcblxuICAgIHZhciBob3Jpem9udGFsU3BhY2UgPSB2aWV3LnJlY3QuZWxlbWVudC53aWR0aDtcbiAgICAvLyBjb25zdCBjaGlsZHJlbiA9IHZpZXcuY2hpbGRWaWV3cztcbiAgICB2YXIgbCA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgICB2YXIgbGFzdCA9IG51bGw7XG5cbiAgICAvLyAtMSwgZG9uJ3QgbW92ZSBpdGVtcyB0byBhY2NvbW9kYXRlIChlaXRoZXIgYWRkIHRvIHRvcCBvciBib3R0b20pXG4gICAgaWYgKGwgPT09IDAgfHwgcG9zaXRpb25JblZpZXcudG9wIDwgY2hpbGRyZW5bMF0ucmVjdC5lbGVtZW50LnRvcCkgcmV0dXJuIC0xO1xuXG4gICAgLy8gbGV0J3MgZ2V0IHRoZSBpdGVtIHdpZHRoXG4gICAgdmFyIGl0ZW0gPSBjaGlsZHJlblswXTtcbiAgICB2YXIgaXRlbVJlY3QgPSBpdGVtLnJlY3QuZWxlbWVudDtcbiAgICB2YXIgaXRlbUhvcml6b250YWxNYXJnaW4gPSBpdGVtUmVjdC5tYXJnaW5MZWZ0ICsgaXRlbVJlY3QubWFyZ2luUmlnaHQ7XG4gICAgdmFyIGl0ZW1XaWR0aCA9IGl0ZW1SZWN0LndpZHRoICsgaXRlbUhvcml6b250YWxNYXJnaW47XG4gICAgdmFyIGl0ZW1zUGVyUm93ID0gTWF0aC5yb3VuZChob3Jpem9udGFsU3BhY2UgLyBpdGVtV2lkdGgpO1xuXG4gICAgLy8gc3RhY2tcbiAgICBpZiAoaXRlbXNQZXJSb3cgPT09IDEpIHtcbiAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsOyBpbmRleCsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2luZGV4XTtcbiAgICAgICAgdmFyIGNoaWxkTWlkID0gY2hpbGQucmVjdC5vdXRlci50b3AgKyBjaGlsZC5yZWN0LmVsZW1lbnQuaGVpZ2h0ICogMC41O1xuICAgICAgICBpZiAocG9zaXRpb25JblZpZXcudG9wIDwgY2hpbGRNaWQpIHtcbiAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBsO1xuICAgIH1cblxuICAgIC8vIGdyaWRcbiAgICB2YXIgaXRlbVZlcnRpY2FsTWFyZ2luID0gaXRlbVJlY3QubWFyZ2luVG9wICsgaXRlbVJlY3QubWFyZ2luQm90dG9tO1xuICAgIHZhciBpdGVtSGVpZ2h0ID0gaXRlbVJlY3QuaGVpZ2h0ICsgaXRlbVZlcnRpY2FsTWFyZ2luO1xuICAgIGZvciAodmFyIF9pbmRleCA9IDA7IF9pbmRleCA8IGw7IF9pbmRleCsrKSB7XG4gICAgICB2YXIgaW5kZXhYID0gX2luZGV4ICUgaXRlbXNQZXJSb3c7XG4gICAgICB2YXIgaW5kZXhZID0gTWF0aC5mbG9vcihfaW5kZXggLyBpdGVtc1BlclJvdyk7XG5cbiAgICAgIHZhciBvZmZzZXRYID0gaW5kZXhYICogaXRlbVdpZHRoO1xuICAgICAgdmFyIG9mZnNldFkgPSBpbmRleFkgKiBpdGVtSGVpZ2h0O1xuXG4gICAgICB2YXIgaXRlbVRvcCA9IG9mZnNldFkgLSBpdGVtUmVjdC5tYXJnaW5Ub3A7XG4gICAgICB2YXIgaXRlbVJpZ2h0ID0gb2Zmc2V0WCArIGl0ZW1XaWR0aDtcbiAgICAgIHZhciBpdGVtQm90dG9tID0gb2Zmc2V0WSArIGl0ZW1IZWlnaHQgKyBpdGVtUmVjdC5tYXJnaW5Cb3R0b207XG5cbiAgICAgIGlmIChwb3NpdGlvbkluVmlldy50b3AgPCBpdGVtQm90dG9tICYmIHBvc2l0aW9uSW5WaWV3LnRvcCA+IGl0ZW1Ub3ApIHtcbiAgICAgICAgaWYgKHBvc2l0aW9uSW5WaWV3LmxlZnQgPCBpdGVtUmlnaHQpIHtcbiAgICAgICAgICByZXR1cm4gX2luZGV4O1xuICAgICAgICB9IGVsc2UgaWYgKF9pbmRleCAhPT0gbCAtIDEpIHtcbiAgICAgICAgICBsYXN0ID0gX2luZGV4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxhc3QgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGxhc3QgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiBsYXN0O1xuICAgIH1cblxuICAgIHJldHVybiBsO1xuICB9O1xuXG4gIHZhciBkcm9wQXJlYURpbWVuc2lvbnMgPSB7XG4gICAgaGVpZ2h0OiAwLFxuICAgIHdpZHRoOiAwLFxuICAgIGdldCBnZXRIZWlnaHQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5oZWlnaHQ7XG4gICAgfSxcbiAgICBzZXQgc2V0SGVpZ2h0KHZhbCkge1xuICAgICAgaWYgKHRoaXMuaGVpZ2h0ID09PSAwIHx8IHZhbCA9PT0gMCkgdGhpcy5oZWlnaHQgPSB2YWw7XG4gICAgfSxcbiAgICBnZXQgZ2V0V2lkdGgoKSB7XG4gICAgICByZXR1cm4gdGhpcy53aWR0aDtcbiAgICB9LFxuICAgIHNldCBzZXRXaWR0aCh2YWwpIHtcbiAgICAgIGlmICh0aGlzLndpZHRoID09PSAwIHx8IHZhbCA9PT0gMCkgdGhpcy53aWR0aCA9IHZhbDtcbiAgICB9LFxuICAgIHNldERpbWVuc2lvbnM6IGZ1bmN0aW9uIHNldERpbWVuc2lvbnMoaGVpZ2h0LCB3aWR0aCkge1xuICAgICAgaWYgKHRoaXMuaGVpZ2h0ID09PSAwIHx8IGhlaWdodCA9PT0gMCkgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICBpZiAodGhpcy53aWR0aCA9PT0gMCB8fCB3aWR0aCA9PT0gMCkgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIH1cbiAgfTtcblxuICB2YXIgY3JlYXRlJDggPSBmdW5jdGlvbiBjcmVhdGUoX3JlZikge1xuICAgIHZhciByb290ID0gX3JlZi5yb290O1xuICAgIC8vIG5lZWQgdG8gc2V0IHJvbGUgdG8gbGlzdCBhcyBvdGhlcndpc2UgaXQgd29uJ3QgYmUgcmVhZCBhcyBhIGxpc3QgYnkgVm9pY2VPdmVyXG4gICAgYXR0cihyb290LmVsZW1lbnQsICdyb2xlJywgJ2xpc3QnKTtcblxuICAgIHJvb3QucmVmLmxhc3RJdGVtU3BhbndEYXRlID0gRGF0ZS5ub3coKTtcbiAgfTtcblxuICAvKipcbiAgICogSW5zZXJ0cyBhIG5ldyBpdGVtXG4gICAqIEBwYXJhbSByb290XG4gICAqIEBwYXJhbSBhY3Rpb25cbiAgICovXG4gIHZhciBhZGRJdGVtVmlldyA9IGZ1bmN0aW9uIGFkZEl0ZW1WaWV3KF9yZWYyKSB7XG4gICAgdmFyIHJvb3QgPSBfcmVmMi5yb290LFxuICAgICAgYWN0aW9uID0gX3JlZjIuYWN0aW9uO1xuICAgIHZhciBpZCA9IGFjdGlvbi5pZCxcbiAgICAgIGluZGV4ID0gYWN0aW9uLmluZGV4LFxuICAgICAgaW50ZXJhY3Rpb25NZXRob2QgPSBhY3Rpb24uaW50ZXJhY3Rpb25NZXRob2Q7XG5cbiAgICByb290LnJlZi5hZGRJbmRleCA9IGluZGV4O1xuXG4gICAgdmFyIG5vdyA9IERhdGUubm93KCk7XG4gICAgdmFyIHNwYXduRGF0ZSA9IG5vdztcbiAgICB2YXIgb3BhY2l0eSA9IDE7XG5cbiAgICBpZiAoaW50ZXJhY3Rpb25NZXRob2QgIT09IEludGVyYWN0aW9uTWV0aG9kLk5PTkUpIHtcbiAgICAgIG9wYWNpdHkgPSAwO1xuICAgICAgdmFyIGNvb2xkb3duID0gcm9vdC5xdWVyeSgnR0VUX0lURU1fSU5TRVJUX0lOVEVSVkFMJyk7XG4gICAgICB2YXIgZGlzdCA9IG5vdyAtIHJvb3QucmVmLmxhc3RJdGVtU3BhbndEYXRlO1xuICAgICAgc3Bhd25EYXRlID0gZGlzdCA8IGNvb2xkb3duID8gbm93ICsgKGNvb2xkb3duIC0gZGlzdCkgOiBub3c7XG4gICAgfVxuXG4gICAgcm9vdC5yZWYubGFzdEl0ZW1TcGFud0RhdGUgPSBzcGF3bkRhdGU7XG5cbiAgICByb290LmFwcGVuZENoaWxkVmlldyhcbiAgICAgIHJvb3QuY3JlYXRlQ2hpbGRWaWV3KFxuICAgICAgICAvLyB2aWV3IHR5cGVcbiAgICAgICAgaXRlbSxcblxuICAgICAgICAvLyBwcm9wc1xuICAgICAgICB7XG4gICAgICAgICAgc3Bhd25EYXRlOiBzcGF3bkRhdGUsXG4gICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgIG9wYWNpdHk6IG9wYWNpdHksXG4gICAgICAgICAgaW50ZXJhY3Rpb25NZXRob2Q6IGludGVyYWN0aW9uTWV0aG9kXG4gICAgICAgIH1cbiAgICAgICksXG5cbiAgICAgIGluZGV4XG4gICAgKTtcbiAgfTtcblxuICB2YXIgbW92ZUl0ZW0gPSBmdW5jdGlvbiBtb3ZlSXRlbShpdGVtLCB4LCB5KSB7XG4gICAgdmFyIHZ4ID1cbiAgICAgIGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogMDtcbiAgICB2YXIgdnkgPVxuICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiAxO1xuXG4gICAgLy8gc2V0IHRvIG51bGwgdG8gcmVtb3ZlIGFuaW1hdGlvbiB3aGlsZSBkcmFnZ2luZ1xuICAgIGlmIChpdGVtLmRyYWdPZmZzZXQpIHtcbiAgICAgIGl0ZW0udHJhbnNsYXRlWCA9IG51bGw7XG4gICAgICBpdGVtLnRyYW5zbGF0ZVkgPSBudWxsO1xuICAgICAgaXRlbS50cmFuc2xhdGVYID0gaXRlbS5kcmFnT3JpZ2luLnggKyBpdGVtLmRyYWdPZmZzZXQueDtcbiAgICAgIGl0ZW0udHJhbnNsYXRlWSA9IGl0ZW0uZHJhZ09yaWdpbi55ICsgaXRlbS5kcmFnT2Zmc2V0Lnk7XG4gICAgICBpdGVtLnNjYWxlWCA9IDEuMDI1O1xuICAgICAgaXRlbS5zY2FsZVkgPSAxLjAyNTtcbiAgICB9IGVsc2Uge1xuICAgICAgaXRlbS50cmFuc2xhdGVYID0geDtcbiAgICAgIGl0ZW0udHJhbnNsYXRlWSA9IHk7XG5cbiAgICAgIGlmIChEYXRlLm5vdygpID4gaXRlbS5zcGF3bkRhdGUpIHtcbiAgICAgICAgLy8gcmV2ZWFsIGVsZW1lbnRcbiAgICAgICAgaWYgKGl0ZW0ub3BhY2l0eSA9PT0gMCkge1xuICAgICAgICAgIGludHJvSXRlbVZpZXcoaXRlbSwgeCwgeSwgdngsIHZ5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG1ha2Ugc3VyZSBpcyBkZWZhdWx0IHNjYWxlIGV2ZXJ5IGZyYW1lXG4gICAgICAgIGl0ZW0uc2NhbGVYID0gMTtcbiAgICAgICAgaXRlbS5zY2FsZVkgPSAxO1xuICAgICAgICBpdGVtLm9wYWNpdHkgPSAxO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgaW50cm9JdGVtVmlldyA9IGZ1bmN0aW9uIGludHJvSXRlbVZpZXcoaXRlbSwgeCwgeSwgdngsIHZ5KSB7XG4gICAgaWYgKGl0ZW0uaW50ZXJhY3Rpb25NZXRob2QgPT09IEludGVyYWN0aW9uTWV0aG9kLk5PTkUpIHtcbiAgICAgIGl0ZW0udHJhbnNsYXRlWCA9IG51bGw7XG4gICAgICBpdGVtLnRyYW5zbGF0ZVggPSB4O1xuICAgICAgaXRlbS50cmFuc2xhdGVZID0gbnVsbDtcbiAgICAgIGl0ZW0udHJhbnNsYXRlWSA9IHk7XG4gICAgfSBlbHNlIGlmIChpdGVtLmludGVyYWN0aW9uTWV0aG9kID09PSBJbnRlcmFjdGlvbk1ldGhvZC5EUk9QKSB7XG4gICAgICBpdGVtLnRyYW5zbGF0ZVggPSBudWxsO1xuICAgICAgaXRlbS50cmFuc2xhdGVYID0geCAtIHZ4ICogMjA7XG5cbiAgICAgIGl0ZW0udHJhbnNsYXRlWSA9IG51bGw7XG4gICAgICBpdGVtLnRyYW5zbGF0ZVkgPSB5IC0gdnkgKiAxMDtcblxuICAgICAgaXRlbS5zY2FsZVggPSAwLjg7XG4gICAgICBpdGVtLnNjYWxlWSA9IDAuODtcbiAgICB9IGVsc2UgaWYgKGl0ZW0uaW50ZXJhY3Rpb25NZXRob2QgPT09IEludGVyYWN0aW9uTWV0aG9kLkJST1dTRSkge1xuICAgICAgaXRlbS50cmFuc2xhdGVZID0gbnVsbDtcbiAgICAgIGl0ZW0udHJhbnNsYXRlWSA9IHkgLSAzMDtcbiAgICB9IGVsc2UgaWYgKGl0ZW0uaW50ZXJhY3Rpb25NZXRob2QgPT09IEludGVyYWN0aW9uTWV0aG9kLkFQSSkge1xuICAgICAgaXRlbS50cmFuc2xhdGVYID0gbnVsbDtcbiAgICAgIGl0ZW0udHJhbnNsYXRlWCA9IHggLSAzMDtcbiAgICAgIGl0ZW0udHJhbnNsYXRlWSA9IG51bGw7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGFuIGV4aXN0aW5nIGl0ZW1cbiAgICogQHBhcmFtIHJvb3RcbiAgICogQHBhcmFtIGFjdGlvblxuICAgKi9cbiAgdmFyIHJlbW92ZUl0ZW1WaWV3ID0gZnVuY3Rpb24gcmVtb3ZlSXRlbVZpZXcoX3JlZjMpIHtcbiAgICB2YXIgcm9vdCA9IF9yZWYzLnJvb3QsXG4gICAgICBhY3Rpb24gPSBfcmVmMy5hY3Rpb247XG4gICAgdmFyIGlkID0gYWN0aW9uLmlkO1xuXG4gICAgLy8gZ2V0IHRoZSB2aWV3IG1hdGNoaW5nIHRoZSBnaXZlbiBpZFxuICAgIHZhciB2aWV3ID0gcm9vdC5jaGlsZFZpZXdzLmZpbmQoZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgIHJldHVybiBjaGlsZC5pZCA9PT0gaWQ7XG4gICAgfSk7XG5cbiAgICAvLyBpZiBubyB2aWV3IGZvdW5kLCBleGl0XG4gICAgaWYgKCF2aWV3KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYW5pbWF0ZSB2aWV3IG91dCBvZiB2aWV3XG4gICAgdmlldy5zY2FsZVggPSAwLjk7XG4gICAgdmlldy5zY2FsZVkgPSAwLjk7XG4gICAgdmlldy5vcGFjaXR5ID0gMDtcblxuICAgIC8vIG1hcmsgZm9yIHJlbW92YWxcbiAgICB2aWV3Lm1hcmtlZEZvclJlbW92YWwgPSB0cnVlO1xuICB9O1xuXG4gIHZhciBnZXRJdGVtSGVpZ2h0ID0gZnVuY3Rpb24gZ2V0SXRlbUhlaWdodChjaGlsZCkge1xuICAgIHJldHVybiAoXG4gICAgICBjaGlsZC5yZWN0LmVsZW1lbnQuaGVpZ2h0ICtcbiAgICAgIGNoaWxkLnJlY3QuZWxlbWVudC5tYXJnaW5Cb3R0b20gKiAwLjUgK1xuICAgICAgY2hpbGQucmVjdC5lbGVtZW50Lm1hcmdpblRvcCAqIDAuNVxuICAgICk7XG4gIH07XG4gIHZhciBnZXRJdGVtV2lkdGggPSBmdW5jdGlvbiBnZXRJdGVtV2lkdGgoY2hpbGQpIHtcbiAgICByZXR1cm4gKFxuICAgICAgY2hpbGQucmVjdC5lbGVtZW50LndpZHRoICtcbiAgICAgIGNoaWxkLnJlY3QuZWxlbWVudC5tYXJnaW5MZWZ0ICogMC41ICtcbiAgICAgIGNoaWxkLnJlY3QuZWxlbWVudC5tYXJnaW5SaWdodCAqIDAuNVxuICAgICk7XG4gIH07XG5cbiAgdmFyIGRyYWdJdGVtID0gZnVuY3Rpb24gZHJhZ0l0ZW0oX3JlZjQpIHtcbiAgICB2YXIgcm9vdCA9IF9yZWY0LnJvb3QsXG4gICAgICBhY3Rpb24gPSBfcmVmNC5hY3Rpb247XG4gICAgdmFyIGlkID0gYWN0aW9uLmlkLFxuICAgICAgZHJhZ1N0YXRlID0gYWN0aW9uLmRyYWdTdGF0ZTtcblxuICAgIC8vIHJlZmVyZW5jZSB0byBpdGVtXG4gICAgdmFyIGl0ZW0gPSByb290LnF1ZXJ5KCdHRVRfSVRFTScsIHsgaWQ6IGlkIH0pO1xuXG4gICAgLy8gZ2V0IHRoZSB2aWV3IG1hdGNoaW5nIHRoZSBnaXZlbiBpZFxuICAgIHZhciB2aWV3ID0gcm9vdC5jaGlsZFZpZXdzLmZpbmQoZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgIHJldHVybiBjaGlsZC5pZCA9PT0gaWQ7XG4gICAgfSk7XG5cbiAgICB2YXIgbnVtSXRlbXMgPSByb290LmNoaWxkVmlld3MubGVuZ3RoO1xuICAgIHZhciBvbGRJbmRleCA9IGRyYWdTdGF0ZS5nZXRJdGVtSW5kZXgoaXRlbSk7XG5cbiAgICAvLyBpZiBubyB2aWV3IGZvdW5kLCBleGl0XG4gICAgaWYgKCF2aWV3KSByZXR1cm47XG5cbiAgICB2YXIgZHJhZ1Bvc2l0aW9uID0ge1xuICAgICAgeDogdmlldy5kcmFnT3JpZ2luLnggKyB2aWV3LmRyYWdPZmZzZXQueCArIHZpZXcuZHJhZ0NlbnRlci54LFxuICAgICAgeTogdmlldy5kcmFnT3JpZ2luLnkgKyB2aWV3LmRyYWdPZmZzZXQueSArIHZpZXcuZHJhZ0NlbnRlci55XG5cbiAgICAgIC8vIGdldCBkcmFnIGFyZWEgZGltZW5zaW9uc1xuICAgIH07XG4gICAgdmFyIGRyYWdIZWlnaHQgPSBnZXRJdGVtSGVpZ2h0KHZpZXcpO1xuICAgIHZhciBkcmFnV2lkdGggPSBnZXRJdGVtV2lkdGgodmlldyk7XG5cbiAgICAvLyBnZXQgcm93cyBhbmQgY29sdW1ucyAoVGhlcmUgd2lsbCBhbHdheXMgYmUgYXQgbGVhc3Qgb25lIHJvdyBhbmQgb25lIGNvbHVtbiBpZiBhIGZpbGUgaXMgcHJlc2VudClcbiAgICB2YXIgY29scyA9IE1hdGguZmxvb3Iocm9vdC5yZWN0Lm91dGVyLndpZHRoIC8gZHJhZ1dpZHRoKTtcbiAgICBpZiAoY29scyA+IG51bUl0ZW1zKSBjb2xzID0gbnVtSXRlbXM7XG5cbiAgICAvLyByb3dzIGFyZSB1c2VkIHRvIGZpbmQgd2hlbiB3ZSBoYXZlIGxlZnQgdGhlIHByZXZpZXcgYXJlYSBib3VuZGluZyBib3hcbiAgICB2YXIgcm93cyA9IE1hdGguZmxvb3IobnVtSXRlbXMgLyBjb2xzICsgMSk7XG5cbiAgICBkcm9wQXJlYURpbWVuc2lvbnMuc2V0SGVpZ2h0ID0gZHJhZ0hlaWdodCAqIHJvd3M7XG4gICAgZHJvcEFyZWFEaW1lbnNpb25zLnNldFdpZHRoID0gZHJhZ1dpZHRoICogY29scztcblxuICAgIC8vIGdldCBuZXcgaW5kZXggb2YgZHJhZ2dlZCBpdGVtXG4gICAgdmFyIGxvY2F0aW9uID0ge1xuICAgICAgeTogTWF0aC5mbG9vcihkcmFnUG9zaXRpb24ueSAvIGRyYWdIZWlnaHQpLFxuICAgICAgeDogTWF0aC5mbG9vcihkcmFnUG9zaXRpb24ueCAvIGRyYWdXaWR0aCksXG4gICAgICBnZXRHcmlkSW5kZXg6IGZ1bmN0aW9uIGdldEdyaWRJbmRleCgpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGRyYWdQb3NpdGlvbi55ID4gZHJvcEFyZWFEaW1lbnNpb25zLmdldEhlaWdodCB8fFxuICAgICAgICAgIGRyYWdQb3NpdGlvbi55IDwgMCB8fFxuICAgICAgICAgIGRyYWdQb3NpdGlvbi54ID4gZHJvcEFyZWFEaW1lbnNpb25zLmdldFdpZHRoIHx8XG4gICAgICAgICAgZHJhZ1Bvc2l0aW9uLnggPCAwXG4gICAgICAgIClcbiAgICAgICAgICByZXR1cm4gb2xkSW5kZXg7XG4gICAgICAgIHJldHVybiB0aGlzLnkgKiBjb2xzICsgdGhpcy54O1xuICAgICAgfSxcbiAgICAgIGdldENvbEluZGV4OiBmdW5jdGlvbiBnZXRDb2xJbmRleCgpIHtcbiAgICAgICAgdmFyIGl0ZW1zID0gcm9vdC5xdWVyeSgnR0VUX0FDVElWRV9JVEVNUycpO1xuICAgICAgICB2YXIgdmlzaWJsZUNoaWxkcmVuID0gcm9vdC5jaGlsZFZpZXdzLmZpbHRlcihmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICAgIHJldHVybiBjaGlsZC5yZWN0LmVsZW1lbnQuaGVpZ2h0O1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gaXRlbXMubWFwKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICByZXR1cm4gdmlzaWJsZUNoaWxkcmVuLmZpbmQoZnVuY3Rpb24oY2hpbGRWaWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gY2hpbGRWaWV3LmlkID09PSBpdGVtLmlkO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGN1cnJlbnRJbmRleCA9IGNoaWxkcmVuLmZpbmRJbmRleChmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICAgIHJldHVybiBjaGlsZCA9PT0gdmlldztcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBkcmFnSGVpZ2h0ID0gZ2V0SXRlbUhlaWdodCh2aWV3KTtcbiAgICAgICAgdmFyIGwgPSBjaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgIHZhciBpZHggPSBsO1xuICAgICAgICB2YXIgY2hpbGRIZWlnaHQgPSAwO1xuICAgICAgICB2YXIgY2hpbGRCb3R0b20gPSAwO1xuICAgICAgICB2YXIgY2hpbGRUb3AgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGNoaWxkSGVpZ2h0ID0gZ2V0SXRlbUhlaWdodChjaGlsZHJlbltpXSk7XG4gICAgICAgICAgY2hpbGRUb3AgPSBjaGlsZEJvdHRvbTtcbiAgICAgICAgICBjaGlsZEJvdHRvbSA9IGNoaWxkVG9wICsgY2hpbGRIZWlnaHQ7XG4gICAgICAgICAgaWYgKGRyYWdQb3NpdGlvbi55IDwgY2hpbGRCb3R0b20pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50SW5kZXggPiBpKSB7XG4gICAgICAgICAgICAgIGlmIChkcmFnUG9zaXRpb24ueSA8IGNoaWxkVG9wICsgZHJhZ0hlaWdodCkge1xuICAgICAgICAgICAgICAgIGlkeCA9IGk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZHggPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpZHg7XG4gICAgICB9XG5cbiAgICAgIC8vIGdldCBuZXcgaW5kZXhcbiAgICB9O1xuICAgIHZhciBpbmRleCA9IGNvbHMgPiAxID8gbG9jYXRpb24uZ2V0R3JpZEluZGV4KCkgOiBsb2NhdGlvbi5nZXRDb2xJbmRleCgpO1xuICAgIHJvb3QuZGlzcGF0Y2goJ01PVkVfSVRFTScsIHsgcXVlcnk6IHZpZXcsIGluZGV4OiBpbmRleCB9KTtcblxuICAgIC8vIGlmIHRoZSBpbmRleCBvZiB0aGUgaXRlbSBjaGFuZ2VkLCBkaXNwYXRjaCByZW9yZGVyIGFjdGlvblxuICAgIHZhciBjdXJyZW50SW5kZXggPSBkcmFnU3RhdGUuZ2V0SW5kZXgoKTtcblxuICAgIGlmIChjdXJyZW50SW5kZXggPT09IHVuZGVmaW5lZCB8fCBjdXJyZW50SW5kZXggIT09IGluZGV4KSB7XG4gICAgICBkcmFnU3RhdGUuc2V0SW5kZXgoaW5kZXgpO1xuXG4gICAgICBpZiAoY3VycmVudEluZGV4ID09PSB1bmRlZmluZWQpIHJldHVybjtcblxuICAgICAgcm9vdC5kaXNwYXRjaCgnRElEX1JFT1JERVJfSVRFTVMnLCB7XG4gICAgICAgIGl0ZW1zOiByb290LnF1ZXJ5KCdHRVRfQUNUSVZFX0lURU1TJyksXG4gICAgICAgIG9yaWdpbjogb2xkSW5kZXgsXG4gICAgICAgIHRhcmdldDogaW5kZXhcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU2V0dXAgYWN0aW9uIHJvdXRlc1xuICAgKi9cbiAgdmFyIHJvdXRlJDIgPSBjcmVhdGVSb3V0ZSh7XG4gICAgRElEX0FERF9JVEVNOiBhZGRJdGVtVmlldyxcbiAgICBESURfUkVNT1ZFX0lURU06IHJlbW92ZUl0ZW1WaWV3LFxuICAgIERJRF9EUkFHX0lURU06IGRyYWdJdGVtXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBXcml0ZSB0byB2aWV3XG4gICAqIEBwYXJhbSByb290XG4gICAqIEBwYXJhbSBhY3Rpb25zXG4gICAqIEBwYXJhbSBwcm9wc1xuICAgKi9cbiAgdmFyIHdyaXRlJDUgPSBmdW5jdGlvbiB3cml0ZShfcmVmNSkge1xuICAgIHZhciByb290ID0gX3JlZjUucm9vdCxcbiAgICAgIHByb3BzID0gX3JlZjUucHJvcHMsXG4gICAgICBhY3Rpb25zID0gX3JlZjUuYWN0aW9ucyxcbiAgICAgIHNob3VsZE9wdGltaXplID0gX3JlZjUuc2hvdWxkT3B0aW1pemU7XG5cbiAgICAvLyByb3V0ZSBhY3Rpb25zXG4gICAgcm91dGUkMih7IHJvb3Q6IHJvb3QsIHByb3BzOiBwcm9wcywgYWN0aW9uczogYWN0aW9ucyB9KTtcbiAgICB2YXIgZHJhZ0Nvb3JkaW5hdGVzID0gcHJvcHMuZHJhZ0Nvb3JkaW5hdGVzO1xuXG4gICAgLy8gYXZhaWxhYmxlIHNwYWNlIG9uIGhvcml6b250YWwgYXhpc1xuICAgIHZhciBob3Jpem9udGFsU3BhY2UgPSByb290LnJlY3QuZWxlbWVudC53aWR0aDtcblxuICAgIC8vIG9ubHkgZHJhdyBjaGlsZHJlbiB0aGF0IGhhdmUgZGltZW5zaW9uc1xuICAgIHZhciB2aXNpYmxlQ2hpbGRyZW4gPSByb290LmNoaWxkVmlld3MuZmlsdGVyKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICByZXR1cm4gY2hpbGQucmVjdC5lbGVtZW50LmhlaWdodDtcbiAgICB9KTtcblxuICAgIC8vIHNvcnQgYmFzZWQgb24gY3VycmVudCBhY3RpdmUgaXRlbXNcbiAgICB2YXIgY2hpbGRyZW4gPSByb290XG4gICAgICAucXVlcnkoJ0dFVF9BQ1RJVkVfSVRFTVMnKVxuICAgICAgLm1hcChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgIHJldHVybiB2aXNpYmxlQ2hpbGRyZW4uZmluZChmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICAgIHJldHVybiBjaGlsZC5pZCA9PT0gaXRlbS5pZDtcbiAgICAgICAgfSk7XG4gICAgICB9KVxuICAgICAgLmZpbHRlcihmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgfSk7XG5cbiAgICAvLyBnZXQgaW5kZXhcbiAgICB2YXIgZHJhZ0luZGV4ID0gZHJhZ0Nvb3JkaW5hdGVzXG4gICAgICA/IGdldEl0ZW1JbmRleEJ5UG9zaXRpb24ocm9vdCwgY2hpbGRyZW4sIGRyYWdDb29yZGluYXRlcylcbiAgICAgIDogbnVsbDtcblxuICAgIC8vIGFkZCBpbmRleCBpcyB1c2VkIHRvIHJlc2VydmUgdGhlIGRyb3BwZWQvYWRkZWQgaXRlbSBpbmRleCB0aWxsIHRoZSBhY3R1YWwgaXRlbSBpcyByZW5kZXJlZFxuICAgIHZhciBhZGRJbmRleCA9IHJvb3QucmVmLmFkZEluZGV4IHx8IG51bGw7XG5cbiAgICAvLyBhZGQgaW5kZXggbm8gbG9uZ2VyIG5lZWRlZCB0aWxsIHBvc3NpYmx5IG5leHQgZHJhd1xuICAgIHJvb3QucmVmLmFkZEluZGV4ID0gbnVsbDtcblxuICAgIHZhciBkcmFnSW5kZXhPZmZzZXQgPSAwO1xuICAgIHZhciByZW1vdmVJbmRleE9mZnNldCA9IDA7XG4gICAgdmFyIGFkZEluZGV4T2Zmc2V0ID0gMDtcblxuICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPT09IDApIHJldHVybjtcblxuICAgIHZhciBjaGlsZFJlY3QgPSBjaGlsZHJlblswXS5yZWN0LmVsZW1lbnQ7XG4gICAgdmFyIGl0ZW1WZXJ0aWNhbE1hcmdpbiA9IGNoaWxkUmVjdC5tYXJnaW5Ub3AgKyBjaGlsZFJlY3QubWFyZ2luQm90dG9tO1xuICAgIHZhciBpdGVtSG9yaXpvbnRhbE1hcmdpbiA9IGNoaWxkUmVjdC5tYXJnaW5MZWZ0ICsgY2hpbGRSZWN0Lm1hcmdpblJpZ2h0O1xuICAgIHZhciBpdGVtV2lkdGggPSBjaGlsZFJlY3Qud2lkdGggKyBpdGVtSG9yaXpvbnRhbE1hcmdpbjtcbiAgICB2YXIgaXRlbUhlaWdodCA9IGNoaWxkUmVjdC5oZWlnaHQgKyBpdGVtVmVydGljYWxNYXJnaW47XG4gICAgdmFyIGl0ZW1zUGVyUm93ID0gTWF0aC5yb3VuZChob3Jpem9udGFsU3BhY2UgLyBpdGVtV2lkdGgpO1xuXG4gICAgLy8gc3RhY2tcbiAgICBpZiAoaXRlbXNQZXJSb3cgPT09IDEpIHtcbiAgICAgIHZhciBvZmZzZXRZID0gMDtcbiAgICAgIHZhciBkcmFnT2Zmc2V0ID0gMDtcblxuICAgICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbihjaGlsZCwgaW5kZXgpIHtcbiAgICAgICAgaWYgKGRyYWdJbmRleCkge1xuICAgICAgICAgIHZhciBkaXN0ID0gaW5kZXggLSBkcmFnSW5kZXg7XG4gICAgICAgICAgaWYgKGRpc3QgPT09IC0yKSB7XG4gICAgICAgICAgICBkcmFnT2Zmc2V0ID0gLWl0ZW1WZXJ0aWNhbE1hcmdpbiAqIDAuMjU7XG4gICAgICAgICAgfSBlbHNlIGlmIChkaXN0ID09PSAtMSkge1xuICAgICAgICAgICAgZHJhZ09mZnNldCA9IC1pdGVtVmVydGljYWxNYXJnaW4gKiAwLjc1O1xuICAgICAgICAgIH0gZWxzZSBpZiAoZGlzdCA9PT0gMCkge1xuICAgICAgICAgICAgZHJhZ09mZnNldCA9IGl0ZW1WZXJ0aWNhbE1hcmdpbiAqIDAuNzU7XG4gICAgICAgICAgfSBlbHNlIGlmIChkaXN0ID09PSAxKSB7XG4gICAgICAgICAgICBkcmFnT2Zmc2V0ID0gaXRlbVZlcnRpY2FsTWFyZ2luICogMC4yNTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZHJhZ09mZnNldCA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNob3VsZE9wdGltaXplKSB7XG4gICAgICAgICAgY2hpbGQudHJhbnNsYXRlWCA9IG51bGw7XG4gICAgICAgICAgY2hpbGQudHJhbnNsYXRlWSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWNoaWxkLm1hcmtlZEZvclJlbW92YWwpIHtcbiAgICAgICAgICBtb3ZlSXRlbShjaGlsZCwgMCwgb2Zmc2V0WSArIGRyYWdPZmZzZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGl0ZW1IZWlnaHQgPSBjaGlsZC5yZWN0LmVsZW1lbnQuaGVpZ2h0ICsgaXRlbVZlcnRpY2FsTWFyZ2luO1xuXG4gICAgICAgIHZhciB2aXN1YWxIZWlnaHQgPVxuICAgICAgICAgIGl0ZW1IZWlnaHQgKiAoY2hpbGQubWFya2VkRm9yUmVtb3ZhbCA/IGNoaWxkLm9wYWNpdHkgOiAxKTtcblxuICAgICAgICBvZmZzZXRZICs9IHZpc3VhbEhlaWdodDtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBncmlkXG4gICAgZWxzZSB7XG4gICAgICB2YXIgcHJldlggPSAwO1xuICAgICAgdmFyIHByZXZZID0gMDtcblxuICAgICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbihjaGlsZCwgaW5kZXgpIHtcbiAgICAgICAgaWYgKGluZGV4ID09PSBkcmFnSW5kZXgpIHtcbiAgICAgICAgICBkcmFnSW5kZXhPZmZzZXQgPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluZGV4ID09PSBhZGRJbmRleCkge1xuICAgICAgICAgIGFkZEluZGV4T2Zmc2V0ICs9IDE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2hpbGQubWFya2VkRm9yUmVtb3ZhbCAmJiBjaGlsZC5vcGFjaXR5IDwgMC41KSB7XG4gICAgICAgICAgcmVtb3ZlSW5kZXhPZmZzZXQgLT0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB2aXN1YWxJbmRleCA9XG4gICAgICAgICAgaW5kZXggKyBhZGRJbmRleE9mZnNldCArIGRyYWdJbmRleE9mZnNldCArIHJlbW92ZUluZGV4T2Zmc2V0O1xuXG4gICAgICAgIHZhciBpbmRleFggPSB2aXN1YWxJbmRleCAlIGl0ZW1zUGVyUm93O1xuICAgICAgICB2YXIgaW5kZXhZID0gTWF0aC5mbG9vcih2aXN1YWxJbmRleCAvIGl0ZW1zUGVyUm93KTtcblxuICAgICAgICB2YXIgb2Zmc2V0WCA9IGluZGV4WCAqIGl0ZW1XaWR0aDtcbiAgICAgICAgdmFyIG9mZnNldFkgPSBpbmRleFkgKiBpdGVtSGVpZ2h0O1xuXG4gICAgICAgIHZhciB2ZWN0b3JYID0gTWF0aC5zaWduKG9mZnNldFggLSBwcmV2WCk7XG4gICAgICAgIHZhciB2ZWN0b3JZID0gTWF0aC5zaWduKG9mZnNldFkgLSBwcmV2WSk7XG5cbiAgICAgICAgcHJldlggPSBvZmZzZXRYO1xuICAgICAgICBwcmV2WSA9IG9mZnNldFk7XG5cbiAgICAgICAgaWYgKGNoaWxkLm1hcmtlZEZvclJlbW92YWwpIHJldHVybjtcblxuICAgICAgICBpZiAoc2hvdWxkT3B0aW1pemUpIHtcbiAgICAgICAgICBjaGlsZC50cmFuc2xhdGVYID0gbnVsbDtcbiAgICAgICAgICBjaGlsZC50cmFuc2xhdGVZID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIG1vdmVJdGVtKGNoaWxkLCBvZmZzZXRYLCBvZmZzZXRZLCB2ZWN0b3JYLCB2ZWN0b3JZKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogRmlsdGVycyBhY3Rpb25zIHRoYXQgYXJlIG1lYW50IHNwZWNpZmljYWxseSBmb3IgYSBjZXJ0YWluIGNoaWxkIG9mIHRoZSBsaXN0XG4gICAqIEBwYXJhbSBjaGlsZFxuICAgKiBAcGFyYW0gYWN0aW9uc1xuICAgKi9cbiAgdmFyIGZpbHRlclNldEl0ZW1BY3Rpb25zID0gZnVuY3Rpb24gZmlsdGVyU2V0SXRlbUFjdGlvbnMoY2hpbGQsIGFjdGlvbnMpIHtcbiAgICByZXR1cm4gYWN0aW9ucy5maWx0ZXIoZnVuY3Rpb24oYWN0aW9uKSB7XG4gICAgICAvLyBpZiBhY3Rpb24gaGFzIGFuIGlkLCBmaWx0ZXIgb3V0IGFjdGlvbnMgdGhhdCBkb24ndCBoYXZlIHRoaXMgY2hpbGQgaWRcbiAgICAgIGlmIChhY3Rpb24uZGF0YSAmJiBhY3Rpb24uZGF0YS5pZCkge1xuICAgICAgICByZXR1cm4gY2hpbGQuaWQgPT09IGFjdGlvbi5kYXRhLmlkO1xuICAgICAgfVxuXG4gICAgICAvLyBhbGxvdyBhbGwgb3RoZXIgYWN0aW9uc1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIGxpc3QgPSBjcmVhdGVWaWV3KHtcbiAgICBjcmVhdGU6IGNyZWF0ZSQ4LFxuICAgIHdyaXRlOiB3cml0ZSQ1LFxuICAgIHRhZzogJ3VsJyxcbiAgICBuYW1lOiAnbGlzdCcsXG4gICAgZGlkV3JpdGVWaWV3OiBmdW5jdGlvbiBkaWRXcml0ZVZpZXcoX3JlZjYpIHtcbiAgICAgIHZhciByb290ID0gX3JlZjYucm9vdDtcbiAgICAgIHJvb3QuY2hpbGRWaWV3c1xuICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKHZpZXcpIHtcbiAgICAgICAgICByZXR1cm4gdmlldy5tYXJrZWRGb3JSZW1vdmFsICYmIHZpZXcub3BhY2l0eSA9PT0gMCAmJiB2aWV3LnJlc3Rpbmc7XG4gICAgICAgIH0pXG4gICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uKHZpZXcpIHtcbiAgICAgICAgICB2aWV3Ll9kZXN0cm95KCk7XG4gICAgICAgICAgcm9vdC5yZW1vdmVDaGlsZFZpZXcodmlldyk7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgZmlsdGVyRnJhbWVBY3Rpb25zRm9yQ2hpbGQ6IGZpbHRlclNldEl0ZW1BY3Rpb25zLFxuICAgIG1peGluczoge1xuICAgICAgYXBpczogWydkcmFnQ29vcmRpbmF0ZXMnXVxuICAgIH1cbiAgfSk7XG5cbiAgdmFyIGNyZWF0ZSQ5ID0gZnVuY3Rpb24gY3JlYXRlKF9yZWYpIHtcbiAgICB2YXIgcm9vdCA9IF9yZWYucm9vdCxcbiAgICAgIHByb3BzID0gX3JlZi5wcm9wcztcbiAgICByb290LnJlZi5saXN0ID0gcm9vdC5hcHBlbmRDaGlsZFZpZXcocm9vdC5jcmVhdGVDaGlsZFZpZXcobGlzdCkpO1xuICAgIHByb3BzLmRyYWdDb29yZGluYXRlcyA9IG51bGw7XG4gICAgcHJvcHMub3ZlcmZsb3dpbmcgPSBmYWxzZTtcbiAgfTtcblxuICB2YXIgc3RvcmVEcmFnQ29vcmRpbmF0ZXMgPSBmdW5jdGlvbiBzdG9yZURyYWdDb29yZGluYXRlcyhfcmVmMikge1xuICAgIHZhciByb290ID0gX3JlZjIucm9vdCxcbiAgICAgIHByb3BzID0gX3JlZjIucHJvcHMsXG4gICAgICBhY3Rpb24gPSBfcmVmMi5hY3Rpb247XG4gICAgaWYgKCFyb290LnF1ZXJ5KCdHRVRfSVRFTV9JTlNFUlRfTE9DQVRJT05fRlJFRURPTScpKSByZXR1cm47XG4gICAgcHJvcHMuZHJhZ0Nvb3JkaW5hdGVzID0ge1xuICAgICAgbGVmdDogYWN0aW9uLnBvc2l0aW9uLnNjb3BlTGVmdCAtIHJvb3QucmVmLmxpc3QucmVjdC5lbGVtZW50LmxlZnQsXG4gICAgICB0b3A6XG4gICAgICAgIGFjdGlvbi5wb3NpdGlvbi5zY29wZVRvcCAtXG4gICAgICAgIChyb290LnJlY3Qub3V0ZXIudG9wICtcbiAgICAgICAgICByb290LnJlY3QuZWxlbWVudC5tYXJnaW5Ub3AgK1xuICAgICAgICAgIHJvb3QucmVjdC5lbGVtZW50LnNjcm9sbFRvcClcbiAgICB9O1xuICB9O1xuXG4gIHZhciBjbGVhckRyYWdDb29yZGluYXRlcyA9IGZ1bmN0aW9uIGNsZWFyRHJhZ0Nvb3JkaW5hdGVzKF9yZWYzKSB7XG4gICAgdmFyIHByb3BzID0gX3JlZjMucHJvcHM7XG4gICAgcHJvcHMuZHJhZ0Nvb3JkaW5hdGVzID0gbnVsbDtcbiAgfTtcblxuICB2YXIgcm91dGUkMyA9IGNyZWF0ZVJvdXRlKHtcbiAgICBESURfRFJBRzogc3RvcmVEcmFnQ29vcmRpbmF0ZXMsXG4gICAgRElEX0VORF9EUkFHOiBjbGVhckRyYWdDb29yZGluYXRlc1xuICB9KTtcblxuICB2YXIgd3JpdGUkNiA9IGZ1bmN0aW9uIHdyaXRlKF9yZWY0KSB7XG4gICAgdmFyIHJvb3QgPSBfcmVmNC5yb290LFxuICAgICAgcHJvcHMgPSBfcmVmNC5wcm9wcyxcbiAgICAgIGFjdGlvbnMgPSBfcmVmNC5hY3Rpb25zO1xuXG4gICAgLy8gcm91dGUgYWN0aW9uc1xuICAgIHJvdXRlJDMoeyByb290OiByb290LCBwcm9wczogcHJvcHMsIGFjdGlvbnM6IGFjdGlvbnMgfSk7XG5cbiAgICAvLyBjdXJyZW50IGRyYWcgcG9zaXRpb25cbiAgICByb290LnJlZi5saXN0LmRyYWdDb29yZGluYXRlcyA9IHByb3BzLmRyYWdDb29yZGluYXRlcztcblxuICAgIC8vIGlmIGN1cnJlbnRseSBvdmVyZmxvd2luZyBidXQgbm8gbG9uZ2VyIHJlY2VpdmVkIG92ZXJmbG93XG4gICAgaWYgKHByb3BzLm92ZXJmbG93aW5nICYmICFwcm9wcy5vdmVyZmxvdykge1xuICAgICAgcHJvcHMub3ZlcmZsb3dpbmcgPSBmYWxzZTtcblxuICAgICAgLy8gcmVzZXQgb3ZlcmZsb3cgc3RhdGVcbiAgICAgIHJvb3QuZWxlbWVudC5kYXRhc2V0LnN0YXRlID0gJyc7XG4gICAgICByb290LmhlaWdodCA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gaWYgaXMgbm90IG92ZXJmbG93aW5nIGN1cnJlbnRseSBidXQgZG9lcyByZWNlaXZlIG92ZXJmbG93IHZhbHVlXG4gICAgaWYgKHByb3BzLm92ZXJmbG93KSB7XG4gICAgICB2YXIgbmV3SGVpZ2h0ID0gTWF0aC5yb3VuZChwcm9wcy5vdmVyZmxvdyk7XG4gICAgICBpZiAobmV3SGVpZ2h0ICE9PSByb290LmhlaWdodCkge1xuICAgICAgICBwcm9wcy5vdmVyZmxvd2luZyA9IHRydWU7XG4gICAgICAgIHJvb3QuZWxlbWVudC5kYXRhc2V0LnN0YXRlID0gJ292ZXJmbG93JztcbiAgICAgICAgcm9vdC5oZWlnaHQgPSBuZXdIZWlnaHQ7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHZhciBsaXN0U2Nyb2xsZXIgPSBjcmVhdGVWaWV3KHtcbiAgICBjcmVhdGU6IGNyZWF0ZSQ5LFxuICAgIHdyaXRlOiB3cml0ZSQ2LFxuICAgIG5hbWU6ICdsaXN0LXNjcm9sbGVyJyxcbiAgICBtaXhpbnM6IHtcbiAgICAgIGFwaXM6IFsnb3ZlcmZsb3cnLCAnZHJhZ0Nvb3JkaW5hdGVzJ10sXG4gICAgICBzdHlsZXM6IFsnaGVpZ2h0JywgJ3RyYW5zbGF0ZVknXSxcbiAgICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgICAgdHJhbnNsYXRlWTogJ3NwcmluZydcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHZhciBhdHRyVG9nZ2xlID0gZnVuY3Rpb24gYXR0clRvZ2dsZShlbGVtZW50LCBuYW1lLCBzdGF0ZSkge1xuICAgIHZhciBlbmFibGVkVmFsdWUgPVxuICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiAnJztcbiAgICBpZiAoc3RhdGUpIHtcbiAgICAgIGF0dHIoZWxlbWVudCwgbmFtZSwgZW5hYmxlZFZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciByZXNldEZpbGVJbnB1dCA9IGZ1bmN0aW9uIHJlc2V0RmlsZUlucHV0KGlucHV0KSB7XG4gICAgLy8gbm8gdmFsdWUsIG5vIG5lZWQgdG8gcmVzZXRcbiAgICBpZiAoIWlucHV0IHx8IGlucHV0LnZhbHVlID09PSAnJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAvLyBmb3IgbW9kZXJuIGJyb3dzZXJzXG4gICAgICBpbnB1dC52YWx1ZSA9ICcnO1xuICAgIH0gY2F0Y2ggKGVycikge31cblxuICAgIC8vIGZvciBJRTEwXG4gICAgaWYgKGlucHV0LnZhbHVlKSB7XG4gICAgICAvLyBxdWlja2x5IGFwcGVuZCBpbnB1dCB0byB0ZW1wIGZvcm0gYW5kIHJlc2V0IGZvcm1cbiAgICAgIHZhciBmb3JtID0gY3JlYXRlRWxlbWVudCQxKCdmb3JtJyk7XG4gICAgICB2YXIgcGFyZW50Tm9kZSA9IGlucHV0LnBhcmVudE5vZGU7XG4gICAgICB2YXIgcmVmID0gaW5wdXQubmV4dFNpYmxpbmc7XG4gICAgICBmb3JtLmFwcGVuZENoaWxkKGlucHV0KTtcbiAgICAgIGZvcm0ucmVzZXQoKTtcblxuICAgICAgLy8gcmUtaW5qZWN0IGlucHV0IHdoZXJlIGl0IG9yaWdpbmFsbHkgd2FzXG4gICAgICBpZiAocmVmKSB7XG4gICAgICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGlucHV0LCByZWYpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyZW50Tm9kZS5hcHBlbmRDaGlsZChpbnB1dCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHZhciBjcmVhdGUkYSA9IGZ1bmN0aW9uIGNyZWF0ZShfcmVmKSB7XG4gICAgdmFyIHJvb3QgPSBfcmVmLnJvb3QsXG4gICAgICBwcm9wcyA9IF9yZWYucHJvcHM7XG5cbiAgICAvLyBzZXQgaWQgc28gY2FuIGJlIHJlZmVyZW5jZWQgZnJvbSBvdXRzaWRlIGxhYmVsc1xuICAgIHJvb3QuZWxlbWVudC5pZCA9ICdmaWxlcG9uZC0tYnJvd3Nlci0nICsgcHJvcHMuaWQ7XG5cbiAgICAvLyBzZXQgbmFtZSBvZiBlbGVtZW50IChpcyByZW1vdmVkIHdoZW4gYSB2YWx1ZSBpcyBzZXQpXG4gICAgYXR0cihyb290LmVsZW1lbnQsICduYW1lJywgcm9vdC5xdWVyeSgnR0VUX05BTUUnKSk7XG5cbiAgICAvLyB3ZSBoYXZlIHRvIGxpbmsgdGhpcyBlbGVtZW50IHRvIHRoZSBzdGF0dXMgZWxlbWVudFxuICAgIGF0dHIocm9vdC5lbGVtZW50LCAnYXJpYS1jb250cm9scycsICdmaWxlcG9uZC0tYXNzaXN0YW50LScgKyBwcm9wcy5pZCk7XG5cbiAgICAvLyBzZXQgbGFiZWwsIHdlIHVzZSBsYWJlbGxlZCBieSBhcyBvdGhlcndpc2UgdGhlIHNjcmVlbnJlYWRlciBkb2VzIG5vdCByZWFkIHRoZSBcImJyb3dzZVwiIHRleHQgaW4gdGhlIGxhYmVsIChhcyBpdCBoYXMgdGFiaW5kZXg6IDApXG4gICAgYXR0cihyb290LmVsZW1lbnQsICdhcmlhLWxhYmVsbGVkYnknLCAnZmlsZXBvbmQtLWRyb3AtbGFiZWwtJyArIHByb3BzLmlkKTtcblxuICAgIC8vIHNldCBjb25maWd1cmFibGUgcHJvcHNcbiAgICBzZXRBY2NlcHRlZEZpbGVUeXBlcyh7XG4gICAgICByb290OiByb290LFxuICAgICAgYWN0aW9uOiB7IHZhbHVlOiByb290LnF1ZXJ5KCdHRVRfQUNDRVBURURfRklMRV9UWVBFUycpIH1cbiAgICB9KTtcbiAgICB0b2dnbGVBbGxvd011bHRpcGxlKHtcbiAgICAgIHJvb3Q6IHJvb3QsXG4gICAgICBhY3Rpb246IHsgdmFsdWU6IHJvb3QucXVlcnkoJ0dFVF9BTExPV19NVUxUSVBMRScpIH1cbiAgICB9KTtcbiAgICB0b2dnbGVEaXJlY3RvcnlGaWx0ZXIoe1xuICAgICAgcm9vdDogcm9vdCxcbiAgICAgIGFjdGlvbjogeyB2YWx1ZTogcm9vdC5xdWVyeSgnR0VUX0FMTE9XX0RJUkVDVE9SSUVTX09OTFknKSB9XG4gICAgfSk7XG4gICAgdG9nZ2xlRGlzYWJsZWQoeyByb290OiByb290IH0pO1xuICAgIHRvZ2dsZVJlcXVpcmVkKHtcbiAgICAgIHJvb3Q6IHJvb3QsXG4gICAgICBhY3Rpb246IHsgdmFsdWU6IHJvb3QucXVlcnkoJ0dFVF9SRVFVSVJFRCcpIH1cbiAgICB9KTtcbiAgICBzZXRDYXB0dXJlTWV0aG9kKHtcbiAgICAgIHJvb3Q6IHJvb3QsXG4gICAgICBhY3Rpb246IHsgdmFsdWU6IHJvb3QucXVlcnkoJ0dFVF9DQVBUVVJFX01FVEhPRCcpIH1cbiAgICB9KTtcblxuICAgIC8vIGhhbmRsZSBjaGFuZ2VzIHRvIHRoZSBpbnB1dCBmaWVsZFxuICAgIHJvb3QucmVmLmhhbmRsZUNoYW5nZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmICghcm9vdC5lbGVtZW50LnZhbHVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gZXh0cmFjdCBmaWxlcyBhbmQgbW92ZSB2YWx1ZSBvZiB3ZWJraXRSZWxhdGl2ZVBhdGggcGF0aCB0byBfcmVsYXRpdmVQYXRoXG4gICAgICB2YXIgZmlsZXMgPSBBcnJheS5mcm9tKHJvb3QuZWxlbWVudC5maWxlcykubWFwKGZ1bmN0aW9uKGZpbGUpIHtcbiAgICAgICAgZmlsZS5fcmVsYXRpdmVQYXRoID0gZmlsZS53ZWJraXRSZWxhdGl2ZVBhdGg7XG4gICAgICAgIHJldHVybiBmaWxlO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIHdlIGFkZCBhIGxpdHRsZSBkZWxheSBzbyB0aGUgT1MgZmlsZSBzZWxlY3Qgd2luZG93IGNhbiBtb3ZlIG91dCBvZiB0aGUgd2F5IGJlZm9yZSB3ZSBhZGQgb3VyIGZpbGVcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIGxvYWQgZmlsZXNcbiAgICAgICAgcHJvcHMub25sb2FkKGZpbGVzKTtcblxuICAgICAgICAvLyByZXNldCBpbnB1dCwgaXQncyBqdXN0IGZvciBleHBvc2luZyBhIG1ldGhvZCB0byBkcm9wIGZpbGVzLCBzaG91bGQgbm90IHJldGFpbiBhbnkgc3RhdGVcbiAgICAgICAgcmVzZXRGaWxlSW5wdXQocm9vdC5lbGVtZW50KTtcbiAgICAgIH0sIDI1MCk7XG4gICAgfTtcblxuICAgIHJvb3QuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCByb290LnJlZi5oYW5kbGVDaGFuZ2UpO1xuICB9O1xuXG4gIHZhciBzZXRBY2NlcHRlZEZpbGVUeXBlcyA9IGZ1bmN0aW9uIHNldEFjY2VwdGVkRmlsZVR5cGVzKF9yZWYyKSB7XG4gICAgdmFyIHJvb3QgPSBfcmVmMi5yb290LFxuICAgICAgYWN0aW9uID0gX3JlZjIuYWN0aW9uO1xuICAgIGlmICghcm9vdC5xdWVyeSgnR0VUX0FMTE9XX1NZTkNfQUNDRVBUX0FUVFJJQlVURScpKSByZXR1cm47XG4gICAgYXR0clRvZ2dsZShcbiAgICAgIHJvb3QuZWxlbWVudCxcbiAgICAgICdhY2NlcHQnLFxuICAgICAgISFhY3Rpb24udmFsdWUsXG4gICAgICBhY3Rpb24udmFsdWUgPyBhY3Rpb24udmFsdWUuam9pbignLCcpIDogJydcbiAgICApO1xuICB9O1xuXG4gIHZhciB0b2dnbGVBbGxvd011bHRpcGxlID0gZnVuY3Rpb24gdG9nZ2xlQWxsb3dNdWx0aXBsZShfcmVmMykge1xuICAgIHZhciByb290ID0gX3JlZjMucm9vdCxcbiAgICAgIGFjdGlvbiA9IF9yZWYzLmFjdGlvbjtcbiAgICBhdHRyVG9nZ2xlKHJvb3QuZWxlbWVudCwgJ211bHRpcGxlJywgYWN0aW9uLnZhbHVlKTtcbiAgfTtcblxuICB2YXIgdG9nZ2xlRGlyZWN0b3J5RmlsdGVyID0gZnVuY3Rpb24gdG9nZ2xlRGlyZWN0b3J5RmlsdGVyKF9yZWY0KSB7XG4gICAgdmFyIHJvb3QgPSBfcmVmNC5yb290LFxuICAgICAgYWN0aW9uID0gX3JlZjQuYWN0aW9uO1xuICAgIGF0dHJUb2dnbGUocm9vdC5lbGVtZW50LCAnd2Via2l0ZGlyZWN0b3J5JywgYWN0aW9uLnZhbHVlKTtcbiAgfTtcblxuICB2YXIgdG9nZ2xlRGlzYWJsZWQgPSBmdW5jdGlvbiB0b2dnbGVEaXNhYmxlZChfcmVmNSkge1xuICAgIHZhciByb290ID0gX3JlZjUucm9vdDtcbiAgICB2YXIgaXNEaXNhYmxlZCA9IHJvb3QucXVlcnkoJ0dFVF9ESVNBQkxFRCcpO1xuICAgIHZhciBkb2VzQWxsb3dCcm93c2UgPSByb290LnF1ZXJ5KCdHRVRfQUxMT1dfQlJPV1NFJyk7XG4gICAgdmFyIGRpc2FibGVGaWVsZCA9IGlzRGlzYWJsZWQgfHwgIWRvZXNBbGxvd0Jyb3dzZTtcbiAgICBhdHRyVG9nZ2xlKHJvb3QuZWxlbWVudCwgJ2Rpc2FibGVkJywgZGlzYWJsZUZpZWxkKTtcbiAgfTtcblxuICB2YXIgdG9nZ2xlUmVxdWlyZWQgPSBmdW5jdGlvbiB0b2dnbGVSZXF1aXJlZChfcmVmNikge1xuICAgIHZhciByb290ID0gX3JlZjYucm9vdCxcbiAgICAgIGFjdGlvbiA9IF9yZWY2LmFjdGlvbjtcbiAgICAvLyB3YW50IHRvIHJlbW92ZSByZXF1aXJlZCwgYWx3YXlzIHBvc3NpYmxlXG4gICAgaWYgKCFhY3Rpb24udmFsdWUpIHtcbiAgICAgIGF0dHJUb2dnbGUocm9vdC5lbGVtZW50LCAncmVxdWlyZWQnLCBmYWxzZSk7XG4gICAgfVxuICAgIC8vIGlmIHdhbnQgdG8gbWFrZSByZXF1aXJlZCwgb25seSBwb3NzaWJsZSB3aGVuIHplcm8gaXRlbXNcbiAgICBlbHNlIGlmIChyb290LnF1ZXJ5KCdHRVRfVE9UQUxfSVRFTVMnKSA9PT0gMCkge1xuICAgICAgYXR0clRvZ2dsZShyb290LmVsZW1lbnQsICdyZXF1aXJlZCcsIHRydWUpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgc2V0Q2FwdHVyZU1ldGhvZCA9IGZ1bmN0aW9uIHNldENhcHR1cmVNZXRob2QoX3JlZjcpIHtcbiAgICB2YXIgcm9vdCA9IF9yZWY3LnJvb3QsXG4gICAgICBhY3Rpb24gPSBfcmVmNy5hY3Rpb247XG4gICAgYXR0clRvZ2dsZShcbiAgICAgIHJvb3QuZWxlbWVudCxcbiAgICAgICdjYXB0dXJlJyxcbiAgICAgICEhYWN0aW9uLnZhbHVlLFxuICAgICAgYWN0aW9uLnZhbHVlID09PSB0cnVlID8gJycgOiBhY3Rpb24udmFsdWVcbiAgICApO1xuICB9O1xuXG4gIHZhciB1cGRhdGVSZXF1aXJlZFN0YXR1cyA9IGZ1bmN0aW9uIHVwZGF0ZVJlcXVpcmVkU3RhdHVzKF9yZWY4KSB7XG4gICAgdmFyIHJvb3QgPSBfcmVmOC5yb290O1xuICAgIHZhciBlbGVtZW50ID0gcm9vdC5lbGVtZW50O1xuICAgIC8vIGFsd2F5cyByZW1vdmUgdGhlIHJlcXVpcmVkIGF0dHJpYnV0ZSB3aGVuIG1vcmUgdGhhbiB6ZXJvIGl0ZW1zXG4gICAgaWYgKHJvb3QucXVlcnkoJ0dFVF9UT1RBTF9JVEVNUycpID4gMCkge1xuICAgICAgYXR0clRvZ2dsZShlbGVtZW50LCAncmVxdWlyZWQnLCBmYWxzZSk7XG4gICAgICBhdHRyVG9nZ2xlKGVsZW1lbnQsICduYW1lJywgZmFsc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBhZGQgbmFtZSBhdHRyaWJ1dGVcbiAgICAgIGF0dHJUb2dnbGUoZWxlbWVudCwgJ25hbWUnLCB0cnVlLCByb290LnF1ZXJ5KCdHRVRfTkFNRScpKTtcblxuICAgICAgLy8gcmVtb3ZlIGFueSB2YWxpZGF0aW9uIG1lc3NhZ2VzXG4gICAgICB2YXIgc2hvdWxkQ2hlY2tWYWxpZGl0eSA9IHJvb3QucXVlcnkoJ0dFVF9DSEVDS19WQUxJRElUWScpO1xuICAgICAgaWYgKHNob3VsZENoZWNrVmFsaWRpdHkpIHtcbiAgICAgICAgZWxlbWVudC5zZXRDdXN0b21WYWxpZGl0eSgnJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIHdlIG9ubHkgYWRkIHJlcXVpcmVkIGlmIHRoZSBmaWVsZCBoYXMgYmVlbiBkZWVtZWQgcmVxdWlyZWRcbiAgICAgIGlmIChyb290LnF1ZXJ5KCdHRVRfUkVRVUlSRUQnKSkge1xuICAgICAgICBhdHRyVG9nZ2xlKGVsZW1lbnQsICdyZXF1aXJlZCcsIHRydWUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgdXBkYXRlRmllbGRWYWxpZGl0eVN0YXR1cyA9IGZ1bmN0aW9uIHVwZGF0ZUZpZWxkVmFsaWRpdHlTdGF0dXMoX3JlZjkpIHtcbiAgICB2YXIgcm9vdCA9IF9yZWY5LnJvb3Q7XG4gICAgdmFyIHNob3VsZENoZWNrVmFsaWRpdHkgPSByb290LnF1ZXJ5KCdHRVRfQ0hFQ0tfVkFMSURJVFknKTtcbiAgICBpZiAoIXNob3VsZENoZWNrVmFsaWRpdHkpIHJldHVybjtcbiAgICByb290LmVsZW1lbnQuc2V0Q3VzdG9tVmFsaWRpdHkocm9vdC5xdWVyeSgnR0VUX0xBQkVMX0lOVkFMSURfRklFTEQnKSk7XG4gIH07XG5cbiAgdmFyIGJyb3dzZXIgPSBjcmVhdGVWaWV3KHtcbiAgICB0YWc6ICdpbnB1dCcsXG4gICAgbmFtZTogJ2Jyb3dzZXInLFxuICAgIGlnbm9yZVJlY3Q6IHRydWUsXG4gICAgaWdub3JlUmVjdFVwZGF0ZTogdHJ1ZSxcbiAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICB0eXBlOiAnZmlsZSdcbiAgICB9LFxuXG4gICAgY3JlYXRlOiBjcmVhdGUkYSxcbiAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KF9yZWYxMCkge1xuICAgICAgdmFyIHJvb3QgPSBfcmVmMTAucm9vdDtcbiAgICAgIHJvb3QuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCByb290LnJlZi5oYW5kbGVDaGFuZ2UpO1xuICAgIH0sXG4gICAgd3JpdGU6IGNyZWF0ZVJvdXRlKHtcbiAgICAgIERJRF9MT0FEX0lURU06IHVwZGF0ZVJlcXVpcmVkU3RhdHVzLFxuICAgICAgRElEX1JFTU9WRV9JVEVNOiB1cGRhdGVSZXF1aXJlZFN0YXR1cyxcbiAgICAgIERJRF9USFJPV19JVEVNX0lOVkFMSUQ6IHVwZGF0ZUZpZWxkVmFsaWRpdHlTdGF0dXMsXG5cbiAgICAgIERJRF9TRVRfRElTQUJMRUQ6IHRvZ2dsZURpc2FibGVkLFxuICAgICAgRElEX1NFVF9BTExPV19CUk9XU0U6IHRvZ2dsZURpc2FibGVkLFxuICAgICAgRElEX1NFVF9BTExPV19ESVJFQ1RPUklFU19PTkxZOiB0b2dnbGVEaXJlY3RvcnlGaWx0ZXIsXG4gICAgICBESURfU0VUX0FMTE9XX01VTFRJUExFOiB0b2dnbGVBbGxvd011bHRpcGxlLFxuICAgICAgRElEX1NFVF9BQ0NFUFRFRF9GSUxFX1RZUEVTOiBzZXRBY2NlcHRlZEZpbGVUeXBlcyxcbiAgICAgIERJRF9TRVRfQ0FQVFVSRV9NRVRIT0Q6IHNldENhcHR1cmVNZXRob2QsXG4gICAgICBESURfU0VUX1JFUVVJUkVEOiB0b2dnbGVSZXF1aXJlZFxuICAgIH0pXG4gIH0pO1xuXG4gIHZhciBLZXkgPSB7XG4gICAgRU5URVI6IDEzLFxuICAgIFNQQUNFOiAzMlxuICB9O1xuXG4gIHZhciBjcmVhdGUkYiA9IGZ1bmN0aW9uIGNyZWF0ZShfcmVmKSB7XG4gICAgdmFyIHJvb3QgPSBfcmVmLnJvb3QsXG4gICAgICBwcm9wcyA9IF9yZWYucHJvcHM7XG5cbiAgICAvLyBjcmVhdGUgdGhlIGxhYmVsIGFuZCBsaW5rIGl0IHRvIHRoZSBmaWxlIGJyb3dzZXJcbiAgICB2YXIgbGFiZWwgPSBjcmVhdGVFbGVtZW50JDEoJ2xhYmVsJyk7XG4gICAgYXR0cihsYWJlbCwgJ2ZvcicsICdmaWxlcG9uZC0tYnJvd3Nlci0nICsgcHJvcHMuaWQpO1xuXG4gICAgLy8gdXNlIGZvciBsYWJlbGluZyBmaWxlIGlucHV0IChhcmlhLWxhYmVsbGVkYnkgb24gZmlsZSBpbnB1dClcbiAgICBhdHRyKGxhYmVsLCAnaWQnLCAnZmlsZXBvbmQtLWRyb3AtbGFiZWwtJyArIHByb3BzLmlkKTtcblxuICAgIC8vIGhpZGUgdGhlIGxhYmVsIGZvciBzY3JlZW5yZWFkZXJzLCB0aGUgaW5wdXQgZWxlbWVudCB3aWxsIHJlYWQgdGhlIGNvbnRlbnRzIG9mIHRoZSBsYWJlbCB3aGVuIGl0J3MgZm9jdXNzZWQuIElmIHdlIGRvbid0IHNldCBhcmlhLWhpZGRlbiB0aGUgc2NyZWVucmVhZGVyIHdpbGwgYWxzbyBuYXZpZ2F0ZSB0aGUgY29udGVudHMgb2YgdGhlIGxhYmVsIHNlcGFyYXRlbHkgZnJvbSB0aGUgaW5wdXQuXG4gICAgYXR0cihsYWJlbCwgJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcblxuICAgIC8vIGhhbmRsZSBrZXlzXG4gICAgcm9vdC5yZWYuaGFuZGxlS2V5RG93biA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgIHZhciBpc0FjdGl2YXRpb25LZXkgPSBlLmtleUNvZGUgPT09IEtleS5FTlRFUiB8fCBlLmtleUNvZGUgPT09IEtleS5TUEFDRTtcbiAgICAgIGlmICghaXNBY3RpdmF0aW9uS2V5KSByZXR1cm47XG4gICAgICAvLyBzdG9wcyBmcm9tIHRyaWdnZXJpbmcgdGhlIGVsZW1lbnQgYSBzZWNvbmQgdGltZVxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAvLyBjbGljayBsaW5rICh3aWxsIHRoZW4gaW4gdHVybiBhY3RpdmF0ZSBmaWxlIGlucHV0KVxuICAgICAgcm9vdC5yZWYubGFiZWwuY2xpY2soKTtcbiAgICB9O1xuXG4gICAgcm9vdC5yZWYuaGFuZGxlQ2xpY2sgPSBmdW5jdGlvbihlKSB7XG4gICAgICB2YXIgaXNMYWJlbENsaWNrID0gZS50YXJnZXQgPT09IGxhYmVsIHx8IGxhYmVsLmNvbnRhaW5zKGUudGFyZ2V0KTtcblxuICAgICAgLy8gZG9uJ3Qgd2FudCB0byBjbGljayB0d2ljZVxuICAgICAgaWYgKGlzTGFiZWxDbGljaykgcmV0dXJuO1xuXG4gICAgICAvLyBjbGljayBsaW5rICh3aWxsIHRoZW4gaW4gdHVybiBhY3RpdmF0ZSBmaWxlIGlucHV0KVxuICAgICAgcm9vdC5yZWYubGFiZWwuY2xpY2soKTtcbiAgICB9O1xuXG4gICAgLy8gYXR0YWNoIGV2ZW50c1xuICAgIGxhYmVsLmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCByb290LnJlZi5oYW5kbGVLZXlEb3duKTtcbiAgICByb290LmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCByb290LnJlZi5oYW5kbGVDbGljayk7XG5cbiAgICAvLyB1cGRhdGVcbiAgICB1cGRhdGVMYWJlbFZhbHVlKGxhYmVsLCBwcm9wcy5jYXB0aW9uKTtcblxuICAgIC8vIGFkZCFcbiAgICByb290LmFwcGVuZENoaWxkKGxhYmVsKTtcbiAgICByb290LnJlZi5sYWJlbCA9IGxhYmVsO1xuICB9O1xuXG4gIHZhciB1cGRhdGVMYWJlbFZhbHVlID0gZnVuY3Rpb24gdXBkYXRlTGFiZWxWYWx1ZShsYWJlbCwgdmFsdWUpIHtcbiAgICBsYWJlbC5pbm5lckhUTUwgPSB2YWx1ZTtcbiAgICB2YXIgY2xpY2thYmxlID0gbGFiZWwucXVlcnlTZWxlY3RvcignLmZpbGVwb25kLS1sYWJlbC1hY3Rpb24nKTtcbiAgICBpZiAoY2xpY2thYmxlKSB7XG4gICAgICBhdHRyKGNsaWNrYWJsZSwgJ3RhYmluZGV4JywgJzAnKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xuXG4gIHZhciBkcm9wTGFiZWwgPSBjcmVhdGVWaWV3KHtcbiAgICBuYW1lOiAnZHJvcC1sYWJlbCcsXG4gICAgaWdub3JlUmVjdDogdHJ1ZSxcbiAgICBjcmVhdGU6IGNyZWF0ZSRiLFxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koX3JlZjIpIHtcbiAgICAgIHZhciByb290ID0gX3JlZjIucm9vdDtcbiAgICAgIHJvb3QucmVmLmxhYmVsLmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCByb290LnJlZi5oYW5kbGVLZXlEb3duKTtcbiAgICAgIHJvb3QuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHJvb3QucmVmLmhhbmRsZUNsaWNrKTtcbiAgICB9LFxuICAgIHdyaXRlOiBjcmVhdGVSb3V0ZSh7XG4gICAgICBESURfU0VUX0xBQkVMX0lETEU6IGZ1bmN0aW9uIERJRF9TRVRfTEFCRUxfSURMRShfcmVmMykge1xuICAgICAgICB2YXIgcm9vdCA9IF9yZWYzLnJvb3QsXG4gICAgICAgICAgYWN0aW9uID0gX3JlZjMuYWN0aW9uO1xuICAgICAgICB1cGRhdGVMYWJlbFZhbHVlKHJvb3QucmVmLmxhYmVsLCBhY3Rpb24udmFsdWUpO1xuICAgICAgfVxuICAgIH0pLFxuXG4gICAgbWl4aW5zOiB7XG4gICAgICBzdHlsZXM6IFsnb3BhY2l0eScsICd0cmFuc2xhdGVYJywgJ3RyYW5zbGF0ZVknXSxcbiAgICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgICAgb3BhY2l0eTogeyB0eXBlOiAndHdlZW4nLCBkdXJhdGlvbjogMTUwIH0sXG4gICAgICAgIHRyYW5zbGF0ZVg6ICdzcHJpbmcnLFxuICAgICAgICB0cmFuc2xhdGVZOiAnc3ByaW5nJ1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgdmFyIGJsb2IgPSBjcmVhdGVWaWV3KHtcbiAgICBuYW1lOiAnZHJpcC1ibG9iJyxcbiAgICBpZ25vcmVSZWN0OiB0cnVlLFxuICAgIG1peGluczoge1xuICAgICAgc3R5bGVzOiBbJ3RyYW5zbGF0ZVgnLCAndHJhbnNsYXRlWScsICdzY2FsZVgnLCAnc2NhbGVZJywgJ29wYWNpdHknXSxcbiAgICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgICAgc2NhbGVYOiAnc3ByaW5nJyxcbiAgICAgICAgc2NhbGVZOiAnc3ByaW5nJyxcbiAgICAgICAgdHJhbnNsYXRlWDogJ3NwcmluZycsXG4gICAgICAgIHRyYW5zbGF0ZVk6ICdzcHJpbmcnLFxuICAgICAgICBvcGFjaXR5OiB7IHR5cGU6ICd0d2VlbicsIGR1cmF0aW9uOiAyNTAgfVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgdmFyIGFkZEJsb2IgPSBmdW5jdGlvbiBhZGRCbG9iKF9yZWYpIHtcbiAgICB2YXIgcm9vdCA9IF9yZWYucm9vdDtcbiAgICB2YXIgY2VudGVyWCA9IHJvb3QucmVjdC5lbGVtZW50LndpZHRoICogMC41O1xuICAgIHZhciBjZW50ZXJZID0gcm9vdC5yZWN0LmVsZW1lbnQuaGVpZ2h0ICogMC41O1xuXG4gICAgcm9vdC5yZWYuYmxvYiA9IHJvb3QuYXBwZW5kQ2hpbGRWaWV3KFxuICAgICAgcm9vdC5jcmVhdGVDaGlsZFZpZXcoYmxvYiwge1xuICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgICBzY2FsZVg6IDIuNSxcbiAgICAgICAgc2NhbGVZOiAyLjUsXG4gICAgICAgIHRyYW5zbGF0ZVg6IGNlbnRlclgsXG4gICAgICAgIHRyYW5zbGF0ZVk6IGNlbnRlcllcbiAgICAgIH0pXG4gICAgKTtcbiAgfTtcblxuICB2YXIgbW92ZUJsb2IgPSBmdW5jdGlvbiBtb3ZlQmxvYihfcmVmMikge1xuICAgIHZhciByb290ID0gX3JlZjIucm9vdCxcbiAgICAgIGFjdGlvbiA9IF9yZWYyLmFjdGlvbjtcbiAgICBpZiAoIXJvb3QucmVmLmJsb2IpIHtcbiAgICAgIGFkZEJsb2IoeyByb290OiByb290IH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJvb3QucmVmLmJsb2IudHJhbnNsYXRlWCA9IGFjdGlvbi5wb3NpdGlvbi5zY29wZUxlZnQ7XG4gICAgcm9vdC5yZWYuYmxvYi50cmFuc2xhdGVZID0gYWN0aW9uLnBvc2l0aW9uLnNjb3BlVG9wO1xuICAgIHJvb3QucmVmLmJsb2Iuc2NhbGVYID0gMTtcbiAgICByb290LnJlZi5ibG9iLnNjYWxlWSA9IDE7XG4gICAgcm9vdC5yZWYuYmxvYi5vcGFjaXR5ID0gMTtcbiAgfTtcblxuICB2YXIgaGlkZUJsb2IgPSBmdW5jdGlvbiBoaWRlQmxvYihfcmVmMykge1xuICAgIHZhciByb290ID0gX3JlZjMucm9vdDtcbiAgICBpZiAoIXJvb3QucmVmLmJsb2IpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcm9vdC5yZWYuYmxvYi5vcGFjaXR5ID0gMDtcbiAgfTtcblxuICB2YXIgZXhwbG9kZUJsb2IgPSBmdW5jdGlvbiBleHBsb2RlQmxvYihfcmVmNCkge1xuICAgIHZhciByb290ID0gX3JlZjQucm9vdDtcbiAgICBpZiAoIXJvb3QucmVmLmJsb2IpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcm9vdC5yZWYuYmxvYi5zY2FsZVggPSAyLjU7XG4gICAgcm9vdC5yZWYuYmxvYi5zY2FsZVkgPSAyLjU7XG4gICAgcm9vdC5yZWYuYmxvYi5vcGFjaXR5ID0gMDtcbiAgfTtcblxuICB2YXIgd3JpdGUkNyA9IGZ1bmN0aW9uIHdyaXRlKF9yZWY1KSB7XG4gICAgdmFyIHJvb3QgPSBfcmVmNS5yb290LFxuICAgICAgcHJvcHMgPSBfcmVmNS5wcm9wcyxcbiAgICAgIGFjdGlvbnMgPSBfcmVmNS5hY3Rpb25zO1xuICAgIHJvdXRlJDQoeyByb290OiByb290LCBwcm9wczogcHJvcHMsIGFjdGlvbnM6IGFjdGlvbnMgfSk7XG4gICAgdmFyIGJsb2IgPSByb290LnJlZi5ibG9iO1xuXG4gICAgaWYgKGFjdGlvbnMubGVuZ3RoID09PSAwICYmIGJsb2IgJiYgYmxvYi5vcGFjaXR5ID09PSAwKSB7XG4gICAgICByb290LnJlbW92ZUNoaWxkVmlldyhibG9iKTtcbiAgICAgIHJvb3QucmVmLmJsb2IgPSBudWxsO1xuICAgIH1cbiAgfTtcblxuICB2YXIgcm91dGUkNCA9IGNyZWF0ZVJvdXRlKHtcbiAgICBESURfRFJBRzogbW92ZUJsb2IsXG4gICAgRElEX0RST1A6IGV4cGxvZGVCbG9iLFxuICAgIERJRF9FTkRfRFJBRzogaGlkZUJsb2JcbiAgfSk7XG5cbiAgdmFyIGRyaXAgPSBjcmVhdGVWaWV3KHtcbiAgICBpZ25vcmVSZWN0OiB0cnVlLFxuICAgIGlnbm9yZVJlY3RVcGRhdGU6IHRydWUsXG4gICAgbmFtZTogJ2RyaXAnLFxuICAgIHdyaXRlOiB3cml0ZSQ3XG4gIH0pO1xuXG4gIHZhciBjcmVhdGUkYyA9IGZ1bmN0aW9uIGNyZWF0ZShfcmVmKSB7XG4gICAgdmFyIHJvb3QgPSBfcmVmLnJvb3Q7XG4gICAgcmV0dXJuIChyb290LnJlZi5maWVsZHMgPSB7fSk7XG4gIH07XG5cbiAgdmFyIGdldEZpZWxkID0gZnVuY3Rpb24gZ2V0RmllbGQocm9vdCwgaWQpIHtcbiAgICByZXR1cm4gcm9vdC5yZWYuZmllbGRzW2lkXTtcbiAgfTtcblxuICB2YXIgc3luY0ZpZWxkUG9zaXRpb25zV2l0aEl0ZW1zID0gZnVuY3Rpb24gc3luY0ZpZWxkUG9zaXRpb25zV2l0aEl0ZW1zKHJvb3QpIHtcbiAgICByb290LnF1ZXJ5KCdHRVRfQUNUSVZFX0lURU1TJykuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XG4gICAgICBpZiAoIXJvb3QucmVmLmZpZWxkc1tpdGVtLmlkXSkgcmV0dXJuO1xuICAgICAgcm9vdC5lbGVtZW50LmFwcGVuZENoaWxkKHJvb3QucmVmLmZpZWxkc1tpdGVtLmlkXSk7XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIGRpZFJlb3JkZXJJdGVtcyA9IGZ1bmN0aW9uIGRpZFJlb3JkZXJJdGVtcyhfcmVmMikge1xuICAgIHZhciByb290ID0gX3JlZjIucm9vdDtcbiAgICByZXR1cm4gc3luY0ZpZWxkUG9zaXRpb25zV2l0aEl0ZW1zKHJvb3QpO1xuICB9O1xuXG4gIHZhciBkaWRBZGRJdGVtID0gZnVuY3Rpb24gZGlkQWRkSXRlbShfcmVmMykge1xuICAgIHZhciByb290ID0gX3JlZjMucm9vdCxcbiAgICAgIGFjdGlvbiA9IF9yZWYzLmFjdGlvbjtcbiAgICB2YXIgZGF0YUNvbnRhaW5lciA9IGNyZWF0ZUVsZW1lbnQkMSgnaW5wdXQnKTtcbiAgICBkYXRhQ29udGFpbmVyLnR5cGUgPSAnaGlkZGVuJztcbiAgICBkYXRhQ29udGFpbmVyLm5hbWUgPSByb290LnF1ZXJ5KCdHRVRfTkFNRScpO1xuICAgIGRhdGFDb250YWluZXIuZGlzYWJsZWQgPSByb290LnF1ZXJ5KCdHRVRfRElTQUJMRUQnKTtcbiAgICByb290LnJlZi5maWVsZHNbYWN0aW9uLmlkXSA9IGRhdGFDb250YWluZXI7XG4gICAgc3luY0ZpZWxkUG9zaXRpb25zV2l0aEl0ZW1zKHJvb3QpO1xuICB9O1xuXG4gIHZhciBkaWRMb2FkSXRlbSQxID0gZnVuY3Rpb24gZGlkTG9hZEl0ZW0oX3JlZjQpIHtcbiAgICB2YXIgcm9vdCA9IF9yZWY0LnJvb3QsXG4gICAgICBhY3Rpb24gPSBfcmVmNC5hY3Rpb247XG4gICAgdmFyIGZpZWxkID0gZ2V0RmllbGQocm9vdCwgYWN0aW9uLmlkKTtcbiAgICBpZiAoIWZpZWxkIHx8IGFjdGlvbi5zZXJ2ZXJGaWxlUmVmZXJlbmNlID09PSBudWxsKSByZXR1cm47XG4gICAgZmllbGQudmFsdWUgPSBhY3Rpb24uc2VydmVyRmlsZVJlZmVyZW5jZTtcbiAgfTtcblxuICB2YXIgZGlkU2V0RGlzYWJsZWQgPSBmdW5jdGlvbiBkaWRTZXREaXNhYmxlZChfcmVmNSkge1xuICAgIHZhciByb290ID0gX3JlZjUucm9vdDtcbiAgICByb290LmVsZW1lbnQuZGlzYWJsZWQgPSByb290LnF1ZXJ5KCdHRVRfRElTQUJMRUQnKTtcbiAgfTtcblxuICB2YXIgZGlkUmVtb3ZlSXRlbSA9IGZ1bmN0aW9uIGRpZFJlbW92ZUl0ZW0oX3JlZjYpIHtcbiAgICB2YXIgcm9vdCA9IF9yZWY2LnJvb3QsXG4gICAgICBhY3Rpb24gPSBfcmVmNi5hY3Rpb247XG4gICAgdmFyIGZpZWxkID0gZ2V0RmllbGQocm9vdCwgYWN0aW9uLmlkKTtcbiAgICBpZiAoIWZpZWxkKSByZXR1cm47XG4gICAgaWYgKGZpZWxkLnBhcmVudE5vZGUpIGZpZWxkLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZmllbGQpO1xuICAgIGRlbGV0ZSByb290LnJlZi5maWVsZHNbYWN0aW9uLmlkXTtcbiAgfTtcblxuICB2YXIgZGlkRGVmaW5lVmFsdWUgPSBmdW5jdGlvbiBkaWREZWZpbmVWYWx1ZShfcmVmNykge1xuICAgIHZhciByb290ID0gX3JlZjcucm9vdCxcbiAgICAgIGFjdGlvbiA9IF9yZWY3LmFjdGlvbjtcbiAgICB2YXIgZmllbGQgPSBnZXRGaWVsZChyb290LCBhY3Rpb24uaWQpO1xuICAgIGlmICghZmllbGQpIHJldHVybjtcbiAgICBpZiAoYWN0aW9uLnZhbHVlID09PSBudWxsKSB7XG4gICAgICBmaWVsZC5yZW1vdmVBdHRyaWJ1dGUoJ3ZhbHVlJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZpZWxkLnZhbHVlID0gYWN0aW9uLnZhbHVlO1xuICAgIH1cbiAgICBzeW5jRmllbGRQb3NpdGlvbnNXaXRoSXRlbXMocm9vdCk7XG4gIH07XG5cbiAgdmFyIHdyaXRlJDggPSBjcmVhdGVSb3V0ZSh7XG4gICAgRElEX1NFVF9ESVNBQkxFRDogZGlkU2V0RGlzYWJsZWQsXG4gICAgRElEX0FERF9JVEVNOiBkaWRBZGRJdGVtLFxuICAgIERJRF9MT0FEX0lURU06IGRpZExvYWRJdGVtJDEsXG4gICAgRElEX1JFTU9WRV9JVEVNOiBkaWRSZW1vdmVJdGVtLFxuICAgIERJRF9ERUZJTkVfVkFMVUU6IGRpZERlZmluZVZhbHVlLFxuICAgIERJRF9SRU9SREVSX0lURU1TOiBkaWRSZW9yZGVySXRlbXMsXG4gICAgRElEX1NPUlRfSVRFTVM6IGRpZFJlb3JkZXJJdGVtc1xuICB9KTtcblxuICB2YXIgZGF0YSA9IGNyZWF0ZVZpZXcoe1xuICAgIHRhZzogJ2ZpZWxkc2V0JyxcbiAgICBuYW1lOiAnZGF0YScsXG4gICAgY3JlYXRlOiBjcmVhdGUkYyxcbiAgICB3cml0ZTogd3JpdGUkOCxcbiAgICBpZ25vcmVSZWN0OiB0cnVlXG4gIH0pO1xuXG4gIHZhciBnZXRSb290Tm9kZSA9IGZ1bmN0aW9uIGdldFJvb3ROb2RlKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gJ2dldFJvb3ROb2RlJyBpbiBlbGVtZW50ID8gZWxlbWVudC5nZXRSb290Tm9kZSgpIDogZG9jdW1lbnQ7XG4gIH07XG5cbiAgdmFyIGltYWdlcyA9IFsnanBnJywgJ2pwZWcnLCAncG5nJywgJ2dpZicsICdibXAnLCAnd2VicCcsICdzdmcnLCAndGlmZiddO1xuICB2YXIgdGV4dCQxID0gWydjc3MnLCAnY3N2JywgJ2h0bWwnLCAndHh0J107XG4gIHZhciBtYXAgPSB7XG4gICAgemlwOiAnemlwfGNvbXByZXNzZWQnLFxuICAgIGVwdWI6ICdhcHBsaWNhdGlvbi9lcHViK3ppcCdcbiAgfTtcblxuICB2YXIgZ3Vlc3N0aW1hdGVNaW1lVHlwZSA9IGZ1bmN0aW9uIGd1ZXNzdGltYXRlTWltZVR5cGUoKSB7XG4gICAgdmFyIGV4dGVuc2lvbiA9XG4gICAgICBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6ICcnO1xuICAgIGV4dGVuc2lvbiA9IGV4dGVuc2lvbi50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChpbWFnZXMuaW5jbHVkZXMoZXh0ZW5zaW9uKSkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgJ2ltYWdlLycgK1xuICAgICAgICAoZXh0ZW5zaW9uID09PSAnanBnJ1xuICAgICAgICAgID8gJ2pwZWcnXG4gICAgICAgICAgOiBleHRlbnNpb24gPT09ICdzdmcnXG4gICAgICAgICAgPyAnc3ZnK3htbCdcbiAgICAgICAgICA6IGV4dGVuc2lvbilcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICh0ZXh0JDEuaW5jbHVkZXMoZXh0ZW5zaW9uKSkge1xuICAgICAgcmV0dXJuICd0ZXh0LycgKyBleHRlbnNpb247XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hcFtleHRlbnNpb25dIHx8ICcnO1xuICB9O1xuXG4gIHZhciByZXF1ZXN0RGF0YVRyYW5zZmVySXRlbXMgPSBmdW5jdGlvbiByZXF1ZXN0RGF0YVRyYW5zZmVySXRlbXMoXG4gICAgZGF0YVRyYW5zZmVyXG4gICkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIC8vIHRyeSB0byBnZXQgbGlua3MgZnJvbSB0cmFuc2ZlciwgaWYgZm91bmQgd2UnbGwgZXhpdCBpbW1lZGlhdGVseSAodW5sZXNzIGEgZmlsZSBpcyBpbiB0aGUgZGF0YVRyYW5zZmVyIGFzIHdlbGwsIHRoaXMgaXMgYmVjYXVzZSBGaXJlZm94IGNvdWxkIHJlcHJlc2VudCB0aGUgZmlsZSBhcyBhIFVSTCBhbmQgYSBmaWxlIG9iamVjdCBhdCB0aGUgc2FtZSB0aW1lKVxuICAgICAgdmFyIGxpbmtzID0gZ2V0TGlua3MoZGF0YVRyYW5zZmVyKTtcbiAgICAgIGlmIChsaW5rcy5sZW5ndGggJiYgIWhhc0ZpbGVzKGRhdGFUcmFuc2ZlcikpIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmUobGlua3MpO1xuICAgICAgfVxuICAgICAgLy8gdHJ5IHRvIGdldCBmaWxlcyBmcm9tIHRoZSB0cmFuc2ZlclxuICAgICAgZ2V0RmlsZXMoZGF0YVRyYW5zZmVyKS50aGVuKHJlc29sdmUpO1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUZXN0IGlmIGRhdGF0cmFuc2ZlciBoYXMgZmlsZXNcbiAgICovXG4gIHZhciBoYXNGaWxlcyA9IGZ1bmN0aW9uIGhhc0ZpbGVzKGRhdGFUcmFuc2Zlcikge1xuICAgIGlmIChkYXRhVHJhbnNmZXIuZmlsZXMpIHJldHVybiBkYXRhVHJhbnNmZXIuZmlsZXMubGVuZ3RoID4gMDtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIEV4dHJhY3RzIGZpbGVzIGZyb20gYSBEYXRhVHJhbnNmZXIgb2JqZWN0XG4gICAqL1xuICB2YXIgZ2V0RmlsZXMgPSBmdW5jdGlvbiBnZXRGaWxlcyhkYXRhVHJhbnNmZXIpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAvLyBnZXQgdGhlIHRyYW5zZmVyIGl0ZW1zIGFzIHByb21pc2VzXG4gICAgICB2YXIgcHJvbWlzZWRGaWxlcyA9IChkYXRhVHJhbnNmZXIuaXRlbXNcbiAgICAgICAgPyBBcnJheS5mcm9tKGRhdGFUcmFuc2Zlci5pdGVtcylcbiAgICAgICAgOiBbXVxuICAgICAgKVxuICAgICAgICAvLyBvbmx5IGtlZXAgZmlsZSBzeXN0ZW0gaXRlbXMgKGZpbGVzIGFuZCBkaXJlY3RvcmllcylcbiAgICAgICAgLmZpbHRlcihmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgcmV0dXJuIGlzRmlsZVN5c3RlbUl0ZW0oaXRlbSk7XG4gICAgICAgIH0pXG5cbiAgICAgICAgLy8gbWFwIGVhY2ggaXRlbSB0byBwcm9taXNlXG4gICAgICAgIC5tYXAoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgIHJldHVybiBnZXRGaWxlc0Zyb21JdGVtKGl0ZW0pO1xuICAgICAgICB9KTtcblxuICAgICAgLy8gaWYgaXMgZW1wdHksIHNlZSBpZiB3ZSBjYW4gZXh0cmFjdCBzb21lIGluZm8gZnJvbSB0aGUgZmlsZXMgcHJvcGVydHkgYXMgYSBmYWxsYmFja1xuICAgICAgaWYgKCFwcm9taXNlZEZpbGVzLmxlbmd0aCkge1xuICAgICAgICAvLyBUT0RPOiB0ZXN0IGZvciBkaXJlY3RvcmllcyAoc2hvdWxkIG5vdCBiZSBhbGxvd2VkKVxuICAgICAgICAvLyBVc2UgRmlsZVJlYWRlciwgcHJvYmxlbSBpcyB0aGF0IHRoZSBmaWxlcyBwcm9wZXJ0eSBnZXRzIGxvc3QgaW4gdGhlIHByb2Nlc3NcbiAgICAgICAgcmVzb2x2ZShkYXRhVHJhbnNmZXIuZmlsZXMgPyBBcnJheS5mcm9tKGRhdGFUcmFuc2Zlci5maWxlcykgOiBbXSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gZG9uZSFcbiAgICAgIFByb21pc2UuYWxsKHByb21pc2VkRmlsZXMpXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uKHJldHVybmVkRmlsZUdyb3Vwcykge1xuICAgICAgICAgIC8vIGZsYXR0ZW4gZ3JvdXBzXG4gICAgICAgICAgdmFyIGZpbGVzID0gW107XG4gICAgICAgICAgcmV0dXJuZWRGaWxlR3JvdXBzLmZvckVhY2goZnVuY3Rpb24oZ3JvdXApIHtcbiAgICAgICAgICAgIGZpbGVzLnB1c2guYXBwbHkoZmlsZXMsIGdyb3VwKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIC8vIGRvbmUgKGZpbHRlciBvdXQgZW1wdHkgZmlsZXMpIVxuICAgICAgICAgIHJlc29sdmUoXG4gICAgICAgICAgICBmaWxlc1xuICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKGZpbGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlsZTtcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbihmaWxlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFmaWxlLl9yZWxhdGl2ZVBhdGgpXG4gICAgICAgICAgICAgICAgICBmaWxlLl9yZWxhdGl2ZVBhdGggPSBmaWxlLndlYmtpdFJlbGF0aXZlUGF0aDtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlsZTtcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goY29uc29sZS5lcnJvcik7XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIGlzRmlsZVN5c3RlbUl0ZW0gPSBmdW5jdGlvbiBpc0ZpbGVTeXN0ZW1JdGVtKGl0ZW0pIHtcbiAgICBpZiAoaXNFbnRyeShpdGVtKSkge1xuICAgICAgdmFyIGVudHJ5ID0gZ2V0QXNFbnRyeShpdGVtKTtcbiAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICByZXR1cm4gZW50cnkuaXNGaWxlIHx8IGVudHJ5LmlzRGlyZWN0b3J5O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaXRlbS5raW5kID09PSAnZmlsZSc7XG4gIH07XG5cbiAgdmFyIGdldEZpbGVzRnJvbUl0ZW0gPSBmdW5jdGlvbiBnZXRGaWxlc0Zyb21JdGVtKGl0ZW0pIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBpZiAoaXNEaXJlY3RvcnlFbnRyeShpdGVtKSkge1xuICAgICAgICBnZXRGaWxlc0luRGlyZWN0b3J5KGdldEFzRW50cnkoaXRlbSkpXG4gICAgICAgICAgLnRoZW4ocmVzb2x2ZSlcbiAgICAgICAgICAuY2F0Y2gocmVqZWN0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByZXNvbHZlKFtpdGVtLmdldEFzRmlsZSgpXSk7XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIGdldEZpbGVzSW5EaXJlY3RvcnkgPSBmdW5jdGlvbiBnZXRGaWxlc0luRGlyZWN0b3J5KGVudHJ5KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIGZpbGVzID0gW107XG5cbiAgICAgIC8vIHRoZSB0b3RhbCBlbnRyaWVzIHRvIHJlYWRcbiAgICAgIHZhciBkaXJDb3VudGVyID0gMDtcbiAgICAgIHZhciBmaWxlQ291bnRlciA9IDA7XG5cbiAgICAgIHZhciByZXNvbHZlSWZEb25lID0gZnVuY3Rpb24gcmVzb2x2ZUlmRG9uZSgpIHtcbiAgICAgICAgaWYgKGZpbGVDb3VudGVyID09PSAwICYmIGRpckNvdW50ZXIgPT09IDApIHtcbiAgICAgICAgICByZXNvbHZlKGZpbGVzKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLy8gdGhlIHJlY3Vyc2l2ZSBmdW5jdGlvblxuICAgICAgdmFyIHJlYWRFbnRyaWVzID0gZnVuY3Rpb24gcmVhZEVudHJpZXMoZGlyRW50cnkpIHtcbiAgICAgICAgZGlyQ291bnRlcisrO1xuXG4gICAgICAgIHZhciBkaXJlY3RvcnlSZWFkZXIgPSBkaXJFbnRyeS5jcmVhdGVSZWFkZXIoKTtcblxuICAgICAgICAvLyBkaXJlY3RvcmllcyBhcmUgcmV0dXJuZWQgaW4gYmF0Y2hlcywgd2UgbmVlZCB0byBwcm9jZXNzIGFsbCBiYXRjaGVzIGJlZm9yZSB3ZSdyZSBkb25lXG4gICAgICAgIHZhciByZWFkQmF0Y2ggPSBmdW5jdGlvbiByZWFkQmF0Y2goKSB7XG4gICAgICAgICAgZGlyZWN0b3J5UmVhZGVyLnJlYWRFbnRyaWVzKGZ1bmN0aW9uKGVudHJpZXMpIHtcbiAgICAgICAgICAgIGlmIChlbnRyaWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICBkaXJDb3VudGVyLS07XG4gICAgICAgICAgICAgIHJlc29sdmVJZkRvbmUoKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlbnRyaWVzLmZvckVhY2goZnVuY3Rpb24oZW50cnkpIHtcbiAgICAgICAgICAgICAgLy8gcmVjdXJzaXZlbHkgcmVhZCBtb3JlIGRpcmVjdG9yaWVzXG4gICAgICAgICAgICAgIGlmIChlbnRyeS5pc0RpcmVjdG9yeSkge1xuICAgICAgICAgICAgICAgIHJlYWRFbnRyaWVzKGVudHJ5KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyByZWFkIGFzIGZpbGVcbiAgICAgICAgICAgICAgICBmaWxlQ291bnRlcisrO1xuXG4gICAgICAgICAgICAgICAgZW50cnkuZmlsZShmdW5jdGlvbihmaWxlKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgY29ycmVjdGVkRmlsZSA9IGNvcnJlY3RNaXNzaW5nRmlsZVR5cGUoZmlsZSk7XG4gICAgICAgICAgICAgICAgICBpZiAoZW50cnkuZnVsbFBhdGgpXG4gICAgICAgICAgICAgICAgICAgIGNvcnJlY3RlZEZpbGUuX3JlbGF0aXZlUGF0aCA9IGVudHJ5LmZ1bGxQYXRoO1xuICAgICAgICAgICAgICAgICAgZmlsZXMucHVzaChjb3JyZWN0ZWRGaWxlKTtcbiAgICAgICAgICAgICAgICAgIGZpbGVDb3VudGVyLS07XG4gICAgICAgICAgICAgICAgICByZXNvbHZlSWZEb25lKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyB0cnkgdG8gZ2V0IG5leHQgYmF0Y2ggb2YgZmlsZXNcbiAgICAgICAgICAgIHJlYWRCYXRjaCgpO1xuICAgICAgICAgIH0sIHJlamVjdCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gcmVhZCBmaXJzdCBiYXRjaCBvZiBmaWxlc1xuICAgICAgICByZWFkQmF0Y2goKTtcbiAgICAgIH07XG5cbiAgICAgIC8vIGdvIVxuICAgICAgcmVhZEVudHJpZXMoZW50cnkpO1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciBjb3JyZWN0TWlzc2luZ0ZpbGVUeXBlID0gZnVuY3Rpb24gY29ycmVjdE1pc3NpbmdGaWxlVHlwZShmaWxlKSB7XG4gICAgaWYgKGZpbGUudHlwZS5sZW5ndGgpIHJldHVybiBmaWxlO1xuICAgIHZhciBkYXRlID0gZmlsZS5sYXN0TW9kaWZpZWREYXRlO1xuICAgIHZhciBuYW1lID0gZmlsZS5uYW1lO1xuICAgIHZhciB0eXBlID0gZ3Vlc3N0aW1hdGVNaW1lVHlwZShnZXRFeHRlbnNpb25Gcm9tRmlsZW5hbWUoZmlsZS5uYW1lKSk7XG4gICAgaWYgKCF0eXBlLmxlbmd0aCkgcmV0dXJuIGZpbGU7XG4gICAgZmlsZSA9IGZpbGUuc2xpY2UoMCwgZmlsZS5zaXplLCB0eXBlKTtcbiAgICBmaWxlLm5hbWUgPSBuYW1lO1xuICAgIGZpbGUubGFzdE1vZGlmaWVkRGF0ZSA9IGRhdGU7XG4gICAgcmV0dXJuIGZpbGU7XG4gIH07XG5cbiAgdmFyIGlzRGlyZWN0b3J5RW50cnkgPSBmdW5jdGlvbiBpc0RpcmVjdG9yeUVudHJ5KGl0ZW0pIHtcbiAgICByZXR1cm4gaXNFbnRyeShpdGVtKSAmJiAoZ2V0QXNFbnRyeShpdGVtKSB8fCB7fSkuaXNEaXJlY3Rvcnk7XG4gIH07XG5cbiAgdmFyIGlzRW50cnkgPSBmdW5jdGlvbiBpc0VudHJ5KGl0ZW0pIHtcbiAgICByZXR1cm4gJ3dlYmtpdEdldEFzRW50cnknIGluIGl0ZW07XG4gIH07XG5cbiAgdmFyIGdldEFzRW50cnkgPSBmdW5jdGlvbiBnZXRBc0VudHJ5KGl0ZW0pIHtcbiAgICByZXR1cm4gaXRlbS53ZWJraXRHZXRBc0VudHJ5KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEV4dHJhY3RzIGxpbmtzIGZyb20gYSBEYXRhVHJhbnNmZXIgb2JqZWN0XG4gICAqL1xuICB2YXIgZ2V0TGlua3MgPSBmdW5jdGlvbiBnZXRMaW5rcyhkYXRhVHJhbnNmZXIpIHtcbiAgICB2YXIgbGlua3MgPSBbXTtcbiAgICB0cnkge1xuICAgICAgLy8gbG9vayBpbiBtZXRhIGRhdGEgcHJvcGVydHlcbiAgICAgIGxpbmtzID0gZ2V0TGlua3NGcm9tVHJhbnNmZXJNZXRhRGF0YShkYXRhVHJhbnNmZXIpO1xuICAgICAgaWYgKGxpbmtzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbGlua3M7XG4gICAgICB9XG4gICAgICBsaW5rcyA9IGdldExpbmtzRnJvbVRyYW5zZmVyVVJMRGF0YShkYXRhVHJhbnNmZXIpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIG5vcGUgbm9wZSBub3BlIChwcm9iYWJseSBJRSB0cm91YmxlKVxuICAgIH1cbiAgICByZXR1cm4gbGlua3M7XG4gIH07XG5cbiAgdmFyIGdldExpbmtzRnJvbVRyYW5zZmVyVVJMRGF0YSA9IGZ1bmN0aW9uIGdldExpbmtzRnJvbVRyYW5zZmVyVVJMRGF0YShcbiAgICBkYXRhVHJhbnNmZXJcbiAgKSB7XG4gICAgdmFyIGRhdGEgPSBkYXRhVHJhbnNmZXIuZ2V0RGF0YSgndXJsJyk7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJyAmJiBkYXRhLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIFtkYXRhXTtcbiAgICB9XG4gICAgcmV0dXJuIFtdO1xuICB9O1xuXG4gIHZhciBnZXRMaW5rc0Zyb21UcmFuc2Zlck1ldGFEYXRhID0gZnVuY3Rpb24gZ2V0TGlua3NGcm9tVHJhbnNmZXJNZXRhRGF0YShcbiAgICBkYXRhVHJhbnNmZXJcbiAgKSB7XG4gICAgdmFyIGRhdGEgPSBkYXRhVHJhbnNmZXIuZ2V0RGF0YSgndGV4dC9odG1sJyk7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJyAmJiBkYXRhLmxlbmd0aCkge1xuICAgICAgdmFyIG1hdGNoZXMgPSBkYXRhLm1hdGNoKC9zcmNcXHMqPVxccypcIiguKz8pXCIvKTtcbiAgICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAgIHJldHVybiBbbWF0Y2hlc1sxXV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbXTtcbiAgfTtcblxuICB2YXIgZHJhZ05Ecm9wT2JzZXJ2ZXJzID0gW107XG5cbiAgdmFyIGV2ZW50UG9zaXRpb24gPSBmdW5jdGlvbiBldmVudFBvc2l0aW9uKGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcGFnZUxlZnQ6IGUucGFnZVgsXG4gICAgICBwYWdlVG9wOiBlLnBhZ2VZLFxuICAgICAgc2NvcGVMZWZ0OiBlLm9mZnNldFggfHwgZS5sYXllclgsXG4gICAgICBzY29wZVRvcDogZS5vZmZzZXRZIHx8IGUubGF5ZXJZXG4gICAgfTtcbiAgfTtcblxuICB2YXIgY3JlYXRlRHJhZ05Ecm9wQ2xpZW50ID0gZnVuY3Rpb24gY3JlYXRlRHJhZ05Ecm9wQ2xpZW50KFxuICAgIGVsZW1lbnQsXG4gICAgc2NvcGVUb09ic2VydmUsXG4gICAgZmlsdGVyRWxlbWVudFxuICApIHtcbiAgICB2YXIgb2JzZXJ2ZXIgPSBnZXREcmFnTkRyb3BPYnNlcnZlcihzY29wZVRvT2JzZXJ2ZSk7XG5cbiAgICB2YXIgY2xpZW50ID0ge1xuICAgICAgZWxlbWVudDogZWxlbWVudCxcbiAgICAgIGZpbHRlckVsZW1lbnQ6IGZpbHRlckVsZW1lbnQsXG4gICAgICBzdGF0ZTogbnVsbCxcbiAgICAgIG9uZHJvcDogZnVuY3Rpb24gb25kcm9wKCkge30sXG4gICAgICBvbmVudGVyOiBmdW5jdGlvbiBvbmVudGVyKCkge30sXG4gICAgICBvbmRyYWc6IGZ1bmN0aW9uIG9uZHJhZygpIHt9LFxuICAgICAgb25leGl0OiBmdW5jdGlvbiBvbmV4aXQoKSB7fSxcbiAgICAgIG9ubG9hZDogZnVuY3Rpb24gb25sb2FkKCkge30sXG4gICAgICBhbGxvd2Ryb3A6IGZ1bmN0aW9uIGFsbG93ZHJvcCgpIHt9XG4gICAgfTtcblxuICAgIGNsaWVudC5kZXN0cm95ID0gb2JzZXJ2ZXIuYWRkTGlzdGVuZXIoY2xpZW50KTtcblxuICAgIHJldHVybiBjbGllbnQ7XG4gIH07XG5cbiAgdmFyIGdldERyYWdORHJvcE9ic2VydmVyID0gZnVuY3Rpb24gZ2V0RHJhZ05Ecm9wT2JzZXJ2ZXIoZWxlbWVudCkge1xuICAgIC8vIHNlZSBpZiBhbHJlYWR5IGV4aXN0cywgaWYgc28sIHJldHVyblxuICAgIHZhciBvYnNlcnZlciA9IGRyYWdORHJvcE9ic2VydmVycy5maW5kKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgIHJldHVybiBpdGVtLmVsZW1lbnQgPT09IGVsZW1lbnQ7XG4gICAgfSk7XG4gICAgaWYgKG9ic2VydmVyKSB7XG4gICAgICByZXR1cm4gb2JzZXJ2ZXI7XG4gICAgfVxuXG4gICAgLy8gY3JlYXRlIG5ldyBvYnNlcnZlciwgZG9lcyBub3QgeWV0IGV4aXN0IGZvciB0aGlzIGVsZW1lbnRcbiAgICB2YXIgbmV3T2JzZXJ2ZXIgPSBjcmVhdGVEcmFnTkRyb3BPYnNlcnZlcihlbGVtZW50KTtcbiAgICBkcmFnTkRyb3BPYnNlcnZlcnMucHVzaChuZXdPYnNlcnZlcik7XG4gICAgcmV0dXJuIG5ld09ic2VydmVyO1xuICB9O1xuXG4gIHZhciBjcmVhdGVEcmFnTkRyb3BPYnNlcnZlciA9IGZ1bmN0aW9uIGNyZWF0ZURyYWdORHJvcE9ic2VydmVyKGVsZW1lbnQpIHtcbiAgICB2YXIgY2xpZW50cyA9IFtdO1xuXG4gICAgdmFyIHJvdXRlcyA9IHtcbiAgICAgIGRyYWdlbnRlcjogZHJhZ2VudGVyLFxuICAgICAgZHJhZ292ZXI6IGRyYWdvdmVyLFxuICAgICAgZHJhZ2xlYXZlOiBkcmFnbGVhdmUsXG4gICAgICBkcm9wOiBkcm9wXG4gICAgfTtcblxuICAgIHZhciBoYW5kbGVycyA9IHt9O1xuXG4gICAgZm9yaW4ocm91dGVzLCBmdW5jdGlvbihldmVudCwgY3JlYXRlSGFuZGxlcikge1xuICAgICAgaGFuZGxlcnNbZXZlbnRdID0gY3JlYXRlSGFuZGxlcihlbGVtZW50LCBjbGllbnRzKTtcbiAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlcnNbZXZlbnRdLCBmYWxzZSk7XG4gICAgfSk7XG5cbiAgICB2YXIgb2JzZXJ2ZXIgPSB7XG4gICAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgICAgYWRkTGlzdGVuZXI6IGZ1bmN0aW9uIGFkZExpc3RlbmVyKGNsaWVudCkge1xuICAgICAgICAvLyBhZGQgYXMgY2xpZW50XG4gICAgICAgIGNsaWVudHMucHVzaChjbGllbnQpO1xuXG4gICAgICAgIC8vIHJldHVybiByZW1vdmVMaXN0ZW5lciBmdW5jdGlvblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgLy8gcmVtb3ZlIGNsaWVudFxuICAgICAgICAgIGNsaWVudHMuc3BsaWNlKGNsaWVudHMuaW5kZXhPZihjbGllbnQpLCAxKTtcblxuICAgICAgICAgIC8vIGlmIG5vIG1vcmUgY2xpZW50cywgY2xlYW4gdXAgb2JzZXJ2ZXJcbiAgICAgICAgICBpZiAoY2xpZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGRyYWdORHJvcE9ic2VydmVycy5zcGxpY2UoZHJhZ05Ecm9wT2JzZXJ2ZXJzLmluZGV4T2Yob2JzZXJ2ZXIpLCAxKTtcblxuICAgICAgICAgICAgZm9yaW4ocm91dGVzLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXJzW2V2ZW50XSwgZmFsc2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gb2JzZXJ2ZXI7XG4gIH07XG5cbiAgdmFyIGVsZW1lbnRGcm9tUG9pbnQgPSBmdW5jdGlvbiBlbGVtZW50RnJvbVBvaW50KHJvb3QsIHBvaW50KSB7XG4gICAgaWYgKCEoJ2VsZW1lbnRGcm9tUG9pbnQnIGluIHJvb3QpKSB7XG4gICAgICByb290ID0gZG9jdW1lbnQ7XG4gICAgfVxuICAgIHJldHVybiByb290LmVsZW1lbnRGcm9tUG9pbnQocG9pbnQueCwgcG9pbnQueSk7XG4gIH07XG5cbiAgdmFyIGlzRXZlbnRUYXJnZXQgPSBmdW5jdGlvbiBpc0V2ZW50VGFyZ2V0KGUsIHRhcmdldCkge1xuICAgIC8vIGdldCByb290XG4gICAgdmFyIHJvb3QgPSBnZXRSb290Tm9kZSh0YXJnZXQpO1xuXG4gICAgLy8gZ2V0IGVsZW1lbnQgYXQgcG9zaXRpb25cbiAgICAvLyBpZiByb290IGlzIG5vdCBhY3R1YWwgc2hhZG93IERPTSBhbmQgZG9lcyBub3QgaGF2ZSBlbGVtZW50RnJvbVBvaW50IG1ldGhvZCwgdXNlIHRoZSBvbmUgb24gZG9jdW1lbnRcbiAgICB2YXIgZWxlbWVudEF0UG9zaXRpb24gPSBlbGVtZW50RnJvbVBvaW50KHJvb3QsIHtcbiAgICAgIHg6IGUucGFnZVggLSB3aW5kb3cucGFnZVhPZmZzZXQsXG4gICAgICB5OiBlLnBhZ2VZIC0gd2luZG93LnBhZ2VZT2Zmc2V0XG4gICAgfSk7XG5cbiAgICAvLyB0ZXN0IGlmIHRhcmdldCBpcyB0aGUgZWxlbWVudCBvciBpZiBvbmUgb2YgaXRzIGNoaWxkcmVuIGlzXG4gICAgcmV0dXJuIGVsZW1lbnRBdFBvc2l0aW9uID09PSB0YXJnZXQgfHwgdGFyZ2V0LmNvbnRhaW5zKGVsZW1lbnRBdFBvc2l0aW9uKTtcbiAgfTtcblxuICB2YXIgaW5pdGlhbFRhcmdldCA9IG51bGw7XG5cbiAgdmFyIHNldERyb3BFZmZlY3QgPSBmdW5jdGlvbiBzZXREcm9wRWZmZWN0KGRhdGFUcmFuc2ZlciwgZWZmZWN0KSB7XG4gICAgLy8gaXMgaW4gdHJ5IGNhdGNoIGFzIElFMTEgd2lsbCB0aHJvdyBlcnJvciBpZiBub3RcbiAgICB0cnkge1xuICAgICAgZGF0YVRyYW5zZmVyLmRyb3BFZmZlY3QgPSBlZmZlY3Q7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfTtcblxuICB2YXIgZHJhZ2VudGVyID0gZnVuY3Rpb24gZHJhZ2VudGVyKHJvb3QsIGNsaWVudHMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oZSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICBpbml0aWFsVGFyZ2V0ID0gZS50YXJnZXQ7XG5cbiAgICAgIGNsaWVudHMuZm9yRWFjaChmdW5jdGlvbihjbGllbnQpIHtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSBjbGllbnQuZWxlbWVudCxcbiAgICAgICAgICBvbmVudGVyID0gY2xpZW50Lm9uZW50ZXI7XG5cbiAgICAgICAgaWYgKGlzRXZlbnRUYXJnZXQoZSwgZWxlbWVudCkpIHtcbiAgICAgICAgICBjbGllbnQuc3RhdGUgPSAnZW50ZXInO1xuXG4gICAgICAgICAgLy8gZmlyZSBlbnRlciBldmVudFxuICAgICAgICAgIG9uZW50ZXIoZXZlbnRQb3NpdGlvbihlKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIGRyYWdvdmVyID0gZnVuY3Rpb24gZHJhZ292ZXIocm9vdCwgY2xpZW50cykge1xuICAgIHJldHVybiBmdW5jdGlvbihlKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgIHZhciBkYXRhVHJhbnNmZXIgPSBlLmRhdGFUcmFuc2ZlcjtcblxuICAgICAgcmVxdWVzdERhdGFUcmFuc2Zlckl0ZW1zKGRhdGFUcmFuc2ZlcikudGhlbihmdW5jdGlvbihpdGVtcykge1xuICAgICAgICB2YXIgb3ZlckRyb3BUYXJnZXQgPSBmYWxzZTtcblxuICAgICAgICBjbGllbnRzLnNvbWUoZnVuY3Rpb24oY2xpZW50KSB7XG4gICAgICAgICAgdmFyIGZpbHRlckVsZW1lbnQgPSBjbGllbnQuZmlsdGVyRWxlbWVudCxcbiAgICAgICAgICAgIGVsZW1lbnQgPSBjbGllbnQuZWxlbWVudCxcbiAgICAgICAgICAgIG9uZW50ZXIgPSBjbGllbnQub25lbnRlcixcbiAgICAgICAgICAgIG9uZXhpdCA9IGNsaWVudC5vbmV4aXQsXG4gICAgICAgICAgICBvbmRyYWcgPSBjbGllbnQub25kcmFnLFxuICAgICAgICAgICAgYWxsb3dkcm9wID0gY2xpZW50LmFsbG93ZHJvcDtcblxuICAgICAgICAgIC8vIGJ5IGRlZmF1bHQgd2UgY2FuIGRyb3BcbiAgICAgICAgICBzZXREcm9wRWZmZWN0KGRhdGFUcmFuc2ZlciwgJ2NvcHknKTtcblxuICAgICAgICAgIC8vIGFsbG93IHRyYW5zZmVyIG9mIHRoZXNlIGl0ZW1zXG4gICAgICAgICAgdmFyIGFsbG93c1RyYW5zZmVyID0gYWxsb3dkcm9wKGl0ZW1zKTtcblxuICAgICAgICAgIC8vIG9ubHkgdXNlZCB3aGVuIGNhbiBiZSBkcm9wcGVkIG9uIHBhZ2VcbiAgICAgICAgICBpZiAoIWFsbG93c1RyYW5zZmVyKSB7XG4gICAgICAgICAgICBzZXREcm9wRWZmZWN0KGRhdGFUcmFuc2ZlciwgJ25vbmUnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyB0YXJnZXR0aW5nIHRoaXMgY2xpZW50XG4gICAgICAgICAgaWYgKGlzRXZlbnRUYXJnZXQoZSwgZWxlbWVudCkpIHtcbiAgICAgICAgICAgIG92ZXJEcm9wVGFyZ2V0ID0gdHJ1ZTtcblxuICAgICAgICAgICAgLy8gaGFkIG5vIHByZXZpb3VzIHN0YXRlLCBtZWFucyB3ZSBhcmUgZW50ZXJpbmcgdGhpcyBjbGllbnRcbiAgICAgICAgICAgIGlmIChjbGllbnQuc3RhdGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgY2xpZW50LnN0YXRlID0gJ2VudGVyJztcbiAgICAgICAgICAgICAgb25lbnRlcihldmVudFBvc2l0aW9uKGUpKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBub3cgb3ZlciBlbGVtZW50IChubyBtYXR0ZXIgaWYgaXQgYWxsb3dzIHRoZSBkcm9wIG9yIG5vdClcbiAgICAgICAgICAgIGNsaWVudC5zdGF0ZSA9ICdvdmVyJztcblxuICAgICAgICAgICAgLy8gbmVlZHMgdG8gYWxsb3cgdHJhbnNmZXJcbiAgICAgICAgICAgIGlmIChmaWx0ZXJFbGVtZW50ICYmICFhbGxvd3NUcmFuc2Zlcikge1xuICAgICAgICAgICAgICBzZXREcm9wRWZmZWN0KGRhdGFUcmFuc2ZlciwgJ25vbmUnKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBkcmFnZ2luZ1xuICAgICAgICAgICAgb25kcmFnKGV2ZW50UG9zaXRpb24oZSkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBzaG91bGQgYmUgb3ZlciBhbiBlbGVtZW50IHRvIGRyb3BcbiAgICAgICAgICAgIGlmIChmaWx0ZXJFbGVtZW50ICYmICFvdmVyRHJvcFRhcmdldCkge1xuICAgICAgICAgICAgICBzZXREcm9wRWZmZWN0KGRhdGFUcmFuc2ZlciwgJ25vbmUnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gbWlnaHQgaGF2ZSBqdXN0IGxlZnQgdGhpcyBjbGllbnQ/XG4gICAgICAgICAgICBpZiAoY2xpZW50LnN0YXRlKSB7XG4gICAgICAgICAgICAgIGNsaWVudC5zdGF0ZSA9IG51bGw7XG4gICAgICAgICAgICAgIG9uZXhpdChldmVudFBvc2l0aW9uKGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgZHJvcCA9IGZ1bmN0aW9uIGRyb3Aocm9vdCwgY2xpZW50cykge1xuICAgIHJldHVybiBmdW5jdGlvbihlKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgIHZhciBkYXRhVHJhbnNmZXIgPSBlLmRhdGFUcmFuc2ZlcjtcblxuICAgICAgcmVxdWVzdERhdGFUcmFuc2Zlckl0ZW1zKGRhdGFUcmFuc2ZlcikudGhlbihmdW5jdGlvbihpdGVtcykge1xuICAgICAgICBjbGllbnRzLmZvckVhY2goZnVuY3Rpb24oY2xpZW50KSB7XG4gICAgICAgICAgdmFyIGZpbHRlckVsZW1lbnQgPSBjbGllbnQuZmlsdGVyRWxlbWVudCxcbiAgICAgICAgICAgIGVsZW1lbnQgPSBjbGllbnQuZWxlbWVudCxcbiAgICAgICAgICAgIG9uZHJvcCA9IGNsaWVudC5vbmRyb3AsXG4gICAgICAgICAgICBvbmV4aXQgPSBjbGllbnQub25leGl0LFxuICAgICAgICAgICAgYWxsb3dkcm9wID0gY2xpZW50LmFsbG93ZHJvcDtcblxuICAgICAgICAgIGNsaWVudC5zdGF0ZSA9IG51bGw7XG5cbiAgICAgICAgICAvLyBpZiB3ZSdyZSBmaWx0ZXJpbmcgb24gZWxlbWVudCB3ZSBuZWVkIHRvIGJlIG92ZXIgdGhlIGVsZW1lbnQgdG8gZHJvcFxuICAgICAgICAgIGlmIChmaWx0ZXJFbGVtZW50ICYmICFpc0V2ZW50VGFyZ2V0KGUsIGVsZW1lbnQpKSByZXR1cm47XG5cbiAgICAgICAgICAvLyBubyB0cmFuc2ZlciBmb3IgdGhpcyBjbGllbnRcbiAgICAgICAgICBpZiAoIWFsbG93ZHJvcChpdGVtcykpIHJldHVybiBvbmV4aXQoZXZlbnRQb3NpdGlvbihlKSk7XG5cbiAgICAgICAgICAvLyB3ZSBjYW4gZHJvcCB0aGVzZSBpdGVtcyBvbiB0aGlzIGNsaWVudFxuICAgICAgICAgIG9uZHJvcChldmVudFBvc2l0aW9uKGUpLCBpdGVtcyk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgZHJhZ2xlYXZlID0gZnVuY3Rpb24gZHJhZ2xlYXZlKHJvb3QsIGNsaWVudHMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oZSkge1xuICAgICAgaWYgKGluaXRpYWxUYXJnZXQgIT09IGUudGFyZ2V0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY2xpZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGNsaWVudCkge1xuICAgICAgICB2YXIgb25leGl0ID0gY2xpZW50Lm9uZXhpdDtcblxuICAgICAgICBjbGllbnQuc3RhdGUgPSBudWxsO1xuXG4gICAgICAgIG9uZXhpdChldmVudFBvc2l0aW9uKGUpKTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIGNyZWF0ZUhvcHBlciA9IGZ1bmN0aW9uIGNyZWF0ZUhvcHBlcihzY29wZSwgdmFsaWRhdGVJdGVtcywgb3B0aW9ucykge1xuICAgIC8vIGlzIG5vdyBob3BwZXIgc2NvcGVcbiAgICBzY29wZS5jbGFzc0xpc3QuYWRkKCdmaWxlcG9uZC0taG9wcGVyJyk7XG5cbiAgICAvLyBzaG9ydGN1dHNcbiAgICB2YXIgY2F0Y2hlc0Ryb3BzT25QYWdlID0gb3B0aW9ucy5jYXRjaGVzRHJvcHNPblBhZ2UsXG4gICAgICByZXF1aXJlc0Ryb3BPbkVsZW1lbnQgPSBvcHRpb25zLnJlcXVpcmVzRHJvcE9uRWxlbWVudCxcbiAgICAgIF9vcHRpb25zJGZpbHRlckl0ZW1zID0gb3B0aW9ucy5maWx0ZXJJdGVtcyxcbiAgICAgIGZpbHRlckl0ZW1zID1cbiAgICAgICAgX29wdGlvbnMkZmlsdGVySXRlbXMgPT09IHZvaWQgMFxuICAgICAgICAgID8gZnVuY3Rpb24oaXRlbXMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIDogX29wdGlvbnMkZmlsdGVySXRlbXM7XG5cbiAgICAvLyBjcmVhdGUgYSBkbmQgY2xpZW50XG4gICAgdmFyIGNsaWVudCA9IGNyZWF0ZURyYWdORHJvcENsaWVudChcbiAgICAgIHNjb3BlLFxuICAgICAgY2F0Y2hlc0Ryb3BzT25QYWdlID8gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50IDogc2NvcGUsXG4gICAgICByZXF1aXJlc0Ryb3BPbkVsZW1lbnRcbiAgICApO1xuXG4gICAgLy8gY3VycmVudCBjbGllbnQgc3RhdGVcbiAgICB2YXIgbGFzdFN0YXRlID0gJyc7XG4gICAgdmFyIGN1cnJlbnRTdGF0ZSA9ICcnO1xuXG4gICAgLy8gZGV0ZXJtaW5lcyBpZiBhIGZpbGUgbWF5IGJlIGRyb3BwZWRcbiAgICBjbGllbnQuYWxsb3dkcm9wID0gZnVuY3Rpb24oaXRlbXMpIHtcbiAgICAgIC8vIFRPRE86IGlmIHdlIGNhbiwgdGhyb3cgZXJyb3IgdG8gaW5kaWNhdGUgdGhlIGl0ZW1zIGNhbm5vdCBieSBkcm9wcGVkXG5cbiAgICAgIHJldHVybiB2YWxpZGF0ZUl0ZW1zKGZpbHRlckl0ZW1zKGl0ZW1zKSk7XG4gICAgfTtcblxuICAgIGNsaWVudC5vbmRyb3AgPSBmdW5jdGlvbihwb3NpdGlvbiwgaXRlbXMpIHtcbiAgICAgIHZhciBmaWx0ZXJlZEl0ZW1zID0gZmlsdGVySXRlbXMoaXRlbXMpO1xuXG4gICAgICBpZiAoIXZhbGlkYXRlSXRlbXMoZmlsdGVyZWRJdGVtcykpIHtcbiAgICAgICAgYXBpLm9uZHJhZ2VuZChwb3NpdGlvbik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY3VycmVudFN0YXRlID0gJ2RyYWctZHJvcCc7XG5cbiAgICAgIGFwaS5vbmxvYWQoZmlsdGVyZWRJdGVtcywgcG9zaXRpb24pO1xuICAgIH07XG5cbiAgICBjbGllbnQub25kcmFnID0gZnVuY3Rpb24ocG9zaXRpb24pIHtcbiAgICAgIGFwaS5vbmRyYWcocG9zaXRpb24pO1xuICAgIH07XG5cbiAgICBjbGllbnQub25lbnRlciA9IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XG4gICAgICBjdXJyZW50U3RhdGUgPSAnZHJhZy1vdmVyJztcblxuICAgICAgYXBpLm9uZHJhZ3N0YXJ0KHBvc2l0aW9uKTtcbiAgICB9O1xuXG4gICAgY2xpZW50Lm9uZXhpdCA9IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XG4gICAgICBjdXJyZW50U3RhdGUgPSAnZHJhZy1leGl0JztcblxuICAgICAgYXBpLm9uZHJhZ2VuZChwb3NpdGlvbik7XG4gICAgfTtcblxuICAgIHZhciBhcGkgPSB7XG4gICAgICB1cGRhdGVIb3BwZXJTdGF0ZTogZnVuY3Rpb24gdXBkYXRlSG9wcGVyU3RhdGUoKSB7XG4gICAgICAgIGlmIChsYXN0U3RhdGUgIT09IGN1cnJlbnRTdGF0ZSkge1xuICAgICAgICAgIHNjb3BlLmRhdGFzZXQuaG9wcGVyU3RhdGUgPSBjdXJyZW50U3RhdGU7XG4gICAgICAgICAgbGFzdFN0YXRlID0gY3VycmVudFN0YXRlO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb25sb2FkOiBmdW5jdGlvbiBvbmxvYWQoKSB7fSxcbiAgICAgIG9uZHJhZ3N0YXJ0OiBmdW5jdGlvbiBvbmRyYWdzdGFydCgpIHt9LFxuICAgICAgb25kcmFnOiBmdW5jdGlvbiBvbmRyYWcoKSB7fSxcbiAgICAgIG9uZHJhZ2VuZDogZnVuY3Rpb24gb25kcmFnZW5kKCkge30sXG4gICAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICAvLyBkZXN0cm95IGNsaWVudFxuICAgICAgICBjbGllbnQuZGVzdHJveSgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gYXBpO1xuICB9O1xuXG4gIHZhciBsaXN0ZW5pbmcgPSBmYWxzZTtcbiAgdmFyIGxpc3RlbmVycyQxID0gW107XG5cbiAgdmFyIGhhbmRsZVBhc3RlID0gZnVuY3Rpb24gaGFuZGxlUGFzdGUoZSkge1xuICAgIC8vIGlmIGlzIHBhc3RpbmcgaW4gaW5wdXQgb3IgdGV4dGFyZWEgYW5kIHRoZSB0YXJnZXQgaXMgb3V0c2lkZSBvZiBhIGZpbGVwb25kIHNjb3BlLCBpZ25vcmVcbiAgICB2YXIgYWN0aXZlRWwgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgIGlmIChhY3RpdmVFbCAmJiAvdGV4dGFyZWF8aW5wdXQvaS50ZXN0KGFjdGl2ZUVsLm5vZGVOYW1lKSkge1xuICAgICAgLy8gdGVzdCB0ZXh0YXJlYSBvciBpbnB1dCBpcyBjb250YWluZWQgaW4gZmlsZXBvbmQgcm9vdFxuICAgICAgdmFyIGluU2NvcGUgPSBmYWxzZTtcbiAgICAgIHZhciBlbGVtZW50ID0gYWN0aXZlRWw7XG4gICAgICB3aGlsZSAoZWxlbWVudCAhPT0gZG9jdW1lbnQuYm9keSkge1xuICAgICAgICBpZiAoZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoJ2ZpbGVwb25kLS1yb290JykpIHtcbiAgICAgICAgICBpblNjb3BlID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWluU2NvcGUpIHJldHVybjtcbiAgICB9XG5cbiAgICByZXF1ZXN0RGF0YVRyYW5zZmVySXRlbXMoZS5jbGlwYm9hcmREYXRhKS50aGVuKGZ1bmN0aW9uKGZpbGVzKSB7XG4gICAgICAvLyBubyBmaWxlcyByZWNlaXZlZFxuICAgICAgaWYgKCFmaWxlcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBub3RpZnkgbGlzdGVuZXJzIG9mIHJlY2VpdmVkIGZpbGVzXG4gICAgICBsaXN0ZW5lcnMkMS5mb3JFYWNoKGZ1bmN0aW9uKGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiBsaXN0ZW5lcihmaWxlcyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgbGlzdGVuID0gZnVuY3Rpb24gbGlzdGVuKGNiKSB7XG4gICAgLy8gY2FuJ3QgYWRkIHR3aWNlXG4gICAgaWYgKGxpc3RlbmVycyQxLmluY2x1ZGVzKGNiKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGFkZCBpbml0aWFsIGxpc3RlbmVyXG4gICAgbGlzdGVuZXJzJDEucHVzaChjYik7XG5cbiAgICAvLyBzZXR1cCBwYXN0ZSBsaXN0ZW5lciBmb3IgZW50aXJlIHBhZ2VcbiAgICBpZiAobGlzdGVuaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGlzdGVuaW5nID0gdHJ1ZTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdwYXN0ZScsIGhhbmRsZVBhc3RlKTtcbiAgfTtcblxuICB2YXIgdW5saXN0ZW4gPSBmdW5jdGlvbiB1bmxpc3RlbihsaXN0ZW5lcikge1xuICAgIGFycmF5UmVtb3ZlKGxpc3RlbmVycyQxLCBsaXN0ZW5lcnMkMS5pbmRleE9mKGxpc3RlbmVyKSk7XG5cbiAgICAvLyBjbGVhbiB1cFxuICAgIGlmIChsaXN0ZW5lcnMkMS5sZW5ndGggPT09IDApIHtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Bhc3RlJywgaGFuZGxlUGFzdGUpO1xuICAgICAgbGlzdGVuaW5nID0gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIHZhciBjcmVhdGVQYXN0ZXIgPSBmdW5jdGlvbiBjcmVhdGVQYXN0ZXIoKSB7XG4gICAgdmFyIGNiID0gZnVuY3Rpb24gY2IoZmlsZXMpIHtcbiAgICAgIGFwaS5vbmxvYWQoZmlsZXMpO1xuICAgIH07XG5cbiAgICB2YXIgYXBpID0ge1xuICAgICAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgdW5saXN0ZW4oY2IpO1xuICAgICAgfSxcbiAgICAgIG9ubG9hZDogZnVuY3Rpb24gb25sb2FkKCkge31cbiAgICB9O1xuXG4gICAgbGlzdGVuKGNiKTtcblxuICAgIHJldHVybiBhcGk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgdGhlIGZpbGUgdmlld1xuICAgKi9cbiAgdmFyIGNyZWF0ZSRkID0gZnVuY3Rpb24gY3JlYXRlKF9yZWYpIHtcbiAgICB2YXIgcm9vdCA9IF9yZWYucm9vdCxcbiAgICAgIHByb3BzID0gX3JlZi5wcm9wcztcbiAgICByb290LmVsZW1lbnQuaWQgPSAnZmlsZXBvbmQtLWFzc2lzdGFudC0nICsgcHJvcHMuaWQ7XG4gICAgYXR0cihyb290LmVsZW1lbnQsICdyb2xlJywgJ3N0YXR1cycpO1xuICAgIGF0dHIocm9vdC5lbGVtZW50LCAnYXJpYS1saXZlJywgJ3BvbGl0ZScpO1xuICAgIGF0dHIocm9vdC5lbGVtZW50LCAnYXJpYS1yZWxldmFudCcsICdhZGRpdGlvbnMnKTtcbiAgfTtcblxuICB2YXIgYWRkRmlsZXNOb3RpZmljYXRpb25UaW1lb3V0ID0gbnVsbDtcbiAgdmFyIG5vdGlmaWNhdGlvbkNsZWFyVGltZW91dCA9IG51bGw7XG5cbiAgdmFyIGZpbGVuYW1lcyA9IFtdO1xuXG4gIHZhciBhc3Npc3QgPSBmdW5jdGlvbiBhc3Npc3Qocm9vdCwgbWVzc2FnZSkge1xuICAgIHJvb3QuZWxlbWVudC50ZXh0Q29udGVudCA9IG1lc3NhZ2U7XG4gIH07XG5cbiAgdmFyIGNsZWFyJDEgPSBmdW5jdGlvbiBjbGVhcihyb290KSB7XG4gICAgcm9vdC5lbGVtZW50LnRleHRDb250ZW50ID0gJyc7XG4gIH07XG5cbiAgdmFyIGxpc3RNb2RpZmllZCA9IGZ1bmN0aW9uIGxpc3RNb2RpZmllZChyb290LCBmaWxlbmFtZSwgbGFiZWwpIHtcbiAgICB2YXIgdG90YWwgPSByb290LnF1ZXJ5KCdHRVRfVE9UQUxfSVRFTVMnKTtcbiAgICBhc3Npc3QoXG4gICAgICByb290LFxuICAgICAgbGFiZWwgK1xuICAgICAgICAnICcgK1xuICAgICAgICBmaWxlbmFtZSArXG4gICAgICAgICcsICcgK1xuICAgICAgICB0b3RhbCArXG4gICAgICAgICcgJyArXG4gICAgICAgICh0b3RhbCA9PT0gMVxuICAgICAgICAgID8gcm9vdC5xdWVyeSgnR0VUX0xBQkVMX0ZJTEVfQ09VTlRfU0lOR1VMQVInKVxuICAgICAgICAgIDogcm9vdC5xdWVyeSgnR0VUX0xBQkVMX0ZJTEVfQ09VTlRfUExVUkFMJykpXG4gICAgKTtcblxuICAgIC8vIGNsZWFyIGdyb3VwIGFmdGVyIHNldCBhbW91bnQgb2YgdGltZSBzbyB0aGUgc3RhdHVzIGlzIG5vdCByZWFkIHR3aWNlXG4gICAgY2xlYXJUaW1lb3V0KG5vdGlmaWNhdGlvbkNsZWFyVGltZW91dCk7XG4gICAgbm90aWZpY2F0aW9uQ2xlYXJUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIGNsZWFyJDEocm9vdCk7XG4gICAgfSwgMTUwMCk7XG4gIH07XG5cbiAgdmFyIGlzVXNpbmdGaWxlUG9uZCA9IGZ1bmN0aW9uIGlzVXNpbmdGaWxlUG9uZChyb290KSB7XG4gICAgcmV0dXJuIHJvb3QuZWxlbWVudC5wYXJlbnROb2RlLmNvbnRhaW5zKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpO1xuICB9O1xuXG4gIHZhciBpdGVtQWRkZWQgPSBmdW5jdGlvbiBpdGVtQWRkZWQoX3JlZjIpIHtcbiAgICB2YXIgcm9vdCA9IF9yZWYyLnJvb3QsXG4gICAgICBhY3Rpb24gPSBfcmVmMi5hY3Rpb247XG4gICAgaWYgKCFpc1VzaW5nRmlsZVBvbmQocm9vdCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICByb290LmVsZW1lbnQudGV4dENvbnRlbnQgPSAnJztcbiAgICB2YXIgaXRlbSA9IHJvb3QucXVlcnkoJ0dFVF9JVEVNJywgYWN0aW9uLmlkKTtcbiAgICBmaWxlbmFtZXMucHVzaChpdGVtLmZpbGVuYW1lKTtcblxuICAgIGNsZWFyVGltZW91dChhZGRGaWxlc05vdGlmaWNhdGlvblRpbWVvdXQpO1xuICAgIGFkZEZpbGVzTm90aWZpY2F0aW9uVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBsaXN0TW9kaWZpZWQoXG4gICAgICAgIHJvb3QsXG4gICAgICAgIGZpbGVuYW1lcy5qb2luKCcsICcpLFxuICAgICAgICByb290LnF1ZXJ5KCdHRVRfTEFCRUxfRklMRV9BRERFRCcpXG4gICAgICApO1xuXG4gICAgICBmaWxlbmFtZXMubGVuZ3RoID0gMDtcbiAgICB9LCA3NTApO1xuICB9O1xuXG4gIHZhciBpdGVtUmVtb3ZlZCA9IGZ1bmN0aW9uIGl0ZW1SZW1vdmVkKF9yZWYzKSB7XG4gICAgdmFyIHJvb3QgPSBfcmVmMy5yb290LFxuICAgICAgYWN0aW9uID0gX3JlZjMuYWN0aW9uO1xuICAgIGlmICghaXNVc2luZ0ZpbGVQb25kKHJvb3QpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGl0ZW0gPSBhY3Rpb24uaXRlbTtcbiAgICBsaXN0TW9kaWZpZWQocm9vdCwgaXRlbS5maWxlbmFtZSwgcm9vdC5xdWVyeSgnR0VUX0xBQkVMX0ZJTEVfUkVNT1ZFRCcpKTtcbiAgfTtcblxuICB2YXIgaXRlbVByb2Nlc3NlZCA9IGZ1bmN0aW9uIGl0ZW1Qcm9jZXNzZWQoX3JlZjQpIHtcbiAgICB2YXIgcm9vdCA9IF9yZWY0LnJvb3QsXG4gICAgICBhY3Rpb24gPSBfcmVmNC5hY3Rpb247XG4gICAgLy8gd2lsbCBhbHNvIG5vdGlmeSB0aGUgdXNlciB3aGVuIEZpbGVQb25kIGlzIG5vdCBiZWluZyB1c2VkLCBhcyB0aGUgdXNlciBtaWdodCBiZSBvY2N1cGllZCB3aXRoIG90aGVyIGFjdGl2aXRpZXMgd2hpbGUgdXBsb2FkaW5nIGEgZmlsZVxuXG4gICAgdmFyIGl0ZW0gPSByb290LnF1ZXJ5KCdHRVRfSVRFTScsIGFjdGlvbi5pZCk7XG4gICAgdmFyIGZpbGVuYW1lID0gaXRlbS5maWxlbmFtZTtcbiAgICB2YXIgbGFiZWwgPSByb290LnF1ZXJ5KCdHRVRfTEFCRUxfRklMRV9QUk9DRVNTSU5HX0NPTVBMRVRFJyk7XG5cbiAgICBhc3Npc3Qocm9vdCwgZmlsZW5hbWUgKyAnICcgKyBsYWJlbCk7XG4gIH07XG5cbiAgdmFyIGl0ZW1Qcm9jZXNzZWRVbmRvID0gZnVuY3Rpb24gaXRlbVByb2Nlc3NlZFVuZG8oX3JlZjUpIHtcbiAgICB2YXIgcm9vdCA9IF9yZWY1LnJvb3QsXG4gICAgICBhY3Rpb24gPSBfcmVmNS5hY3Rpb247XG4gICAgdmFyIGl0ZW0gPSByb290LnF1ZXJ5KCdHRVRfSVRFTScsIGFjdGlvbi5pZCk7XG4gICAgdmFyIGZpbGVuYW1lID0gaXRlbS5maWxlbmFtZTtcbiAgICB2YXIgbGFiZWwgPSByb290LnF1ZXJ5KCdHRVRfTEFCRUxfRklMRV9QUk9DRVNTSU5HX0FCT1JURUQnKTtcblxuICAgIGFzc2lzdChyb290LCBmaWxlbmFtZSArICcgJyArIGxhYmVsKTtcbiAgfTtcblxuICB2YXIgaXRlbUVycm9yID0gZnVuY3Rpb24gaXRlbUVycm9yKF9yZWY2KSB7XG4gICAgdmFyIHJvb3QgPSBfcmVmNi5yb290LFxuICAgICAgYWN0aW9uID0gX3JlZjYuYWN0aW9uO1xuICAgIHZhciBpdGVtID0gcm9vdC5xdWVyeSgnR0VUX0lURU0nLCBhY3Rpb24uaWQpO1xuICAgIHZhciBmaWxlbmFtZSA9IGl0ZW0uZmlsZW5hbWU7XG5cbiAgICAvLyB3aWxsIGFsc28gbm90aWZ5IHRoZSB1c2VyIHdoZW4gRmlsZVBvbmQgaXMgbm90IGJlaW5nIHVzZWQsIGFzIHRoZSB1c2VyIG1pZ2h0IGJlIG9jY3VwaWVkIHdpdGggb3RoZXIgYWN0aXZpdGllcyB3aGlsZSB1cGxvYWRpbmcgYSBmaWxlXG5cbiAgICBhc3Npc3Qocm9vdCwgYWN0aW9uLnN0YXR1cy5tYWluICsgJyAnICsgZmlsZW5hbWUgKyAnICcgKyBhY3Rpb24uc3RhdHVzLnN1Yik7XG4gIH07XG5cbiAgdmFyIGFzc2lzdGFudCA9IGNyZWF0ZVZpZXcoe1xuICAgIGNyZWF0ZTogY3JlYXRlJGQsXG4gICAgaWdub3JlUmVjdDogdHJ1ZSxcbiAgICBpZ25vcmVSZWN0VXBkYXRlOiB0cnVlLFxuICAgIHdyaXRlOiBjcmVhdGVSb3V0ZSh7XG4gICAgICBESURfTE9BRF9JVEVNOiBpdGVtQWRkZWQsXG4gICAgICBESURfUkVNT1ZFX0lURU06IGl0ZW1SZW1vdmVkLFxuICAgICAgRElEX0NPTVBMRVRFX0lURU1fUFJPQ0VTU0lORzogaXRlbVByb2Nlc3NlZCxcblxuICAgICAgRElEX0FCT1JUX0lURU1fUFJPQ0VTU0lORzogaXRlbVByb2Nlc3NlZFVuZG8sXG4gICAgICBESURfUkVWRVJUX0lURU1fUFJPQ0VTU0lORzogaXRlbVByb2Nlc3NlZFVuZG8sXG5cbiAgICAgIERJRF9USFJPV19JVEVNX1JFTU9WRV9FUlJPUjogaXRlbUVycm9yLFxuICAgICAgRElEX1RIUk9XX0lURU1fTE9BRF9FUlJPUjogaXRlbUVycm9yLFxuICAgICAgRElEX1RIUk9XX0lURU1fSU5WQUxJRDogaXRlbUVycm9yLFxuICAgICAgRElEX1RIUk9XX0lURU1fUFJPQ0VTU0lOR19FUlJPUjogaXRlbUVycm9yXG4gICAgfSksXG5cbiAgICB0YWc6ICdzcGFuJyxcbiAgICBuYW1lOiAnYXNzaXN0YW50J1xuICB9KTtcblxuICB2YXIgdG9DYW1lbHMgPSBmdW5jdGlvbiB0b0NhbWVscyhzdHJpbmcpIHtcbiAgICB2YXIgc2VwYXJhdG9yID1cbiAgICAgIGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJy0nO1xuICAgIHJldHVybiBzdHJpbmcucmVwbGFjZShuZXcgUmVnRXhwKHNlcGFyYXRvciArICcuJywgJ2cnKSwgZnVuY3Rpb24oc3ViKSB7XG4gICAgICByZXR1cm4gc3ViLmNoYXJBdCgxKS50b1VwcGVyQ2FzZSgpO1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciBkZWJvdW5jZSA9IGZ1bmN0aW9uIGRlYm91bmNlKGZ1bmMpIHtcbiAgICB2YXIgaW50ZXJ2YWwgPVxuICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAxNjtcbiAgICB2YXIgaW1taWRpYXRlT25seSA9XG4gICAgICBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHRydWU7XG4gICAgdmFyIGxhc3QgPSBEYXRlLm5vdygpO1xuICAgIHZhciB0aW1lb3V0ID0gbnVsbDtcblxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGZvciAoXG4gICAgICAgIHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7XG4gICAgICAgIF9rZXkgPCBfbGVuO1xuICAgICAgICBfa2V5KytcbiAgICAgICkge1xuICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuXG4gICAgICB2YXIgZGlzdCA9IERhdGUubm93KCkgLSBsYXN0O1xuXG4gICAgICB2YXIgZm4gPSBmdW5jdGlvbiBmbigpIHtcbiAgICAgICAgbGFzdCA9IERhdGUubm93KCk7XG4gICAgICAgIGZ1bmMuYXBwbHkodm9pZCAwLCBhcmdzKTtcbiAgICAgIH07XG5cbiAgICAgIGlmIChkaXN0IDwgaW50ZXJ2YWwpIHtcbiAgICAgICAgLy8gd2UgbmVlZCB0byBkZWxheSBieSB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIGludGVydmFsIGFuZCBkaXN0XG4gICAgICAgIC8vIGZvciBleGFtcGxlOiBpZiBkaXN0YW5jZSBpcyAxMCBtcyBhbmQgaW50ZXJ2YWwgaXMgMTYgbXMsXG4gICAgICAgIC8vIHdlIG5lZWQgdG8gd2FpdCBhbiBhZGRpdGlvbmFsIDZtcyBiZWZvcmUgY2FsbGluZyB0aGUgZnVuY3Rpb24pXG4gICAgICAgIGlmICghaW1taWRpYXRlT25seSkge1xuICAgICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGZuLCBpbnRlcnZhbCAtIGRpc3QpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBnbyFcbiAgICAgICAgZm4oKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIHZhciBNQVhfRklMRVNfTElNSVQgPSAxMDAwMDAwO1xuXG4gIHZhciBwcmV2ZW50ID0gZnVuY3Rpb24gcHJldmVudChlKSB7XG4gICAgcmV0dXJuIGUucHJldmVudERlZmF1bHQoKTtcbiAgfTtcblxuICB2YXIgY3JlYXRlJGUgPSBmdW5jdGlvbiBjcmVhdGUoX3JlZikge1xuICAgIHZhciByb290ID0gX3JlZi5yb290LFxuICAgICAgcHJvcHMgPSBfcmVmLnByb3BzO1xuXG4gICAgLy8gQWRkIGlkXG4gICAgdmFyIGlkID0gcm9vdC5xdWVyeSgnR0VUX0lEJyk7XG4gICAgaWYgKGlkKSB7XG4gICAgICByb290LmVsZW1lbnQuaWQgPSBpZDtcbiAgICB9XG5cbiAgICAvLyBBZGQgY2xhc3NOYW1lXG4gICAgdmFyIGNsYXNzTmFtZSA9IHJvb3QucXVlcnkoJ0dFVF9DTEFTU19OQU1FJyk7XG4gICAgaWYgKGNsYXNzTmFtZSkge1xuICAgICAgY2xhc3NOYW1lXG4gICAgICAgIC5zcGxpdCgnICcpXG4gICAgICAgIC5maWx0ZXIoZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgIHJldHVybiBuYW1lLmxlbmd0aDtcbiAgICAgICAgfSlcbiAgICAgICAgLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgIHJvb3QuZWxlbWVudC5jbGFzc0xpc3QuYWRkKG5hbWUpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBGaWVsZCBsYWJlbFxuICAgIHJvb3QucmVmLmxhYmVsID0gcm9vdC5hcHBlbmRDaGlsZFZpZXcoXG4gICAgICByb290LmNyZWF0ZUNoaWxkVmlldyhcbiAgICAgICAgZHJvcExhYmVsLFxuICAgICAgICBPYmplY3QuYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHRyYW5zbGF0ZVk6IG51bGwsXG4gICAgICAgICAgY2FwdGlvbjogcm9vdC5xdWVyeSgnR0VUX0xBQkVMX0lETEUnKVxuICAgICAgICB9KVxuICAgICAgKVxuICAgICk7XG5cbiAgICAvLyBMaXN0IG9mIGl0ZW1zXG4gICAgcm9vdC5yZWYubGlzdCA9IHJvb3QuYXBwZW5kQ2hpbGRWaWV3KFxuICAgICAgcm9vdC5jcmVhdGVDaGlsZFZpZXcobGlzdFNjcm9sbGVyLCB7IHRyYW5zbGF0ZVk6IG51bGwgfSlcbiAgICApO1xuXG4gICAgLy8gQmFja2dyb3VuZCBwYW5lbFxuICAgIHJvb3QucmVmLnBhbmVsID0gcm9vdC5hcHBlbmRDaGlsZFZpZXcoXG4gICAgICByb290LmNyZWF0ZUNoaWxkVmlldyhwYW5lbCwgeyBuYW1lOiAncGFuZWwtcm9vdCcgfSlcbiAgICApO1xuXG4gICAgLy8gQXNzaXN0YW50IG5vdGlmaWVzIGFzc2lzdGl2ZSB0ZWNoIHdoZW4gY29udGVudCBjaGFuZ2VzXG4gICAgcm9vdC5yZWYuYXNzaXN0YW50ID0gcm9vdC5hcHBlbmRDaGlsZFZpZXcoXG4gICAgICByb290LmNyZWF0ZUNoaWxkVmlldyhhc3Npc3RhbnQsIE9iamVjdC5hc3NpZ24oe30sIHByb3BzKSlcbiAgICApO1xuXG4gICAgLy8gRGF0YVxuICAgIHJvb3QucmVmLmRhdGEgPSByb290LmFwcGVuZENoaWxkVmlldyhcbiAgICAgIHJvb3QuY3JlYXRlQ2hpbGRWaWV3KGRhdGEsIE9iamVjdC5hc3NpZ24oe30sIHByb3BzKSlcbiAgICApO1xuXG4gICAgLy8gTWVhc3VyZSAodGVzdHMgaWYgZml4ZWQgaGVpZ2h0IHdhcyBzZXQpXG4gICAgLy8gRE9DVFlQRSBuZWVkcyB0byBiZSBzZXQgZm9yIHRoaXMgdG8gd29ya1xuICAgIHJvb3QucmVmLm1lYXN1cmUgPSBjcmVhdGVFbGVtZW50JDEoJ2RpdicpO1xuICAgIHJvb3QucmVmLm1lYXN1cmUuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuICAgIHJvb3QuZWxlbWVudC5hcHBlbmRDaGlsZChyb290LnJlZi5tZWFzdXJlKTtcblxuICAgIC8vIGluZm9ybWF0aW9uIG9uIHRoZSByb290IGhlaWdodCBvciBmaXhlZCBoZWlnaHQgc3RhdHVzXG4gICAgcm9vdC5yZWYuYm91bmRzID0gbnVsbDtcblxuICAgIC8vIGFwcGx5IGluaXRpYWwgc3R5bGUgcHJvcGVydGllc1xuICAgIHJvb3RcbiAgICAgIC5xdWVyeSgnR0VUX1NUWUxFUycpXG4gICAgICAuZmlsdGVyKGZ1bmN0aW9uKHN0eWxlKSB7XG4gICAgICAgIHJldHVybiAhaXNFbXB0eShzdHlsZS52YWx1ZSk7XG4gICAgICB9KVxuICAgICAgLm1hcChmdW5jdGlvbihfcmVmMikge1xuICAgICAgICB2YXIgbmFtZSA9IF9yZWYyLm5hbWUsXG4gICAgICAgICAgdmFsdWUgPSBfcmVmMi52YWx1ZTtcbiAgICAgICAgcm9vdC5lbGVtZW50LmRhdGFzZXRbbmFtZV0gPSB2YWx1ZTtcbiAgICAgIH0pO1xuXG4gICAgLy8gZGV0ZXJtaW5lIGlmIHdpZHRoIGNoYW5nZWRcbiAgICByb290LnJlZi53aWR0aFByZXZpb3VzID0gbnVsbDtcbiAgICByb290LnJlZi53aWR0aFVwZGF0ZWQgPSBkZWJvdW5jZShmdW5jdGlvbigpIHtcbiAgICAgIHJvb3QucmVmLnVwZGF0ZUhpc3RvcnkgPSBbXTtcbiAgICAgIHJvb3QuZGlzcGF0Y2goJ0RJRF9SRVNJWkVfUk9PVCcpO1xuICAgIH0sIDI1MCk7XG5cbiAgICAvLyBoaXN0b3J5IG9mIHVwZGF0ZXNcbiAgICByb290LnJlZi5wcmV2aW91c0FzcGVjdFJhdGlvID0gbnVsbDtcbiAgICByb290LnJlZi51cGRhdGVIaXN0b3J5ID0gW107XG5cbiAgICAvLyBwcmV2ZW50IHNjcm9sbGluZyBhbmQgem9vbWluZyBvbiBpT1MgKG9ubHkgaWYgc3VwcG9ydHMgcG9pbnRlciBldmVudHMsIGZvciB0aGVuIHdlIGNhbiBlbmFibGUgcmVvcmRlcilcbiAgICB2YXIgY2FuSG92ZXIgPSB3aW5kb3cubWF0Y2hNZWRpYSgnKHBvaW50ZXI6IGZpbmUpIGFuZCAoaG92ZXI6IGhvdmVyKScpXG4gICAgICAubWF0Y2hlcztcbiAgICB2YXIgaGFzUG9pbnRlckV2ZW50cyA9ICdQb2ludGVyRXZlbnQnIGluIHdpbmRvdztcbiAgICBpZiAocm9vdC5xdWVyeSgnR0VUX0FMTE9XX1JFT1JERVInKSAmJiBoYXNQb2ludGVyRXZlbnRzICYmICFjYW5Ib3Zlcikge1xuICAgICAgcm9vdC5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHByZXZlbnQsIHsgcGFzc2l2ZTogZmFsc2UgfSk7XG4gICAgICByb290LmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZ2VzdHVyZXN0YXJ0JywgcHJldmVudCk7XG4gICAgfVxuXG4gICAgLy8gYWRkIGNyZWRpdHNcbiAgICB2YXIgY3JlZGl0cyA9IHJvb3QucXVlcnkoJ0dFVF9DUkVESVRTJyk7XG4gICAgdmFyIGhhc0NyZWRpdHMgPSBjcmVkaXRzLmxlbmd0aCA9PT0gMjtcbiAgICBpZiAoaGFzQ3JlZGl0cykge1xuICAgICAgdmFyIGZyYWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgICBmcmFnLmNsYXNzTmFtZSA9ICdmaWxlcG9uZC0tY3JlZGl0cyc7XG4gICAgICBmcmFnLnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCAndHJ1ZScpO1xuICAgICAgZnJhZy5ocmVmID0gY3JlZGl0c1swXTtcbiAgICAgIGZyYWcudGFiaW5kZXggPSAtMTtcbiAgICAgIGZyYWcudGFyZ2V0ID0gJ19ibGFuayc7XG4gICAgICBmcmFnLnJlbCA9ICdub29wZW5lciBub3JlZmVycmVyJztcbiAgICAgIGZyYWcudGV4dENvbnRlbnQgPSBjcmVkaXRzWzFdO1xuICAgICAgcm9vdC5lbGVtZW50LmFwcGVuZENoaWxkKGZyYWcpO1xuICAgICAgcm9vdC5yZWYuY3JlZGl0cyA9IGZyYWc7XG4gICAgfVxuICB9O1xuXG4gIHZhciB3cml0ZSQ5ID0gZnVuY3Rpb24gd3JpdGUoX3JlZjMpIHtcbiAgICB2YXIgcm9vdCA9IF9yZWYzLnJvb3QsXG4gICAgICBwcm9wcyA9IF9yZWYzLnByb3BzLFxuICAgICAgYWN0aW9ucyA9IF9yZWYzLmFjdGlvbnM7XG5cbiAgICAvLyByb3V0ZSBhY3Rpb25zXG4gICAgcm91dGUkNSh7IHJvb3Q6IHJvb3QsIHByb3BzOiBwcm9wcywgYWN0aW9uczogYWN0aW9ucyB9KTtcblxuICAgIC8vIGFwcGx5IHN0eWxlIHByb3BlcnRpZXNcbiAgICBhY3Rpb25zXG4gICAgICAuZmlsdGVyKGZ1bmN0aW9uKGFjdGlvbikge1xuICAgICAgICByZXR1cm4gL15ESURfU0VUX1NUWUxFXy8udGVzdChhY3Rpb24udHlwZSk7XG4gICAgICB9KVxuICAgICAgLmZpbHRlcihmdW5jdGlvbihhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuICFpc0VtcHR5KGFjdGlvbi5kYXRhLnZhbHVlKTtcbiAgICAgIH0pXG4gICAgICAubWFwKGZ1bmN0aW9uKF9yZWY0KSB7XG4gICAgICAgIHZhciB0eXBlID0gX3JlZjQudHlwZSxcbiAgICAgICAgICBkYXRhID0gX3JlZjQuZGF0YTtcbiAgICAgICAgdmFyIG5hbWUgPSB0b0NhbWVscyh0eXBlLnN1YnN0cig4KS50b0xvd2VyQ2FzZSgpLCAnXycpO1xuICAgICAgICByb290LmVsZW1lbnQuZGF0YXNldFtuYW1lXSA9IGRhdGEudmFsdWU7XG4gICAgICAgIHJvb3QuaW52YWxpZGF0ZUxheW91dCgpO1xuICAgICAgfSk7XG5cbiAgICBpZiAocm9vdC5yZWN0LmVsZW1lbnQuaGlkZGVuKSByZXR1cm47XG5cbiAgICBpZiAocm9vdC5yZWN0LmVsZW1lbnQud2lkdGggIT09IHJvb3QucmVmLndpZHRoUHJldmlvdXMpIHtcbiAgICAgIHJvb3QucmVmLndpZHRoUHJldmlvdXMgPSByb290LnJlY3QuZWxlbWVudC53aWR0aDtcbiAgICAgIHJvb3QucmVmLndpZHRoVXBkYXRlZCgpO1xuICAgIH1cblxuICAgIC8vIGdldCBib3ggYm91bmRzLCB3ZSBkbyB0aGlzIG9ubHkgb25jZVxuICAgIHZhciBib3VuZHMgPSByb290LnJlZi5ib3VuZHM7XG4gICAgaWYgKCFib3VuZHMpIHtcbiAgICAgIGJvdW5kcyA9IHJvb3QucmVmLmJvdW5kcyA9IGNhbGN1bGF0ZVJvb3RCb3VuZGluZ0JveEhlaWdodChyb290KTtcblxuICAgICAgLy8gZGVzdHJveSBtZWFzdXJlIGVsZW1lbnRcbiAgICAgIHJvb3QuZWxlbWVudC5yZW1vdmVDaGlsZChyb290LnJlZi5tZWFzdXJlKTtcbiAgICAgIHJvb3QucmVmLm1lYXN1cmUgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIGdldCBxdWljayByZWZlcmVuY2VzIHRvIHZhcmlvdXMgaGlnaCBsZXZlbCBwYXJ0cyBvZiB0aGUgdXBsb2FkIHRvb2xcbiAgICB2YXIgX3Jvb3QkcmVmID0gcm9vdC5yZWYsXG4gICAgICBob3BwZXIgPSBfcm9vdCRyZWYuaG9wcGVyLFxuICAgICAgbGFiZWwgPSBfcm9vdCRyZWYubGFiZWwsXG4gICAgICBsaXN0ID0gX3Jvb3QkcmVmLmxpc3QsXG4gICAgICBwYW5lbCA9IF9yb290JHJlZi5wYW5lbDtcblxuICAgIC8vIHNldHMgY29ycmVjdCBzdGF0ZSB0byBob3BwZXIgc2NvcGVcbiAgICBpZiAoaG9wcGVyKSB7XG4gICAgICBob3BwZXIudXBkYXRlSG9wcGVyU3RhdGUoKTtcbiAgICB9XG5cbiAgICAvLyBib29sIHRvIGluZGljYXRlIGlmIHdlJ3JlIGZ1bGwgb3Igbm90XG4gICAgdmFyIGFzcGVjdFJhdGlvID0gcm9vdC5xdWVyeSgnR0VUX1BBTkVMX0FTUEVDVF9SQVRJTycpO1xuICAgIHZhciBpc011bHRpSXRlbSA9IHJvb3QucXVlcnkoJ0dFVF9BTExPV19NVUxUSVBMRScpO1xuICAgIHZhciB0b3RhbEl0ZW1zID0gcm9vdC5xdWVyeSgnR0VUX1RPVEFMX0lURU1TJyk7XG4gICAgdmFyIG1heEl0ZW1zID0gaXNNdWx0aUl0ZW1cbiAgICAgID8gcm9vdC5xdWVyeSgnR0VUX01BWF9GSUxFUycpIHx8IE1BWF9GSUxFU19MSU1JVFxuICAgICAgOiAxO1xuICAgIHZhciBhdE1heENhcGFjaXR5ID0gdG90YWxJdGVtcyA9PT0gbWF4SXRlbXM7XG5cbiAgICAvLyBhY3Rpb24gdXNlZCB0byBhZGQgaXRlbVxuICAgIHZhciBhZGRBY3Rpb24gPSBhY3Rpb25zLmZpbmQoZnVuY3Rpb24oYWN0aW9uKSB7XG4gICAgICByZXR1cm4gYWN0aW9uLnR5cGUgPT09ICdESURfQUREX0lURU0nO1xuICAgIH0pO1xuXG4gICAgLy8gaWYgcmVhY2hlZCBtYXggY2FwYWNpdHkgYW5kIHdlJ3ZlIGp1c3QgcmVhY2hlZCBpdFxuICAgIGlmIChhdE1heENhcGFjaXR5ICYmIGFkZEFjdGlvbikge1xuICAgICAgLy8gZ2V0IGludGVyYWN0aW9uIHR5cGVcbiAgICAgIHZhciBpbnRlcmFjdGlvbk1ldGhvZCA9IGFkZEFjdGlvbi5kYXRhLmludGVyYWN0aW9uTWV0aG9kO1xuXG4gICAgICAvLyBoaWRlIGxhYmVsXG4gICAgICBsYWJlbC5vcGFjaXR5ID0gMDtcblxuICAgICAgaWYgKGlzTXVsdGlJdGVtKSB7XG4gICAgICAgIGxhYmVsLnRyYW5zbGF0ZVkgPSAtNDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaW50ZXJhY3Rpb25NZXRob2QgPT09IEludGVyYWN0aW9uTWV0aG9kLkFQSSkge1xuICAgICAgICAgIGxhYmVsLnRyYW5zbGF0ZVggPSA0MDtcbiAgICAgICAgfSBlbHNlIGlmIChpbnRlcmFjdGlvbk1ldGhvZCA9PT0gSW50ZXJhY3Rpb25NZXRob2QuQlJPV1NFKSB7XG4gICAgICAgICAgbGFiZWwudHJhbnNsYXRlWSA9IDQwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxhYmVsLnRyYW5zbGF0ZVkgPSAzMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWF0TWF4Q2FwYWNpdHkpIHtcbiAgICAgIGxhYmVsLm9wYWNpdHkgPSAxO1xuICAgICAgbGFiZWwudHJhbnNsYXRlWCA9IDA7XG4gICAgICBsYWJlbC50cmFuc2xhdGVZID0gMDtcbiAgICB9XG5cbiAgICB2YXIgbGlzdEl0ZW1NYXJnaW4gPSBjYWxjdWxhdGVMaXN0SXRlbU1hcmdpbihyb290KTtcblxuICAgIHZhciBsaXN0SGVpZ2h0ID0gY2FsY3VsYXRlTGlzdEhlaWdodChyb290KTtcblxuICAgIHZhciBsYWJlbEhlaWdodCA9IGxhYmVsLnJlY3QuZWxlbWVudC5oZWlnaHQ7XG4gICAgdmFyIGN1cnJlbnRMYWJlbEhlaWdodCA9ICFpc011bHRpSXRlbSB8fCBhdE1heENhcGFjaXR5ID8gMCA6IGxhYmVsSGVpZ2h0O1xuXG4gICAgdmFyIGxpc3RNYXJnaW5Ub3AgPSBhdE1heENhcGFjaXR5ID8gbGlzdC5yZWN0LmVsZW1lbnQubWFyZ2luVG9wIDogMDtcbiAgICB2YXIgbGlzdE1hcmdpbkJvdHRvbSA9XG4gICAgICB0b3RhbEl0ZW1zID09PSAwID8gMCA6IGxpc3QucmVjdC5lbGVtZW50Lm1hcmdpbkJvdHRvbTtcblxuICAgIHZhciB2aXN1YWxIZWlnaHQgPVxuICAgICAgY3VycmVudExhYmVsSGVpZ2h0ICsgbGlzdE1hcmdpblRvcCArIGxpc3RIZWlnaHQudmlzdWFsICsgbGlzdE1hcmdpbkJvdHRvbTtcbiAgICB2YXIgYm91bmRzSGVpZ2h0ID1cbiAgICAgIGN1cnJlbnRMYWJlbEhlaWdodCArIGxpc3RNYXJnaW5Ub3AgKyBsaXN0SGVpZ2h0LmJvdW5kcyArIGxpc3RNYXJnaW5Cb3R0b207XG5cbiAgICAvLyBsaW5rIGxpc3QgdG8gbGFiZWwgYm90dG9tIHBvc2l0aW9uXG4gICAgbGlzdC50cmFuc2xhdGVZID1cbiAgICAgIE1hdGgubWF4KDAsIGN1cnJlbnRMYWJlbEhlaWdodCAtIGxpc3QucmVjdC5lbGVtZW50Lm1hcmdpblRvcCkgLVxuICAgICAgbGlzdEl0ZW1NYXJnaW4udG9wO1xuXG4gICAgaWYgKGFzcGVjdFJhdGlvKSB7XG4gICAgICAvLyBmaXhlZCBhc3BlY3QgcmF0aW9cblxuICAgICAgLy8gY2FsY3VsYXRlIGhlaWdodCBiYXNlZCBvbiB3aWR0aFxuICAgICAgdmFyIHdpZHRoID0gcm9vdC5yZWN0LmVsZW1lbnQud2lkdGg7XG4gICAgICB2YXIgaGVpZ2h0ID0gd2lkdGggKiBhc3BlY3RSYXRpbztcblxuICAgICAgLy8gY2xlYXIgaGlzdG9yeSBpZiBhc3BlY3QgcmF0aW8gaGFzIGNoYW5nZWRcbiAgICAgIGlmIChhc3BlY3RSYXRpbyAhPT0gcm9vdC5yZWYucHJldmlvdXNBc3BlY3RSYXRpbykge1xuICAgICAgICByb290LnJlZi5wcmV2aW91c0FzcGVjdFJhdGlvID0gYXNwZWN0UmF0aW87XG4gICAgICAgIHJvb3QucmVmLnVwZGF0ZUhpc3RvcnkgPSBbXTtcbiAgICAgIH1cblxuICAgICAgLy8gcmVtZW1iZXIgdGhpcyB3aWR0aFxuICAgICAgdmFyIGhpc3RvcnkgPSByb290LnJlZi51cGRhdGVIaXN0b3J5O1xuICAgICAgaGlzdG9yeS5wdXNoKHdpZHRoKTtcblxuICAgICAgdmFyIE1BWF9CT1VOQ0VTID0gMjtcbiAgICAgIGlmIChoaXN0b3J5Lmxlbmd0aCA+IE1BWF9CT1VOQ0VTICogMikge1xuICAgICAgICB2YXIgbCA9IGhpc3RvcnkubGVuZ3RoO1xuICAgICAgICB2YXIgYm90dG9tID0gbCAtIDEwO1xuICAgICAgICB2YXIgYm91bmNlcyA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSBsOyBpID49IGJvdHRvbTsgaS0tKSB7XG4gICAgICAgICAgaWYgKGhpc3RvcnlbaV0gPT09IGhpc3RvcnlbaSAtIDJdKSB7XG4gICAgICAgICAgICBib3VuY2VzKys7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGJvdW5jZXMgPj0gTUFYX0JPVU5DRVMpIHtcbiAgICAgICAgICAgIC8vIGRvbnQgYWRqdXN0IGhlaWdodFxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBmaXggaGVpZ2h0IG9mIHBhbmVsIHNvIGl0IGFkaGVyZXMgdG8gYXNwZWN0IHJhdGlvXG4gICAgICBwYW5lbC5zY2FsYWJsZSA9IGZhbHNlO1xuICAgICAgcGFuZWwuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgICAvLyBhdmFpbGFibGUgaGVpZ2h0IGZvciBsaXN0XG4gICAgICB2YXIgbGlzdEF2YWlsYWJsZUhlaWdodCA9XG4gICAgICAgIC8vIHRoZSBoZWlnaHQgb2YgdGhlIHBhbmVsIG1pbnVzIHRoZSBsYWJlbCBoZWlnaHRcbiAgICAgICAgaGVpZ2h0IC1cbiAgICAgICAgY3VycmVudExhYmVsSGVpZ2h0IC1cbiAgICAgICAgLy8gdGhlIHJvb20gd2UgbGVhdmUgb3BlbiBiZXR3ZWVuIHRoZSBlbmQgb2YgdGhlIGxpc3QgYW5kIHRoZSBwYW5lbCBib3R0b21cbiAgICAgICAgKGxpc3RNYXJnaW5Cb3R0b20gLSBsaXN0SXRlbU1hcmdpbi5ib3R0b20pIC1cbiAgICAgICAgLy8gaWYgd2UncmUgZnVsbCB3ZSBuZWVkIHRvIGxlYXZlIHNvbWUgcm9vbSBiZXR3ZWVuIHRoZSB0b3Agb2YgdGhlIHBhbmVsIGFuZCB0aGUgbGlzdFxuICAgICAgICAoYXRNYXhDYXBhY2l0eSA/IGxpc3RNYXJnaW5Ub3AgOiAwKTtcblxuICAgICAgaWYgKGxpc3RIZWlnaHQudmlzdWFsID4gbGlzdEF2YWlsYWJsZUhlaWdodCkge1xuICAgICAgICBsaXN0Lm92ZXJmbG93ID0gbGlzdEF2YWlsYWJsZUhlaWdodDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpc3Qub3ZlcmZsb3cgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICAvLyBzZXQgY29udGFpbmVyIGJvdW5kcyAoc28gcHVzaGVzIHNpYmxpbmdzIGRvd253YXJkcylcbiAgICAgIHJvb3QuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIH0gZWxzZSBpZiAoYm91bmRzLmZpeGVkSGVpZ2h0KSB7XG4gICAgICAvLyBmaXhlZCBoZWlnaHRcblxuICAgICAgLy8gZml4IGhlaWdodCBvZiBwYW5lbFxuICAgICAgcGFuZWwuc2NhbGFibGUgPSBmYWxzZTtcblxuICAgICAgLy8gYXZhaWxhYmxlIGhlaWdodCBmb3IgbGlzdFxuICAgICAgdmFyIF9saXN0QXZhaWxhYmxlSGVpZ2h0ID1cbiAgICAgICAgLy8gdGhlIGhlaWdodCBvZiB0aGUgcGFuZWwgbWludXMgdGhlIGxhYmVsIGhlaWdodFxuICAgICAgICBib3VuZHMuZml4ZWRIZWlnaHQgLVxuICAgICAgICBjdXJyZW50TGFiZWxIZWlnaHQgLVxuICAgICAgICAvLyB0aGUgcm9vbSB3ZSBsZWF2ZSBvcGVuIGJldHdlZW4gdGhlIGVuZCBvZiB0aGUgbGlzdCBhbmQgdGhlIHBhbmVsIGJvdHRvbVxuICAgICAgICAobGlzdE1hcmdpbkJvdHRvbSAtIGxpc3RJdGVtTWFyZ2luLmJvdHRvbSkgLVxuICAgICAgICAvLyBpZiB3ZSdyZSBmdWxsIHdlIG5lZWQgdG8gbGVhdmUgc29tZSByb29tIGJldHdlZW4gdGhlIHRvcCBvZiB0aGUgcGFuZWwgYW5kIHRoZSBsaXN0XG4gICAgICAgIChhdE1heENhcGFjaXR5ID8gbGlzdE1hcmdpblRvcCA6IDApO1xuXG4gICAgICAvLyBzZXQgbGlzdCBoZWlnaHRcbiAgICAgIGlmIChsaXN0SGVpZ2h0LnZpc3VhbCA+IF9saXN0QXZhaWxhYmxlSGVpZ2h0KSB7XG4gICAgICAgIGxpc3Qub3ZlcmZsb3cgPSBfbGlzdEF2YWlsYWJsZUhlaWdodDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpc3Qub3ZlcmZsb3cgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICAvLyBubyBuZWVkIHRvIHNldCBjb250YWluZXIgYm91bmRzIGFzIHRoZXNlIGFyZSBoYW5kbGVzIGJ5IENTUyBmaXhlZCBoZWlnaHRcbiAgICB9IGVsc2UgaWYgKGJvdW5kcy5jYXBwZWRIZWlnaHQpIHtcbiAgICAgIC8vIG1heC1oZWlnaHRcblxuICAgICAgLy8gbm90IGEgZml4ZWQgaGVpZ2h0IHBhbmVsXG4gICAgICB2YXIgaXNDYXBwZWRIZWlnaHQgPSB2aXN1YWxIZWlnaHQgPj0gYm91bmRzLmNhcHBlZEhlaWdodDtcbiAgICAgIHZhciBwYW5lbEhlaWdodCA9IE1hdGgubWluKGJvdW5kcy5jYXBwZWRIZWlnaHQsIHZpc3VhbEhlaWdodCk7XG4gICAgICBwYW5lbC5zY2FsYWJsZSA9IHRydWU7XG4gICAgICBwYW5lbC5oZWlnaHQgPSBpc0NhcHBlZEhlaWdodFxuICAgICAgICA/IHBhbmVsSGVpZ2h0XG4gICAgICAgIDogcGFuZWxIZWlnaHQgLSBsaXN0SXRlbU1hcmdpbi50b3AgLSBsaXN0SXRlbU1hcmdpbi5ib3R0b207XG5cbiAgICAgIC8vIGF2YWlsYWJsZSBoZWlnaHQgZm9yIGxpc3RcbiAgICAgIHZhciBfbGlzdEF2YWlsYWJsZUhlaWdodDIgPVxuICAgICAgICAvLyB0aGUgaGVpZ2h0IG9mIHRoZSBwYW5lbCBtaW51cyB0aGUgbGFiZWwgaGVpZ2h0XG4gICAgICAgIHBhbmVsSGVpZ2h0IC1cbiAgICAgICAgY3VycmVudExhYmVsSGVpZ2h0IC1cbiAgICAgICAgLy8gdGhlIHJvb20gd2UgbGVhdmUgb3BlbiBiZXR3ZWVuIHRoZSBlbmQgb2YgdGhlIGxpc3QgYW5kIHRoZSBwYW5lbCBib3R0b21cbiAgICAgICAgKGxpc3RNYXJnaW5Cb3R0b20gLSBsaXN0SXRlbU1hcmdpbi5ib3R0b20pIC1cbiAgICAgICAgLy8gaWYgd2UncmUgZnVsbCB3ZSBuZWVkIHRvIGxlYXZlIHNvbWUgcm9vbSBiZXR3ZWVuIHRoZSB0b3Agb2YgdGhlIHBhbmVsIGFuZCB0aGUgbGlzdFxuICAgICAgICAoYXRNYXhDYXBhY2l0eSA/IGxpc3RNYXJnaW5Ub3AgOiAwKTtcblxuICAgICAgLy8gc2V0IGxpc3QgaGVpZ2h0IChpZiBpcyBvdmVyZmxvd2luZylcbiAgICAgIGlmIChcbiAgICAgICAgdmlzdWFsSGVpZ2h0ID4gYm91bmRzLmNhcHBlZEhlaWdodCAmJlxuICAgICAgICBsaXN0SGVpZ2h0LnZpc3VhbCA+IF9saXN0QXZhaWxhYmxlSGVpZ2h0MlxuICAgICAgKSB7XG4gICAgICAgIGxpc3Qub3ZlcmZsb3cgPSBfbGlzdEF2YWlsYWJsZUhlaWdodDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaXN0Lm92ZXJmbG93ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLy8gc2V0IGNvbnRhaW5lciBib3VuZHMgKHNvIHB1c2hlcyBzaWJsaW5ncyBkb3dud2FyZHMpXG4gICAgICByb290LmhlaWdodCA9IE1hdGgubWluKFxuICAgICAgICBib3VuZHMuY2FwcGVkSGVpZ2h0LFxuICAgICAgICBib3VuZHNIZWlnaHQgLSBsaXN0SXRlbU1hcmdpbi50b3AgLSBsaXN0SXRlbU1hcmdpbi5ib3R0b21cbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGZsZXhpYmxlIGhlaWdodFxuXG4gICAgICAvLyBub3QgYSBmaXhlZCBoZWlnaHQgcGFuZWxcbiAgICAgIHZhciBpdGVtTWFyZ2luID1cbiAgICAgICAgdG90YWxJdGVtcyA+IDAgPyBsaXN0SXRlbU1hcmdpbi50b3AgKyBsaXN0SXRlbU1hcmdpbi5ib3R0b20gOiAwO1xuICAgICAgcGFuZWwuc2NhbGFibGUgPSB0cnVlO1xuICAgICAgcGFuZWwuaGVpZ2h0ID0gTWF0aC5tYXgobGFiZWxIZWlnaHQsIHZpc3VhbEhlaWdodCAtIGl0ZW1NYXJnaW4pO1xuXG4gICAgICAvLyBzZXQgY29udGFpbmVyIGJvdW5kcyAoc28gcHVzaGVzIHNpYmxpbmdzIGRvd253YXJkcylcbiAgICAgIHJvb3QuaGVpZ2h0ID0gTWF0aC5tYXgobGFiZWxIZWlnaHQsIGJvdW5kc0hlaWdodCAtIGl0ZW1NYXJnaW4pO1xuICAgIH1cblxuICAgIC8vIG1vdmUgY3JlZGl0cyB0byBib3R0b21cbiAgICBpZiAocm9vdC5yZWYuY3JlZGl0cyAmJiBwYW5lbC5oZWlnaHRDdXJyZW50KVxuICAgICAgcm9vdC5yZWYuY3JlZGl0cy5zdHlsZS50cmFuc2Zvcm0gPVxuICAgICAgICAndHJhbnNsYXRlWSgnICsgcGFuZWwuaGVpZ2h0Q3VycmVudCArICdweCknO1xuICB9O1xuXG4gIHZhciBjYWxjdWxhdGVMaXN0SXRlbU1hcmdpbiA9IGZ1bmN0aW9uIGNhbGN1bGF0ZUxpc3RJdGVtTWFyZ2luKHJvb3QpIHtcbiAgICB2YXIgaXRlbSA9IHJvb3QucmVmLmxpc3QuY2hpbGRWaWV3c1swXS5jaGlsZFZpZXdzWzBdO1xuICAgIHJldHVybiBpdGVtXG4gICAgICA/IHtcbiAgICAgICAgICB0b3A6IGl0ZW0ucmVjdC5lbGVtZW50Lm1hcmdpblRvcCxcbiAgICAgICAgICBib3R0b206IGl0ZW0ucmVjdC5lbGVtZW50Lm1hcmdpbkJvdHRvbVxuICAgICAgICB9XG4gICAgICA6IHtcbiAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgYm90dG9tOiAwXG4gICAgICAgIH07XG4gIH07XG5cbiAgdmFyIGNhbGN1bGF0ZUxpc3RIZWlnaHQgPSBmdW5jdGlvbiBjYWxjdWxhdGVMaXN0SGVpZ2h0KHJvb3QpIHtcbiAgICB2YXIgdmlzdWFsID0gMDtcbiAgICB2YXIgYm91bmRzID0gMDtcblxuICAgIC8vIGdldCBmaWxlIGxpc3QgcmVmZXJlbmNlXG4gICAgdmFyIHNjcm9sbExpc3QgPSByb290LnJlZi5saXN0O1xuICAgIHZhciBpdGVtTGlzdCA9IHNjcm9sbExpc3QuY2hpbGRWaWV3c1swXTtcbiAgICB2YXIgdmlzaWJsZUNoaWxkcmVuID0gaXRlbUxpc3QuY2hpbGRWaWV3cy5maWx0ZXIoZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgIHJldHVybiBjaGlsZC5yZWN0LmVsZW1lbnQuaGVpZ2h0O1xuICAgIH0pO1xuICAgIHZhciBjaGlsZHJlbiA9IHJvb3RcbiAgICAgIC5xdWVyeSgnR0VUX0FDVElWRV9JVEVNUycpXG4gICAgICAubWFwKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIHZpc2libGVDaGlsZHJlbi5maW5kKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgICAgcmV0dXJuIGNoaWxkLmlkID09PSBpdGVtLmlkO1xuICAgICAgICB9KTtcbiAgICAgIH0pXG4gICAgICAuZmlsdGVyKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICB9KTtcblxuICAgIC8vIG5vIGNoaWxkcmVuLCBkb25lIVxuICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPT09IDApIHJldHVybiB7IHZpc3VhbDogdmlzdWFsLCBib3VuZHM6IGJvdW5kcyB9O1xuXG4gICAgdmFyIGhvcml6b250YWxTcGFjZSA9IGl0ZW1MaXN0LnJlY3QuZWxlbWVudC53aWR0aDtcbiAgICB2YXIgZHJhZ0luZGV4ID0gZ2V0SXRlbUluZGV4QnlQb3NpdGlvbihcbiAgICAgIGl0ZW1MaXN0LFxuICAgICAgY2hpbGRyZW4sXG4gICAgICBzY3JvbGxMaXN0LmRyYWdDb29yZGluYXRlc1xuICAgICk7XG5cbiAgICB2YXIgY2hpbGRSZWN0ID0gY2hpbGRyZW5bMF0ucmVjdC5lbGVtZW50O1xuXG4gICAgdmFyIGl0ZW1WZXJ0aWNhbE1hcmdpbiA9IGNoaWxkUmVjdC5tYXJnaW5Ub3AgKyBjaGlsZFJlY3QubWFyZ2luQm90dG9tO1xuICAgIHZhciBpdGVtSG9yaXpvbnRhbE1hcmdpbiA9IGNoaWxkUmVjdC5tYXJnaW5MZWZ0ICsgY2hpbGRSZWN0Lm1hcmdpblJpZ2h0O1xuXG4gICAgdmFyIGl0ZW1XaWR0aCA9IGNoaWxkUmVjdC53aWR0aCArIGl0ZW1Ib3Jpem9udGFsTWFyZ2luO1xuICAgIHZhciBpdGVtSGVpZ2h0ID0gY2hpbGRSZWN0LmhlaWdodCArIGl0ZW1WZXJ0aWNhbE1hcmdpbjtcblxuICAgIHZhciBuZXdJdGVtID0gdHlwZW9mIGRyYWdJbmRleCAhPT0gJ3VuZGVmaW5lZCcgJiYgZHJhZ0luZGV4ID49IDAgPyAxIDogMDtcbiAgICB2YXIgcmVtb3ZlZEl0ZW0gPSBjaGlsZHJlbi5maW5kKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICByZXR1cm4gY2hpbGQubWFya2VkRm9yUmVtb3ZhbCAmJiBjaGlsZC5vcGFjaXR5IDwgMC40NTtcbiAgICB9KVxuICAgICAgPyAtMVxuICAgICAgOiAwO1xuICAgIHZhciB2ZXJ0aWNhbEl0ZW1Db3VudCA9IGNoaWxkcmVuLmxlbmd0aCArIG5ld0l0ZW0gKyByZW1vdmVkSXRlbTtcbiAgICB2YXIgaXRlbXNQZXJSb3cgPSBNYXRoLnJvdW5kKGhvcml6b250YWxTcGFjZSAvIGl0ZW1XaWR0aCk7XG5cbiAgICAvLyBzdGFja1xuICAgIGlmIChpdGVtc1BlclJvdyA9PT0gMSkge1xuICAgICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgIHZhciBoZWlnaHQgPSBpdGVtLnJlY3QuZWxlbWVudC5oZWlnaHQgKyBpdGVtVmVydGljYWxNYXJnaW47XG4gICAgICAgIGJvdW5kcyArPSBoZWlnaHQ7XG4gICAgICAgIHZpc3VhbCArPSBoZWlnaHQgKiBpdGVtLm9wYWNpdHk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLy8gZ3JpZFxuICAgIGVsc2Uge1xuICAgICAgYm91bmRzID0gTWF0aC5jZWlsKHZlcnRpY2FsSXRlbUNvdW50IC8gaXRlbXNQZXJSb3cpICogaXRlbUhlaWdodDtcbiAgICAgIHZpc3VhbCA9IGJvdW5kcztcbiAgICB9XG5cbiAgICByZXR1cm4geyB2aXN1YWw6IHZpc3VhbCwgYm91bmRzOiBib3VuZHMgfTtcbiAgfTtcblxuICB2YXIgY2FsY3VsYXRlUm9vdEJvdW5kaW5nQm94SGVpZ2h0ID0gZnVuY3Rpb24gY2FsY3VsYXRlUm9vdEJvdW5kaW5nQm94SGVpZ2h0KFxuICAgIHJvb3RcbiAgKSB7XG4gICAgdmFyIGhlaWdodCA9IHJvb3QucmVmLm1lYXN1cmVIZWlnaHQgfHwgbnVsbDtcbiAgICB2YXIgY2FwcGVkSGVpZ2h0ID0gcGFyc2VJbnQocm9vdC5zdHlsZS5tYXhIZWlnaHQsIDEwKSB8fCBudWxsO1xuICAgIHZhciBmaXhlZEhlaWdodCA9IGhlaWdodCA9PT0gMCA/IG51bGwgOiBoZWlnaHQ7XG5cbiAgICByZXR1cm4ge1xuICAgICAgY2FwcGVkSGVpZ2h0OiBjYXBwZWRIZWlnaHQsXG4gICAgICBmaXhlZEhlaWdodDogZml4ZWRIZWlnaHRcbiAgICB9O1xuICB9O1xuXG4gIHZhciBleGNlZWRzTWF4RmlsZXMgPSBmdW5jdGlvbiBleGNlZWRzTWF4RmlsZXMocm9vdCwgaXRlbXMpIHtcbiAgICB2YXIgYWxsb3dSZXBsYWNlID0gcm9vdC5xdWVyeSgnR0VUX0FMTE9XX1JFUExBQ0UnKTtcbiAgICB2YXIgYWxsb3dNdWx0aXBsZSA9IHJvb3QucXVlcnkoJ0dFVF9BTExPV19NVUxUSVBMRScpO1xuICAgIHZhciB0b3RhbEl0ZW1zID0gcm9vdC5xdWVyeSgnR0VUX1RPVEFMX0lURU1TJyk7XG4gICAgdmFyIG1heEl0ZW1zID0gcm9vdC5xdWVyeSgnR0VUX01BWF9GSUxFUycpO1xuXG4gICAgLy8gdG90YWwgYW1vdW50IG9mIGl0ZW1zIGJlaW5nIGRyYWdnZWRcbiAgICB2YXIgdG90YWxCcm93c2VJdGVtcyA9IGl0ZW1zLmxlbmd0aDtcblxuICAgIC8vIGlmIGRvZXMgbm90IGFsbG93IG11bHRpcGxlIGl0ZW1zIGFuZCBkcmFnZ2luZyBtb3JlIHRoYW4gb25lIGl0ZW1cbiAgICBpZiAoIWFsbG93TXVsdGlwbGUgJiYgdG90YWxCcm93c2VJdGVtcyA+IDEpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIGxpbWl0IG1heCBpdGVtcyB0byBvbmUgaWYgbm90IGFsbG93ZWQgdG8gZHJvcCBtdWx0aXBsZSBpdGVtc1xuICAgIG1heEl0ZW1zID0gYWxsb3dNdWx0aXBsZSA/IG1heEl0ZW1zIDogYWxsb3dSZXBsYWNlID8gbWF4SXRlbXMgOiAxO1xuXG4gICAgLy8gbm8gbW9yZSByb29tP1xuICAgIHZhciBoYXNNYXhJdGVtcyA9IGlzSW50KG1heEl0ZW1zKTtcbiAgICBpZiAoaGFzTWF4SXRlbXMgJiYgdG90YWxJdGVtcyArIHRvdGFsQnJvd3NlSXRlbXMgPiBtYXhJdGVtcykge1xuICAgICAgcm9vdC5kaXNwYXRjaCgnRElEX1RIUk9XX01BWF9GSUxFUycsIHtcbiAgICAgICAgc291cmNlOiBpdGVtcyxcbiAgICAgICAgZXJyb3I6IGNyZWF0ZVJlc3BvbnNlKCd3YXJuaW5nJywgMCwgJ01heCBmaWxlcycpXG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIHZhciBnZXREcmFnSW5kZXggPSBmdW5jdGlvbiBnZXREcmFnSW5kZXgobGlzdCwgY2hpbGRyZW4sIHBvc2l0aW9uKSB7XG4gICAgdmFyIGl0ZW1MaXN0ID0gbGlzdC5jaGlsZFZpZXdzWzBdO1xuICAgIHJldHVybiBnZXRJdGVtSW5kZXhCeVBvc2l0aW9uKGl0ZW1MaXN0LCBjaGlsZHJlbiwge1xuICAgICAgbGVmdDogcG9zaXRpb24uc2NvcGVMZWZ0IC0gaXRlbUxpc3QucmVjdC5lbGVtZW50LmxlZnQsXG4gICAgICB0b3A6XG4gICAgICAgIHBvc2l0aW9uLnNjb3BlVG9wIC1cbiAgICAgICAgKGxpc3QucmVjdC5vdXRlci50b3AgK1xuICAgICAgICAgIGxpc3QucmVjdC5lbGVtZW50Lm1hcmdpblRvcCArXG4gICAgICAgICAgbGlzdC5yZWN0LmVsZW1lbnQuc2Nyb2xsVG9wKVxuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBFbmFibGUgb3IgZGlzYWJsZSBmaWxlIGRyb3AgZnVuY3Rpb25hbGl0eVxuICAgKi9cbiAgdmFyIHRvZ2dsZURyb3AgPSBmdW5jdGlvbiB0b2dnbGVEcm9wKHJvb3QpIHtcbiAgICB2YXIgaXNBbGxvd2VkID0gcm9vdC5xdWVyeSgnR0VUX0FMTE9XX0RST1AnKTtcbiAgICB2YXIgaXNEaXNhYmxlZCA9IHJvb3QucXVlcnkoJ0dFVF9ESVNBQkxFRCcpO1xuICAgIHZhciBlbmFibGVkID0gaXNBbGxvd2VkICYmICFpc0Rpc2FibGVkO1xuICAgIGlmIChlbmFibGVkICYmICFyb290LnJlZi5ob3BwZXIpIHtcbiAgICAgIHZhciBob3BwZXIgPSBjcmVhdGVIb3BwZXIoXG4gICAgICAgIHJvb3QuZWxlbWVudCxcbiAgICAgICAgZnVuY3Rpb24oaXRlbXMpIHtcbiAgICAgICAgICAvLyBhbGxvdyBxdWljayB2YWxpZGF0aW9uIG9mIGRyb3BwZWQgaXRlbXNcbiAgICAgICAgICB2YXIgYmVmb3JlRHJvcEZpbGUgPVxuICAgICAgICAgICAgcm9vdC5xdWVyeSgnR0VUX0JFRk9SRV9EUk9QX0ZJTEUnKSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgIC8vIGFsbCBpdGVtcyBzaG91bGQgYmUgdmFsaWRhdGVkIGJ5IGFsbCBmaWx0ZXJzIGFzIHZhbGlkXG4gICAgICAgICAgdmFyIGRyb3BWYWxpZGF0aW9uID0gcm9vdC5xdWVyeSgnR0VUX0RST1BfVkFMSURBVElPTicpO1xuICAgICAgICAgIHJldHVybiBkcm9wVmFsaWRhdGlvblxuICAgICAgICAgICAgPyBpdGVtcy5ldmVyeShmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgIGFwcGx5RmlsdGVycygnQUxMT1dfSE9QUEVSX0lURU0nLCBpdGVtLCB7XG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiByb290LnF1ZXJ5XG4gICAgICAgICAgICAgICAgICB9KS5ldmVyeShmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIH0pICYmIGJlZm9yZURyb3BGaWxlKGl0ZW0pXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIDogdHJ1ZTtcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGZpbHRlckl0ZW1zOiBmdW5jdGlvbiBmaWx0ZXJJdGVtcyhpdGVtcykge1xuICAgICAgICAgICAgdmFyIGlnbm9yZWRGaWxlcyA9IHJvb3QucXVlcnkoJ0dFVF9JR05PUkVEX0ZJTEVTJyk7XG4gICAgICAgICAgICByZXR1cm4gaXRlbXMuZmlsdGVyKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgaWYgKGlzRmlsZShpdGVtKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAhaWdub3JlZEZpbGVzLmluY2x1ZGVzKGl0ZW0ubmFtZS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgY2F0Y2hlc0Ryb3BzT25QYWdlOiByb290LnF1ZXJ5KCdHRVRfRFJPUF9PTl9QQUdFJyksXG4gICAgICAgICAgcmVxdWlyZXNEcm9wT25FbGVtZW50OiByb290LnF1ZXJ5KCdHRVRfRFJPUF9PTl9FTEVNRU5UJylcbiAgICAgICAgfVxuICAgICAgKTtcblxuICAgICAgaG9wcGVyLm9ubG9hZCA9IGZ1bmN0aW9uKGl0ZW1zLCBwb3NpdGlvbikge1xuICAgICAgICAvLyBnZXQgaXRlbSBjaGlsZHJlbiBlbGVtZW50cyBhbmQgc29ydCBiYXNlZCBvbiBsaXN0IHNvcnRcbiAgICAgICAgdmFyIGxpc3QgPSByb290LnJlZi5saXN0LmNoaWxkVmlld3NbMF07XG4gICAgICAgIHZhciB2aXNpYmxlQ2hpbGRyZW4gPSBsaXN0LmNoaWxkVmlld3MuZmlsdGVyKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgICAgcmV0dXJuIGNoaWxkLnJlY3QuZWxlbWVudC5oZWlnaHQ7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSByb290XG4gICAgICAgICAgLnF1ZXJ5KCdHRVRfQUNUSVZFX0lURU1TJylcbiAgICAgICAgICAubWFwKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybiB2aXNpYmxlQ2hpbGRyZW4uZmluZChmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICAgICAgICByZXR1cm4gY2hpbGQuaWQgPT09IGl0ZW0uaWQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgYXBwbHlGaWx0ZXJDaGFpbignQUREX0lURU1TJywgaXRlbXMsIHsgZGlzcGF0Y2g6IHJvb3QuZGlzcGF0Y2ggfSkudGhlbihcbiAgICAgICAgICBmdW5jdGlvbihxdWV1ZSkge1xuICAgICAgICAgICAgLy8gdGhlc2UgZmlsZXMgZG9uJ3QgZml0IHNvIHN0b3AgaGVyZVxuICAgICAgICAgICAgaWYgKGV4Y2VlZHNNYXhGaWxlcyhyb290LCBxdWV1ZSkpIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgLy8gZ29cbiAgICAgICAgICAgIHJvb3QuZGlzcGF0Y2goJ0FERF9JVEVNUycsIHtcbiAgICAgICAgICAgICAgaXRlbXM6IHF1ZXVlLFxuICAgICAgICAgICAgICBpbmRleDogZ2V0RHJhZ0luZGV4KHJvb3QucmVmLmxpc3QsIGNoaWxkcmVuLCBwb3NpdGlvbiksXG4gICAgICAgICAgICAgIGludGVyYWN0aW9uTWV0aG9kOiBJbnRlcmFjdGlvbk1ldGhvZC5EUk9QXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICk7XG5cbiAgICAgICAgcm9vdC5kaXNwYXRjaCgnRElEX0RST1AnLCB7IHBvc2l0aW9uOiBwb3NpdGlvbiB9KTtcblxuICAgICAgICByb290LmRpc3BhdGNoKCdESURfRU5EX0RSQUcnLCB7IHBvc2l0aW9uOiBwb3NpdGlvbiB9KTtcbiAgICAgIH07XG5cbiAgICAgIGhvcHBlci5vbmRyYWdzdGFydCA9IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XG4gICAgICAgIHJvb3QuZGlzcGF0Y2goJ0RJRF9TVEFSVF9EUkFHJywgeyBwb3NpdGlvbjogcG9zaXRpb24gfSk7XG4gICAgICB9O1xuXG4gICAgICBob3BwZXIub25kcmFnID0gZGVib3VuY2UoZnVuY3Rpb24ocG9zaXRpb24pIHtcbiAgICAgICAgcm9vdC5kaXNwYXRjaCgnRElEX0RSQUcnLCB7IHBvc2l0aW9uOiBwb3NpdGlvbiB9KTtcbiAgICAgIH0pO1xuXG4gICAgICBob3BwZXIub25kcmFnZW5kID0gZnVuY3Rpb24ocG9zaXRpb24pIHtcbiAgICAgICAgcm9vdC5kaXNwYXRjaCgnRElEX0VORF9EUkFHJywgeyBwb3NpdGlvbjogcG9zaXRpb24gfSk7XG4gICAgICB9O1xuXG4gICAgICByb290LnJlZi5ob3BwZXIgPSBob3BwZXI7XG5cbiAgICAgIHJvb3QucmVmLmRyaXAgPSByb290LmFwcGVuZENoaWxkVmlldyhyb290LmNyZWF0ZUNoaWxkVmlldyhkcmlwKSk7XG4gICAgfSBlbHNlIGlmICghZW5hYmxlZCAmJiByb290LnJlZi5ob3BwZXIpIHtcbiAgICAgIHJvb3QucmVmLmhvcHBlci5kZXN0cm95KCk7XG4gICAgICByb290LnJlZi5ob3BwZXIgPSBudWxsO1xuICAgICAgcm9vdC5yZW1vdmVDaGlsZFZpZXcocm9vdC5yZWYuZHJpcCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBFbmFibGUgb3IgZGlzYWJsZSBicm93c2UgZnVuY3Rpb25hbGl0eVxuICAgKi9cbiAgdmFyIHRvZ2dsZUJyb3dzZSA9IGZ1bmN0aW9uIHRvZ2dsZUJyb3dzZShyb290LCBwcm9wcykge1xuICAgIHZhciBpc0FsbG93ZWQgPSByb290LnF1ZXJ5KCdHRVRfQUxMT1dfQlJPV1NFJyk7XG4gICAgdmFyIGlzRGlzYWJsZWQgPSByb290LnF1ZXJ5KCdHRVRfRElTQUJMRUQnKTtcbiAgICB2YXIgZW5hYmxlZCA9IGlzQWxsb3dlZCAmJiAhaXNEaXNhYmxlZDtcbiAgICBpZiAoZW5hYmxlZCAmJiAhcm9vdC5yZWYuYnJvd3Nlcikge1xuICAgICAgcm9vdC5yZWYuYnJvd3NlciA9IHJvb3QuYXBwZW5kQ2hpbGRWaWV3KFxuICAgICAgICByb290LmNyZWF0ZUNoaWxkVmlldyhcbiAgICAgICAgICBicm93c2VyLFxuICAgICAgICAgIE9iamVjdC5hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgICBvbmxvYWQ6IGZ1bmN0aW9uIG9ubG9hZChpdGVtcykge1xuICAgICAgICAgICAgICBhcHBseUZpbHRlckNoYWluKCdBRERfSVRFTVMnLCBpdGVtcywge1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoOiByb290LmRpc3BhdGNoXG4gICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24ocXVldWUpIHtcbiAgICAgICAgICAgICAgICAvLyB0aGVzZSBmaWxlcyBkb24ndCBmaXQgc28gc3RvcCBoZXJlXG4gICAgICAgICAgICAgICAgaWYgKGV4Y2VlZHNNYXhGaWxlcyhyb290LCBxdWV1ZSkpIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgICAgIC8vIGFkZCBpdGVtcyFcbiAgICAgICAgICAgICAgICByb290LmRpc3BhdGNoKCdBRERfSVRFTVMnLCB7XG4gICAgICAgICAgICAgICAgICBpdGVtczogcXVldWUsXG4gICAgICAgICAgICAgICAgICBpbmRleDogLTEsXG4gICAgICAgICAgICAgICAgICBpbnRlcmFjdGlvbk1ldGhvZDogSW50ZXJhY3Rpb25NZXRob2QuQlJPV1NFXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgICksXG5cbiAgICAgICAgMFxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKCFlbmFibGVkICYmIHJvb3QucmVmLmJyb3dzZXIpIHtcbiAgICAgIHJvb3QucmVtb3ZlQ2hpbGRWaWV3KHJvb3QucmVmLmJyb3dzZXIpO1xuICAgICAgcm9vdC5yZWYuYnJvd3NlciA9IG51bGw7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBFbmFibGUgb3IgZGlzYWJsZSBwYXN0ZSBmdW5jdGlvbmFsaXR5XG4gICAqL1xuICB2YXIgdG9nZ2xlUGFzdGUgPSBmdW5jdGlvbiB0b2dnbGVQYXN0ZShyb290KSB7XG4gICAgdmFyIGlzQWxsb3dlZCA9IHJvb3QucXVlcnkoJ0dFVF9BTExPV19QQVNURScpO1xuICAgIHZhciBpc0Rpc2FibGVkID0gcm9vdC5xdWVyeSgnR0VUX0RJU0FCTEVEJyk7XG4gICAgdmFyIGVuYWJsZWQgPSBpc0FsbG93ZWQgJiYgIWlzRGlzYWJsZWQ7XG4gICAgaWYgKGVuYWJsZWQgJiYgIXJvb3QucmVmLnBhc3Rlcikge1xuICAgICAgcm9vdC5yZWYucGFzdGVyID0gY3JlYXRlUGFzdGVyKCk7XG4gICAgICByb290LnJlZi5wYXN0ZXIub25sb2FkID0gZnVuY3Rpb24oaXRlbXMpIHtcbiAgICAgICAgYXBwbHlGaWx0ZXJDaGFpbignQUREX0lURU1TJywgaXRlbXMsIHsgZGlzcGF0Y2g6IHJvb3QuZGlzcGF0Y2ggfSkudGhlbihcbiAgICAgICAgICBmdW5jdGlvbihxdWV1ZSkge1xuICAgICAgICAgICAgLy8gdGhlc2UgZmlsZXMgZG9uJ3QgZml0IHNvIHN0b3AgaGVyZVxuICAgICAgICAgICAgaWYgKGV4Y2VlZHNNYXhGaWxlcyhyb290LCBxdWV1ZSkpIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgLy8gYWRkIGl0ZW1zIVxuICAgICAgICAgICAgcm9vdC5kaXNwYXRjaCgnQUREX0lURU1TJywge1xuICAgICAgICAgICAgICBpdGVtczogcXVldWUsXG4gICAgICAgICAgICAgIGluZGV4OiAtMSxcbiAgICAgICAgICAgICAgaW50ZXJhY3Rpb25NZXRob2Q6IEludGVyYWN0aW9uTWV0aG9kLlBBU1RFXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoIWVuYWJsZWQgJiYgcm9vdC5yZWYucGFzdGVyKSB7XG4gICAgICByb290LnJlZi5wYXN0ZXIuZGVzdHJveSgpO1xuICAgICAgcm9vdC5yZWYucGFzdGVyID0gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJvdXRlIGFjdGlvbnNcbiAgICovXG4gIHZhciByb3V0ZSQ1ID0gY3JlYXRlUm91dGUoe1xuICAgIERJRF9TRVRfQUxMT1dfQlJPV1NFOiBmdW5jdGlvbiBESURfU0VUX0FMTE9XX0JST1dTRShfcmVmNSkge1xuICAgICAgdmFyIHJvb3QgPSBfcmVmNS5yb290LFxuICAgICAgICBwcm9wcyA9IF9yZWY1LnByb3BzO1xuICAgICAgdG9nZ2xlQnJvd3NlKHJvb3QsIHByb3BzKTtcbiAgICB9LFxuICAgIERJRF9TRVRfQUxMT1dfRFJPUDogZnVuY3Rpb24gRElEX1NFVF9BTExPV19EUk9QKF9yZWY2KSB7XG4gICAgICB2YXIgcm9vdCA9IF9yZWY2LnJvb3Q7XG4gICAgICB0b2dnbGVEcm9wKHJvb3QpO1xuICAgIH0sXG4gICAgRElEX1NFVF9BTExPV19QQVNURTogZnVuY3Rpb24gRElEX1NFVF9BTExPV19QQVNURShfcmVmNykge1xuICAgICAgdmFyIHJvb3QgPSBfcmVmNy5yb290O1xuICAgICAgdG9nZ2xlUGFzdGUocm9vdCk7XG4gICAgfSxcbiAgICBESURfU0VUX0RJU0FCTEVEOiBmdW5jdGlvbiBESURfU0VUX0RJU0FCTEVEKF9yZWY4KSB7XG4gICAgICB2YXIgcm9vdCA9IF9yZWY4LnJvb3QsXG4gICAgICAgIHByb3BzID0gX3JlZjgucHJvcHM7XG4gICAgICB0b2dnbGVEcm9wKHJvb3QpO1xuICAgICAgdG9nZ2xlUGFzdGUocm9vdCk7XG4gICAgICB0b2dnbGVCcm93c2Uocm9vdCwgcHJvcHMpO1xuICAgICAgdmFyIGlzRGlzYWJsZWQgPSByb290LnF1ZXJ5KCdHRVRfRElTQUJMRUQnKTtcbiAgICAgIGlmIChpc0Rpc2FibGVkKSB7XG4gICAgICAgIHJvb3QuZWxlbWVudC5kYXRhc2V0LmRpc2FibGVkID0gJ2Rpc2FibGVkJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRlbGV0ZSByb290LmVsZW1lbnQuZGF0YXNldC5kaXNhYmxlZDsgPD0gdGhpcyBkb2VzIG5vdCB3b3JrIG9uIGlPUyAxMFxuICAgICAgICByb290LmVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdkYXRhLWRpc2FibGVkJyk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICB2YXIgcm9vdCA9IGNyZWF0ZVZpZXcoe1xuICAgIG5hbWU6ICdyb290JyxcbiAgICByZWFkOiBmdW5jdGlvbiByZWFkKF9yZWY5KSB7XG4gICAgICB2YXIgcm9vdCA9IF9yZWY5LnJvb3Q7XG4gICAgICBpZiAocm9vdC5yZWYubWVhc3VyZSkge1xuICAgICAgICByb290LnJlZi5tZWFzdXJlSGVpZ2h0ID0gcm9vdC5yZWYubWVhc3VyZS5vZmZzZXRIZWlnaHQ7XG4gICAgICB9XG4gICAgfSxcbiAgICBjcmVhdGU6IGNyZWF0ZSRlLFxuICAgIHdyaXRlOiB3cml0ZSQ5LFxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koX3JlZjEwKSB7XG4gICAgICB2YXIgcm9vdCA9IF9yZWYxMC5yb290O1xuICAgICAgaWYgKHJvb3QucmVmLnBhc3Rlcikge1xuICAgICAgICByb290LnJlZi5wYXN0ZXIuZGVzdHJveSgpO1xuICAgICAgfVxuICAgICAgaWYgKHJvb3QucmVmLmhvcHBlcikge1xuICAgICAgICByb290LnJlZi5ob3BwZXIuZGVzdHJveSgpO1xuICAgICAgfVxuICAgICAgcm9vdC5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHByZXZlbnQpO1xuICAgICAgcm9vdC5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2dlc3R1cmVzdGFydCcsIHByZXZlbnQpO1xuICAgIH0sXG4gICAgbWl4aW5zOiB7XG4gICAgICBzdHlsZXM6IFsnaGVpZ2h0J11cbiAgICB9XG4gIH0pO1xuXG4gIC8vIGNyZWF0ZXMgdGhlIGFwcFxuICB2YXIgY3JlYXRlQXBwID0gZnVuY3Rpb24gY3JlYXRlQXBwKCkge1xuICAgIHZhciBpbml0aWFsT3B0aW9ucyA9XG4gICAgICBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIC8vIGxldCBlbGVtZW50XG4gICAgdmFyIG9yaWdpbmFsRWxlbWVudCA9IG51bGw7XG5cbiAgICAvLyBnZXQgZGVmYXVsdCBvcHRpb25zXG4gICAgdmFyIGRlZmF1bHRPcHRpb25zID0gZ2V0T3B0aW9ucygpO1xuXG4gICAgLy8gY3JlYXRlIHRoZSBkYXRhIHN0b3JlLCB0aGlzIHdpbGwgY29udGFpbiBhbGwgb3VyIGFwcCBpbmZvXG4gICAgdmFyIHN0b3JlID0gY3JlYXRlU3RvcmUoXG4gICAgICAvLyBpbml0aWFsIHN0YXRlIChzaG91bGQgYmUgc2VyaWFsaXphYmxlKVxuICAgICAgY3JlYXRlSW5pdGlhbFN0YXRlKGRlZmF1bHRPcHRpb25zKSxcblxuICAgICAgLy8gcXVlcmllc1xuICAgICAgW3F1ZXJpZXMsIGNyZWF0ZU9wdGlvblF1ZXJpZXMoZGVmYXVsdE9wdGlvbnMpXSxcblxuICAgICAgLy8gYWN0aW9uIGhhbmRsZXJzXG4gICAgICBbYWN0aW9ucywgY3JlYXRlT3B0aW9uQWN0aW9ucyhkZWZhdWx0T3B0aW9ucyldXG4gICAgKTtcblxuICAgIC8vIHNldCBpbml0aWFsIG9wdGlvbnNcbiAgICBzdG9yZS5kaXNwYXRjaCgnU0VUX09QVElPTlMnLCB7IG9wdGlvbnM6IGluaXRpYWxPcHRpb25zIH0pO1xuXG4gICAgLy8ga2ljayB0aHJlYWQgaWYgdmlzaWJpbGl0eSBjaGFuZ2VzXG4gICAgdmFyIHZpc2liaWxpdHlIYW5kbGVyID0gZnVuY3Rpb24gdmlzaWJpbGl0eUhhbmRsZXIoKSB7XG4gICAgICBpZiAoZG9jdW1lbnQuaGlkZGVuKSByZXR1cm47XG4gICAgICBzdG9yZS5kaXNwYXRjaCgnS0lDSycpO1xuICAgIH07XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsIHZpc2liaWxpdHlIYW5kbGVyKTtcblxuICAgIC8vIHJlLXJlbmRlciBvbiB3aW5kb3cgcmVzaXplIHN0YXJ0IGFuZCBmaW5pc2hcbiAgICB2YXIgcmVzaXplRG9uZVRpbWVyID0gbnVsbDtcbiAgICB2YXIgaXNSZXNpemluZyA9IGZhbHNlO1xuICAgIHZhciBpc1Jlc2l6aW5nSG9yaXpvbnRhbGx5ID0gZmFsc2U7XG4gICAgdmFyIGluaXRpYWxXaW5kb3dXaWR0aCA9IG51bGw7XG4gICAgdmFyIGN1cnJlbnRXaW5kb3dXaWR0aCA9IG51bGw7XG4gICAgdmFyIHJlc2l6ZUhhbmRsZXIgPSBmdW5jdGlvbiByZXNpemVIYW5kbGVyKCkge1xuICAgICAgaWYgKCFpc1Jlc2l6aW5nKSB7XG4gICAgICAgIGlzUmVzaXppbmcgPSB0cnVlO1xuICAgICAgfVxuICAgICAgY2xlYXJUaW1lb3V0KHJlc2l6ZURvbmVUaW1lcik7XG4gICAgICByZXNpemVEb25lVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICBpc1Jlc2l6aW5nID0gZmFsc2U7XG4gICAgICAgIGluaXRpYWxXaW5kb3dXaWR0aCA9IG51bGw7XG4gICAgICAgIGN1cnJlbnRXaW5kb3dXaWR0aCA9IG51bGw7XG4gICAgICAgIGlmIChpc1Jlc2l6aW5nSG9yaXpvbnRhbGx5KSB7XG4gICAgICAgICAgaXNSZXNpemluZ0hvcml6b250YWxseSA9IGZhbHNlO1xuICAgICAgICAgIHN0b3JlLmRpc3BhdGNoKCdESURfU1RPUF9SRVNJWkUnKTtcbiAgICAgICAgfVxuICAgICAgfSwgNTAwKTtcbiAgICB9O1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCByZXNpemVIYW5kbGVyKTtcblxuICAgIC8vIHJlbmRlciBpbml0aWFsIHZpZXdcbiAgICB2YXIgdmlldyA9IHJvb3Qoc3RvcmUsIHsgaWQ6IGdldFVuaXF1ZUlkKCkgfSk7XG5cbiAgICAvL1xuICAgIC8vIFBSSVZBVEUgQVBJIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvL1xuICAgIHZhciBpc1Jlc3RpbmcgPSBmYWxzZTtcbiAgICB2YXIgaXNIaWRkZW4gPSBmYWxzZTtcblxuICAgIHZhciByZWFkV3JpdGVBcGkgPSB7XG4gICAgICAvLyBuZWNlc3NhcnkgZm9yIHVwZGF0ZSBsb29wXG5cbiAgICAgIC8qKlxuICAgICAgICogUmVhZHMgZnJvbSBkb20gKG5ldmVyIGNhbGwgbWFudWFsbHkpXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG4gICAgICBfcmVhZDogZnVuY3Rpb24gX3JlYWQoKSB7XG4gICAgICAgIC8vIHRlc3QgaWYgd2UncmUgcmVzaXppbmcgaG9yaXpvbnRhbGx5XG4gICAgICAgIC8vIFRPRE86IHNlZSBpZiB3ZSBjYW4gb3B0aW1pemUgdGhpcyBieSBtZWFzdXJpbmcgcm9vdCByZWN0XG4gICAgICAgIGlmIChpc1Jlc2l6aW5nKSB7XG4gICAgICAgICAgY3VycmVudFdpbmRvd1dpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgICAgICAgaWYgKCFpbml0aWFsV2luZG93V2lkdGgpIHtcbiAgICAgICAgICAgIGluaXRpYWxXaW5kb3dXaWR0aCA9IGN1cnJlbnRXaW5kb3dXaWR0aDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAhaXNSZXNpemluZ0hvcml6b250YWxseSAmJlxuICAgICAgICAgICAgY3VycmVudFdpbmRvd1dpZHRoICE9PSBpbml0aWFsV2luZG93V2lkdGhcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHN0b3JlLmRpc3BhdGNoKCdESURfU1RBUlRfUkVTSVpFJyk7XG4gICAgICAgICAgICBpc1Jlc2l6aW5nSG9yaXpvbnRhbGx5ID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNIaWRkZW4gJiYgaXNSZXN0aW5nKSB7XG4gICAgICAgICAgLy8gdGVzdCBpZiBpcyBubyBsb25nZXIgaGlkZGVuXG4gICAgICAgICAgaXNSZXN0aW5nID0gdmlldy5lbGVtZW50Lm9mZnNldFBhcmVudCA9PT0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHJlc3RpbmcsIG5vIG5lZWQgdG8gcmVhZCBhcyBudW1iZXJzIHdpbGwgc3RpbGwgYWxsIGJlIGNvcnJlY3RcbiAgICAgICAgaWYgKGlzUmVzdGluZykgcmV0dXJuO1xuXG4gICAgICAgIC8vIHJlYWQgdmlldyBkYXRhXG4gICAgICAgIHZpZXcuX3JlYWQoKTtcblxuICAgICAgICAvLyBpZiBpcyBoaWRkZW4gd2UgbmVlZCB0byBrbm93IHNvIHdlIGV4aXQgcmVzdCBtb2RlIHdoZW4gcmV2ZWFsZWRcbiAgICAgICAgaXNIaWRkZW4gPSB2aWV3LnJlY3QuZWxlbWVudC5oaWRkZW47XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFdyaXRlcyB0byBkb20gKG5ldmVyIGNhbGwgbWFudWFsbHkpXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG4gICAgICBfd3JpdGU6IGZ1bmN0aW9uIF93cml0ZSh0cykge1xuICAgICAgICAvLyBnZXQgYWxsIGFjdGlvbnMgZnJvbSBzdG9yZVxuICAgICAgICB2YXIgYWN0aW9ucyA9IHN0b3JlXG4gICAgICAgICAgLnByb2Nlc3NBY3Rpb25RdWV1ZSgpXG5cbiAgICAgICAgICAvLyBmaWx0ZXIgb3V0IHNldCBhY3Rpb25zICh0aGVzZSB3aWxsIGF1dG9tYXRpY2FsbHkgdHJpZ2dlciBESURfU0VUKVxuICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24oYWN0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gIS9eU0VUXy8udGVzdChhY3Rpb24udHlwZSk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gaWYgd2FzIGlkbGluZyBhbmQgbm8gYWN0aW9ucyBzdG9wIGhlcmVcbiAgICAgICAgaWYgKGlzUmVzdGluZyAmJiAhYWN0aW9ucy5sZW5ndGgpIHJldHVybjtcblxuICAgICAgICAvLyBzb21lIGFjdGlvbnMgbWlnaHQgdHJpZ2dlciBldmVudHNcbiAgICAgICAgcm91dGVBY3Rpb25zVG9FdmVudHMoYWN0aW9ucyk7XG5cbiAgICAgICAgLy8gdXBkYXRlIHRoZSB2aWV3XG4gICAgICAgIGlzUmVzdGluZyA9IHZpZXcuX3dyaXRlKHRzLCBhY3Rpb25zLCBpc1Jlc2l6aW5nSG9yaXpvbnRhbGx5KTtcblxuICAgICAgICAvLyB3aWxsIGNsZWFuIHVwIGFsbCBhcmNoaXZlZCBpdGVtc1xuICAgICAgICByZW1vdmVSZWxlYXNlZEl0ZW1zKHN0b3JlLnF1ZXJ5KCdHRVRfSVRFTVMnKSk7XG5cbiAgICAgICAgLy8gbm93IGlkbGluZ1xuICAgICAgICBpZiAoaXNSZXN0aW5nKSB7XG4gICAgICAgICAgc3RvcmUucHJvY2Vzc0Rpc3BhdGNoUXVldWUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICAvL1xuICAgIC8vIEVYUE9TRSBFVkVOVFMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vXG4gICAgdmFyIGNyZWF0ZUV2ZW50ID0gZnVuY3Rpb24gY3JlYXRlRXZlbnQobmFtZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgLy8gY3JlYXRlIGRlZmF1bHQgZXZlbnRcbiAgICAgICAgdmFyIGV2ZW50ID0ge1xuICAgICAgICAgIHR5cGU6IG5hbWVcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBubyBkYXRhIHRvIGFkZFxuICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb3B5IHJlbGV2YW50IHByb3BzXG4gICAgICAgIGlmIChkYXRhLmhhc093blByb3BlcnR5KCdlcnJvcicpKSB7XG4gICAgICAgICAgZXZlbnQuZXJyb3IgPSBkYXRhLmVycm9yID8gT2JqZWN0LmFzc2lnbih7fSwgZGF0YS5lcnJvcikgOiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRhdGEuc3RhdHVzKSB7XG4gICAgICAgICAgZXZlbnQuc3RhdHVzID0gT2JqZWN0LmFzc2lnbih7fSwgZGF0YS5zdGF0dXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRhdGEuZmlsZSkge1xuICAgICAgICAgIGV2ZW50Lm91dHB1dCA9IGRhdGEuZmlsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG9ubHkgc291cmNlIGlzIGF2YWlsYWJsZSwgZWxzZSBhZGQgaXRlbSBpZiBwb3NzaWJsZVxuICAgICAgICBpZiAoZGF0YS5zb3VyY2UpIHtcbiAgICAgICAgICBldmVudC5maWxlID0gZGF0YS5zb3VyY2U7XG4gICAgICAgIH0gZWxzZSBpZiAoZGF0YS5pdGVtIHx8IGRhdGEuaWQpIHtcbiAgICAgICAgICB2YXIgaXRlbSA9IGRhdGEuaXRlbSA/IGRhdGEuaXRlbSA6IHN0b3JlLnF1ZXJ5KCdHRVRfSVRFTScsIGRhdGEuaWQpO1xuICAgICAgICAgIGV2ZW50LmZpbGUgPSBpdGVtID8gY3JlYXRlSXRlbUFQSShpdGVtKSA6IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBtYXAgYWxsIGl0ZW1zIGluIGEgcG9zc2libGUgaXRlbXMgYXJyYXlcbiAgICAgICAgaWYgKGRhdGEuaXRlbXMpIHtcbiAgICAgICAgICBldmVudC5pdGVtcyA9IGRhdGEuaXRlbXMubWFwKGNyZWF0ZUl0ZW1BUEkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgdGhpcyBpcyBhIHByb2dyZXNzIGV2ZW50IGFkZCB0aGUgcHJvZ3Jlc3MgYW1vdW50XG4gICAgICAgIGlmICgvcHJvZ3Jlc3MvLnRlc3QobmFtZSkpIHtcbiAgICAgICAgICBldmVudC5wcm9ncmVzcyA9IGRhdGEucHJvZ3Jlc3M7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb3B5IHJlbGV2YW50IHByb3BzXG4gICAgICAgIGlmIChkYXRhLmhhc093blByb3BlcnR5KCdvcmlnaW4nKSAmJiBkYXRhLmhhc093blByb3BlcnR5KCd0YXJnZXQnKSkge1xuICAgICAgICAgIGV2ZW50Lm9yaWdpbiA9IGRhdGEub3JpZ2luO1xuICAgICAgICAgIGV2ZW50LnRhcmdldCA9IGRhdGEudGFyZ2V0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGV2ZW50Um91dGVzID0ge1xuICAgICAgRElEX0RFU1RST1k6IGNyZWF0ZUV2ZW50KCdkZXN0cm95JyksXG5cbiAgICAgIERJRF9JTklUOiBjcmVhdGVFdmVudCgnaW5pdCcpLFxuXG4gICAgICBESURfVEhST1dfTUFYX0ZJTEVTOiBjcmVhdGVFdmVudCgnd2FybmluZycpLFxuXG4gICAgICBESURfSU5JVF9JVEVNOiBjcmVhdGVFdmVudCgnaW5pdGZpbGUnKSxcbiAgICAgIERJRF9TVEFSVF9JVEVNX0xPQUQ6IGNyZWF0ZUV2ZW50KCdhZGRmaWxlc3RhcnQnKSxcbiAgICAgIERJRF9VUERBVEVfSVRFTV9MT0FEX1BST0dSRVNTOiBjcmVhdGVFdmVudCgnYWRkZmlsZXByb2dyZXNzJyksXG4gICAgICBESURfTE9BRF9JVEVNOiBjcmVhdGVFdmVudCgnYWRkZmlsZScpLFxuXG4gICAgICBESURfVEhST1dfSVRFTV9JTlZBTElEOiBbY3JlYXRlRXZlbnQoJ2Vycm9yJyksIGNyZWF0ZUV2ZW50KCdhZGRmaWxlJyldLFxuXG4gICAgICBESURfVEhST1dfSVRFTV9MT0FEX0VSUk9SOiBbY3JlYXRlRXZlbnQoJ2Vycm9yJyksIGNyZWF0ZUV2ZW50KCdhZGRmaWxlJyldLFxuXG4gICAgICBESURfVEhST1dfSVRFTV9SRU1PVkVfRVJST1I6IFtcbiAgICAgICAgY3JlYXRlRXZlbnQoJ2Vycm9yJyksXG4gICAgICAgIGNyZWF0ZUV2ZW50KCdyZW1vdmVmaWxlJylcbiAgICAgIF0sXG5cbiAgICAgIERJRF9QUkVQQVJFX09VVFBVVDogY3JlYXRlRXZlbnQoJ3ByZXBhcmVmaWxlJyksXG5cbiAgICAgIERJRF9TVEFSVF9JVEVNX1BST0NFU1NJTkc6IGNyZWF0ZUV2ZW50KCdwcm9jZXNzZmlsZXN0YXJ0JyksXG4gICAgICBESURfVVBEQVRFX0lURU1fUFJPQ0VTU19QUk9HUkVTUzogY3JlYXRlRXZlbnQoJ3Byb2Nlc3NmaWxlcHJvZ3Jlc3MnKSxcbiAgICAgIERJRF9BQk9SVF9JVEVNX1BST0NFU1NJTkc6IGNyZWF0ZUV2ZW50KCdwcm9jZXNzZmlsZWFib3J0JyksXG4gICAgICBESURfQ09NUExFVEVfSVRFTV9QUk9DRVNTSU5HOiBjcmVhdGVFdmVudCgncHJvY2Vzc2ZpbGUnKSxcbiAgICAgIERJRF9DT01QTEVURV9JVEVNX1BST0NFU1NJTkdfQUxMOiBjcmVhdGVFdmVudCgncHJvY2Vzc2ZpbGVzJyksXG4gICAgICBESURfUkVWRVJUX0lURU1fUFJPQ0VTU0lORzogY3JlYXRlRXZlbnQoJ3Byb2Nlc3NmaWxlcmV2ZXJ0JyksXG5cbiAgICAgIERJRF9USFJPV19JVEVNX1BST0NFU1NJTkdfRVJST1I6IFtcbiAgICAgICAgY3JlYXRlRXZlbnQoJ2Vycm9yJyksXG4gICAgICAgIGNyZWF0ZUV2ZW50KCdwcm9jZXNzZmlsZScpXG4gICAgICBdLFxuXG4gICAgICBESURfUkVNT1ZFX0lURU06IGNyZWF0ZUV2ZW50KCdyZW1vdmVmaWxlJyksXG5cbiAgICAgIERJRF9VUERBVEVfSVRFTVM6IGNyZWF0ZUV2ZW50KCd1cGRhdGVmaWxlcycpLFxuXG4gICAgICBESURfQUNUSVZBVEVfSVRFTTogY3JlYXRlRXZlbnQoJ2FjdGl2YXRlZmlsZScpLFxuXG4gICAgICBESURfUkVPUkRFUl9JVEVNUzogY3JlYXRlRXZlbnQoJ3Jlb3JkZXJmaWxlcycpXG4gICAgfTtcblxuICAgIHZhciBleHBvc2VFdmVudCA9IGZ1bmN0aW9uIGV4cG9zZUV2ZW50KGV2ZW50KSB7XG4gICAgICAvLyBjcmVhdGUgZXZlbnQgb2JqZWN0IHRvIGJlIGRpc3BhdGNoZWRcbiAgICAgIHZhciBkZXRhaWwgPSBPYmplY3QuYXNzaWduKHsgcG9uZDogZXhwb3J0cyB9LCBldmVudCk7XG4gICAgICBkZWxldGUgZGV0YWlsLnR5cGU7XG4gICAgICB2aWV3LmVsZW1lbnQuZGlzcGF0Y2hFdmVudChcbiAgICAgICAgbmV3IEN1c3RvbUV2ZW50KCdGaWxlUG9uZDonICsgZXZlbnQudHlwZSwge1xuICAgICAgICAgIC8vIGV2ZW50IGluZm9cbiAgICAgICAgICBkZXRhaWw6IGRldGFpbCxcblxuICAgICAgICAgIC8vIGV2ZW50IGJlaGF2aW91clxuICAgICAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb21wb3NlZDogdHJ1ZSAvLyB0cmlnZ2VycyBsaXN0ZW5lcnMgb3V0c2lkZSBvZiBzaGFkb3cgcm9vdFxuICAgICAgICB9KVxuICAgICAgKTtcblxuICAgICAgLy8gZXZlbnQgb2JqZWN0IHRvIHBhcmFtcyB1c2VkIGZvciBgb24oKWAgZXZlbnQgaGFuZGxlcnMgYW5kIGNhbGxiYWNrcyBgb25pbml0KClgXG4gICAgICB2YXIgcGFyYW1zID0gW107XG5cbiAgICAgIC8vIGlmIGlzIHBvc3NpYmxlIGVycm9yIGV2ZW50LCBtYWtlIGl0IHRoZSBmaXJzdCBwYXJhbVxuICAgICAgaWYgKGV2ZW50Lmhhc093blByb3BlcnR5KCdlcnJvcicpKSB7XG4gICAgICAgIHBhcmFtcy5wdXNoKGV2ZW50LmVycm9yKTtcbiAgICAgIH1cblxuICAgICAgLy8gZmlsZSBpcyBhbHdheXMgc2VjdGlvblxuICAgICAgaWYgKGV2ZW50Lmhhc093blByb3BlcnR5KCdmaWxlJykpIHtcbiAgICAgICAgcGFyYW1zLnB1c2goZXZlbnQuZmlsZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGFwcGVuZCBvdGhlciBwcm9wc1xuICAgICAgdmFyIGZpbHRlcmVkID0gWyd0eXBlJywgJ2Vycm9yJywgJ2ZpbGUnXTtcbiAgICAgIE9iamVjdC5rZXlzKGV2ZW50KVxuICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgIHJldHVybiAhZmlsdGVyZWQuaW5jbHVkZXMoa2V5KTtcbiAgICAgICAgfSlcbiAgICAgICAgLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgcmV0dXJuIHBhcmFtcy5wdXNoKGV2ZW50W2tleV0pO1xuICAgICAgICB9KTtcblxuICAgICAgLy8gb24odHlwZSwgKCkgPT4geyB9KVxuICAgICAgZXhwb3J0cy5maXJlLmFwcGx5KGV4cG9ydHMsIFtldmVudC50eXBlXS5jb25jYXQocGFyYW1zKSk7XG5cbiAgICAgIC8vIG9uaW5pdCA9ICgpID0+IHt9XG4gICAgICB2YXIgaGFuZGxlciA9IHN0b3JlLnF1ZXJ5KCdHRVRfT04nICsgZXZlbnQudHlwZS50b1VwcGVyQ2FzZSgpKTtcbiAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgIGhhbmRsZXIuYXBwbHkodm9pZCAwLCBwYXJhbXMpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgcm91dGVBY3Rpb25zVG9FdmVudHMgPSBmdW5jdGlvbiByb3V0ZUFjdGlvbnNUb0V2ZW50cyhhY3Rpb25zKSB7XG4gICAgICBpZiAoIWFjdGlvbnMubGVuZ3RoKSByZXR1cm47XG4gICAgICBhY3Rpb25zXG4gICAgICAgIC5maWx0ZXIoZnVuY3Rpb24oYWN0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIGV2ZW50Um91dGVzW2FjdGlvbi50eXBlXTtcbiAgICAgICAgfSlcbiAgICAgICAgLmZvckVhY2goZnVuY3Rpb24oYWN0aW9uKSB7XG4gICAgICAgICAgdmFyIHJvdXRlcyA9IGV2ZW50Um91dGVzW2FjdGlvbi50eXBlXTtcbiAgICAgICAgICAoQXJyYXkuaXNBcnJheShyb3V0ZXMpID8gcm91dGVzIDogW3JvdXRlc10pLmZvckVhY2goZnVuY3Rpb24ocm91dGUpIHtcbiAgICAgICAgICAgIC8vIHRoaXMgaXNuJ3QgZmFudGFzdGljLCBidXQgYmVjYXVzZSBvZiB0aGUgc3RhY2tpbmcgb2Ygc2V0dGltZW91dHMgcGx1Z2lucyBjYW4gaGFuZGxlIHRoZSBkaWRfbG9hZCBiZWZvcmUgdGhlIGRpZF9pbml0XG4gICAgICAgICAgICBpZiAoYWN0aW9uLnR5cGUgPT09ICdESURfSU5JVF9JVEVNJykge1xuICAgICAgICAgICAgICBleHBvc2VFdmVudChyb3V0ZShhY3Rpb24uZGF0YSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBleHBvc2VFdmVudChyb3V0ZShhY3Rpb24uZGF0YSkpO1xuICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vXG4gICAgLy8gUFVCTElDIEFQSSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy9cbiAgICB2YXIgc2V0T3B0aW9ucyA9IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgcmV0dXJuIHN0b3JlLmRpc3BhdGNoKCdTRVRfT1BUSU9OUycsIHsgb3B0aW9uczogb3B0aW9ucyB9KTtcbiAgICB9O1xuXG4gICAgdmFyIGdldEZpbGUgPSBmdW5jdGlvbiBnZXRGaWxlKHF1ZXJ5KSB7XG4gICAgICByZXR1cm4gc3RvcmUucXVlcnkoJ0dFVF9BQ1RJVkVfSVRFTScsIHF1ZXJ5KTtcbiAgICB9O1xuXG4gICAgdmFyIHByZXBhcmVGaWxlID0gZnVuY3Rpb24gcHJlcGFyZUZpbGUocXVlcnkpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgc3RvcmUuZGlzcGF0Y2goJ1JFUVVFU1RfSVRFTV9QUkVQQVJFJywge1xuICAgICAgICAgIHF1ZXJ5OiBxdWVyeSxcbiAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiBzdWNjZXNzKGl0ZW0pIHtcbiAgICAgICAgICAgIHJlc29sdmUoaXRlbSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBmYWlsdXJlOiBmdW5jdGlvbiBmYWlsdXJlKGVycm9yKSB7XG4gICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyIGFkZEZpbGUgPSBmdW5jdGlvbiBhZGRGaWxlKHNvdXJjZSkge1xuICAgICAgdmFyIG9wdGlvbnMgPVxuICAgICAgICBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBhZGRGaWxlcyhbeyBzb3VyY2U6IHNvdXJjZSwgb3B0aW9uczogb3B0aW9ucyB9XSwge1xuICAgICAgICAgIGluZGV4OiBvcHRpb25zLmluZGV4XG4gICAgICAgIH0pXG4gICAgICAgICAgLnRoZW4oZnVuY3Rpb24oaXRlbXMpIHtcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGl0ZW1zICYmIGl0ZW1zWzBdKTtcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5jYXRjaChyZWplY3QpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHZhciBpc0ZpbGVQb25kRmlsZSA9IGZ1bmN0aW9uIGlzRmlsZVBvbmRGaWxlKG9iaikge1xuICAgICAgcmV0dXJuIG9iai5maWxlICYmIG9iai5pZDtcbiAgICB9O1xuXG4gICAgdmFyIHJlbW92ZUZpbGUgPSBmdW5jdGlvbiByZW1vdmVGaWxlKHF1ZXJ5LCBvcHRpb25zKSB7XG4gICAgICAvLyBpZiBvbmx5IHBhc3NlZCBvcHRpb25zXG4gICAgICBpZiAodHlwZW9mIHF1ZXJ5ID09PSAnb2JqZWN0JyAmJiAhaXNGaWxlUG9uZEZpbGUocXVlcnkpICYmICFvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBxdWVyeTtcbiAgICAgICAgcXVlcnkgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIC8vIHJlcXVlc3QgaXRlbSByZW1vdmFsXG4gICAgICBzdG9yZS5kaXNwYXRjaChcbiAgICAgICAgJ1JFTU9WRV9JVEVNJyxcbiAgICAgICAgT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywgeyBxdWVyeTogcXVlcnkgfSlcbiAgICAgICk7XG5cbiAgICAgIC8vIHNlZSBpZiBpdGVtIGhhcyBiZWVuIHJlbW92ZWRcbiAgICAgIHJldHVybiBzdG9yZS5xdWVyeSgnR0VUX0FDVElWRV9JVEVNJywgcXVlcnkpID09PSBudWxsO1xuICAgIH07XG5cbiAgICB2YXIgYWRkRmlsZXMgPSBmdW5jdGlvbiBhZGRGaWxlcygpIHtcbiAgICAgIGZvciAoXG4gICAgICAgIHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7XG4gICAgICAgIF9rZXkgPCBfbGVuO1xuICAgICAgICBfa2V5KytcbiAgICAgICkge1xuICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB2YXIgc291cmNlcyA9IFtdO1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHt9O1xuXG4gICAgICAgIC8vIHVzZXIgcGFzc2VkIGEgc291cmNlcyBhcnJheVxuICAgICAgICBpZiAoaXNBcnJheShhcmdzWzBdKSkge1xuICAgICAgICAgIHNvdXJjZXMucHVzaC5hcHBseShzb3VyY2VzLCBhcmdzWzBdKTtcbiAgICAgICAgICBPYmplY3QuYXNzaWduKG9wdGlvbnMsIGFyZ3NbMV0gfHwge30pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHVzZXIgcGFzc2VkIHNvdXJjZXMgYXMgYXJndW1lbnRzLCBsYXN0IG9uZSBtaWdodCBiZSBvcHRpb25zIG9iamVjdFxuICAgICAgICAgIHZhciBsYXN0QXJndW1lbnQgPSBhcmdzW2FyZ3MubGVuZ3RoIC0gMV07XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgdHlwZW9mIGxhc3RBcmd1bWVudCA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgICEobGFzdEFyZ3VtZW50IGluc3RhbmNlb2YgQmxvYilcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ob3B0aW9ucywgYXJncy5wb3AoKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gYWRkIHJlc3QgdG8gc291cmNlc1xuICAgICAgICAgIHNvdXJjZXMucHVzaC5hcHBseShzb3VyY2VzLCBhcmdzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0b3JlLmRpc3BhdGNoKCdBRERfSVRFTVMnLCB7XG4gICAgICAgICAgaXRlbXM6IHNvdXJjZXMsXG4gICAgICAgICAgaW5kZXg6IG9wdGlvbnMuaW5kZXgsXG4gICAgICAgICAgaW50ZXJhY3Rpb25NZXRob2Q6IEludGVyYWN0aW9uTWV0aG9kLkFQSSxcbiAgICAgICAgICBzdWNjZXNzOiByZXNvbHZlLFxuICAgICAgICAgIGZhaWx1cmU6IHJlamVjdFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICB2YXIgZ2V0RmlsZXMgPSBmdW5jdGlvbiBnZXRGaWxlcygpIHtcbiAgICAgIHJldHVybiBzdG9yZS5xdWVyeSgnR0VUX0FDVElWRV9JVEVNUycpO1xuICAgIH07XG5cbiAgICB2YXIgcHJvY2Vzc0ZpbGUgPSBmdW5jdGlvbiBwcm9jZXNzRmlsZShxdWVyeSkge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBzdG9yZS5kaXNwYXRjaCgnUkVRVUVTVF9JVEVNX1BST0NFU1NJTkcnLCB7XG4gICAgICAgICAgcXVlcnk6IHF1ZXJ5LFxuICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIHN1Y2Nlc3MoaXRlbSkge1xuICAgICAgICAgICAgcmVzb2x2ZShpdGVtKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGZhaWx1cmU6IGZ1bmN0aW9uIGZhaWx1cmUoZXJyb3IpIHtcbiAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICB2YXIgcHJlcGFyZUZpbGVzID0gZnVuY3Rpb24gcHJlcGFyZUZpbGVzKCkge1xuICAgICAgZm9yIChcbiAgICAgICAgdmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiksIF9rZXkyID0gMDtcbiAgICAgICAgX2tleTIgPCBfbGVuMjtcbiAgICAgICAgX2tleTIrK1xuICAgICAgKSB7XG4gICAgICAgIGFyZ3NbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cbiAgICAgIHZhciBxdWVyaWVzID0gQXJyYXkuaXNBcnJheShhcmdzWzBdKSA/IGFyZ3NbMF0gOiBhcmdzO1xuICAgICAgdmFyIGl0ZW1zID0gcXVlcmllcy5sZW5ndGggPyBxdWVyaWVzIDogZ2V0RmlsZXMoKTtcbiAgICAgIHJldHVybiBQcm9taXNlLmFsbChpdGVtcy5tYXAocHJlcGFyZUZpbGUpKTtcbiAgICB9O1xuXG4gICAgdmFyIHByb2Nlc3NGaWxlcyA9IGZ1bmN0aW9uIHByb2Nlc3NGaWxlcygpIHtcbiAgICAgIGZvciAoXG4gICAgICAgIHZhciBfbGVuMyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjMpLCBfa2V5MyA9IDA7XG4gICAgICAgIF9rZXkzIDwgX2xlbjM7XG4gICAgICAgIF9rZXkzKytcbiAgICAgICkge1xuICAgICAgICBhcmdzW19rZXkzXSA9IGFyZ3VtZW50c1tfa2V5M107XG4gICAgICB9XG4gICAgICB2YXIgcXVlcmllcyA9IEFycmF5LmlzQXJyYXkoYXJnc1swXSkgPyBhcmdzWzBdIDogYXJncztcbiAgICAgIGlmICghcXVlcmllcy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGZpbGVzID0gZ2V0RmlsZXMoKS5maWx0ZXIoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAhKFxuICAgICAgICAgICAgICBpdGVtLnN0YXR1cyA9PT0gSXRlbVN0YXR1cy5JRExFICYmXG4gICAgICAgICAgICAgIGl0ZW0ub3JpZ2luID09PSBGaWxlT3JpZ2luLkxPQ0FMXG4gICAgICAgICAgICApICYmXG4gICAgICAgICAgICBpdGVtLnN0YXR1cyAhPT0gSXRlbVN0YXR1cy5QUk9DRVNTSU5HICYmXG4gICAgICAgICAgICBpdGVtLnN0YXR1cyAhPT0gSXRlbVN0YXR1cy5QUk9DRVNTSU5HX0NPTVBMRVRFICYmXG4gICAgICAgICAgICBpdGVtLnN0YXR1cyAhPT0gSXRlbVN0YXR1cy5QUk9DRVNTSU5HX1JFVkVSVF9FUlJPUlxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChmaWxlcy5tYXAocHJvY2Vzc0ZpbGUpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBQcm9taXNlLmFsbChxdWVyaWVzLm1hcChwcm9jZXNzRmlsZSkpO1xuICAgIH07XG5cbiAgICB2YXIgcmVtb3ZlRmlsZXMgPSBmdW5jdGlvbiByZW1vdmVGaWxlcygpIHtcbiAgICAgIGZvciAoXG4gICAgICAgIHZhciBfbGVuNCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjQpLCBfa2V5NCA9IDA7XG4gICAgICAgIF9rZXk0IDwgX2xlbjQ7XG4gICAgICAgIF9rZXk0KytcbiAgICAgICkge1xuICAgICAgICBhcmdzW19rZXk0XSA9IGFyZ3VtZW50c1tfa2V5NF07XG4gICAgICB9XG5cbiAgICAgIHZhciBxdWVyaWVzID0gQXJyYXkuaXNBcnJheShhcmdzWzBdKSA/IGFyZ3NbMF0gOiBhcmdzO1xuXG4gICAgICB2YXIgb3B0aW9ucztcbiAgICAgIGlmICh0eXBlb2YgcXVlcmllc1txdWVyaWVzLmxlbmd0aCAtIDFdID09PSAnb2JqZWN0Jykge1xuICAgICAgICBvcHRpb25zID0gcXVlcmllcy5wb3AoKTtcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhcmdzWzBdKSkge1xuICAgICAgICBvcHRpb25zID0gYXJnc1sxXTtcbiAgICAgIH1cblxuICAgICAgdmFyIGZpbGVzID0gZ2V0RmlsZXMoKTtcblxuICAgICAgaWYgKCFxdWVyaWVzLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFxuICAgICAgICAgIGZpbGVzLm1hcChmdW5jdGlvbihmaWxlKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVtb3ZlRmlsZShmaWxlLCBvcHRpb25zKTtcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuXG4gICAgICAvLyB3aGVuIHJlbW92aW5nIGJ5IGluZGV4IHRoZSBpbmRleGVzIHNoaWZ0IGFmdGVyIGVhY2ggZmlsZSByZW1vdmFsIHNvIHdlIG5lZWQgdG8gY29udmVydCBpbmRleGVzIHRvIGlkc1xuICAgICAgdmFyIG1hcHBlZFF1ZXJpZXMgPSBxdWVyaWVzXG4gICAgICAgIC5tYXAoZnVuY3Rpb24ocXVlcnkpIHtcbiAgICAgICAgICByZXR1cm4gaXNOdW1iZXIocXVlcnkpXG4gICAgICAgICAgICA/IGZpbGVzW3F1ZXJ5XVxuICAgICAgICAgICAgICA/IGZpbGVzW3F1ZXJ5XS5pZFxuICAgICAgICAgICAgICA6IG51bGxcbiAgICAgICAgICAgIDogcXVlcnk7XG4gICAgICAgIH0pXG4gICAgICAgIC5maWx0ZXIoZnVuY3Rpb24ocXVlcnkpIHtcbiAgICAgICAgICByZXR1cm4gcXVlcnk7XG4gICAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gbWFwcGVkUXVlcmllcy5tYXAoZnVuY3Rpb24ocSkge1xuICAgICAgICByZXR1cm4gcmVtb3ZlRmlsZShxLCBvcHRpb25zKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICB2YXIgZXhwb3J0cyA9IE9iamVjdC5hc3NpZ24oXG4gICAgICB7fSxcblxuICAgICAgb24oKSxcbiAgICAgIHt9LFxuXG4gICAgICByZWFkV3JpdGVBcGksXG4gICAgICB7fSxcblxuICAgICAgY3JlYXRlT3B0aW9uQVBJKHN0b3JlLCBkZWZhdWx0T3B0aW9ucyksXG4gICAgICB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPdmVycmlkZSBvcHRpb25zIGRlZmluZWQgaW4gb3B0aW9ucyBvYmplY3RcbiAgICAgICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgICAgICovXG4gICAgICAgIHNldE9wdGlvbnM6IHNldE9wdGlvbnMsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIExvYWQgdGhlIGdpdmVuIGZpbGVcbiAgICAgICAgICogQHBhcmFtIHNvdXJjZSAtIHRoZSBzb3VyY2Ugb2YgdGhlIGZpbGUgKGVpdGhlciBhIEZpbGUsIGJhc2U2NCBkYXRhIHVyaSBvciB1cmwpXG4gICAgICAgICAqIEBwYXJhbSBvcHRpb25zIC0gb2JqZWN0LCB7IGluZGV4OiAwIH1cbiAgICAgICAgICovXG4gICAgICAgIGFkZEZpbGU6IGFkZEZpbGUsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIExvYWQgdGhlIGdpdmVuIGZpbGVzXG4gICAgICAgICAqIEBwYXJhbSBzb3VyY2VzIC0gdGhlIHNvdXJjZXMgb2YgdGhlIGZpbGVzIHRvIGxvYWRcbiAgICAgICAgICogQHBhcmFtIG9wdGlvbnMgLSBvYmplY3QsIHsgaW5kZXg6IDAgfVxuICAgICAgICAgKi9cbiAgICAgICAgYWRkRmlsZXM6IGFkZEZpbGVzLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBmaWxlIG9iamVjdHMgbWF0Y2hpbmcgdGhlIGdpdmVuIHF1ZXJ5XG4gICAgICAgICAqIEBwYXJhbSBxdWVyeSB7IHN0cmluZywgbnVtYmVyLCBudWxsIH1cbiAgICAgICAgICovXG4gICAgICAgIGdldEZpbGU6IGdldEZpbGUsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwbG9hZCBmaWxlIHdpdGggZ2l2ZW4gbmFtZVxuICAgICAgICAgKiBAcGFyYW0gcXVlcnkgeyBzdHJpbmcsIG51bWJlciwgbnVsbCAgfVxuICAgICAgICAgKi9cbiAgICAgICAgcHJvY2Vzc0ZpbGU6IHByb2Nlc3NGaWxlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXF1ZXN0IHByZXBhcmUgb3V0cHV0IGZvciBmaWxlIHdpdGggZ2l2ZW4gbmFtZVxuICAgICAgICAgKiBAcGFyYW0gcXVlcnkgeyBzdHJpbmcsIG51bWJlciwgbnVsbCAgfVxuICAgICAgICAgKi9cbiAgICAgICAgcHJlcGFyZUZpbGU6IHByZXBhcmVGaWxlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmVzIGEgZmlsZSBieSBpdHMgbmFtZVxuICAgICAgICAgKiBAcGFyYW0gcXVlcnkgeyBzdHJpbmcsIG51bWJlciwgbnVsbCAgfVxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3ZlRmlsZTogcmVtb3ZlRmlsZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogTW92ZXMgYSBmaWxlIHRvIGEgbmV3IGxvY2F0aW9uIGluIHRoZSBmaWxlcyBsaXN0XG4gICAgICAgICAqL1xuICAgICAgICBtb3ZlRmlsZTogZnVuY3Rpb24gbW92ZUZpbGUocXVlcnksIGluZGV4KSB7XG4gICAgICAgICAgcmV0dXJuIHN0b3JlLmRpc3BhdGNoKCdNT1ZFX0lURU0nLCB7IHF1ZXJ5OiBxdWVyeSwgaW5kZXg6IGluZGV4IH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGFsbCBmaWxlcyAod3JhcHBlZCBpbiBwdWJsaWMgYXBpKVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0RmlsZXM6IGdldEZpbGVzLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdGFydHMgdXBsb2FkaW5nIGFsbCBmaWxlc1xuICAgICAgICAgKi9cbiAgICAgICAgcHJvY2Vzc0ZpbGVzOiBwcm9jZXNzRmlsZXMsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENsZWFycyBhbGwgZmlsZXMgZnJvbSB0aGUgZmlsZXMgbGlzdFxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3ZlRmlsZXM6IHJlbW92ZUZpbGVzLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdGFydHMgcHJlcGFyaW5nIG91dHB1dCBvZiBhbGwgZmlsZXNcbiAgICAgICAgICovXG4gICAgICAgIHByZXBhcmVGaWxlczogcHJlcGFyZUZpbGVzLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTb3J0IGxpc3Qgb2YgZmlsZXNcbiAgICAgICAgICovXG4gICAgICAgIHNvcnQ6IGZ1bmN0aW9uIHNvcnQoY29tcGFyZSkge1xuICAgICAgICAgIHJldHVybiBzdG9yZS5kaXNwYXRjaCgnU09SVCcsIHsgY29tcGFyZTogY29tcGFyZSB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQnJvd3NlIHRoZSBmaWxlIHN5c3RlbSBmb3IgYSBmaWxlXG4gICAgICAgICAqL1xuICAgICAgICBicm93c2U6IGZ1bmN0aW9uIGJyb3dzZSgpIHtcbiAgICAgICAgICAvLyBuZWVkcyB0byBiZSB0cmlnZ2VyIGRpcmVjdGx5IGFzIHVzZXIgYWN0aW9uIG5lZWRzIHRvIGJlIHRyYWNlYWJsZSAoaXMgbm90IHRyYWNlYWJsZSBpbiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUpXG4gICAgICAgICAgdmFyIGlucHV0ID0gdmlldy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ2lucHV0W3R5cGU9ZmlsZV0nKTtcbiAgICAgICAgICBpZiAoaW5wdXQpIHtcbiAgICAgICAgICAgIGlucHV0LmNsaWNrKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXN0cm95cyB0aGUgYXBwXG4gICAgICAgICAqL1xuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICAgIC8vIHJlcXVlc3QgZGVzdHJ1Y3Rpb25cbiAgICAgICAgICBleHBvcnRzLmZpcmUoJ2Rlc3Ryb3knLCB2aWV3LmVsZW1lbnQpO1xuXG4gICAgICAgICAgLy8gc3RvcCBhY3RpdmUgcHJvY2Vzc2VzIChmaWxlIHVwbG9hZHMsIGZldGNoZXMsIHN0dWZmIGxpa2UgdGhhdClcbiAgICAgICAgICAvLyBsb29wIG92ZXIgaXRlbXMgYW5kIGRlcGVuZGluZyBvbiBzdGF0ZXMgY2FsbCBhYm9ydCBmb3Igb25nb2luZyBwcm9jZXNzZXNcbiAgICAgICAgICBzdG9yZS5kaXNwYXRjaCgnQUJPUlRfQUxMJyk7XG5cbiAgICAgICAgICAvLyBkZXN0cm95IHZpZXdcbiAgICAgICAgICB2aWV3Ll9kZXN0cm95KCk7XG5cbiAgICAgICAgICAvLyBzdG9wIGxpc3RlbmluZyB0byByZXNpemVcbiAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgcmVzaXplSGFuZGxlcik7XG5cbiAgICAgICAgICAvLyBzdG9wIGxpc3RlbmluZyB0byB0aGUgdmlzaWJsaXR5Y2hhbmdlIGV2ZW50XG4gICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsIHZpc2liaWxpdHlIYW5kbGVyKTtcblxuICAgICAgICAgIC8vIGRpc3BhdGNoIGRlc3Ryb3lcbiAgICAgICAgICBzdG9yZS5kaXNwYXRjaCgnRElEX0RFU1RST1knKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSW5zZXJ0cyB0aGUgcGx1Z2luIGJlZm9yZSB0aGUgdGFyZ2V0IGVsZW1lbnRcbiAgICAgICAgICovXG4gICAgICAgIGluc2VydEJlZm9yZTogZnVuY3Rpb24gaW5zZXJ0QmVmb3JlJDEoZWxlbWVudCkge1xuICAgICAgICAgIHJldHVybiBpbnNlcnRCZWZvcmUodmlldy5lbGVtZW50LCBlbGVtZW50KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSW5zZXJ0cyB0aGUgcGx1Z2luIGFmdGVyIHRoZSB0YXJnZXQgZWxlbWVudFxuICAgICAgICAgKi9cbiAgICAgICAgaW5zZXJ0QWZ0ZXI6IGZ1bmN0aW9uIGluc2VydEFmdGVyJDEoZWxlbWVudCkge1xuICAgICAgICAgIHJldHVybiBpbnNlcnRBZnRlcih2aWV3LmVsZW1lbnQsIGVsZW1lbnQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBcHBlbmRzIHRoZSBwbHVnaW4gdG8gdGhlIHRhcmdldCBlbGVtZW50XG4gICAgICAgICAqL1xuICAgICAgICBhcHBlbmRUbzogZnVuY3Rpb24gYXBwZW5kVG8oZWxlbWVudCkge1xuICAgICAgICAgIHJldHVybiBlbGVtZW50LmFwcGVuZENoaWxkKHZpZXcuZWxlbWVudCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlcGxhY2VzIGFuIGVsZW1lbnQgd2l0aCB0aGUgYXBwXG4gICAgICAgICAqL1xuICAgICAgICByZXBsYWNlRWxlbWVudDogZnVuY3Rpb24gcmVwbGFjZUVsZW1lbnQoZWxlbWVudCkge1xuICAgICAgICAgIC8vIGluc2VydCB0aGUgYXBwIGJlZm9yZSB0aGUgZWxlbWVudFxuICAgICAgICAgIGluc2VydEJlZm9yZSh2aWV3LmVsZW1lbnQsIGVsZW1lbnQpO1xuXG4gICAgICAgICAgLy8gcmVtb3ZlIHRoZSBvcmlnaW5hbCBlbGVtZW50XG4gICAgICAgICAgZWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsZW1lbnQpO1xuXG4gICAgICAgICAgLy8gcmVtZW1iZXIgb3JpZ2luYWwgZWxlbWVudFxuICAgICAgICAgIG9yaWdpbmFsRWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlc3RvcmVzIHRoZSBvcmlnaW5hbCBlbGVtZW50XG4gICAgICAgICAqL1xuICAgICAgICByZXN0b3JlRWxlbWVudDogZnVuY3Rpb24gcmVzdG9yZUVsZW1lbnQoKSB7XG4gICAgICAgICAgaWYgKCFvcmlnaW5hbEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybjsgLy8gbm8gZWxlbWVudCB0byByZXN0b3JlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gcmVzdG9yZSBvcmlnaW5hbCBlbGVtZW50XG4gICAgICAgICAgaW5zZXJ0QWZ0ZXIob3JpZ2luYWxFbGVtZW50LCB2aWV3LmVsZW1lbnQpO1xuXG4gICAgICAgICAgLy8gcmVtb3ZlIG91ciBlbGVtZW50XG4gICAgICAgICAgdmlldy5lbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodmlldy5lbGVtZW50KTtcblxuICAgICAgICAgIC8vIHJlbW92ZSByZWZlcmVuY2VcbiAgICAgICAgICBvcmlnaW5hbEVsZW1lbnQgPSBudWxsO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGFwcCByb290IGlzIGF0dGFjaGVkIHRvIGdpdmVuIGVsZW1lbnRcbiAgICAgICAgICogQHBhcmFtIGVsZW1lbnRcbiAgICAgICAgICovXG4gICAgICAgIGlzQXR0YWNoZWRUbzogZnVuY3Rpb24gaXNBdHRhY2hlZFRvKGVsZW1lbnQpIHtcbiAgICAgICAgICByZXR1cm4gdmlldy5lbGVtZW50ID09PSBlbGVtZW50IHx8IG9yaWdpbmFsRWxlbWVudCA9PT0gZWxlbWVudDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgcm9vdCBlbGVtZW50XG4gICAgICAgICAqL1xuICAgICAgICBlbGVtZW50OiB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdmlldy5lbGVtZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgY3VycmVudCBwb25kIHN0YXR1c1xuICAgICAgICAgKi9cbiAgICAgICAgc3RhdHVzOiB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RvcmUucXVlcnkoJ0dFVF9TVEFUVVMnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApO1xuXG4gICAgLy8gRG9uZSFcbiAgICBzdG9yZS5kaXNwYXRjaCgnRElEX0lOSVQnKTtcblxuICAgIC8vIGNyZWF0ZSBhY3R1YWwgYXBpIG9iamVjdFxuICAgIHJldHVybiBjcmVhdGVPYmplY3QoZXhwb3J0cyk7XG4gIH07XG5cbiAgdmFyIGNyZWF0ZUFwcE9iamVjdCA9IGZ1bmN0aW9uIGNyZWF0ZUFwcE9iamVjdCgpIHtcbiAgICB2YXIgY3VzdG9tT3B0aW9ucyA9XG4gICAgICBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIC8vIGRlZmF1bHQgb3B0aW9uc1xuICAgIHZhciBkZWZhdWx0T3B0aW9ucyA9IHt9O1xuICAgIGZvcmluKGdldE9wdGlvbnMoKSwgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgZGVmYXVsdE9wdGlvbnNba2V5XSA9IHZhbHVlWzBdO1xuICAgIH0pO1xuXG4gICAgLy8gc2V0IGFwcCBvcHRpb25zXG4gICAgdmFyIGFwcCA9IGNyZWF0ZUFwcChcbiAgICAgIE9iamVjdC5hc3NpZ24oXG4gICAgICAgIHt9LFxuXG4gICAgICAgIGRlZmF1bHRPcHRpb25zLFxuICAgICAgICB7fSxcblxuICAgICAgICBjdXN0b21PcHRpb25zXG4gICAgICApXG4gICAgKTtcblxuICAgIC8vIHJldHVybiB0aGUgcGx1Z2luIGluc3RhbmNlXG4gICAgcmV0dXJuIGFwcDtcbiAgfTtcblxuICB2YXIgbG93ZXJDYXNlRmlyc3RMZXR0ZXIgPSBmdW5jdGlvbiBsb3dlckNhc2VGaXJzdExldHRlcihzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nLmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpICsgc3RyaW5nLnNsaWNlKDEpO1xuICB9O1xuXG4gIHZhciBhdHRyaWJ1dGVOYW1lVG9Qcm9wZXJ0eU5hbWUgPSBmdW5jdGlvbiBhdHRyaWJ1dGVOYW1lVG9Qcm9wZXJ0eU5hbWUoXG4gICAgYXR0cmlidXRlTmFtZVxuICApIHtcbiAgICByZXR1cm4gdG9DYW1lbHMoYXR0cmlidXRlTmFtZS5yZXBsYWNlKC9eZGF0YS0vLCAnJykpO1xuICB9O1xuXG4gIHZhciBtYXBPYmplY3QgPSBmdW5jdGlvbiBtYXBPYmplY3Qob2JqZWN0LCBwcm9wZXJ0eU1hcCkge1xuICAgIC8vIHJlbW92ZSB1bndhbnRlZFxuICAgIGZvcmluKHByb3BlcnR5TWFwLCBmdW5jdGlvbihzZWxlY3RvciwgbWFwcGluZykge1xuICAgICAgZm9yaW4ob2JqZWN0LCBmdW5jdGlvbihwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgICAgICAgLy8gY3JlYXRlIHJlZ2V4cCBzaG9ydGN1dFxuICAgICAgICB2YXIgc2VsZWN0b3JSZWdFeHAgPSBuZXcgUmVnRXhwKHNlbGVjdG9yKTtcblxuICAgICAgICAvLyB0ZXN0cyBpZlxuICAgICAgICB2YXIgbWF0Y2hlcyA9IHNlbGVjdG9yUmVnRXhwLnRlc3QocHJvcGVydHkpO1xuXG4gICAgICAgIC8vIG5vIG1hdGNoLCBza2lwXG4gICAgICAgIGlmICghbWF0Y2hlcykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHRoZXJlJ3MgYSBtYXBwaW5nLCB0aGUgb3JpZ2luYWwgcHJvcGVydHkgaXMgYWx3YXlzIHJlbW92ZWRcbiAgICAgICAgZGVsZXRlIG9iamVjdFtwcm9wZXJ0eV07XG5cbiAgICAgICAgLy8gc2hvdWxkIG9ubHkgcmVtb3ZlLCB3ZSBkb25lIVxuICAgICAgICBpZiAobWFwcGluZyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBtb3ZlIHZhbHVlIHRvIG5ldyBwcm9wZXJ0eVxuICAgICAgICBpZiAoaXNTdHJpbmcobWFwcGluZykpIHtcbiAgICAgICAgICBvYmplY3RbbWFwcGluZ10gPSB2YWx1ZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBtb3ZlIHRvIGdyb3VwXG4gICAgICAgIHZhciBncm91cCA9IG1hcHBpbmcuZ3JvdXA7XG4gICAgICAgIGlmIChpc09iamVjdChtYXBwaW5nKSAmJiAhb2JqZWN0W2dyb3VwXSkge1xuICAgICAgICAgIG9iamVjdFtncm91cF0gPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9iamVjdFtncm91cF1bXG4gICAgICAgICAgbG93ZXJDYXNlRmlyc3RMZXR0ZXIocHJvcGVydHkucmVwbGFjZShzZWxlY3RvclJlZ0V4cCwgJycpKVxuICAgICAgICBdID0gdmFsdWU7XG4gICAgICB9KTtcblxuICAgICAgLy8gZG8gc3VibWFwcGluZ1xuICAgICAgaWYgKG1hcHBpbmcubWFwcGluZykge1xuICAgICAgICBtYXBPYmplY3Qob2JqZWN0W21hcHBpbmcuZ3JvdXBdLCBtYXBwaW5nLm1hcHBpbmcpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIHZhciBnZXRBdHRyaWJ1dGVzQXNPYmplY3QgPSBmdW5jdGlvbiBnZXRBdHRyaWJ1dGVzQXNPYmplY3Qobm9kZSkge1xuICAgIHZhciBhdHRyaWJ1dGVNYXBwaW5nID1cbiAgICAgIGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgLy8gdHVybiBhdHRyaWJ1dGVzIGludG8gb2JqZWN0XG4gICAgdmFyIGF0dHJpYnV0ZXMgPSBbXTtcbiAgICBmb3Jpbihub2RlLmF0dHJpYnV0ZXMsIGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICBhdHRyaWJ1dGVzLnB1c2gobm9kZS5hdHRyaWJ1dGVzW2luZGV4XSk7XG4gICAgfSk7XG5cbiAgICB2YXIgb3V0cHV0ID0gYXR0cmlidXRlc1xuICAgICAgLmZpbHRlcihmdW5jdGlvbihhdHRyaWJ1dGUpIHtcbiAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZS5uYW1lO1xuICAgICAgfSlcbiAgICAgIC5yZWR1Y2UoZnVuY3Rpb24ob2JqLCBhdHRyaWJ1dGUpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXR0cihub2RlLCBhdHRyaWJ1dGUubmFtZSk7XG5cbiAgICAgICAgb2JqW2F0dHJpYnV0ZU5hbWVUb1Byb3BlcnR5TmFtZShhdHRyaWJ1dGUubmFtZSldID1cbiAgICAgICAgICB2YWx1ZSA9PT0gYXR0cmlidXRlLm5hbWUgPyB0cnVlIDogdmFsdWU7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgICB9LCB7fSk7XG5cbiAgICAvLyBkbyBtYXBwaW5nIG9mIG9iamVjdCBwcm9wZXJ0aWVzXG4gICAgbWFwT2JqZWN0KG91dHB1dCwgYXR0cmlidXRlTWFwcGluZyk7XG5cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9O1xuXG4gIHZhciBjcmVhdGVBcHBBdEVsZW1lbnQgPSBmdW5jdGlvbiBjcmVhdGVBcHBBdEVsZW1lbnQoZWxlbWVudCkge1xuICAgIHZhciBvcHRpb25zID1cbiAgICAgIGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICAvLyBob3cgYXR0cmlidXRlcyBvZiB0aGUgaW5wdXQgZWxlbWVudCBhcmUgbWFwcGVkIHRvIHRoZSBvcHRpb25zIGZvciB0aGUgcGx1Z2luXG4gICAgdmFyIGF0dHJpYnV0ZU1hcHBpbmcgPSB7XG4gICAgICAvLyB0cmFuc2xhdGUgdG8gb3RoZXIgbmFtZVxuICAgICAgJ15jbGFzcyQnOiAnY2xhc3NOYW1lJyxcbiAgICAgICdebXVsdGlwbGUkJzogJ2FsbG93TXVsdGlwbGUnLFxuICAgICAgJ15jYXB0dXJlJCc6ICdjYXB0dXJlTWV0aG9kJyxcbiAgICAgICded2Via2l0ZGlyZWN0b3J5JCc6ICdhbGxvd0RpcmVjdG9yaWVzT25seScsXG5cbiAgICAgIC8vIGdyb3VwIHVuZGVyIHNpbmdsZSBwcm9wZXJ0eVxuICAgICAgJ15zZXJ2ZXInOiB7XG4gICAgICAgIGdyb3VwOiAnc2VydmVyJyxcbiAgICAgICAgbWFwcGluZzoge1xuICAgICAgICAgICdecHJvY2Vzcyc6IHtcbiAgICAgICAgICAgIGdyb3VwOiAncHJvY2VzcydcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgJ15yZXZlcnQnOiB7XG4gICAgICAgICAgICBncm91cDogJ3JldmVydCdcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgJ15mZXRjaCc6IHtcbiAgICAgICAgICAgIGdyb3VwOiAnZmV0Y2gnXG4gICAgICAgICAgfSxcblxuICAgICAgICAgICdecmVzdG9yZSc6IHtcbiAgICAgICAgICAgIGdyb3VwOiAncmVzdG9yZSdcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgJ15sb2FkJzoge1xuICAgICAgICAgICAgZ3JvdXA6ICdsb2FkJ1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgLy8gZG9uJ3QgaW5jbHVkZSBpbiBvYmplY3RcbiAgICAgICdedHlwZSQnOiBmYWxzZSxcbiAgICAgICdeZmlsZXMkJzogZmFsc2VcbiAgICB9O1xuXG4gICAgLy8gYWRkIGFkZGl0aW9uYWwgb3B0aW9uIHRyYW5zbGF0b3JzXG4gICAgYXBwbHlGaWx0ZXJzKCdTRVRfQVRUUklCVVRFX1RPX09QVElPTl9NQVAnLCBhdHRyaWJ1dGVNYXBwaW5nKTtcblxuICAgIC8vIGNyZWF0ZSBmaW5hbCBvcHRpb25zIG9iamVjdCBieSBzZXR0aW5nIG9wdGlvbnMgb2JqZWN0IGFuZCB0aGVuIG92ZXJyaWRpbmcgb3B0aW9ucyBzdXBwbGllZCBvbiBlbGVtZW50XG4gICAgdmFyIG1lcmdlZE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTtcblxuICAgIHZhciBhdHRyaWJ1dGVPcHRpb25zID0gZ2V0QXR0cmlidXRlc0FzT2JqZWN0KFxuICAgICAgZWxlbWVudC5ub2RlTmFtZSA9PT0gJ0ZJRUxEU0VUJ1xuICAgICAgICA/IGVsZW1lbnQucXVlcnlTZWxlY3RvcignaW5wdXRbdHlwZT1maWxlXScpXG4gICAgICAgIDogZWxlbWVudCxcbiAgICAgIGF0dHJpYnV0ZU1hcHBpbmdcbiAgICApO1xuXG4gICAgLy8gbWVyZ2Ugd2l0aCBvcHRpb25zIG9iamVjdFxuICAgIE9iamVjdC5rZXlzKGF0dHJpYnV0ZU9wdGlvbnMpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICBpZiAoaXNPYmplY3QoYXR0cmlidXRlT3B0aW9uc1trZXldKSkge1xuICAgICAgICBpZiAoIWlzT2JqZWN0KG1lcmdlZE9wdGlvbnNba2V5XSkpIHtcbiAgICAgICAgICBtZXJnZWRPcHRpb25zW2tleV0gPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuYXNzaWduKG1lcmdlZE9wdGlvbnNba2V5XSwgYXR0cmlidXRlT3B0aW9uc1trZXldKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1lcmdlZE9wdGlvbnNba2V5XSA9IGF0dHJpYnV0ZU9wdGlvbnNba2V5XTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIGlmIHBhcmVudCBpcyBhIGZpZWxkc2V0LCBnZXQgZmlsZXMgZnJvbSBwYXJlbnQgYnkgc2VsZWN0aW5nIGFsbCBpbnB1dCBmaWVsZHMgdGhhdCBhcmUgbm90IGZpbGUgdXBsb2FkIGZpZWxkc1xuICAgIC8vIHRoZXNlIHdpbGwgdGhlbiBiZSBhdXRvbWF0aWNhbGx5IHNldCB0byB0aGUgaW5pdGlhbCBmaWxlc1xuICAgIG1lcmdlZE9wdGlvbnMuZmlsZXMgPSAob3B0aW9ucy5maWxlcyB8fCBbXSkuY29uY2F0KFxuICAgICAgQXJyYXkuZnJvbShlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0Om5vdChbdHlwZT1maWxlXSknKSkubWFwKFxuICAgICAgICBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzb3VyY2U6IGlucHV0LnZhbHVlLFxuICAgICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgICB0eXBlOiBpbnB1dC5kYXRhc2V0LnR5cGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICApXG4gICAgKTtcblxuICAgIC8vIGJ1aWxkIHBsdWdpblxuICAgIHZhciBhcHAgPSBjcmVhdGVBcHBPYmplY3QobWVyZ2VkT3B0aW9ucyk7XG5cbiAgICAvLyBhZGQgYWxyZWFkeSBzZWxlY3RlZCBmaWxlc1xuICAgIGlmIChlbGVtZW50LmZpbGVzKSB7XG4gICAgICBBcnJheS5mcm9tKGVsZW1lbnQuZmlsZXMpLmZvckVhY2goZnVuY3Rpb24oZmlsZSkge1xuICAgICAgICBhcHAuYWRkRmlsZShmaWxlKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIHJlcGxhY2UgdGhlIHRhcmdldCBlbGVtZW50XG4gICAgYXBwLnJlcGxhY2VFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgLy8gZXhwb3NlXG4gICAgcmV0dXJuIGFwcDtcbiAgfTtcblxuICAvLyBpZiBhbiBlbGVtZW50IGlzIHBhc3NlZCwgd2UgY3JlYXRlIHRoZSBpbnN0YW5jZSBhdCB0aGF0IGVsZW1lbnQsIGlmIG5vdCwgd2UganVzdCBjcmVhdGUgYW4gdXAgb2JqZWN0XG4gIHZhciBjcmVhdGVBcHAkMSA9IGZ1bmN0aW9uIGNyZWF0ZUFwcCgpIHtcbiAgICByZXR1cm4gaXNOb2RlKGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXSlcbiAgICAgID8gY3JlYXRlQXBwQXRFbGVtZW50LmFwcGx5KHZvaWQgMCwgYXJndW1lbnRzKVxuICAgICAgOiBjcmVhdGVBcHBPYmplY3QuYXBwbHkodm9pZCAwLCBhcmd1bWVudHMpO1xuICB9O1xuXG4gIHZhciBQUklWQVRFX01FVEhPRFMgPSBbJ2ZpcmUnLCAnX3JlYWQnLCAnX3dyaXRlJ107XG5cbiAgdmFyIGNyZWF0ZUFwcEFQSSA9IGZ1bmN0aW9uIGNyZWF0ZUFwcEFQSShhcHApIHtcbiAgICB2YXIgYXBpID0ge307XG5cbiAgICBjb3B5T2JqZWN0UHJvcGVydGllc1RvT2JqZWN0KGFwcCwgYXBpLCBQUklWQVRFX01FVEhPRFMpO1xuXG4gICAgcmV0dXJuIGFwaTtcbiAgfTtcblxuICAvKipcbiAgICogUmVwbGFjZXMgcGxhY2Vob2xkZXJzIGluIGdpdmVuIHN0cmluZyB3aXRoIHJlcGxhY2VtZW50c1xuICAgKiBAcGFyYW0gc3RyaW5nIC0gXCJGb28ge2Jhcn1cIlwiXG4gICAqIEBwYXJhbSByZXBsYWNlbWVudHMgLSB7IFwiYmFyXCI6IDEwIH1cbiAgICovXG4gIHZhciByZXBsYWNlSW5TdHJpbmcgPSBmdW5jdGlvbiByZXBsYWNlSW5TdHJpbmcoc3RyaW5nLCByZXBsYWNlbWVudHMpIHtcbiAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoLyg/OnsoW2EtekEtWl0rKX0pL2csIGZ1bmN0aW9uKG1hdGNoLCBncm91cCkge1xuICAgICAgcmV0dXJuIHJlcGxhY2VtZW50c1tncm91cF07XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIGNyZWF0ZVdvcmtlciA9IGZ1bmN0aW9uIGNyZWF0ZVdvcmtlcihmbikge1xuICAgIHZhciB3b3JrZXJCbG9iID0gbmV3IEJsb2IoWycoJywgZm4udG9TdHJpbmcoKSwgJykoKSddLCB7XG4gICAgICB0eXBlOiAnYXBwbGljYXRpb24vamF2YXNjcmlwdCdcbiAgICB9KTtcblxuICAgIHZhciB3b3JrZXJVUkwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKHdvcmtlckJsb2IpO1xuICAgIHZhciB3b3JrZXIgPSBuZXcgV29ya2VyKHdvcmtlclVSTCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHJhbnNmZXI6IGZ1bmN0aW9uIHRyYW5zZmVyKG1lc3NhZ2UsIGNiKSB7fSxcbiAgICAgIHBvc3Q6IGZ1bmN0aW9uIHBvc3QobWVzc2FnZSwgY2IsIHRyYW5zZmVyTGlzdCkge1xuICAgICAgICB2YXIgaWQgPSBnZXRVbmlxdWVJZCgpO1xuXG4gICAgICAgIHdvcmtlci5vbm1lc3NhZ2UgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgaWYgKGUuZGF0YS5pZCA9PT0gaWQpIHtcbiAgICAgICAgICAgIGNiKGUuZGF0YS5tZXNzYWdlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgd29ya2VyLnBvc3RNZXNzYWdlKFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2VcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgdHJhbnNmZXJMaXN0XG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgdGVybWluYXRlOiBmdW5jdGlvbiB0ZXJtaW5hdGUoKSB7XG4gICAgICAgIHdvcmtlci50ZXJtaW5hdGUoKTtcbiAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTCh3b3JrZXJVUkwpO1xuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgdmFyIGxvYWRJbWFnZSA9IGZ1bmN0aW9uIGxvYWRJbWFnZSh1cmwpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgaW1nID0gbmV3IEltYWdlKCk7XG4gICAgICBpbWcub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlc29sdmUoaW1nKTtcbiAgICAgIH07XG4gICAgICBpbWcub25lcnJvciA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfTtcbiAgICAgIGltZy5zcmMgPSB1cmw7XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIHJlbmFtZUZpbGUgPSBmdW5jdGlvbiByZW5hbWVGaWxlKGZpbGUsIG5hbWUpIHtcbiAgICB2YXIgcmVuYW1lZEZpbGUgPSBmaWxlLnNsaWNlKDAsIGZpbGUuc2l6ZSwgZmlsZS50eXBlKTtcbiAgICByZW5hbWVkRmlsZS5sYXN0TW9kaWZpZWREYXRlID0gZmlsZS5sYXN0TW9kaWZpZWREYXRlO1xuICAgIHJlbmFtZWRGaWxlLm5hbWUgPSBuYW1lO1xuICAgIHJldHVybiByZW5hbWVkRmlsZTtcbiAgfTtcblxuICB2YXIgY29weUZpbGUgPSBmdW5jdGlvbiBjb3B5RmlsZShmaWxlKSB7XG4gICAgcmV0dXJuIHJlbmFtZUZpbGUoZmlsZSwgZmlsZS5uYW1lKTtcbiAgfTtcblxuICAvLyBhbHJlYWR5IHJlZ2lzdGVyZWQgcGx1Z2lucyAoY2FuJ3QgcmVnaXN0ZXIgdHdpY2UpXG4gIHZhciByZWdpc3RlcmVkUGx1Z2lucyA9IFtdO1xuXG4gIC8vIHBhc3MgdXRpbHMgdG8gcGx1Z2luXG4gIHZhciBjcmVhdGVBcHBQbHVnaW4gPSBmdW5jdGlvbiBjcmVhdGVBcHBQbHVnaW4ocGx1Z2luKSB7XG4gICAgLy8gYWxyZWFkeSByZWdpc3RlcmVkXG4gICAgaWYgKHJlZ2lzdGVyZWRQbHVnaW5zLmluY2x1ZGVzKHBsdWdpbikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyByZW1lbWJlciB0aGlzIHBsdWdpblxuICAgIHJlZ2lzdGVyZWRQbHVnaW5zLnB1c2gocGx1Z2luKTtcblxuICAgIC8vIHNldHVwIVxuICAgIHZhciBwbHVnaW5PdXRsaW5lID0gcGx1Z2luKHtcbiAgICAgIGFkZEZpbHRlcjogYWRkRmlsdGVyLFxuICAgICAgdXRpbHM6IHtcbiAgICAgICAgVHlwZTogVHlwZSxcbiAgICAgICAgZm9yaW46IGZvcmluLFxuICAgICAgICBpc1N0cmluZzogaXNTdHJpbmcsXG4gICAgICAgIGlzRmlsZTogaXNGaWxlLFxuICAgICAgICB0b05hdHVyYWxGaWxlU2l6ZTogdG9OYXR1cmFsRmlsZVNpemUsXG4gICAgICAgIHJlcGxhY2VJblN0cmluZzogcmVwbGFjZUluU3RyaW5nLFxuICAgICAgICBnZXRFeHRlbnNpb25Gcm9tRmlsZW5hbWU6IGdldEV4dGVuc2lvbkZyb21GaWxlbmFtZSxcbiAgICAgICAgZ2V0RmlsZW5hbWVXaXRob3V0RXh0ZW5zaW9uOiBnZXRGaWxlbmFtZVdpdGhvdXRFeHRlbnNpb24sXG4gICAgICAgIGd1ZXNzdGltYXRlTWltZVR5cGU6IGd1ZXNzdGltYXRlTWltZVR5cGUsXG4gICAgICAgIGdldEZpbGVGcm9tQmxvYjogZ2V0RmlsZUZyb21CbG9iLFxuICAgICAgICBnZXRGaWxlbmFtZUZyb21VUkw6IGdldEZpbGVuYW1lRnJvbVVSTCxcbiAgICAgICAgY3JlYXRlUm91dGU6IGNyZWF0ZVJvdXRlLFxuICAgICAgICBjcmVhdGVXb3JrZXI6IGNyZWF0ZVdvcmtlcixcbiAgICAgICAgY3JlYXRlVmlldzogY3JlYXRlVmlldyxcbiAgICAgICAgY3JlYXRlSXRlbUFQSTogY3JlYXRlSXRlbUFQSSxcbiAgICAgICAgbG9hZEltYWdlOiBsb2FkSW1hZ2UsXG4gICAgICAgIGNvcHlGaWxlOiBjb3B5RmlsZSxcbiAgICAgICAgcmVuYW1lRmlsZTogcmVuYW1lRmlsZSxcbiAgICAgICAgY3JlYXRlQmxvYjogY3JlYXRlQmxvYixcbiAgICAgICAgYXBwbHlGaWx0ZXJDaGFpbjogYXBwbHlGaWx0ZXJDaGFpbixcbiAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgZ2V0TnVtZXJpY0FzcGVjdFJhdGlvRnJvbVN0cmluZzogZ2V0TnVtZXJpY0FzcGVjdFJhdGlvRnJvbVN0cmluZ1xuICAgICAgfSxcblxuICAgICAgdmlld3M6IHtcbiAgICAgICAgZmlsZUFjdGlvbkJ1dHRvbjogZmlsZUFjdGlvbkJ1dHRvblxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gYWRkIHBsdWdpbiBvcHRpb25zIHRvIGRlZmF1bHQgb3B0aW9uc1xuICAgIGV4dGVuZERlZmF1bHRPcHRpb25zKHBsdWdpbk91dGxpbmUub3B0aW9ucyk7XG4gIH07XG5cbiAgLy8gZmVhdHVyZSBkZXRlY3Rpb24gdXNlZCBieSBzdXBwb3J0ZWQoKSBtZXRob2RcbiAgdmFyIGlzT3BlcmFNaW5pID0gZnVuY3Rpb24gaXNPcGVyYU1pbmkoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh3aW5kb3cub3BlcmFtaW5pKSA9PT0gJ1tvYmplY3QgT3BlcmFNaW5pXSdcbiAgICApO1xuICB9O1xuICB2YXIgaGFzUHJvbWlzZXMgPSBmdW5jdGlvbiBoYXNQcm9taXNlcygpIHtcbiAgICByZXR1cm4gJ1Byb21pc2UnIGluIHdpbmRvdztcbiAgfTtcbiAgdmFyIGhhc0Jsb2JTbGljZSA9IGZ1bmN0aW9uIGhhc0Jsb2JTbGljZSgpIHtcbiAgICByZXR1cm4gJ3NsaWNlJyBpbiBCbG9iLnByb3RvdHlwZTtcbiAgfTtcbiAgdmFyIGhhc0NyZWF0ZU9iamVjdFVSTCA9IGZ1bmN0aW9uIGhhc0NyZWF0ZU9iamVjdFVSTCgpIHtcbiAgICByZXR1cm4gJ1VSTCcgaW4gd2luZG93ICYmICdjcmVhdGVPYmplY3RVUkwnIGluIHdpbmRvdy5VUkw7XG4gIH07XG4gIHZhciBoYXNWaXNpYmlsaXR5ID0gZnVuY3Rpb24gaGFzVmlzaWJpbGl0eSgpIHtcbiAgICByZXR1cm4gJ3Zpc2liaWxpdHlTdGF0ZScgaW4gZG9jdW1lbnQ7XG4gIH07XG4gIHZhciBoYXNUaW1pbmcgPSBmdW5jdGlvbiBoYXNUaW1pbmcoKSB7XG4gICAgcmV0dXJuICdwZXJmb3JtYW5jZScgaW4gd2luZG93O1xuICB9OyAvLyBpT1MgOC54XG4gIHZhciBoYXNDU1NTdXBwb3J0cyA9IGZ1bmN0aW9uIGhhc0NTU1N1cHBvcnRzKCkge1xuICAgIHJldHVybiAnc3VwcG9ydHMnIGluICh3aW5kb3cuQ1NTIHx8IHt9KTtcbiAgfTsgLy8gdXNlIHRvIGRldGVjdCBTYWZhcmkgOStcbiAgdmFyIGlzSUUxMSA9IGZ1bmN0aW9uIGlzSUUxMSgpIHtcbiAgICByZXR1cm4gL01TSUV8VHJpZGVudC8udGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gIH07XG5cbiAgdmFyIHN1cHBvcnRlZCA9IChmdW5jdGlvbigpIHtcbiAgICAvLyBSdW5zIGltbWVkaWF0ZWx5IGFuZCB0aGVuIHJlbWVtYmVycyByZXN1bHQgZm9yIHN1YnNlcXVlbnQgY2FsbHNcbiAgICB2YXIgaXNTdXBwb3J0ZWQgPVxuICAgICAgLy8gSGFzIHRvIGJlIGEgYnJvd3NlclxuICAgICAgaXNCcm93c2VyKCkgJiZcbiAgICAgIC8vIENhbid0IHJ1biBvbiBPcGVyYSBNaW5pIGR1ZSB0byBsYWNrIG9mIGV2ZXJ5dGhpbmdcbiAgICAgICFpc09wZXJhTWluaSgpICYmXG4gICAgICAvLyBSZXF1aXJlIHRoZXNlIEFQSXMgdG8gZmVhdHVyZSBkZXRlY3QgYSBtb2Rlcm4gYnJvd3NlclxuICAgICAgaGFzVmlzaWJpbGl0eSgpICYmXG4gICAgICBoYXNQcm9taXNlcygpICYmXG4gICAgICBoYXNCbG9iU2xpY2UoKSAmJlxuICAgICAgaGFzQ3JlYXRlT2JqZWN0VVJMKCkgJiZcbiAgICAgIGhhc1RpbWluZygpICYmXG4gICAgICAvLyBkb2Vzbid0IG5lZWQgQ1NTU3VwcG9ydHMgYnV0IGlzIGEgZ29vZCB3YXkgdG8gZGV0ZWN0IFNhZmFyaSA5KyAod2UgZG8gd2FudCB0byBzdXBwb3J0IElFMTEgdGhvdWdoKVxuICAgICAgKGhhc0NTU1N1cHBvcnRzKCkgfHwgaXNJRTExKCkpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGlzU3VwcG9ydGVkO1xuICAgIH07XG4gIH0pKCk7XG5cbiAgLyoqXG4gICAqIFBsdWdpbiBpbnRlcm5hbCBzdGF0ZSAob3ZlciBhbGwgaW5zdGFuY2VzKVxuICAgKi9cbiAgdmFyIHN0YXRlID0ge1xuICAgIC8vIGFjdGl2ZSBhcHAgaW5zdGFuY2VzLCB1c2VkIHRvIHJlZHJhdyB0aGUgYXBwcyBhbmQgdG8gZmluZCB0aGUgbGF0ZXJcbiAgICBhcHBzOiBbXVxuICB9O1xuXG4gIC8vIHBsdWdpbiBuYW1lXG4gIHZhciBuYW1lID0gJ2ZpbGVwb25kJztcblxuICAvKipcbiAgICogUHVibGljIFBsdWdpbiBtZXRob2RzXG4gICAqL1xuICB2YXIgZm4gPSBmdW5jdGlvbiBmbigpIHt9O1xuICBleHBvcnRzLlN0YXR1cyA9IHt9O1xuICBleHBvcnRzLkZpbGVTdGF0dXMgPSB7fTtcbiAgZXhwb3J0cy5GaWxlT3JpZ2luID0ge307XG4gIGV4cG9ydHMuT3B0aW9uVHlwZXMgPSB7fTtcbiAgZXhwb3J0cy5jcmVhdGUgPSBmbjtcbiAgZXhwb3J0cy5kZXN0cm95ID0gZm47XG4gIGV4cG9ydHMucGFyc2UgPSBmbjtcbiAgZXhwb3J0cy5maW5kID0gZm47XG4gIGV4cG9ydHMucmVnaXN0ZXJQbHVnaW4gPSBmbjtcbiAgZXhwb3J0cy5nZXRPcHRpb25zID0gZm47XG4gIGV4cG9ydHMuc2V0T3B0aW9ucyA9IGZuO1xuXG4gIC8vIGlmIG5vdCBzdXBwb3J0ZWQsIG5vIEFQSVxuICBpZiAoc3VwcG9ydGVkKCkpIHtcbiAgICAvLyBzdGFydCBwYWludGVyIGFuZCBmaXJlIGxvYWQgZXZlbnRcbiAgICBjcmVhdGVQYWludGVyKFxuICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgIHN0YXRlLmFwcHMuZm9yRWFjaChmdW5jdGlvbihhcHApIHtcbiAgICAgICAgICByZXR1cm4gYXBwLl9yZWFkKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGZ1bmN0aW9uKHRzKSB7XG4gICAgICAgIHN0YXRlLmFwcHMuZm9yRWFjaChmdW5jdGlvbihhcHApIHtcbiAgICAgICAgICByZXR1cm4gYXBwLl93cml0ZSh0cyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICk7XG5cbiAgICAvLyBmaXJlIGxvYWRlZCBldmVudCBzbyB3ZSBrbm93IHdoZW4gRmlsZVBvbmQgaXMgYXZhaWxhYmxlXG4gICAgdmFyIGRpc3BhdGNoID0gZnVuY3Rpb24gZGlzcGF0Y2goKSB7XG4gICAgICAvLyBsZXQgb3RoZXJzIGtub3cgd2UgaGF2ZSBhcmVhIHJlYWR5XG4gICAgICBkb2N1bWVudC5kaXNwYXRjaEV2ZW50KFxuICAgICAgICBuZXcgQ3VzdG9tRXZlbnQoJ0ZpbGVQb25kOmxvYWRlZCcsIHtcbiAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgIHN1cHBvcnRlZDogc3VwcG9ydGVkLFxuICAgICAgICAgICAgY3JlYXRlOiBleHBvcnRzLmNyZWF0ZSxcbiAgICAgICAgICAgIGRlc3Ryb3k6IGV4cG9ydHMuZGVzdHJveSxcbiAgICAgICAgICAgIHBhcnNlOiBleHBvcnRzLnBhcnNlLFxuICAgICAgICAgICAgZmluZDogZXhwb3J0cy5maW5kLFxuICAgICAgICAgICAgcmVnaXN0ZXJQbHVnaW46IGV4cG9ydHMucmVnaXN0ZXJQbHVnaW4sXG4gICAgICAgICAgICBzZXRPcHRpb25zOiBleHBvcnRzLnNldE9wdGlvbnNcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICApO1xuXG4gICAgICAvLyBjbGVhbiB1cCBldmVudFxuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGRpc3BhdGNoKTtcbiAgICB9O1xuXG4gICAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgIT09ICdsb2FkaW5nJykge1xuICAgICAgLy8gbW92ZSB0byBiYWNrIG9mIGV4ZWN1dGlvbiBxdWV1ZSwgRmlsZVBvbmQgc2hvdWxkIGhhdmUgYmVlbiBleHBvcnRlZCBieSB0aGVuXG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZGlzcGF0Y2goKTtcbiAgICAgIH0sIDApO1xuICAgIH0gZWxzZSB7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgZGlzcGF0Y2gpO1xuICAgIH1cblxuICAgIC8vIHVwZGF0ZXMgdGhlIE9wdGlvblR5cGVzIG9iamVjdCBiYXNlZCBvbiB0aGUgY3VycmVudCBvcHRpb25zXG4gICAgdmFyIHVwZGF0ZU9wdGlvblR5cGVzID0gZnVuY3Rpb24gdXBkYXRlT3B0aW9uVHlwZXMoKSB7XG4gICAgICByZXR1cm4gZm9yaW4oZ2V0T3B0aW9ucygpLCBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgIGV4cG9ydHMuT3B0aW9uVHlwZXNba2V5XSA9IHZhbHVlWzFdO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGV4cG9ydHMuU3RhdHVzID0gT2JqZWN0LmFzc2lnbih7fSwgU3RhdHVzKTtcbiAgICBleHBvcnRzLkZpbGVPcmlnaW4gPSBPYmplY3QuYXNzaWduKHt9LCBGaWxlT3JpZ2luKTtcbiAgICBleHBvcnRzLkZpbGVTdGF0dXMgPSBPYmplY3QuYXNzaWduKHt9LCBJdGVtU3RhdHVzKTtcblxuICAgIGV4cG9ydHMuT3B0aW9uVHlwZXMgPSB7fTtcbiAgICB1cGRhdGVPcHRpb25UeXBlcygpO1xuXG4gICAgLy8gY3JlYXRlIG1ldGhvZCwgY3JlYXRlcyBhcHBzIGFuZCBhZGRzIHRoZW0gdG8gdGhlIGFwcCBhcnJheVxuICAgIGV4cG9ydHMuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKCkge1xuICAgICAgdmFyIGFwcCA9IGNyZWF0ZUFwcCQxLmFwcGx5KHZvaWQgMCwgYXJndW1lbnRzKTtcbiAgICAgIGFwcC5vbignZGVzdHJveScsIGV4cG9ydHMuZGVzdHJveSk7XG4gICAgICBzdGF0ZS5hcHBzLnB1c2goYXBwKTtcbiAgICAgIHJldHVybiBjcmVhdGVBcHBBUEkoYXBwKTtcbiAgICB9O1xuXG4gICAgLy8gZGVzdHJveXMgYXBwcyBhbmQgcmVtb3ZlcyB0aGVtIGZyb20gdGhlIGFwcCBhcnJheVxuICAgIGV4cG9ydHMuZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koaG9vaykge1xuICAgICAgLy8gcmV0dXJucyB0cnVlIGlmIHRoZSBhcHAgd2FzIGRlc3Ryb3llZCBzdWNjZXNzZnVsbHlcbiAgICAgIHZhciBpbmRleFRvUmVtb3ZlID0gc3RhdGUuYXBwcy5maW5kSW5kZXgoZnVuY3Rpb24oYXBwKSB7XG4gICAgICAgIHJldHVybiBhcHAuaXNBdHRhY2hlZFRvKGhvb2spO1xuICAgICAgfSk7XG4gICAgICBpZiAoaW5kZXhUb1JlbW92ZSA+PSAwKSB7XG4gICAgICAgIC8vIHJlbW92ZSBmcm9tIGFwcHNcbiAgICAgICAgdmFyIGFwcCA9IHN0YXRlLmFwcHMuc3BsaWNlKGluZGV4VG9SZW1vdmUsIDEpWzBdO1xuXG4gICAgICAgIC8vIHJlc3RvcmUgb3JpZ2luYWwgZG9tIGVsZW1lbnRcbiAgICAgICAgYXBwLnJlc3RvcmVFbGVtZW50KCk7XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgLy8gcGFyc2VzIHRoZSBnaXZlbiBjb250ZXh0IGZvciBwbHVnaW5zIChkb2VzIG5vdCBpbmNsdWRlIHRoZSBjb250ZXh0IGVsZW1lbnQgaXRzZWxmKVxuICAgIGV4cG9ydHMucGFyc2UgPSBmdW5jdGlvbiBwYXJzZShjb250ZXh0KSB7XG4gICAgICAvLyBnZXQgYWxsIHBvc3NpYmxlIGhvb2tzXG4gICAgICB2YXIgbWF0Y2hlZEhvb2tzID0gQXJyYXkuZnJvbShjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoJy4nICsgbmFtZSkpO1xuXG4gICAgICAvLyBmaWx0ZXIgb3V0IGFscmVhZHkgYWN0aXZlIGhvb2tzXG4gICAgICB2YXIgbmV3SG9va3MgPSBtYXRjaGVkSG9va3MuZmlsdGVyKGZ1bmN0aW9uKG5ld0hvb2spIHtcbiAgICAgICAgcmV0dXJuICFzdGF0ZS5hcHBzLmZpbmQoZnVuY3Rpb24oYXBwKSB7XG4gICAgICAgICAgcmV0dXJuIGFwcC5pc0F0dGFjaGVkVG8obmV3SG9vayk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIGNyZWF0ZSBuZXcgaW5zdGFuY2UgZm9yIGVhY2ggaG9va1xuICAgICAgcmV0dXJuIG5ld0hvb2tzLm1hcChmdW5jdGlvbihob29rKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLmNyZWF0ZShob29rKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyByZXR1cm5zIGFuIGFwcCBiYXNlZCBvbiB0aGUgZ2l2ZW4gZWxlbWVudCBob29rXG4gICAgZXhwb3J0cy5maW5kID0gZnVuY3Rpb24gZmluZChob29rKSB7XG4gICAgICB2YXIgYXBwID0gc3RhdGUuYXBwcy5maW5kKGZ1bmN0aW9uKGFwcCkge1xuICAgICAgICByZXR1cm4gYXBwLmlzQXR0YWNoZWRUbyhob29rKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKCFhcHApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gY3JlYXRlQXBwQVBJKGFwcCk7XG4gICAgfTtcblxuICAgIC8vIGFkZHMgYSBwbHVnaW4gZXh0ZW5zaW9uXG4gICAgZXhwb3J0cy5yZWdpc3RlclBsdWdpbiA9IGZ1bmN0aW9uIHJlZ2lzdGVyUGx1Z2luKCkge1xuICAgICAgZm9yIChcbiAgICAgICAgdmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBwbHVnaW5zID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDtcbiAgICAgICAgX2tleSA8IF9sZW47XG4gICAgICAgIF9rZXkrK1xuICAgICAgKSB7XG4gICAgICAgIHBsdWdpbnNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIC8vIHJlZ2lzdGVyIHBsdWdpbnNcbiAgICAgIHBsdWdpbnMuZm9yRWFjaChjcmVhdGVBcHBQbHVnaW4pO1xuXG4gICAgICAvLyB1cGRhdGUgT3B0aW9uVHlwZXMsIGVhY2ggcGx1Z2luIG1pZ2h0IGhhdmUgZXh0ZW5kZWQgdGhlIGRlZmF1bHQgb3B0aW9uc1xuICAgICAgdXBkYXRlT3B0aW9uVHlwZXMoKTtcbiAgICB9O1xuXG4gICAgZXhwb3J0cy5nZXRPcHRpb25zID0gZnVuY3Rpb24gZ2V0T3B0aW9ucyQxKCkge1xuICAgICAgdmFyIG9wdHMgPSB7fTtcbiAgICAgIGZvcmluKGdldE9wdGlvbnMoKSwgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICBvcHRzW2tleV0gPSB2YWx1ZVswXTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG9wdHM7XG4gICAgfTtcblxuICAgIGV4cG9ydHMuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uIHNldE9wdGlvbnMkMShvcHRzKSB7XG4gICAgICBpZiAoaXNPYmplY3Qob3B0cykpIHtcbiAgICAgICAgLy8gdXBkYXRlIGV4aXN0aW5nIHBsdWdpbnNcbiAgICAgICAgc3RhdGUuYXBwcy5mb3JFYWNoKGZ1bmN0aW9uKGFwcCkge1xuICAgICAgICAgIGFwcC5zZXRPcHRpb25zKG9wdHMpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBvdmVycmlkZSBkZWZhdWx0c1xuICAgICAgICBzZXRPcHRpb25zKG9wdHMpO1xuICAgICAgfVxuXG4gICAgICAvLyByZXR1cm4gbmV3IG9wdGlvbnNcbiAgICAgIHJldHVybiBleHBvcnRzLmdldE9wdGlvbnMoKTtcbiAgICB9O1xuICB9XG5cbiAgZXhwb3J0cy5zdXBwb3J0ZWQgPSBzdXBwb3J0ZWQ7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn0pO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/filepond/dist/filepond.js\n");

/***/ }),

/***/ "./node_modules/filepond/dist/filepond.min.css":
/*!*****************************************************!*\
  !*** ./node_modules/filepond/dist/filepond.min.css ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\nvar content = __webpack_require__(/*! !../../css-loader??ref--9-1!../../postcss-loader/src??ref--9-2!./filepond.min.css */ \"./node_modules/css-loader/index.js?!./node_modules/postcss-loader/src/index.js?!./node_modules/filepond/dist/filepond.min.css\");\n\nif(typeof content === 'string') content = [[module.i, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = __webpack_require__(/*! ../../style-loader/lib/addStyles.js */ \"./node_modules/style-loader/lib/addStyles.js\")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(false) {}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmlsZXBvbmQvZGlzdC9maWxlcG9uZC5taW4uY3NzP2U0OGQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUNBLGNBQWMsbUJBQU8sQ0FBQyx3TkFBc0c7O0FBRTVILDRDQUE0QyxRQUFTOztBQUVyRDtBQUNBOzs7O0FBSUEsZUFBZTs7QUFFZjtBQUNBOztBQUVBLGFBQWEsbUJBQU8sQ0FBQyx5RkFBc0M7O0FBRTNEOztBQUVBLEdBQUcsS0FBVSxFQUFFIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2ZpbGVwb25kL2Rpc3QvZmlsZXBvbmQubWluLmNzcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9jc3MtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTktMSEuLi8uLi9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3JlZi0tOS0yIS4vZmlsZXBvbmQubWluLmNzc1wiKTtcblxuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG5cbnZhciB0cmFuc2Zvcm07XG52YXIgaW5zZXJ0SW50bztcblxuXG5cbnZhciBvcHRpb25zID0ge1wiaG1yXCI6dHJ1ZX1cblxub3B0aW9ucy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cbm9wdGlvbnMuaW5zZXJ0SW50byA9IHVuZGVmaW5lZDtcblxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanNcIikoY29udGVudCwgb3B0aW9ucyk7XG5cbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuXG5pZihtb2R1bGUuaG90KSB7XG5cdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi9jc3MtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTktMSEuLi8uLi9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3JlZi0tOS0yIS4vZmlsZXBvbmQubWluLmNzc1wiLCBmdW5jdGlvbigpIHtcblx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL2Nzcy1sb2FkZXIvaW5kZXguanM/P3JlZi0tOS0xIS4uLy4uL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cmVmLS05LTIhLi9maWxlcG9uZC5taW4uY3NzXCIpO1xuXG5cdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cblx0XHR2YXIgbG9jYWxzID0gKGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdHZhciBrZXksIGlkeCA9IDA7XG5cblx0XHRcdGZvcihrZXkgaW4gYSkge1xuXHRcdFx0XHRpZighYiB8fCBhW2tleV0gIT09IGJba2V5XSkgcmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRpZHgrKztcblx0XHRcdH1cblxuXHRcdFx0Zm9yKGtleSBpbiBiKSBpZHgtLTtcblxuXHRcdFx0cmV0dXJuIGlkeCA9PT0gMDtcblx0XHR9KGNvbnRlbnQubG9jYWxzLCBuZXdDb250ZW50LmxvY2FscykpO1xuXG5cdFx0aWYoIWxvY2FscykgdGhyb3cgbmV3IEVycm9yKCdBYm9ydGluZyBDU1MgSE1SIGR1ZSB0byBjaGFuZ2VkIGNzcy1tb2R1bGVzIGxvY2Fscy4nKTtcblxuXHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0fSk7XG5cblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/filepond/dist/filepond.min.css\n");

/***/ }),

/***/ "./node_modules/style-loader/lib/addStyles.js":
/*!****************************************************!*\
  !*** ./node_modules/style-loader/lib/addStyles.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\nvar stylesInDom = {};\n\nvar\tmemoize = function (fn) {\n\tvar memo;\n\n\treturn function () {\n\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\treturn memo;\n\t};\n};\n\nvar isOldIE = memoize(function () {\n\t// Test for IE <= 9 as proposed by Browserhacks\n\t// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n\t// Tests for existence of standard globals is to allow style-loader\n\t// to operate correctly into non-standard environments\n\t// @see https://github.com/webpack-contrib/style-loader/issues/177\n\treturn window && document && document.all && !window.atob;\n});\n\nvar getTarget = function (target, parent) {\n  if (parent){\n    return parent.querySelector(target);\n  }\n  return document.querySelector(target);\n};\n\nvar getElement = (function (fn) {\n\tvar memo = {};\n\n\treturn function(target, parent) {\n                // If passing function in options, then use it for resolve \"head\" element.\n                // Useful for Shadow Root style i.e\n                // {\n                //   insertInto: function () { return document.querySelector(\"#foo\").shadowRoot }\n                // }\n                if (typeof target === 'function') {\n                        return target();\n                }\n                if (typeof memo[target] === \"undefined\") {\n\t\t\tvar styleTarget = getTarget.call(this, target, parent);\n\t\t\t// Special case to return head of iframe instead of iframe itself\n\t\t\tif (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n\t\t\t\ttry {\n\t\t\t\t\t// This will throw an exception if access to iframe is blocked\n\t\t\t\t\t// due to cross-origin restrictions\n\t\t\t\t\tstyleTarget = styleTarget.contentDocument.head;\n\t\t\t\t} catch(e) {\n\t\t\t\t\tstyleTarget = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemo[target] = styleTarget;\n\t\t}\n\t\treturn memo[target]\n\t};\n})();\n\nvar singleton = null;\nvar\tsingletonCounter = 0;\nvar\tstylesInsertedAtTop = [];\n\nvar\tfixUrls = __webpack_require__(/*! ./urls */ \"./node_modules/style-loader/lib/urls.js\");\n\nmodule.exports = function(list, options) {\n\tif (typeof DEBUG !== \"undefined\" && DEBUG) {\n\t\tif (typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t}\n\n\toptions = options || {};\n\n\toptions.attrs = typeof options.attrs === \"object\" ? options.attrs : {};\n\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (!options.singleton && typeof options.singleton !== \"boolean\") options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the <head> element\n        if (!options.insertInto) options.insertInto = \"head\";\n\n\t// By default, add <style> tags to the bottom of the target\n\tif (!options.insertAt) options.insertAt = \"bottom\";\n\n\tvar styles = listToStyles(list, options);\n\n\taddStylesToDom(styles, options);\n\n\treturn function update (newList) {\n\t\tvar mayRemove = [];\n\n\t\tfor (var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList, options);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\n\t\tfor (var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();\n\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n};\n\nfunction addStylesToDom (styles, options) {\n\tfor (var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles (list, options) {\n\tvar styles = [];\n\tvar newStyles = {};\n\n\tfor (var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = options.base ? item[0] + options.base : item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\n\t\tif(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse newStyles[id].parts.push(part);\n\t}\n\n\treturn styles;\n}\n\nfunction insertStyleElement (options, style) {\n\tvar target = getElement(options.insertInto)\n\n\tif (!target) {\n\t\tthrow new Error(\"Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.\");\n\t}\n\n\tvar lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];\n\n\tif (options.insertAt === \"top\") {\n\t\tif (!lastStyleElementInsertedAtTop) {\n\t\t\ttarget.insertBefore(style, target.firstChild);\n\t\t} else if (lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\ttarget.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\ttarget.appendChild(style);\n\t\t}\n\t\tstylesInsertedAtTop.push(style);\n\t} else if (options.insertAt === \"bottom\") {\n\t\ttarget.appendChild(style);\n\t} else if (typeof options.insertAt === \"object\" && options.insertAt.before) {\n\t\tvar nextSibling = getElement(options.insertAt.before, target);\n\t\ttarget.insertBefore(style, nextSibling);\n\t} else {\n\t\tthrow new Error(\"[Style Loader]\\n\\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\\n Must be 'top', 'bottom', or Object.\\n (https://github.com/webpack-contrib/style-loader#insertat)\\n\");\n\t}\n}\n\nfunction removeStyleElement (style) {\n\tif (style.parentNode === null) return false;\n\tstyle.parentNode.removeChild(style);\n\n\tvar idx = stylesInsertedAtTop.indexOf(style);\n\tif(idx >= 0) {\n\t\tstylesInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement (options) {\n\tvar style = document.createElement(\"style\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\n\tif(options.attrs.nonce === undefined) {\n\t\tvar nonce = getNonce();\n\t\tif (nonce) {\n\t\t\toptions.attrs.nonce = nonce;\n\t\t}\n\t}\n\n\taddAttrs(style, options.attrs);\n\tinsertStyleElement(options, style);\n\n\treturn style;\n}\n\nfunction createLinkElement (options) {\n\tvar link = document.createElement(\"link\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\toptions.attrs.rel = \"stylesheet\";\n\n\taddAttrs(link, options.attrs);\n\tinsertStyleElement(options, link);\n\n\treturn link;\n}\n\nfunction addAttrs (el, attrs) {\n\tObject.keys(attrs).forEach(function (key) {\n\t\tel.setAttribute(key, attrs[key]);\n\t});\n}\n\nfunction getNonce() {\n\tif (false) {}\n\n\treturn __webpack_require__.nc;\n}\n\nfunction addStyle (obj, options) {\n\tvar style, update, remove, result;\n\n\t// If a transform function was defined, run it on the css\n\tif (options.transform && obj.css) {\n\t    result = typeof options.transform === 'function'\n\t\t ? options.transform(obj.css) \n\t\t : options.transform.default(obj.css);\n\n\t    if (result) {\n\t    \t// If transform returns a value, use that instead of the original css.\n\t    \t// This allows running runtime transformations on the css.\n\t    \tobj.css = result;\n\t    } else {\n\t    \t// If the transform function returns a falsy value, don't add this css.\n\t    \t// This allows conditional loading of css\n\t    \treturn function() {\n\t    \t\t// noop\n\t    \t};\n\t    }\n\t}\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\n\t\tstyle = singleton || (singleton = createStyleElement(options));\n\n\t\tupdate = applyToSingletonTag.bind(null, style, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, style, styleIndex, true);\n\n\t} else if (\n\t\tobj.sourceMap &&\n\t\ttypeof URL === \"function\" &&\n\t\ttypeof URL.createObjectURL === \"function\" &&\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\n\t\ttypeof Blob === \"function\" &&\n\t\ttypeof btoa === \"function\"\n\t) {\n\t\tstyle = createLinkElement(options);\n\t\tupdate = updateLink.bind(null, style, options);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\n\t\t\tif(style.href) URL.revokeObjectURL(style.href);\n\t\t};\n\t} else {\n\t\tstyle = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, style);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle (newObj) {\n\t\tif (newObj) {\n\t\t\tif (\n\t\t\t\tnewObj.css === obj.css &&\n\t\t\t\tnewObj.media === obj.media &&\n\t\t\t\tnewObj.sourceMap === obj.sourceMap\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\n\t\treturn textStore.filter(Boolean).join('\\n');\n\t};\n})();\n\nfunction applyToSingletonTag (style, index, remove, obj) {\n\tvar css = remove ? \"\" : obj.css;\n\n\tif (style.styleSheet) {\n\t\tstyle.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = style.childNodes;\n\n\t\tif (childNodes[index]) style.removeChild(childNodes[index]);\n\n\t\tif (childNodes.length) {\n\t\t\tstyle.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyle.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag (style, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\n\tif(media) {\n\t\tstyle.setAttribute(\"media\", media)\n\t}\n\n\tif(style.styleSheet) {\n\t\tstyle.styleSheet.cssText = css;\n\t} else {\n\t\twhile(style.firstChild) {\n\t\t\tstyle.removeChild(style.firstChild);\n\t\t}\n\n\t\tstyle.appendChild(document.createTextNode(css));\n\t}\n}\n\nfunction updateLink (link, options, obj) {\n\tvar css = obj.css;\n\tvar sourceMap = obj.sourceMap;\n\n\t/*\n\t\tIf convertToAbsoluteUrls isn't defined, but sourcemaps are enabled\n\t\tand there is no publicPath defined then lets turn convertToAbsoluteUrls\n\t\ton by default.  Otherwise default to the convertToAbsoluteUrls option\n\t\tdirectly\n\t*/\n\tvar autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;\n\n\tif (options.convertToAbsoluteUrls || autoFixUrls) {\n\t\tcss = fixUrls(css);\n\t}\n\n\tif (sourceMap) {\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t}\n\n\tvar blob = new Blob([css], { type: \"text/css\" });\n\n\tvar oldSrc = link.href;\n\n\tlink.href = URL.createObjectURL(blob);\n\n\tif(oldSrc) URL.revokeObjectURL(oldSrc);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanM/Njg0NCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBLGNBQWMsbUJBQU8sQ0FBQyx1REFBUTs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQixtQkFBbUI7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLHNCQUFzQjtBQUN2Qzs7QUFFQTtBQUNBLG1CQUFtQiwyQkFBMkI7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsbUJBQW1CO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQkFBaUIsMkJBQTJCO0FBQzVDO0FBQ0E7O0FBRUEsUUFBUSx1QkFBdUI7QUFDL0I7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQSxpQkFBaUIsdUJBQXVCO0FBQ3hDO0FBQ0E7O0FBRUEsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYzs7QUFFZCxrREFBa0Qsc0JBQXNCO0FBQ3hFO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0EsS0FBSyxLQUF3QyxFQUFFLEVBRTdDOztBQUVGLFFBQVEsc0JBQWlCO0FBQ3pCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDs7QUFFQSw2QkFBNkIsbUJBQW1COztBQUVoRDs7QUFFQTs7QUFFQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cblxudmFyIHN0eWxlc0luRG9tID0ge307XG5cbnZhclx0bWVtb2l6ZSA9IGZ1bmN0aW9uIChmbikge1xuXHR2YXIgbWVtbztcblxuXHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0eXBlb2YgbWVtbyA9PT0gXCJ1bmRlZmluZWRcIikgbWVtbyA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIG1lbW87XG5cdH07XG59O1xuXG52YXIgaXNPbGRJRSA9IG1lbW9pemUoZnVuY3Rpb24gKCkge1xuXHQvLyBUZXN0IGZvciBJRSA8PSA5IGFzIHByb3Bvc2VkIGJ5IEJyb3dzZXJoYWNrc1xuXHQvLyBAc2VlIGh0dHA6Ly9icm93c2VyaGFja3MuY29tLyNoYWNrLWU3MWQ4NjkyZjY1MzM0MTczZmVlNzE1YzIyMmNiODA1XG5cdC8vIFRlc3RzIGZvciBleGlzdGVuY2Ugb2Ygc3RhbmRhcmQgZ2xvYmFscyBpcyB0byBhbGxvdyBzdHlsZS1sb2FkZXJcblx0Ly8gdG8gb3BlcmF0ZSBjb3JyZWN0bHkgaW50byBub24tc3RhbmRhcmQgZW52aXJvbm1lbnRzXG5cdC8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi9zdHlsZS1sb2FkZXIvaXNzdWVzLzE3N1xuXHRyZXR1cm4gd2luZG93ICYmIGRvY3VtZW50ICYmIGRvY3VtZW50LmFsbCAmJiAhd2luZG93LmF0b2I7XG59KTtcblxudmFyIGdldFRhcmdldCA9IGZ1bmN0aW9uICh0YXJnZXQsIHBhcmVudCkge1xuICBpZiAocGFyZW50KXtcbiAgICByZXR1cm4gcGFyZW50LnF1ZXJ5U2VsZWN0b3IodGFyZ2V0KTtcbiAgfVxuICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpO1xufTtcblxudmFyIGdldEVsZW1lbnQgPSAoZnVuY3Rpb24gKGZuKSB7XG5cdHZhciBtZW1vID0ge307XG5cblx0cmV0dXJuIGZ1bmN0aW9uKHRhcmdldCwgcGFyZW50KSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgcGFzc2luZyBmdW5jdGlvbiBpbiBvcHRpb25zLCB0aGVuIHVzZSBpdCBmb3IgcmVzb2x2ZSBcImhlYWRcIiBlbGVtZW50LlxuICAgICAgICAgICAgICAgIC8vIFVzZWZ1bCBmb3IgU2hhZG93IFJvb3Qgc3R5bGUgaS5lXG4gICAgICAgICAgICAgICAgLy8ge1xuICAgICAgICAgICAgICAgIC8vICAgaW5zZXJ0SW50bzogZnVuY3Rpb24gKCkgeyByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNmb29cIikuc2hhZG93Um9vdCB9XG4gICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbWVtb1t0YXJnZXRdID09PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0XHR2YXIgc3R5bGVUYXJnZXQgPSBnZXRUYXJnZXQuY2FsbCh0aGlzLCB0YXJnZXQsIHBhcmVudCk7XG5cdFx0XHQvLyBTcGVjaWFsIGNhc2UgdG8gcmV0dXJuIGhlYWQgb2YgaWZyYW1lIGluc3RlYWQgb2YgaWZyYW1lIGl0c2VsZlxuXHRcdFx0aWYgKHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCAmJiBzdHlsZVRhcmdldCBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCkge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdC8vIFRoaXMgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24gaWYgYWNjZXNzIHRvIGlmcmFtZSBpcyBibG9ja2VkXG5cdFx0XHRcdFx0Ly8gZHVlIHRvIGNyb3NzLW9yaWdpbiByZXN0cmljdGlvbnNcblx0XHRcdFx0XHRzdHlsZVRhcmdldCA9IHN0eWxlVGFyZ2V0LmNvbnRlbnREb2N1bWVudC5oZWFkO1xuXHRcdFx0XHR9IGNhdGNoKGUpIHtcblx0XHRcdFx0XHRzdHlsZVRhcmdldCA9IG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdG1lbW9bdGFyZ2V0XSA9IHN0eWxlVGFyZ2V0O1xuXHRcdH1cblx0XHRyZXR1cm4gbWVtb1t0YXJnZXRdXG5cdH07XG59KSgpO1xuXG52YXIgc2luZ2xldG9uID0gbnVsbDtcbnZhclx0c2luZ2xldG9uQ291bnRlciA9IDA7XG52YXJcdHN0eWxlc0luc2VydGVkQXRUb3AgPSBbXTtcblxudmFyXHRmaXhVcmxzID0gcmVxdWlyZShcIi4vdXJsc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihsaXN0LCBvcHRpb25zKSB7XG5cdGlmICh0eXBlb2YgREVCVUcgIT09IFwidW5kZWZpbmVkXCIgJiYgREVCVUcpIHtcblx0XHRpZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcIm9iamVjdFwiKSB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc3R5bGUtbG9hZGVyIGNhbm5vdCBiZSB1c2VkIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRcIik7XG5cdH1cblxuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRvcHRpb25zLmF0dHJzID0gdHlwZW9mIG9wdGlvbnMuYXR0cnMgPT09IFwib2JqZWN0XCIgPyBvcHRpb25zLmF0dHJzIDoge307XG5cblx0Ly8gRm9yY2Ugc2luZ2xlLXRhZyBzb2x1dGlvbiBvbiBJRTYtOSwgd2hpY2ggaGFzIGEgaGFyZCBsaW1pdCBvbiB0aGUgIyBvZiA8c3R5bGU+XG5cdC8vIHRhZ3MgaXQgd2lsbCBhbGxvdyBvbiBhIHBhZ2Vcblx0aWYgKCFvcHRpb25zLnNpbmdsZXRvbiAmJiB0eXBlb2Ygb3B0aW9ucy5zaW5nbGV0b24gIT09IFwiYm9vbGVhblwiKSBvcHRpb25zLnNpbmdsZXRvbiA9IGlzT2xkSUUoKTtcblxuXHQvLyBCeSBkZWZhdWx0LCBhZGQgPHN0eWxlPiB0YWdzIHRvIHRoZSA8aGVhZD4gZWxlbWVudFxuICAgICAgICBpZiAoIW9wdGlvbnMuaW5zZXJ0SW50bykgb3B0aW9ucy5pbnNlcnRJbnRvID0gXCJoZWFkXCI7XG5cblx0Ly8gQnkgZGVmYXVsdCwgYWRkIDxzdHlsZT4gdGFncyB0byB0aGUgYm90dG9tIG9mIHRoZSB0YXJnZXRcblx0aWYgKCFvcHRpb25zLmluc2VydEF0KSBvcHRpb25zLmluc2VydEF0ID0gXCJib3R0b21cIjtcblxuXHR2YXIgc3R5bGVzID0gbGlzdFRvU3R5bGVzKGxpc3QsIG9wdGlvbnMpO1xuXG5cdGFkZFN0eWxlc1RvRG9tKHN0eWxlcywgb3B0aW9ucyk7XG5cblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZSAobmV3TGlzdCkge1xuXHRcdHZhciBtYXlSZW1vdmUgPSBbXTtcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IHN0eWxlc1tpXTtcblx0XHRcdHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xuXG5cdFx0XHRkb21TdHlsZS5yZWZzLS07XG5cdFx0XHRtYXlSZW1vdmUucHVzaChkb21TdHlsZSk7XG5cdFx0fVxuXG5cdFx0aWYobmV3TGlzdCkge1xuXHRcdFx0dmFyIG5ld1N0eWxlcyA9IGxpc3RUb1N0eWxlcyhuZXdMaXN0LCBvcHRpb25zKTtcblx0XHRcdGFkZFN0eWxlc1RvRG9tKG5ld1N0eWxlcywgb3B0aW9ucyk7XG5cdFx0fVxuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBtYXlSZW1vdmUubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBkb21TdHlsZSA9IG1heVJlbW92ZVtpXTtcblxuXHRcdFx0aWYoZG9tU3R5bGUucmVmcyA9PT0gMCkge1xuXHRcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSBkb21TdHlsZS5wYXJ0c1tqXSgpO1xuXG5cdFx0XHRcdGRlbGV0ZSBzdHlsZXNJbkRvbVtkb21TdHlsZS5pZF07XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufTtcblxuZnVuY3Rpb24gYWRkU3R5bGVzVG9Eb20gKHN0eWxlcywgb3B0aW9ucykge1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xuXHRcdHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xuXG5cdFx0aWYoZG9tU3R5bGUpIHtcblx0XHRcdGRvbVN0eWxlLnJlZnMrKztcblxuXHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGRvbVN0eWxlLnBhcnRzW2pdKGl0ZW0ucGFydHNbal0pO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IoOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRkb21TdHlsZS5wYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIHBhcnRzID0gW107XG5cblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdHBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xuXHRcdFx0fVxuXG5cdFx0XHRzdHlsZXNJbkRvbVtpdGVtLmlkXSA9IHtpZDogaXRlbS5pZCwgcmVmczogMSwgcGFydHM6IHBhcnRzfTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gbGlzdFRvU3R5bGVzIChsaXN0LCBvcHRpb25zKSB7XG5cdHZhciBzdHlsZXMgPSBbXTtcblx0dmFyIG5ld1N0eWxlcyA9IHt9O1xuXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBpdGVtID0gbGlzdFtpXTtcblx0XHR2YXIgaWQgPSBvcHRpb25zLmJhc2UgPyBpdGVtWzBdICsgb3B0aW9ucy5iYXNlIDogaXRlbVswXTtcblx0XHR2YXIgY3NzID0gaXRlbVsxXTtcblx0XHR2YXIgbWVkaWEgPSBpdGVtWzJdO1xuXHRcdHZhciBzb3VyY2VNYXAgPSBpdGVtWzNdO1xuXHRcdHZhciBwYXJ0ID0ge2NzczogY3NzLCBtZWRpYTogbWVkaWEsIHNvdXJjZU1hcDogc291cmNlTWFwfTtcblxuXHRcdGlmKCFuZXdTdHlsZXNbaWRdKSBzdHlsZXMucHVzaChuZXdTdHlsZXNbaWRdID0ge2lkOiBpZCwgcGFydHM6IFtwYXJ0XX0pO1xuXHRcdGVsc2UgbmV3U3R5bGVzW2lkXS5wYXJ0cy5wdXNoKHBhcnQpO1xuXHR9XG5cblx0cmV0dXJuIHN0eWxlcztcbn1cblxuZnVuY3Rpb24gaW5zZXJ0U3R5bGVFbGVtZW50IChvcHRpb25zLCBzdHlsZSkge1xuXHR2YXIgdGFyZ2V0ID0gZ2V0RWxlbWVudChvcHRpb25zLmluc2VydEludG8pXG5cblx0aWYgKCF0YXJnZXQpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBmaW5kIGEgc3R5bGUgdGFyZ2V0LiBUaGlzIHByb2JhYmx5IG1lYW5zIHRoYXQgdGhlIHZhbHVlIGZvciB0aGUgJ2luc2VydEludG8nIHBhcmFtZXRlciBpcyBpbnZhbGlkLlwiKTtcblx0fVxuXG5cdHZhciBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCA9IHN0eWxlc0luc2VydGVkQXRUb3Bbc3R5bGVzSW5zZXJ0ZWRBdFRvcC5sZW5ndGggLSAxXTtcblxuXHRpZiAob3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJ0b3BcIikge1xuXHRcdGlmICghbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3ApIHtcblx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoc3R5bGUsIHRhcmdldC5maXJzdENoaWxkKTtcblx0XHR9IGVsc2UgaWYgKGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wLm5leHRTaWJsaW5nKSB7XG5cdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlLCBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRhcmdldC5hcHBlbmRDaGlsZChzdHlsZSk7XG5cdFx0fVxuXHRcdHN0eWxlc0luc2VydGVkQXRUb3AucHVzaChzdHlsZSk7XG5cdH0gZWxzZSBpZiAob3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJib3R0b21cIikge1xuXHRcdHRhcmdldC5hcHBlbmRDaGlsZChzdHlsZSk7XG5cdH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwib2JqZWN0XCIgJiYgb3B0aW9ucy5pbnNlcnRBdC5iZWZvcmUpIHtcblx0XHR2YXIgbmV4dFNpYmxpbmcgPSBnZXRFbGVtZW50KG9wdGlvbnMuaW5zZXJ0QXQuYmVmb3JlLCB0YXJnZXQpO1xuXHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoc3R5bGUsIG5leHRTaWJsaW5nKTtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJbU3R5bGUgTG9hZGVyXVxcblxcbiBJbnZhbGlkIHZhbHVlIGZvciBwYXJhbWV0ZXIgJ2luc2VydEF0JyAoJ29wdGlvbnMuaW5zZXJ0QXQnKSBmb3VuZC5cXG4gTXVzdCBiZSAndG9wJywgJ2JvdHRvbScsIG9yIE9iamVjdC5cXG4gKGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrLWNvbnRyaWIvc3R5bGUtbG9hZGVyI2luc2VydGF0KVxcblwiKTtcblx0fVxufVxuXG5mdW5jdGlvbiByZW1vdmVTdHlsZUVsZW1lbnQgKHN0eWxlKSB7XG5cdGlmIChzdHlsZS5wYXJlbnROb2RlID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cdHN0eWxlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGUpO1xuXG5cdHZhciBpZHggPSBzdHlsZXNJbnNlcnRlZEF0VG9wLmluZGV4T2Yoc3R5bGUpO1xuXHRpZihpZHggPj0gMCkge1xuXHRcdHN0eWxlc0luc2VydGVkQXRUb3Auc3BsaWNlKGlkeCwgMSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlU3R5bGVFbGVtZW50IChvcHRpb25zKSB7XG5cdHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcblxuXHRpZihvcHRpb25zLmF0dHJzLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuXHRcdG9wdGlvbnMuYXR0cnMudHlwZSA9IFwidGV4dC9jc3NcIjtcblx0fVxuXG5cdGlmKG9wdGlvbnMuYXR0cnMubm9uY2UgPT09IHVuZGVmaW5lZCkge1xuXHRcdHZhciBub25jZSA9IGdldE5vbmNlKCk7XG5cdFx0aWYgKG5vbmNlKSB7XG5cdFx0XHRvcHRpb25zLmF0dHJzLm5vbmNlID0gbm9uY2U7XG5cdFx0fVxuXHR9XG5cblx0YWRkQXR0cnMoc3R5bGUsIG9wdGlvbnMuYXR0cnMpO1xuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgc3R5bGUpO1xuXG5cdHJldHVybiBzdHlsZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTGlua0VsZW1lbnQgKG9wdGlvbnMpIHtcblx0dmFyIGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiKTtcblxuXHRpZihvcHRpb25zLmF0dHJzLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuXHRcdG9wdGlvbnMuYXR0cnMudHlwZSA9IFwidGV4dC9jc3NcIjtcblx0fVxuXHRvcHRpb25zLmF0dHJzLnJlbCA9IFwic3R5bGVzaGVldFwiO1xuXG5cdGFkZEF0dHJzKGxpbmssIG9wdGlvbnMuYXR0cnMpO1xuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgbGluayk7XG5cblx0cmV0dXJuIGxpbms7XG59XG5cbmZ1bmN0aW9uIGFkZEF0dHJzIChlbCwgYXR0cnMpIHtcblx0T2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHRcdGVsLnNldEF0dHJpYnV0ZShrZXksIGF0dHJzW2tleV0pO1xuXHR9KTtcbn1cblxuZnVuY3Rpb24gZ2V0Tm9uY2UoKSB7XG5cdGlmICh0eXBlb2YgX193ZWJwYWNrX25vbmNlX18gPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHRyZXR1cm4gX193ZWJwYWNrX25vbmNlX187XG59XG5cbmZ1bmN0aW9uIGFkZFN0eWxlIChvYmosIG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlLCB1cGRhdGUsIHJlbW92ZSwgcmVzdWx0O1xuXG5cdC8vIElmIGEgdHJhbnNmb3JtIGZ1bmN0aW9uIHdhcyBkZWZpbmVkLCBydW4gaXQgb24gdGhlIGNzc1xuXHRpZiAob3B0aW9ucy50cmFuc2Zvcm0gJiYgb2JqLmNzcykge1xuXHQgICAgcmVzdWx0ID0gdHlwZW9mIG9wdGlvbnMudHJhbnNmb3JtID09PSAnZnVuY3Rpb24nXG5cdFx0ID8gb3B0aW9ucy50cmFuc2Zvcm0ob2JqLmNzcykgXG5cdFx0IDogb3B0aW9ucy50cmFuc2Zvcm0uZGVmYXVsdChvYmouY3NzKTtcblxuXHQgICAgaWYgKHJlc3VsdCkge1xuXHQgICAgXHQvLyBJZiB0cmFuc2Zvcm0gcmV0dXJucyBhIHZhbHVlLCB1c2UgdGhhdCBpbnN0ZWFkIG9mIHRoZSBvcmlnaW5hbCBjc3MuXG5cdCAgICBcdC8vIFRoaXMgYWxsb3dzIHJ1bm5pbmcgcnVudGltZSB0cmFuc2Zvcm1hdGlvbnMgb24gdGhlIGNzcy5cblx0ICAgIFx0b2JqLmNzcyA9IHJlc3VsdDtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICBcdC8vIElmIHRoZSB0cmFuc2Zvcm0gZnVuY3Rpb24gcmV0dXJucyBhIGZhbHN5IHZhbHVlLCBkb24ndCBhZGQgdGhpcyBjc3MuXG5cdCAgICBcdC8vIFRoaXMgYWxsb3dzIGNvbmRpdGlvbmFsIGxvYWRpbmcgb2YgY3NzXG5cdCAgICBcdHJldHVybiBmdW5jdGlvbigpIHtcblx0ICAgIFx0XHQvLyBub29wXG5cdCAgICBcdH07XG5cdCAgICB9XG5cdH1cblxuXHRpZiAob3B0aW9ucy5zaW5nbGV0b24pIHtcblx0XHR2YXIgc3R5bGVJbmRleCA9IHNpbmdsZXRvbkNvdW50ZXIrKztcblxuXHRcdHN0eWxlID0gc2luZ2xldG9uIHx8IChzaW5nbGV0b24gPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucykpO1xuXG5cdFx0dXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCBmYWxzZSk7XG5cdFx0cmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCB0cnVlKTtcblxuXHR9IGVsc2UgaWYgKFxuXHRcdG9iai5zb3VyY2VNYXAgJiZcblx0XHR0eXBlb2YgVVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgVVJMLmNyZWF0ZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIFVSTC5yZXZva2VPYmplY3RVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBCbG9iID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgYnRvYSA9PT0gXCJmdW5jdGlvblwiXG5cdCkge1xuXHRcdHN0eWxlID0gY3JlYXRlTGlua0VsZW1lbnQob3B0aW9ucyk7XG5cdFx0dXBkYXRlID0gdXBkYXRlTGluay5iaW5kKG51bGwsIHN0eWxlLCBvcHRpb25zKTtcblx0XHRyZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuXG5cdFx0XHRpZihzdHlsZS5ocmVmKSBVUkwucmV2b2tlT2JqZWN0VVJMKHN0eWxlLmhyZWYpO1xuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0c3R5bGUgPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucyk7XG5cdFx0dXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlKTtcblx0XHRyZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuXHRcdH07XG5cdH1cblxuXHR1cGRhdGUob2JqKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlU3R5bGUgKG5ld09iaikge1xuXHRcdGlmIChuZXdPYmopIHtcblx0XHRcdGlmIChcblx0XHRcdFx0bmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJlxuXHRcdFx0XHRuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJlxuXHRcdFx0XHRuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwXG5cdFx0XHQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR1cGRhdGUob2JqID0gbmV3T2JqKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmVtb3ZlKCk7XG5cdFx0fVxuXHR9O1xufVxuXG52YXIgcmVwbGFjZVRleHQgPSAoZnVuY3Rpb24gKCkge1xuXHR2YXIgdGV4dFN0b3JlID0gW107XG5cblx0cmV0dXJuIGZ1bmN0aW9uIChpbmRleCwgcmVwbGFjZW1lbnQpIHtcblx0XHR0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnQ7XG5cblx0XHRyZXR1cm4gdGV4dFN0b3JlLmZpbHRlcihCb29sZWFuKS5qb2luKCdcXG4nKTtcblx0fTtcbn0pKCk7XG5cbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcgKHN0eWxlLCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcblx0dmFyIGNzcyA9IHJlbW92ZSA/IFwiXCIgOiBvYmouY3NzO1xuXG5cdGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcyk7XG5cdH0gZWxzZSB7XG5cdFx0dmFyIGNzc05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpO1xuXHRcdHZhciBjaGlsZE5vZGVzID0gc3R5bGUuY2hpbGROb2RlcztcblxuXHRcdGlmIChjaGlsZE5vZGVzW2luZGV4XSkgc3R5bGUucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO1xuXG5cdFx0aWYgKGNoaWxkTm9kZXMubGVuZ3RoKSB7XG5cdFx0XHRzdHlsZS5pbnNlcnRCZWZvcmUoY3NzTm9kZSwgY2hpbGROb2Rlc1tpbmRleF0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzdHlsZS5hcHBlbmRDaGlsZChjc3NOb2RlKTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gYXBwbHlUb1RhZyAoc3R5bGUsIG9iaikge1xuXHR2YXIgY3NzID0gb2JqLmNzcztcblx0dmFyIG1lZGlhID0gb2JqLm1lZGlhO1xuXG5cdGlmKG1lZGlhKSB7XG5cdFx0c3R5bGUuc2V0QXR0cmlidXRlKFwibWVkaWFcIiwgbWVkaWEpXG5cdH1cblxuXHRpZihzdHlsZS5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuXHR9IGVsc2Uge1xuXHRcdHdoaWxlKHN0eWxlLmZpcnN0Q2hpbGQpIHtcblx0XHRcdHN0eWxlLnJlbW92ZUNoaWxkKHN0eWxlLmZpcnN0Q2hpbGQpO1xuXHRcdH1cblxuXHRcdHN0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUxpbmsgKGxpbmssIG9wdGlvbnMsIG9iaikge1xuXHR2YXIgY3NzID0gb2JqLmNzcztcblx0dmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XG5cblx0Lypcblx0XHRJZiBjb252ZXJ0VG9BYnNvbHV0ZVVybHMgaXNuJ3QgZGVmaW5lZCwgYnV0IHNvdXJjZW1hcHMgYXJlIGVuYWJsZWRcblx0XHRhbmQgdGhlcmUgaXMgbm8gcHVibGljUGF0aCBkZWZpbmVkIHRoZW4gbGV0cyB0dXJuIGNvbnZlcnRUb0Fic29sdXRlVXJsc1xuXHRcdG9uIGJ5IGRlZmF1bHQuICBPdGhlcndpc2UgZGVmYXVsdCB0byB0aGUgY29udmVydFRvQWJzb2x1dGVVcmxzIG9wdGlvblxuXHRcdGRpcmVjdGx5XG5cdCovXG5cdHZhciBhdXRvRml4VXJscyA9IG9wdGlvbnMuY29udmVydFRvQWJzb2x1dGVVcmxzID09PSB1bmRlZmluZWQgJiYgc291cmNlTWFwO1xuXG5cdGlmIChvcHRpb25zLmNvbnZlcnRUb0Fic29sdXRlVXJscyB8fCBhdXRvRml4VXJscykge1xuXHRcdGNzcyA9IGZpeFVybHMoY3NzKTtcblx0fVxuXG5cdGlmIChzb3VyY2VNYXApIHtcblx0XHQvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yNjYwMzg3NVxuXHRcdGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIgKyBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpICsgXCIgKi9cIjtcblx0fVxuXG5cdHZhciBibG9iID0gbmV3IEJsb2IoW2Nzc10sIHsgdHlwZTogXCJ0ZXh0L2Nzc1wiIH0pO1xuXG5cdHZhciBvbGRTcmMgPSBsaW5rLmhyZWY7XG5cblx0bGluay5ocmVmID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcblxuXHRpZihvbGRTcmMpIFVSTC5yZXZva2VPYmplY3RVUkwob2xkU3JjKTtcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/style-loader/lib/addStyles.js\n");

/***/ }),

/***/ "./node_modules/style-loader/lib/urls.js":
/*!***********************************************!*\
  !*** ./node_modules/style-loader/lib/urls.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\n/**\n * When source maps are enabled, `style-loader` uses a link element with a data-uri to\n * embed the css on the page. This breaks all relative urls because now they are relative to a\n * bundle instead of the current page.\n *\n * One solution is to only use full urls, but that may be impossible.\n *\n * Instead, this function \"fixes\" the relative urls to be absolute according to the current page location.\n *\n * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.\n *\n */\n\nmodule.exports = function (css) {\n  // get current location\n  var location = typeof window !== \"undefined\" && window.location;\n\n  if (!location) {\n    throw new Error(\"fixUrls requires window.location\");\n  }\n\n\t// blank or null?\n\tif (!css || typeof css !== \"string\") {\n\t  return css;\n  }\n\n  var baseUrl = location.protocol + \"//\" + location.host;\n  var currentDir = baseUrl + location.pathname.replace(/\\/[^\\/]*$/, \"/\");\n\n\t// convert each url(...)\n\t/*\n\tThis regular expression is just a way to recursively match brackets within\n\ta string.\n\n\t /url\\s*\\(  = Match on the word \"url\" with any whitespace after it and then a parens\n\t   (  = Start a capturing group\n\t     (?:  = Start a non-capturing group\n\t         [^)(]  = Match anything that isn't a parentheses\n\t         |  = OR\n\t         \\(  = Match a start parentheses\n\t             (?:  = Start another non-capturing groups\n\t                 [^)(]+  = Match anything that isn't a parentheses\n\t                 |  = OR\n\t                 \\(  = Match a start parentheses\n\t                     [^)(]*  = Match anything that isn't a parentheses\n\t                 \\)  = Match a end parentheses\n\t             )  = End Group\n              *\\) = Match anything and then a close parens\n          )  = Close non-capturing group\n          *  = Match anything\n       )  = Close capturing group\n\t \\)  = Match a close parens\n\n\t /gi  = Get all matches, not the first.  Be case insensitive.\n\t */\n\tvar fixedCss = css.replace(/url\\s*\\(((?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)\\)/gi, function(fullMatch, origUrl) {\n\t\t// strip quotes (if they exist)\n\t\tvar unquotedOrigUrl = origUrl\n\t\t\t.trim()\n\t\t\t.replace(/^\"(.*)\"$/, function(o, $1){ return $1; })\n\t\t\t.replace(/^'(.*)'$/, function(o, $1){ return $1; });\n\n\t\t// already a full url? no change\n\t\tif (/^(#|data:|http:\\/\\/|https:\\/\\/|file:\\/\\/\\/|\\s*$)/i.test(unquotedOrigUrl)) {\n\t\t  return fullMatch;\n\t\t}\n\n\t\t// convert the url to a full url\n\t\tvar newUrl;\n\n\t\tif (unquotedOrigUrl.indexOf(\"//\") === 0) {\n\t\t  \t//TODO: should we add protocol?\n\t\t\tnewUrl = unquotedOrigUrl;\n\t\t} else if (unquotedOrigUrl.indexOf(\"/\") === 0) {\n\t\t\t// path should be relative to the base url\n\t\t\tnewUrl = baseUrl + unquotedOrigUrl; // already starts with '/'\n\t\t} else {\n\t\t\t// path should be relative to current directory\n\t\t\tnewUrl = currentDir + unquotedOrigUrl.replace(/^\\.\\//, \"\"); // Strip leading './'\n\t\t}\n\n\t\t// send back the fixed url(...)\n\t\treturn \"url(\" + JSON.stringify(newUrl) + \")\";\n\t});\n\n\t// send back the fixed css\n\treturn fixedCss;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi91cmxzLmpzP2Y2ZDMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxXQUFXLEVBQUU7QUFDckQsd0NBQXdDLFdBQVcsRUFBRTs7QUFFckQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxzQ0FBc0M7QUFDdEMsR0FBRztBQUNIO0FBQ0EsOERBQThEO0FBQzlEOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL3VybHMuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qKlxuICogV2hlbiBzb3VyY2UgbWFwcyBhcmUgZW5hYmxlZCwgYHN0eWxlLWxvYWRlcmAgdXNlcyBhIGxpbmsgZWxlbWVudCB3aXRoIGEgZGF0YS11cmkgdG9cbiAqIGVtYmVkIHRoZSBjc3Mgb24gdGhlIHBhZ2UuIFRoaXMgYnJlYWtzIGFsbCByZWxhdGl2ZSB1cmxzIGJlY2F1c2Ugbm93IHRoZXkgYXJlIHJlbGF0aXZlIHRvIGFcbiAqIGJ1bmRsZSBpbnN0ZWFkIG9mIHRoZSBjdXJyZW50IHBhZ2UuXG4gKlxuICogT25lIHNvbHV0aW9uIGlzIHRvIG9ubHkgdXNlIGZ1bGwgdXJscywgYnV0IHRoYXQgbWF5IGJlIGltcG9zc2libGUuXG4gKlxuICogSW5zdGVhZCwgdGhpcyBmdW5jdGlvbiBcImZpeGVzXCIgdGhlIHJlbGF0aXZlIHVybHMgdG8gYmUgYWJzb2x1dGUgYWNjb3JkaW5nIHRvIHRoZSBjdXJyZW50IHBhZ2UgbG9jYXRpb24uXG4gKlxuICogQSBydWRpbWVudGFyeSB0ZXN0IHN1aXRlIGlzIGxvY2F0ZWQgYXQgYHRlc3QvZml4VXJscy5qc2AgYW5kIGNhbiBiZSBydW4gdmlhIHRoZSBgbnBtIHRlc3RgIGNvbW1hbmQuXG4gKlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNzcykge1xuICAvLyBnZXQgY3VycmVudCBsb2NhdGlvblxuICB2YXIgbG9jYXRpb24gPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5sb2NhdGlvbjtcblxuICBpZiAoIWxvY2F0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZml4VXJscyByZXF1aXJlcyB3aW5kb3cubG9jYXRpb25cIik7XG4gIH1cblxuXHQvLyBibGFuayBvciBudWxsP1xuXHRpZiAoIWNzcyB8fCB0eXBlb2YgY3NzICE9PSBcInN0cmluZ1wiKSB7XG5cdCAgcmV0dXJuIGNzcztcbiAgfVxuXG4gIHZhciBiYXNlVXJsID0gbG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKyBsb2NhdGlvbi5ob3N0O1xuICB2YXIgY3VycmVudERpciA9IGJhc2VVcmwgKyBsb2NhdGlvbi5wYXRobmFtZS5yZXBsYWNlKC9cXC9bXlxcL10qJC8sIFwiL1wiKTtcblxuXHQvLyBjb252ZXJ0IGVhY2ggdXJsKC4uLilcblx0Lypcblx0VGhpcyByZWd1bGFyIGV4cHJlc3Npb24gaXMganVzdCBhIHdheSB0byByZWN1cnNpdmVseSBtYXRjaCBicmFja2V0cyB3aXRoaW5cblx0YSBzdHJpbmcuXG5cblx0IC91cmxcXHMqXFwoICA9IE1hdGNoIG9uIHRoZSB3b3JkIFwidXJsXCIgd2l0aCBhbnkgd2hpdGVzcGFjZSBhZnRlciBpdCBhbmQgdGhlbiBhIHBhcmVuc1xuXHQgICAoICA9IFN0YXJ0IGEgY2FwdHVyaW5nIGdyb3VwXG5cdCAgICAgKD86ICA9IFN0YXJ0IGEgbm9uLWNhcHR1cmluZyBncm91cFxuXHQgICAgICAgICBbXikoXSAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgfCAgPSBPUlxuXHQgICAgICAgICBcXCggID0gTWF0Y2ggYSBzdGFydCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgKD86ICA9IFN0YXJ0IGFub3RoZXIgbm9uLWNhcHR1cmluZyBncm91cHNcblx0ICAgICAgICAgICAgICAgICBbXikoXSsgID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgfCAgPSBPUlxuXHQgICAgICAgICAgICAgICAgIFxcKCAgPSBNYXRjaCBhIHN0YXJ0IHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgICAgIFteKShdKiAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICAgICBcXCkgID0gTWF0Y2ggYSBlbmQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICkgID0gRW5kIEdyb3VwXG4gICAgICAgICAgICAgICpcXCkgPSBNYXRjaCBhbnl0aGluZyBhbmQgdGhlbiBhIGNsb3NlIHBhcmVuc1xuICAgICAgICAgICkgID0gQ2xvc2Ugbm9uLWNhcHR1cmluZyBncm91cFxuICAgICAgICAgICogID0gTWF0Y2ggYW55dGhpbmdcbiAgICAgICApICA9IENsb3NlIGNhcHR1cmluZyBncm91cFxuXHQgXFwpICA9IE1hdGNoIGEgY2xvc2UgcGFyZW5zXG5cblx0IC9naSAgPSBHZXQgYWxsIG1hdGNoZXMsIG5vdCB0aGUgZmlyc3QuICBCZSBjYXNlIGluc2Vuc2l0aXZlLlxuXHQgKi9cblx0dmFyIGZpeGVkQ3NzID0gY3NzLnJlcGxhY2UoL3VybFxccypcXCgoKD86W14pKF18XFwoKD86W14pKF0rfFxcKFteKShdKlxcKSkqXFwpKSopXFwpL2dpLCBmdW5jdGlvbihmdWxsTWF0Y2gsIG9yaWdVcmwpIHtcblx0XHQvLyBzdHJpcCBxdW90ZXMgKGlmIHRoZXkgZXhpc3QpXG5cdFx0dmFyIHVucXVvdGVkT3JpZ1VybCA9IG9yaWdVcmxcblx0XHRcdC50cmltKClcblx0XHRcdC5yZXBsYWNlKC9eXCIoLiopXCIkLywgZnVuY3Rpb24obywgJDEpeyByZXR1cm4gJDE7IH0pXG5cdFx0XHQucmVwbGFjZSgvXicoLiopJyQvLCBmdW5jdGlvbihvLCAkMSl7IHJldHVybiAkMTsgfSk7XG5cblx0XHQvLyBhbHJlYWR5IGEgZnVsbCB1cmw/IG5vIGNoYW5nZVxuXHRcdGlmICgvXigjfGRhdGE6fGh0dHA6XFwvXFwvfGh0dHBzOlxcL1xcL3xmaWxlOlxcL1xcL1xcL3xcXHMqJCkvaS50ZXN0KHVucXVvdGVkT3JpZ1VybCkpIHtcblx0XHQgIHJldHVybiBmdWxsTWF0Y2g7XG5cdFx0fVxuXG5cdFx0Ly8gY29udmVydCB0aGUgdXJsIHRvIGEgZnVsbCB1cmxcblx0XHR2YXIgbmV3VXJsO1xuXG5cdFx0aWYgKHVucXVvdGVkT3JpZ1VybC5pbmRleE9mKFwiLy9cIikgPT09IDApIHtcblx0XHQgIFx0Ly9UT0RPOiBzaG91bGQgd2UgYWRkIHByb3RvY29sP1xuXHRcdFx0bmV3VXJsID0gdW5xdW90ZWRPcmlnVXJsO1xuXHRcdH0gZWxzZSBpZiAodW5xdW90ZWRPcmlnVXJsLmluZGV4T2YoXCIvXCIpID09PSAwKSB7XG5cdFx0XHQvLyBwYXRoIHNob3VsZCBiZSByZWxhdGl2ZSB0byB0aGUgYmFzZSB1cmxcblx0XHRcdG5ld1VybCA9IGJhc2VVcmwgKyB1bnF1b3RlZE9yaWdVcmw7IC8vIGFscmVhZHkgc3RhcnRzIHdpdGggJy8nXG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIHBhdGggc2hvdWxkIGJlIHJlbGF0aXZlIHRvIGN1cnJlbnQgZGlyZWN0b3J5XG5cdFx0XHRuZXdVcmwgPSBjdXJyZW50RGlyICsgdW5xdW90ZWRPcmlnVXJsLnJlcGxhY2UoL15cXC5cXC8vLCBcIlwiKTsgLy8gU3RyaXAgbGVhZGluZyAnLi8nXG5cdFx0fVxuXG5cdFx0Ly8gc2VuZCBiYWNrIHRoZSBmaXhlZCB1cmwoLi4uKVxuXHRcdHJldHVybiBcInVybChcIiArIEpTT04uc3RyaW5naWZ5KG5ld1VybCkgKyBcIilcIjtcblx0fSk7XG5cblx0Ly8gc2VuZCBiYWNrIHRoZSBmaXhlZCBjc3Ncblx0cmV0dXJuIGZpeGVkQ3NzO1xufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/style-loader/lib/urls.js\n");

/***/ }),

/***/ "./resources/js/dashboard/main.js":
/*!****************************************!*\
  !*** ./resources/js/dashboard/main.js ***!
  \****************************************/
/*! exports provided: ALLOWEDTYPES, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ALLOWEDTYPES\", function() { return ALLOWEDTYPES; });\nElement.prototype.findParent = function (loops) {\n  var parent = this;\n\n  for (var i = 0; i < loops; i++) {\n    parent = parent.parentElement;\n  }\n\n  return parent;\n}, false;\nElement.prototype.appendBefore = function (element) {\n  element.parentNode.insertBefore(this, element);\n}, false;\nElement.prototype.appendAfter = function (element) {\n  element.parentNode.insertBefore(this, element.nextSibling);\n}, false; //!##########################################\n//!\t\t\t\tGlobal Variables\t\tF\t#\n//!##########################################\n\nvar baseUrl = window.location.origin;\nvar timer = 0;\nvar ALLOWEDTYPES = [\"application/octet-stream\", \"application/x-zip-compressed\", \"application/pdf\", \"application/msword\", \"application/vnd.openxmlformats-officedocument.wordprocessingml.document\", \"application/vnd.openxmlformats-officedocument.wordprocessingml.template\", \"application/vnd.ms-word.document.macroEnabled.12\", \"application/vnd.ms-word.template.macroEnabled.12\", \"application/vnd.ms-excel\", \"application/vnd.ms-excel\", \"application/vnd.ms-excel\", \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\", \"application/vnd.openxmlformats-officedocument.spreadsheetml.template\", \"application/vnd.ms-excel.sheet.macroEnabled.12\", \"application/vnd.ms-excel.template.macroEnabled.12\", \"application/vnd.ms-excel.addin.macroEnabled.12\", \"application/vnd.ms-excel.sheet.binary.macroEnabled.12\", \"application/vnd.ms-powerpoint\", \"application/vnd.openxmlformats-officedocument.presentationml.presentation\", \"application/vnd.openxmlformats-officedocument.presentationml.template\", \"application/vnd.openxmlformats-officedocument.presentationml.slideshow\", \"application/vnd.ms-powerpoint.addin.macroEnabled.12\", \"application/vnd.ms-powerpoint.presentation.macroEnabled.12\", \"application/vnd.ms-powerpoint.template.macroEnabled.12\", \"application/vnd.ms-powerpoint.slideshow.macroEnabled.12\", \"application/vnd.ms-access\", \"audio/mpeg\", \"application/vnd.oasis.opendocument.presentation\", \"application/vnd.oasis.opendocument.spreadsheet\", \"application/vnd.oasis.opendocument.text\", \"application/rtf\", \"application/vnd.oasis.opendocument.graphics\", \"text/html\"]; //!##########################################\n//!\t\t\t\tConfigurations\t\t\t\t#\n//!##########################################\n//!ALERT\n//!============================================================\n\nfunction toastAlert(icon, message) {\n  Swal.fire({\n    toast: 'true',\n    position: 'top-end',\n    icon: icon,\n    title: message,\n    showConfirmButton: false,\n    timer: 3000,\n    timerProgressBar: true\n  });\n}\n\nfunction toastAlertDelete(text) {\n  var icon = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"warning\";\n  return Swal.fire({\n    title: 'Είστε σίγουρος;',\n    text: text,\n    icon: icon,\n    showCancelButton: true,\n    confirmButtonColor: '#ff5b5b',\n    confirmButtonText: 'Ναί, διαγραφή!',\n    cancelButtonText: 'Άκυρο'\n  });\n} //!CONFIG\n//!============================================================\n\n\nvar articleConfig = {\n  css: \"/css/\",\n  custom: {\n    css: [\"/css/bootstrap.min.css\", \"/css/customArticleStyle.css\"]\n  },\n  // plugins: ['mediaLibrary', 'reorder'],\n  classes: {\n    img: 'img-fluid',\n    p: 'text-wrap'\n  },\n  grid: {\n    classname: 'row',\n    columns: 12,\n    gutter: '1px',\n    offset: {\n      left: '15px',\n      right: '15px'\n    },\n    patterns: {\n      '6|6': 'col-6|col-6',\n      '4|4|4': 'col-4|col-4|col-4',\n      '3|3|3|3': 'col-3|col-3|col-3|col-3',\n      '2|2|2|2|2|2': 'col-2|col-2|col-2|col-2|col-2|col-2',\n      '3|6|3': 'col-3|col-6|col-3',\n      '2|8|2': 'col-2|col-8|col-2',\n      '5|7': 'col-5|col-7',\n      '7|5': 'col-7|col-5',\n      '4|8': 'col-4|col-8',\n      '8|4': 'col-8|col-4',\n      '3|9': 'col-3|col-9',\n      '9|3': 'col-9|col-3',\n      '2|10': 'col-2|col-10',\n      '10|2': 'col-10|col-2',\n      '12': 'col-12'\n    }\n  },\n  align: {\n    left: \"text-left\",\n    center: \"text-center\",\n    right: \"text-right\"\n  },\n  editor: {\n    minHeight: \"300px\"\n  },\n  image: {\n    upload: \"/media/upload-images\",\n    data: {\n      \"_token\": $('meta[name=\"csrf-token\"]').attr('content')\n    }\n  }\n};\nvar redactorConfig = {\n  buttons: ['html', 'undo', 'redo', 'format', 'bold', 'underline', 'italic', 'deleted', 'sup', 'sub', 'lists', 'file', 'link', 'image'],\n  style: false,\n  plugins: ['alignment'],\n  minHeight: '150px'\n};\nvar datePickerConfig = {\n  ranges: {\n    'Today': [moment(), moment()],\n    'Yesterday': [moment().subtract(1, 'days'), moment().subtract(1, 'days')],\n    'Last 7 Days': [moment().subtract(6, 'days'), moment()],\n    'Last 30 Days': [moment().subtract(29, 'days'), moment()],\n    'This Month': [moment().startOf('month'), moment().endOf('month')],\n    'Last Month': [moment().subtract(1, 'month').startOf('month'), moment().subtract(1, 'month').endOf('month')],\n    'This Year': [moment().startOf('year'), moment().endOf('year')],\n    'Last Year': [moment().subtract(1, 'year').startOf('year'), moment().subtract(1, 'year').endOf('year')]\n  },\n  alwaysShowCalendars: true,\n  showCustomRangeLabel: false,\n  drops: \"auto\",\n  autoUpdateInput: false,\n  opens: \"center\",\n  locale: {\n    format: \"DD/MM/YYYY\"\n  }\n};\nvar tableLocale = {\n  emptyTable: \"Δεν υπάρχουν εγγραφές\",\n  info: \"_START_ έως _END_ απο τα _TOTAL_ αποτελέσματα\",\n  infoEmpty: \"0 απο 0 τα 0 αποτελέσματα\",\n  lengthMenu: \"_MENU_\",\n  loadingRecords: \"Φόρτωση ...\",\n  processing: \"Επεξεργασία ...\",\n  search: \"\",\n  searchPlaceholder: \"Αναζήτηση... \",\n  zeroRecords: \"Δεν βρέθηκαν αποτελέσματα\",\n  paginate: {\n    previous: \"<i class='mdi mdi-chevron-left'>\",\n    next: \"<i class='mdi mdi-chevron-right'>\"\n  },\n  infoFiltered: \"(Φιλτραρισμένα απο τις _MAX_ εγγραφές)\"\n}; //!GLOBAL FUNCTION\n//!============================================================\n\nfunction mainCheckboxSwitcher(main, minor) {\n  var bulkBtn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var status = true;\n  var counter = 0;\n  main.checked = true;\n\n  for (var i = 0; i < minor.length; i++) {\n    if (!minor[i].checked) {\n      minor[i].findParent(3).classList.remove(\"bg-selected\");\n      main.checked = false;\n    } else {\n      minor[i].findParent(3).classList.add(\"bg-selected\");\n      counter++;\n      status = false;\n    }\n  }\n\n  if (bulkBtn) {\n    bulkModifier(bulkBtn, status, counter);\n  }\n}\n\nfunction minorCheckboxSwitcher(main, minor) {\n  var bulkBtn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var counter = 0;\n  var status = true;\n\n  if (main.checked && minor.length > 0) {\n    counter = minor.length;\n    status = false;\n\n    for (var i = 0; i < minor.length; i++) {\n      minor[i].checked = true;\n      minor[i].findParent(3).classList.add(\"bg-selected\");\n    }\n  } else {\n    for (var i = 0; i < minor.length; i++) {\n      minor[i].checked = false;\n      minor[i].findParent(3).classList.remove(\"bg-selected\");\n    }\n  }\n\n  if (bulkBtn) {\n    bulkModifier(bulkBtn, status, counter);\n  }\n}\n\nfunction bulkModifier(bulkBtn, status, sum) {\n  var text = bulkBtn.dataset.text ? bulkBtn.dataset.text : \"Επιλογές\";\n  var enabledColor = bulkBtn.dataset.enabledColor ? bulkBtn.dataset.enabledColor : \"btn-warning\";\n  var disabledColor = bulkBtn.dataset.disabledColor ? bulkBtn.dataset.disabledColor : \"btn-secondary\";\n\n  if (status) {\n    bulkBtn.classList.add(disabledColor);\n    bulkBtn.classList.remove(enabledColor);\n    bulkBtn.textContent = \"\".concat(text, \" (0)  \");\n    bulkBtn.disabled = true;\n  } else {\n    bulkBtn.classList.add(enabledColor);\n    bulkBtn.classList.remove(disabledColor);\n    bulkBtn.textContent = \"\".concat(text, \"  (\").concat(sum, \")  \");\n    bulkBtn.disabled = false;\n  }\n}\n\nfunction filterStyle(input, value) {\n  if (value == \"\") {\n    input.classList.remove(\"select2-selected\");\n  } else {\n    input.classList.add(\"select2-selected\");\n  }\n}\n\nvar filterButton = function filterButton(attr, column, table, tableId) {\n  $(attr).detach().appendTo(tableId);\n  $(attr).on('change', function () {\n    table.columns(column).search(this.value).draw();\n  });\n};\n\nvar changeInputHidden = function changeInputHidden(attr, hiddenAttr) {\n  $(attr).change(function () {\n    if (attr == \"#activeMaterial\") {\n      this.value = $(this).prop('checked') == true ? 1 : 0;\n    }\n\n    var hiddenValue = $(hiddenAttr)[0].value = this.value;\n  });\n};\n\nfunction createStateSelect() {\n  var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n  var selectElm = document.createElement(\"select\");\n  selectElm.classList.add(\"ml-1\", \"select2\");\n  selectElm.id = id;\n  selectElm.innerHTML = \"\\n\\t\\t<option value=\\\"\\\">\\u038C\\u03BB\\u03B5\\u03C2 \\u03BF\\u03B9 \\u039A\\u03B1\\u03C4\\u03B1\\u03C3\\u03C4\\u03AC\\u03C3\\u03B5\\u03B9\\u03C2</option>\\n\\t\\t<option value=\\\"1\\\">\\u0395\\u03BD\\u03B5\\u03C1\\u03B3\\u03AC</option>\\n\\t\\t<option value=\\\"0\\\">\\u0391\\u03BD\\u03B5\\u03BD\\u03B5\\u03C1\\u03B3\\u03AC</option>\\n\\t\";\n  return selectElm;\n}\n\nfunction createDateElm(id) {\n  var input = document.createElement(\"input\");\n  input.classList.add(\"form-control\", \"date\", \"d-inline-block\", \"ml-1\", \"js-date-search\");\n  input.id = id;\n  input.dataset.toggle = \"date-picker\";\n  input.dataset.cancelClass = \"btn-secondary\";\n  input.style.height = \"31.96px\";\n  input.style.width = \"195px\";\n  input.placeholder = \"Επιλέξτε ημερομηνίες...\";\n  return input;\n}\n\nfunction createCourseTypeSelect() {\n  var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n  var selectElm = document.createElement(\"select\");\n  selectElm.classList.add(\"ml-1\", \"select2\");\n  selectElm.id = id;\n  selectElm.innerHTML = \"\\n\\t\\t<option value=\\\"\\\">\\u038C\\u03BB\\u03B5\\u03C2 \\u03BF\\u03B9 \\u0395\\u03BA\\u03B4\\u03CC\\u03C3\\u03B5\\u03B9\\u03C2</option>\\n\\t\\t<option value=\\\"Normal\\\">Normal</option>\\n\\t\\t<option value=\\\"Trial\\\">Trial</option>\\n\\t\";\n  return selectElm;\n}\n\nfunction startDate(input) {\n  var dateInput = input;\n\n  if (!dateInput || dateInput.value == \"\") {\n    return \"\";\n  }\n\n  var dateInputValue = dateInput.value.split(\" - \");\n  var firstDate = dateInputValue[0].split(\"/\").reverse().join(\"-\");\n  return firstDate;\n}\n\nfunction endDate(input) {\n  var dateInput = input;\n\n  if (!dateInput || dateInput.value == \"\") {\n    return \"\";\n  }\n\n  var dateInputValue = dateInput.value.split(\" - \");\n  var secondDate = dateInputValue[1].split(\"/\").reverse().join(\"-\");\n  return secondDate;\n}\n\nfunction resetBulk(bulkBtn, checkbox) {\n  bulkBtn.text(\"Επιλογές  (0)\");\n  bulkBtn.addClass(\"btn-secondary\");\n  bulkBtn.removeClass(\"btn-warning\");\n  bulkBtn.prop(\"disabled\", true);\n  checkbox.prop(\"checked\", false);\n}\n\nfunction resetAddButton(addBtn, checkbox) {\n  addBtn.text(\"Προσθήκη Επιλογών (0)\");\n  addBtn.addClass(\"btn-secondary\");\n  addBtn.removeClass(\"btn-primary\");\n  addBtn.prop(\"disabled\", true);\n  checkbox.prop(\"checked\", false);\n} //!##############################################\n//!\t\t\t\tMedia Library Functions\t\t\t#\n//!##############################################\n\n\nfunction paginationHandler(event) {\n  event.preventDefault();\n  var activePage = this.href.split(\"page=\")[1];\n  var search = $(\"#image-search\").val();\n  paginationRequest(activePage, search);\n}\n\nfunction searchHandler() {\n  clearTimeout(timer);\n\n  if (this.value.length < 3 || this.value == \"\") {\n    timer = setTimeout(paginationRequest, 800, 1, \"\");\n  } else {\n    timer = setTimeout(paginationRequest, 800, 1, this.value);\n  }\n}\n\nfunction imageHandler() {\n  var modal = $(\"#gallery-content\")[0];\n  var model = modal.dataset.model;\n  var modelId = modal.dataset.id;\n  var editorId = modal.dataset.editorId;\n  var type = modal.dataset.type;\n  var image = {\n    'img': {\n      url: \"\".concat(this.dataset.imageSource)\n    }\n  };\n\n  if (type == \"article\") {\n    ArticleEditor(editorId).image.insert(image);\n  } else if (type == \"redactor\") {\n    $R(editorId, 'insertion.insertHtml', \"<img class=\\\"img-fluid\\\" src=\\\"\".concat(this.dataset.imageSource, \"\\\" alt=\\\"\").concat(this.dataset.name, \"\\\" />\"));\n  } else if (type == \"gallery\") {\n    $(\"#remove-all-images-btn\").removeClass(\"d-none\");\n    addToGallery(model, modelId, this.dataset.imageId);\n    return;\n  } else {\n    changeCoverRequest(model, modelId, this.dataset.imageSource);\n  }\n\n  $(\"#gallery-modal\").modal('hide');\n}\n\nfunction paginationRequest(activePage, search) {\n  axios.get(\"/media/images\", {\n    params: {\n      page: activePage,\n      search: search\n    }\n  }).then(function (res) {\n    var gallery = $(\"#gallery-content\")[0];\n    gallery.innerHTML = res.data;\n    var pagination = gallery.getElementsByClassName(\"js-gallery-page-btn\");\n    var addBtns = gallery.getElementsByClassName(\"js-add-image\");\n\n    for (var i = 0; i < addBtns.length; i++) {\n      addBtns[i].removeEventListener(\"click\", imageHandler);\n      addBtns[i].addEventListener(\"click\", imageHandler);\n    }\n\n    for (var _i = 0; _i < pagination.length; _i++) {\n      pagination[_i].removeEventListener(\"click\", paginationHandler);\n\n      pagination[_i].addEventListener(\"click\", paginationHandler);\n    }\n  });\n}\n\nfunction changeCoverRequest(namespace, id, url) {\n  if (typeof id === \"undefined\" && namespace == \"App\\\\User\") {\n    var img = $(\"#cover-image\")[0];\n    var removeBtnCnt = $(\"#remove-cover-btn\").parent();\n    img.src = \"\".concat(url);\n    img.classList.remove(\"d-none\");\n    removeBtnCnt.removeClass(\"d-none\");\n    removeBtnCnt.addClass(\"d-flex\");\n    $(\"#custom-file\")[0].value = \"\".concat(url);\n  } else {\n    axios.patch(\"/media/cover/replace\", {\n      namespace: namespace,\n      id: id,\n      url: url\n    }).then(function (res) {\n      var img = $(\"#cover-image\")[0];\n      var removeBtnCnt = $(\"#remove-cover-btn\").parent();\n      img.src = res.data.imgUrl;\n      img.classList.remove(\"d-none\");\n      $(\"#change-cover-btn\").text(\"Αλλαγή\");\n      $(\"#cover-status\").addClass(\"d-none\");\n      removeBtnCnt.removeClass(\"d-none\");\n      removeBtnCnt.addClass(\"d-flex\");\n      toastAlert(\"success\", \"Το Cover άλλαξε!\");\n    })[\"catch\"](function (err) {\n      console.log(err);\n      toastAlert('error', \"Παρουσιάστηκε κάποιο πρόβλημα ...\");\n    });\n  }\n}\n\nfunction addToGallery(namespace, id, imageId) {\n  axios.post(\"/media/gallery\", {\n    namespace: namespace,\n    modelId: id,\n    ids: [imageId]\n  }).then(function (res) {\n    var gallery = $(\"#gallery-cnt\");\n    gallery.html(res.data);\n    var closeBtns = gallery.find(\".js-remove-image\");\n    closeBtns.on(\"click\", removeImageHandler);\n    toastAlert(\"success\", \"Η εικόνα προστέθηκε.\");\n    gallery.modal(\"hide\");\n    var bulk = $(\"#gallery-bulk-action-btn\");\n    var checkboxes = $(\".js-gallery-checkbox\");\n    resetGalleryBtns(bulk, checkboxes);\n  })[\"catch\"](function (err) {\n    console.log(err);\n    toastAlert('error', \"Παρουσιάστηκε κάποιο πρόβλημα ...\");\n  });\n}\n\nfunction removeImageHandler() {\n  var _this = this;\n\n  Swal.fire({\n    icon: 'info',\n    title: 'Προσοχή!',\n    text: 'Η εικόνα θα αφαιρεθεί απο το Gallery.',\n    showCancelButton: true,\n    confirmButtonColor: '#536de6',\n    confirmButtonText: \"\\u039D\\u03B1\\u03B9, \\u03B1\\u03C6\\u03B1\\u03AF\\u03C1\\u03B5\\u03C3\\u03B7!\",\n    cancelButtonText: \"Άκυρο\"\n  }).then(function (result) {\n    if (result.isConfirmed) {\n      removeImages([_this.dataset.imageId]);\n    }\n  });\n}\n\nfunction removeImages(ids) {\n  var gallery = $(\"#gallery-cnt\")[0];\n  var namespace = gallery.dataset.namespace;\n  var modelId = gallery.dataset.modelId;\n  axios.post(\"/media/gallery-remove\", {\n    namespace: namespace,\n    modelId: modelId,\n    ids: ids\n  }).then(function (res) {\n    var gallery = $(\"#gallery-cnt\");\n    gallery.html(res.data);\n    var closeBtns = gallery.find(\".js-remove-image\");\n    closeBtns.on(\"click\", removeImageHandler);\n\n    if (closeBtns.length == 0) {\n      $(\"#remove-all-images-btn\").addClass(\"d-none\");\n    }\n  })[\"catch\"](function (err) {\n    console.log(err);\n    utilities.toastAlert('error', \"Παρουσιάστηκε κάποιο πρόβλημα ...\");\n  });\n}\n\nfunction resetGalleryBtns(bulk, checkboxes) {\n  bulk.text(\"Επιλογές (0)\");\n  bulk.prop(\"disabled\", true);\n  bulk.removeClass(\"btn-warning\");\n  bulk.addClass(\"btn-secondary\");\n\n  for (var i = 0; i < checkboxes.length; i++) {\n    checkboxes[i].checked = false;\n  }\n} //!######################################################\n//!\t\t\t\tMedia Library Functions End\t\t\t\t#\n//!######################################################\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  toastAlert: toastAlert,\n  mainCheckboxSwitcher: mainCheckboxSwitcher,\n  minorCheckboxSwitcher: minorCheckboxSwitcher,\n  filterButton: filterButton,\n  tableLocale: tableLocale,\n  changeInputHidden: changeInputHidden,\n  redactorConfig: redactorConfig,\n  createStateSelect: createStateSelect,\n  datePickerConfig: datePickerConfig,\n  toastAlertDelete: toastAlertDelete,\n  filterStyle: filterStyle,\n  createDateElm: createDateElm,\n  startDate: startDate,\n  endDate: endDate,\n  resetBulk: resetBulk,\n  resetAddButton: resetAddButton,\n  createCourseTypeSelect: createCourseTypeSelect,\n  paginationHandler: paginationHandler,\n  searchHandler: searchHandler,\n  imageHandler: imageHandler,\n  paginationRequest: paginationRequest,\n  resetGalleryBtns: resetGalleryBtns,\n  removeImageHandler: removeImageHandler,\n  removeImages: removeImages,\n  articleConfig: articleConfig,\n  ALLOWEDTYPES: ALLOWEDTYPES\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvZGFzaGJvYXJkL21haW4uanM/ODIyYiJdLCJuYW1lcyI6WyJFbGVtZW50IiwicHJvdG90eXBlIiwiZmluZFBhcmVudCIsImxvb3BzIiwicGFyZW50IiwiaSIsInBhcmVudEVsZW1lbnQiLCJhcHBlbmRCZWZvcmUiLCJlbGVtZW50IiwicGFyZW50Tm9kZSIsImluc2VydEJlZm9yZSIsImFwcGVuZEFmdGVyIiwibmV4dFNpYmxpbmciLCJiYXNlVXJsIiwid2luZG93IiwibG9jYXRpb24iLCJvcmlnaW4iLCJ0aW1lciIsIkFMTE9XRURUWVBFUyIsInRvYXN0QWxlcnQiLCJpY29uIiwibWVzc2FnZSIsIlN3YWwiLCJmaXJlIiwidG9hc3QiLCJwb3NpdGlvbiIsInRpdGxlIiwic2hvd0NvbmZpcm1CdXR0b24iLCJ0aW1lclByb2dyZXNzQmFyIiwidG9hc3RBbGVydERlbGV0ZSIsInRleHQiLCJzaG93Q2FuY2VsQnV0dG9uIiwiY29uZmlybUJ1dHRvbkNvbG9yIiwiY29uZmlybUJ1dHRvblRleHQiLCJjYW5jZWxCdXR0b25UZXh0IiwiYXJ0aWNsZUNvbmZpZyIsImNzcyIsImN1c3RvbSIsImNsYXNzZXMiLCJpbWciLCJwIiwiZ3JpZCIsImNsYXNzbmFtZSIsImNvbHVtbnMiLCJndXR0ZXIiLCJvZmZzZXQiLCJsZWZ0IiwicmlnaHQiLCJwYXR0ZXJucyIsImFsaWduIiwiY2VudGVyIiwiZWRpdG9yIiwibWluSGVpZ2h0IiwiaW1hZ2UiLCJ1cGxvYWQiLCJkYXRhIiwiJCIsImF0dHIiLCJyZWRhY3RvckNvbmZpZyIsImJ1dHRvbnMiLCJzdHlsZSIsInBsdWdpbnMiLCJkYXRlUGlja2VyQ29uZmlnIiwicmFuZ2VzIiwibW9tZW50Iiwic3VidHJhY3QiLCJzdGFydE9mIiwiZW5kT2YiLCJhbHdheXNTaG93Q2FsZW5kYXJzIiwic2hvd0N1c3RvbVJhbmdlTGFiZWwiLCJkcm9wcyIsImF1dG9VcGRhdGVJbnB1dCIsIm9wZW5zIiwibG9jYWxlIiwiZm9ybWF0IiwidGFibGVMb2NhbGUiLCJlbXB0eVRhYmxlIiwiaW5mbyIsImluZm9FbXB0eSIsImxlbmd0aE1lbnUiLCJsb2FkaW5nUmVjb3JkcyIsInByb2Nlc3NpbmciLCJzZWFyY2giLCJzZWFyY2hQbGFjZWhvbGRlciIsInplcm9SZWNvcmRzIiwicGFnaW5hdGUiLCJwcmV2aW91cyIsIm5leHQiLCJpbmZvRmlsdGVyZWQiLCJtYWluQ2hlY2tib3hTd2l0Y2hlciIsIm1haW4iLCJtaW5vciIsImJ1bGtCdG4iLCJzdGF0dXMiLCJjb3VudGVyIiwiY2hlY2tlZCIsImxlbmd0aCIsImNsYXNzTGlzdCIsInJlbW92ZSIsImFkZCIsImJ1bGtNb2RpZmllciIsIm1pbm9yQ2hlY2tib3hTd2l0Y2hlciIsInN1bSIsImRhdGFzZXQiLCJlbmFibGVkQ29sb3IiLCJkaXNhYmxlZENvbG9yIiwidGV4dENvbnRlbnQiLCJkaXNhYmxlZCIsImZpbHRlclN0eWxlIiwiaW5wdXQiLCJ2YWx1ZSIsImZpbHRlckJ1dHRvbiIsImNvbHVtbiIsInRhYmxlIiwidGFibGVJZCIsImRldGFjaCIsImFwcGVuZFRvIiwib24iLCJkcmF3IiwiY2hhbmdlSW5wdXRIaWRkZW4iLCJoaWRkZW5BdHRyIiwiY2hhbmdlIiwicHJvcCIsImhpZGRlblZhbHVlIiwiY3JlYXRlU3RhdGVTZWxlY3QiLCJpZCIsInNlbGVjdEVsbSIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImlubmVySFRNTCIsImNyZWF0ZURhdGVFbG0iLCJ0b2dnbGUiLCJjYW5jZWxDbGFzcyIsImhlaWdodCIsIndpZHRoIiwicGxhY2Vob2xkZXIiLCJjcmVhdGVDb3Vyc2VUeXBlU2VsZWN0Iiwic3RhcnREYXRlIiwiZGF0ZUlucHV0IiwiZGF0ZUlucHV0VmFsdWUiLCJzcGxpdCIsImZpcnN0RGF0ZSIsInJldmVyc2UiLCJqb2luIiwiZW5kRGF0ZSIsInNlY29uZERhdGUiLCJyZXNldEJ1bGsiLCJjaGVja2JveCIsImFkZENsYXNzIiwicmVtb3ZlQ2xhc3MiLCJyZXNldEFkZEJ1dHRvbiIsImFkZEJ0biIsInBhZ2luYXRpb25IYW5kbGVyIiwiZXZlbnQiLCJwcmV2ZW50RGVmYXVsdCIsImFjdGl2ZVBhZ2UiLCJocmVmIiwidmFsIiwicGFnaW5hdGlvblJlcXVlc3QiLCJzZWFyY2hIYW5kbGVyIiwiY2xlYXJUaW1lb3V0Iiwic2V0VGltZW91dCIsImltYWdlSGFuZGxlciIsIm1vZGFsIiwibW9kZWwiLCJtb2RlbElkIiwiZWRpdG9ySWQiLCJ0eXBlIiwidXJsIiwiaW1hZ2VTb3VyY2UiLCJBcnRpY2xlRWRpdG9yIiwiaW5zZXJ0IiwiJFIiLCJuYW1lIiwiYWRkVG9HYWxsZXJ5IiwiaW1hZ2VJZCIsImNoYW5nZUNvdmVyUmVxdWVzdCIsImF4aW9zIiwiZ2V0IiwicGFyYW1zIiwicGFnZSIsInRoZW4iLCJyZXMiLCJnYWxsZXJ5IiwicGFnaW5hdGlvbiIsImdldEVsZW1lbnRzQnlDbGFzc05hbWUiLCJhZGRCdG5zIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImFkZEV2ZW50TGlzdGVuZXIiLCJuYW1lc3BhY2UiLCJyZW1vdmVCdG5DbnQiLCJzcmMiLCJwYXRjaCIsImltZ1VybCIsImVyciIsImNvbnNvbGUiLCJsb2ciLCJwb3N0IiwiaWRzIiwiaHRtbCIsImNsb3NlQnRucyIsImZpbmQiLCJyZW1vdmVJbWFnZUhhbmRsZXIiLCJidWxrIiwiY2hlY2tib3hlcyIsInJlc2V0R2FsbGVyeUJ0bnMiLCJyZXN1bHQiLCJpc0NvbmZpcm1lZCIsInJlbW92ZUltYWdlcyIsInV0aWxpdGllcyJdLCJtYXBwaW5ncyI6IkFBQUFBO0FBQUFBO0FBQUFBLE9BQU8sQ0FBQ0MsU0FBUixDQUFrQkMsVUFBbEIsR0FBK0IsVUFBVUMsS0FBVixFQUFpQjtBQUM1QyxNQUFJQyxNQUFNLEdBQUcsSUFBYjs7QUFFQSxPQUFLLElBQUlDLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdGLEtBQXBCLEVBQTJCRSxDQUFDLEVBQTVCLEVBQWdDO0FBQzVCRCxVQUFNLEdBQUdBLE1BQU0sQ0FBQ0UsYUFBaEI7QUFDSDs7QUFFRCxTQUFPRixNQUFQO0FBQ0gsQ0FSRCxFQVFHLEtBUkg7QUFVQUosT0FBTyxDQUFDQyxTQUFSLENBQWtCTSxZQUFsQixHQUFpQyxVQUFVQyxPQUFWLEVBQW1CO0FBQ2hEQSxTQUFPLENBQUNDLFVBQVIsQ0FBbUJDLFlBQW5CLENBQWdDLElBQWhDLEVBQXNDRixPQUF0QztBQUNILENBRkQsRUFFRyxLQUZIO0FBSUFSLE9BQU8sQ0FBQ0MsU0FBUixDQUFrQlUsV0FBbEIsR0FBZ0MsVUFBVUgsT0FBVixFQUFtQjtBQUUvQ0EsU0FBTyxDQUFDQyxVQUFSLENBQW1CQyxZQUFuQixDQUFnQyxJQUFoQyxFQUFzQ0YsT0FBTyxDQUFDSSxXQUE5QztBQUVILENBSkQsRUFJRyxLQUpILEMsQ0FNQTtBQUNBO0FBQ0E7O0FBRUEsSUFBTUMsT0FBTyxHQUFHQyxNQUFNLENBQUNDLFFBQVAsQ0FBZ0JDLE1BQWhDO0FBQ0EsSUFBSUMsS0FBSyxHQUFHLENBQVo7QUFDTyxJQUFNQyxZQUFZLEdBQUcsQ0FDM0IsMEJBRDJCLEVBQ0MsOEJBREQsRUFDaUMsaUJBRGpDLEVBRTNCLG9CQUYyQixFQUVMLHlFQUZLLEVBRzNCLHlFQUgyQixFQUdnRCxrREFIaEQsRUFJM0Isa0RBSjJCLEVBSXlCLDBCQUp6QixFQUlxRCwwQkFKckQsRUFJaUYsMEJBSmpGLEVBSzNCLG1FQUwyQixFQUswQyxzRUFMMUMsRUFNM0IsZ0RBTjJCLEVBTXVCLG1EQU52QixFQU8zQixnREFQMkIsRUFPdUIsdURBUHZCLEVBUTNCLCtCQVIyQixFQVFNLDJFQVJOLEVBUzNCLHVFQVQyQixFQVM4Qyx3RUFUOUMsRUFVM0IscURBVjJCLEVBVTRCLDREQVY1QixFQVczQix3REFYMkIsRUFXK0IseURBWC9CLEVBWTNCLDJCQVoyQixFQVlFLFlBWkYsRUFZZ0IsaURBWmhCLEVBYTNCLGdEQWIyQixFQWF1Qix5Q0FidkIsRUFjM0IsaUJBZDJCLEVBY1IsNkNBZFEsRUFjdUMsV0FkdkMsQ0FBckIsQyxDQWlCUDtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUNBLFNBQVNDLFVBQVQsQ0FBb0JDLElBQXBCLEVBQTBCQyxPQUExQixFQUFtQztBQUMvQkMsTUFBSSxDQUFDQyxJQUFMLENBQVU7QUFDTkMsU0FBSyxFQUFFLE1BREQ7QUFFTkMsWUFBUSxFQUFFLFNBRko7QUFHTkwsUUFBSSxFQUFFQSxJQUhBO0FBSU5NLFNBQUssRUFBRUwsT0FKRDtBQUtOTSxxQkFBaUIsRUFBRSxLQUxiO0FBTU5WLFNBQUssRUFBRSxJQU5EO0FBT05XLG9CQUFnQixFQUFFO0FBUFosR0FBVjtBQVNIOztBQUVELFNBQVNDLGdCQUFULENBQTBCQyxJQUExQixFQUFrRDtBQUFBLE1BQWxCVixJQUFrQix1RUFBWCxTQUFXO0FBQzlDLFNBQU9FLElBQUksQ0FBQ0MsSUFBTCxDQUFVO0FBQ2JHLFNBQUssRUFBRSxpQkFETTtBQUViSSxRQUFJLEVBQUVBLElBRk87QUFHYlYsUUFBSSxFQUFFQSxJQUhPO0FBSW5CVyxvQkFBZ0IsRUFBRSxJQUpDO0FBS25CQyxzQkFBa0IsRUFBRSxTQUxEO0FBTWJDLHFCQUFpQixFQUFFLGdCQU5OO0FBT2JDLG9CQUFnQixFQUFFO0FBUEwsR0FBVixDQUFQO0FBU0gsQyxDQUdEO0FBQ0E7OztBQUNBLElBQU1DLGFBQWEsR0FBRztBQUNyQkMsS0FBRyxFQUFFLE9BRGdCO0FBRXJCQyxRQUFNLEVBQUU7QUFDUEQsT0FBRyxFQUFFLENBQ0osd0JBREksRUFFSiw2QkFGSTtBQURFLEdBRmE7QUFRckI7QUFDQUUsU0FBTyxFQUFFO0FBQ1JDLE9BQUcsRUFBRSxXQURHO0FBRVJDLEtBQUMsRUFBRTtBQUZLLEdBVFk7QUFhckJDLE1BQUksRUFBRTtBQUNMQyxhQUFTLEVBQUUsS0FETjtBQUVMQyxXQUFPLEVBQUUsRUFGSjtBQUdMQyxVQUFNLEVBQUUsS0FISDtBQUlMQyxVQUFNLEVBQUU7QUFDUEMsVUFBSSxFQUFFLE1BREM7QUFFUEMsV0FBSyxFQUFFO0FBRkEsS0FKSDtBQVFMQyxZQUFRLEVBQUU7QUFDVCxhQUFPLGFBREU7QUFFVCxlQUFTLG1CQUZBO0FBR1QsaUJBQVcseUJBSEY7QUFJVCxxQkFBZSxxQ0FKTjtBQUtULGVBQVMsbUJBTEE7QUFNVCxlQUFTLG1CQU5BO0FBT1QsYUFBTyxhQVBFO0FBUVQsYUFBTyxhQVJFO0FBU1QsYUFBTyxhQVRFO0FBVVQsYUFBTyxhQVZFO0FBV1QsYUFBTyxhQVhFO0FBWVQsYUFBTyxhQVpFO0FBYVQsY0FBUSxjQWJDO0FBY1QsY0FBUSxjQWRDO0FBZVQsWUFBTTtBQWZHO0FBUkwsR0FiZTtBQXVDckJDLE9BQUssRUFBRTtBQUNOSCxRQUFJLEVBQUUsV0FEQTtBQUVOSSxVQUFNLEVBQUUsYUFGRjtBQUdOSCxTQUFLLEVBQUU7QUFIRCxHQXZDYztBQTRDckJJLFFBQU0sRUFBRTtBQUNQQyxhQUFTLEVBQUU7QUFESixHQTVDYTtBQStDckJDLE9BQUssRUFBRTtBQUNOQyxVQUFNLEVBQUUsc0JBREY7QUFFTkMsUUFBSSxFQUFFO0FBQ0wsZ0JBQVVDLENBQUMsQ0FBQyx5QkFBRCxDQUFELENBQTZCQyxJQUE3QixDQUFrQyxTQUFsQztBQURMO0FBRkE7QUEvQ2MsQ0FBdEI7QUF1REEsSUFBTUMsY0FBYyxHQUFHO0FBQ25CQyxTQUFPLEVBQUUsQ0FDWCxNQURXLEVBQ0gsTUFERyxFQUNLLE1BREwsRUFDYSxRQURiLEVBRVgsTUFGVyxFQUVILFdBRkcsRUFFVSxRQUZWLEVBRW9CLFNBRnBCLEVBR1gsS0FIVyxFQUdKLEtBSEksRUFHRyxPQUhILEVBR1ksTUFIWixFQUdvQixNQUhwQixFQUc0QixPQUg1QixDQURVO0FBTXRCQyxPQUFLLEVBQUUsS0FOZTtBQU90QkMsU0FBTyxFQUFFLENBQUMsV0FBRCxDQVBhO0FBUXRCVCxXQUFTLEVBQUU7QUFSVyxDQUF2QjtBQVdBLElBQU1VLGdCQUFnQixHQUFHO0FBQ3JCQyxRQUFNLEVBQUU7QUFDSixhQUFTLENBQUNDLE1BQU0sRUFBUCxFQUFXQSxNQUFNLEVBQWpCLENBREw7QUFFSixpQkFBYSxDQUFDQSxNQUFNLEdBQUdDLFFBQVQsQ0FBa0IsQ0FBbEIsRUFBcUIsTUFBckIsQ0FBRCxFQUErQkQsTUFBTSxHQUFHQyxRQUFULENBQWtCLENBQWxCLEVBQXFCLE1BQXJCLENBQS9CLENBRlQ7QUFHSixtQkFBZSxDQUFDRCxNQUFNLEdBQUdDLFFBQVQsQ0FBa0IsQ0FBbEIsRUFBcUIsTUFBckIsQ0FBRCxFQUErQkQsTUFBTSxFQUFyQyxDQUhYO0FBSUosb0JBQWdCLENBQUNBLE1BQU0sR0FBR0MsUUFBVCxDQUFrQixFQUFsQixFQUFzQixNQUF0QixDQUFELEVBQWdDRCxNQUFNLEVBQXRDLENBSlo7QUFLSixrQkFBYyxDQUFDQSxNQUFNLEdBQUdFLE9BQVQsQ0FBaUIsT0FBakIsQ0FBRCxFQUE0QkYsTUFBTSxHQUFHRyxLQUFULENBQWUsT0FBZixDQUE1QixDQUxWO0FBTUosa0JBQWMsQ0FBQ0gsTUFBTSxHQUFHQyxRQUFULENBQWtCLENBQWxCLEVBQXFCLE9BQXJCLEVBQThCQyxPQUE5QixDQUFzQyxPQUF0QyxDQUFELEVBQWlERixNQUFNLEdBQUdDLFFBQVQsQ0FBa0IsQ0FBbEIsRUFBcUIsT0FBckIsRUFBOEJFLEtBQTlCLENBQW9DLE9BQXBDLENBQWpELENBTlY7QUFPSixpQkFBYSxDQUFDSCxNQUFNLEdBQUdFLE9BQVQsQ0FBaUIsTUFBakIsQ0FBRCxFQUEyQkYsTUFBTSxHQUFHRyxLQUFULENBQWUsTUFBZixDQUEzQixDQVBUO0FBUUosaUJBQWEsQ0FBQ0gsTUFBTSxHQUFHQyxRQUFULENBQWtCLENBQWxCLEVBQXFCLE1BQXJCLEVBQTZCQyxPQUE3QixDQUFxQyxNQUFyQyxDQUFELEVBQStDRixNQUFNLEdBQUdDLFFBQVQsQ0FBa0IsQ0FBbEIsRUFBcUIsTUFBckIsRUFBNkJFLEtBQTdCLENBQW1DLE1BQW5DLENBQS9DO0FBUlQsR0FEYTtBQVdyQkMscUJBQW1CLEVBQUUsSUFYQTtBQVlyQkMsc0JBQW9CLEVBQUUsS0FaRDtBQWFyQkMsT0FBSyxFQUFFLE1BYmM7QUFjckJDLGlCQUFlLEVBQUUsS0FkSTtBQWVyQkMsT0FBSyxFQUFFLFFBZmM7QUFnQnJCQyxRQUFNLEVBQUU7QUFDSkMsVUFBTSxFQUFFO0FBREo7QUFoQmEsQ0FBekI7QUFxQkEsSUFBTUMsV0FBVyxHQUFHO0FBQ2hCQyxZQUFVLEVBQUUsdUJBREk7QUFFaEJDLE1BQUksRUFBRSwrQ0FGVTtBQUdoQkMsV0FBUyxFQUFFLDJCQUhLO0FBSWhCQyxZQUFVLEVBQUUsUUFKSTtBQUtoQkMsZ0JBQWMsRUFBRSxhQUxBO0FBTWhCQyxZQUFVLEVBQUUsaUJBTkk7QUFPaEJDLFFBQU0sRUFBRSxFQVBRO0FBUWhCQyxtQkFBaUIsRUFBRSxlQVJIO0FBU2hCQyxhQUFXLEVBQUUsMkJBVEc7QUFVaEJDLFVBQVEsRUFBRTtBQUNOQyxZQUFRLEVBQUUsa0NBREo7QUFFTkMsUUFBSSxFQUFFO0FBRkEsR0FWTTtBQWNuQkMsY0FBWSxFQUFFO0FBZEssQ0FBcEIsQyxDQWlCQTtBQUNBOztBQUNBLFNBQVNDLG9CQUFULENBQThCQyxJQUE5QixFQUFvQ0MsS0FBcEMsRUFBNEQ7QUFBQSxNQUFqQkMsT0FBaUIsdUVBQVAsS0FBTztBQUN4RCxNQUFJQyxNQUFNLEdBQUcsSUFBYjtBQUNBLE1BQUlDLE9BQU8sR0FBRyxDQUFkO0FBQ0FKLE1BQUksQ0FBQ0ssT0FBTCxHQUFlLElBQWY7O0FBRUEsT0FBSyxJQUFJMUYsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR3NGLEtBQUssQ0FBQ0ssTUFBMUIsRUFBa0MzRixDQUFDLEVBQW5DLEVBQXVDO0FBQ25DLFFBQUksQ0FBQ3NGLEtBQUssQ0FBQ3RGLENBQUQsQ0FBTCxDQUFTMEYsT0FBZCxFQUF1QjtBQUNuQkosV0FBSyxDQUFDdEYsQ0FBRCxDQUFMLENBQVNILFVBQVQsQ0FBb0IsQ0FBcEIsRUFBdUIrRixTQUF2QixDQUFpQ0MsTUFBakMsQ0FBd0MsYUFBeEM7QUFDQVIsVUFBSSxDQUFDSyxPQUFMLEdBQWUsS0FBZjtBQUNILEtBSEQsTUFHTztBQUNISixXQUFLLENBQUN0RixDQUFELENBQUwsQ0FBU0gsVUFBVCxDQUFvQixDQUFwQixFQUF1QitGLFNBQXZCLENBQWlDRSxHQUFqQyxDQUFxQyxhQUFyQztBQUNBTCxhQUFPO0FBQ1BELFlBQU0sR0FBRyxLQUFUO0FBQ0g7QUFDSjs7QUFFRCxNQUFJRCxPQUFKLEVBQWE7QUFDVFEsZ0JBQVksQ0FBQ1IsT0FBRCxFQUFVQyxNQUFWLEVBQWtCQyxPQUFsQixDQUFaO0FBQ0g7QUFDSjs7QUFFRCxTQUFTTyxxQkFBVCxDQUErQlgsSUFBL0IsRUFBcUNDLEtBQXJDLEVBQTZEO0FBQUEsTUFBakJDLE9BQWlCLHVFQUFQLEtBQU87QUFDekQsTUFBSUUsT0FBTyxHQUFHLENBQWQ7QUFDQSxNQUFJRCxNQUFNLEdBQUcsSUFBYjs7QUFFQSxNQUFJSCxJQUFJLENBQUNLLE9BQUwsSUFBZ0JKLEtBQUssQ0FBQ0ssTUFBTixHQUFlLENBQW5DLEVBQXNDO0FBRWxDRixXQUFPLEdBQUdILEtBQUssQ0FBQ0ssTUFBaEI7QUFDQUgsVUFBTSxHQUFHLEtBQVQ7O0FBRUEsU0FBSyxJQUFJeEYsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR3NGLEtBQUssQ0FBQ0ssTUFBMUIsRUFBa0MzRixDQUFDLEVBQW5DLEVBQXVDO0FBQ25Dc0YsV0FBSyxDQUFDdEYsQ0FBRCxDQUFMLENBQVMwRixPQUFULEdBQW1CLElBQW5CO0FBQ0FKLFdBQUssQ0FBQ3RGLENBQUQsQ0FBTCxDQUFTSCxVQUFULENBQW9CLENBQXBCLEVBQXVCK0YsU0FBdkIsQ0FBaUNFLEdBQWpDLENBQXFDLGFBQXJDO0FBQ0g7QUFDSixHQVRELE1BU087QUFDSCxTQUFLLElBQUk5RixDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHc0YsS0FBSyxDQUFDSyxNQUExQixFQUFrQzNGLENBQUMsRUFBbkMsRUFBdUM7QUFDbkNzRixXQUFLLENBQUN0RixDQUFELENBQUwsQ0FBUzBGLE9BQVQsR0FBbUIsS0FBbkI7QUFDQUosV0FBSyxDQUFDdEYsQ0FBRCxDQUFMLENBQVNILFVBQVQsQ0FBb0IsQ0FBcEIsRUFBdUIrRixTQUF2QixDQUFpQ0MsTUFBakMsQ0FBd0MsYUFBeEM7QUFDSDtBQUNKOztBQUVELE1BQUlOLE9BQUosRUFBYTtBQUNUUSxnQkFBWSxDQUFDUixPQUFELEVBQVVDLE1BQVYsRUFBa0JDLE9BQWxCLENBQVo7QUFDSDtBQUNKOztBQUVELFNBQVNNLFlBQVQsQ0FBc0JSLE9BQXRCLEVBQStCQyxNQUEvQixFQUF1Q1MsR0FBdkMsRUFBNEM7QUFFeEMsTUFBSXhFLElBQUksR0FBRzhELE9BQU8sQ0FBQ1csT0FBUixDQUFnQnpFLElBQWhCLEdBQXVCOEQsT0FBTyxDQUFDVyxPQUFSLENBQWdCekUsSUFBdkMsR0FBOEMsVUFBekQ7QUFDQSxNQUFJMEUsWUFBWSxHQUFHWixPQUFPLENBQUNXLE9BQVIsQ0FBZ0JDLFlBQWhCLEdBQStCWixPQUFPLENBQUNXLE9BQVIsQ0FBZ0JDLFlBQS9DLEdBQThELGFBQWpGO0FBQ0EsTUFBSUMsYUFBYSxHQUFHYixPQUFPLENBQUNXLE9BQVIsQ0FBZ0JFLGFBQWhCLEdBQWdDYixPQUFPLENBQUNXLE9BQVIsQ0FBZ0JFLGFBQWhELEdBQWdFLGVBQXBGOztBQUVBLE1BQUlaLE1BQUosRUFBWTtBQUNSRCxXQUFPLENBQUNLLFNBQVIsQ0FBa0JFLEdBQWxCLENBQXNCTSxhQUF0QjtBQUNBYixXQUFPLENBQUNLLFNBQVIsQ0FBa0JDLE1BQWxCLENBQXlCTSxZQUF6QjtBQUNBWixXQUFPLENBQUNjLFdBQVIsYUFBeUI1RSxJQUF6QjtBQUNBOEQsV0FBTyxDQUFDZSxRQUFSLEdBQW1CLElBQW5CO0FBQ0gsR0FMRCxNQUtPO0FBQ0hmLFdBQU8sQ0FBQ0ssU0FBUixDQUFrQkUsR0FBbEIsQ0FBc0JLLFlBQXRCO0FBQ0FaLFdBQU8sQ0FBQ0ssU0FBUixDQUFrQkMsTUFBbEIsQ0FBeUJPLGFBQXpCO0FBQ0FiLFdBQU8sQ0FBQ2MsV0FBUixhQUF5QjVFLElBQXpCLGdCQUFtQ3dFLEdBQW5DO0FBQ0FWLFdBQU8sQ0FBQ2UsUUFBUixHQUFtQixLQUFuQjtBQUNIO0FBQ0o7O0FBRUQsU0FBU0MsV0FBVCxDQUFxQkMsS0FBckIsRUFBNEJDLEtBQTVCLEVBQW1DO0FBRS9CLE1BQUlBLEtBQUssSUFBSSxFQUFiLEVBQWlCO0FBQ2JELFNBQUssQ0FBQ1osU0FBTixDQUFnQkMsTUFBaEIsQ0FBdUIsa0JBQXZCO0FBQ0gsR0FGRCxNQUVPO0FBQ0hXLFNBQUssQ0FBQ1osU0FBTixDQUFnQkUsR0FBaEIsQ0FBb0Isa0JBQXBCO0FBQ0g7QUFFSjs7QUFFRCxJQUFNWSxZQUFZLEdBQUcsU0FBZkEsWUFBZSxDQUFVdEQsSUFBVixFQUFnQnVELE1BQWhCLEVBQXdCQyxLQUF4QixFQUErQkMsT0FBL0IsRUFBd0M7QUFDekQxRCxHQUFDLENBQUNDLElBQUQsQ0FBRCxDQUFRMEQsTUFBUixHQUFpQkMsUUFBakIsQ0FBMEJGLE9BQTFCO0FBSUExRCxHQUFDLENBQUNDLElBQUQsQ0FBRCxDQUFRNEQsRUFBUixDQUFXLFFBQVgsRUFBcUIsWUFBWTtBQUM3QkosU0FBSyxDQUFDdEUsT0FBTixDQUFjcUUsTUFBZCxFQUFzQjlCLE1BQXRCLENBQTZCLEtBQUs0QixLQUFsQyxFQUF5Q1EsSUFBekM7QUFHSCxHQUpEO0FBS0gsQ0FWRDs7QUFZQSxJQUFNQyxpQkFBaUIsR0FBRyxTQUFwQkEsaUJBQW9CLENBQUM5RCxJQUFELEVBQU8rRCxVQUFQLEVBQXNCO0FBRTVDaEUsR0FBQyxDQUFDQyxJQUFELENBQUQsQ0FBUWdFLE1BQVIsQ0FBZSxZQUFZO0FBQ3ZCLFFBQUloRSxJQUFJLElBQUksaUJBQVosRUFBK0I7QUFDM0IsV0FBS3FELEtBQUwsR0FBYXRELENBQUMsQ0FBQyxJQUFELENBQUQsQ0FBUWtFLElBQVIsQ0FBYSxTQUFiLEtBQTJCLElBQTNCLEdBQWtDLENBQWxDLEdBQXNDLENBQW5EO0FBQ0g7O0FBRUQsUUFBSUMsV0FBVyxHQUFHbkUsQ0FBQyxDQUFDZ0UsVUFBRCxDQUFELENBQWMsQ0FBZCxFQUFpQlYsS0FBakIsR0FBeUIsS0FBS0EsS0FBaEQ7QUFFSCxHQVBEO0FBUUgsQ0FWRDs7QUFZQSxTQUFTYyxpQkFBVCxHQUFvQztBQUFBLE1BQVRDLEVBQVMsdUVBQUosRUFBSTtBQUNoQyxNQUFNQyxTQUFTLEdBQUdDLFFBQVEsQ0FBQ0MsYUFBVCxDQUF1QixRQUF2QixDQUFsQjtBQUNBRixXQUFTLENBQUM3QixTQUFWLENBQW9CRSxHQUFwQixDQUF3QixNQUF4QixFQUFnQyxTQUFoQztBQUNBMkIsV0FBUyxDQUFDRCxFQUFWLEdBQWVBLEVBQWY7QUFFQUMsV0FBUyxDQUFDRyxTQUFWO0FBTUEsU0FBT0gsU0FBUDtBQUNIOztBQUVELFNBQVNJLGFBQVQsQ0FBdUJMLEVBQXZCLEVBQTJCO0FBQ3ZCLE1BQUloQixLQUFLLEdBQUdrQixRQUFRLENBQUNDLGFBQVQsQ0FBdUIsT0FBdkIsQ0FBWjtBQUVBbkIsT0FBSyxDQUFDWixTQUFOLENBQWdCRSxHQUFoQixDQUFvQixjQUFwQixFQUFvQyxNQUFwQyxFQUE0QyxnQkFBNUMsRUFBOEQsTUFBOUQsRUFBc0UsZ0JBQXRFO0FBQ0FVLE9BQUssQ0FBQ2dCLEVBQU4sR0FBV0EsRUFBWDtBQUNBaEIsT0FBSyxDQUFDTixPQUFOLENBQWM0QixNQUFkLEdBQXVCLGFBQXZCO0FBQ0F0QixPQUFLLENBQUNOLE9BQU4sQ0FBYzZCLFdBQWQsR0FBNEIsZUFBNUI7QUFDQXZCLE9BQUssQ0FBQ2pELEtBQU4sQ0FBWXlFLE1BQVosR0FBcUIsU0FBckI7QUFDQXhCLE9BQUssQ0FBQ2pELEtBQU4sQ0FBWTBFLEtBQVosR0FBb0IsT0FBcEI7QUFDQXpCLE9BQUssQ0FBQzBCLFdBQU4sR0FBb0IseUJBQXBCO0FBRUEsU0FBTzFCLEtBQVA7QUFDSDs7QUFFRCxTQUFTMkIsc0JBQVQsR0FBeUM7QUFBQSxNQUFUWCxFQUFTLHVFQUFKLEVBQUk7QUFFckMsTUFBTUMsU0FBUyxHQUFHQyxRQUFRLENBQUNDLGFBQVQsQ0FBdUIsUUFBdkIsQ0FBbEI7QUFFQUYsV0FBUyxDQUFDN0IsU0FBVixDQUFvQkUsR0FBcEIsQ0FBd0IsTUFBeEIsRUFBZ0MsU0FBaEM7QUFDQTJCLFdBQVMsQ0FBQ0QsRUFBVixHQUFlQSxFQUFmO0FBRUFDLFdBQVMsQ0FBQ0csU0FBVjtBQU1BLFNBQU9ILFNBQVA7QUFDSDs7QUFFRCxTQUFTVyxTQUFULENBQW1CNUIsS0FBbkIsRUFBMEI7QUFFdEIsTUFBSTZCLFNBQVMsR0FBRzdCLEtBQWhCOztBQUVBLE1BQUksQ0FBQzZCLFNBQUQsSUFBY0EsU0FBUyxDQUFDNUIsS0FBVixJQUFtQixFQUFyQyxFQUF5QztBQUNyQyxXQUFPLEVBQVA7QUFDSDs7QUFFRCxNQUFJNkIsY0FBYyxHQUFHRCxTQUFTLENBQUM1QixLQUFWLENBQWdCOEIsS0FBaEIsQ0FBc0IsS0FBdEIsQ0FBckI7QUFDQSxNQUFJQyxTQUFTLEdBQUdGLGNBQWMsQ0FBQyxDQUFELENBQWQsQ0FBa0JDLEtBQWxCLENBQXdCLEdBQXhCLEVBQTZCRSxPQUE3QixHQUF1Q0MsSUFBdkMsQ0FBNEMsR0FBNUMsQ0FBaEI7QUFFQSxTQUFPRixTQUFQO0FBQ0g7O0FBRUQsU0FBU0csT0FBVCxDQUFpQm5DLEtBQWpCLEVBQXdCO0FBRXBCLE1BQUk2QixTQUFTLEdBQUc3QixLQUFoQjs7QUFFQSxNQUFJLENBQUM2QixTQUFELElBQWNBLFNBQVMsQ0FBQzVCLEtBQVYsSUFBbUIsRUFBckMsRUFBeUM7QUFDckMsV0FBTyxFQUFQO0FBQ0g7O0FBRUQsTUFBSTZCLGNBQWMsR0FBR0QsU0FBUyxDQUFDNUIsS0FBVixDQUFnQjhCLEtBQWhCLENBQXNCLEtBQXRCLENBQXJCO0FBQ0EsTUFBSUssVUFBVSxHQUFHTixjQUFjLENBQUMsQ0FBRCxDQUFkLENBQWtCQyxLQUFsQixDQUF3QixHQUF4QixFQUE2QkUsT0FBN0IsR0FBdUNDLElBQXZDLENBQTRDLEdBQTVDLENBQWpCO0FBRUEsU0FBT0UsVUFBUDtBQUNIOztBQUVELFNBQVNDLFNBQVQsQ0FBbUJ0RCxPQUFuQixFQUE0QnVELFFBQTVCLEVBQXNDO0FBRWxDdkQsU0FBTyxDQUFDOUQsSUFBUixDQUFhLGVBQWI7QUFDQThELFNBQU8sQ0FBQ3dELFFBQVIsQ0FBaUIsZUFBakI7QUFDQXhELFNBQU8sQ0FBQ3lELFdBQVIsQ0FBb0IsYUFBcEI7QUFDQXpELFNBQU8sQ0FBQzhCLElBQVIsQ0FBYSxVQUFiLEVBQXlCLElBQXpCO0FBQ0F5QixVQUFRLENBQUN6QixJQUFULENBQWMsU0FBZCxFQUF5QixLQUF6QjtBQUNIOztBQUVELFNBQVM0QixjQUFULENBQXdCQyxNQUF4QixFQUFnQ0osUUFBaEMsRUFBMEM7QUFDdENJLFFBQU0sQ0FBQ3pILElBQVAsQ0FBWSx1QkFBWjtBQUNBeUgsUUFBTSxDQUFDSCxRQUFQLENBQWdCLGVBQWhCO0FBQ0FHLFFBQU0sQ0FBQ0YsV0FBUCxDQUFtQixhQUFuQjtBQUNBRSxRQUFNLENBQUM3QixJQUFQLENBQVksVUFBWixFQUF3QixJQUF4QjtBQUNBeUIsVUFBUSxDQUFDekIsSUFBVCxDQUFjLFNBQWQsRUFBeUIsS0FBekI7QUFDSCxDLENBR0Q7QUFDQTtBQUNBOzs7QUFFQSxTQUFTOEIsaUJBQVQsQ0FBMkJDLEtBQTNCLEVBQWtDO0FBRTlCQSxPQUFLLENBQUNDLGNBQU47QUFFQSxNQUFJQyxVQUFVLEdBQUcsS0FBS0MsSUFBTCxDQUFVaEIsS0FBVixDQUFnQixPQUFoQixFQUF5QixDQUF6QixDQUFqQjtBQUNBLE1BQUkxRCxNQUFNLEdBQUcxQixDQUFDLENBQUMsZUFBRCxDQUFELENBQW1CcUcsR0FBbkIsRUFBYjtBQUVBQyxtQkFBaUIsQ0FBQ0gsVUFBRCxFQUFhekUsTUFBYixDQUFqQjtBQUVIOztBQUVELFNBQVM2RSxhQUFULEdBQXlCO0FBRXJCQyxjQUFZLENBQUMvSSxLQUFELENBQVo7O0FBRUEsTUFBSSxLQUFLNkYsS0FBTCxDQUFXZCxNQUFYLEdBQW9CLENBQXBCLElBQXlCLEtBQUtjLEtBQUwsSUFBYyxFQUEzQyxFQUErQztBQUMzQzdGLFNBQUssR0FBR2dKLFVBQVUsQ0FBQ0gsaUJBQUQsRUFBb0IsR0FBcEIsRUFBeUIsQ0FBekIsRUFBNEIsRUFBNUIsQ0FBbEI7QUFDSCxHQUZELE1BRU87QUFDSDdJLFNBQUssR0FBR2dKLFVBQVUsQ0FBQ0gsaUJBQUQsRUFBb0IsR0FBcEIsRUFBeUIsQ0FBekIsRUFBNEIsS0FBS2hELEtBQWpDLENBQWxCO0FBQ0g7QUFFSjs7QUFFRCxTQUFTb0QsWUFBVCxHQUF3QjtBQUVwQixNQUFJQyxLQUFLLEdBQUczRyxDQUFDLENBQUMsa0JBQUQsQ0FBRCxDQUFzQixDQUF0QixDQUFaO0FBQ0EsTUFBSTRHLEtBQUssR0FBR0QsS0FBSyxDQUFDNUQsT0FBTixDQUFjNkQsS0FBMUI7QUFDQSxNQUFJQyxPQUFPLEdBQUdGLEtBQUssQ0FBQzVELE9BQU4sQ0FBY3NCLEVBQTVCO0FBQ0EsTUFBSXlDLFFBQVEsR0FBR0gsS0FBSyxDQUFDNUQsT0FBTixDQUFjK0QsUUFBN0I7QUFDQSxNQUFJQyxJQUFJLEdBQUdKLEtBQUssQ0FBQzVELE9BQU4sQ0FBY2dFLElBQXpCO0FBRUEsTUFBSWxILEtBQUssR0FBRztBQUNSLFdBQU87QUFDSG1ILFNBQUcsWUFBSyxLQUFLakUsT0FBTCxDQUFha0UsV0FBbEI7QUFEQTtBQURDLEdBQVo7O0FBTUEsTUFBSUYsSUFBSSxJQUFJLFNBQVosRUFBdUI7QUFDbkJHLGlCQUFhLENBQUNKLFFBQUQsQ0FBYixDQUF3QmpILEtBQXhCLENBQThCc0gsTUFBOUIsQ0FBcUN0SCxLQUFyQztBQUNOLEdBRkUsTUFHRSxJQUFJa0gsSUFBSSxJQUFJLFVBQVosRUFBd0I7QUFDdEJLLE1BQUUsQ0FBRU4sUUFBRixFQUNFLHNCQURGLDJDQUVpQyxLQUFLL0QsT0FBTCxDQUFha0UsV0FGOUMsc0JBRW1FLEtBQUtsRSxPQUFMLENBQWFzRSxJQUZoRixXQUFGO0FBSU4sR0FMSSxNQU1BLElBQUtOLElBQUksSUFBSSxTQUFiLEVBQXlCO0FBRTdCL0csS0FBQyxDQUFDLHdCQUFELENBQUQsQ0FBNEI2RixXQUE1QixDQUF3QyxRQUF4QztBQUNBeUIsZ0JBQVksQ0FBQ1YsS0FBRCxFQUFRQyxPQUFSLEVBQWlCLEtBQUs5RCxPQUFMLENBQWF3RSxPQUE5QixDQUFaO0FBQ0E7QUFDQSxHQUxJLE1BTUc7QUFFREMsc0JBQWtCLENBQUNaLEtBQUQsRUFBUUMsT0FBUixFQUFpQixLQUFLOUQsT0FBTCxDQUFha0UsV0FBOUIsQ0FBbEI7QUFFSDs7QUFFRGpILEdBQUMsQ0FBQyxnQkFBRCxDQUFELENBQW9CMkcsS0FBcEIsQ0FBMEIsTUFBMUI7QUFFSDs7QUFFRCxTQUFTTCxpQkFBVCxDQUEyQkgsVUFBM0IsRUFBdUN6RSxNQUF2QyxFQUErQztBQUUzQytGLE9BQUssQ0FBQ0MsR0FBTixrQkFBMkI7QUFDdkJDLFVBQU0sRUFBRTtBQUNKQyxVQUFJLEVBQUV6QixVQURGO0FBRUp6RSxZQUFNLEVBQU5BO0FBRkk7QUFEZSxHQUEzQixFQU1LbUcsSUFOTCxDQU1VLFVBQUNDLEdBQUQsRUFBUztBQUNYLFFBQUlDLE9BQU8sR0FBRy9ILENBQUMsQ0FBQyxrQkFBRCxDQUFELENBQXNCLENBQXRCLENBQWQ7QUFDQStILFdBQU8sQ0FBQ3RELFNBQVIsR0FBb0JxRCxHQUFHLENBQUMvSCxJQUF4QjtBQUVBLFFBQUlpSSxVQUFVLEdBQUdELE9BQU8sQ0FBQ0Usc0JBQVIsQ0FBK0IscUJBQS9CLENBQWpCO0FBQ0EsUUFBSUMsT0FBTyxHQUFHSCxPQUFPLENBQUNFLHNCQUFSLENBQStCLGNBQS9CLENBQWQ7O0FBRUEsU0FBSyxJQUFJcEwsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR3FMLE9BQU8sQ0FBQzFGLE1BQTVCLEVBQW9DM0YsQ0FBQyxFQUFyQyxFQUF5QztBQUNyQ3FMLGFBQU8sQ0FBQ3JMLENBQUQsQ0FBUCxDQUFXc0wsbUJBQVgsQ0FBK0IsT0FBL0IsRUFBd0N6QixZQUF4QztBQUNad0IsYUFBTyxDQUFDckwsQ0FBRCxDQUFQLENBQVd1TCxnQkFBWCxDQUE0QixPQUE1QixFQUFxQzFCLFlBQXJDO0FBQ1M7O0FBRUQsU0FBSyxJQUFJN0osRUFBQyxHQUFHLENBQWIsRUFBZ0JBLEVBQUMsR0FBR21MLFVBQVUsQ0FBQ3hGLE1BQS9CLEVBQXVDM0YsRUFBQyxFQUF4QyxFQUE0QztBQUN4Q21MLGdCQUFVLENBQUNuTCxFQUFELENBQVYsQ0FBY3NMLG1CQUFkLENBQWtDLE9BQWxDLEVBQTJDbkMsaUJBQTNDOztBQUNBZ0MsZ0JBQVUsQ0FBQ25MLEVBQUQsQ0FBVixDQUFjdUwsZ0JBQWQsQ0FBK0IsT0FBL0IsRUFBd0NwQyxpQkFBeEM7QUFDSDtBQUNKLEdBdEJMO0FBdUJIOztBQUVELFNBQVN3QixrQkFBVCxDQUE0QmEsU0FBNUIsRUFBdUNoRSxFQUF2QyxFQUEyQzJDLEdBQTNDLEVBQWdEO0FBQy9DLE1BQUssT0FBTzNDLEVBQVAsS0FBYyxXQUFkLElBQTZCZ0UsU0FBUyxJQUFJLFdBQS9DLEVBQTZEO0FBQzVELFFBQUl0SixHQUFHLEdBQUdpQixDQUFDLENBQUMsY0FBRCxDQUFELENBQWtCLENBQWxCLENBQVY7QUFDQSxRQUFJc0ksWUFBWSxHQUFHdEksQ0FBQyxDQUFDLG1CQUFELENBQUQsQ0FBdUJwRCxNQUF2QixFQUFuQjtBQUVBbUMsT0FBRyxDQUFDd0osR0FBSixhQUFhdkIsR0FBYjtBQUNBakksT0FBRyxDQUFDMEQsU0FBSixDQUFjQyxNQUFkLENBQXFCLFFBQXJCO0FBRUE0RixnQkFBWSxDQUFDekMsV0FBYixDQUF5QixRQUF6QjtBQUNBeUMsZ0JBQVksQ0FBQzFDLFFBQWIsQ0FBc0IsUUFBdEI7QUFFTTVGLEtBQUMsQ0FBQyxjQUFELENBQUQsQ0FBa0IsQ0FBbEIsRUFBcUJzRCxLQUFyQixhQUFnQzBELEdBQWhDO0FBRUgsR0FaSixNQVlVO0FBQ0hTLFNBQUssQ0FBQ2UsS0FBTixDQUFZLHNCQUFaLEVBQW9DO0FBQ2hDSCxlQUFTLEVBQVRBLFNBRGdDO0FBQ3JCaEUsUUFBRSxFQUFGQSxFQURxQjtBQUNqQjJDLFNBQUcsRUFBSEE7QUFEaUIsS0FBcEMsRUFHS2EsSUFITCxDQUdVLFVBQUFDLEdBQUcsRUFBSTtBQUVyQixVQUFJL0ksR0FBRyxHQUFHaUIsQ0FBQyxDQUFDLGNBQUQsQ0FBRCxDQUFrQixDQUFsQixDQUFWO0FBQ0EsVUFBSXNJLFlBQVksR0FBR3RJLENBQUMsQ0FBQyxtQkFBRCxDQUFELENBQXVCcEQsTUFBdkIsRUFBbkI7QUFFQW1DLFNBQUcsQ0FBQ3dKLEdBQUosR0FBVVQsR0FBRyxDQUFDL0gsSUFBSixDQUFTMEksTUFBbkI7QUFDQTFKLFNBQUcsQ0FBQzBELFNBQUosQ0FBY0MsTUFBZCxDQUFxQixRQUFyQjtBQUVBMUMsT0FBQyxDQUFDLG1CQUFELENBQUQsQ0FBdUIxQixJQUF2QixDQUE0QixRQUE1QjtBQUNBMEIsT0FBQyxDQUFDLGVBQUQsQ0FBRCxDQUFtQjRGLFFBQW5CLENBQTRCLFFBQTVCO0FBRUEwQyxrQkFBWSxDQUFDekMsV0FBYixDQUF5QixRQUF6QjtBQUNBeUMsa0JBQVksQ0FBQzFDLFFBQWIsQ0FBc0IsUUFBdEI7QUFFWWpJLGdCQUFVLENBQUMsU0FBRCxFQUFZLGtCQUFaLENBQVY7QUFDSCxLQWxCTCxXQW1CVyxVQUFBK0ssR0FBRyxFQUFJO0FBQ1ZDLGFBQU8sQ0FBQ0MsR0FBUixDQUFZRixHQUFaO0FBQ0EvSyxnQkFBVSxDQUFDLE9BQUQsRUFBVSxtQ0FBVixDQUFWO0FBQ0gsS0F0Qkw7QUF1Qkg7QUFDSjs7QUFFRCxTQUFTMkosWUFBVCxDQUFzQmUsU0FBdEIsRUFBaUNoRSxFQUFqQyxFQUFxQ2tELE9BQXJDLEVBQThDO0FBRTdDRSxPQUFLLENBQUNvQixJQUFOLENBQVksZ0JBQVosRUFBOEI7QUFDN0JSLGFBQVMsRUFBVEEsU0FENkI7QUFFN0J4QixXQUFPLEVBQUV4QyxFQUZvQjtBQUc3QnlFLE9BQUcsRUFBRSxDQUFDdkIsT0FBRDtBQUh3QixHQUE5QixFQUtDTSxJQUxELENBS08sVUFBQUMsR0FBRyxFQUFJO0FBRWIsUUFBSUMsT0FBTyxHQUFHL0gsQ0FBQyxDQUFDLGNBQUQsQ0FBZjtBQUNBK0gsV0FBTyxDQUFDZ0IsSUFBUixDQUFhakIsR0FBRyxDQUFDL0gsSUFBakI7QUFFQSxRQUFJaUosU0FBUyxHQUFHakIsT0FBTyxDQUFDa0IsSUFBUixDQUFhLGtCQUFiLENBQWhCO0FBQ0FELGFBQVMsQ0FBQ25GLEVBQVYsQ0FBYSxPQUFiLEVBQXNCcUYsa0JBQXRCO0FBRUF2TCxjQUFVLENBQUMsU0FBRCxFQUFZLHNCQUFaLENBQVY7QUFDQW9LLFdBQU8sQ0FBQ3BCLEtBQVIsQ0FBYyxNQUFkO0FBRUEsUUFBSXdDLElBQUksR0FBR25KLENBQUMsQ0FBQywwQkFBRCxDQUFaO0FBQ0EsUUFBSW9KLFVBQVUsR0FBR3BKLENBQUMsQ0FBQyxzQkFBRCxDQUFsQjtBQUVBcUosb0JBQWdCLENBQUVGLElBQUYsRUFBUUMsVUFBUixDQUFoQjtBQUNBLEdBcEJELFdBcUJRLFVBQUFWLEdBQUcsRUFBSTtBQUNkQyxXQUFPLENBQUNDLEdBQVIsQ0FBWUYsR0FBWjtBQUNBL0ssY0FBVSxDQUFDLE9BQUQsRUFBVSxtQ0FBVixDQUFWO0FBQ0EsR0F4QkQ7QUF5QkE7O0FBR0QsU0FBU3VMLGtCQUFULEdBQThCO0FBQUE7O0FBQzdCcEwsTUFBSSxDQUFDQyxJQUFMLENBQVU7QUFDVEgsUUFBSSxFQUFFLE1BREc7QUFFVE0sU0FBSyxFQUFFLFVBRkU7QUFHVEksUUFBSSxFQUFFLHVDQUhHO0FBSVRDLG9CQUFnQixFQUFFLElBSlQ7QUFLVEMsc0JBQWtCLEVBQUUsU0FMWDtBQU1UQyxxQkFBaUIseUVBTlI7QUFPVEMsb0JBQWdCLEVBQUU7QUFQVCxHQUFWLEVBU0NtSixJQVRELENBU00sVUFBQ3lCLE1BQUQsRUFBWTtBQUVqQixRQUFLQSxNQUFNLENBQUNDLFdBQVosRUFBMEI7QUFDekJDLGtCQUFZLENBQUUsQ0FBQyxLQUFJLENBQUN6RyxPQUFMLENBQWF3RSxPQUFkLENBQUYsQ0FBWjtBQUNBO0FBRUQsR0FmRDtBQWdCQTs7QUFFRCxTQUFTaUMsWUFBVCxDQUF1QlYsR0FBdkIsRUFBNkI7QUFFNUIsTUFBSWYsT0FBTyxHQUFHL0gsQ0FBQyxDQUFDLGNBQUQsQ0FBRCxDQUFrQixDQUFsQixDQUFkO0FBQ0EsTUFBSXFJLFNBQVMsR0FBR04sT0FBTyxDQUFDaEYsT0FBUixDQUFnQnNGLFNBQWhDO0FBQ0EsTUFBSXhCLE9BQU8sR0FBR2tCLE9BQU8sQ0FBQ2hGLE9BQVIsQ0FBZ0I4RCxPQUE5QjtBQUVBWSxPQUFLLENBQUNvQixJQUFOLENBQVcsdUJBQVgsRUFBb0M7QUFDbkNSLGFBQVMsRUFBVEEsU0FEbUM7QUFDeEJ4QixXQUFPLEVBQVBBLE9BRHdCO0FBQ2ZpQyxPQUFHLEVBQUhBO0FBRGUsR0FBcEMsRUFHQ2pCLElBSEQsQ0FHTyxVQUFBQyxHQUFHLEVBQUk7QUFFYixRQUFJQyxPQUFPLEdBQUcvSCxDQUFDLENBQUMsY0FBRCxDQUFmO0FBQ0ErSCxXQUFPLENBQUNnQixJQUFSLENBQWFqQixHQUFHLENBQUMvSCxJQUFqQjtBQUVBLFFBQUlpSixTQUFTLEdBQUdqQixPQUFPLENBQUNrQixJQUFSLENBQWEsa0JBQWIsQ0FBaEI7QUFDQUQsYUFBUyxDQUFDbkYsRUFBVixDQUFhLE9BQWIsRUFBc0JxRixrQkFBdEI7O0FBRUEsUUFBS0YsU0FBUyxDQUFDeEcsTUFBVixJQUFvQixDQUF6QixFQUE2QjtBQUM1QnhDLE9BQUMsQ0FBQyx3QkFBRCxDQUFELENBQTRCNEYsUUFBNUIsQ0FBcUMsUUFBckM7QUFDQTtBQUVELEdBZkQsV0FnQlEsVUFBQThDLEdBQUcsRUFBSTtBQUNkQyxXQUFPLENBQUNDLEdBQVIsQ0FBWUYsR0FBWjtBQUNBZSxhQUFTLENBQUM5TCxVQUFWLENBQXNCLE9BQXRCLEVBQStCLG1DQUEvQjtBQUNBLEdBbkJEO0FBcUJBOztBQUlELFNBQVMwTCxnQkFBVCxDQUEyQkYsSUFBM0IsRUFBaUNDLFVBQWpDLEVBQThDO0FBRTdDRCxNQUFJLENBQUM3SyxJQUFMLENBQVUsY0FBVjtBQUNBNkssTUFBSSxDQUFDakYsSUFBTCxDQUFVLFVBQVYsRUFBc0IsSUFBdEI7QUFDQWlGLE1BQUksQ0FBQ3RELFdBQUwsQ0FBaUIsYUFBakI7QUFDQXNELE1BQUksQ0FBQ3ZELFFBQUwsQ0FBYyxlQUFkOztBQUVBLE9BQUssSUFBSS9JLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUd1TSxVQUFVLENBQUM1RyxNQUEvQixFQUF1QzNGLENBQUMsRUFBeEMsRUFBNEM7QUFDM0N1TSxjQUFVLENBQUN2TSxDQUFELENBQVYsQ0FBYzBGLE9BQWQsR0FBd0IsS0FBeEI7QUFDQTtBQUVELEMsQ0FFRDtBQUNBO0FBQ0E7OztBQUVlO0FBQ1g1RSxZQUFVLEVBQVZBLFVBRFc7QUFFWHNFLHNCQUFvQixFQUFwQkEsb0JBRlc7QUFHWFksdUJBQXFCLEVBQXJCQSxxQkFIVztBQUlYVSxjQUFZLEVBQVpBLFlBSlc7QUFLWHBDLGFBQVcsRUFBWEEsV0FMVztBQU1YNEMsbUJBQWlCLEVBQWpCQSxpQkFOVztBQU9YN0QsZ0JBQWMsRUFBZEEsY0FQVztBQVFYa0UsbUJBQWlCLEVBQWpCQSxpQkFSVztBQVNYOUQsa0JBQWdCLEVBQWhCQSxnQkFUVztBQVVYakMsa0JBQWdCLEVBQWhCQSxnQkFWVztBQVdYK0UsYUFBVyxFQUFYQSxXQVhXO0FBWVhzQixlQUFhLEVBQWJBLGFBWlc7QUFhWE8sV0FBUyxFQUFUQSxTQWJXO0FBY1hPLFNBQU8sRUFBUEEsT0FkVztBQWVYRSxXQUFTLEVBQVRBLFNBZlc7QUFnQlhJLGdCQUFjLEVBQWRBLGNBaEJXO0FBaUJYZCx3QkFBc0IsRUFBdEJBLHNCQWpCVztBQWtCWGdCLG1CQUFpQixFQUFqQkEsaUJBbEJXO0FBbUJYTyxlQUFhLEVBQWJBLGFBbkJXO0FBb0JYRyxjQUFZLEVBQVpBLFlBcEJXO0FBcUJkSixtQkFBaUIsRUFBakJBLGlCQXJCYztBQXNCZCtDLGtCQUFnQixFQUFoQkEsZ0JBdEJjO0FBdUJkSCxvQkFBa0IsRUFBbEJBLGtCQXZCYztBQXdCZE0sY0FBWSxFQUFaQSxZQXhCYztBQXlCZDdLLGVBQWEsRUFBYkEsYUF6QmM7QUEwQmRqQixjQUFZLEVBQVpBO0FBMUJjLENBQWYiLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvZGFzaGJvYXJkL21haW4uanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJFbGVtZW50LnByb3RvdHlwZS5maW5kUGFyZW50ID0gZnVuY3Rpb24gKGxvb3BzKSB7XHJcbiAgICBsZXQgcGFyZW50ID0gdGhpcztcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxvb3BzOyBpKyspIHtcclxuICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50RWxlbWVudDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcGFyZW50O1xyXG59LCBmYWxzZTtcclxuXHJcbkVsZW1lbnQucHJvdG90eXBlLmFwcGVuZEJlZm9yZSA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XHJcbiAgICBlbGVtZW50LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMsIGVsZW1lbnQpO1xyXG59LCBmYWxzZTtcclxuXHJcbkVsZW1lbnQucHJvdG90eXBlLmFwcGVuZEFmdGVyID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuXHJcbiAgICBlbGVtZW50LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMsIGVsZW1lbnQubmV4dFNpYmxpbmcpO1xyXG5cclxufSwgZmFsc2U7XHJcblxyXG4vLyEjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcclxuLy8hXHRcdFx0XHRHbG9iYWwgVmFyaWFibGVzXHRcdEZcdCNcclxuLy8hIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXHJcblxyXG5jb25zdCBiYXNlVXJsID0gd2luZG93LmxvY2F0aW9uLm9yaWdpbjtcclxudmFyIHRpbWVyID0gMDtcclxuZXhwb3J0IGNvbnN0IEFMTE9XRURUWVBFUyA9IFtcclxuXHRcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiLCBcImFwcGxpY2F0aW9uL3gtemlwLWNvbXByZXNzZWRcIiwgXCJhcHBsaWNhdGlvbi9wZGZcIixcclxuXHRcImFwcGxpY2F0aW9uL21zd29yZFwiLCBcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC53b3JkcHJvY2Vzc2luZ21sLmRvY3VtZW50XCIsXHJcblx0XCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQud29yZHByb2Nlc3NpbmdtbC50ZW1wbGF0ZVwiLCBcImFwcGxpY2F0aW9uL3ZuZC5tcy13b3JkLmRvY3VtZW50Lm1hY3JvRW5hYmxlZC4xMlwiLFxyXG5cdFwiYXBwbGljYXRpb24vdm5kLm1zLXdvcmQudGVtcGxhdGUubWFjcm9FbmFibGVkLjEyXCIsIFwiYXBwbGljYXRpb24vdm5kLm1zLWV4Y2VsXCIsIFwiYXBwbGljYXRpb24vdm5kLm1zLWV4Y2VsXCIsIFwiYXBwbGljYXRpb24vdm5kLm1zLWV4Y2VsXCIsXHJcblx0XCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQuc3ByZWFkc2hlZXRtbC5zaGVldFwiLCBcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5zcHJlYWRzaGVldG1sLnRlbXBsYXRlXCIsXHJcblx0XCJhcHBsaWNhdGlvbi92bmQubXMtZXhjZWwuc2hlZXQubWFjcm9FbmFibGVkLjEyXCIsIFwiYXBwbGljYXRpb24vdm5kLm1zLWV4Y2VsLnRlbXBsYXRlLm1hY3JvRW5hYmxlZC4xMlwiLFxyXG5cdFwiYXBwbGljYXRpb24vdm5kLm1zLWV4Y2VsLmFkZGluLm1hY3JvRW5hYmxlZC4xMlwiLCBcImFwcGxpY2F0aW9uL3ZuZC5tcy1leGNlbC5zaGVldC5iaW5hcnkubWFjcm9FbmFibGVkLjEyXCIsXHJcblx0XCJhcHBsaWNhdGlvbi92bmQubXMtcG93ZXJwb2ludFwiLCBcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5wcmVzZW50YXRpb25tbC5wcmVzZW50YXRpb25cIixcclxuXHRcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5wcmVzZW50YXRpb25tbC50ZW1wbGF0ZVwiLCBcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5wcmVzZW50YXRpb25tbC5zbGlkZXNob3dcIixcclxuXHRcImFwcGxpY2F0aW9uL3ZuZC5tcy1wb3dlcnBvaW50LmFkZGluLm1hY3JvRW5hYmxlZC4xMlwiLCBcImFwcGxpY2F0aW9uL3ZuZC5tcy1wb3dlcnBvaW50LnByZXNlbnRhdGlvbi5tYWNyb0VuYWJsZWQuMTJcIixcclxuXHRcImFwcGxpY2F0aW9uL3ZuZC5tcy1wb3dlcnBvaW50LnRlbXBsYXRlLm1hY3JvRW5hYmxlZC4xMlwiLCBcImFwcGxpY2F0aW9uL3ZuZC5tcy1wb3dlcnBvaW50LnNsaWRlc2hvdy5tYWNyb0VuYWJsZWQuMTJcIixcclxuXHRcImFwcGxpY2F0aW9uL3ZuZC5tcy1hY2Nlc3NcIiwgXCJhdWRpby9tcGVnXCIsIFwiYXBwbGljYXRpb24vdm5kLm9hc2lzLm9wZW5kb2N1bWVudC5wcmVzZW50YXRpb25cIixcclxuXHRcImFwcGxpY2F0aW9uL3ZuZC5vYXNpcy5vcGVuZG9jdW1lbnQuc3ByZWFkc2hlZXRcIiwgXCJhcHBsaWNhdGlvbi92bmQub2FzaXMub3BlbmRvY3VtZW50LnRleHRcIixcclxuXHRcImFwcGxpY2F0aW9uL3J0ZlwiLCBcImFwcGxpY2F0aW9uL3ZuZC5vYXNpcy5vcGVuZG9jdW1lbnQuZ3JhcGhpY3NcIiwgXCJ0ZXh0L2h0bWxcIlxyXG5dO1xyXG5cclxuLy8hIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXHJcbi8vIVx0XHRcdFx0Q29uZmlndXJhdGlvbnNcdFx0XHRcdCNcclxuLy8hIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXHJcblxyXG4vLyFBTEVSVFxyXG4vLyE9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuZnVuY3Rpb24gdG9hc3RBbGVydChpY29uLCBtZXNzYWdlKSB7XHJcbiAgICBTd2FsLmZpcmUoe1xyXG4gICAgICAgIHRvYXN0OiAndHJ1ZScsXHJcbiAgICAgICAgcG9zaXRpb246ICd0b3AtZW5kJyxcclxuICAgICAgICBpY29uOiBpY29uLFxyXG4gICAgICAgIHRpdGxlOiBtZXNzYWdlLFxyXG4gICAgICAgIHNob3dDb25maXJtQnV0dG9uOiBmYWxzZSxcclxuICAgICAgICB0aW1lcjogMzAwMCxcclxuICAgICAgICB0aW1lclByb2dyZXNzQmFyOiB0cnVlXHJcbiAgICB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gdG9hc3RBbGVydERlbGV0ZSh0ZXh0LCBpY29uID0gXCJ3YXJuaW5nXCIpIHtcclxuICAgIHJldHVybiBTd2FsLmZpcmUoe1xyXG4gICAgICAgIHRpdGxlOiAnzpXOr8+Dz4TOtSDPg86vzrPOv8+Fz4HOv8+COycsXHJcbiAgICAgICAgdGV4dDogdGV4dCxcclxuICAgICAgICBpY29uOiBpY29uLFxyXG5cdFx0c2hvd0NhbmNlbEJ1dHRvbjogdHJ1ZSxcclxuXHRcdGNvbmZpcm1CdXR0b25Db2xvcjogJyNmZjViNWInLFxyXG4gICAgICAgIGNvbmZpcm1CdXR0b25UZXh0OiAnzp3Osc6vLCDOtM65zrHOs8+BzrHPhs6uIScsXHJcbiAgICAgICAgY2FuY2VsQnV0dG9uVGV4dDogJ86GzrrPhc+Bzr8nXHJcbiAgICB9KTtcclxufVxyXG5cclxuXHJcbi8vIUNPTkZJR1xyXG4vLyE9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuY29uc3QgYXJ0aWNsZUNvbmZpZyA9IHtcclxuXHRjc3M6IFwiL2Nzcy9cIixcclxuXHRjdXN0b206IHtcclxuXHRcdGNzczogW1xyXG5cdFx0XHRcIi9jc3MvYm9vdHN0cmFwLm1pbi5jc3NcIixcclxuXHRcdFx0XCIvY3NzL2N1c3RvbUFydGljbGVTdHlsZS5jc3NcIixcclxuXHRcdF1cclxuXHR9LFxyXG5cdC8vIHBsdWdpbnM6IFsnbWVkaWFMaWJyYXJ5JywgJ3Jlb3JkZXInXSxcclxuXHRjbGFzc2VzOiB7XHJcblx0XHRpbWc6ICdpbWctZmx1aWQnLFxyXG5cdFx0cDogJ3RleHQtd3JhcCdcclxuXHR9LFxyXG5cdGdyaWQ6IHtcclxuXHRcdGNsYXNzbmFtZTogJ3JvdycsXHJcblx0XHRjb2x1bW5zOiAxMixcclxuXHRcdGd1dHRlcjogJzFweCcsXHJcblx0XHRvZmZzZXQ6IHtcclxuXHRcdFx0bGVmdDogJzE1cHgnLFxyXG5cdFx0XHRyaWdodDogJzE1cHgnXHJcblx0XHR9LFxyXG5cdFx0cGF0dGVybnM6IHtcclxuXHRcdFx0JzZ8Nic6ICdjb2wtNnxjb2wtNicsXHJcblx0XHRcdCc0fDR8NCc6ICdjb2wtNHxjb2wtNHxjb2wtNCcsXHJcblx0XHRcdCczfDN8M3wzJzogJ2NvbC0zfGNvbC0zfGNvbC0zfGNvbC0zJyxcclxuXHRcdFx0JzJ8MnwyfDJ8MnwyJzogJ2NvbC0yfGNvbC0yfGNvbC0yfGNvbC0yfGNvbC0yfGNvbC0yJyxcclxuXHRcdFx0JzN8NnwzJzogJ2NvbC0zfGNvbC02fGNvbC0zJyxcclxuXHRcdFx0JzJ8OHwyJzogJ2NvbC0yfGNvbC04fGNvbC0yJyxcclxuXHRcdFx0JzV8Nyc6ICdjb2wtNXxjb2wtNycsXHJcblx0XHRcdCc3fDUnOiAnY29sLTd8Y29sLTUnLFxyXG5cdFx0XHQnNHw4JzogJ2NvbC00fGNvbC04JyxcclxuXHRcdFx0Jzh8NCc6ICdjb2wtOHxjb2wtNCcsXHJcblx0XHRcdCczfDknOiAnY29sLTN8Y29sLTknLFxyXG5cdFx0XHQnOXwzJzogJ2NvbC05fGNvbC0zJyxcclxuXHRcdFx0JzJ8MTAnOiAnY29sLTJ8Y29sLTEwJyxcclxuXHRcdFx0JzEwfDInOiAnY29sLTEwfGNvbC0yJyxcclxuXHRcdFx0JzEyJzogJ2NvbC0xMidcclxuXHRcdH1cclxuXHR9LFxyXG5cdGFsaWduOiB7XHJcblx0XHRsZWZ0OiBcInRleHQtbGVmdFwiLFxyXG5cdFx0Y2VudGVyOiBcInRleHQtY2VudGVyXCIsXHJcblx0XHRyaWdodDogXCJ0ZXh0LXJpZ2h0XCIsXHJcblx0fSxcclxuXHRlZGl0b3I6IHtcclxuXHRcdG1pbkhlaWdodDogXCIzMDBweFwiXHJcblx0fSxcclxuXHRpbWFnZToge1xyXG5cdFx0dXBsb2FkOiBcIi9tZWRpYS91cGxvYWQtaW1hZ2VzXCIsXHJcblx0XHRkYXRhOiB7XHJcblx0XHRcdFwiX3Rva2VuXCI6ICQoJ21ldGFbbmFtZT1cImNzcmYtdG9rZW5cIl0nKS5hdHRyKCdjb250ZW50JyksXHJcblx0XHR9XHJcblx0fVxyXG59XHJcblxyXG5jb25zdCByZWRhY3RvckNvbmZpZyA9IHtcclxuICAgIGJ1dHRvbnM6IFtcclxuXHRcdCdodG1sJywgJ3VuZG8nLCAncmVkbycsICdmb3JtYXQnLFxyXG5cdFx0J2JvbGQnLCAndW5kZXJsaW5lJywgJ2l0YWxpYycsICdkZWxldGVkJyxcclxuXHRcdCdzdXAnLCAnc3ViJywgJ2xpc3RzJywgJ2ZpbGUnLCAnbGluaycsICdpbWFnZSdcclxuXHRdLFxyXG5cdHN0eWxlOiBmYWxzZSxcclxuXHRwbHVnaW5zOiBbJ2FsaWdubWVudCddLFxyXG5cdG1pbkhlaWdodDogJzE1MHB4JyxcclxufVxyXG5cclxuY29uc3QgZGF0ZVBpY2tlckNvbmZpZyA9IHtcclxuICAgIHJhbmdlczoge1xyXG4gICAgICAgICdUb2RheSc6IFttb21lbnQoKSwgbW9tZW50KCldLFxyXG4gICAgICAgICdZZXN0ZXJkYXknOiBbbW9tZW50KCkuc3VidHJhY3QoMSwgJ2RheXMnKSwgbW9tZW50KCkuc3VidHJhY3QoMSwgJ2RheXMnKV0sXHJcbiAgICAgICAgJ0xhc3QgNyBEYXlzJzogW21vbWVudCgpLnN1YnRyYWN0KDYsICdkYXlzJyksIG1vbWVudCgpXSxcclxuICAgICAgICAnTGFzdCAzMCBEYXlzJzogW21vbWVudCgpLnN1YnRyYWN0KDI5LCAnZGF5cycpLCBtb21lbnQoKV0sXHJcbiAgICAgICAgJ1RoaXMgTW9udGgnOiBbbW9tZW50KCkuc3RhcnRPZignbW9udGgnKSwgbW9tZW50KCkuZW5kT2YoJ21vbnRoJyldLFxyXG4gICAgICAgICdMYXN0IE1vbnRoJzogW21vbWVudCgpLnN1YnRyYWN0KDEsICdtb250aCcpLnN0YXJ0T2YoJ21vbnRoJyksIG1vbWVudCgpLnN1YnRyYWN0KDEsICdtb250aCcpLmVuZE9mKCdtb250aCcpXSxcclxuICAgICAgICAnVGhpcyBZZWFyJzogW21vbWVudCgpLnN0YXJ0T2YoJ3llYXInKSwgbW9tZW50KCkuZW5kT2YoJ3llYXInKV0sXHJcbiAgICAgICAgJ0xhc3QgWWVhcic6IFttb21lbnQoKS5zdWJ0cmFjdCgxLCAneWVhcicpLnN0YXJ0T2YoJ3llYXInKSwgbW9tZW50KCkuc3VidHJhY3QoMSwgJ3llYXInKS5lbmRPZigneWVhcicpXVxyXG4gICAgfSxcclxuICAgIGFsd2F5c1Nob3dDYWxlbmRhcnM6IHRydWUsXHJcbiAgICBzaG93Q3VzdG9tUmFuZ2VMYWJlbDogZmFsc2UsXHJcbiAgICBkcm9wczogXCJhdXRvXCIsXHJcbiAgICBhdXRvVXBkYXRlSW5wdXQ6IGZhbHNlLFxyXG4gICAgb3BlbnM6IFwiY2VudGVyXCIsXHJcbiAgICBsb2NhbGU6IHtcclxuICAgICAgICBmb3JtYXQ6IFwiREQvTU0vWVlZWVwiLFxyXG4gICAgfSxcclxufVxyXG5cclxuY29uc3QgdGFibGVMb2NhbGUgPSB7XHJcbiAgICBlbXB0eVRhYmxlOiBcIs6UzrXOvSDPhc+AzqzPgc+Hzr/Phc69IM61zrPOs8+BzrHPhs6tz4JcIixcclxuICAgIGluZm86IFwiX1NUQVJUXyDOrc+Jz4IgX0VORF8gzrHPgM6/IM+EzrEgX1RPVEFMXyDOsc+Azr/PhM61zrvOrc+DzrzOsc+EzrFcIixcclxuICAgIGluZm9FbXB0eTogXCIwIM6xz4DOvyAwIM+EzrEgMCDOsc+Azr/PhM61zrvOrc+DzrzOsc+EzrFcIixcclxuICAgIGxlbmd0aE1lbnU6IFwiX01FTlVfXCIsXHJcbiAgICBsb2FkaW5nUmVjb3JkczogXCLOps+Mz4HPhM+Jz4POtyAuLi5cIixcclxuICAgIHByb2Nlc3Npbmc6IFwizpXPgM61zr7Otc+BzrPOsc+Dzq/OsSAuLi5cIixcclxuICAgIHNlYXJjaDogXCJcIixcclxuICAgIHNlYXJjaFBsYWNlaG9sZGVyOiBcIs6Rzr3Osc62zq7PhM63z4POty4uLiBcIixcclxuICAgIHplcm9SZWNvcmRzOiBcIs6UzrXOvSDOss+Bzq3OuM63zrrOsc69IM6xz4DOv8+EzrXOu86tz4POvM6xz4TOsVwiLFxyXG4gICAgcGFnaW5hdGU6IHtcclxuICAgICAgICBwcmV2aW91czogXCI8aSBjbGFzcz0nbWRpIG1kaS1jaGV2cm9uLWxlZnQnPlwiLFxyXG4gICAgICAgIG5leHQ6IFwiPGkgY2xhc3M9J21kaSBtZGktY2hldnJvbi1yaWdodCc+XCJcclxuXHR9LFxyXG5cdGluZm9GaWx0ZXJlZDogXCIozqbOuc67z4TPgc6xz4HOuc+DzrzOrc69zrEgzrHPgM6/IM+EzrnPgiBfTUFYXyDOtc6zzrPPgc6xz4bOrc+CKVwiXHJcbn1cclxuXHJcbi8vIUdMT0JBTCBGVU5DVElPTlxyXG4vLyE9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuZnVuY3Rpb24gbWFpbkNoZWNrYm94U3dpdGNoZXIobWFpbiwgbWlub3IsIGJ1bGtCdG4gPSBmYWxzZSkge1xyXG4gICAgbGV0IHN0YXR1cyA9IHRydWU7XHJcbiAgICBsZXQgY291bnRlciA9IDA7XHJcbiAgICBtYWluLmNoZWNrZWQgPSB0cnVlO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWlub3IubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpZiAoIW1pbm9yW2ldLmNoZWNrZWQpIHtcclxuICAgICAgICAgICAgbWlub3JbaV0uZmluZFBhcmVudCgzKS5jbGFzc0xpc3QucmVtb3ZlKFwiYmctc2VsZWN0ZWRcIik7XHJcbiAgICAgICAgICAgIG1haW4uY2hlY2tlZCA9IGZhbHNlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG1pbm9yW2ldLmZpbmRQYXJlbnQoMykuY2xhc3NMaXN0LmFkZChcImJnLXNlbGVjdGVkXCIpO1xyXG4gICAgICAgICAgICBjb3VudGVyKytcclxuICAgICAgICAgICAgc3RhdHVzID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChidWxrQnRuKSB7XHJcbiAgICAgICAgYnVsa01vZGlmaWVyKGJ1bGtCdG4sIHN0YXR1cywgY291bnRlcik7XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG1pbm9yQ2hlY2tib3hTd2l0Y2hlcihtYWluLCBtaW5vciwgYnVsa0J0biA9IGZhbHNlKSB7XHJcbiAgICBsZXQgY291bnRlciA9IDA7XHJcbiAgICBsZXQgc3RhdHVzID0gdHJ1ZTtcclxuXHJcbiAgICBpZiAobWFpbi5jaGVja2VkICYmIG1pbm9yLmxlbmd0aCA+IDApIHtcclxuXHJcbiAgICAgICAgY291bnRlciA9IG1pbm9yLmxlbmd0aDtcclxuICAgICAgICBzdGF0dXMgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtaW5vci5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBtaW5vcltpXS5jaGVja2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgbWlub3JbaV0uZmluZFBhcmVudCgzKS5jbGFzc0xpc3QuYWRkKFwiYmctc2VsZWN0ZWRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1pbm9yLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIG1pbm9yW2ldLmNoZWNrZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgbWlub3JbaV0uZmluZFBhcmVudCgzKS5jbGFzc0xpc3QucmVtb3ZlKFwiYmctc2VsZWN0ZWRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChidWxrQnRuKSB7XHJcbiAgICAgICAgYnVsa01vZGlmaWVyKGJ1bGtCdG4sIHN0YXR1cywgY291bnRlcik7XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGJ1bGtNb2RpZmllcihidWxrQnRuLCBzdGF0dXMsIHN1bSkge1xyXG5cclxuICAgIGxldCB0ZXh0ID0gYnVsa0J0bi5kYXRhc2V0LnRleHQgPyBidWxrQnRuLmRhdGFzZXQudGV4dCA6IFwizpXPgM65zrvOv86zzq3PglwiO1xyXG4gICAgbGV0IGVuYWJsZWRDb2xvciA9IGJ1bGtCdG4uZGF0YXNldC5lbmFibGVkQ29sb3IgPyBidWxrQnRuLmRhdGFzZXQuZW5hYmxlZENvbG9yIDogXCJidG4td2FybmluZ1wiO1xyXG4gICAgbGV0IGRpc2FibGVkQ29sb3IgPSBidWxrQnRuLmRhdGFzZXQuZGlzYWJsZWRDb2xvciA/IGJ1bGtCdG4uZGF0YXNldC5kaXNhYmxlZENvbG9yIDogXCJidG4tc2Vjb25kYXJ5XCI7XHJcblxyXG4gICAgaWYgKHN0YXR1cykge1xyXG4gICAgICAgIGJ1bGtCdG4uY2xhc3NMaXN0LmFkZChkaXNhYmxlZENvbG9yKVxyXG4gICAgICAgIGJ1bGtCdG4uY2xhc3NMaXN0LnJlbW92ZShlbmFibGVkQ29sb3IpXHJcbiAgICAgICAgYnVsa0J0bi50ZXh0Q29udGVudCA9IGAke3RleHR9ICgwKSAgYFxyXG4gICAgICAgIGJ1bGtCdG4uZGlzYWJsZWQgPSB0cnVlO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBidWxrQnRuLmNsYXNzTGlzdC5hZGQoZW5hYmxlZENvbG9yKTtcclxuICAgICAgICBidWxrQnRuLmNsYXNzTGlzdC5yZW1vdmUoZGlzYWJsZWRDb2xvcik7XHJcbiAgICAgICAgYnVsa0J0bi50ZXh0Q29udGVudCA9IGAke3RleHR9ICAoJHtzdW19KSAgYFxyXG4gICAgICAgIGJ1bGtCdG4uZGlzYWJsZWQgPSBmYWxzZTtcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZmlsdGVyU3R5bGUoaW5wdXQsIHZhbHVlKSB7XHJcblxyXG4gICAgaWYgKHZhbHVlID09IFwiXCIpIHtcclxuICAgICAgICBpbnB1dC5jbGFzc0xpc3QucmVtb3ZlKFwic2VsZWN0Mi1zZWxlY3RlZFwiKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaW5wdXQuY2xhc3NMaXN0LmFkZChcInNlbGVjdDItc2VsZWN0ZWRcIik7XHJcbiAgICB9XHJcblxyXG59XHJcblxyXG5jb25zdCBmaWx0ZXJCdXR0b24gPSBmdW5jdGlvbiAoYXR0ciwgY29sdW1uLCB0YWJsZSwgdGFibGVJZCkge1xyXG4gICAgJChhdHRyKS5kZXRhY2goKS5hcHBlbmRUbyh0YWJsZUlkKVxyXG5cclxuXHJcblxyXG4gICAgJChhdHRyKS5vbignY2hhbmdlJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRhYmxlLmNvbHVtbnMoY29sdW1uKS5zZWFyY2godGhpcy52YWx1ZSkuZHJhdygpO1xyXG5cclxuXHJcbiAgICB9KTtcclxufVxyXG5cclxuY29uc3QgY2hhbmdlSW5wdXRIaWRkZW4gPSAoYXR0ciwgaGlkZGVuQXR0cikgPT4ge1xyXG5cclxuICAgICQoYXR0cikuY2hhbmdlKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoYXR0ciA9PSBcIiNhY3RpdmVNYXRlcmlhbFwiKSB7XHJcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSAkKHRoaXMpLnByb3AoJ2NoZWNrZWQnKSA9PSB0cnVlID8gMSA6IDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgaGlkZGVuVmFsdWUgPSAkKGhpZGRlbkF0dHIpWzBdLnZhbHVlID0gdGhpcy52YWx1ZVxyXG5cclxuICAgIH0pXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZVN0YXRlU2VsZWN0KGlkID0gXCJcIikge1xyXG4gICAgY29uc3Qgc2VsZWN0RWxtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNlbGVjdFwiKTtcclxuICAgIHNlbGVjdEVsbS5jbGFzc0xpc3QuYWRkKFwibWwtMVwiLCBcInNlbGVjdDJcIik7XHJcbiAgICBzZWxlY3RFbG0uaWQgPSBpZDtcclxuXHJcbiAgICBzZWxlY3RFbG0uaW5uZXJIVE1MID0gYFxyXG5cdFx0PG9wdGlvbiB2YWx1ZT1cIlwiPs6MzrvOtc+CIM6/zrkgzprOsc+EzrHPg8+EzqzPg861zrnPgjwvb3B0aW9uPlxyXG5cdFx0PG9wdGlvbiB2YWx1ZT1cIjFcIj7Olc69zrXPgc6zzqw8L29wdGlvbj5cclxuXHRcdDxvcHRpb24gdmFsdWU9XCIwXCI+zpHOvc61zr3Otc+BzrPOrDwvb3B0aW9uPlxyXG5cdGA7XHJcblxyXG4gICAgcmV0dXJuIHNlbGVjdEVsbTtcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlRGF0ZUVsbShpZCkge1xyXG4gICAgbGV0IGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xyXG5cclxuICAgIGlucHV0LmNsYXNzTGlzdC5hZGQoXCJmb3JtLWNvbnRyb2xcIiwgXCJkYXRlXCIsIFwiZC1pbmxpbmUtYmxvY2tcIiwgXCJtbC0xXCIsIFwianMtZGF0ZS1zZWFyY2hcIik7XHJcbiAgICBpbnB1dC5pZCA9IGlkO1xyXG4gICAgaW5wdXQuZGF0YXNldC50b2dnbGUgPSBcImRhdGUtcGlja2VyXCI7XHJcbiAgICBpbnB1dC5kYXRhc2V0LmNhbmNlbENsYXNzID0gXCJidG4tc2Vjb25kYXJ5XCI7XHJcbiAgICBpbnB1dC5zdHlsZS5oZWlnaHQgPSBcIjMxLjk2cHhcIjtcclxuICAgIGlucHV0LnN0eWxlLndpZHRoID0gXCIxOTVweFwiO1xyXG4gICAgaW5wdXQucGxhY2Vob2xkZXIgPSBcIs6Vz4DOuc67zq3Ovs+EzrUgzrfOvM61z4HOv868zrfOvc6vzrXPgi4uLlwiO1xyXG5cclxuICAgIHJldHVybiBpbnB1dDtcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlQ291cnNlVHlwZVNlbGVjdChpZCA9IFwiXCIpIHtcclxuXHJcbiAgICBjb25zdCBzZWxlY3RFbG0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2VsZWN0XCIpO1xyXG5cclxuICAgIHNlbGVjdEVsbS5jbGFzc0xpc3QuYWRkKFwibWwtMVwiLCBcInNlbGVjdDJcIik7XHJcbiAgICBzZWxlY3RFbG0uaWQgPSBpZDtcclxuXHJcbiAgICBzZWxlY3RFbG0uaW5uZXJIVE1MID0gYFxyXG5cdFx0PG9wdGlvbiB2YWx1ZT1cIlwiPs6MzrvOtc+CIM6/zrkgzpXOus60z4zPg861zrnPgjwvb3B0aW9uPlxyXG5cdFx0PG9wdGlvbiB2YWx1ZT1cIk5vcm1hbFwiPk5vcm1hbDwvb3B0aW9uPlxyXG5cdFx0PG9wdGlvbiB2YWx1ZT1cIlRyaWFsXCI+VHJpYWw8L29wdGlvbj5cclxuXHRgO1xyXG5cclxuICAgIHJldHVybiBzZWxlY3RFbG07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHN0YXJ0RGF0ZShpbnB1dCkge1xyXG5cclxuICAgIGxldCBkYXRlSW5wdXQgPSBpbnB1dDtcclxuXHJcbiAgICBpZiAoIWRhdGVJbnB1dCB8fCBkYXRlSW5wdXQudmFsdWUgPT0gXCJcIikge1xyXG4gICAgICAgIHJldHVybiBcIlwiO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBkYXRlSW5wdXRWYWx1ZSA9IGRhdGVJbnB1dC52YWx1ZS5zcGxpdChcIiAtIFwiKTtcclxuICAgIGxldCBmaXJzdERhdGUgPSBkYXRlSW5wdXRWYWx1ZVswXS5zcGxpdChcIi9cIikucmV2ZXJzZSgpLmpvaW4oXCItXCIpO1xyXG5cclxuICAgIHJldHVybiBmaXJzdERhdGU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGVuZERhdGUoaW5wdXQpIHtcclxuXHJcbiAgICBsZXQgZGF0ZUlucHV0ID0gaW5wdXQ7XHJcblxyXG4gICAgaWYgKCFkYXRlSW5wdXQgfHwgZGF0ZUlucHV0LnZhbHVlID09IFwiXCIpIHtcclxuICAgICAgICByZXR1cm4gXCJcIjtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgZGF0ZUlucHV0VmFsdWUgPSBkYXRlSW5wdXQudmFsdWUuc3BsaXQoXCIgLSBcIik7XHJcbiAgICBsZXQgc2Vjb25kRGF0ZSA9IGRhdGVJbnB1dFZhbHVlWzFdLnNwbGl0KFwiL1wiKS5yZXZlcnNlKCkuam9pbihcIi1cIik7XHJcblxyXG4gICAgcmV0dXJuIHNlY29uZERhdGU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlc2V0QnVsayhidWxrQnRuLCBjaGVja2JveCkge1xyXG5cclxuICAgIGJ1bGtCdG4udGV4dChcIs6Vz4DOuc67zr/Os86tz4IgICgwKVwiKTtcclxuICAgIGJ1bGtCdG4uYWRkQ2xhc3MoXCJidG4tc2Vjb25kYXJ5XCIpO1xyXG4gICAgYnVsa0J0bi5yZW1vdmVDbGFzcyhcImJ0bi13YXJuaW5nXCIpO1xyXG4gICAgYnVsa0J0bi5wcm9wKFwiZGlzYWJsZWRcIiwgdHJ1ZSk7XHJcbiAgICBjaGVja2JveC5wcm9wKFwiY2hlY2tlZFwiLCBmYWxzZSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlc2V0QWRkQnV0dG9uKGFkZEJ0biwgY2hlY2tib3gpIHtcclxuICAgIGFkZEJ0bi50ZXh0KFwizqDPgc6/z4POuM6uzrrOtyDOlc+AzrnOu86/zrPPjs69ICgwKVwiKTtcclxuICAgIGFkZEJ0bi5hZGRDbGFzcyhcImJ0bi1zZWNvbmRhcnlcIik7XHJcbiAgICBhZGRCdG4ucmVtb3ZlQ2xhc3MoXCJidG4tcHJpbWFyeVwiKTtcclxuICAgIGFkZEJ0bi5wcm9wKFwiZGlzYWJsZWRcIiwgdHJ1ZSk7XHJcbiAgICBjaGVja2JveC5wcm9wKFwiY2hlY2tlZFwiLCBmYWxzZSk7XHJcbn1cclxuXHJcblxyXG4vLyEjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXHJcbi8vIVx0XHRcdFx0TWVkaWEgTGlicmFyeSBGdW5jdGlvbnNcdFx0XHQjXHJcbi8vISMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcclxuXHJcbmZ1bmN0aW9uIHBhZ2luYXRpb25IYW5kbGVyKGV2ZW50KSB7XHJcblxyXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuXHJcbiAgICBsZXQgYWN0aXZlUGFnZSA9IHRoaXMuaHJlZi5zcGxpdChcInBhZ2U9XCIpWzFdO1xyXG4gICAgbGV0IHNlYXJjaCA9ICQoXCIjaW1hZ2Utc2VhcmNoXCIpLnZhbCgpO1xyXG5cclxuICAgIHBhZ2luYXRpb25SZXF1ZXN0KGFjdGl2ZVBhZ2UsIHNlYXJjaCk7XHJcblxyXG59XHJcblxyXG5mdW5jdGlvbiBzZWFyY2hIYW5kbGVyKCkge1xyXG5cclxuICAgIGNsZWFyVGltZW91dCh0aW1lcik7XHJcblxyXG4gICAgaWYgKHRoaXMudmFsdWUubGVuZ3RoIDwgMyB8fCB0aGlzLnZhbHVlID09IFwiXCIpIHtcclxuICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQocGFnaW5hdGlvblJlcXVlc3QsIDgwMCwgMSwgXCJcIik7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRpbWVyID0gc2V0VGltZW91dChwYWdpbmF0aW9uUmVxdWVzdCwgODAwLCAxLCB0aGlzLnZhbHVlKTtcclxuICAgIH1cclxuXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGltYWdlSGFuZGxlcigpIHtcclxuXHJcbiAgICBsZXQgbW9kYWwgPSAkKFwiI2dhbGxlcnktY29udGVudFwiKVswXTtcclxuICAgIGxldCBtb2RlbCA9IG1vZGFsLmRhdGFzZXQubW9kZWw7XHJcbiAgICBsZXQgbW9kZWxJZCA9IG1vZGFsLmRhdGFzZXQuaWQ7XHJcbiAgICBsZXQgZWRpdG9ySWQgPSBtb2RhbC5kYXRhc2V0LmVkaXRvcklkO1xyXG4gICAgbGV0IHR5cGUgPSBtb2RhbC5kYXRhc2V0LnR5cGU7XHJcblxyXG4gICAgbGV0IGltYWdlID0ge1xyXG4gICAgICAgICdpbWcnOiB7XHJcbiAgICAgICAgICAgIHVybDogYCR7dGhpcy5kYXRhc2V0LmltYWdlU291cmNlfWAsXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmICh0eXBlID09IFwiYXJ0aWNsZVwiKSB7XHJcbiAgICAgICAgQXJ0aWNsZUVkaXRvcihlZGl0b3JJZCkuaW1hZ2UuaW5zZXJ0KGltYWdlKTtcclxuXHR9XHJcblx0ZWxzZSBpZiAodHlwZSA9PSBcInJlZGFjdG9yXCIpIHtcclxuICAgICAgICAkUiggZWRpdG9ySWQsXHJcbiAgICAgICAgICAgICdpbnNlcnRpb24uaW5zZXJ0SHRtbCcsXHJcbiAgICAgICAgICAgIGA8aW1nIGNsYXNzPVwiaW1nLWZsdWlkXCIgc3JjPVwiJHt0aGlzLmRhdGFzZXQuaW1hZ2VTb3VyY2V9XCIgYWx0PVwiJHt0aGlzLmRhdGFzZXQubmFtZX1cIiAvPmBcclxuICAgICAgICApO1xyXG5cdH1cclxuXHRlbHNlIGlmICggdHlwZSA9PSBcImdhbGxlcnlcIiApIHtcclxuXHJcblx0XHQkKFwiI3JlbW92ZS1hbGwtaW1hZ2VzLWJ0blwiKS5yZW1vdmVDbGFzcyhcImQtbm9uZVwiKTtcclxuXHRcdGFkZFRvR2FsbGVyeShtb2RlbCwgbW9kZWxJZCwgdGhpcy5kYXRhc2V0LmltYWdlSWQpO1xyXG5cdFx0cmV0dXJuO1xyXG5cdH1cclxuICAgIGVsc2Uge1xyXG5cclxuICAgICAgICBjaGFuZ2VDb3ZlclJlcXVlc3QobW9kZWwsIG1vZGVsSWQsIHRoaXMuZGF0YXNldC5pbWFnZVNvdXJjZSk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgICQoXCIjZ2FsbGVyeS1tb2RhbFwiKS5tb2RhbCgnaGlkZScpO1xyXG5cclxufVxyXG5cclxuZnVuY3Rpb24gcGFnaW5hdGlvblJlcXVlc3QoYWN0aXZlUGFnZSwgc2VhcmNoKSB7XHJcblxyXG4gICAgYXhpb3MuZ2V0KGAvbWVkaWEvaW1hZ2VzYCwge1xyXG4gICAgICAgIHBhcmFtczoge1xyXG4gICAgICAgICAgICBwYWdlOiBhY3RpdmVQYWdlLFxyXG4gICAgICAgICAgICBzZWFyY2hcclxuICAgICAgICB9XHJcbiAgICB9KVxyXG4gICAgICAgIC50aGVuKChyZXMpID0+IHtcclxuICAgICAgICAgICAgbGV0IGdhbGxlcnkgPSAkKFwiI2dhbGxlcnktY29udGVudFwiKVswXVxyXG4gICAgICAgICAgICBnYWxsZXJ5LmlubmVySFRNTCA9IHJlcy5kYXRhO1xyXG5cclxuICAgICAgICAgICAgbGV0IHBhZ2luYXRpb24gPSBnYWxsZXJ5LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoXCJqcy1nYWxsZXJ5LXBhZ2UtYnRuXCIpO1xyXG4gICAgICAgICAgICBsZXQgYWRkQnRucyA9IGdhbGxlcnkuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcImpzLWFkZC1pbWFnZVwiKTtcclxuXHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWRkQnRucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgYWRkQnRuc1tpXS5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgaW1hZ2VIYW5kbGVyKTtcclxuXHRcdFx0XHRhZGRCdG5zW2ldLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBpbWFnZUhhbmRsZXIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhZ2luYXRpb24ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHBhZ2luYXRpb25baV0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHBhZ2luYXRpb25IYW5kbGVyKTtcclxuICAgICAgICAgICAgICAgIHBhZ2luYXRpb25baV0uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHBhZ2luYXRpb25IYW5kbGVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNoYW5nZUNvdmVyUmVxdWVzdChuYW1lc3BhY2UsIGlkLCB1cmwpIHtcclxuXHRpZiAoIHR5cGVvZiBpZCA9PT0gXCJ1bmRlZmluZWRcIiAmJiBuYW1lc3BhY2UgPT0gXCJBcHBcXFxcVXNlclwiICkge1xyXG5cdFx0bGV0IGltZyA9ICQoXCIjY292ZXItaW1hZ2VcIilbMF07XHJcblx0XHRsZXQgcmVtb3ZlQnRuQ250ID0gJChcIiNyZW1vdmUtY292ZXItYnRuXCIpLnBhcmVudCgpO1xyXG5cclxuXHRcdGltZy5zcmMgPSBgJHt1cmx9YDtcclxuXHRcdGltZy5jbGFzc0xpc3QucmVtb3ZlKFwiZC1ub25lXCIpO1xyXG5cclxuXHRcdHJlbW92ZUJ0bkNudC5yZW1vdmVDbGFzcyhcImQtbm9uZVwiKTtcclxuXHRcdHJlbW92ZUJ0bkNudC5hZGRDbGFzcyhcImQtZmxleFwiKTtcclxuXHJcbiAgICAgICAgJChcIiNjdXN0b20tZmlsZVwiKVswXS52YWx1ZSA9IGAke3VybH1gO1xyXG5cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgYXhpb3MucGF0Y2goXCIvbWVkaWEvY292ZXIvcmVwbGFjZVwiLCB7XHJcbiAgICAgICAgICAgIG5hbWVzcGFjZSwgaWQsIHVybFxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC50aGVuKHJlcyA9PiB7XHJcblxyXG5cdFx0XHRcdGxldCBpbWcgPSAkKFwiI2NvdmVyLWltYWdlXCIpWzBdO1xyXG5cdFx0XHRcdGxldCByZW1vdmVCdG5DbnQgPSAkKFwiI3JlbW92ZS1jb3Zlci1idG5cIikucGFyZW50KCk7XHJcblxyXG5cdFx0XHRcdGltZy5zcmMgPSByZXMuZGF0YS5pbWdVcmw7XHJcblx0XHRcdFx0aW1nLmNsYXNzTGlzdC5yZW1vdmUoXCJkLW5vbmVcIik7XHJcblxyXG5cdFx0XHRcdCQoXCIjY2hhbmdlLWNvdmVyLWJ0blwiKS50ZXh0KFwizpHOu867zrHOs86uXCIpO1xyXG5cdFx0XHRcdCQoXCIjY292ZXItc3RhdHVzXCIpLmFkZENsYXNzKFwiZC1ub25lXCIpO1xyXG5cclxuXHRcdFx0XHRyZW1vdmVCdG5DbnQucmVtb3ZlQ2xhc3MoXCJkLW5vbmVcIik7XHJcblx0XHRcdFx0cmVtb3ZlQnRuQ250LmFkZENsYXNzKFwiZC1mbGV4XCIpO1xyXG5cclxuICAgICAgICAgICAgICAgIHRvYXN0QWxlcnQoXCJzdWNjZXNzXCIsIFwizqTOvyBDb3ZlciDOrM67zrvOsc6+zrUhXCIpO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuY2F0Y2goZXJyID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGVycik7XHJcbiAgICAgICAgICAgICAgICB0b2FzdEFsZXJ0KCdlcnJvcicsIFwizqDOsc+Bzr/Phc+DzrnOrM+Dz4TOt866zrUgzrrOrM+Azr/Ouc6/IM+Az4HPjM6yzrvOt868zrEgLi4uXCIpO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBhZGRUb0dhbGxlcnkobmFtZXNwYWNlLCBpZCwgaW1hZ2VJZCkge1xyXG5cclxuXHRheGlvcy5wb3N0KCBcIi9tZWRpYS9nYWxsZXJ5XCIsIHtcclxuXHRcdG5hbWVzcGFjZSxcclxuXHRcdG1vZGVsSWQ6IGlkLFxyXG5cdFx0aWRzOiBbaW1hZ2VJZF1cclxuXHR9KVxyXG5cdC50aGVuKCByZXMgPT4ge1xyXG5cclxuXHRcdGxldCBnYWxsZXJ5ID0gJChcIiNnYWxsZXJ5LWNudFwiKTtcclxuXHRcdGdhbGxlcnkuaHRtbChyZXMuZGF0YSk7XHJcblxyXG5cdFx0bGV0IGNsb3NlQnRucyA9IGdhbGxlcnkuZmluZChcIi5qcy1yZW1vdmUtaW1hZ2VcIik7XHJcblx0XHRjbG9zZUJ0bnMub24oXCJjbGlja1wiLCByZW1vdmVJbWFnZUhhbmRsZXIpO1xyXG5cclxuXHRcdHRvYXN0QWxlcnQoXCJzdWNjZXNzXCIsIFwizpcgzrXOuc66z4zOvc6xIM+Az4HOv8+Dz4TOrc64zrfOus61LlwiKTtcclxuXHRcdGdhbGxlcnkubW9kYWwoXCJoaWRlXCIpO1xyXG5cclxuXHRcdGxldCBidWxrID0gJChcIiNnYWxsZXJ5LWJ1bGstYWN0aW9uLWJ0blwiKTtcclxuXHRcdGxldCBjaGVja2JveGVzID0gJChcIi5qcy1nYWxsZXJ5LWNoZWNrYm94XCIpO1xyXG5cclxuXHRcdHJlc2V0R2FsbGVyeUJ0bnMoIGJ1bGssIGNoZWNrYm94ZXMgKTtcclxuXHR9KVxyXG5cdC5jYXRjaCggZXJyID0+IHtcclxuXHRcdGNvbnNvbGUubG9nKGVycik7XHJcblx0XHR0b2FzdEFsZXJ0KCdlcnJvcicsIFwizqDOsc+Bzr/Phc+DzrnOrM+Dz4TOt866zrUgzrrOrM+Azr/Ouc6/IM+Az4HPjM6yzrvOt868zrEgLi4uXCIpO1xyXG5cdH0pXHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiByZW1vdmVJbWFnZUhhbmRsZXIoKSB7XHJcblx0U3dhbC5maXJlKHtcclxuXHRcdGljb246ICdpbmZvJyxcclxuXHRcdHRpdGxlOiAnzqDPgc6/z4POv8+Hzq4hJyxcclxuXHRcdHRleHQ6ICfOlyDOtc65zrrPjM69zrEgzrjOsSDOsc+GzrHOuc+BzrXOuM61zq8gzrHPgM6/IM+Ezr8gR2FsbGVyeS4nLFxyXG5cdFx0c2hvd0NhbmNlbEJ1dHRvbjogdHJ1ZSxcclxuXHRcdGNvbmZpcm1CdXR0b25Db2xvcjogJyM1MzZkZTYnLFxyXG5cdFx0Y29uZmlybUJ1dHRvblRleHQ6IGDOnc6xzrksIM6xz4bOsc6vz4HOtc+DzrchYCxcclxuXHRcdGNhbmNlbEJ1dHRvblRleHQ6IFwizobOus+Fz4HOv1wiXHJcblx0fSlcclxuXHQudGhlbigocmVzdWx0KSA9PiB7XHJcblxyXG5cdFx0aWYgKCByZXN1bHQuaXNDb25maXJtZWQgKSB7XHJcblx0XHRcdHJlbW92ZUltYWdlcyggW3RoaXMuZGF0YXNldC5pbWFnZUlkXSApO1xyXG5cdFx0fVxyXG5cclxuXHR9KVxyXG59XHJcblxyXG5mdW5jdGlvbiByZW1vdmVJbWFnZXMoIGlkcyApIHtcclxuXHJcblx0bGV0IGdhbGxlcnkgPSAkKFwiI2dhbGxlcnktY250XCIpWzBdO1xyXG5cdGxldCBuYW1lc3BhY2UgPSBnYWxsZXJ5LmRhdGFzZXQubmFtZXNwYWNlO1xyXG5cdGxldCBtb2RlbElkID0gZ2FsbGVyeS5kYXRhc2V0Lm1vZGVsSWQ7XHJcblxyXG5cdGF4aW9zLnBvc3QoXCIvbWVkaWEvZ2FsbGVyeS1yZW1vdmVcIiwge1xyXG5cdFx0bmFtZXNwYWNlLCBtb2RlbElkLCBpZHNcclxuXHR9KVxyXG5cdC50aGVuKCByZXMgPT4ge1xyXG5cclxuXHRcdGxldCBnYWxsZXJ5ID0gJChcIiNnYWxsZXJ5LWNudFwiKTtcclxuXHRcdGdhbGxlcnkuaHRtbChyZXMuZGF0YSk7XHJcblxyXG5cdFx0bGV0IGNsb3NlQnRucyA9IGdhbGxlcnkuZmluZChcIi5qcy1yZW1vdmUtaW1hZ2VcIik7XHJcblx0XHRjbG9zZUJ0bnMub24oXCJjbGlja1wiLCByZW1vdmVJbWFnZUhhbmRsZXIpO1xyXG5cclxuXHRcdGlmICggY2xvc2VCdG5zLmxlbmd0aCA9PSAwICkge1xyXG5cdFx0XHQkKFwiI3JlbW92ZS1hbGwtaW1hZ2VzLWJ0blwiKS5hZGRDbGFzcyhcImQtbm9uZVwiKTtcclxuXHRcdH1cclxuXHJcblx0fSlcclxuXHQuY2F0Y2goIGVyciA9PiB7XHJcblx0XHRjb25zb2xlLmxvZyhlcnIpO1xyXG5cdFx0dXRpbGl0aWVzLnRvYXN0QWxlcnQoICdlcnJvcicsIFwizqDOsc+Bzr/Phc+DzrnOrM+Dz4TOt866zrUgzrrOrM+Azr/Ouc6/IM+Az4HPjM6yzrvOt868zrEgLi4uXCIgKTtcclxuXHR9KVxyXG5cclxufVxyXG5cclxuXHJcblxyXG5mdW5jdGlvbiByZXNldEdhbGxlcnlCdG5zKCBidWxrLCBjaGVja2JveGVzICkge1xyXG5cclxuXHRidWxrLnRleHQoXCLOlc+AzrnOu86/zrPOrc+CICgwKVwiKVxyXG5cdGJ1bGsucHJvcChcImRpc2FibGVkXCIsIHRydWUpO1xyXG5cdGJ1bGsucmVtb3ZlQ2xhc3MoXCJidG4td2FybmluZ1wiKTtcclxuXHRidWxrLmFkZENsYXNzKFwiYnRuLXNlY29uZGFyeVwiKTtcclxuXHJcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBjaGVja2JveGVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRjaGVja2JveGVzW2ldLmNoZWNrZWQgPSBmYWxzZTtcclxuXHR9XHJcblxyXG59XHJcblxyXG4vLyEjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcclxuLy8hXHRcdFx0XHRNZWRpYSBMaWJyYXJ5IEZ1bmN0aW9ucyBFbmRcdFx0XHRcdCNcclxuLy8hIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgICB0b2FzdEFsZXJ0LFxyXG4gICAgbWFpbkNoZWNrYm94U3dpdGNoZXIsXHJcbiAgICBtaW5vckNoZWNrYm94U3dpdGNoZXIsXHJcbiAgICBmaWx0ZXJCdXR0b24sXHJcbiAgICB0YWJsZUxvY2FsZSxcclxuICAgIGNoYW5nZUlucHV0SGlkZGVuLFxyXG4gICAgcmVkYWN0b3JDb25maWcsXHJcbiAgICBjcmVhdGVTdGF0ZVNlbGVjdCxcclxuICAgIGRhdGVQaWNrZXJDb25maWcsXHJcbiAgICB0b2FzdEFsZXJ0RGVsZXRlLFxyXG4gICAgZmlsdGVyU3R5bGUsXHJcbiAgICBjcmVhdGVEYXRlRWxtLFxyXG4gICAgc3RhcnREYXRlLFxyXG4gICAgZW5kRGF0ZSxcclxuICAgIHJlc2V0QnVsayxcclxuICAgIHJlc2V0QWRkQnV0dG9uLFxyXG4gICAgY3JlYXRlQ291cnNlVHlwZVNlbGVjdCxcclxuICAgIHBhZ2luYXRpb25IYW5kbGVyLFxyXG4gICAgc2VhcmNoSGFuZGxlcixcclxuICAgIGltYWdlSGFuZGxlcixcclxuXHRwYWdpbmF0aW9uUmVxdWVzdCxcclxuXHRyZXNldEdhbGxlcnlCdG5zLFxyXG5cdHJlbW92ZUltYWdlSGFuZGxlcixcclxuXHRyZW1vdmVJbWFnZXMsXHJcblx0YXJ0aWNsZUNvbmZpZyxcclxuXHRBTExPV0VEVFlQRVNcclxufVxyXG5cclxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./resources/js/dashboard/main.js\n");

/***/ }),

/***/ "./resources/js/dashboard/settings/general-settings.js":
/*!*************************************************************!*\
  !*** ./resources/js/dashboard/settings/general-settings.js ***!
  \*************************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _main__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../main */ \"./resources/js/dashboard/main.js\");\n/* harmony import */ var filepond__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! filepond */ \"./node_modules/filepond/dist/filepond.js\");\n/* harmony import */ var filepond__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(filepond__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var filepond_plugin_file_validate_type__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! filepond-plugin-file-validate-type */ \"./node_modules/filepond-plugin-file-validate-type/dist/filepond-plugin-file-validate-type.js\");\n/* harmony import */ var filepond_plugin_file_validate_type__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(filepond_plugin_file_validate_type__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var filepond_plugin_file_validate_size__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! filepond-plugin-file-validate-size */ \"./node_modules/filepond-plugin-file-validate-size/dist/filepond-plugin-file-validate-size.js\");\n/* harmony import */ var filepond_plugin_file_validate_size__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(filepond_plugin_file_validate_size__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var filepond_dist_filepond_min_css__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! filepond/dist/filepond.min.css */ \"./node_modules/filepond/dist/filepond.min.css\");\n/* harmony import */ var filepond_dist_filepond_min_css__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(filepond_dist_filepond_min_css__WEBPACK_IMPORTED_MODULE_4__);\n//! GLOBAL VARIABLES\n//!============================================================\nvar baseUrl = window.location.origin;\nvar timer = 0; //!######################################\n//! \t\t\t\tImports\t\t\t\t#\n//!######################################\n\n\n\n\n\n\n$(\"#image-search\").on(\"input\", _main__WEBPACK_IMPORTED_MODULE_0__[\"default\"].searchHandler);\n$(\".js-gallery-page-btn\").on('click', _main__WEBPACK_IMPORTED_MODULE_0__[\"default\"].paginationHandler);\n$(\".js-add-image\").on(\"click\", _main__WEBPACK_IMPORTED_MODULE_0__[\"default\"].imageHandler);\nfilepond__WEBPACK_IMPORTED_MODULE_1__[\"registerPlugin\"](filepond_plugin_file_validate_type__WEBPACK_IMPORTED_MODULE_2___default.a);\nfilepond__WEBPACK_IMPORTED_MODULE_1__[\"registerPlugin\"](filepond_plugin_file_validate_size__WEBPACK_IMPORTED_MODULE_3___default.a);\nvar dropzone = document.getElementById(\"file-pond\");\nvar pond = filepond__WEBPACK_IMPORTED_MODULE_1__[\"create\"](dropzone, {\n  name: 'file[]',\n  allowMultiple: true,\n  className: \"js-filepond-file-dragging\",\n  labelIdle: \"Drag & Drop your files or Browse\",\n  allowRevert: false,\n  server: {\n    url: baseUrl,\n    process: {\n      url: '/media/upload-images',\n      headers: {\n        \"X-CSRF-TOKEN\": $('meta[name=\"csrf-token\"]').attr('content')\n      },\n      onload: function onload(data) {\n        _main__WEBPACK_IMPORTED_MODULE_0__[\"default\"].paginationRequest(1, \"\");\n      }\n    }\n  },\n  onprocessfile: function onprocessfile(error, data) {\n    if (pond.status === 2) {\n      (function () {\n        clearTimeout(timer);\n        var files = pond.getFiles();\n\n        var _loop = function _loop(i) {\n          if (files[i].status === 5) {\n            timer = setTimeout(function () {\n              pond.removeFile(files[i]);\n            }, (i + 1) * 500);\n          }\n        };\n\n        for (var i = 0; i < files.length; i++) {\n          _loop(i);\n        }\n      })();\n    }\n  },\n  onprocessfiles: function onprocessfiles() {\n    var files = pond.getFiles();\n\n    var _loop2 = function _loop2(i) {\n      timer = setTimeout(function () {\n        pond.removeFile(files[i]);\n      }, (i + 1) * 500);\n    };\n\n    for (var i = 0; i < files.length; i++) {\n      _loop2(i);\n    }\n  },\n  acceptedFileTypes: ['image/png', 'image/jpeg']\n});\nvar dropArea = document.getElementsByClassName(\"js-filepond-file-dragging\");\n\nfor (var i = 0; i < dropArea.length; i++) {\n  dropArea[i].addEventListener(\"dragover\", function (event) {\n    var draggingArea = this.getElementsByClassName(\"filepond--drop-label\")[0];\n    var label = draggingArea.querySelector(\"label\");\n    draggingArea.classList.add(\"limegreen\");\n    label.classList.add(\"text-limegreen\");\n  });\n  dropArea[i].addEventListener(\"dragleave\", function (event) {\n    var draggingArea = this.getElementsByClassName(\"filepond--drop-label\")[0];\n    var label = draggingArea.querySelector(\"label\");\n    draggingArea.classList.remove(\"limegreen\");\n    label.classList.remove(\"text-limegreen\");\n  });\n  dropArea[i].addEventListener(\"drop\", function (event) {\n    var draggingArea = this.getElementsByClassName(\"filepond--drop-label\")[0];\n    var label = draggingArea.querySelector(\"label\");\n    draggingArea.classList.remove(\"limegreen\");\n    label.classList.remove(\"text-limegreen\");\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvZGFzaGJvYXJkL3NldHRpbmdzL2dlbmVyYWwtc2V0dGluZ3MuanM/MzEwZCJdLCJuYW1lcyI6WyJiYXNlVXJsIiwid2luZG93IiwibG9jYXRpb24iLCJvcmlnaW4iLCJ0aW1lciIsIiQiLCJvbiIsInV0aWxpdGllcyIsInNlYXJjaEhhbmRsZXIiLCJwYWdpbmF0aW9uSGFuZGxlciIsImltYWdlSGFuZGxlciIsIkZpbGVQb25kIiwiRmlsZVBvbmRQbHVnaW5GaWxlVmFsaWRhdGVUeXBlIiwiRmlsZVBvbmRQbHVnaW5GaWxlVmFsaWRhdGVTaXplIiwiZHJvcHpvbmUiLCJkb2N1bWVudCIsImdldEVsZW1lbnRCeUlkIiwicG9uZCIsIm5hbWUiLCJhbGxvd011bHRpcGxlIiwiY2xhc3NOYW1lIiwibGFiZWxJZGxlIiwiYWxsb3dSZXZlcnQiLCJzZXJ2ZXIiLCJ1cmwiLCJwcm9jZXNzIiwiaGVhZGVycyIsImF0dHIiLCJvbmxvYWQiLCJkYXRhIiwicGFnaW5hdGlvblJlcXVlc3QiLCJvbnByb2Nlc3NmaWxlIiwiZXJyb3IiLCJzdGF0dXMiLCJjbGVhclRpbWVvdXQiLCJmaWxlcyIsImdldEZpbGVzIiwiaSIsInNldFRpbWVvdXQiLCJyZW1vdmVGaWxlIiwibGVuZ3RoIiwib25wcm9jZXNzZmlsZXMiLCJhY2NlcHRlZEZpbGVUeXBlcyIsImRyb3BBcmVhIiwiZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJldmVudCIsImRyYWdnaW5nQXJlYSIsImxhYmVsIiwicXVlcnlTZWxlY3RvciIsImNsYXNzTGlzdCIsImFkZCIsInJlbW92ZSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0EsSUFBTUEsT0FBTyxHQUFHQyxNQUFNLENBQUNDLFFBQVAsQ0FBZ0JDLE1BQWhDO0FBRUEsSUFBSUMsS0FBSyxH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LFFBQU1JLEtBQUssR0FBR0QsWUFBWSxDQUFDRSxhQUFiLENBQTJCLE9BQTNCLENBQWQ7QUFFQ0YsZ0JBQVksQ0FBQ0csU0FBYixDQUF1QkUsTUFBdkIsQ0FBOEIsV0FBOUI7QUFDQUosU0FBSyxDQUFDRSxTQUFOLENBQWdCRSxNQUFoQixDQUF1QixnQkFBdkI7QUFFRCxHQVBEO0FBUUEiLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvZGFzaGJvYXJkL3NldHRpbmdzL2dlbmVyYWwtc2V0dGluZ3MuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyEgR0xPQkFMIFZBUklBQkxFU1xyXG4vLyE9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuY29uc3QgYmFzZVVybCA9IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW47XHJcblxyXG5sZXQgdGltZXIgPSAwO1xyXG5cclxuLy8hIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcclxuLy8hIFx0XHRcdFx0SW1wb3J0c1x0XHRcdFx0I1xyXG4vLyEjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xyXG5pbXBvcnQgdXRpbGl0aWVzIGZyb20gJy4uL21haW4nO1xyXG5cclxuaW1wb3J0ICogYXMgRmlsZVBvbmQgZnJvbSAnZmlsZXBvbmQnO1xyXG5pbXBvcnQgRmlsZVBvbmRQbHVnaW5GaWxlVmFsaWRhdGVUeXBlIGZyb20gJ2ZpbGVwb25kLXBsdWdpbi1maWxlLXZhbGlkYXRlLXR5cGUnO1xyXG5pbXBvcnQgRmlsZVBvbmRQbHVnaW5GaWxlVmFsaWRhdGVTaXplIGZyb20gJ2ZpbGVwb25kLXBsdWdpbi1maWxlLXZhbGlkYXRlLXNpemUnO1xyXG5pbXBvcnQgJ2ZpbGVwb25kL2Rpc3QvZmlsZXBvbmQubWluLmNzcyc7XHJcblxyXG5cclxuJChcIiNpbWFnZS1zZWFyY2hcIikub24oXCJpbnB1dFwiLCB1dGlsaXRpZXMuc2VhcmNoSGFuZGxlcik7XHJcblxyXG4kKFwiLmpzLWdhbGxlcnktcGFnZS1idG5cIikub24oICdjbGljaycsIHV0aWxpdGllcy5wYWdpbmF0aW9uSGFuZGxlcik7XHJcblxyXG4kKFwiLmpzLWFkZC1pbWFnZVwiKS5vbiggXCJjbGlja1wiLCB1dGlsaXRpZXMuaW1hZ2VIYW5kbGVyKTtcclxuXHJcbkZpbGVQb25kLnJlZ2lzdGVyUGx1Z2luKEZpbGVQb25kUGx1Z2luRmlsZVZhbGlkYXRlVHlwZSk7XHJcbkZpbGVQb25kLnJlZ2lzdGVyUGx1Z2luKEZpbGVQb25kUGx1Z2luRmlsZVZhbGlkYXRlU2l6ZSk7XHJcblxyXG5sZXQgZHJvcHpvbmUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImZpbGUtcG9uZFwiKTtcclxuY29uc3QgcG9uZCA9IEZpbGVQb25kLmNyZWF0ZSggZHJvcHpvbmUsIHtcclxuXHRuYW1lOiAnZmlsZVtdJyxcclxuXHRhbGxvd011bHRpcGxlOiB0cnVlLFxyXG5cdGNsYXNzTmFtZTogXCJqcy1maWxlcG9uZC1maWxlLWRyYWdnaW5nXCIsXHJcblx0bGFiZWxJZGxlOiBcIkRyYWcgJiBEcm9wIHlvdXIgZmlsZXMgb3IgQnJvd3NlXCIsXHJcblx0YWxsb3dSZXZlcnQ6IGZhbHNlLFxyXG5cdHNlcnZlcjoge1xyXG5cdFx0dXJsOiBiYXNlVXJsLFxyXG5cdFx0cHJvY2Vzczoge1xyXG5cdFx0XHR1cmw6ICcvbWVkaWEvdXBsb2FkLWltYWdlcycsXHJcblx0XHRcdGhlYWRlcnM6IHtcclxuXHRcdFx0XHRcIlgtQ1NSRi1UT0tFTlwiOiAkKCdtZXRhW25hbWU9XCJjc3JmLXRva2VuXCJdJykuYXR0cignY29udGVudCcpLFxyXG5cdFx0XHR9LFxyXG5cdFx0XHRvbmxvYWQ6IGZ1bmN0aW9uKGRhdGEpIHtcclxuXHRcdFx0XHR1dGlsaXRpZXMucGFnaW5hdGlvblJlcXVlc3QoIDEsIFwiXCIgKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHR9LFxyXG5cdG9ucHJvY2Vzc2ZpbGU6IGZ1bmN0aW9uIChlcnJvciwgZGF0YSkge1xyXG5cdFx0XHJcblx0XHRpZiAoIHBvbmQuc3RhdHVzID09PSAyICkge1xyXG5cclxuXHRcdFx0Y2xlYXJUaW1lb3V0KHRpbWVyKTtcclxuXHRcdFx0bGV0IGZpbGVzID0gcG9uZC5nZXRGaWxlcygpO1xyXG5cclxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBmaWxlcy5sZW5ndGg7IGkrKyApIHtcclxuXHJcblx0XHRcdFx0aWYgKCBmaWxlc1tpXS5zdGF0dXMgPT09IDUgKSB7XHJcblx0XHRcdFx0XHR0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHRcdHBvbmQucmVtb3ZlRmlsZShmaWxlc1tpXSk7XHJcblx0XHRcdFx0XHR9LCAoIGkgKyAxICkgKiA1MDApO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHRvbnByb2Nlc3NmaWxlczogZnVuY3Rpb24oKSB7XHJcblxyXG5cdFx0bGV0IGZpbGVzID0gcG9uZC5nZXRGaWxlcygpO1xyXG5cclxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgZmlsZXMubGVuZ3RoOyBpKysgKSB7XHJcblxyXG5cdFx0XHR0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cG9uZC5yZW1vdmVGaWxlKGZpbGVzW2ldKTtcclxuXHRcdFx0XHRcclxuXHRcdFx0fSwgKCBpICsgMSApICogNTAwKTtcclxuXHRcdFx0XHJcblx0XHR9XHJcblxyXG5cdH0sXHJcblx0YWNjZXB0ZWRGaWxlVHlwZXM6IFsnaW1hZ2UvcG5nJywgJ2ltYWdlL2pwZWcnXSxcclxufSApO1xyXG5cclxuY29uc3QgZHJvcEFyZWEgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwianMtZmlsZXBvbmQtZmlsZS1kcmFnZ2luZ1wiKTtcclxuZm9yICggbGV0IGkgPSAwOyBpIDwgZHJvcEFyZWEubGVuZ3RoOyBpKysgKSB7XHJcblxyXG5cdGRyb3BBcmVhW2ldLmFkZEV2ZW50TGlzdGVuZXIoXCJkcmFnb3ZlclwiLCBmdW5jdGlvbihldmVudCkge1xyXG5cdFx0Y29uc3QgZHJhZ2dpbmdBcmVhID0gdGhpcy5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwiZmlsZXBvbmQtLWRyb3AtbGFiZWxcIilbMF07XHJcblx0XHRjb25zdCBsYWJlbCA9IGRyYWdnaW5nQXJlYS5xdWVyeVNlbGVjdG9yKFwibGFiZWxcIik7XHJcblxyXG5cdFx0XHRkcmFnZ2luZ0FyZWEuY2xhc3NMaXN0LmFkZChcImxpbWVncmVlblwiKTtcclxuXHRcdFx0bGFiZWwuY2xhc3NMaXN0LmFkZChcInRleHQtbGltZWdyZWVuXCIpO1xyXG5cclxuXHR9KTtcclxuXHJcblx0ZHJvcEFyZWFbaV0uYWRkRXZlbnRMaXN0ZW5lcihcImRyYWdsZWF2ZVwiLCBmdW5jdGlvbihldmVudCkge1xyXG5cdFx0Y29uc3QgZHJhZ2dpbmdBcmVhID0gdGhpcy5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwiZmlsZXBvbmQtLWRyb3AtbGFiZWxcIilbMF07XHJcblx0XHRjb25zdCBsYWJlbCA9IGRyYWdnaW5nQXJlYS5xdWVyeVNlbGVjdG9yKFwibGFiZWxcIik7XHJcblxyXG5cdFx0XHRkcmFnZ2luZ0FyZWEuY2xhc3NMaXN0LnJlbW92ZShcImxpbWVncmVlblwiKTtcclxuXHRcdFx0bGFiZWwuY2xhc3NMaXN0LnJlbW92ZShcInRleHQtbGltZWdyZWVuXCIpO1xyXG5cclxuXHR9KTtcclxuXHJcblx0ZHJvcEFyZWFbaV0uYWRkRXZlbnRMaXN0ZW5lcihcImRyb3BcIiwgZnVuY3Rpb24oZXZlbnQpIHtcclxuXHRcdGNvbnN0IGRyYWdnaW5nQXJlYSA9IHRoaXMuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcImZpbGVwb25kLS1kcm9wLWxhYmVsXCIpWzBdO1xyXG5cdFx0Y29uc3QgbGFiZWwgPSBkcmFnZ2luZ0FyZWEucXVlcnlTZWxlY3RvcihcImxhYmVsXCIpO1xyXG5cclxuXHRcdFx0ZHJhZ2dpbmdBcmVhLmNsYXNzTGlzdC5yZW1vdmUoXCJsaW1lZ3JlZW5cIik7XHJcblx0XHRcdGxhYmVsLmNsYXNzTGlzdC5yZW1vdmUoXCJ0ZXh0LWxpbWVncmVlblwiKTtcclxuXHJcblx0fSk7XHJcbn0iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/js/dashboard/settings/general-settings.js\n");

/***/ }),

/***/ 19:
/*!*******************************************************************!*\
  !*** multi ./resources/js/dashboard/settings/general-settings.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! D:\Coding\Darkpony\Idrogeios\Demo LMS\resources\js\dashboard\settings\general-settings.js */"./resources/js/dashboard/settings/general-settings.js");


/***/ })

/******/ });