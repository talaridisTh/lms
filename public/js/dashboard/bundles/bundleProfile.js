/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 7);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/css-loader/index.js?!./node_modules/postcss-loader/src/index.js?!./node_modules/filepond/dist/filepond.min.css":
/*!*************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader??ref--9-1!./node_modules/postcss-loader/src??ref--9-2!./node_modules/filepond/dist/filepond.min.css ***!
  \*************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, "/*!\n * FilePond 4.25.1\n * Licensed under MIT, https://opensource.org/licenses/MIT/\n * Please visit https://pqina.nl/filepond/ for details.\n */\n\n/* eslint-disable */\n\n.filepond--assistant{\n  position:absolute;\n  overflow:hidden;\n  height:1px;\n  width:1px;\n  padding:0;\n  border:0;\n  clip:rect(1px,1px,1px,1px);\n  -webkit-clip-path:inset(50%);\n  clip-path:inset(50%);\n  white-space:nowrap\n}\n\n.filepond--browser.filepond--browser{\n  position:absolute;\n  margin:0;\n  padding:0;\n  left:1em;\n  top:1.75em;\n  width:calc(100% - 2em);\n  opacity:0;\n  font-size:0\n}\n\n.filepond--data{\n  position:absolute;\n  width:0;\n  height:0;\n  padding:0;\n  margin:0;\n  border:none;\n  visibility:hidden;\n  pointer-events:none;\n  contain:strict\n}\n\n.filepond--drip{\n  position:absolute;\n  top:0;\n  left:0;\n  right:0;\n  bottom:0;\n  overflow:hidden;\n  opacity:.1;\n  pointer-events:none;\n  border-radius:.5em;\n  background:rgba(0,0,0,.01)\n}\n\n.filepond--drip-blob{\n  -webkit-transform-origin:center center;\n  transform-origin:center center;\n  width:8em;\n  height:8em;\n  margin-left:-4em;\n  margin-top:-4em;\n  background:#292625;\n  border-radius:50%\n}\n\n.filepond--drip-blob,.filepond--drop-label{\n  position:absolute;\n  top:0;\n  left:0;\n  will-change:transform,opacity\n}\n\n.filepond--drop-label{\n  right:0;\n  margin:0;\n  color:#4f4f4f;\n  display:flex;\n  justify-content:center;\n  align-items:center;\n  height:0;\n  -webkit-user-select:none;\n  -moz-user-select:none;\n  -ms-user-select:none;\n  user-select:none\n}\n\n.filepond--drop-label.filepond--drop-label label{\n  display:block;\n  margin:0;\n  padding:.5em\n}\n\n.filepond--drop-label label{\n  cursor:default;\n  font-size:.875em;\n  font-weight:400;\n  text-align:center;\n  line-height:1.5\n}\n\n.filepond--label-action{\n  text-decoration:underline;\n  -webkit-text-decoration-skip:ink;\n  text-decoration-skip-ink:auto;\n  -webkit-text-decoration-color:#a7a4a4;\n  text-decoration-color:#a7a4a4;\n  cursor:pointer\n}\n\n.filepond--root[data-disabled] .filepond--drop-label label{\n  opacity:.5\n}\n\n.filepond--file-action-button.filepond--file-action-button{\n  font-size:1em;\n  width:1.625em;\n  height:1.625em;\n  font-family:inherit;\n  line-height:inherit;\n  margin:0;\n  padding:0;\n  border:none;\n  outline:none;\n  will-change:transform,opacity\n}\n\n.filepond--file-action-button.filepond--file-action-button span{\n  position:absolute;\n  overflow:hidden;\n  height:1px;\n  width:1px;\n  padding:0;\n  border:0;\n  clip:rect(1px,1px,1px,1px);\n  -webkit-clip-path:inset(50%);\n  clip-path:inset(50%);\n  white-space:nowrap\n}\n\n.filepond--file-action-button.filepond--file-action-button svg{\n  width:100%;\n  height:100%\n}\n\n.filepond--file-action-button.filepond--file-action-button:after{\n  position:absolute;\n  left:-.75em;\n  right:-.75em;\n  top:-.75em;\n  bottom:-.75em;\n  content:\"\"\n}\n\n.filepond--file-action-button{\n  cursor:auto;\n  color:#fff;\n  border-radius:50%;\n  background-color:rgba(0,0,0,.5);\n  background-image:none;\n  box-shadow:0 0 0 0 hsla(0,0%,100%,0);\n  transition:box-shadow .25s ease-in\n}\n\n.filepond--file-action-button:focus,.filepond--file-action-button:hover{\n  box-shadow:0 0 0 .125em hsla(0,0%,100%,.9)\n}\n\n.filepond--file-action-button[disabled]{\n  color:hsla(0,0%,100%,.5);\n  background-color:rgba(0,0,0,.25)\n}\n\n.filepond--file-action-button[hidden]{\n  display:none\n}\n\n.filepond--action-edit-item.filepond--action-edit-item{\n  width:2em;\n  height:2em;\n  padding:.1875em\n}\n\n.filepond--action-edit-item.filepond--action-edit-item[data-align*=center]{\n  margin-left:-.1875em\n}\n\n.filepond--action-edit-item.filepond--action-edit-item[data-align*=bottom]{\n  margin-bottom:-.1875em\n}\n\n.filepond--action-edit-item-alt{\n  border:none;\n  line-height:inherit;\n  background:transparent;\n  font-family:inherit;\n  color:inherit;\n  outline:none;\n  padding:0;\n  margin:0 0 0 .25em;\n  pointer-events:all;\n  position:absolute\n}\n\n.filepond--action-edit-item-alt svg{\n  width:1.3125em;\n  height:1.3125em\n}\n\n.filepond--action-edit-item-alt span{\n  font-size:0;\n  opacity:0\n}\n\n.filepond--file-info{\n  position:static;\n  display:flex;\n  flex-direction:column;\n  align-items:flex-start;\n  flex:1;\n  margin:0 .5em 0 0;\n  min-width:0;\n  will-change:transform,opacity;\n  pointer-events:none;\n  -webkit-user-select:none;\n  -moz-user-select:none;\n  -ms-user-select:none;\n  user-select:none\n}\n\n.filepond--file-info *{\n  margin:0\n}\n\n.filepond--file-info .filepond--file-info-main{\n  font-size:.75em;\n  line-height:1.2;\n  text-overflow:ellipsis;\n  overflow:hidden;\n  white-space:nowrap;\n  width:100%\n}\n\n.filepond--file-info .filepond--file-info-sub{\n  font-size:.625em;\n  opacity:.5;\n  transition:opacity .25s ease-in-out;\n  white-space:nowrap\n}\n\n.filepond--file-info .filepond--file-info-sub:empty{\n  display:none\n}\n\n.filepond--file-status{\n  position:static;\n  display:flex;\n  flex-direction:column;\n  align-items:flex-end;\n  flex-grow:0;\n  flex-shrink:0;\n  margin:0;\n  min-width:2.25em;\n  text-align:right;\n  will-change:transform,opacity;\n  pointer-events:none;\n  -webkit-user-select:none;\n  -moz-user-select:none;\n  -ms-user-select:none;\n  user-select:none\n}\n\n.filepond--file-status *{\n  margin:0;\n  white-space:nowrap\n}\n\n.filepond--file-status .filepond--file-status-main{\n  font-size:.75em;\n  line-height:1.2\n}\n\n.filepond--file-status .filepond--file-status-sub{\n  font-size:.625em;\n  opacity:.5;\n  transition:opacity .25s ease-in-out\n}\n\n.filepond--file-wrapper.filepond--file-wrapper{\n  border:none;\n  margin:0;\n  padding:0;\n  min-width:0;\n  height:100%\n}\n\n.filepond--file-wrapper.filepond--file-wrapper>legend{\n  position:absolute;\n  overflow:hidden;\n  height:1px;\n  width:1px;\n  padding:0;\n  border:0;\n  clip:rect(1px,1px,1px,1px);\n  -webkit-clip-path:inset(50%);\n  clip-path:inset(50%);\n  white-space:nowrap\n}\n\n.filepond--file{\n  position:static;\n  display:flex;\n  height:100%;\n  align-items:flex-start;\n  padding:.5625em;\n  color:#fff;\n  border-radius:.5em\n}\n\n.filepond--file .filepond--file-status{\n  margin-left:auto;\n  margin-right:2.25em\n}\n\n.filepond--file .filepond--processing-complete-indicator{\n  pointer-events:none;\n  -webkit-user-select:none;\n  -moz-user-select:none;\n  -ms-user-select:none;\n  user-select:none;\n  z-index:3\n}\n\n.filepond--file .filepond--file-action-button,.filepond--file .filepond--processing-complete-indicator,.filepond--file .filepond--progress-indicator{\n  position:absolute\n}\n\n.filepond--file [data-align*=left]{\n  left:.5625em\n}\n\n.filepond--file [data-align*=right]{\n  right:.5625em\n}\n\n.filepond--file [data-align*=center]{\n  left:calc(50% - .8125em)\n}\n\n.filepond--file [data-align*=bottom]{\n  bottom:1.125em\n}\n\n.filepond--file [data-align=center]{\n  top:calc(50% - .8125em)\n}\n\n.filepond--file .filepond--progress-indicator{\n  margin-top:.1875em\n}\n\n.filepond--file .filepond--progress-indicator[data-align*=right]{\n  margin-right:.1875em\n}\n\n.filepond--file .filepond--progress-indicator[data-align*=left]{\n  margin-left:.1875em\n}\n\n[data-filepond-item-state*=error] .filepond--file-info,[data-filepond-item-state*=invalid] .filepond--file-info,[data-filepond-item-state=cancelled] .filepond--file-info{\n  margin-right:2.25em\n}\n\n[data-filepond-item-state~=processing] .filepond--file-status-sub{\n  opacity:0\n}\n\n[data-filepond-item-state~=processing] .filepond--action-abort-item-processing~.filepond--file-status .filepond--file-status-sub{\n  opacity:.5\n}\n\n[data-filepond-item-state=processing-error] .filepond--file-status-sub{\n  opacity:0\n}\n\n[data-filepond-item-state=processing-error] .filepond--action-retry-item-processing~.filepond--file-status .filepond--file-status-sub{\n  opacity:.5\n}\n\n[data-filepond-item-state=processing-complete] .filepond--action-revert-item-processing svg{\n  -webkit-animation:fall .5s linear .125s both;\n  animation:fall .5s linear .125s both\n}\n\n[data-filepond-item-state=processing-complete] .filepond--file-status-sub{\n  opacity:.5\n}\n\n[data-filepond-item-state=processing-complete] .filepond--file-info-sub,[data-filepond-item-state=processing-complete] .filepond--processing-complete-indicator:not([style*=hidden])~.filepond--file-status .filepond--file-status-sub{\n  opacity:0\n}\n\n[data-filepond-item-state=processing-complete] .filepond--action-revert-item-processing~.filepond--file-info .filepond--file-info-sub{\n  opacity:.5\n}\n\n[data-filepond-item-state*=error] .filepond--file-wrapper,[data-filepond-item-state*=error] .filepond--panel,[data-filepond-item-state*=invalid] .filepond--file-wrapper,[data-filepond-item-state*=invalid] .filepond--panel{\n  -webkit-animation:shake .65s linear both;\n  animation:shake .65s linear both\n}\n\n[data-filepond-item-state*=busy] .filepond--progress-indicator svg{\n  -webkit-animation:spin 1s linear infinite;\n  animation:spin 1s linear infinite\n}\n\n@-webkit-keyframes spin{\n  0%{\n    -webkit-transform:rotate(0deg);\n    transform:rotate(0deg)\n  }\n\n  to{\n    -webkit-transform:rotate(1turn);\n    transform:rotate(1turn)\n  }\n}\n\n@keyframes spin{\n  0%{\n    -webkit-transform:rotate(0deg);\n    transform:rotate(0deg)\n  }\n\n  to{\n    -webkit-transform:rotate(1turn);\n    transform:rotate(1turn)\n  }\n}\n\n@-webkit-keyframes shake{\n  10%,90%{\n    -webkit-transform:translateX(-.0625em);\n    transform:translateX(-.0625em)\n  }\n\n  20%,80%{\n    -webkit-transform:translateX(.125em);\n    transform:translateX(.125em)\n  }\n\n  30%,50%,70%{\n    -webkit-transform:translateX(-.25em);\n    transform:translateX(-.25em)\n  }\n\n  40%,60%{\n    -webkit-transform:translateX(.25em);\n    transform:translateX(.25em)\n  }\n}\n\n@keyframes shake{\n  10%,90%{\n    -webkit-transform:translateX(-.0625em);\n    transform:translateX(-.0625em)\n  }\n\n  20%,80%{\n    -webkit-transform:translateX(.125em);\n    transform:translateX(.125em)\n  }\n\n  30%,50%,70%{\n    -webkit-transform:translateX(-.25em);\n    transform:translateX(-.25em)\n  }\n\n  40%,60%{\n    -webkit-transform:translateX(.25em);\n    transform:translateX(.25em)\n  }\n}\n\n@-webkit-keyframes fall{\n  0%{\n    opacity:0;\n    -webkit-transform:scale(.5);\n    transform:scale(.5);\n    -webkit-animation-timing-function:ease-out;\n    animation-timing-function:ease-out\n  }\n\n  70%{\n    opacity:1;\n    -webkit-transform:scale(1.1);\n    transform:scale(1.1);\n    -webkit-animation-timing-function:ease-in-out;\n    animation-timing-function:ease-in-out\n  }\n\n  to{\n    -webkit-transform:scale(1);\n    transform:scale(1);\n    -webkit-animation-timing-function:ease-out;\n    animation-timing-function:ease-out\n  }\n}\n\n@keyframes fall{\n  0%{\n    opacity:0;\n    -webkit-transform:scale(.5);\n    transform:scale(.5);\n    -webkit-animation-timing-function:ease-out;\n    animation-timing-function:ease-out\n  }\n\n  70%{\n    opacity:1;\n    -webkit-transform:scale(1.1);\n    transform:scale(1.1);\n    -webkit-animation-timing-function:ease-in-out;\n    animation-timing-function:ease-in-out\n  }\n\n  to{\n    -webkit-transform:scale(1);\n    transform:scale(1);\n    -webkit-animation-timing-function:ease-out;\n    animation-timing-function:ease-out\n  }\n}\n\n.filepond--hopper[data-hopper-state=drag-over]>*{\n  pointer-events:none\n}\n\n.filepond--hopper[data-hopper-state=drag-over]:after{\n  content:\"\";\n  position:absolute;\n  left:0;\n  top:0;\n  right:0;\n  bottom:0;\n  z-index:100\n}\n\n.filepond--progress-indicator{\n  z-index:103\n}\n\n.filepond--file-action-button{\n  z-index:102\n}\n\n.filepond--file-status{\n  z-index:101\n}\n\n.filepond--file-info{\n  z-index:100\n}\n\n.filepond--item{\n  position:absolute;\n  top:0;\n  left:0;\n  right:0;\n  z-index:1;\n  padding:0;\n  margin:.25em;\n  will-change:transform,opacity\n}\n\n.filepond--item>.filepond--panel{\n  z-index:-1\n}\n\n.filepond--item>.filepond--panel .filepond--panel-bottom{\n  box-shadow:0 .0625em .125em -.0625em rgba(0,0,0,.25)\n}\n\n.filepond--item>.filepond--file-wrapper,.filepond--item>.filepond--panel{\n  transition:opacity .15s ease-out\n}\n\n.filepond--item[data-drag-state]{\n  cursor:-webkit-grab;\n  cursor:grab\n}\n\n.filepond--item[data-drag-state]>.filepond--panel{\n  transition:box-shadow .125s ease-in-out;\n  box-shadow:0 0 0 transparent\n}\n\n.filepond--item[data-drag-state=drag]{\n  cursor:-webkit-grabbing;\n  cursor:grabbing\n}\n\n.filepond--item[data-drag-state=drag]>.filepond--panel{\n  box-shadow:0 .125em .3125em rgba(0,0,0,.325)\n}\n\n.filepond--item[data-drag-state]:not([data-drag-state=idle]){\n  z-index:2\n}\n\n.filepond--item-panel{\n  background-color:#64605e\n}\n\n[data-filepond-item-state=processing-complete] .filepond--item-panel{\n  background-color:#369763\n}\n\n[data-filepond-item-state*=error] .filepond--item-panel,[data-filepond-item-state*=invalid] .filepond--item-panel{\n  background-color:#c44e47\n}\n\n.filepond--item-panel{\n  border-radius:.5em;\n  transition:background-color .25s\n}\n\n.filepond--list-scroller{\n  position:absolute;\n  top:0;\n  left:0;\n  right:0;\n  margin:0;\n  will-change:transform\n}\n\n.filepond--list-scroller[data-state=overflow]{\n  overflow-y:scroll;\n  overflow-x:hidden;\n  -webkit-overflow-scrolling:touch;\n  -webkit-mask:linear-gradient(180deg,#000 calc(100% - .5em),transparent);\n  mask:linear-gradient(180deg,#000 calc(100% - .5em),transparent)\n}\n\n.filepond--list-scroller[data-state=overflow] .filepond--list{\n  bottom:0;\n  right:0\n}\n\n.filepond--list-scroller::-webkit-scrollbar{\n  background:transparent\n}\n\n.filepond--list-scroller::-webkit-scrollbar:vertical{\n  width:1em\n}\n\n.filepond--list-scroller::-webkit-scrollbar:horizontal{\n  height:0\n}\n\n.filepond--list-scroller::-webkit-scrollbar-thumb{\n  background-color:rgba(0,0,0,.3);\n  border-radius:99999px;\n  border:.3125em solid transparent;\n  background-clip:content-box\n}\n\n.filepond--list.filepond--list{\n  position:absolute;\n  top:0;\n  margin:0;\n  padding:0;\n  list-style-type:none;\n  will-change:transform\n}\n\n.filepond--list{\n  left:.75em;\n  right:.75em\n}\n\n.filepond--root[data-style-panel-layout~=integrated]{\n  width:100%;\n  height:100%;\n  max-width:none;\n  margin:0\n}\n\n.filepond--root[data-style-panel-layout~=circle] .filepond--panel-root,.filepond--root[data-style-panel-layout~=integrated] .filepond--panel-root{\n  border-radius:0\n}\n\n.filepond--root[data-style-panel-layout~=circle] .filepond--panel-root>*,.filepond--root[data-style-panel-layout~=integrated] .filepond--panel-root>*{\n  display:none\n}\n\n.filepond--root[data-style-panel-layout~=circle] .filepond--drop-label,.filepond--root[data-style-panel-layout~=integrated] .filepond--drop-label{\n  bottom:0;\n  height:auto;\n  display:flex;\n  justify-content:center;\n  align-items:center;\n  z-index:7\n}\n\n.filepond--root[data-style-panel-layout~=circle] .filepond--item-panel,.filepond--root[data-style-panel-layout~=integrated] .filepond--item-panel{\n  display:none\n}\n\n.filepond--root[data-style-panel-layout~=compact] .filepond--list-scroller,.filepond--root[data-style-panel-layout~=integrated] .filepond--list-scroller{\n  overflow:hidden;\n  height:100%;\n  margin-top:0;\n  margin-bottom:0\n}\n\n.filepond--root[data-style-panel-layout~=compact] .filepond--list,.filepond--root[data-style-panel-layout~=integrated] .filepond--list{\n  left:0;\n  right:0;\n  height:100%\n}\n\n.filepond--root[data-style-panel-layout~=compact] .filepond--item,.filepond--root[data-style-panel-layout~=integrated] .filepond--item{\n  margin:0\n}\n\n.filepond--root[data-style-panel-layout~=compact] .filepond--file-wrapper,.filepond--root[data-style-panel-layout~=integrated] .filepond--file-wrapper{\n  height:100%\n}\n\n.filepond--root[data-style-panel-layout~=compact] .filepond--drop-label,.filepond--root[data-style-panel-layout~=integrated] .filepond--drop-label{\n  z-index:7\n}\n\n.filepond--root[data-style-panel-layout~=circle]{\n  border-radius:99999rem;\n  overflow:hidden\n}\n\n.filepond--root[data-style-panel-layout~=circle]>.filepond--panel{\n  border-radius:inherit\n}\n\n.filepond--root[data-style-panel-layout~=circle] .filepond--file-info,.filepond--root[data-style-panel-layout~=circle] .filepond--file-status,.filepond--root[data-style-panel-layout~=circle]>.filepond--panel>*{\n  display:none\n}\n\n.filepond--root[data-style-panel-layout~=circle] .filepond--action-edit-item{\n  opacity:1!important;\n  visibility:visible!important\n}\n\n@media not all and (min-resolution:0.001dpcm){\n  @supports (-webkit-appearance:none) and (stroke-color:transparent){\n    .filepond--root[data-style-panel-layout~=circle]{\n      will-change:transform\n    }\n  }\n}\n\n.filepond--panel-root{\n  border-radius:.5em;\n  background-color:#f1f0ef\n}\n\n.filepond--panel{\n  position:absolute;\n  left:0;\n  top:0;\n  right:0;\n  margin:0;\n  height:100%!important;\n  pointer-events:none\n}\n\n.filepond-panel:not([data-scalable=false]){\n  height:auto!important\n}\n\n.filepond--panel[data-scalable=false]>div{\n  display:none\n}\n\n.filepond--panel[data-scalable=true]{\n  -webkit-transform-style:preserve-3d;\n  transform-style:preserve-3d;\n  background-color:transparent!important;\n  border:none!important\n}\n\n.filepond--panel-bottom,.filepond--panel-center,.filepond--panel-top{\n  position:absolute;\n  left:0;\n  top:0;\n  right:0;\n  margin:0;\n  padding:0\n}\n\n.filepond--panel-bottom,.filepond--panel-top{\n  height:.5em\n}\n\n.filepond--panel-top{\n  border-bottom-left-radius:0!important;\n  border-bottom-right-radius:0!important;\n  border-bottom:none!important\n}\n\n.filepond--panel-top:after{\n  content:\"\";\n  position:absolute;\n  height:2px;\n  left:0;\n  right:0;\n  bottom:-1px;\n  background-color:inherit\n}\n\n.filepond--panel-bottom,.filepond--panel-center{\n  will-change:transform;\n  -webkit-backface-visibility:hidden;\n  backface-visibility:hidden;\n  -webkit-transform-origin:left top;\n  transform-origin:left top;\n  -webkit-transform:translate3d(0,.5em,0);\n  transform:translate3d(0,.5em,0)\n}\n\n.filepond--panel-bottom{\n  border-top-left-radius:0!important;\n  border-top-right-radius:0!important;\n  border-top:none!important\n}\n\n.filepond--panel-bottom:before{\n  content:\"\";\n  position:absolute;\n  height:2px;\n  left:0;\n  right:0;\n  top:-1px;\n  background-color:inherit\n}\n\n.filepond--panel-center{\n  height:100px!important;\n  border-top:none!important;\n  border-bottom:none!important;\n  border-radius:0!important\n}\n\n.filepond--panel-center:not([style]){\n  visibility:hidden\n}\n\n.filepond--progress-indicator{\n  position:static;\n  width:1.25em;\n  height:1.25em;\n  color:#fff;\n  margin:0;\n  pointer-events:none;\n  will-change:transform,opacity\n}\n\n.filepond--progress-indicator svg{\n  width:100%;\n  height:100%;\n  vertical-align:top;\n  transform-box:fill-box\n}\n\n.filepond--progress-indicator path{\n  fill:none;\n  stroke:currentColor\n}\n\n.filepond--list-scroller{\n  z-index:6\n}\n\n.filepond--drop-label{\n  z-index:5\n}\n\n.filepond--drip{\n  z-index:3\n}\n\n.filepond--root>.filepond--panel{\n  z-index:2\n}\n\n.filepond--browser{\n  z-index:1\n}\n\n.filepond--root{\n  box-sizing:border-box;\n  position:relative;\n  margin-bottom:1em;\n  font-size:1rem;\n  line-height:normal;\n  font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol;\n  font-weight:450;\n  text-align:left;\n  text-rendering:optimizeLegibility;\n  direction:ltr;\n  contain:layout style size\n}\n\n.filepond--root *{\n  box-sizing:inherit;\n  line-height:inherit\n}\n\n.filepond--root :not(text){\n  font-size:inherit\n}\n\n.filepond--root[data-disabled]{\n  pointer-events:none\n}\n\n.filepond--root[data-disabled] .filepond--list-scroller{\n  pointer-events:all\n}\n\n.filepond--root[data-disabled] .filepond--list{\n  pointer-events:none\n}\n\n.filepond--root .filepond--drop-label{\n  min-height:4.75em\n}\n\n.filepond--root .filepond--list-scroller{\n  margin-top:1em;\n  margin-bottom:1em\n}\n\n.filepond--root .filepond--credits{\n  position:absolute;\n  right:0;\n  opacity:.175;\n  line-height:.85;\n  font-size:11px;\n  color:inherit;\n  text-decoration:none;\n  z-index:3;\n  bottom:-14px\n}\n\n.filepond--root .filepond--credits[style]{\n  top:0;\n  bottom:auto;\n  margin-top:14px\n}", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/lib/css-base.js":
/*!*************************************************!*\
  !*** ./node_modules/css-loader/lib/css-base.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function(useSourceMap) {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		return this.map(function (item) {
			var content = cssWithMappingToString(item, useSourceMap);
			if(item[2]) {
				return "@media " + item[2] + "{" + content + "}";
			} else {
				return content;
			}
		}).join("");
	};

	// import a list of modules into the list
	list.i = function(modules, mediaQuery) {
		if(typeof modules === "string")
			modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for(var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if(typeof id === "number")
				alreadyImportedModules[id] = true;
		}
		for(i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if(mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if(mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};

function cssWithMappingToString(item, useSourceMap) {
	var content = item[1] || '';
	var cssMapping = item[3];
	if (!cssMapping) {
		return content;
	}

	if (useSourceMap && typeof btoa === 'function') {
		var sourceMapping = toComment(cssMapping);
		var sourceURLs = cssMapping.sources.map(function (source) {
			return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'
		});

		return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
	}

	return [content].join('\n');
}

// Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
	// eslint-disable-next-line no-undef
	var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
	var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;

	return '/*# ' + data + ' */';
}


/***/ }),

/***/ "./node_modules/filepond-plugin-file-validate-type/dist/filepond-plugin-file-validate-type.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/filepond-plugin-file-validate-type/dist/filepond-plugin-file-validate-type.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*!
 * FilePondPluginFileValidateType 1.2.5
 * Licensed under MIT, https://opensource.org/licenses/MIT/
 * Please visit https://pqina.nl/filepond/ for details.
 */

/* eslint-disable */

(function(global, factory) {
   true
    ? (module.exports = factory())
    : undefined;
})(this, function() {
  'use strict';

  var plugin = function plugin(_ref) {
    var addFilter = _ref.addFilter,
      utils = _ref.utils;
    // get quick reference to Type utils
    var Type = utils.Type,
      isString = utils.isString,
      replaceInString = utils.replaceInString,
      guesstimateMimeType = utils.guesstimateMimeType,
      getExtensionFromFilename = utils.getExtensionFromFilename,
      getFilenameFromURL = utils.getFilenameFromURL;

    var mimeTypeMatchesWildCard = function mimeTypeMatchesWildCard(
      mimeType,
      wildcard
    ) {
      var mimeTypeGroup = (/^[^/]+/.exec(mimeType) || []).pop(); // image/png -> image
      var wildcardGroup = wildcard.slice(0, -2); // image/* -> image
      return mimeTypeGroup === wildcardGroup;
    };

    var isValidMimeType = function isValidMimeType(
      acceptedTypes,
      userInputType
    ) {
      return acceptedTypes.some(function(acceptedType) {
        // accepted is wildcard mime type
        if (/\*$/.test(acceptedType)) {
          return mimeTypeMatchesWildCard(userInputType, acceptedType);
        }

        // is normal mime type
        return acceptedType === userInputType;
      });
    };

    var getItemType = function getItemType(item) {
      // if the item is a url we guess the mime type by the extension
      var type = '';
      if (isString(item)) {
        var filename = getFilenameFromURL(item);
        var extension = getExtensionFromFilename(filename);
        if (extension) {
          type = guesstimateMimeType(extension);
        }
      } else {
        type = item.type;
      }

      return type;
    };

    var validateFile = function validateFile(
      item,
      acceptedFileTypes,
      typeDetector
    ) {
      // no types defined, everything is allowed \o/
      if (acceptedFileTypes.length === 0) {
        return true;
      }

      // gets the item type
      var type = getItemType(item);

      // no type detector, test now
      if (!typeDetector) {
        return isValidMimeType(acceptedFileTypes, type);
      }

      // use type detector
      return new Promise(function(resolve, reject) {
        typeDetector(item, type)
          .then(function(detectedType) {
            if (isValidMimeType(acceptedFileTypes, detectedType)) {
              resolve();
            } else {
              reject();
            }
          })
          .catch(reject);
      });
    };

    var applyMimeTypeMap = function applyMimeTypeMap(map) {
      return function(acceptedFileType) {
        return map[acceptedFileType] === null
          ? false
          : map[acceptedFileType] || acceptedFileType;
      };
    };

    // setup attribute mapping for accept
    addFilter('SET_ATTRIBUTE_TO_OPTION_MAP', function(map) {
      return Object.assign(map, {
        accept: 'acceptedFileTypes'
      });
    });

    // filtering if an item is allowed in hopper
    addFilter('ALLOW_HOPPER_ITEM', function(file, _ref2) {
      var query = _ref2.query;
      // if we are not doing file type validation exit
      if (!query('GET_ALLOW_FILE_TYPE_VALIDATION')) {
        return true;
      }

      // we validate the file against the accepted file types
      return validateFile(file, query('GET_ACCEPTED_FILE_TYPES'));
    });

    // called for each file that is loaded
    // right before it is set to the item state
    // should return a promise
    addFilter('LOAD_FILE', function(file, _ref3) {
      var query = _ref3.query;
      return new Promise(function(resolve, reject) {
        if (!query('GET_ALLOW_FILE_TYPE_VALIDATION')) {
          resolve(file);
          return;
        }

        var acceptedFileTypes = query('GET_ACCEPTED_FILE_TYPES');

        // custom type detector method
        var typeDetector = query('GET_FILE_VALIDATE_TYPE_DETECT_TYPE');

        // if invalid, exit here
        var validationResult = validateFile(
          file,
          acceptedFileTypes,
          typeDetector
        );

        var handleRejection = function handleRejection() {
          var acceptedFileTypesMapped = acceptedFileTypes
            .map(
              applyMimeTypeMap(
                query('GET_FILE_VALIDATE_TYPE_LABEL_EXPECTED_TYPES_MAP')
              )
            )
            .filter(function(label) {
              return label !== false;
            });

          reject({
            status: {
              main: query('GET_LABEL_FILE_TYPE_NOT_ALLOWED'),
              sub: replaceInString(
                query('GET_FILE_VALIDATE_TYPE_LABEL_EXPECTED_TYPES'),
                {
                  allTypes: acceptedFileTypesMapped.join(', '),
                  allButLastType: acceptedFileTypesMapped
                    .slice(0, -1)
                    .join(', '),
                  lastType:
                    acceptedFileTypesMapped[acceptedFileTypesMapped.length - 1]
                }
              )
            }
          });
        };

        // has returned new filename immidiately
        if (typeof validationResult === 'boolean') {
          if (!validationResult) {
            return handleRejection();
          }
          return resolve(file);
        }

        // is promise
        validationResult
          .then(function() {
            resolve(file);
          })
          .catch(handleRejection);
      });
    });

    // expose plugin
    return {
      // default options
      options: {
        // Enable or disable file type validation
        allowFileTypeValidation: [true, Type.BOOLEAN],

        // What file types to accept
        acceptedFileTypes: [[], Type.ARRAY],
        // - must be comma separated
        // - mime types: image/png, image/jpeg, image/gif
        // - extensions: .png, .jpg, .jpeg ( not enabled yet )
        // - wildcards: image/*

        // label to show when a type is not allowed
        labelFileTypeNotAllowed: ['File is of invalid type', Type.STRING],

        // nicer label
        fileValidateTypeLabelExpectedTypes: [
          'Expects {allButLastType} or {lastType}',
          Type.STRING
        ],

        // map mime types to extensions
        fileValidateTypeLabelExpectedTypesMap: [{}, Type.OBJECT],

        // Custom function to detect type of file
        fileValidateTypeDetectType: [null, Type.FUNCTION]
      }
    };
  };

  // fire pluginloaded event if running in browser, this allows registering the plugin when using async script tags
  var isBrowser =
    typeof window !== 'undefined' && typeof window.document !== 'undefined';
  if (isBrowser) {
    document.dispatchEvent(
      new CustomEvent('FilePond:pluginloaded', { detail: plugin })
    );
  }

  return plugin;
});


/***/ }),

/***/ "./node_modules/filepond/dist/filepond.js":
/*!************************************************!*\
  !*** ./node_modules/filepond/dist/filepond.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*!
 * FilePond 4.25.1
 * Licensed under MIT, https://opensource.org/licenses/MIT/
 * Please visit https://pqina.nl/filepond/ for details.
 */

/* eslint-disable */

(function(global, factory) {
   true
    ? factory(exports)
    : undefined;
})(this, function(exports) {
  'use strict';

  var isNode = function isNode(value) {
    return value instanceof HTMLElement;
  };

  var createStore = function createStore(initialState) {
    var queries =
      arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    var actions =
      arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
    // internal state
    var state = Object.assign({}, initialState);

    // contains all actions for next frame, is clear when actions are requested
    var actionQueue = [];
    var dispatchQueue = [];

    // returns a duplicate of the current state
    var getState = function getState() {
      return Object.assign({}, state);
    };

    // returns a duplicate of the actions array and clears the actions array
    var processActionQueue = function processActionQueue() {
      // create copy of actions queue
      var queue = [].concat(actionQueue);

      // clear actions queue (we don't want no double actions)
      actionQueue.length = 0;

      return queue;
    };

    // processes actions that might block the main UI thread
    var processDispatchQueue = function processDispatchQueue() {
      // create copy of actions queue
      var queue = [].concat(dispatchQueue);

      // clear actions queue (we don't want no double actions)
      dispatchQueue.length = 0;

      // now dispatch these actions
      queue.forEach(function(_ref) {
        var type = _ref.type,
          data = _ref.data;
        dispatch(type, data);
      });
    };

    // adds a new action, calls its handler and
    var dispatch = function dispatch(type, data, isBlocking) {
      // is blocking action (should never block if document is hidden)
      if (isBlocking && !document.hidden) {
        dispatchQueue.push({ type: type, data: data });
        return;
      }

      // if this action has a handler, handle the action
      if (actionHandlers[type]) {
        actionHandlers[type](data);
      }

      // now add action
      actionQueue.push({
        type: type,
        data: data
      });
    };

    var query = function query(str) {
      var _queryHandles;
      for (
        var _len = arguments.length,
          args = new Array(_len > 1 ? _len - 1 : 0),
          _key = 1;
        _key < _len;
        _key++
      ) {
        args[_key - 1] = arguments[_key];
      }
      return queryHandles[str]
        ? (_queryHandles = queryHandles)[str].apply(_queryHandles, args)
        : null;
    };

    var api = {
      getState: getState,
      processActionQueue: processActionQueue,
      processDispatchQueue: processDispatchQueue,
      dispatch: dispatch,
      query: query
    };

    var queryHandles = {};
    queries.forEach(function(query) {
      queryHandles = Object.assign({}, query(state), {}, queryHandles);
    });

    var actionHandlers = {};
    actions.forEach(function(action) {
      actionHandlers = Object.assign(
        {},
        action(dispatch, query, state),
        {},
        actionHandlers
      );
    });

    return api;
  };

  var defineProperty = function defineProperty(obj, property, definition) {
    if (typeof definition === 'function') {
      obj[property] = definition;
      return;
    }
    Object.defineProperty(obj, property, Object.assign({}, definition));
  };

  var forin = function forin(obj, cb) {
    for (var key in obj) {
      if (!obj.hasOwnProperty(key)) {
        continue;
      }

      cb(key, obj[key]);
    }
  };

  var createObject = function createObject(definition) {
    var obj = {};
    forin(definition, function(property) {
      defineProperty(obj, property, definition[property]);
    });
    return obj;
  };

  var attr = function attr(node, name) {
    var value =
      arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    if (value === null) {
      return node.getAttribute(name) || node.hasAttribute(name);
    }
    node.setAttribute(name, value);
  };

  var ns = 'http://www.w3.org/2000/svg';
  var svgElements = ['svg', 'path']; // only svg elements used

  var isSVGElement = function isSVGElement(tag) {
    return svgElements.includes(tag);
  };

  var createElement = function createElement(tag, className) {
    var attributes =
      arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    if (typeof className === 'object') {
      attributes = className;
      className = null;
    }
    var element = isSVGElement(tag)
      ? document.createElementNS(ns, tag)
      : document.createElement(tag);
    if (className) {
      if (isSVGElement(tag)) {
        attr(element, 'class', className);
      } else {
        element.className = className;
      }
    }
    forin(attributes, function(name, value) {
      attr(element, name, value);
    });
    return element;
  };

  var appendChild = function appendChild(parent) {
    return function(child, index) {
      if (typeof index !== 'undefined' && parent.children[index]) {
        parent.insertBefore(child, parent.children[index]);
      } else {
        parent.appendChild(child);
      }
    };
  };

  var appendChildView = function appendChildView(parent, childViews) {
    return function(view, index) {
      if (typeof index !== 'undefined') {
        childViews.splice(index, 0, view);
      } else {
        childViews.push(view);
      }

      return view;
    };
  };

  var removeChildView = function removeChildView(parent, childViews) {
    return function(view) {
      // remove from child views
      childViews.splice(childViews.indexOf(view), 1);

      // remove the element
      if (view.element.parentNode) {
        parent.removeChild(view.element);
      }

      return view;
    };
  };

  var IS_BROWSER = (function() {
    return (
      typeof window !== 'undefined' && typeof window.document !== 'undefined'
    );
  })();
  var isBrowser = function isBrowser() {
    return IS_BROWSER;
  };

  var testElement = isBrowser() ? createElement('svg') : {};
  var getChildCount =
    'children' in testElement
      ? function(el) {
          return el.children.length;
        }
      : function(el) {
          return el.childNodes.length;
        };

  var getViewRect = function getViewRect(
    elementRect,
    childViews,
    offset,
    scale
  ) {
    var left = offset[0] || elementRect.left;
    var top = offset[1] || elementRect.top;
    var right = left + elementRect.width;
    var bottom = top + elementRect.height * (scale[1] || 1);

    var rect = {
      // the rectangle of the element itself
      element: Object.assign({}, elementRect),

      // the rectangle of the element expanded to contain its children, does not include any margins
      inner: {
        left: elementRect.left,
        top: elementRect.top,
        right: elementRect.right,
        bottom: elementRect.bottom
      },

      // the rectangle of the element expanded to contain its children including own margin and child margins
      // margins will be added after we've recalculated the size
      outer: {
        left: left,
        top: top,
        right: right,
        bottom: bottom
      }
    };

    // expand rect to fit all child rectangles
    childViews
      .filter(function(childView) {
        return !childView.isRectIgnored();
      })
      .map(function(childView) {
        return childView.rect;
      })
      .forEach(function(childViewRect) {
        expandRect(rect.inner, Object.assign({}, childViewRect.inner));
        expandRect(rect.outer, Object.assign({}, childViewRect.outer));
      });

    // calculate inner width and height
    calculateRectSize(rect.inner);

    // append additional margin (top and left margins are included in top and left automatically)
    rect.outer.bottom += rect.element.marginBottom;
    rect.outer.right += rect.element.marginRight;

    // calculate outer width and height
    calculateRectSize(rect.outer);

    return rect;
  };

  var expandRect = function expandRect(parent, child) {
    // adjust for parent offset
    child.top += parent.top;
    child.right += parent.left;
    child.bottom += parent.top;
    child.left += parent.left;

    if (child.bottom > parent.bottom) {
      parent.bottom = child.bottom;
    }

    if (child.right > parent.right) {
      parent.right = child.right;
    }
  };

  var calculateRectSize = function calculateRectSize(rect) {
    rect.width = rect.right - rect.left;
    rect.height = rect.bottom - rect.top;
  };

  var isNumber = function isNumber(value) {
    return typeof value === 'number';
  };

  /**
   * Determines if position is at destination
   * @param position
   * @param destination
   * @param velocity
   * @param errorMargin
   * @returns {boolean}
   */
  var thereYet = function thereYet(position, destination, velocity) {
    var errorMargin =
      arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.001;
    return (
      Math.abs(position - destination) < errorMargin &&
      Math.abs(velocity) < errorMargin
    );
  };

  /**
   * Spring animation
   */
  var spring =
    // default options
    function spring() // method definition
    {
      var _ref =
          arguments.length > 0 && arguments[0] !== undefined
            ? arguments[0]
            : {},
        _ref$stiffness = _ref.stiffness,
        stiffness = _ref$stiffness === void 0 ? 0.5 : _ref$stiffness,
        _ref$damping = _ref.damping,
        damping = _ref$damping === void 0 ? 0.75 : _ref$damping,
        _ref$mass = _ref.mass,
        mass = _ref$mass === void 0 ? 10 : _ref$mass;
      var target = null;
      var position = null;
      var velocity = 0;
      var resting = false;

      // updates spring state
      var interpolate = function interpolate(ts, skipToEndState) {
        // in rest, don't animate
        if (resting) return;

        // need at least a target or position to do springy things
        if (!(isNumber(target) && isNumber(position))) {
          resting = true;
          velocity = 0;
          return;
        }

        // calculate spring force
        var f = -(position - target) * stiffness;

        // update velocity by adding force based on mass
        velocity += f / mass;

        // update position by adding velocity
        position += velocity;

        // slow down based on amount of damping
        velocity *= damping;

        // we've arrived if we're near target and our velocity is near zero
        if (thereYet(position, target, velocity) || skipToEndState) {
          position = target;
          velocity = 0;
          resting = true;

          // we done
          api.onupdate(position);
          api.oncomplete(position);
        } else {
          // progress update
          api.onupdate(position);
        }
      };

      /**
       * Set new target value
       * @param value
       */
      var setTarget = function setTarget(value) {
        // if currently has no position, set target and position to this value
        if (isNumber(value) && !isNumber(position)) {
          position = value;
        }

        // next target value will not be animated to
        if (target === null) {
          target = value;
          position = value;
        }

        // let start moving to target
        target = value;

        // already at target
        if (position === target || typeof target === 'undefined') {
          // now resting as target is current position, stop moving
          resting = true;
          velocity = 0;

          // done!
          api.onupdate(position);
          api.oncomplete(position);

          return;
        }

        resting = false;
      };

      // need 'api' to call onupdate callback
      var api = createObject({
        interpolate: interpolate,
        target: {
          set: setTarget,
          get: function get() {
            return target;
          }
        },

        resting: {
          get: function get() {
            return resting;
          }
        },

        onupdate: function onupdate(value) {},
        oncomplete: function oncomplete(value) {}
      });

      return api;
    };

  var easeLinear = function easeLinear(t) {
    return t;
  };
  var easeInOutQuad = function easeInOutQuad(t) {
    return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
  };

  var tween =
    // default values
    function tween() // method definition
    {
      var _ref =
          arguments.length > 0 && arguments[0] !== undefined
            ? arguments[0]
            : {},
        _ref$duration = _ref.duration,
        duration = _ref$duration === void 0 ? 500 : _ref$duration,
        _ref$easing = _ref.easing,
        easing = _ref$easing === void 0 ? easeInOutQuad : _ref$easing,
        _ref$delay = _ref.delay,
        delay = _ref$delay === void 0 ? 0 : _ref$delay;
      var start = null;
      var t;
      var p;
      var resting = true;
      var reverse = false;
      var target = null;

      var interpolate = function interpolate(ts, skipToEndState) {
        if (resting || target === null) return;

        if (start === null) {
          start = ts;
        }

        if (ts - start < delay) return;

        t = ts - start - delay;

        if (t >= duration || skipToEndState) {
          t = 1;
          p = reverse ? 0 : 1;
          api.onupdate(p * target);
          api.oncomplete(p * target);
          resting = true;
        } else {
          p = t / duration;
          api.onupdate((t >= 0 ? easing(reverse ? 1 - p : p) : 0) * target);
        }
      };

      // need 'api' to call onupdate callback
      var api = createObject({
        interpolate: interpolate,
        target: {
          get: function get() {
            return reverse ? 0 : target;
          },
          set: function set(value) {
            // is initial value
            if (target === null) {
              target = value;
              api.onupdate(value);
              api.oncomplete(value);
              return;
            }

            // want to tween to a smaller value and have a current value
            if (value < target) {
              target = 1;
              reverse = true;
            } else {
              // not tweening to a smaller value
              reverse = false;
              target = value;
            }

            // let's go!
            resting = false;
            start = null;
          }
        },

        resting: {
          get: function get() {
            return resting;
          }
        },

        onupdate: function onupdate(value) {},
        oncomplete: function oncomplete(value) {}
      });

      return api;
    };

  var animator = {
    spring: spring,
    tween: tween
  };

  /*
                       { type: 'spring', stiffness: .5, damping: .75, mass: 10 };
                       { translation: { type: 'spring', ... }, ... }
                       { translation: { x: { type: 'spring', ... } } }
                      */
  var createAnimator = function createAnimator(definition, category, property) {
    // default is single definition
    // we check if transform is set, if so, we check if property is set
    var def =
      definition[category] && typeof definition[category][property] === 'object'
        ? definition[category][property]
        : definition[category] || definition;

    var type = typeof def === 'string' ? def : def.type;
    var props = typeof def === 'object' ? Object.assign({}, def) : {};

    return animator[type] ? animator[type](props) : null;
  };

  var addGetSet = function addGetSet(keys, obj, props) {
    var overwrite =
      arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    obj = Array.isArray(obj) ? obj : [obj];
    obj.forEach(function(o) {
      keys.forEach(function(key) {
        var name = key;
        var getter = function getter() {
          return props[key];
        };
        var setter = function setter(value) {
          return (props[key] = value);
        };

        if (typeof key === 'object') {
          name = key.key;
          getter = key.getter || getter;
          setter = key.setter || setter;
        }

        if (o[name] && !overwrite) {
          return;
        }

        o[name] = {
          get: getter,
          set: setter
        };
      });
    });
  };

  // add to state,
  // add getters and setters to internal and external api (if not set)
  // setup animators

  var animations = function animations(_ref) {
    var mixinConfig = _ref.mixinConfig,
      viewProps = _ref.viewProps,
      viewInternalAPI = _ref.viewInternalAPI,
      viewExternalAPI = _ref.viewExternalAPI;
    // initial properties
    var initialProps = Object.assign({}, viewProps);

    // list of all active animations
    var animations = [];

    // setup animators
    forin(mixinConfig, function(property, animation) {
      var animator = createAnimator(animation);
      if (!animator) {
        return;
      }

      // when the animator updates, update the view state value
      animator.onupdate = function(value) {
        viewProps[property] = value;
      };

      // set animator target
      animator.target = initialProps[property];

      // when value is set, set the animator target value
      var prop = {
        key: property,
        setter: function setter(value) {
          // if already at target, we done!
          if (animator.target === value) {
            return;
          }

          animator.target = value;
        },
        getter: function getter() {
          return viewProps[property];
        }
      };

      // add getters and setters
      addGetSet([prop], [viewInternalAPI, viewExternalAPI], viewProps, true);

      // add it to the list for easy updating from the _write method
      animations.push(animator);
    });

    // expose internal write api
    return {
      write: function write(ts) {
        var skipToEndState = document.hidden;
        var resting = true;
        animations.forEach(function(animation) {
          if (!animation.resting) resting = false;
          animation.interpolate(ts, skipToEndState);
        });
        return resting;
      },
      destroy: function destroy() {}
    };
  };

  var addEvent = function addEvent(element) {
    return function(type, fn) {
      element.addEventListener(type, fn);
    };
  };

  var removeEvent = function removeEvent(element) {
    return function(type, fn) {
      element.removeEventListener(type, fn);
    };
  };

  // mixin
  var listeners = function listeners(_ref) {
    var mixinConfig = _ref.mixinConfig,
      viewProps = _ref.viewProps,
      viewInternalAPI = _ref.viewInternalAPI,
      viewExternalAPI = _ref.viewExternalAPI,
      viewState = _ref.viewState,
      view = _ref.view;
    var events = [];

    var add = addEvent(view.element);
    var remove = removeEvent(view.element);

    viewExternalAPI.on = function(type, fn) {
      events.push({
        type: type,
        fn: fn
      });

      add(type, fn);
    };

    viewExternalAPI.off = function(type, fn) {
      events.splice(
        events.findIndex(function(event) {
          return event.type === type && event.fn === fn;
        }),
        1
      );

      remove(type, fn);
    };

    return {
      write: function write() {
        // not busy
        return true;
      },
      destroy: function destroy() {
        events.forEach(function(event) {
          remove(event.type, event.fn);
        });
      }
    };
  };

  // add to external api and link to props

  var apis = function apis(_ref) {
    var mixinConfig = _ref.mixinConfig,
      viewProps = _ref.viewProps,
      viewExternalAPI = _ref.viewExternalAPI;
    addGetSet(mixinConfig, viewExternalAPI, viewProps);
  };

  var isDefined = function isDefined(value) {
    return value != null;
  };

  // add to state,
  // add getters and setters to internal and external api (if not set)
  // set initial state based on props in viewProps
  // apply as transforms each frame

  var defaults = {
    opacity: 1,
    scaleX: 1,
    scaleY: 1,
    translateX: 0,
    translateY: 0,
    rotateX: 0,
    rotateY: 0,
    rotateZ: 0,
    originX: 0,
    originY: 0
  };

  var styles = function styles(_ref) {
    var mixinConfig = _ref.mixinConfig,
      viewProps = _ref.viewProps,
      viewInternalAPI = _ref.viewInternalAPI,
      viewExternalAPI = _ref.viewExternalAPI,
      view = _ref.view;
    // initial props
    var initialProps = Object.assign({}, viewProps);

    // current props
    var currentProps = {};

    // we will add those properties to the external API and link them to the viewState
    addGetSet(mixinConfig, [viewInternalAPI, viewExternalAPI], viewProps);

    // override rect on internal and external rect getter so it takes in account transforms
    var getOffset = function getOffset() {
      return [viewProps['translateX'] || 0, viewProps['translateY'] || 0];
    };

    var getScale = function getScale() {
      return [viewProps['scaleX'] || 0, viewProps['scaleY'] || 0];
    };
    var getRect = function getRect() {
      return view.rect
        ? getViewRect(view.rect, view.childViews, getOffset(), getScale())
        : null;
    };
    viewInternalAPI.rect = { get: getRect };
    viewExternalAPI.rect = { get: getRect };

    // apply view props
    mixinConfig.forEach(function(key) {
      viewProps[key] =
        typeof initialProps[key] === 'undefined'
          ? defaults[key]
          : initialProps[key];
    });

    // expose api
    return {
      write: function write() {
        // see if props have changed
        if (!propsHaveChanged(currentProps, viewProps)) {
          return;
        }

        // moves element to correct position on screen
        applyStyles(view.element, viewProps);

        // store new transforms
        Object.assign(currentProps, Object.assign({}, viewProps));

        // no longer busy
        return true;
      },
      destroy: function destroy() {}
    };
  };

  var propsHaveChanged = function propsHaveChanged(currentProps, newProps) {
    // different amount of keys
    if (Object.keys(currentProps).length !== Object.keys(newProps).length) {
      return true;
    }

    // lets analyze the individual props
    for (var prop in newProps) {
      if (newProps[prop] !== currentProps[prop]) {
        return true;
      }
    }

    return false;
  };

  var applyStyles = function applyStyles(element, _ref2) {
    var opacity = _ref2.opacity,
      perspective = _ref2.perspective,
      translateX = _ref2.translateX,
      translateY = _ref2.translateY,
      scaleX = _ref2.scaleX,
      scaleY = _ref2.scaleY,
      rotateX = _ref2.rotateX,
      rotateY = _ref2.rotateY,
      rotateZ = _ref2.rotateZ,
      originX = _ref2.originX,
      originY = _ref2.originY,
      width = _ref2.width,
      height = _ref2.height;

    var transforms = '';
    var styles = '';

    // handle transform origin
    if (isDefined(originX) || isDefined(originY)) {
      styles +=
        'transform-origin: ' + (originX || 0) + 'px ' + (originY || 0) + 'px;';
    }

    // transform order is relevant
    // 0. perspective
    if (isDefined(perspective)) {
      transforms += 'perspective(' + perspective + 'px) ';
    }

    // 1. translate
    if (isDefined(translateX) || isDefined(translateY)) {
      transforms +=
        'translate3d(' +
        (translateX || 0) +
        'px, ' +
        (translateY || 0) +
        'px, 0) ';
    }

    // 2. scale
    if (isDefined(scaleX) || isDefined(scaleY)) {
      transforms +=
        'scale3d(' +
        (isDefined(scaleX) ? scaleX : 1) +
        ', ' +
        (isDefined(scaleY) ? scaleY : 1) +
        ', 1) ';
    }

    // 3. rotate
    if (isDefined(rotateZ)) {
      transforms += 'rotateZ(' + rotateZ + 'rad) ';
    }

    if (isDefined(rotateX)) {
      transforms += 'rotateX(' + rotateX + 'rad) ';
    }

    if (isDefined(rotateY)) {
      transforms += 'rotateY(' + rotateY + 'rad) ';
    }

    // add transforms
    if (transforms.length) {
      styles += 'transform:' + transforms + ';';
    }

    // add opacity
    if (isDefined(opacity)) {
      styles += 'opacity:' + opacity + ';';

      // if we reach zero, we make the element inaccessible
      if (opacity === 0) {
        styles += 'visibility:hidden;';
      }

      // if we're below 100% opacity this element can't be clicked
      if (opacity < 1) {
        styles += 'pointer-events:none;';
      }
    }

    // add height
    if (isDefined(height)) {
      styles += 'height:' + height + 'px;';
    }

    // add width
    if (isDefined(width)) {
      styles += 'width:' + width + 'px;';
    }

    // apply styles
    var elementCurrentStyle = element.elementCurrentStyle || '';

    // if new styles does not match current styles, lets update!
    if (
      styles.length !== elementCurrentStyle.length ||
      styles !== elementCurrentStyle
    ) {
      element.style.cssText = styles;
      // store current styles so we can compare them to new styles later on
      // _not_ getting the style value is faster
      element.elementCurrentStyle = styles;
    }
  };

  var Mixins = {
    styles: styles,
    listeners: listeners,
    animations: animations,
    apis: apis
  };

  var updateRect = function updateRect() {
    var rect =
      arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var element =
      arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var style =
      arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    if (!element.layoutCalculated) {
      rect.paddingTop = parseInt(style.paddingTop, 10) || 0;
      rect.marginTop = parseInt(style.marginTop, 10) || 0;
      rect.marginRight = parseInt(style.marginRight, 10) || 0;
      rect.marginBottom = parseInt(style.marginBottom, 10) || 0;
      rect.marginLeft = parseInt(style.marginLeft, 10) || 0;
      element.layoutCalculated = true;
    }

    rect.left = element.offsetLeft || 0;
    rect.top = element.offsetTop || 0;
    rect.width = element.offsetWidth || 0;
    rect.height = element.offsetHeight || 0;

    rect.right = rect.left + rect.width;
    rect.bottom = rect.top + rect.height;

    rect.scrollTop = element.scrollTop;

    rect.hidden = element.offsetParent === null;

    return rect;
  };

  var createView =
    // default view definition
    function createView() {
      var _ref =
          arguments.length > 0 && arguments[0] !== undefined
            ? arguments[0]
            : {},
        _ref$tag = _ref.tag,
        tag = _ref$tag === void 0 ? 'div' : _ref$tag,
        _ref$name = _ref.name,
        name = _ref$name === void 0 ? null : _ref$name,
        _ref$attributes = _ref.attributes,
        attributes = _ref$attributes === void 0 ? {} : _ref$attributes,
        _ref$read = _ref.read,
        read = _ref$read === void 0 ? function() {} : _ref$read,
        _ref$write = _ref.write,
        write = _ref$write === void 0 ? function() {} : _ref$write,
        _ref$create = _ref.create,
        create = _ref$create === void 0 ? function() {} : _ref$create,
        _ref$destroy = _ref.destroy,
        destroy = _ref$destroy === void 0 ? function() {} : _ref$destroy,
        _ref$filterFrameActio = _ref.filterFrameActionsForChild,
        filterFrameActionsForChild =
          _ref$filterFrameActio === void 0
            ? function(child, actions) {
                return actions;
              }
            : _ref$filterFrameActio,
        _ref$didCreateView = _ref.didCreateView,
        didCreateView =
          _ref$didCreateView === void 0 ? function() {} : _ref$didCreateView,
        _ref$didWriteView = _ref.didWriteView,
        didWriteView =
          _ref$didWriteView === void 0 ? function() {} : _ref$didWriteView,
        _ref$ignoreRect = _ref.ignoreRect,
        ignoreRect = _ref$ignoreRect === void 0 ? false : _ref$ignoreRect,
        _ref$ignoreRectUpdate = _ref.ignoreRectUpdate,
        ignoreRectUpdate =
          _ref$ignoreRectUpdate === void 0 ? false : _ref$ignoreRectUpdate,
        _ref$mixins = _ref.mixins,
        mixins = _ref$mixins === void 0 ? [] : _ref$mixins;
      return function(
        // each view requires reference to store
        store
      ) {
        var props =
          arguments.length > 1 && arguments[1] !== undefined
            ? arguments[1]
            : {};
        // root element should not be changed
        var element = createElement(tag, 'filepond--' + name, attributes);

        // style reference should also not be changed
        var style = window.getComputedStyle(element, null);

        // element rectangle
        var rect = updateRect();
        var frameRect = null;

        // rest state
        var isResting = false;

        // pretty self explanatory
        var childViews = [];

        // loaded mixins
        var activeMixins = [];

        // references to created children
        var ref = {};

        // state used for each instance
        var state = {};

        // list of writers that will be called to update this view
        var writers = [
          write // default writer
        ];

        var readers = [
          read // default reader
        ];

        var destroyers = [
          destroy // default destroy
        ];

        // core view methods
        var getElement = function getElement() {
          return element;
        };
        var getChildViews = function getChildViews() {
          return childViews.concat();
        };
        var getReference = function getReference() {
          return ref;
        };
        var createChildView = function createChildView(store) {
          return function(view, props) {
            return view(store, props);
          };
        };
        var getRect = function getRect() {
          if (frameRect) {
            return frameRect;
          }
          frameRect = getViewRect(rect, childViews, [0, 0], [1, 1]);
          return frameRect;
        };
        var getStyle = function getStyle() {
          return style;
        };

        /**
         * Read data from DOM
         * @private
         */
        var _read = function _read() {
          frameRect = null;

          // read child views
          childViews.forEach(function(child) {
            return child._read();
          });

          var shouldUpdate = !(ignoreRectUpdate && rect.width && rect.height);
          if (shouldUpdate) {
            updateRect(rect, element, style);
          }

          // readers
          var api = { root: internalAPI, props: props, rect: rect };
          readers.forEach(function(reader) {
            return reader(api);
          });
        };

        /**
         * Write data to DOM
         * @private
         */
        var _write = function _write(ts, frameActions, shouldOptimize) {
          // if no actions, we assume that the view is resting
          var resting = frameActions.length === 0;

          // writers
          writers.forEach(function(writer) {
            var writerResting = writer({
              props: props,
              root: internalAPI,
              actions: frameActions,
              timestamp: ts,
              shouldOptimize: shouldOptimize
            });

            if (writerResting === false) {
              resting = false;
            }
          });

          // run mixins
          activeMixins.forEach(function(mixin) {
            // if one of the mixins is still busy after write operation, we are not resting
            var mixinResting = mixin.write(ts);
            if (mixinResting === false) {
              resting = false;
            }
          });

          // updates child views that are currently attached to the DOM
          childViews
            .filter(function(child) {
              return !!child.element.parentNode;
            })
            .forEach(function(child) {
              // if a child view is not resting, we are not resting
              var childResting = child._write(
                ts,
                filterFrameActionsForChild(child, frameActions),
                shouldOptimize
              );

              if (!childResting) {
                resting = false;
              }
            });

          // append new elements to DOM and update those
          childViews
            //.filter(child => !child.element.parentNode)
            .forEach(function(child, index) {
              // skip
              if (child.element.parentNode) {
                return;
              }

              // append to DOM
              internalAPI.appendChild(child.element, index);

              // call read (need to know the size of these elements)
              child._read();

              // re-call write
              child._write(
                ts,
                filterFrameActionsForChild(child, frameActions),
                shouldOptimize
              );

              // we just added somthing to the dom, no rest
              resting = false;
            });

          // update resting state
          isResting = resting;

          didWriteView({
            props: props,
            root: internalAPI,
            actions: frameActions,
            timestamp: ts
          });

          // let parent know if we are resting
          return resting;
        };

        var _destroy = function _destroy() {
          activeMixins.forEach(function(mixin) {
            return mixin.destroy();
          });
          destroyers.forEach(function(destroyer) {
            destroyer({ root: internalAPI, props: props });
          });
          childViews.forEach(function(child) {
            return child._destroy();
          });
        };

        // sharedAPI
        var sharedAPIDefinition = {
          element: {
            get: getElement
          },

          style: {
            get: getStyle
          },

          childViews: {
            get: getChildViews
          }
        };

        // private API definition
        var internalAPIDefinition = Object.assign({}, sharedAPIDefinition, {
          rect: {
            get: getRect
          },

          // access to custom children references
          ref: {
            get: getReference
          },

          // dom modifiers
          is: function is(needle) {
            return name === needle;
          },
          appendChild: appendChild(element),
          createChildView: createChildView(store),
          linkView: function linkView(view) {
            childViews.push(view);
            return view;
          },
          unlinkView: function unlinkView(view) {
            childViews.splice(childViews.indexOf(view), 1);
          },
          appendChildView: appendChildView(element, childViews),
          removeChildView: removeChildView(element, childViews),
          registerWriter: function registerWriter(writer) {
            return writers.push(writer);
          },
          registerReader: function registerReader(reader) {
            return readers.push(reader);
          },
          registerDestroyer: function registerDestroyer(destroyer) {
            return destroyers.push(destroyer);
          },
          invalidateLayout: function invalidateLayout() {
            return (element.layoutCalculated = false);
          },

          // access to data store
          dispatch: store.dispatch,
          query: store.query
        });

        // public view API methods
        var externalAPIDefinition = {
          element: {
            get: getElement
          },

          childViews: {
            get: getChildViews
          },

          rect: {
            get: getRect
          },

          resting: {
            get: function get() {
              return isResting;
            }
          },

          isRectIgnored: function isRectIgnored() {
            return ignoreRect;
          },
          _read: _read,
          _write: _write,
          _destroy: _destroy
        };

        // mixin API methods
        var mixinAPIDefinition = Object.assign({}, sharedAPIDefinition, {
          rect: {
            get: function get() {
              return rect;
            }
          }
        });

        // add mixin functionality
        Object.keys(mixins)
          .sort(function(a, b) {
            // move styles to the back of the mixin list (so adjustments of other mixins are applied to the props correctly)
            if (a === 'styles') {
              return 1;
            } else if (b === 'styles') {
              return -1;
            }
            return 0;
          })
          .forEach(function(key) {
            var mixinAPI = Mixins[key]({
              mixinConfig: mixins[key],
              viewProps: props,
              viewState: state,
              viewInternalAPI: internalAPIDefinition,
              viewExternalAPI: externalAPIDefinition,
              view: createObject(mixinAPIDefinition)
            });

            if (mixinAPI) {
              activeMixins.push(mixinAPI);
            }
          });

        // construct private api
        var internalAPI = createObject(internalAPIDefinition);

        // create the view
        create({
          root: internalAPI,
          props: props
        });

        // append created child views to root node
        var childCount = getChildCount(element); // need to know the current child count so appending happens in correct order
        childViews.forEach(function(child, index) {
          internalAPI.appendChild(child.element, childCount + index);
        });

        // call did create
        didCreateView(internalAPI);

        // expose public api
        return createObject(externalAPIDefinition);
      };
    };

  var createPainter = function createPainter(read, write) {
    var fps =
      arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 60;

    var name = '__framePainter';

    // set global painter
    if (window[name]) {
      window[name].readers.push(read);
      window[name].writers.push(write);
      return;
    }

    window[name] = {
      readers: [read],
      writers: [write]
    };

    var painter = window[name];

    var interval = 1000 / fps;
    var last = null;
    var id = null;
    var requestTick = null;
    var cancelTick = null;

    var setTimerType = function setTimerType() {
      if (document.hidden) {
        requestTick = function requestTick() {
          return window.setTimeout(function() {
            return tick(performance.now());
          }, interval);
        };
        cancelTick = function cancelTick() {
          return window.clearTimeout(id);
        };
      } else {
        requestTick = function requestTick() {
          return window.requestAnimationFrame(tick);
        };
        cancelTick = function cancelTick() {
          return window.cancelAnimationFrame(id);
        };
      }
    };

    document.addEventListener('visibilitychange', function() {
      if (cancelTick) cancelTick();
      setTimerType();
      tick(performance.now());
    });

    var tick = function tick(ts) {
      // queue next tick
      id = requestTick(tick);

      // limit fps
      if (!last) {
        last = ts;
      }

      var delta = ts - last;

      if (delta <= interval) {
        // skip frame
        return;
      }

      // align next frame
      last = ts - (delta % interval);

      // update view
      painter.readers.forEach(function(read) {
        return read();
      });
      painter.writers.forEach(function(write) {
        return write(ts);
      });
    };

    setTimerType();
    tick(performance.now());

    return {
      pause: function pause() {
        cancelTick(id);
      }
    };
  };

  var createRoute = function createRoute(routes, fn) {
    return function(_ref) {
      var root = _ref.root,
        props = _ref.props,
        _ref$actions = _ref.actions,
        actions = _ref$actions === void 0 ? [] : _ref$actions,
        timestamp = _ref.timestamp,
        shouldOptimize = _ref.shouldOptimize;
      actions
        .filter(function(action) {
          return routes[action.type];
        })
        .forEach(function(action) {
          return routes[action.type]({
            root: root,
            props: props,
            action: action.data,
            timestamp: timestamp,
            shouldOptimize: shouldOptimize
          });
        });

      if (fn) {
        fn({
          root: root,
          props: props,
          actions: actions,
          timestamp: timestamp,
          shouldOptimize: shouldOptimize
        });
      }
    };
  };

  var insertBefore = function insertBefore(newNode, referenceNode) {
    return referenceNode.parentNode.insertBefore(newNode, referenceNode);
  };

  var insertAfter = function insertAfter(newNode, referenceNode) {
    return referenceNode.parentNode.insertBefore(
      newNode,
      referenceNode.nextSibling
    );
  };

  var isArray = function isArray(value) {
    return Array.isArray(value);
  };

  var isEmpty = function isEmpty(value) {
    return value == null;
  };

  var trim = function trim(str) {
    return str.trim();
  };

  var toString = function toString(value) {
    return '' + value;
  };

  var toArray = function toArray(value) {
    var splitter =
      arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ',';
    if (isEmpty(value)) {
      return [];
    }
    if (isArray(value)) {
      return value;
    }
    return toString(value)
      .split(splitter)
      .map(trim)
      .filter(function(str) {
        return str.length;
      });
  };

  var isBoolean = function isBoolean(value) {
    return typeof value === 'boolean';
  };

  var toBoolean = function toBoolean(value) {
    return isBoolean(value) ? value : value === 'true';
  };

  var isString = function isString(value) {
    return typeof value === 'string';
  };

  var toNumber = function toNumber(value) {
    return isNumber(value)
      ? value
      : isString(value)
      ? toString(value).replace(/[a-z]+/gi, '')
      : 0;
  };

  var toInt = function toInt(value) {
    return parseInt(toNumber(value), 10);
  };

  var toFloat = function toFloat(value) {
    return parseFloat(toNumber(value));
  };

  var isInt = function isInt(value) {
    return isNumber(value) && isFinite(value) && Math.floor(value) === value;
  };

  var toBytes = function toBytes(value) {
    var base =
      arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;
    // is in bytes
    if (isInt(value)) {
      return value;
    }

    // is natural file size
    var naturalFileSize = toString(value).trim();

    // if is value in megabytes
    if (/MB$/i.test(naturalFileSize)) {
      naturalFileSize = naturalFileSize.replace(/MB$i/, '').trim();
      return toInt(naturalFileSize) * base * base;
    }

    // if is value in kilobytes
    if (/KB/i.test(naturalFileSize)) {
      naturalFileSize = naturalFileSize.replace(/KB$i/, '').trim();
      return toInt(naturalFileSize) * base;
    }

    return toInt(naturalFileSize);
  };

  var isFunction = function isFunction(value) {
    return typeof value === 'function';
  };

  var toFunctionReference = function toFunctionReference(string) {
    var ref = self;
    var levels = string.split('.');
    var level = null;
    while ((level = levels.shift())) {
      ref = ref[level];
      if (!ref) {
        return null;
      }
    }
    return ref;
  };

  var methods = {
    process: 'POST',
    patch: 'PATCH',
    revert: 'DELETE',
    fetch: 'GET',
    restore: 'GET',
    load: 'GET'
  };

  var createServerAPI = function createServerAPI(outline) {
    var api = {};

    api.url = isString(outline) ? outline : outline.url || '';
    api.timeout = outline.timeout ? parseInt(outline.timeout, 10) : 0;
    api.headers = outline.headers ? outline.headers : {};

    forin(methods, function(key) {
      api[key] = createAction(
        key,
        outline[key],
        methods[key],
        api.timeout,
        api.headers
      );
    });

    // special treatment for remove
    api.remove = outline.remove || null;

    // remove generic headers from api object
    delete api.headers;

    return api;
  };

  var createAction = function createAction(
    name,
    outline,
    method,
    timeout,
    headers
  ) {
    // is explicitely set to null so disable
    if (outline === null) {
      return null;
    }

    // if is custom function, done! Dev handles everything.
    if (typeof outline === 'function') {
      return outline;
    }

    // build action object
    var action = {
      url: method === 'GET' || method === 'PATCH' ? '?' + name + '=' : '',
      method: method,
      headers: headers,
      withCredentials: false,
      timeout: timeout,
      onload: null,
      ondata: null,
      onerror: null
    };

    // is a single url
    if (isString(outline)) {
      action.url = outline;
      return action;
    }

    // overwrite
    Object.assign(action, outline);

    // see if should reformat headers;
    if (isString(action.headers)) {
      var parts = action.headers.split(/:(.+)/);
      action.headers = {
        header: parts[0],
        value: parts[1]
      };
    }

    // if is bool withCredentials
    action.withCredentials = toBoolean(action.withCredentials);

    return action;
  };

  var toServerAPI = function toServerAPI(value) {
    return createServerAPI(value);
  };

  var isNull = function isNull(value) {
    return value === null;
  };

  var isObject = function isObject(value) {
    return typeof value === 'object' && value !== null;
  };

  var isAPI = function isAPI(value) {
    return (
      isObject(value) &&
      isString(value.url) &&
      isObject(value.process) &&
      isObject(value.revert) &&
      isObject(value.restore) &&
      isObject(value.fetch)
    );
  };

  var getType = function getType(value) {
    if (isArray(value)) {
      return 'array';
    }

    if (isNull(value)) {
      return 'null';
    }

    if (isInt(value)) {
      return 'int';
    }

    if (/^[0-9]+ ?(?:GB|MB|KB)$/gi.test(value)) {
      return 'bytes';
    }

    if (isAPI(value)) {
      return 'api';
    }

    return typeof value;
  };

  var replaceSingleQuotes = function replaceSingleQuotes(str) {
    return str
      .replace(/{\s*'/g, '{"')
      .replace(/'\s*}/g, '"}')
      .replace(/'\s*:/g, '":')
      .replace(/:\s*'/g, ':"')
      .replace(/,\s*'/g, ',"')
      .replace(/'\s*,/g, '",');
  };

  var conversionTable = {
    array: toArray,
    boolean: toBoolean,
    int: function int(value) {
      return getType(value) === 'bytes' ? toBytes(value) : toInt(value);
    },
    number: toFloat,
    float: toFloat,
    bytes: toBytes,
    string: function string(value) {
      return isFunction(value) ? value : toString(value);
    },
    function: function _function(value) {
      return toFunctionReference(value);
    },
    serverapi: toServerAPI,
    object: function object(value) {
      try {
        return JSON.parse(replaceSingleQuotes(value));
      } catch (e) {
        return null;
      }
    }
  };

  var convertTo = function convertTo(value, type) {
    return conversionTable[type](value);
  };

  var getValueByType = function getValueByType(
    newValue,
    defaultValue,
    valueType
  ) {
    // can always assign default value
    if (newValue === defaultValue) {
      return newValue;
    }

    // get the type of the new value
    var newValueType = getType(newValue);

    // is valid type?
    if (newValueType !== valueType) {
      // is string input, let's attempt to convert
      var convertedValue = convertTo(newValue, valueType);

      // what is the type now
      newValueType = getType(convertedValue);

      // no valid conversions found
      if (convertedValue === null) {
        throw 'Trying to assign value with incorrect type to "' +
          option +
          '", allowed type: "' +
          valueType +
          '"';
      } else {
        newValue = convertedValue;
      }
    }

    // assign new value
    return newValue;
  };

  var createOption = function createOption(defaultValue, valueType) {
    var currentValue = defaultValue;
    return {
      enumerable: true,
      get: function get() {
        return currentValue;
      },
      set: function set(newValue) {
        currentValue = getValueByType(newValue, defaultValue, valueType);
      }
    };
  };

  var createOptions = function createOptions(options) {
    var obj = {};
    forin(options, function(prop) {
      var optionDefinition = options[prop];
      obj[prop] = createOption(optionDefinition[0], optionDefinition[1]);
    });
    return createObject(obj);
  };

  var createInitialState = function createInitialState(options) {
    return {
      // model
      items: [],

      // timeout used for calling update items
      listUpdateTimeout: null,

      // timeout used for stacking metadata updates
      itemUpdateTimeout: null,

      // queue of items waiting to be processed
      processingQueue: [],

      // options
      options: createOptions(options)
    };
  };

  var fromCamels = function fromCamels(string) {
    var separator =
      arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '-';
    return string
      .split(/(?=[A-Z])/)
      .map(function(part) {
        return part.toLowerCase();
      })
      .join(separator);
  };

  var createOptionAPI = function createOptionAPI(store, options) {
    var obj = {};
    forin(options, function(key) {
      obj[key] = {
        get: function get() {
          return store.getState().options[key];
        },
        set: function set(value) {
          store.dispatch('SET_' + fromCamels(key, '_').toUpperCase(), {
            value: value
          });
        }
      };
    });
    return obj;
  };

  var createOptionActions = function createOptionActions(options) {
    return function(dispatch, query, state) {
      var obj = {};
      forin(options, function(key) {
        var name = fromCamels(key, '_').toUpperCase();

        obj['SET_' + name] = function(action) {
          try {
            state.options[key] = action.value;
          } catch (e) {} // nope, failed

          // we successfully set the value of this option
          dispatch('DID_SET_' + name, { value: state.options[key] });
        };
      });
      return obj;
    };
  };

  var createOptionQueries = function createOptionQueries(options) {
    return function(state) {
      var obj = {};
      forin(options, function(key) {
        obj['GET_' + fromCamels(key, '_').toUpperCase()] = function(action) {
          return state.options[key];
        };
      });
      return obj;
    };
  };

  var InteractionMethod = {
    API: 1,
    DROP: 2,
    BROWSE: 3,
    PASTE: 4,
    NONE: 5
  };

  var getUniqueId = function getUniqueId() {
    return Math.random()
      .toString(36)
      .substr(2, 9);
  };

  function _typeof(obj) {
    if (typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol') {
      _typeof = function(obj) {
        return typeof obj;
      };
    } else {
      _typeof = function(obj) {
        return obj &&
          typeof Symbol === 'function' &&
          obj.constructor === Symbol &&
          obj !== Symbol.prototype
          ? 'symbol'
          : typeof obj;
      };
    }

    return _typeof(obj);
  }

  var REACT_ELEMENT_TYPE;

  function _jsx(type, props, key, children) {
    if (!REACT_ELEMENT_TYPE) {
      REACT_ELEMENT_TYPE =
        (typeof Symbol === 'function' &&
          Symbol['for'] &&
          Symbol['for']('react.element')) ||
        0xeac7;
    }

    var defaultProps = type && type.defaultProps;
    var childrenLength = arguments.length - 3;

    if (!props && childrenLength !== 0) {
      props = {
        children: void 0
      };
    }

    if (props && defaultProps) {
      for (var propName in defaultProps) {
        if (props[propName] === void 0) {
          props[propName] = defaultProps[propName];
        }
      }
    } else if (!props) {
      props = defaultProps || {};
    }

    if (childrenLength === 1) {
      props.children = children;
    } else if (childrenLength > 1) {
      var childArray = new Array(childrenLength);

      for (var i = 0; i < childrenLength; i++) {
        childArray[i] = arguments[i + 3];
      }

      props.children = childArray;
    }

    return {
      $$typeof: REACT_ELEMENT_TYPE,
      type: type,
      key: key === undefined ? null : '' + key,
      ref: null,
      props: props,
      _owner: null
    };
  }

  function _asyncIterator(iterable) {
    var method;

    if (typeof Symbol !== 'undefined') {
      if (Symbol.asyncIterator) {
        method = iterable[Symbol.asyncIterator];
        if (method != null) return method.call(iterable);
      }

      if (Symbol.iterator) {
        method = iterable[Symbol.iterator];
        if (method != null) return method.call(iterable);
      }
    }

    throw new TypeError('Object is not async iterable');
  }

  function _AwaitValue(value) {
    this.wrapped = value;
  }

  function _AsyncGenerator(gen) {
    var front, back;

    function send(key, arg) {
      return new Promise(function(resolve, reject) {
        var request = {
          key: key,
          arg: arg,
          resolve: resolve,
          reject: reject,
          next: null
        };

        if (back) {
          back = back.next = request;
        } else {
          front = back = request;
          resume(key, arg);
        }
      });
    }

    function resume(key, arg) {
      try {
        var result = gen[key](arg);
        var value = result.value;
        var wrappedAwait = value instanceof _AwaitValue;
        Promise.resolve(wrappedAwait ? value.wrapped : value).then(
          function(arg) {
            if (wrappedAwait) {
              resume('next', arg);
              return;
            }

            settle(result.done ? 'return' : 'normal', arg);
          },
          function(err) {
            resume('throw', err);
          }
        );
      } catch (err) {
        settle('throw', err);
      }
    }

    function settle(type, value) {
      switch (type) {
        case 'return':
          front.resolve({
            value: value,
            done: true
          });
          break;

        case 'throw':
          front.reject(value);
          break;

        default:
          front.resolve({
            value: value,
            done: false
          });
          break;
      }

      front = front.next;

      if (front) {
        resume(front.key, front.arg);
      } else {
        back = null;
      }
    }

    this._invoke = send;

    if (typeof gen.return !== 'function') {
      this.return = undefined;
    }
  }

  if (typeof Symbol === 'function' && Symbol.asyncIterator) {
    _AsyncGenerator.prototype[Symbol.asyncIterator] = function() {
      return this;
    };
  }

  _AsyncGenerator.prototype.next = function(arg) {
    return this._invoke('next', arg);
  };

  _AsyncGenerator.prototype.throw = function(arg) {
    return this._invoke('throw', arg);
  };

  _AsyncGenerator.prototype.return = function(arg) {
    return this._invoke('return', arg);
  };

  function _wrapAsyncGenerator(fn) {
    return function() {
      return new _AsyncGenerator(fn.apply(this, arguments));
    };
  }

  function _awaitAsyncGenerator(value) {
    return new _AwaitValue(value);
  }

  function _asyncGeneratorDelegate(inner, awaitWrap) {
    var iter = {},
      waiting = false;

    function pump(key, value) {
      waiting = true;
      value = new Promise(function(resolve) {
        resolve(inner[key](value));
      });
      return {
        done: false,
        value: awaitWrap(value)
      };
    }

    if (typeof Symbol === 'function' && Symbol.iterator) {
      iter[Symbol.iterator] = function() {
        return this;
      };
    }

    iter.next = function(value) {
      if (waiting) {
        waiting = false;
        return value;
      }

      return pump('next', value);
    };

    if (typeof inner.throw === 'function') {
      iter.throw = function(value) {
        if (waiting) {
          waiting = false;
          throw value;
        }

        return pump('throw', value);
      };
    }

    if (typeof inner.return === 'function') {
      iter.return = function(value) {
        return pump('return', value);
      };
    }

    return iter;
  }

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function() {
      var self = this,
        args = arguments;
      return new Promise(function(resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(
            gen,
            resolve,
            reject,
            _next,
            _throw,
            'next',
            value
          );
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'throw', err);
        }

        _next(undefined);
      });
    };
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError('Cannot call a class as a function');
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ('value' in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _defineEnumerableProperties(obj, descs) {
    for (var key in descs) {
      var desc = descs[key];
      desc.configurable = desc.enumerable = true;
      if ('value' in desc) desc.writable = true;
      Object.defineProperty(obj, key, desc);
    }

    if (Object.getOwnPropertySymbols) {
      var objectSymbols = Object.getOwnPropertySymbols(descs);

      for (var i = 0; i < objectSymbols.length; i++) {
        var sym = objectSymbols[i];
        var desc = descs[sym];
        desc.configurable = desc.enumerable = true;
        if ('value' in desc) desc.writable = true;
        Object.defineProperty(obj, sym, desc);
      }
    }

    return obj;
  }

  function _defaults(obj, defaults) {
    var keys = Object.getOwnPropertyNames(defaults);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      var value = Object.getOwnPropertyDescriptor(defaults, key);

      if (value && value.configurable && obj[key] === undefined) {
        Object.defineProperty(obj, key, value);
      }
    }

    return obj;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _extends() {
    _extends =
      Object.assign ||
      function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];

          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }

        return target;
      };

    return _extends.apply(this, arguments);
  }

  function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      var ownKeys = Object.keys(source);

      if (typeof Object.getOwnPropertySymbols === 'function') {
        ownKeys = ownKeys.concat(
          Object.getOwnPropertySymbols(source).filter(function(sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
          })
        );
      }

      ownKeys.forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    }

    return target;
  }

  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};

      if (i % 2) {
        ownKeys(source, true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(
          target,
          Object.getOwnPropertyDescriptors(source)
        );
      } else {
        ownKeys(source).forEach(function(key) {
          Object.defineProperty(
            target,
            key,
            Object.getOwnPropertyDescriptor(source, key)
          );
        });
      }
    }

    return target;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== 'function' && superClass !== null) {
      throw new TypeError('Super expression must either be null or a function');
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf
      ? Object.getPrototypeOf
      : function _getPrototypeOf(o) {
          return o.__proto__ || Object.getPrototypeOf(o);
        };
    return _getPrototypeOf(o);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf =
      Object.setPrototypeOf ||
      function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };

    return _setPrototypeOf(o, p);
  }

  function isNativeReflectConstruct() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === 'function') return true;

    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function() {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _construct(Parent, args, Class) {
    if (isNativeReflectConstruct()) {
      _construct = Reflect.construct;
    } else {
      _construct = function _construct(Parent, args, Class) {
        var a = [null];
        a.push.apply(a, args);
        var Constructor = Function.bind.apply(Parent, a);
        var instance = new Constructor();
        if (Class) _setPrototypeOf(instance, Class.prototype);
        return instance;
      };
    }

    return _construct.apply(null, arguments);
  }

  function _isNativeFunction(fn) {
    return Function.toString.call(fn).indexOf('[native code]') !== -1;
  }

  function _wrapNativeSuper(Class) {
    var _cache = typeof Map === 'function' ? new Map() : undefined;

    _wrapNativeSuper = function _wrapNativeSuper(Class) {
      if (Class === null || !_isNativeFunction(Class)) return Class;

      if (typeof Class !== 'function') {
        throw new TypeError(
          'Super expression must either be null or a function'
        );
      }

      if (typeof _cache !== 'undefined') {
        if (_cache.has(Class)) return _cache.get(Class);

        _cache.set(Class, Wrapper);
      }

      function Wrapper() {
        return _construct(Class, arguments, _getPrototypeOf(this).constructor);
      }

      Wrapper.prototype = Object.create(Class.prototype, {
        constructor: {
          value: Wrapper,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      return _setPrototypeOf(Wrapper, Class);
    };

    return _wrapNativeSuper(Class);
  }

  function _instanceof(left, right) {
    if (
      right != null &&
      typeof Symbol !== 'undefined' &&
      right[Symbol.hasInstance]
    ) {
      return !!right[Symbol.hasInstance](left);
    } else {
      return left instanceof right;
    }
  }

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule
      ? obj
      : {
          default: obj
        };
  }

  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};

      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc =
              Object.defineProperty && Object.getOwnPropertyDescriptor
                ? Object.getOwnPropertyDescriptor(obj, key)
                : {};

            if (desc.get || desc.set) {
              Object.defineProperty(newObj, key, desc);
            } else {
              newObj[key] = obj[key];
            }
          }
        }
      }

      newObj.default = obj;
      return newObj;
    }
  }

  function _newArrowCheck(innerThis, boundThis) {
    if (innerThis !== boundThis) {
      throw new TypeError('Cannot instantiate an arrow function');
    }
  }

  function _objectDestructuringEmpty(obj) {
    if (obj == null) throw new TypeError('Cannot destructure undefined');
  }

  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    return target;
  }

  function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};

    var target = _objectWithoutPropertiesLoose(source, excluded);

    var key, i;

    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
        target[key] = source[key];
      }
    }

    return target;
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError(
        "this hasn't been initialised - super() hasn't been called"
      );
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === 'object' || typeof call === 'function')) {
      return call;
    }

    return _assertThisInitialized(self);
  }

  function _superPropBase(object, property) {
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
      object = _getPrototypeOf(object);
      if (object === null) break;
    }

    return object;
  }

  function _get(target, property, receiver) {
    if (typeof Reflect !== 'undefined' && Reflect.get) {
      _get = Reflect.get;
    } else {
      _get = function _get(target, property, receiver) {
        var base = _superPropBase(target, property);

        if (!base) return;
        var desc = Object.getOwnPropertyDescriptor(base, property);

        if (desc.get) {
          return desc.get.call(receiver);
        }

        return desc.value;
      };
    }

    return _get(target, property, receiver || target);
  }

  function set(target, property, value, receiver) {
    if (typeof Reflect !== 'undefined' && Reflect.set) {
      set = Reflect.set;
    } else {
      set = function set(target, property, value, receiver) {
        var base = _superPropBase(target, property);

        var desc;

        if (base) {
          desc = Object.getOwnPropertyDescriptor(base, property);

          if (desc.set) {
            desc.set.call(receiver, value);
            return true;
          } else if (!desc.writable) {
            return false;
          }
        }

        desc = Object.getOwnPropertyDescriptor(receiver, property);

        if (desc) {
          if (!desc.writable) {
            return false;
          }

          desc.value = value;
          Object.defineProperty(receiver, property, desc);
        } else {
          _defineProperty(receiver, property, value);
        }

        return true;
      };
    }

    return set(target, property, value, receiver);
  }

  function _set(target, property, value, receiver, isStrict) {
    var s = set(target, property, value, receiver || target);

    if (!s && isStrict) {
      throw new Error('failed to set property');
    }

    return value;
  }

  function _taggedTemplateLiteral(strings, raw) {
    if (!raw) {
      raw = strings.slice(0);
    }

    return Object.freeze(
      Object.defineProperties(strings, {
        raw: {
          value: Object.freeze(raw)
        }
      })
    );
  }

  function _taggedTemplateLiteralLoose(strings, raw) {
    if (!raw) {
      raw = strings.slice(0);
    }

    strings.raw = raw;
    return strings;
  }

  function _temporalRef(val, name) {
    if (val === _temporalUndefined) {
      throw new ReferenceError(name + ' is not defined - temporal dead zone');
    } else {
      return val;
    }
  }

  function _readOnlyError(name) {
    throw new Error('"' + name + '" is read-only');
  }

  function _classNameTDZError(name) {
    throw new Error(
      'Class "' + name + '" cannot be referenced in computed property keys.'
    );
  }

  var _temporalUndefined = {};

  function _slicedToArray(arr, i) {
    return (
      _arrayWithHoles(arr) ||
      _iterableToArrayLimit(arr, i) ||
      _nonIterableRest()
    );
  }

  function _slicedToArrayLoose(arr, i) {
    return (
      _arrayWithHoles(arr) ||
      _iterableToArrayLimitLoose(arr, i) ||
      _nonIterableRest()
    );
  }

  function _toArray(arr) {
    return _arrayWithHoles(arr) || _iterableToArray(arr) || _nonIterableRest();
  }

  function _toConsumableArray(arr) {
    return (
      _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread()
    );
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++)
        arr2[i] = arr[i];

      return arr2;
    }
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArray(iter) {
    if (
      Symbol.iterator in Object(iter) ||
      Object.prototype.toString.call(iter) === '[object Arguments]'
    )
      return Array.from(iter);
  }

  function _iterableToArrayLimit(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (
        var _i = arr[Symbol.iterator](), _s;
        !(_n = (_s = _i.next()).done);
        _n = true
      ) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i['return'] != null) _i['return']();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _iterableToArrayLimitLoose(arr, i) {
    var _arr = [];

    for (
      var _iterator = arr[Symbol.iterator](), _step;
      !(_step = _iterator.next()).done;

    ) {
      _arr.push(_step.value);

      if (i && _arr.length === i) break;
    }

    return _arr;
  }

  function _nonIterableSpread() {
    throw new TypeError('Invalid attempt to spread non-iterable instance');
  }

  function _nonIterableRest() {
    throw new TypeError('Invalid attempt to destructure non-iterable instance');
  }

  function _skipFirstGeneratorNext(fn) {
    return function() {
      var it = fn.apply(this, arguments);
      it.next();
      return it;
    };
  }

  function _toPrimitive(input, hint) {
    if (typeof input !== 'object' || input === null) return input;
    var prim = input[Symbol.toPrimitive];

    if (prim !== undefined) {
      var res = prim.call(input, hint || 'default');
      if (typeof res !== 'object') return res;
      throw new TypeError('@@toPrimitive must return a primitive value.');
    }

    return (hint === 'string' ? String : Number)(input);
  }

  function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, 'string');

    return typeof key === 'symbol' ? key : String(key);
  }

  function _initializerWarningHelper(descriptor, context) {
    throw new Error(
      'Decorating class property failed. Please ensure that ' +
        'proposal-class-properties is enabled and set to use loose mode. ' +
        'To use proposal-class-properties in spec mode with decorators, wait for ' +
        'the next major version of decorators in stage 2.'
    );
  }

  function _initializerDefineProperty(target, property, descriptor, context) {
    if (!descriptor) return;
    Object.defineProperty(target, property, {
      enumerable: descriptor.enumerable,
      configurable: descriptor.configurable,
      writable: descriptor.writable,
      value: descriptor.initializer
        ? descriptor.initializer.call(context)
        : void 0
    });
  }

  function _applyDecoratedDescriptor(
    target,
    property,
    decorators,
    descriptor,
    context
  ) {
    var desc = {};
    Object.keys(descriptor).forEach(function(key) {
      desc[key] = descriptor[key];
    });
    desc.enumerable = !!desc.enumerable;
    desc.configurable = !!desc.configurable;

    if ('value' in desc || desc.initializer) {
      desc.writable = true;
    }

    desc = decorators
      .slice()
      .reverse()
      .reduce(function(desc, decorator) {
        return decorator(target, property, desc) || desc;
      }, desc);

    if (context && desc.initializer !== void 0) {
      desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
      desc.initializer = undefined;
    }

    if (desc.initializer === void 0) {
      Object.defineProperty(target, property, desc);
      desc = null;
    }

    return desc;
  }

  var id = 0;

  function _classPrivateFieldLooseKey(name) {
    return '__private_' + id++ + '_' + name;
  }

  function _classPrivateFieldLooseBase(receiver, privateKey) {
    if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
      throw new TypeError('attempted to use private field on non-instance');
    }

    return receiver;
  }

  function _classPrivateFieldGet(receiver, privateMap) {
    var descriptor = privateMap.get(receiver);

    if (!descriptor) {
      throw new TypeError('attempted to get private field on non-instance');
    }

    if (descriptor.get) {
      return descriptor.get.call(receiver);
    }

    return descriptor.value;
  }

  function _classPrivateFieldSet(receiver, privateMap, value) {
    var descriptor = privateMap.get(receiver);

    if (!descriptor) {
      throw new TypeError('attempted to set private field on non-instance');
    }

    if (descriptor.set) {
      descriptor.set.call(receiver, value);
    } else {
      if (!descriptor.writable) {
        throw new TypeError('attempted to set read only private field');
      }

      descriptor.value = value;
    }

    return value;
  }

  function _classPrivateFieldDestructureSet(receiver, privateMap) {
    if (!privateMap.has(receiver)) {
      throw new TypeError('attempted to set private field on non-instance');
    }

    var descriptor = privateMap.get(receiver);

    if (descriptor.set) {
      if (!('__destrObj' in descriptor)) {
        descriptor.__destrObj = {
          set value(v) {
            descriptor.set.call(receiver, v);
          }
        };
      }

      return descriptor.__destrObj;
    } else {
      if (!descriptor.writable) {
        throw new TypeError('attempted to set read only private field');
      }

      return descriptor;
    }
  }

  function _classStaticPrivateFieldSpecGet(
    receiver,
    classConstructor,
    descriptor
  ) {
    if (receiver !== classConstructor) {
      throw new TypeError('Private static access of wrong provenance');
    }

    return descriptor.value;
  }

  function _classStaticPrivateFieldSpecSet(
    receiver,
    classConstructor,
    descriptor,
    value
  ) {
    if (receiver !== classConstructor) {
      throw new TypeError('Private static access of wrong provenance');
    }

    if (!descriptor.writable) {
      throw new TypeError('attempted to set read only private field');
    }

    descriptor.value = value;
    return value;
  }

  function _classStaticPrivateMethodGet(receiver, classConstructor, method) {
    if (receiver !== classConstructor) {
      throw new TypeError('Private static access of wrong provenance');
    }

    return method;
  }

  function _classStaticPrivateMethodSet() {
    throw new TypeError('attempted to set read only static private field');
  }

  function _decorate(decorators, factory, superClass, mixins) {
    var api = _getDecoratorsApi();

    if (mixins) {
      for (var i = 0; i < mixins.length; i++) {
        api = mixins[i](api);
      }
    }

    var r = factory(function initialize(O) {
      api.initializeInstanceElements(O, decorated.elements);
    }, superClass);
    var decorated = api.decorateClass(
      _coalesceClassElements(r.d.map(_createElementDescriptor)),
      decorators
    );
    api.initializeClassElements(r.F, decorated.elements);
    return api.runClassFinishers(r.F, decorated.finishers);
  }

  function _getDecoratorsApi() {
    _getDecoratorsApi = function() {
      return api;
    };

    var api = {
      elementsDefinitionOrder: [['method'], ['field']],
      initializeInstanceElements: function(O, elements) {
        ['method', 'field'].forEach(function(kind) {
          elements.forEach(function(element) {
            if (element.kind === kind && element.placement === 'own') {
              this.defineClassElement(O, element);
            }
          }, this);
        }, this);
      },
      initializeClassElements: function(F, elements) {
        var proto = F.prototype;
        ['method', 'field'].forEach(function(kind) {
          elements.forEach(function(element) {
            var placement = element.placement;

            if (
              element.kind === kind &&
              (placement === 'static' || placement === 'prototype')
            ) {
              var receiver = placement === 'static' ? F : proto;
              this.defineClassElement(receiver, element);
            }
          }, this);
        }, this);
      },
      defineClassElement: function(receiver, element) {
        var descriptor = element.descriptor;

        if (element.kind === 'field') {
          var initializer = element.initializer;
          descriptor = {
            enumerable: descriptor.enumerable,
            writable: descriptor.writable,
            configurable: descriptor.configurable,
            value: initializer === void 0 ? void 0 : initializer.call(receiver)
          };
        }

        Object.defineProperty(receiver, element.key, descriptor);
      },
      decorateClass: function(elements, decorators) {
        var newElements = [];
        var finishers = [];
        var placements = {
          static: [],
          prototype: [],
          own: []
        };
        elements.forEach(function(element) {
          this.addElementPlacement(element, placements);
        }, this);
        elements.forEach(function(element) {
          if (!_hasDecorators(element)) return newElements.push(element);
          var elementFinishersExtras = this.decorateElement(
            element,
            placements
          );
          newElements.push(elementFinishersExtras.element);
          newElements.push.apply(newElements, elementFinishersExtras.extras);
          finishers.push.apply(finishers, elementFinishersExtras.finishers);
        }, this);

        if (!decorators) {
          return {
            elements: newElements,
            finishers: finishers
          };
        }

        var result = this.decorateConstructor(newElements, decorators);
        finishers.push.apply(finishers, result.finishers);
        result.finishers = finishers;
        return result;
      },
      addElementPlacement: function(element, placements, silent) {
        var keys = placements[element.placement];

        if (!silent && keys.indexOf(element.key) !== -1) {
          throw new TypeError('Duplicated element (' + element.key + ')');
        }

        keys.push(element.key);
      },
      decorateElement: function(element, placements) {
        var extras = [];
        var finishers = [];

        for (
          var decorators = element.decorators, i = decorators.length - 1;
          i >= 0;
          i--
        ) {
          var keys = placements[element.placement];
          keys.splice(keys.indexOf(element.key), 1);
          var elementObject = this.fromElementDescriptor(element);
          var elementFinisherExtras = this.toElementFinisherExtras(
            (0, decorators[i])(elementObject) || elementObject
          );
          element = elementFinisherExtras.element;
          this.addElementPlacement(element, placements);

          if (elementFinisherExtras.finisher) {
            finishers.push(elementFinisherExtras.finisher);
          }

          var newExtras = elementFinisherExtras.extras;

          if (newExtras) {
            for (var j = 0; j < newExtras.length; j++) {
              this.addElementPlacement(newExtras[j], placements);
            }

            extras.push.apply(extras, newExtras);
          }
        }

        return {
          element: element,
          finishers: finishers,
          extras: extras
        };
      },
      decorateConstructor: function(elements, decorators) {
        var finishers = [];

        for (var i = decorators.length - 1; i >= 0; i--) {
          var obj = this.fromClassDescriptor(elements);
          var elementsAndFinisher = this.toClassDescriptor(
            (0, decorators[i])(obj) || obj
          );

          if (elementsAndFinisher.finisher !== undefined) {
            finishers.push(elementsAndFinisher.finisher);
          }

          if (elementsAndFinisher.elements !== undefined) {
            elements = elementsAndFinisher.elements;

            for (var j = 0; j < elements.length - 1; j++) {
              for (var k = j + 1; k < elements.length; k++) {
                if (
                  elements[j].key === elements[k].key &&
                  elements[j].placement === elements[k].placement
                ) {
                  throw new TypeError(
                    'Duplicated element (' + elements[j].key + ')'
                  );
                }
              }
            }
          }
        }

        return {
          elements: elements,
          finishers: finishers
        };
      },
      fromElementDescriptor: function(element) {
        var obj = {
          kind: element.kind,
          key: element.key,
          placement: element.placement,
          descriptor: element.descriptor
        };
        var desc = {
          value: 'Descriptor',
          configurable: true
        };
        Object.defineProperty(obj, Symbol.toStringTag, desc);
        if (element.kind === 'field') obj.initializer = element.initializer;
        return obj;
      },
      toElementDescriptors: function(elementObjects) {
        if (elementObjects === undefined) return;
        return _toArray(elementObjects).map(function(elementObject) {
          var element = this.toElementDescriptor(elementObject);
          this.disallowProperty(
            elementObject,
            'finisher',
            'An element descriptor'
          );
          this.disallowProperty(
            elementObject,
            'extras',
            'An element descriptor'
          );
          return element;
        }, this);
      },
      toElementDescriptor: function(elementObject) {
        var kind = String(elementObject.kind);

        if (kind !== 'method' && kind !== 'field') {
          throw new TypeError(
            'An element descriptor\'s .kind property must be either "method" or' +
              ' "field", but a decorator created an element descriptor with' +
              ' .kind "' +
              kind +
              '"'
          );
        }

        var key = _toPropertyKey(elementObject.key);

        var placement = String(elementObject.placement);

        if (
          placement !== 'static' &&
          placement !== 'prototype' &&
          placement !== 'own'
        ) {
          throw new TypeError(
            'An element descriptor\'s .placement property must be one of "static",' +
              ' "prototype" or "own", but a decorator created an element descriptor' +
              ' with .placement "' +
              placement +
              '"'
          );
        }

        var descriptor = elementObject.descriptor;
        this.disallowProperty(
          elementObject,
          'elements',
          'An element descriptor'
        );
        var element = {
          kind: kind,
          key: key,
          placement: placement,
          descriptor: Object.assign({}, descriptor)
        };

        if (kind !== 'field') {
          this.disallowProperty(
            elementObject,
            'initializer',
            'A method descriptor'
          );
        } else {
          this.disallowProperty(
            descriptor,
            'get',
            'The property descriptor of a field descriptor'
          );
          this.disallowProperty(
            descriptor,
            'set',
            'The property descriptor of a field descriptor'
          );
          this.disallowProperty(
            descriptor,
            'value',
            'The property descriptor of a field descriptor'
          );
          element.initializer = elementObject.initializer;
        }

        return element;
      },
      toElementFinisherExtras: function(elementObject) {
        var element = this.toElementDescriptor(elementObject);

        var finisher = _optionalCallableProperty(elementObject, 'finisher');

        var extras = this.toElementDescriptors(elementObject.extras);
        return {
          element: element,
          finisher: finisher,
          extras: extras
        };
      },
      fromClassDescriptor: function(elements) {
        var obj = {
          kind: 'class',
          elements: elements.map(this.fromElementDescriptor, this)
        };
        var desc = {
          value: 'Descriptor',
          configurable: true
        };
        Object.defineProperty(obj, Symbol.toStringTag, desc);
        return obj;
      },
      toClassDescriptor: function(obj) {
        var kind = String(obj.kind);

        if (kind !== 'class') {
          throw new TypeError(
            'A class descriptor\'s .kind property must be "class", but a decorator' +
              ' created a class descriptor with .kind "' +
              kind +
              '"'
          );
        }

        this.disallowProperty(obj, 'key', 'A class descriptor');
        this.disallowProperty(obj, 'placement', 'A class descriptor');
        this.disallowProperty(obj, 'descriptor', 'A class descriptor');
        this.disallowProperty(obj, 'initializer', 'A class descriptor');
        this.disallowProperty(obj, 'extras', 'A class descriptor');

        var finisher = _optionalCallableProperty(obj, 'finisher');

        var elements = this.toElementDescriptors(obj.elements);
        return {
          elements: elements,
          finisher: finisher
        };
      },
      runClassFinishers: function(constructor, finishers) {
        for (var i = 0; i < finishers.length; i++) {
          var newConstructor = (0, finishers[i])(constructor);

          if (newConstructor !== undefined) {
            if (typeof newConstructor !== 'function') {
              throw new TypeError('Finishers must return a constructor.');
            }

            constructor = newConstructor;
          }
        }

        return constructor;
      },
      disallowProperty: function(obj, name, objectType) {
        if (obj[name] !== undefined) {
          throw new TypeError(
            objectType + " can't have a ." + name + ' property.'
          );
        }
      }
    };
    return api;
  }

  function _createElementDescriptor(def) {
    var key = _toPropertyKey(def.key);

    var descriptor;

    if (def.kind === 'method') {
      descriptor = {
        value: def.value,
        writable: true,
        configurable: true,
        enumerable: false
      };
    } else if (def.kind === 'get') {
      descriptor = {
        get: def.value,
        configurable: true,
        enumerable: false
      };
    } else if (def.kind === 'set') {
      descriptor = {
        set: def.value,
        configurable: true,
        enumerable: false
      };
    } else if (def.kind === 'field') {
      descriptor = {
        configurable: true,
        writable: true,
        enumerable: true
      };
    }

    var element = {
      kind: def.kind === 'field' ? 'field' : 'method',
      key: key,
      placement: def.static
        ? 'static'
        : def.kind === 'field'
        ? 'own'
        : 'prototype',
      descriptor: descriptor
    };
    if (def.decorators) element.decorators = def.decorators;
    if (def.kind === 'field') element.initializer = def.value;
    return element;
  }

  function _coalesceGetterSetter(element, other) {
    if (element.descriptor.get !== undefined) {
      other.descriptor.get = element.descriptor.get;
    } else {
      other.descriptor.set = element.descriptor.set;
    }
  }

  function _coalesceClassElements(elements) {
    var newElements = [];

    var isSameElement = function(other) {
      return (
        other.kind === 'method' &&
        other.key === element.key &&
        other.placement === element.placement
      );
    };

    for (var i = 0; i < elements.length; i++) {
      var element = elements[i];
      var other;

      if (
        element.kind === 'method' &&
        (other = newElements.find(isSameElement))
      ) {
        if (
          _isDataDescriptor(element.descriptor) ||
          _isDataDescriptor(other.descriptor)
        ) {
          if (_hasDecorators(element) || _hasDecorators(other)) {
            throw new ReferenceError(
              'Duplicated methods (' + element.key + ") can't be decorated."
            );
          }

          other.descriptor = element.descriptor;
        } else {
          if (_hasDecorators(element)) {
            if (_hasDecorators(other)) {
              throw new ReferenceError(
                "Decorators can't be placed on different accessors with for " +
                  'the same property (' +
                  element.key +
                  ').'
              );
            }

            other.decorators = element.decorators;
          }

          _coalesceGetterSetter(element, other);
        }
      } else {
        newElements.push(element);
      }
    }

    return newElements;
  }

  function _hasDecorators(element) {
    return element.decorators && element.decorators.length;
  }

  function _isDataDescriptor(desc) {
    return (
      desc !== undefined &&
      !(desc.value === undefined && desc.writable === undefined)
    );
  }

  function _optionalCallableProperty(obj, name) {
    var value = obj[name];

    if (value !== undefined && typeof value !== 'function') {
      throw new TypeError("Expected '" + name + "' to be a function");
    }

    return value;
  }

  function _classPrivateMethodGet(receiver, privateSet, fn) {
    if (!privateSet.has(receiver)) {
      throw new TypeError('attempted to get private field on non-instance');
    }

    return fn;
  }

  function _classPrivateMethodSet() {
    throw new TypeError('attempted to reassign private method');
  }

  function _wrapRegExp(re, groups) {
    _wrapRegExp = function(re, groups) {
      return new BabelRegExp(re, groups);
    };

    var _RegExp = _wrapNativeSuper(RegExp);

    var _super = RegExp.prototype;

    var _groups = new WeakMap();

    function BabelRegExp(re, groups) {
      var _this = _RegExp.call(this, re);

      _groups.set(_this, groups);

      return _this;
    }

    _inherits(BabelRegExp, _RegExp);

    BabelRegExp.prototype.exec = function(str) {
      var result = _super.exec.call(this, str);

      if (result) result.groups = buildGroups(result, this);
      return result;
    };

    BabelRegExp.prototype[Symbol.replace] = function(str, substitution) {
      if (typeof substitution === 'string') {
        var groups = _groups.get(this);

        return _super[Symbol.replace].call(
          this,
          str,
          substitution.replace(/\$<([^>]+)>/g, function(_, name) {
            return '$' + groups[name];
          })
        );
      } else if (typeof substitution === 'function') {
        var _this = this;

        return _super[Symbol.replace].call(this, str, function() {
          var args = [];
          args.push.apply(args, arguments);

          if (typeof args[args.length - 1] !== 'object') {
            args.push(buildGroups(args, _this));
          }

          return substitution.apply(this, args);
        });
      } else {
        return _super[Symbol.replace].call(this, str, substitution);
      }
    };

    function buildGroups(result, re) {
      var g = _groups.get(re);

      return Object.keys(g).reduce(function(groups, name) {
        groups[name] = result[g[name]];
        return groups;
      }, Object.create(null));
    }

    return _wrapRegExp.apply(this, arguments);
  }

  var arrayRemove = function arrayRemove(arr, index) {
    return arr.splice(index, 1);
  };

  var run = function run(cb, sync) {
    if (sync) {
      cb();
    } else if (document.hidden) {
      Promise.resolve(1).then(cb);
    } else {
      setTimeout(cb, 0);
    }
  };

  var on = function on() {
    var listeners = [];
    var off = function off(event, cb) {
      arrayRemove(
        listeners,
        listeners.findIndex(function(listener) {
          return listener.event === event && (listener.cb === cb || !cb);
        })
      );
    };
    var _fire = function fire(event, args, sync) {
      listeners
        .filter(function(listener) {
          return listener.event === event;
        })
        .map(function(listener) {
          return listener.cb;
        })
        .forEach(function(cb) {
          return run(function() {
            return cb.apply(void 0, _toConsumableArray(args));
          }, sync);
        });
    };
    return {
      fireSync: function fireSync(event) {
        for (
          var _len = arguments.length,
            args = new Array(_len > 1 ? _len - 1 : 0),
            _key = 1;
          _key < _len;
          _key++
        ) {
          args[_key - 1] = arguments[_key];
        }
        _fire(event, args, true);
      },
      fire: function fire(event) {
        for (
          var _len2 = arguments.length,
            args = new Array(_len2 > 1 ? _len2 - 1 : 0),
            _key2 = 1;
          _key2 < _len2;
          _key2++
        ) {
          args[_key2 - 1] = arguments[_key2];
        }
        _fire(event, args, false);
      },
      on: function on(event, cb) {
        listeners.push({ event: event, cb: cb });
      },
      onOnce: function onOnce(event, _cb) {
        listeners.push({
          event: event,
          cb: function cb() {
            off(event, _cb);
            _cb.apply(void 0, arguments);
          }
        });
      },
      off: off
    };
  };

  var copyObjectPropertiesToObject = function copyObjectPropertiesToObject(
    src,
    target,
    excluded
  ) {
    Object.getOwnPropertyNames(src)
      .filter(function(property) {
        return !excluded.includes(property);
      })
      .forEach(function(key) {
        return Object.defineProperty(
          target,
          key,
          Object.getOwnPropertyDescriptor(src, key)
        );
      });
  };

  var PRIVATE = [
    'fire',
    'process',
    'revert',
    'load',
    'on',
    'off',
    'onOnce',
    'retryLoad',
    'extend',
    'archive',
    'archived',
    'release',
    'released',
    'requestProcessing',
    'freeze'
  ];

  var createItemAPI = function createItemAPI(item) {
    var api = {};
    copyObjectPropertiesToObject(item, api, PRIVATE);
    return api;
  };

  var removeReleasedItems = function removeReleasedItems(items) {
    items.forEach(function(item, index) {
      if (item.released) {
        arrayRemove(items, index);
      }
    });
  };

  var ItemStatus = {
    INIT: 1,
    IDLE: 2,
    PROCESSING_QUEUED: 9,
    PROCESSING: 3,
    PROCESSING_COMPLETE: 5,
    PROCESSING_ERROR: 6,
    PROCESSING_REVERT_ERROR: 10,
    LOADING: 7,
    LOAD_ERROR: 8
  };

  var FileOrigin = {
    INPUT: 1,
    LIMBO: 2,
    LOCAL: 3
  };

  var getNonNumeric = function getNonNumeric(str) {
    return /[^0-9]+/.exec(str);
  };

  var getDecimalSeparator = function getDecimalSeparator() {
    return getNonNumeric((1.1).toLocaleString())[0];
  };

  var getThousandsSeparator = function getThousandsSeparator() {
    // Added for browsers that do not return the thousands separator (happend on native browser Android 4.4.4)
    // We check against the normal toString output and if they're the same return a comma when decimal separator is a dot
    var decimalSeparator = getDecimalSeparator();
    var thousandsStringWithSeparator = (1000.0).toLocaleString();
    var thousandsStringWithoutSeparator = (1000.0).toString();
    if (thousandsStringWithSeparator !== thousandsStringWithoutSeparator) {
      return getNonNumeric(thousandsStringWithSeparator)[0];
    }
    return decimalSeparator === '.' ? ',' : '.';
  };

  var Type = {
    BOOLEAN: 'boolean',
    INT: 'int',
    NUMBER: 'number',
    STRING: 'string',
    ARRAY: 'array',
    OBJECT: 'object',
    FUNCTION: 'function',
    ACTION: 'action',
    SERVER_API: 'serverapi',
    REGEX: 'regex'
  };

  // all registered filters
  var filters = [];

  // loops over matching filters and passes options to each filter, returning the mapped results
  var applyFilterChain = function applyFilterChain(key, value, utils) {
    return new Promise(function(resolve, reject) {
      // find matching filters for this key
      var matchingFilters = filters
        .filter(function(f) {
          return f.key === key;
        })
        .map(function(f) {
          return f.cb;
        });

      // resolve now
      if (matchingFilters.length === 0) {
        resolve(value);
        return;
      }

      // first filter to kick things of
      var initialFilter = matchingFilters.shift();

      // chain filters
      matchingFilters
        .reduce(
          // loop over promises passing value to next promise
          function(current, next) {
            return current.then(function(value) {
              return next(value, utils);
            });
          },

          // call initial filter, will return a promise
          initialFilter(value, utils)

          // all executed
        )
        .then(function(value) {
          return resolve(value);
        })
        .catch(function(error) {
          return reject(error);
        });
    });
  };

  var applyFilters = function applyFilters(key, value, utils) {
    return filters
      .filter(function(f) {
        return f.key === key;
      })
      .map(function(f) {
        return f.cb(value, utils);
      });
  };

  // adds a new filter to the list
  var addFilter = function addFilter(key, cb) {
    return filters.push({ key: key, cb: cb });
  };

  var extendDefaultOptions = function extendDefaultOptions(additionalOptions) {
    return Object.assign(defaultOptions, additionalOptions);
  };

  var getOptions = function getOptions() {
    return Object.assign({}, defaultOptions);
  };

  var setOptions = function setOptions(opts) {
    forin(opts, function(key, value) {
      // key does not exist, so this option cannot be set
      if (!defaultOptions[key]) {
        return;
      }
      defaultOptions[key][0] = getValueByType(
        value,
        defaultOptions[key][0],
        defaultOptions[key][1]
      );
    });
  };

  // default options on app
  var defaultOptions = {
    // the id to add to the root element
    id: [null, Type.STRING],

    // input field name to use
    name: ['filepond', Type.STRING],

    // disable the field
    disabled: [false, Type.BOOLEAN],

    // classname to put on wrapper
    className: [null, Type.STRING],

    // is the field required
    required: [false, Type.BOOLEAN],

    // Allow media capture when value is set
    captureMethod: [null, Type.STRING],
    // - "camera", "microphone" or "camcorder",
    // - Does not work with multiple on apple devices
    // - If set, acceptedFileTypes must be made to match with media wildcard "image/*", "audio/*" or "video/*"

    // sync `acceptedFileTypes` property with `accept` attribute
    allowSyncAcceptAttribute: [true, Type.BOOLEAN],

    // Feature toggles
    allowDrop: [true, Type.BOOLEAN], // Allow dropping of files
    allowBrowse: [true, Type.BOOLEAN], // Allow browsing the file system
    allowPaste: [true, Type.BOOLEAN], // Allow pasting files
    allowMultiple: [false, Type.BOOLEAN], // Allow multiple files (disabled by default, as multiple attribute is also required on input to allow multiple)
    allowReplace: [true, Type.BOOLEAN], // Allow dropping a file on other file to replace it (only works when multiple is set to false)
    allowRevert: [true, Type.BOOLEAN], // Allows user to revert file upload
    allowRemove: [true, Type.BOOLEAN], // Allow user to remove a file
    allowProcess: [true, Type.BOOLEAN], // Allows user to process a file, when set to false, this removes the file upload button
    allowReorder: [false, Type.BOOLEAN], // Allow reordering of files
    allowDirectoriesOnly: [false, Type.BOOLEAN], // Allow only selecting directories with browse (no support for filtering dnd at this point)

    // Revert mode
    forceRevert: [false, Type.BOOLEAN], // Set to 'force' to require the file to be reverted before removal

    // Input requirements
    maxFiles: [null, Type.INT], // Max number of files
    checkValidity: [false, Type.BOOLEAN], // Enables custom validity messages

    // Where to put file
    itemInsertLocationFreedom: [true, Type.BOOLEAN], // Set to false to always add items to begin or end of list
    itemInsertLocation: ['before', Type.STRING], // Default index in list to add items that have been dropped at the top of the list
    itemInsertInterval: [75, Type.INT],

    // Drag 'n Drop related
    dropOnPage: [false, Type.BOOLEAN], // Allow dropping of files anywhere on page (prevents browser from opening file if dropped outside of Up)
    dropOnElement: [true, Type.BOOLEAN], // Drop needs to happen on element (set to false to also load drops outside of Up)
    dropValidation: [false, Type.BOOLEAN], // Enable or disable validating files on drop
    ignoredFiles: [['.ds_store', 'thumbs.db', 'desktop.ini'], Type.ARRAY],

    // Upload related
    instantUpload: [true, Type.BOOLEAN], // Should upload files immediately on drop
    maxParallelUploads: [2, Type.INT], // Maximum files to upload in parallel

    // Chunks
    chunkUploads: [false, Type.BOOLEAN], // Enable chunked uploads
    chunkForce: [false, Type.BOOLEAN], // Force use of chunk uploads even for files smaller than chunk size
    chunkSize: [5000000, Type.INT], // Size of chunks (5MB default)
    chunkRetryDelays: [[500, 1000, 3000], Type.Array], // Amount of times to retry upload of a chunk when it fails

    // The server api end points to use for uploading (see docs)
    server: [null, Type.SERVER_API],

    // File size calculations, can set to 1024, this is only used for display, properties use file size base 1000
    fileSizeBase: [1000, Type.INT],

    // Labels and status messages
    labelDecimalSeparator: [getDecimalSeparator(), Type.STRING], // Default is locale separator
    labelThousandsSeparator: [getThousandsSeparator(), Type.STRING], // Default is locale separator

    labelIdle: [
      'Drag & Drop your files or <span class="filepond--label-action">Browse</span>',
      Type.STRING
    ],
    labelInvalidField: ['Field contains invalid files', Type.STRING],
    labelFileWaitingForSize: ['Waiting for size', Type.STRING],
    labelFileSizeNotAvailable: ['Size not available', Type.STRING],
    labelFileCountSingular: ['file in list', Type.STRING],
    labelFileCountPlural: ['files in list', Type.STRING],
    labelFileLoading: ['Loading', Type.STRING],
    labelFileAdded: ['Added', Type.STRING], // assistive only
    labelFileLoadError: ['Error during load', Type.STRING],
    labelFileRemoved: ['Removed', Type.STRING], // assistive only
    labelFileRemoveError: ['Error during remove', Type.STRING],
    labelFileProcessing: ['Uploading', Type.STRING],
    labelFileProcessingComplete: ['Upload complete', Type.STRING],
    labelFileProcessingAborted: ['Upload cancelled', Type.STRING],
    labelFileProcessingError: ['Error during upload', Type.STRING],
    labelFileProcessingRevertError: ['Error during revert', Type.STRING],

    labelTapToCancel: ['tap to cancel', Type.STRING],
    labelTapToRetry: ['tap to retry', Type.STRING],
    labelTapToUndo: ['tap to undo', Type.STRING],

    labelButtonRemoveItem: ['Remove', Type.STRING],
    labelButtonAbortItemLoad: ['Abort', Type.STRING],
    labelButtonRetryItemLoad: ['Retry', Type.STRING],
    labelButtonAbortItemProcessing: ['Cancel', Type.STRING],
    labelButtonUndoItemProcessing: ['Undo', Type.STRING],
    labelButtonRetryItemProcessing: ['Retry', Type.STRING],
    labelButtonProcessItem: ['Upload', Type.STRING],

    // make sure width and height plus viewpox are even numbers so icons are nicely centered
    iconRemove: [
      '<svg width="26" height="26" viewBox="0 0 26 26" xmlns="http://www.w3.org/2000/svg"><path d="M11.586 13l-2.293 2.293a1 1 0 0 0 1.414 1.414L13 14.414l2.293 2.293a1 1 0 0 0 1.414-1.414L14.414 13l2.293-2.293a1 1 0 0 0-1.414-1.414L13 11.586l-2.293-2.293a1 1 0 0 0-1.414 1.414L11.586 13z" fill="currentColor" fill-rule="nonzero"/></svg>',
      Type.STRING
    ],

    iconProcess: [
      '<svg width="26" height="26" viewBox="0 0 26 26" xmlns="http://www.w3.org/2000/svg"><path d="M14 10.414v3.585a1 1 0 0 1-2 0v-3.585l-1.293 1.293a1 1 0 0 1-1.414-1.415l3-3a1 1 0 0 1 1.414 0l3 3a1 1 0 0 1-1.414 1.415L14 10.414zM9 18a1 1 0 0 1 0-2h8a1 1 0 0 1 0 2H9z" fill="currentColor" fill-rule="evenodd"/></svg>',
      Type.STRING
    ],

    iconRetry: [
      '<svg width="26" height="26" viewBox="0 0 26 26" xmlns="http://www.w3.org/2000/svg"><path d="M10.81 9.185l-.038.02A4.997 4.997 0 0 0 8 13.683a5 5 0 0 0 5 5 5 5 0 0 0 5-5 1 1 0 0 1 2 0A7 7 0 1 1 9.722 7.496l-.842-.21a.999.999 0 1 1 .484-1.94l3.23.806c.535.133.86.675.73 1.21l-.804 3.233a.997.997 0 0 1-1.21.73.997.997 0 0 1-.73-1.21l.23-.928v-.002z" fill="currentColor" fill-rule="nonzero"/></svg>',
      Type.STRING
    ],

    iconUndo: [
      '<svg width="26" height="26" viewBox="0 0 26 26" xmlns="http://www.w3.org/2000/svg"><path d="M9.185 10.81l.02-.038A4.997 4.997 0 0 1 13.683 8a5 5 0 0 1 5 5 5 5 0 0 1-5 5 1 1 0 0 0 0 2A7 7 0 1 0 7.496 9.722l-.21-.842a.999.999 0 1 0-1.94.484l.806 3.23c.133.535.675.86 1.21.73l3.233-.803a.997.997 0 0 0 .73-1.21.997.997 0 0 0-1.21-.73l-.928.23-.002-.001z" fill="currentColor" fill-rule="nonzero"/></svg>',
      Type.STRING
    ],

    iconDone: [
      '<svg width="26" height="26" viewBox="0 0 26 26" xmlns="http://www.w3.org/2000/svg"><path d="M18.293 9.293a1 1 0 0 1 1.414 1.414l-7.002 7a1 1 0 0 1-1.414 0l-3.998-4a1 1 0 1 1 1.414-1.414L12 15.586l6.294-6.293z" fill="currentColor" fill-rule="nonzero"/></svg>',
      Type.STRING
    ],

    // event handlers
    oninit: [null, Type.FUNCTION],
    onwarning: [null, Type.FUNCTION],
    onerror: [null, Type.FUNCTION],
    onactivatefile: [null, Type.FUNCTION],
    oninitfile: [null, Type.FUNCTION],
    onaddfilestart: [null, Type.FUNCTION],
    onaddfileprogress: [null, Type.FUNCTION],
    onaddfile: [null, Type.FUNCTION],
    onprocessfilestart: [null, Type.FUNCTION],
    onprocessfileprogress: [null, Type.FUNCTION],
    onprocessfileabort: [null, Type.FUNCTION],
    onprocessfilerevert: [null, Type.FUNCTION],
    onprocessfile: [null, Type.FUNCTION],
    onprocessfiles: [null, Type.FUNCTION],
    onremovefile: [null, Type.FUNCTION],
    onpreparefile: [null, Type.FUNCTION],
    onupdatefiles: [null, Type.FUNCTION],
    onreorderfiles: [null, Type.FUNCTION],

    // hooks
    beforeDropFile: [null, Type.FUNCTION],
    beforeAddFile: [null, Type.FUNCTION],
    beforeRemoveFile: [null, Type.FUNCTION],
    beforePrepareFile: [null, Type.FUNCTION],

    // styles
    stylePanelLayout: [null, Type.STRING], // null 'integrated', 'compact', 'circle'
    stylePanelAspectRatio: [null, Type.STRING], // null or '3:2' or 1
    styleItemPanelAspectRatio: [null, Type.STRING],
    styleButtonRemoveItemPosition: ['left', Type.STRING],
    styleButtonProcessItemPosition: ['right', Type.STRING],
    styleLoadIndicatorPosition: ['right', Type.STRING],
    styleProgressIndicatorPosition: ['right', Type.STRING],
    styleButtonRemoveItemAlign: [false, Type.BOOLEAN],

    // custom initial files array
    files: [[], Type.ARRAY],

    // show support by displaying credits
    credits: [['https://pqina.nl/', 'Powered by PQINA'], Type.ARRAY]
  };

  var getItemByQuery = function getItemByQuery(items, query) {
    // just return first index
    if (isEmpty(query)) {
      return items[0] || null;
    }

    // query is index
    if (isInt(query)) {
      return items[query] || null;
    }

    // if query is item, get the id
    if (typeof query === 'object') {
      query = query.id;
    }

    // assume query is a string and return item by id
    return (
      items.find(function(item) {
        return item.id === query;
      }) || null
    );
  };

  var getNumericAspectRatioFromString = function getNumericAspectRatioFromString(
    aspectRatio
  ) {
    if (isEmpty(aspectRatio)) {
      return aspectRatio;
    }
    if (/:/.test(aspectRatio)) {
      var parts = aspectRatio.split(':');
      return parts[1] / parts[0];
    }
    return parseFloat(aspectRatio);
  };

  var getActiveItems = function getActiveItems(items) {
    return items.filter(function(item) {
      return !item.archived;
    });
  };

  var Status = {
    EMPTY: 0,
    IDLE: 1, // waiting
    ERROR: 2, // a file is in error state
    BUSY: 3, // busy processing or loading
    READY: 4 // all files uploaded
  };

  var ITEM_ERROR = [
    ItemStatus.LOAD_ERROR,
    ItemStatus.PROCESSING_ERROR,
    ItemStatus.PROCESSING_REVERT_ERROR
  ];
  var ITEM_BUSY = [
    ItemStatus.LOADING,
    ItemStatus.PROCESSING,
    ItemStatus.PROCESSING_QUEUED,
    ItemStatus.INIT
  ];
  var ITEM_READY = [ItemStatus.PROCESSING_COMPLETE];

  var isItemInErrorState = function isItemInErrorState(item) {
    return ITEM_ERROR.includes(item.status);
  };
  var isItemInBusyState = function isItemInBusyState(item) {
    return ITEM_BUSY.includes(item.status);
  };
  var isItemInReadyState = function isItemInReadyState(item) {
    return ITEM_READY.includes(item.status);
  };

  var queries = function queries(state) {
    return {
      GET_STATUS: function GET_STATUS() {
        var items = getActiveItems(state.items);
        var EMPTY = Status.EMPTY,
          ERROR = Status.ERROR,
          BUSY = Status.BUSY,
          IDLE = Status.IDLE,
          READY = Status.READY;

        if (items.length === 0) return EMPTY;

        if (items.some(isItemInErrorState)) return ERROR;

        if (items.some(isItemInBusyState)) return BUSY;

        if (items.some(isItemInReadyState)) return READY;

        return IDLE;
      },

      GET_ITEM: function GET_ITEM(query) {
        return getItemByQuery(state.items, query);
      },

      GET_ACTIVE_ITEM: function GET_ACTIVE_ITEM(query) {
        return getItemByQuery(getActiveItems(state.items), query);
      },

      GET_ACTIVE_ITEMS: function GET_ACTIVE_ITEMS() {
        return getActiveItems(state.items);
      },

      GET_ITEMS: function GET_ITEMS() {
        return state.items;
      },

      GET_ITEM_NAME: function GET_ITEM_NAME(query) {
        var item = getItemByQuery(state.items, query);
        return item ? item.filename : null;
      },

      GET_ITEM_SIZE: function GET_ITEM_SIZE(query) {
        var item = getItemByQuery(state.items, query);
        return item ? item.fileSize : null;
      },

      GET_STYLES: function GET_STYLES() {
        return Object.keys(state.options)
          .filter(function(key) {
            return /^style/.test(key);
          })
          .map(function(option) {
            return {
              name: option,
              value: state.options[option]
            };
          });
      },

      GET_PANEL_ASPECT_RATIO: function GET_PANEL_ASPECT_RATIO() {
        var isShapeCircle = /circle/.test(state.options.stylePanelLayout);
        var aspectRatio = isShapeCircle
          ? 1
          : getNumericAspectRatioFromString(
              state.options.stylePanelAspectRatio
            );
        return aspectRatio;
      },

      GET_ITEM_PANEL_ASPECT_RATIO: function GET_ITEM_PANEL_ASPECT_RATIO() {
        return state.options.styleItemPanelAspectRatio;
      },

      GET_ITEMS_BY_STATUS: function GET_ITEMS_BY_STATUS(status) {
        return getActiveItems(state.items).filter(function(item) {
          return item.status === status;
        });
      },

      GET_TOTAL_ITEMS: function GET_TOTAL_ITEMS() {
        return getActiveItems(state.items).length;
      },

      IS_ASYNC: function IS_ASYNC() {
        return (
          isObject(state.options.server) &&
          (isObject(state.options.server.process) ||
            isFunction(state.options.server.process))
        );
      }
    };
  };

  var hasRoomForItem = function hasRoomForItem(state) {
    var count = getActiveItems(state.items).length;

    // if cannot have multiple items, to add one item it should currently not contain items
    if (!state.options.allowMultiple) {
      return count === 0;
    }

    // if allows multiple items, we check if a max item count has been set, if not, there's no limit
    var maxFileCount = state.options.maxFiles;
    if (maxFileCount === null) {
      return true;
    }

    // we check if the current count is smaller than the max count, if so, another file can still be added
    if (count < maxFileCount) {
      return true;
    }

    // no more room for another file
    return false;
  };

  var limit = function limit(value, min, max) {
    return Math.max(Math.min(max, value), min);
  };

  var arrayInsert = function arrayInsert(arr, index, item) {
    return arr.splice(index, 0, item);
  };

  var insertItem = function insertItem(items, item, index) {
    if (isEmpty(item)) {
      return null;
    }

    // if index is undefined, append
    if (typeof index === 'undefined') {
      items.push(item);
      return item;
    }

    // limit the index to the size of the items array
    index = limit(index, 0, items.length);

    // add item to array
    arrayInsert(items, index, item);

    // expose
    return item;
  };

  var isBase64DataURI = function isBase64DataURI(str) {
    return /^\s*data:([a-z]+\/[a-z0-9-+.]+(;[a-z-]+=[a-z0-9-]+)?)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s]*)\s*$/i.test(
      str
    );
  };

  var getFilenameFromURL = function getFilenameFromURL(url) {
    return url
      .split('/')
      .pop()
      .split('?')
      .shift();
  };

  var getExtensionFromFilename = function getExtensionFromFilename(name) {
    return name.split('.').pop();
  };

  var guesstimateExtension = function guesstimateExtension(type) {
    // if no extension supplied, exit here
    if (typeof type !== 'string') {
      return '';
    }

    // get subtype
    var subtype = type.split('/').pop();

    // is svg subtype
    if (/svg/.test(subtype)) {
      return 'svg';
    }

    if (/zip|compressed/.test(subtype)) {
      return 'zip';
    }

    if (/plain/.test(subtype)) {
      return 'txt';
    }

    if (/msword/.test(subtype)) {
      return 'doc';
    }

    // if is valid subtype
    if (/[a-z]+/.test(subtype)) {
      // always use jpg extension
      if (subtype === 'jpeg') {
        return 'jpg';
      }

      // return subtype
      return subtype;
    }

    return '';
  };

  var leftPad = function leftPad(value) {
    var padding =
      arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
    return (padding + value).slice(-padding.length);
  };

  var getDateString = function getDateString() {
    var date =
      arguments.length > 0 && arguments[0] !== undefined
        ? arguments[0]
        : new Date();
    return (
      date.getFullYear() +
      '-' +
      leftPad(date.getMonth() + 1, '00') +
      '-' +
      leftPad(date.getDate(), '00') +
      '_' +
      leftPad(date.getHours(), '00') +
      '-' +
      leftPad(date.getMinutes(), '00') +
      '-' +
      leftPad(date.getSeconds(), '00')
    );
  };

  var getFileFromBlob = function getFileFromBlob(blob, filename) {
    var type =
      arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var extension =
      arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    var file =
      typeof type === 'string'
        ? blob.slice(0, blob.size, type)
        : blob.slice(0, blob.size, blob.type);
    file.lastModifiedDate = new Date();

    // copy relative path
    if (blob._relativePath) file._relativePath = blob._relativePath;

    // if blob has name property, use as filename if no filename supplied
    if (!isString(filename)) {
      filename = getDateString();
    }

    // if filename supplied but no extension and filename has extension
    if (filename && extension === null && getExtensionFromFilename(filename)) {
      file.name = filename;
    } else {
      extension = extension || guesstimateExtension(file.type);
      file.name = filename + (extension ? '.' + extension : '');
    }

    return file;
  };

  var getBlobBuilder = function getBlobBuilder() {
    return (window.BlobBuilder =
      window.BlobBuilder ||
      window.WebKitBlobBuilder ||
      window.MozBlobBuilder ||
      window.MSBlobBuilder);
  };

  var createBlob = function createBlob(arrayBuffer, mimeType) {
    var BB = getBlobBuilder();

    if (BB) {
      var bb = new BB();
      bb.append(arrayBuffer);
      return bb.getBlob(mimeType);
    }

    return new Blob([arrayBuffer], {
      type: mimeType
    });
  };

  var getBlobFromByteStringWithMimeType = function getBlobFromByteStringWithMimeType(
    byteString,
    mimeType
  ) {
    var ab = new ArrayBuffer(byteString.length);
    var ia = new Uint8Array(ab);

    for (var i = 0; i < byteString.length; i++) {
      ia[i] = byteString.charCodeAt(i);
    }

    return createBlob(ab, mimeType);
  };

  var getMimeTypeFromBase64DataURI = function getMimeTypeFromBase64DataURI(
    dataURI
  ) {
    return (/^data:(.+);/.exec(dataURI) || [])[1] || null;
  };

  var getBase64DataFromBase64DataURI = function getBase64DataFromBase64DataURI(
    dataURI
  ) {
    // get data part of string (remove data:image/jpeg...,)
    var data = dataURI.split(',')[1];

    // remove any whitespace as that causes InvalidCharacterError in IE
    return data.replace(/\s/g, '');
  };

  var getByteStringFromBase64DataURI = function getByteStringFromBase64DataURI(
    dataURI
  ) {
    return atob(getBase64DataFromBase64DataURI(dataURI));
  };

  var getBlobFromBase64DataURI = function getBlobFromBase64DataURI(dataURI) {
    var mimeType = getMimeTypeFromBase64DataURI(dataURI);
    var byteString = getByteStringFromBase64DataURI(dataURI);

    return getBlobFromByteStringWithMimeType(byteString, mimeType);
  };

  var getFileFromBase64DataURI = function getFileFromBase64DataURI(
    dataURI,
    filename,
    extension
  ) {
    return getFileFromBlob(
      getBlobFromBase64DataURI(dataURI),
      filename,
      null,
      extension
    );
  };

  var getFileNameFromHeader = function getFileNameFromHeader(header) {
    // test if is content disposition header, if not exit
    if (!/^content-disposition:/i.test(header)) return null;

    // get filename parts
    var matches = header
      .split(/filename=|filename\*=.+''/)
      .splice(1)
      .map(function(name) {
        return name.trim().replace(/^["']|[;"']{0,2}$/g, '');
      })
      .filter(function(name) {
        return name.length;
      });

    return matches.length ? decodeURI(matches[matches.length - 1]) : null;
  };

  var getFileSizeFromHeader = function getFileSizeFromHeader(header) {
    if (/content-length:/i.test(header)) {
      var size = header.match(/[0-9]+/)[0];
      return size ? parseInt(size, 10) : null;
    }
    return null;
  };

  var getTranfserIdFromHeader = function getTranfserIdFromHeader(header) {
    if (/x-content-transfer-id:/i.test(header)) {
      var id = (header.split(':')[1] || '').trim();
      return id || null;
    }
    return null;
  };

  var getFileInfoFromHeaders = function getFileInfoFromHeaders(headers) {
    var info = {
      source: null,
      name: null,
      size: null
    };

    var rows = headers.split('\n');
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;
    try {
      for (
        var _iterator = rows[Symbol.iterator](), _step;
        !(_iteratorNormalCompletion = (_step = _iterator.next()).done);
        _iteratorNormalCompletion = true
      ) {
        var header = _step.value;

        var name = getFileNameFromHeader(header);
        if (name) {
          info.name = name;
          continue;
        }

        var size = getFileSizeFromHeader(header);
        if (size) {
          info.size = size;
          continue;
        }

        var source = getTranfserIdFromHeader(header);
        if (source) {
          info.source = source;
          continue;
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return info;
  };

  var createFileLoader = function createFileLoader(fetchFn) {
    var state = {
      source: null,
      complete: false,
      progress: 0,
      size: null,
      timestamp: null,
      duration: 0,
      request: null
    };

    var getProgress = function getProgress() {
      return state.progress;
    };
    var abort = function abort() {
      if (state.request && state.request.abort) {
        state.request.abort();
      }
    };

    // load source
    var load = function load() {
      // get quick reference
      var source = state.source;

      api.fire('init', source);

      // Load Files
      if (source instanceof File) {
        api.fire('load', source);
      } else if (source instanceof Blob) {
        // Load blobs, set default name to current date
        api.fire('load', getFileFromBlob(source, source.name));
      } else if (isBase64DataURI(source)) {
        // Load base 64, set default name to current date
        api.fire('load', getFileFromBase64DataURI(source));
      } else {
        // Deal as if is external URL, let's load it!
        loadURL(source);
      }
    };

    // loads a url
    var loadURL = function loadURL(url) {
      // is remote url and no fetch method supplied
      if (!fetchFn) {
        api.fire('error', {
          type: 'error',
          body: "Can't load URL",
          code: 400
        });

        return;
      }

      // set request start
      state.timestamp = Date.now();

      // load file
      state.request = fetchFn(
        url,
        function(response) {
          // update duration
          state.duration = Date.now() - state.timestamp;

          // done!
          state.complete = true;

          // turn blob response into a file
          if (response instanceof Blob) {
            response = getFileFromBlob(
              response,
              response.name || getFilenameFromURL(url)
            );
          }

          api.fire(
            'load',
            // if has received blob, we go with blob, if no response, we return null
            response instanceof Blob
              ? response
              : response
              ? response.body
              : null
          );
        },
        function(error) {
          api.fire(
            'error',
            typeof error === 'string'
              ? {
                  type: 'error',
                  code: 0,
                  body: error
                }
              : error
          );
        },
        function(computable, current, total) {
          // collected some meta data already
          if (total) {
            state.size = total;
          }

          // update duration
          state.duration = Date.now() - state.timestamp;

          // if we can't compute progress, we're not going to fire progress events
          if (!computable) {
            state.progress = null;
            return;
          }

          // update progress percentage
          state.progress = current / total;

          // expose
          api.fire('progress', state.progress);
        },
        function() {
          api.fire('abort');
        },
        function(response) {
          var fileinfo = getFileInfoFromHeaders(
            typeof response === 'string' ? response : response.headers
          );
          api.fire('meta', {
            size: state.size || fileinfo.size,
            filename: fileinfo.name,
            source: fileinfo.source
          });
        }
      );
    };

    var api = Object.assign({}, on(), {
      setSource: function setSource(source) {
        return (state.source = source);
      },
      getProgress: getProgress, // file load progress
      abort: abort, // abort file load
      load: load // start load
    });

    return api;
  };

  var isGet = function isGet(method) {
    return /GET|HEAD/.test(method);
  };

  var sendRequest = function sendRequest(data, url, options) {
    var api = {
      onheaders: function onheaders() {},
      onprogress: function onprogress() {},
      onload: function onload() {},
      ontimeout: function ontimeout() {},
      onerror: function onerror() {},
      onabort: function onabort() {},
      abort: function abort() {
        aborted = true;
        xhr.abort();
      }
    };

    // timeout identifier, only used when timeout is defined
    var aborted = false;
    var headersReceived = false;

    // set default options
    options = Object.assign(
      {
        method: 'POST',
        headers: {},
        withCredentials: false
      },
      options
    );

    // encode url
    url = encodeURI(url);

    // if method is GET, add any received data to url

    if (isGet(options.method) && data) {
      url =
        '' +
        url +
        encodeURIComponent(
          typeof data === 'string' ? data : JSON.stringify(data)
        );
    }

    // create request
    var xhr = new XMLHttpRequest();

    // progress of load
    var process = isGet(options.method) ? xhr : xhr.upload;
    process.onprogress = function(e) {
      // no progress event when aborted ( onprogress is called once after abort() )
      if (aborted) {
        return;
      }

      api.onprogress(e.lengthComputable, e.loaded, e.total);
    };

    // tries to get header info to the app as fast as possible
    xhr.onreadystatechange = function() {
      // not interesting in these states ('unsent' and 'openend' as they don't give us any additional info)
      if (xhr.readyState < 2) {
        return;
      }

      // no server response
      if (xhr.readyState === 4 && xhr.status === 0) {
        return;
      }

      if (headersReceived) {
        return;
      }

      headersReceived = true;

      // we've probably received some useful data in response headers
      api.onheaders(xhr);
    };

    // load successful
    xhr.onload = function() {
      // is classified as valid response
      if (xhr.status >= 200 && xhr.status < 300) {
        api.onload(xhr);
      } else {
        api.onerror(xhr);
      }
    };

    // error during load
    xhr.onerror = function() {
      return api.onerror(xhr);
    };

    // request aborted
    xhr.onabort = function() {
      aborted = true;
      api.onabort();
    };

    // request timeout
    xhr.ontimeout = function() {
      return api.ontimeout(xhr);
    };

    // open up open up!
    xhr.open(options.method, url, true);

    // set timeout if defined (do it after open so IE11 plays ball)
    if (isInt(options.timeout)) {
      xhr.timeout = options.timeout;
    }

    // add headers
    Object.keys(options.headers).forEach(function(key) {
      var value = unescape(encodeURIComponent(options.headers[key]));
      xhr.setRequestHeader(key, value);
    });

    // set type of response
    if (options.responseType) {
      xhr.responseType = options.responseType;
    }

    // set credentials
    if (options.withCredentials) {
      xhr.withCredentials = true;
    }

    // let's send our data
    xhr.send(data);

    return api;
  };

  var createResponse = function createResponse(type, code, body, headers) {
    return {
      type: type,
      code: code,
      body: body,
      headers: headers
    };
  };

  var createTimeoutResponse = function createTimeoutResponse(cb) {
    return function(xhr) {
      cb(createResponse('error', 0, 'Timeout', xhr.getAllResponseHeaders()));
    };
  };

  var hasQS = function hasQS(str) {
    return /\?/.test(str);
  };
  var buildURL = function buildURL() {
    var url = '';
    for (
      var _len = arguments.length, parts = new Array(_len), _key = 0;
      _key < _len;
      _key++
    ) {
      parts[_key] = arguments[_key];
    }
    parts.forEach(function(part) {
      url += hasQS(url) && hasQS(part) ? part.replace(/\?/, '&') : part;
    });
    return url;
  };

  var createFetchFunction = function createFetchFunction() {
    var apiUrl =
      arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    var action = arguments.length > 1 ? arguments[1] : undefined;
    // custom handler (should also handle file, load, error, progress and abort)
    if (typeof action === 'function') {
      return action;
    }

    // no action supplied
    if (!action || !isString(action.url)) {
      return null;
    }

    // set onload hanlder
    var onload =
      action.onload ||
      function(res) {
        return res;
      };
    var onerror =
      action.onerror ||
      function(res) {
        return null;
      };

    // internal handler
    return function(url, load, error, progress, abort, headers) {
      // do local or remote request based on if the url is external
      var request = sendRequest(
        url,
        buildURL(apiUrl, action.url),
        Object.assign({}, action, {
          responseType: 'blob'
        })
      );

      request.onload = function(xhr) {
        // get headers
        var headers = xhr.getAllResponseHeaders();

        // get filename
        var filename =
          getFileInfoFromHeaders(headers).name || getFilenameFromURL(url);

        // create response
        load(
          createResponse(
            'load',
            xhr.status,
            action.method === 'HEAD'
              ? null
              : getFileFromBlob(onload(xhr.response), filename),
            headers
          )
        );
      };

      request.onerror = function(xhr) {
        error(
          createResponse(
            'error',
            xhr.status,
            onerror(xhr.response) || xhr.statusText,
            xhr.getAllResponseHeaders()
          )
        );
      };

      request.onheaders = function(xhr) {
        headers(
          createResponse(
            'headers',
            xhr.status,
            null,
            xhr.getAllResponseHeaders()
          )
        );
      };

      request.ontimeout = createTimeoutResponse(error);
      request.onprogress = progress;
      request.onabort = abort;

      // should return request
      return request;
    };
  };

  var ChunkStatus = {
    QUEUED: 0,
    COMPLETE: 1,
    PROCESSING: 2,
    ERROR: 3,
    WAITING: 4
  };

  /*
                                                       function signature:
                                                         (file, metadata, load, error, progress, abort, transfer, options) => {
                                                           return {
                                                           abort:() => {}
                                                         }
                                                       }
                                                       */

  // apiUrl, action, name, file, metadata, load, error, progress, abort, transfer, options
  var processFileChunked = function processFileChunked(
    apiUrl,
    action,
    name,
    file,
    metadata,
    load,
    error,
    progress,
    abort,
    transfer,
    options
  ) {
    // all chunks
    var chunks = [];
    var chunkTransferId = options.chunkTransferId,
      chunkServer = options.chunkServer,
      chunkSize = options.chunkSize,
      chunkRetryDelays = options.chunkRetryDelays;

    // default state
    var state = {
      serverId: chunkTransferId,
      aborted: false
    };

    // set onload handlers
    var ondata =
      action.ondata ||
      function(fd) {
        return fd;
      };
    var onload =
      action.onload ||
      function(xhr, method) {
        return method === 'HEAD'
          ? xhr.getResponseHeader('Upload-Offset')
          : xhr.response;
      };
    var onerror =
      action.onerror ||
      function(res) {
        return null;
      };

    // create server hook
    var requestTransferId = function requestTransferId(cb) {
      var formData = new FormData();

      // add metadata under same name
      if (isObject(metadata)) formData.append(name, JSON.stringify(metadata));

      var headers =
        typeof action.headers === 'function'
          ? action.headers(file, metadata)
          : Object.assign({}, action.headers, {
              'Upload-Length': file.size
            });

      var requestParams = Object.assign({}, action, {
        headers: headers
      });

      // send request object
      var request = sendRequest(
        ondata(formData),
        buildURL(apiUrl, action.url),
        requestParams
      );

      request.onload = function(xhr) {
        return cb(onload(xhr, requestParams.method));
      };

      request.onerror = function(xhr) {
        return error(
          createResponse(
            'error',
            xhr.status,
            onerror(xhr.response) || xhr.statusText,
            xhr.getAllResponseHeaders()
          )
        );
      };

      request.ontimeout = createTimeoutResponse(error);
    };

    var requestTransferOffset = function requestTransferOffset(cb) {
      var requestUrl = buildURL(apiUrl, chunkServer.url, state.serverId);

      var headers =
        typeof action.headers === 'function'
          ? action.headers(state.serverId)
          : Object.assign({}, action.headers);

      var requestParams = {
        headers: headers,
        method: 'HEAD'
      };

      var request = sendRequest(null, requestUrl, requestParams);

      request.onload = function(xhr) {
        return cb(onload(xhr, requestParams.method));
      };

      request.onerror = function(xhr) {
        return error(
          createResponse(
            'error',
            xhr.status,
            onerror(xhr.response) || xhr.statusText,
            xhr.getAllResponseHeaders()
          )
        );
      };

      request.ontimeout = createTimeoutResponse(error);
    };

    // create chunks
    var lastChunkIndex = Math.floor(file.size / chunkSize);
    for (var i = 0; i <= lastChunkIndex; i++) {
      var offset = i * chunkSize;
      var data = file.slice(
        offset,
        offset + chunkSize,
        'application/offset+octet-stream'
      );
      chunks[i] = {
        index: i,
        size: data.size,
        offset: offset,
        data: data,
        file: file,
        progress: 0,
        retries: _toConsumableArray(chunkRetryDelays),
        status: ChunkStatus.QUEUED,
        error: null,
        request: null,
        timeout: null
      };
    }

    var completeProcessingChunks = function completeProcessingChunks() {
      return load(state.serverId);
    };

    var canProcessChunk = function canProcessChunk(chunk) {
      return (
        chunk.status === ChunkStatus.QUEUED ||
        chunk.status === ChunkStatus.ERROR
      );
    };

    var processChunk = function processChunk(chunk) {
      // processing is paused, wait here
      if (state.aborted) return;

      // get next chunk to process
      chunk = chunk || chunks.find(canProcessChunk);

      // no more chunks to process
      if (!chunk) {
        // all done?
        if (
          chunks.every(function(chunk) {
            return chunk.status === ChunkStatus.COMPLETE;
          })
        ) {
          completeProcessingChunks();
        }

        // no chunk to handle
        return;
      }

      // now processing this chunk
      chunk.status = ChunkStatus.PROCESSING;
      chunk.progress = null;

      // allow parsing of formdata
      var ondata =
        chunkServer.ondata ||
        function(fd) {
          return fd;
        };
      var onerror =
        chunkServer.onerror ||
        function(res) {
          return null;
        };

      // send request object
      var requestUrl = buildURL(apiUrl, chunkServer.url, state.serverId);

      var headers =
        typeof chunkServer.headers === 'function'
          ? chunkServer.headers(chunk)
          : Object.assign({}, chunkServer.headers, {
              'Content-Type': 'application/offset+octet-stream',
              'Upload-Offset': chunk.offset,
              'Upload-Length': file.size,
              'Upload-Name': file.name
            });

      var request = (chunk.request = sendRequest(
        ondata(chunk.data),
        requestUrl,
        Object.assign({}, chunkServer, {
          headers: headers
        })
      ));

      request.onload = function() {
        // done!
        chunk.status = ChunkStatus.COMPLETE;

        // remove request reference
        chunk.request = null;

        // start processing more chunks
        processChunks();
      };

      request.onprogress = function(lengthComputable, loaded, total) {
        chunk.progress = lengthComputable ? loaded : null;
        updateTotalProgress();
      };

      request.onerror = function(xhr) {
        chunk.status = ChunkStatus.ERROR;
        chunk.request = null;
        chunk.error = onerror(xhr.response) || xhr.statusText;
        if (!retryProcessChunk(chunk)) {
          error(
            createResponse(
              'error',
              xhr.status,
              onerror(xhr.response) || xhr.statusText,
              xhr.getAllResponseHeaders()
            )
          );
        }
      };

      request.ontimeout = function(xhr) {
        chunk.status = ChunkStatus.ERROR;
        chunk.request = null;
        if (!retryProcessChunk(chunk)) {
          createTimeoutResponse(error)(xhr);
        }
      };

      request.onabort = function() {
        chunk.status = ChunkStatus.QUEUED;
        chunk.request = null;
        abort();
      };
    };

    var retryProcessChunk = function retryProcessChunk(chunk) {
      // no more retries left
      if (chunk.retries.length === 0) return false;

      // new retry
      chunk.status = ChunkStatus.WAITING;
      clearTimeout(chunk.timeout);
      chunk.timeout = setTimeout(function() {
        processChunk(chunk);
      }, chunk.retries.shift());

      // we're going to retry
      return true;
    };

    var updateTotalProgress = function updateTotalProgress() {
      // calculate total progress fraction
      var totalBytesTransfered = chunks.reduce(function(p, chunk) {
        if (p === null || chunk.progress === null) return null;
        return p + chunk.progress;
      }, 0);

      // can't compute progress
      if (totalBytesTransfered === null) return progress(false, 0, 0);

      // calculate progress values
      var totalSize = chunks.reduce(function(total, chunk) {
        return total + chunk.size;
      }, 0);

      // can update progress indicator
      progress(true, totalBytesTransfered, totalSize);
    };

    // process new chunks
    var processChunks = function processChunks() {
      var totalProcessing = chunks.filter(function(chunk) {
        return chunk.status === ChunkStatus.PROCESSING;
      }).length;
      if (totalProcessing >= 1) return;
      processChunk();
    };

    var abortChunks = function abortChunks() {
      chunks.forEach(function(chunk) {
        clearTimeout(chunk.timeout);
        if (chunk.request) {
          chunk.request.abort();
        }
      });
    };

    // let's go!
    if (!state.serverId) {
      requestTransferId(function(serverId) {
        // stop here if aborted, might have happened in between request and callback
        if (state.aborted) return;

        // pass back to item so we can use it if something goes wrong
        transfer(serverId);

        // store internally
        state.serverId = serverId;
        processChunks();
      });
    } else {
      requestTransferOffset(function(offset) {
        // stop here if aborted, might have happened in between request and callback
        if (state.aborted) return;

        // mark chunks with lower offset as complete
        chunks
          .filter(function(chunk) {
            return chunk.offset < offset;
          })
          .forEach(function(chunk) {
            chunk.status = ChunkStatus.COMPLETE;
            chunk.progress = chunk.size;
          });

        // continue processing
        processChunks();
      });
    }

    return {
      abort: function abort() {
        state.aborted = true;
        abortChunks();
      }
    };
  };

  /*
                                                               function signature:
                                                                 (file, metadata, load, error, progress, abort) => {
                                                                   return {
                                                                   abort:() => {}
                                                                 }
                                                               }
                                                               */
  var createFileProcessorFunction = function createFileProcessorFunction(
    apiUrl,
    action,
    name,
    options
  ) {
    return function(file, metadata, load, error, progress, abort, transfer) {
      // no file received
      if (!file) return;

      // if was passed a file, and we can chunk it, exit here
      var canChunkUpload = options.chunkUploads;
      var shouldChunkUpload = canChunkUpload && file.size > options.chunkSize;
      var willChunkUpload =
        canChunkUpload && (shouldChunkUpload || options.chunkForce);
      if (file instanceof Blob && willChunkUpload)
        return processFileChunked(
          apiUrl,
          action,
          name,
          file,
          metadata,
          load,
          error,
          progress,
          abort,
          transfer,
          options
        );

      // set handlers
      var ondata =
        action.ondata ||
        function(fd) {
          return fd;
        };
      var onload =
        action.onload ||
        function(res) {
          return res;
        };
      var onerror =
        action.onerror ||
        function(res) {
          return null;
        };

      // create formdata object
      var formData = new FormData();

      // add metadata under same name
      if (isObject(metadata)) {
        formData.append(name, JSON.stringify(metadata));
      }

      // Turn into an array of objects so no matter what the input, we can handle it the same way
      (file instanceof Blob ? [{ name: null, file: file }] : file).forEach(
        function(item) {
          formData.append(
            name,
            item.file,
            item.name === null
              ? item.file.name
              : '' + item.name + item.file.name
          );
        }
      );

      // send request object
      var request = sendRequest(
        ondata(formData),
        buildURL(apiUrl, action.url),
        action
      );
      request.onload = function(xhr) {
        load(
          createResponse(
            'load',
            xhr.status,
            onload(xhr.response),
            xhr.getAllResponseHeaders()
          )
        );
      };

      request.onerror = function(xhr) {
        error(
          createResponse(
            'error',
            xhr.status,
            onerror(xhr.response) || xhr.statusText,
            xhr.getAllResponseHeaders()
          )
        );
      };

      request.ontimeout = createTimeoutResponse(error);
      request.onprogress = progress;
      request.onabort = abort;

      // should return request
      return request;
    };
  };

  var createProcessorFunction = function createProcessorFunction() {
    var apiUrl =
      arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    var action = arguments.length > 1 ? arguments[1] : undefined;
    var name = arguments.length > 2 ? arguments[2] : undefined;
    var options = arguments.length > 3 ? arguments[3] : undefined;

    // custom handler (should also handle file, load, error, progress and abort)
    if (typeof action === 'function')
      return function() {
        for (
          var _len = arguments.length, params = new Array(_len), _key = 0;
          _key < _len;
          _key++
        ) {
          params[_key] = arguments[_key];
        }
        return action.apply(void 0, [name].concat(params, [options]));
      };

    // no action supplied
    if (!action || !isString(action.url)) return null;

    // internal handler
    return createFileProcessorFunction(apiUrl, action, name, options);
  };

  /*
                                                      function signature:
                                                      (uniqueFileId, load, error) => { }
                                                      */
  var createRevertFunction = function createRevertFunction() {
    var apiUrl =
      arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    var action = arguments.length > 1 ? arguments[1] : undefined;
    // is custom implementation
    if (typeof action === 'function') {
      return action;
    }

    // no action supplied, return stub function, interface will work, but file won't be removed
    if (!action || !isString(action.url)) {
      return function(uniqueFileId, load) {
        return load();
      };
    }

    // set onload hanlder
    var onload =
      action.onload ||
      function(res) {
        return res;
      };
    var onerror =
      action.onerror ||
      function(res) {
        return null;
      };

    // internal implementation
    return function(uniqueFileId, load, error) {
      var request = sendRequest(
        uniqueFileId,
        apiUrl + action.url,
        action // contains method, headers and withCredentials properties
      );
      request.onload = function(xhr) {
        load(
          createResponse(
            'load',
            xhr.status,
            onload(xhr.response),
            xhr.getAllResponseHeaders()
          )
        );
      };

      request.onerror = function(xhr) {
        error(
          createResponse(
            'error',
            xhr.status,
            onerror(xhr.response) || xhr.statusText,
            xhr.getAllResponseHeaders()
          )
        );
      };

      request.ontimeout = createTimeoutResponse(error);

      return request;
    };
  };

  var getRandomNumber = function getRandomNumber() {
    var min =
      arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var max =
      arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    return min + Math.random() * (max - min);
  };

  var createPerceivedPerformanceUpdater = function createPerceivedPerformanceUpdater(
    cb
  ) {
    var duration =
      arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;
    var offset =
      arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var tickMin =
      arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 25;
    var tickMax =
      arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 250;
    var timeout = null;
    var start = Date.now();

    var tick = function tick() {
      var runtime = Date.now() - start;
      var delay = getRandomNumber(tickMin, tickMax);

      if (runtime + delay > duration) {
        delay = runtime + delay - duration;
      }

      var progress = runtime / duration;
      if (progress >= 1 || document.hidden) {
        cb(1);
        return;
      }

      cb(progress);

      timeout = setTimeout(tick, delay);
    };

    tick();

    return {
      clear: function clear() {
        clearTimeout(timeout);
      }
    };
  };

  var createFileProcessor = function createFileProcessor(processFn) {
    var state = {
      complete: false,
      perceivedProgress: 0,
      perceivedPerformanceUpdater: null,
      progress: null,
      timestamp: null,
      perceivedDuration: 0,
      duration: 0,
      request: null,
      response: null
    };

    var process = function process(file, metadata) {
      var progressFn = function progressFn() {
        // we've not yet started the real download, stop here
        // the request might not go through, for instance, there might be some server trouble
        // if state.progress is null, the server does not allow computing progress and we show the spinner instead
        if (state.duration === 0 || state.progress === null) return;

        // as we're now processing, fire the progress event
        api.fire('progress', api.getProgress());
      };

      var completeFn = function completeFn() {
        state.complete = true;
        api.fire('load-perceived', state.response.body);
      };

      // let's start processing
      api.fire('start');

      // set request start
      state.timestamp = Date.now();

      // create perceived performance progress indicator
      state.perceivedPerformanceUpdater = createPerceivedPerformanceUpdater(
        function(progress) {
          state.perceivedProgress = progress;
          state.perceivedDuration = Date.now() - state.timestamp;

          progressFn();

          // if fake progress is done, and a response has been received,
          // and we've not yet called the complete method
          if (
            state.response &&
            state.perceivedProgress === 1 &&
            !state.complete
          ) {
            // we done!
            completeFn();
          }
        },
        // random delay as in a list of files you start noticing
        // files uploading at the exact same speed
        getRandomNumber(750, 1500)
      );

      // remember request so we can abort it later
      state.request = processFn(
        // the file to process
        file,

        // the metadata to send along
        metadata,

        // callbacks (load, error, progress, abort, transfer)
        // load expects the body to be a server id if
        // you want to make use of revert
        function(response) {
          // we put the response in state so we can access
          // it outside of this method
          state.response = isObject(response)
            ? response
            : {
                type: 'load',
                code: 200,
                body: '' + response,
                headers: {}
              };

          // update duration
          state.duration = Date.now() - state.timestamp;

          // force progress to 1 as we're now done
          state.progress = 1;

          // actual load is done let's share results
          api.fire('load', state.response.body);

          // we are really done
          // if perceived progress is 1 ( wait for perceived progress to complete )
          // or if server does not support progress ( null )
          if (state.perceivedProgress === 1) {
            completeFn();
          }
        },

        // error is expected to be an object with type, code, body
        function(error) {
          // cancel updater
          state.perceivedPerformanceUpdater.clear();

          // update others about this error
          api.fire(
            'error',
            isObject(error)
              ? error
              : {
                  type: 'error',
                  code: 0,
                  body: '' + error
                }
          );
        },

        // actual processing progress
        function(computable, current, total) {
          // update actual duration
          state.duration = Date.now() - state.timestamp;

          // update actual progress
          state.progress = computable ? current / total : null;

          progressFn();
        },

        // abort does not expect a value
        function() {
          // stop updater
          state.perceivedPerformanceUpdater.clear();

          // fire the abort event so we can switch visuals
          api.fire('abort', state.response ? state.response.body : null);
        },

        // register the id for this transfer
        function(transferId) {
          api.fire('transfer', transferId);
        }
      );
    };

    var abort = function abort() {
      // no request running, can't abort
      if (!state.request) return;

      // stop updater
      state.perceivedPerformanceUpdater.clear();

      // abort actual request
      if (state.request.abort) state.request.abort();

      // if has response object, we've completed the request
      state.complete = true;
    };

    var reset = function reset() {
      abort();
      state.complete = false;
      state.perceivedProgress = 0;
      state.progress = 0;
      state.timestamp = null;
      state.perceivedDuration = 0;
      state.duration = 0;
      state.request = null;
      state.response = null;
    };

    var getProgress = function getProgress() {
      return state.progress
        ? Math.min(state.progress, state.perceivedProgress)
        : null;
    };
    var getDuration = function getDuration() {
      return Math.min(state.duration, state.perceivedDuration);
    };

    var api = Object.assign({}, on(), {
      process: process, // start processing file
      abort: abort, // abort active process request
      getProgress: getProgress,
      getDuration: getDuration,
      reset: reset
    });

    return api;
  };

  var getFilenameWithoutExtension = function getFilenameWithoutExtension(name) {
    return name.substr(0, name.lastIndexOf('.')) || name;
  };

  var createFileStub = function createFileStub(source) {
    var data = [source.name, source.size, source.type];

    // is blob or base64, then we need to set the name
    if (source instanceof Blob || isBase64DataURI(source)) {
      data[0] = source.name || getDateString();
    } else if (isBase64DataURI(source)) {
      // if is base64 data uri we need to determine the average size and type
      data[1] = source.length;
      data[2] = getMimeTypeFromBase64DataURI(source);
    } else if (isString(source)) {
      // url
      data[0] = getFilenameFromURL(source);
      data[1] = 0;
      data[2] = 'application/octet-stream';
    }

    return {
      name: data[0],
      size: data[1],
      type: data[2]
    };
  };

  var isFile = function isFile(value) {
    return !!(value instanceof File || (value instanceof Blob && value.name));
  };

  var deepCloneObject = function deepCloneObject(src) {
    if (!isObject(src)) return src;
    var target = isArray(src) ? [] : {};
    for (var key in src) {
      if (!src.hasOwnProperty(key)) continue;
      var v = src[key];
      target[key] = v && isObject(v) ? deepCloneObject(v) : v;
    }
    return target;
  };

  var createItem = function createItem() {
    var origin =
      arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var serverFileReference =
      arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var file =
      arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    // unique id for this item, is used to identify the item across views
    var id = getUniqueId();

    /**
     * Internal item state
     */
    var state = {
      // is archived
      archived: false,

      // if is frozen, no longer fires events
      frozen: false,

      // removed from view
      released: false,

      // original source
      source: null,

      // file model reference
      file: file,

      // id of file on server
      serverFileReference: serverFileReference,

      // id of file transfer on server
      transferId: null,

      // is aborted
      processingAborted: false,

      // current item status
      status: serverFileReference
        ? ItemStatus.PROCESSING_COMPLETE
        : ItemStatus.INIT,

      // active processes
      activeLoader: null,
      activeProcessor: null
    };

    // callback used when abort processing is called to link back to the resolve method
    var abortProcessingRequestComplete = null;

    /**
     * Externally added item metadata
     */
    var metadata = {};

    // item data
    var setStatus = function setStatus(status) {
      return (state.status = status);
    };

    // fire event unless the item has been archived
    var fire = function fire(event) {
      if (state.released || state.frozen) return;
      for (
        var _len = arguments.length,
          params = new Array(_len > 1 ? _len - 1 : 0),
          _key = 1;
        _key < _len;
        _key++
      ) {
        params[_key - 1] = arguments[_key];
      }
      api.fire.apply(api, [event].concat(params));
    };

    // file data
    var getFileExtension = function getFileExtension() {
      return getExtensionFromFilename(state.file.name);
    };
    var getFileType = function getFileType() {
      return state.file.type;
    };
    var getFileSize = function getFileSize() {
      return state.file.size;
    };
    var getFile = function getFile() {
      return state.file;
    };

    //
    // logic to load a file
    //
    var load = function load(source, loader, onload) {
      // remember the original item source
      state.source = source;

      // source is known
      api.fireSync('init');

      // file stub is already there
      if (state.file) {
        api.fireSync('load-skip');
        return;
      }

      // set a stub file object while loading the actual data
      state.file = createFileStub(source);

      // starts loading
      loader.on('init', function() {
        fire('load-init');
      });

      // we'eve received a size indication, let's update the stub
      loader.on('meta', function(meta) {
        // set size of file stub
        state.file.size = meta.size;

        // set name of file stub
        state.file.filename = meta.filename;

        // if has received source, we done
        if (meta.source) {
          origin = FileOrigin.LIMBO;
          state.serverFileReference = meta.source;
          state.status = ItemStatus.PROCESSING_COMPLETE;
        }

        // size has been updated
        fire('load-meta');
      });

      // the file is now loading we need to update the progress indicators
      loader.on('progress', function(progress) {
        setStatus(ItemStatus.LOADING);

        fire('load-progress', progress);
      });

      // an error was thrown while loading the file, we need to switch to error state
      loader.on('error', function(error) {
        setStatus(ItemStatus.LOAD_ERROR);

        fire('load-request-error', error);
      });

      // user or another process aborted the file load (cannot retry)
      loader.on('abort', function() {
        setStatus(ItemStatus.INIT);
        fire('load-abort');
      });

      // done loading
      loader.on('load', function(file) {
        // as we've now loaded the file the loader is no longer required
        state.activeLoader = null;

        // called when file has loaded succesfully
        var success = function success(result) {
          // set (possibly) transformed file
          state.file = isFile(result) ? result : state.file;

          // file received
          if (origin === FileOrigin.LIMBO && state.serverFileReference) {
            setStatus(ItemStatus.PROCESSING_COMPLETE);
          } else {
            setStatus(ItemStatus.IDLE);
          }

          fire('load');
        };

        var error = function error(result) {
          // set original file
          state.file = file;
          fire('load-meta');

          setStatus(ItemStatus.LOAD_ERROR);
          fire('load-file-error', result);
        };

        // if we already have a server file reference, we don't need to call the onload method
        if (state.serverFileReference) {
          success(file);
          return;
        }

        // no server id, let's give this file the full treatment
        onload(file, success, error);
      });

      // set loader source data
      loader.setSource(source);

      // set as active loader
      state.activeLoader = loader;

      // load the source data
      loader.load();
    };

    var retryLoad = function retryLoad() {
      if (!state.activeLoader) {
        return;
      }
      state.activeLoader.load();
    };

    var abortLoad = function abortLoad() {
      if (state.activeLoader) {
        state.activeLoader.abort();
        return;
      }
      setStatus(ItemStatus.INIT);
      fire('load-abort');
    };

    //
    // logic to process a file
    //
    var process = function process(processor, onprocess) {
      // processing was aborted
      if (state.processingAborted) {
        state.processingAborted = false;
        return;
      }

      // now processing
      setStatus(ItemStatus.PROCESSING);

      // reset abort callback
      abortProcessingRequestComplete = null;

      // if no file loaded we'll wait for the load event
      if (!(state.file instanceof Blob)) {
        api.on('load', function() {
          process(processor, onprocess);
        });
        return;
      }

      // setup processor
      processor.on('load', function(serverFileReference) {
        // need this id to be able to revert the upload
        state.transferId = null;
        state.serverFileReference = serverFileReference;
      });

      // register transfer id
      processor.on('transfer', function(transferId) {
        // need this id to be able to revert the upload
        state.transferId = transferId;
      });

      processor.on('load-perceived', function(serverFileReference) {
        // no longer required
        state.activeProcessor = null;

        // need this id to be able to rever the upload
        state.transferId = null;
        state.serverFileReference = serverFileReference;

        setStatus(ItemStatus.PROCESSING_COMPLETE);
        fire('process-complete', serverFileReference);
      });

      processor.on('start', function() {
        fire('process-start');
      });

      processor.on('error', function(error) {
        state.activeProcessor = null;
        setStatus(ItemStatus.PROCESSING_ERROR);
        fire('process-error', error);
      });

      processor.on('abort', function(serverFileReference) {
        state.activeProcessor = null;

        // if file was uploaded but processing was cancelled during perceived processor time store file reference
        state.transferId = null;
        state.serverFileReference = serverFileReference;

        setStatus(ItemStatus.IDLE);
        fire('process-abort');

        // has timeout so doesn't interfere with remove action
        if (abortProcessingRequestComplete) {
          abortProcessingRequestComplete();
        }
      });

      processor.on('progress', function(progress) {
        fire('process-progress', progress);
      });

      // when successfully transformed
      var success = function success(file) {
        // if was archived in the mean time, don't process
        if (state.archived) return;

        // process file!
        processor.process(file, Object.assign({}, metadata));
      };

      // something went wrong during transform phase
      var error = console.error;

      // start processing the file
      onprocess(state.file, success, error);

      // set as active processor
      state.activeProcessor = processor;
    };

    var requestProcessing = function requestProcessing() {
      state.processingAborted = false;
      setStatus(ItemStatus.PROCESSING_QUEUED);
    };

    var abortProcessing = function abortProcessing() {
      return new Promise(function(resolve) {
        if (!state.activeProcessor) {
          state.processingAborted = true;

          setStatus(ItemStatus.IDLE);
          fire('process-abort');

          resolve();
          return;
        }

        abortProcessingRequestComplete = function abortProcessingRequestComplete() {
          resolve();
        };

        state.activeProcessor.abort();
      });
    };

    //
    // logic to revert a processed file
    //
    var revert = function revert(revertFileUpload, forceRevert) {
      return new Promise(function(resolve, reject) {
        // cannot revert without a server id for this process
        if (state.serverFileReference === null) {
          resolve();
          return;
        }

        // revert the upload (fire and forget)
        revertFileUpload(
          state.serverFileReference,
          function() {
            // reset file server id as now it's no available on the server
            state.serverFileReference = null;
            resolve();
          },
          function(error) {
            // don't set error state when reverting is optional, it will always resolve
            if (!forceRevert) {
              resolve();
              return;
            }

            // oh no errors
            setStatus(ItemStatus.PROCESSING_REVERT_ERROR);
            fire('process-revert-error');
            reject(error);
          }
        );

        // fire event
        setStatus(ItemStatus.IDLE);
        fire('process-revert');
      });
    };

    // exposed methods
    var _setMetadata = function setMetadata(key, value, silent) {
      var keys = key.split('.');
      var root = keys[0];
      var last = keys.pop();
      var data = metadata;
      keys.forEach(function(key) {
        return (data = data[key]);
      });

      // compare old value against new value, if they're the same, we're not updating
      if (JSON.stringify(data[last]) === JSON.stringify(value)) return;

      // update value
      data[last] = value;

      // don't fire update
      if (silent) return;

      // fire update
      fire('metadata-update', {
        key: root,
        value: metadata[root]
      });
    };

    var getMetadata = function getMetadata(key) {
      return deepCloneObject(key ? metadata[key] : metadata);
    };

    var api = Object.assign(
      {
        id: {
          get: function get() {
            return id;
          }
        },
        origin: {
          get: function get() {
            return origin;
          }
        },
        serverId: {
          get: function get() {
            return state.serverFileReference;
          }
        },
        transferId: {
          get: function get() {
            return state.transferId;
          }
        },
        status: {
          get: function get() {
            return state.status;
          }
        },
        filename: {
          get: function get() {
            return state.file.name;
          }
        },
        filenameWithoutExtension: {
          get: function get() {
            return getFilenameWithoutExtension(state.file.name);
          }
        },
        fileExtension: { get: getFileExtension },
        fileType: { get: getFileType },
        fileSize: { get: getFileSize },
        file: { get: getFile },
        relativePath: {
          get: function get() {
            return state.file._relativePath;
          }
        },

        source: {
          get: function get() {
            return state.source;
          }
        },

        getMetadata: getMetadata,
        setMetadata: function setMetadata(key, value, silent) {
          if (isObject(key)) {
            var data = key;
            Object.keys(data).forEach(function(key) {
              _setMetadata(key, data[key], value);
            });
            return key;
          }
          _setMetadata(key, value, silent);
          return value;
        },

        extend: function extend(name, handler) {
          return (itemAPI[name] = handler);
        },

        abortLoad: abortLoad,
        retryLoad: retryLoad,
        requestProcessing: requestProcessing,
        abortProcessing: abortProcessing,

        load: load,
        process: process,
        revert: revert
      },

      on(),
      {
        freeze: function freeze() {
          return (state.frozen = true);
        },

        release: function release() {
          return (state.released = true);
        },
        released: {
          get: function get() {
            return state.released;
          }
        },

        archive: function archive() {
          return (state.archived = true);
        },
        archived: {
          get: function get() {
            return state.archived;
          }
        }
      }
    );

    // create it here instead of returning it instantly so we can extend it later
    var itemAPI = createObject(api);

    return itemAPI;
  };

  var getItemIndexByQuery = function getItemIndexByQuery(items, query) {
    // just return first index
    if (isEmpty(query)) {
      return 0;
    }

    // invalid queries
    if (!isString(query)) {
      return -1;
    }

    // return item by id (or -1 if not found)
    return items.findIndex(function(item) {
      return item.id === query;
    });
  };

  var getItemById = function getItemById(items, itemId) {
    var index = getItemIndexByQuery(items, itemId);
    if (index < 0) {
      return;
    }
    return items[index] || null;
  };

  var fetchBlob = function fetchBlob(
    url,
    load,
    error,
    progress,
    abort,
    headers
  ) {
    var request = sendRequest(null, url, {
      method: 'GET',
      responseType: 'blob'
    });

    request.onload = function(xhr) {
      // get headers
      var headers = xhr.getAllResponseHeaders();

      // get filename
      var filename =
        getFileInfoFromHeaders(headers).name || getFilenameFromURL(url);

      // create response
      load(
        createResponse(
          'load',
          xhr.status,
          getFileFromBlob(xhr.response, filename),
          headers
        )
      );
    };

    request.onerror = function(xhr) {
      error(
        createResponse(
          'error',
          xhr.status,
          xhr.statusText,
          xhr.getAllResponseHeaders()
        )
      );
    };

    request.onheaders = function(xhr) {
      headers(
        createResponse('headers', xhr.status, null, xhr.getAllResponseHeaders())
      );
    };

    request.ontimeout = createTimeoutResponse(error);
    request.onprogress = progress;
    request.onabort = abort;

    // should return request
    return request;
  };

  var getDomainFromURL = function getDomainFromURL(url) {
    if (url.indexOf('//') === 0) {
      url = location.protocol + url;
    }
    return url
      .toLowerCase()
      .replace('blob:', '')
      .replace(/([a-z])?:\/\//, '$1')
      .split('/')[0];
  };

  var isExternalURL = function isExternalURL(url) {
    return (
      (url.indexOf(':') > -1 || url.indexOf('//') > -1) &&
      getDomainFromURL(location.href) !== getDomainFromURL(url)
    );
  };

  var dynamicLabel = function dynamicLabel(label) {
    return function() {
      return isFunction(label) ? label.apply(void 0, arguments) : label;
    };
  };

  var isMockItem = function isMockItem(item) {
    return !isFile(item.file);
  };

  var listUpdated = function listUpdated(dispatch, state) {
    clearTimeout(state.listUpdateTimeout);
    state.listUpdateTimeout = setTimeout(function() {
      dispatch('DID_UPDATE_ITEMS', { items: getActiveItems(state.items) });
    }, 0);
  };

  var optionalPromise = function optionalPromise(fn) {
    for (
      var _len = arguments.length,
        params = new Array(_len > 1 ? _len - 1 : 0),
        _key = 1;
      _key < _len;
      _key++
    ) {
      params[_key - 1] = arguments[_key];
    }
    return new Promise(function(resolve) {
      if (!fn) {
        return resolve(true);
      }

      var result = fn.apply(void 0, params);

      if (result == null) {
        return resolve(true);
      }

      if (typeof result === 'boolean') {
        return resolve(result);
      }

      if (typeof result.then === 'function') {
        result.then(resolve);
      }
    });
  };

  var sortItems = function sortItems(state, compare) {
    state.items.sort(function(a, b) {
      return compare(createItemAPI(a), createItemAPI(b));
    });
  };

  // returns item based on state
  var getItemByQueryFromState = function getItemByQueryFromState(
    state,
    itemHandler
  ) {
    return function() {
      var _ref =
        arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var query = _ref.query,
        _ref$success = _ref.success,
        success = _ref$success === void 0 ? function() {} : _ref$success,
        _ref$failure = _ref.failure,
        failure = _ref$failure === void 0 ? function() {} : _ref$failure,
        options = _objectWithoutProperties(_ref, [
          'query',
          'success',
          'failure'
        ]);
      var item = getItemByQuery(state.items, query);
      if (!item) {
        failure({
          error: createResponse('error', 0, 'Item not found'),

          file: null
        });

        return;
      }
      itemHandler(item, success, failure, options || {});
    };
  };

  var actions = function actions(dispatch, query, state) {
    return {
      /**
       * Aborts all ongoing processes
       */
      ABORT_ALL: function ABORT_ALL() {
        getActiveItems(state.items).forEach(function(item) {
          item.freeze();
          item.abortLoad();
          item.abortProcessing();
        });
      },

      /**
       * Sets initial files
       */
      DID_SET_FILES: function DID_SET_FILES(_ref2) {
        var _ref2$value = _ref2.value,
          value = _ref2$value === void 0 ? [] : _ref2$value;

        // map values to file objects
        var files = value.map(function(file) {
          return {
            source: file.source ? file.source : file,
            options: file.options
          };
        });

        // loop over files, if file is in list, leave it be, if not, remove
        // test if items should be moved
        var activeItems = getActiveItems(state.items);

        activeItems.forEach(function(item) {
          // if item not is in new value, remove
          if (
            !files.find(function(file) {
              return file.source === item.source || file.source === item.file;
            })
          ) {
            dispatch('REMOVE_ITEM', { query: item, remove: false });
          }
        });

        // add new files
        activeItems = getActiveItems(state.items);
        files.forEach(function(file, index) {
          // if file is already in list
          if (
            activeItems.find(function(item) {
              return item.source === file.source || item.file === file.source;
            })
          )
            return;

          // not in list, add
          dispatch(
            'ADD_ITEM',
            Object.assign({}, file, {
              interactionMethod: InteractionMethod.NONE,
              index: index
            })
          );
        });
      },

      DID_UPDATE_ITEM_METADATA: function DID_UPDATE_ITEM_METADATA(_ref3) {
        var id = _ref3.id,
          action = _ref3.action;

        // if is called multiple times in close succession we combined all calls together to save resources
        clearTimeout(state.itemUpdateTimeout);
        state.itemUpdateTimeout = setTimeout(function() {
          var item = getItemById(state.items, id);

          // only revert and attempt to upload when we're uploading to a server
          if (!query('IS_ASYNC')) {
            // should we update the output data
            applyFilterChain('SHOULD_PREPARE_OUTPUT', false, {
              item: item,
              query: query,
              action: action
            }).then(function(shouldPrepareOutput) {
              // plugins determined the output data should be prepared (or not), can be adjusted with beforePrepareOutput hook
              var beforePrepareFile = query('GET_BEFORE_PREPARE_FILE');
              if (beforePrepareFile)
                shouldPrepareOutput = beforePrepareFile(
                  item,
                  shouldPrepareOutput
                );

              if (!shouldPrepareOutput) return;

              dispatch(
                'REQUEST_PREPARE_OUTPUT',
                {
                  query: id,
                  item: item,
                  success: function success(file) {
                    dispatch('DID_PREPARE_OUTPUT', { id: id, file: file });
                  }
                },
                true
              );
            });

            return;
          }

          // for async scenarios
          var upload = function upload() {
            // we push this forward a bit so the interface is updated correctly
            setTimeout(function() {
              dispatch('REQUEST_ITEM_PROCESSING', { query: id });
            }, 32);
          };

          var revert = function revert(doUpload) {
            item
              .revert(
                createRevertFunction(
                  state.options.server.url,
                  state.options.server.revert
                ),
                query('GET_FORCE_REVERT')
              )
              .then(doUpload ? upload : function() {})
              .catch(function() {});
          };

          var abort = function abort(doUpload) {
            item.abortProcessing().then(doUpload ? upload : function() {});
          };

          // if we should re-upload the file immediately
          if (item.status === ItemStatus.PROCESSING_COMPLETE) {
            return revert(state.options.instantUpload);
          }

          // if currently uploading, cancel upload
          if (item.status === ItemStatus.PROCESSING) {
            return abort(state.options.instantUpload);
          }

          if (state.options.instantUpload) {
            upload();
          }
        }, 0);
      },

      MOVE_ITEM: function MOVE_ITEM(_ref4) {
        var query = _ref4.query,
          index = _ref4.index;
        var item = getItemByQuery(state.items, query);
        if (!item) return;
        var currentIndex = state.items.indexOf(item);
        index = limit(index, 0, state.items.length - 1);
        if (currentIndex === index) return;
        state.items.splice(index, 0, state.items.splice(currentIndex, 1)[0]);
      },

      SORT: function SORT(_ref5) {
        var compare = _ref5.compare;
        sortItems(state, compare);
        dispatch('DID_SORT_ITEMS', {
          items: query('GET_ACTIVE_ITEMS')
        });
      },

      ADD_ITEMS: function ADD_ITEMS(_ref6) {
        var items = _ref6.items,
          index = _ref6.index,
          interactionMethod = _ref6.interactionMethod,
          _ref6$success = _ref6.success,
          success = _ref6$success === void 0 ? function() {} : _ref6$success,
          _ref6$failure = _ref6.failure,
          failure = _ref6$failure === void 0 ? function() {} : _ref6$failure;

        var currentIndex = index;

        if (index === -1 || typeof index === 'undefined') {
          var insertLocation = query('GET_ITEM_INSERT_LOCATION');
          var totalItems = query('GET_TOTAL_ITEMS');
          currentIndex = insertLocation === 'before' ? 0 : totalItems;
        }

        var ignoredFiles = query('GET_IGNORED_FILES');
        var isValidFile = function isValidFile(source) {
          return isFile(source)
            ? !ignoredFiles.includes(source.name.toLowerCase())
            : !isEmpty(source);
        };
        var validItems = items.filter(isValidFile);

        var promises = validItems.map(function(source) {
          return new Promise(function(resolve, reject) {
            dispatch('ADD_ITEM', {
              interactionMethod: interactionMethod,
              source: source.source || source,
              success: resolve,
              failure: reject,
              index: currentIndex++,
              options: source.options || {}
            });
          });
        });

        Promise.all(promises)
          .then(success)
          .catch(failure);
      },

      /**
       * @param source
       * @param index
       * @param interactionMethod
       */
      ADD_ITEM: function ADD_ITEM(_ref7) {
        var source = _ref7.source,
          _ref7$index = _ref7.index,
          index = _ref7$index === void 0 ? -1 : _ref7$index,
          interactionMethod = _ref7.interactionMethod,
          _ref7$success = _ref7.success,
          success = _ref7$success === void 0 ? function() {} : _ref7$success,
          _ref7$failure = _ref7.failure,
          failure = _ref7$failure === void 0 ? function() {} : _ref7$failure,
          _ref7$options = _ref7.options,
          options = _ref7$options === void 0 ? {} : _ref7$options;

        // if no source supplied
        if (isEmpty(source)) {
          failure({
            error: createResponse('error', 0, 'No source'),

            file: null
          });

          return;
        }

        // filter out invalid file items, used to filter dropped directory contents
        if (
          isFile(source) &&
          state.options.ignoredFiles.includes(source.name.toLowerCase())
        ) {
          // fail silently
          return;
        }

        // test if there's still room in the list of files
        if (!hasRoomForItem(state)) {
          // if multiple allowed, we can't replace
          // or if only a single item is allowed but we're not allowed to replace it we exit
          if (
            state.options.allowMultiple ||
            (!state.options.allowMultiple && !state.options.allowReplace)
          ) {
            var error = createResponse('warning', 0, 'Max files');

            dispatch('DID_THROW_MAX_FILES', {
              source: source,
              error: error
            });

            failure({ error: error, file: null });

            return;
          }

          // let's replace the item
          // id of first item we're about to remove
          var _item = getActiveItems(state.items)[0];

          // if has been processed remove it from the server as well
          if (
            _item.status === ItemStatus.PROCESSING_COMPLETE ||
            _item.status === ItemStatus.PROCESSING_REVERT_ERROR
          ) {
            var forceRevert = query('GET_FORCE_REVERT');
            _item
              .revert(
                createRevertFunction(
                  state.options.server.url,
                  state.options.server.revert
                ),
                forceRevert
              )
              .then(function() {
                if (!forceRevert) return;

                // try to add now
                dispatch('ADD_ITEM', {
                  source: source,
                  index: index,
                  interactionMethod: interactionMethod,
                  success: success,
                  failure: failure,
                  options: options
                });
              })
              .catch(function() {}); // no need to handle this catch state for now

            if (forceRevert) return;
          }

          // remove first item as it will be replaced by this item
          dispatch('REMOVE_ITEM', { query: _item.id });
        }

        // where did the file originate
        var origin =
          options.type === 'local'
            ? FileOrigin.LOCAL
            : options.type === 'limbo'
            ? FileOrigin.LIMBO
            : FileOrigin.INPUT;

        // create a new blank item
        var item = createItem(
          // where did this file come from
          origin,

          // an input file never has a server file reference
          origin === FileOrigin.INPUT ? null : source,

          // file mock data, if defined
          options.file
        );

        // set initial meta data
        Object.keys(options.metadata || {}).forEach(function(key) {
          item.setMetadata(key, options.metadata[key]);
        });

        // created the item, let plugins add methods
        applyFilters('DID_CREATE_ITEM', item, {
          query: query,
          dispatch: dispatch
        });

        // where to insert new items
        var itemInsertLocation = query('GET_ITEM_INSERT_LOCATION');

        // adjust index if is not allowed to pick location
        if (!state.options.itemInsertLocationFreedom) {
          index = itemInsertLocation === 'before' ? -1 : state.items.length;
        }

        // add item to list
        insertItem(state.items, item, index);

        // sort items in list
        if (isFunction(itemInsertLocation) && source) {
          sortItems(state, itemInsertLocation);
        }

        // get a quick reference to the item id
        var id = item.id;

        // observe item events
        item.on('init', function() {
          dispatch('DID_INIT_ITEM', { id: id });
        });

        item.on('load-init', function() {
          dispatch('DID_START_ITEM_LOAD', { id: id });
        });

        item.on('load-meta', function() {
          dispatch('DID_UPDATE_ITEM_META', { id: id });
        });

        item.on('load-progress', function(progress) {
          dispatch('DID_UPDATE_ITEM_LOAD_PROGRESS', {
            id: id,
            progress: progress
          });
        });

        item.on('load-request-error', function(error) {
          var mainStatus = dynamicLabel(state.options.labelFileLoadError)(
            error
          );

          // is client error, no way to recover
          if (error.code >= 400 && error.code < 500) {
            dispatch('DID_THROW_ITEM_INVALID', {
              id: id,
              error: error,
              status: {
                main: mainStatus,
                sub: error.code + ' (' + error.body + ')'
              }
            });

            // reject the file so can be dealt with through API
            failure({ error: error, file: createItemAPI(item) });
            return;
          }

          // is possible server error, so might be possible to retry
          dispatch('DID_THROW_ITEM_LOAD_ERROR', {
            id: id,
            error: error,
            status: {
              main: mainStatus,
              sub: state.options.labelTapToRetry
            }
          });
        });

        item.on('load-file-error', function(error) {
          dispatch('DID_THROW_ITEM_INVALID', {
            id: id,
            error: error.status,
            status: error.status
          });

          failure({ error: error.status, file: createItemAPI(item) });
        });

        item.on('load-abort', function() {
          dispatch('REMOVE_ITEM', { query: id });
        });

        item.on('load-skip', function() {
          dispatch('COMPLETE_LOAD_ITEM', {
            query: id,
            item: item,
            data: {
              source: source,
              success: success
            }
          });
        });

        item.on('load', function() {
          var handleAdd = function handleAdd(shouldAdd) {
            // no should not add this file
            if (!shouldAdd) {
              dispatch('REMOVE_ITEM', {
                query: id
              });

              return;
            }

            // now interested in metadata updates
            item.on('metadata-update', function(change) {
              dispatch('DID_UPDATE_ITEM_METADATA', { id: id, change: change });
            });

            // let plugins decide if the output data should be prepared at this point
            // means we'll do this and wait for idle state
            applyFilterChain('SHOULD_PREPARE_OUTPUT', false, {
              item: item,
              query: query
            }).then(function(shouldPrepareOutput) {
              // plugins determined the output data should be prepared (or not), can be adjusted with beforePrepareOutput hook
              var beforePrepareFile = query('GET_BEFORE_PREPARE_FILE');
              if (beforePrepareFile)
                shouldPrepareOutput = beforePrepareFile(
                  item,
                  shouldPrepareOutput
                );

              var loadComplete = function loadComplete() {
                dispatch('COMPLETE_LOAD_ITEM', {
                  query: id,
                  item: item,
                  data: {
                    source: source,
                    success: success
                  }
                });

                listUpdated(dispatch, state);
              };

              // exit
              if (shouldPrepareOutput) {
                // wait for idle state and then run PREPARE_OUTPUT
                dispatch(
                  'REQUEST_PREPARE_OUTPUT',
                  {
                    query: id,
                    item: item,
                    success: function success(file) {
                      dispatch('DID_PREPARE_OUTPUT', { id: id, file: file });
                      loadComplete();
                    }
                  },
                  true
                );

                return;
              }

              loadComplete();
            });
          };

          // item loaded, allow plugins to
          // - read data (quickly)
          // - add metadata
          applyFilterChain('DID_LOAD_ITEM', item, {
            query: query,
            dispatch: dispatch
          })
            .then(function() {
              optionalPromise(
                query('GET_BEFORE_ADD_FILE'),
                createItemAPI(item)
              ).then(handleAdd);
            })
            .catch(function() {
              handleAdd(false);
            });
        });

        item.on('process-start', function() {
          dispatch('DID_START_ITEM_PROCESSING', { id: id });
        });

        item.on('process-progress', function(progress) {
          dispatch('DID_UPDATE_ITEM_PROCESS_PROGRESS', {
            id: id,
            progress: progress
          });
        });

        item.on('process-error', function(error) {
          dispatch('DID_THROW_ITEM_PROCESSING_ERROR', {
            id: id,
            error: error,
            status: {
              main: dynamicLabel(state.options.labelFileProcessingError)(error),
              sub: state.options.labelTapToRetry
            }
          });
        });

        item.on('process-revert-error', function(error) {
          dispatch('DID_THROW_ITEM_PROCESSING_REVERT_ERROR', {
            id: id,
            error: error,
            status: {
              main: dynamicLabel(state.options.labelFileProcessingRevertError)(
                error
              ),
              sub: state.options.labelTapToRetry
            }
          });
        });

        item.on('process-complete', function(serverFileReference) {
          dispatch('DID_COMPLETE_ITEM_PROCESSING', {
            id: id,
            error: null,
            serverFileReference: serverFileReference
          });

          dispatch('DID_DEFINE_VALUE', { id: id, value: serverFileReference });
        });

        item.on('process-abort', function() {
          dispatch('DID_ABORT_ITEM_PROCESSING', { id: id });
        });

        item.on('process-revert', function() {
          dispatch('DID_REVERT_ITEM_PROCESSING', { id: id });
          dispatch('DID_DEFINE_VALUE', { id: id, value: null });
        });

        // let view know the item has been inserted
        dispatch('DID_ADD_ITEM', {
          id: id,
          index: index,
          interactionMethod: interactionMethod
        });

        listUpdated(dispatch, state);

        // start loading the source
        var _ref8 = state.options.server || {},
          url = _ref8.url,
          load = _ref8.load,
          restore = _ref8.restore,
          fetch = _ref8.fetch;

        item.load(
          source,

          // this creates a function that loads the file based on the type of file (string, base64, blob, file) and location of file (local, remote, limbo)
          createFileLoader(
            origin === FileOrigin.INPUT
              ? // input, if is remote, see if should use custom fetch, else use default fetchBlob
                isString(source) && isExternalURL(source)
                ? fetch
                  ? createFetchFunction(url, fetch)
                  : fetchBlob // remote url
                : fetchBlob // try to fetch url
              : // limbo or local
              origin === FileOrigin.LIMBO
              ? createFetchFunction(url, restore) // limbo
              : createFetchFunction(url, load) // local
          ),

          // called when the file is loaded so it can be piped through the filters
          function(file, success, error) {
            // let's process the file
            applyFilterChain('LOAD_FILE', file, { query: query })
              .then(success)
              .catch(error);
          }
        );
      },

      REQUEST_PREPARE_OUTPUT: function REQUEST_PREPARE_OUTPUT(_ref9) {
        var item = _ref9.item,
          success = _ref9.success,
          _ref9$failure = _ref9.failure,
          failure = _ref9$failure === void 0 ? function() {} : _ref9$failure;

        // error response if item archived
        var err = {
          error: createResponse('error', 0, 'Item not found'),

          file: null
        };

        // don't handle archived items, an item could have been archived (load aborted) while waiting to be prepared
        if (item.archived) return failure(err);

        // allow plugins to alter the file data
        applyFilterChain('PREPARE_OUTPUT', item.file, {
          query: query,
          item: item
        }).then(function(result) {
          applyFilterChain('COMPLETE_PREPARE_OUTPUT', result, {
            query: query,
            item: item
          }).then(function(result) {
            // don't handle archived items, an item could have been archived (load aborted) while being prepared
            if (item.archived) return failure(err);

            // we done!
            success(result);
          });
        });
      },

      COMPLETE_LOAD_ITEM: function COMPLETE_LOAD_ITEM(_ref10) {
        var item = _ref10.item,
          data = _ref10.data;
        var success = data.success,
          source = data.source;

        // sort items in list
        var itemInsertLocation = query('GET_ITEM_INSERT_LOCATION');
        if (isFunction(itemInsertLocation) && source) {
          sortItems(state, itemInsertLocation);
        }

        // let interface know the item has loaded
        dispatch('DID_LOAD_ITEM', {
          id: item.id,
          error: null,
          serverFileReference: item.origin === FileOrigin.INPUT ? null : source
        });

        // item has been successfully loaded and added to the
        // list of items so can now be safely returned for use
        success(createItemAPI(item));

        // if this is a local server file we need to show a different state
        if (item.origin === FileOrigin.LOCAL) {
          dispatch('DID_LOAD_LOCAL_ITEM', { id: item.id });
          return;
        }

        // if is a temp server file we prevent async upload call here (as the file is already on the server)
        if (item.origin === FileOrigin.LIMBO) {
          dispatch('DID_COMPLETE_ITEM_PROCESSING', {
            id: item.id,
            error: null,
            serverFileReference: source
          });

          dispatch('DID_DEFINE_VALUE', {
            id: item.id,
            value: source
          });

          return;
        }

        // id we are allowed to upload the file immediately, lets do it
        if (query('IS_ASYNC') && state.options.instantUpload) {
          dispatch('REQUEST_ITEM_PROCESSING', { query: item.id });
        }
      },

      RETRY_ITEM_LOAD: getItemByQueryFromState(state, function(item) {
        // try loading the source one more time
        item.retryLoad();
      }),

      REQUEST_ITEM_PREPARE: getItemByQueryFromState(state, function(
        item,
        _success,
        failure
      ) {
        dispatch(
          'REQUEST_PREPARE_OUTPUT',
          {
            query: item.id,
            item: item,
            success: function success(file) {
              dispatch('DID_PREPARE_OUTPUT', { id: item.id, file: file });
              _success({
                file: item,
                output: file
              });
            },
            failure: failure
          },
          true
        );
      }),

      REQUEST_ITEM_PROCESSING: getItemByQueryFromState(state, function(
        item,
        success,
        failure
      ) {
        // cannot be queued (or is already queued)
        var itemCanBeQueuedForProcessing =
          // waiting for something
          item.status === ItemStatus.IDLE ||
          // processing went wrong earlier
          item.status === ItemStatus.PROCESSING_ERROR;

        // not ready to be processed
        if (!itemCanBeQueuedForProcessing) {
          var processNow = function processNow() {
            return dispatch('REQUEST_ITEM_PROCESSING', {
              query: item,
              success: success,
              failure: failure
            });
          };

          var process = function process() {
            return document.hidden ? processNow() : setTimeout(processNow, 32);
          };

          // if already done processing or tried to revert but didn't work, try again
          if (
            item.status === ItemStatus.PROCESSING_COMPLETE ||
            item.status === ItemStatus.PROCESSING_REVERT_ERROR
          ) {
            item
              .revert(
                createRevertFunction(
                  state.options.server.url,
                  state.options.server.revert
                ),
                query('GET_FORCE_REVERT')
              )
              .then(process)
              .catch(function() {}); // don't continue with processing if something went wrong
          } else if (item.status === ItemStatus.PROCESSING) {
            item.abortProcessing().then(process);
          }

          return;
        }

        // already queued for processing
        if (item.status === ItemStatus.PROCESSING_QUEUED) return;

        item.requestProcessing();

        dispatch('DID_REQUEST_ITEM_PROCESSING', { id: item.id });

        dispatch(
          'PROCESS_ITEM',
          { query: item, success: success, failure: failure },
          true
        );
      }),

      PROCESS_ITEM: getItemByQueryFromState(state, function(
        item,
        success,
        failure
      ) {
        var maxParallelUploads = query('GET_MAX_PARALLEL_UPLOADS');
        var totalCurrentUploads = query(
          'GET_ITEMS_BY_STATUS',
          ItemStatus.PROCESSING
        ).length;

        // queue and wait till queue is freed up
        if (totalCurrentUploads === maxParallelUploads) {
          // queue for later processing
          state.processingQueue.push({
            id: item.id,
            success: success,
            failure: failure
          });

          // stop it!
          return;
        }

        // if was not queued or is already processing exit here
        if (item.status === ItemStatus.PROCESSING) return;

        var processNext = function processNext() {
          // process queueud items
          var queueEntry = state.processingQueue.shift();

          // no items left
          if (!queueEntry) return;

          // get item reference
          var id = queueEntry.id,
            success = queueEntry.success,
            failure = queueEntry.failure;
          var itemReference = getItemByQuery(state.items, id);

          // if item was archived while in queue, jump to next
          if (!itemReference || itemReference.archived) {
            processNext();
            return;
          }

          // process queued item
          dispatch(
            'PROCESS_ITEM',
            { query: id, success: success, failure: failure },
            true
          );
        };

        // we done function
        item.onOnce('process-complete', function() {
          success(createItemAPI(item));
          processNext();

          // All items processed? No errors?
          var allItemsProcessed =
            query('GET_ITEMS_BY_STATUS', ItemStatus.PROCESSING_COMPLETE)
              .length === state.items.length;
          if (allItemsProcessed) {
            dispatch('DID_COMPLETE_ITEM_PROCESSING_ALL');
          }
        });

        // we error function
        item.onOnce('process-error', function(error) {
          failure({ error: error, file: createItemAPI(item) });
          processNext();
        });

        // start file processing
        var options = state.options;
        item.process(
          createFileProcessor(
            createProcessorFunction(
              options.server.url,
              options.server.process,
              options.name,
              {
                chunkTransferId: item.transferId,
                chunkServer: options.server.patch,
                chunkUploads: options.chunkUploads,
                chunkForce: options.chunkForce,
                chunkSize: options.chunkSize,
                chunkRetryDelays: options.chunkRetryDelays
              }
            )
          ),

          // called when the file is about to be processed so it can be piped through the transform filters
          function(file, success, error) {
            // allow plugins to alter the file data
            applyFilterChain('PREPARE_OUTPUT', file, {
              query: query,
              item: item
            })
              .then(function(file) {
                dispatch('DID_PREPARE_OUTPUT', { id: item.id, file: file });

                success(file);
              })
              .catch(error);
          }
        );
      }),

      RETRY_ITEM_PROCESSING: getItemByQueryFromState(state, function(item) {
        dispatch('REQUEST_ITEM_PROCESSING', { query: item });
      }),

      REQUEST_REMOVE_ITEM: getItemByQueryFromState(state, function(item) {
        optionalPromise(
          query('GET_BEFORE_REMOVE_FILE'),
          createItemAPI(item)
        ).then(function(shouldRemove) {
          if (!shouldRemove) {
            return;
          }
          dispatch('REMOVE_ITEM', { query: item });
        });
      }),

      RELEASE_ITEM: getItemByQueryFromState(state, function(item) {
        item.release();
      }),

      REMOVE_ITEM: getItemByQueryFromState(state, function(
        item,
        success,
        failure,
        options
      ) {
        var removeFromView = function removeFromView() {
          // get id reference
          var id = item.id;

          // archive the item, this does not remove it from the list
          getItemById(state.items, id).archive();

          // tell the view the item has been removed
          dispatch('DID_REMOVE_ITEM', { error: null, id: id, item: item });

          // now the list has been modified
          listUpdated(dispatch, state);

          // correctly removed
          success(createItemAPI(item));
        };

        // if this is a local file and the server.remove function has been configured, send source there so dev can remove file from server
        var server = state.options.server;
        if (
          item.origin === FileOrigin.LOCAL &&
          server &&
          isFunction(server.remove) &&
          options.remove !== false
        ) {
          dispatch('DID_START_ITEM_REMOVE', { id: item.id });

          server.remove(
            item.source,
            function() {
              return removeFromView();
            },
            function(status) {
              dispatch('DID_THROW_ITEM_REMOVE_ERROR', {
                id: item.id,
                error: createResponse('error', 0, status, null),
                status: {
                  main: dynamicLabel(state.options.labelFileRemoveError)(
                    status
                  ),
                  sub: state.options.labelTapToRetry
                }
              });
            }
          );
        } else {
          // if is requesting revert and can revert need to call revert handler (not calling request_ because that would also trigger beforeRemoveHook)
          if (
            options.revert &&
            item.origin !== FileOrigin.LOCAL &&
            item.serverId !== null
          ) {
            item.revert(
              createRevertFunction(
                state.options.server.url,
                state.options.server.revert
              ),
              query('GET_FORCE_REVERT')
            );
          }

          // can now safely remove from view
          removeFromView();
        }
      }),

      ABORT_ITEM_LOAD: getItemByQueryFromState(state, function(item) {
        item.abortLoad();
      }),

      ABORT_ITEM_PROCESSING: getItemByQueryFromState(state, function(item) {
        // test if is already processed
        if (item.serverId) {
          dispatch('REVERT_ITEM_PROCESSING', { id: item.id });
          return;
        }

        // abort
        item.abortProcessing().then(function() {
          var shouldRemove = state.options.instantUpload;
          if (shouldRemove) {
            dispatch('REMOVE_ITEM', { query: item.id });
          }
        });
      }),

      REQUEST_REVERT_ITEM_PROCESSING: getItemByQueryFromState(state, function(
        item
      ) {
        // not instant uploading, revert immediately
        if (!state.options.instantUpload) {
          dispatch('REVERT_ITEM_PROCESSING', { query: item });
          return;
        }

        // if we're instant uploading the file will also be removed if we revert,
        // so if a before remove file hook is defined we need to run it now
        var handleRevert = function handleRevert(shouldRevert) {
          if (!shouldRevert) return;
          dispatch('REVERT_ITEM_PROCESSING', { query: item });
        };

        var fn = query('GET_BEFORE_REMOVE_FILE');
        if (!fn) {
          return handleRevert(true);
        }

        var requestRemoveResult = fn(createItemAPI(item));
        if (requestRemoveResult == null) {
          // undefined or null
          return handleRevert(true);
        }

        if (typeof requestRemoveResult === 'boolean') {
          return handleRevert(requestRemoveResult);
        }

        if (typeof requestRemoveResult.then === 'function') {
          requestRemoveResult.then(handleRevert);
        }
      }),

      REVERT_ITEM_PROCESSING: getItemByQueryFromState(state, function(item) {
        item
          .revert(
            createRevertFunction(
              state.options.server.url,
              state.options.server.revert
            ),
            query('GET_FORCE_REVERT')
          )
          .then(function() {
            var shouldRemove = state.options.instantUpload || isMockItem(item);
            if (shouldRemove) {
              dispatch('REMOVE_ITEM', { query: item.id });
            }
          })
          .catch(function() {});
      }),

      SET_OPTIONS: function SET_OPTIONS(_ref11) {
        var options = _ref11.options;
        forin(options, function(key, value) {
          dispatch('SET_' + fromCamels(key, '_').toUpperCase(), {
            value: value
          });
        });
      }
    };
  };

  var formatFilename = function formatFilename(name) {
    return name;
  };

  var createElement$1 = function createElement(tagName) {
    return document.createElement(tagName);
  };

  var text = function text(node, value) {
    var textNode = node.childNodes[0];
    if (!textNode) {
      textNode = document.createTextNode(value);
      node.appendChild(textNode);
    } else if (value !== textNode.nodeValue) {
      textNode.nodeValue = value;
    }
  };

  var polarToCartesian = function polarToCartesian(
    centerX,
    centerY,
    radius,
    angleInDegrees
  ) {
    var angleInRadians = (((angleInDegrees % 360) - 90) * Math.PI) / 180.0;
    return {
      x: centerX + radius * Math.cos(angleInRadians),
      y: centerY + radius * Math.sin(angleInRadians)
    };
  };

  var describeArc = function describeArc(
    x,
    y,
    radius,
    startAngle,
    endAngle,
    arcSweep
  ) {
    var start = polarToCartesian(x, y, radius, endAngle);
    var end = polarToCartesian(x, y, radius, startAngle);
    return [
      'M',
      start.x,
      start.y,
      'A',
      radius,
      radius,
      0,
      arcSweep,
      0,
      end.x,
      end.y
    ].join(' ');
  };

  var percentageArc = function percentageArc(x, y, radius, from, to) {
    var arcSweep = 1;
    if (to > from && to - from <= 0.5) {
      arcSweep = 0;
    }
    if (from > to && from - to >= 0.5) {
      arcSweep = 0;
    }
    return describeArc(
      x,
      y,
      radius,
      Math.min(0.9999, from) * 360,
      Math.min(0.9999, to) * 360,
      arcSweep
    );
  };

  var create = function create(_ref) {
    var root = _ref.root,
      props = _ref.props;
    // start at 0
    props.spin = false;
    props.progress = 0;
    props.opacity = 0;

    // svg
    var svg = createElement('svg');
    root.ref.path = createElement('path', {
      'stroke-width': 2,
      'stroke-linecap': 'round'
    });

    svg.appendChild(root.ref.path);

    root.ref.svg = svg;

    root.appendChild(svg);
  };

  var write = function write(_ref2) {
    var root = _ref2.root,
      props = _ref2.props;

    if (props.opacity === 0) {
      return;
    }

    if (props.align) {
      root.element.dataset.align = props.align;
    }

    // get width of stroke
    var ringStrokeWidth = parseInt(attr(root.ref.path, 'stroke-width'), 10);

    // calculate size of ring
    var size = root.rect.element.width * 0.5;

    // ring state
    var ringFrom = 0;
    var ringTo = 0;

    // now in busy mode
    if (props.spin) {
      ringFrom = 0;
      ringTo = 0.5;
    } else {
      ringFrom = 0;
      ringTo = props.progress;
    }

    // get arc path
    var coordinates = percentageArc(
      size,
      size,
      size - ringStrokeWidth,
      ringFrom,
      ringTo
    );

    // update progress bar
    attr(root.ref.path, 'd', coordinates);

    // hide while contains 0 value
    attr(
      root.ref.path,
      'stroke-opacity',
      props.spin || props.progress > 0 ? 1 : 0
    );
  };

  var progressIndicator = createView({
    tag: 'div',
    name: 'progress-indicator',
    ignoreRectUpdate: true,
    ignoreRect: true,
    create: create,
    write: write,
    mixins: {
      apis: ['progress', 'spin', 'align'],
      styles: ['opacity'],
      animations: {
        opacity: { type: 'tween', duration: 500 },
        progress: {
          type: 'spring',
          stiffness: 0.95,
          damping: 0.65,
          mass: 10
        }
      }
    }
  });

  var create$1 = function create(_ref) {
    var root = _ref.root,
      props = _ref.props;
    root.element.innerHTML =
      (props.icon || '') + ('<span>' + props.label + '</span>');

    props.isDisabled = false;
  };

  var write$1 = function write(_ref2) {
    var root = _ref2.root,
      props = _ref2.props;
    var isDisabled = props.isDisabled;
    var shouldDisable = root.query('GET_DISABLED') || props.opacity === 0;

    if (shouldDisable && !isDisabled) {
      props.isDisabled = true;
      attr(root.element, 'disabled', 'disabled');
    } else if (!shouldDisable && isDisabled) {
      props.isDisabled = false;
      root.element.removeAttribute('disabled');
    }
  };

  var fileActionButton = createView({
    tag: 'button',
    attributes: {
      type: 'button'
    },

    ignoreRect: true,
    ignoreRectUpdate: true,
    name: 'file-action-button',
    mixins: {
      apis: ['label'],
      styles: ['translateX', 'translateY', 'scaleX', 'scaleY', 'opacity'],
      animations: {
        scaleX: 'spring',
        scaleY: 'spring',
        translateX: 'spring',
        translateY: 'spring',
        opacity: { type: 'tween', duration: 250 }
      },

      listeners: true
    },

    create: create$1,
    write: write$1
  });

  var toNaturalFileSize = function toNaturalFileSize(bytes) {
    var decimalSeparator =
      arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '.';
    var base =
      arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1000;
    // no negative byte sizes
    bytes = Math.round(Math.abs(bytes));

    var KB = base;
    var MB = base * base;
    var GB = base * base * base;

    // just bytes
    if (bytes < KB) {
      return bytes + ' bytes';
    }

    // kilobytes
    if (bytes < MB) {
      return Math.floor(bytes / KB) + ' KB';
    }

    // megabytes
    if (bytes < GB) {
      return removeDecimalsWhenZero(bytes / MB, 1, decimalSeparator) + ' MB';
    }

    // gigabytes
    return removeDecimalsWhenZero(bytes / GB, 2, decimalSeparator) + ' GB';
  };

  var removeDecimalsWhenZero = function removeDecimalsWhenZero(
    value,
    decimalCount,
    separator
  ) {
    return value
      .toFixed(decimalCount)
      .split('.')
      .filter(function(part) {
        return part !== '0';
      })
      .join(separator);
  };

  var create$2 = function create(_ref) {
    var root = _ref.root,
      props = _ref.props;
    // filename
    var fileName = createElement$1('span');
    fileName.className = 'filepond--file-info-main';
    // hide for screenreaders
    // the file is contained in a fieldset with legend that contains the filename
    // no need to read it twice
    attr(fileName, 'aria-hidden', 'true');
    root.appendChild(fileName);
    root.ref.fileName = fileName;

    // filesize
    var fileSize = createElement$1('span');
    fileSize.className = 'filepond--file-info-sub';
    root.appendChild(fileSize);
    root.ref.fileSize = fileSize;

    // set initial values
    text(fileSize, root.query('GET_LABEL_FILE_WAITING_FOR_SIZE'));
    text(fileName, formatFilename(root.query('GET_ITEM_NAME', props.id)));
  };

  var updateFile = function updateFile(_ref2) {
    var root = _ref2.root,
      props = _ref2.props;
    text(
      root.ref.fileSize,
      toNaturalFileSize(
        root.query('GET_ITEM_SIZE', props.id),
        '.',
        root.query('GET_FILE_SIZE_BASE')
      )
    );

    text(
      root.ref.fileName,
      formatFilename(root.query('GET_ITEM_NAME', props.id))
    );
  };

  var updateFileSizeOnError = function updateFileSizeOnError(_ref3) {
    var root = _ref3.root,
      props = _ref3.props;
    // if size is available don't fallback to unknown size message
    if (isInt(root.query('GET_ITEM_SIZE', props.id))) {
      return;
    }

    text(root.ref.fileSize, root.query('GET_LABEL_FILE_SIZE_NOT_AVAILABLE'));
  };

  var fileInfo = createView({
    name: 'file-info',
    ignoreRect: true,
    ignoreRectUpdate: true,
    write: createRoute({
      DID_LOAD_ITEM: updateFile,
      DID_UPDATE_ITEM_META: updateFile,
      DID_THROW_ITEM_LOAD_ERROR: updateFileSizeOnError,
      DID_THROW_ITEM_INVALID: updateFileSizeOnError
    }),

    didCreateView: function didCreateView(root) {
      applyFilters('CREATE_VIEW', Object.assign({}, root, { view: root }));
    },
    create: create$2,
    mixins: {
      styles: ['translateX', 'translateY'],
      animations: {
        translateX: 'spring',
        translateY: 'spring'
      }
    }
  });

  var toPercentage = function toPercentage(value) {
    return Math.round(value * 100);
  };

  var create$3 = function create(_ref) {
    var root = _ref.root;

    // main status
    var main = createElement$1('span');
    main.className = 'filepond--file-status-main';
    root.appendChild(main);
    root.ref.main = main;

    // sub status
    var sub = createElement$1('span');
    sub.className = 'filepond--file-status-sub';
    root.appendChild(sub);
    root.ref.sub = sub;

    didSetItemLoadProgress({ root: root, action: { progress: null } });
  };

  var didSetItemLoadProgress = function didSetItemLoadProgress(_ref2) {
    var root = _ref2.root,
      action = _ref2.action;
    var title =
      action.progress === null
        ? root.query('GET_LABEL_FILE_LOADING')
        : root.query('GET_LABEL_FILE_LOADING') +
          ' ' +
          toPercentage(action.progress) +
          '%';

    text(root.ref.main, title);
    text(root.ref.sub, root.query('GET_LABEL_TAP_TO_CANCEL'));
  };

  var didSetItemProcessProgress = function didSetItemProcessProgress(_ref3) {
    var root = _ref3.root,
      action = _ref3.action;
    var title =
      action.progress === null
        ? root.query('GET_LABEL_FILE_PROCESSING')
        : root.query('GET_LABEL_FILE_PROCESSING') +
          ' ' +
          toPercentage(action.progress) +
          '%';

    text(root.ref.main, title);
    text(root.ref.sub, root.query('GET_LABEL_TAP_TO_CANCEL'));
  };

  var didRequestItemProcessing = function didRequestItemProcessing(_ref4) {
    var root = _ref4.root;
    text(root.ref.main, root.query('GET_LABEL_FILE_PROCESSING'));
    text(root.ref.sub, root.query('GET_LABEL_TAP_TO_CANCEL'));
  };

  var didAbortItemProcessing = function didAbortItemProcessing(_ref5) {
    var root = _ref5.root;
    text(root.ref.main, root.query('GET_LABEL_FILE_PROCESSING_ABORTED'));
    text(root.ref.sub, root.query('GET_LABEL_TAP_TO_RETRY'));
  };

  var didCompleteItemProcessing = function didCompleteItemProcessing(_ref6) {
    var root = _ref6.root;
    text(root.ref.main, root.query('GET_LABEL_FILE_PROCESSING_COMPLETE'));
    text(root.ref.sub, root.query('GET_LABEL_TAP_TO_UNDO'));
  };

  var clear = function clear(_ref7) {
    var root = _ref7.root;
    text(root.ref.main, '');
    text(root.ref.sub, '');
  };

  var error = function error(_ref8) {
    var root = _ref8.root,
      action = _ref8.action;
    text(root.ref.main, action.status.main);
    text(root.ref.sub, action.status.sub);
  };

  var fileStatus = createView({
    name: 'file-status',
    ignoreRect: true,
    ignoreRectUpdate: true,
    write: createRoute({
      DID_LOAD_ITEM: clear,
      DID_REVERT_ITEM_PROCESSING: clear,
      DID_REQUEST_ITEM_PROCESSING: didRequestItemProcessing,
      DID_ABORT_ITEM_PROCESSING: didAbortItemProcessing,
      DID_COMPLETE_ITEM_PROCESSING: didCompleteItemProcessing,
      DID_UPDATE_ITEM_PROCESS_PROGRESS: didSetItemProcessProgress,
      DID_UPDATE_ITEM_LOAD_PROGRESS: didSetItemLoadProgress,
      DID_THROW_ITEM_LOAD_ERROR: error,
      DID_THROW_ITEM_INVALID: error,
      DID_THROW_ITEM_PROCESSING_ERROR: error,
      DID_THROW_ITEM_PROCESSING_REVERT_ERROR: error,
      DID_THROW_ITEM_REMOVE_ERROR: error
    }),

    didCreateView: function didCreateView(root) {
      applyFilters('CREATE_VIEW', Object.assign({}, root, { view: root }));
    },
    create: create$3,
    mixins: {
      styles: ['translateX', 'translateY', 'opacity'],
      animations: {
        opacity: { type: 'tween', duration: 250 },
        translateX: 'spring',
        translateY: 'spring'
      }
    }
  });

  /**
   * Button definitions for the file view
   */

  var Buttons = {
    AbortItemLoad: {
      label: 'GET_LABEL_BUTTON_ABORT_ITEM_LOAD',
      action: 'ABORT_ITEM_LOAD',
      className: 'filepond--action-abort-item-load',
      align: 'LOAD_INDICATOR_POSITION' // right
    },
    RetryItemLoad: {
      label: 'GET_LABEL_BUTTON_RETRY_ITEM_LOAD',
      action: 'RETRY_ITEM_LOAD',
      icon: 'GET_ICON_RETRY',
      className: 'filepond--action-retry-item-load',
      align: 'BUTTON_PROCESS_ITEM_POSITION' // right
    },
    RemoveItem: {
      label: 'GET_LABEL_BUTTON_REMOVE_ITEM',
      action: 'REQUEST_REMOVE_ITEM',
      icon: 'GET_ICON_REMOVE',
      className: 'filepond--action-remove-item',
      align: 'BUTTON_REMOVE_ITEM_POSITION' // left
    },
    ProcessItem: {
      label: 'GET_LABEL_BUTTON_PROCESS_ITEM',
      action: 'REQUEST_ITEM_PROCESSING',
      icon: 'GET_ICON_PROCESS',
      className: 'filepond--action-process-item',
      align: 'BUTTON_PROCESS_ITEM_POSITION' // right
    },
    AbortItemProcessing: {
      label: 'GET_LABEL_BUTTON_ABORT_ITEM_PROCESSING',
      action: 'ABORT_ITEM_PROCESSING',
      className: 'filepond--action-abort-item-processing',
      align: 'BUTTON_PROCESS_ITEM_POSITION' // right
    },
    RetryItemProcessing: {
      label: 'GET_LABEL_BUTTON_RETRY_ITEM_PROCESSING',
      action: 'RETRY_ITEM_PROCESSING',
      icon: 'GET_ICON_RETRY',
      className: 'filepond--action-retry-item-processing',
      align: 'BUTTON_PROCESS_ITEM_POSITION' // right
    },
    RevertItemProcessing: {
      label: 'GET_LABEL_BUTTON_UNDO_ITEM_PROCESSING',
      action: 'REQUEST_REVERT_ITEM_PROCESSING',
      icon: 'GET_ICON_UNDO',
      className: 'filepond--action-revert-item-processing',
      align: 'BUTTON_PROCESS_ITEM_POSITION' // right
    }
  };

  // make a list of buttons, we can then remove buttons from this list if they're disabled
  var ButtonKeys = [];
  forin(Buttons, function(key) {
    ButtonKeys.push(key);
  });

  var calculateFileInfoOffset = function calculateFileInfoOffset(root) {
    var buttonRect = root.ref.buttonRemoveItem.rect.element;
    return buttonRect.hidden ? null : buttonRect.width + buttonRect.left;
  };

  var calculateButtonWidth = function calculateButtonWidth(root) {
    var buttonRect = root.ref.buttonAbortItemLoad.rect.element;
    return buttonRect.width;
  };

  // Force on full pixels so text stays crips
  var calculateFileVerticalCenterOffset = function calculateFileVerticalCenterOffset(
    root
  ) {
    return Math.floor(root.ref.buttonRemoveItem.rect.element.height / 4);
  };
  var calculateFileHorizontalCenterOffset = function calculateFileHorizontalCenterOffset(
    root
  ) {
    return Math.floor(root.ref.buttonRemoveItem.rect.element.left / 2);
  };

  var getLoadIndicatorAlignment = function getLoadIndicatorAlignment(root) {
    return root.query('GET_STYLE_LOAD_INDICATOR_POSITION');
  };
  var getProcessIndicatorAlignment = function getProcessIndicatorAlignment(
    root
  ) {
    return root.query('GET_STYLE_PROGRESS_INDICATOR_POSITION');
  };
  var getRemoveIndicatorAligment = function getRemoveIndicatorAligment(root) {
    return root.query('GET_STYLE_BUTTON_REMOVE_ITEM_POSITION');
  };

  var DefaultStyle = {
    buttonAbortItemLoad: { opacity: 0 },
    buttonRetryItemLoad: { opacity: 0 },
    buttonRemoveItem: { opacity: 0 },
    buttonProcessItem: { opacity: 0 },
    buttonAbortItemProcessing: { opacity: 0 },
    buttonRetryItemProcessing: { opacity: 0 },
    buttonRevertItemProcessing: { opacity: 0 },
    loadProgressIndicator: { opacity: 0, align: getLoadIndicatorAlignment },
    processProgressIndicator: {
      opacity: 0,
      align: getProcessIndicatorAlignment
    },
    processingCompleteIndicator: { opacity: 0, scaleX: 0.75, scaleY: 0.75 },
    info: { translateX: 0, translateY: 0, opacity: 0 },
    status: { translateX: 0, translateY: 0, opacity: 0 }
  };

  var IdleStyle = {
    buttonRemoveItem: { opacity: 1 },
    buttonProcessItem: { opacity: 1 },
    info: { translateX: calculateFileInfoOffset },
    status: { translateX: calculateFileInfoOffset }
  };

  var ProcessingStyle = {
    buttonAbortItemProcessing: { opacity: 1 },
    processProgressIndicator: { opacity: 1 },
    status: { opacity: 1 }
  };

  var StyleMap = {
    DID_THROW_ITEM_INVALID: {
      buttonRemoveItem: { opacity: 1 },
      info: { translateX: calculateFileInfoOffset },
      status: { translateX: calculateFileInfoOffset, opacity: 1 }
    },

    DID_START_ITEM_LOAD: {
      buttonAbortItemLoad: { opacity: 1 },
      loadProgressIndicator: { opacity: 1 },
      status: { opacity: 1 }
    },

    DID_THROW_ITEM_LOAD_ERROR: {
      buttonRetryItemLoad: { opacity: 1 },
      buttonRemoveItem: { opacity: 1 },
      info: { translateX: calculateFileInfoOffset },
      status: { opacity: 1 }
    },

    DID_START_ITEM_REMOVE: {
      processProgressIndicator: {
        opacity: 1,
        align: getRemoveIndicatorAligment
      },
      info: { translateX: calculateFileInfoOffset },
      status: { opacity: 0 }
    },

    DID_THROW_ITEM_REMOVE_ERROR: {
      processProgressIndicator: {
        opacity: 0,
        align: getRemoveIndicatorAligment
      },
      buttonRemoveItem: { opacity: 1 },
      info: { translateX: calculateFileInfoOffset },
      status: { opacity: 1, translateX: calculateFileInfoOffset }
    },

    DID_LOAD_ITEM: IdleStyle,
    DID_LOAD_LOCAL_ITEM: {
      buttonRemoveItem: { opacity: 1 },
      info: { translateX: calculateFileInfoOffset },
      status: { translateX: calculateFileInfoOffset }
    },

    DID_START_ITEM_PROCESSING: ProcessingStyle,
    DID_REQUEST_ITEM_PROCESSING: ProcessingStyle,
    DID_UPDATE_ITEM_PROCESS_PROGRESS: ProcessingStyle,
    DID_COMPLETE_ITEM_PROCESSING: {
      buttonRevertItemProcessing: { opacity: 1 },
      info: { opacity: 1 },
      status: { opacity: 1 }
    },

    DID_THROW_ITEM_PROCESSING_ERROR: {
      buttonRemoveItem: { opacity: 1 },
      buttonRetryItemProcessing: { opacity: 1 },
      status: { opacity: 1 },
      info: { translateX: calculateFileInfoOffset }
    },

    DID_THROW_ITEM_PROCESSING_REVERT_ERROR: {
      buttonRevertItemProcessing: { opacity: 1 },
      status: { opacity: 1 },
      info: { opacity: 1 }
    },

    DID_ABORT_ITEM_PROCESSING: {
      buttonRemoveItem: { opacity: 1 },
      buttonProcessItem: { opacity: 1 },
      info: { translateX: calculateFileInfoOffset },
      status: { opacity: 1 }
    },

    DID_REVERT_ITEM_PROCESSING: IdleStyle
  };

  // complete indicator view
  var processingCompleteIndicatorView = createView({
    create: function create(_ref) {
      var root = _ref.root;
      root.element.innerHTML = root.query('GET_ICON_DONE');
    },
    name: 'processing-complete-indicator',
    ignoreRect: true,
    mixins: {
      styles: ['scaleX', 'scaleY', 'opacity'],
      animations: {
        scaleX: 'spring',
        scaleY: 'spring',
        opacity: { type: 'tween', duration: 250 }
      }
    }
  });

  /**
   * Creates the file view
   */
  var create$4 = function create(_ref2) {
    var root = _ref2.root,
      props = _ref2.props;
    var id = props.id;

    // allow reverting upload
    var allowRevert = root.query('GET_ALLOW_REVERT');

    // allow remove file
    var allowRemove = root.query('GET_ALLOW_REMOVE');

    // allow processing upload
    var allowProcess = root.query('GET_ALLOW_PROCESS');

    // is instant uploading, need this to determine the icon of the undo button
    var instantUpload = root.query('GET_INSTANT_UPLOAD');

    // is async set up
    var isAsync = root.query('IS_ASYNC');

    // should align remove item buttons
    var alignRemoveItemButton = root.query(
      'GET_STYLE_BUTTON_REMOVE_ITEM_ALIGN'
    );

    // enabled buttons array
    var buttonFilter;
    if (isAsync) {
      if (allowProcess && !allowRevert) {
        // only remove revert button
        buttonFilter = function buttonFilter(key) {
          return !/RevertItemProcessing/.test(key);
        };
      } else if (!allowProcess && allowRevert) {
        // only remove process button
        buttonFilter = function buttonFilter(key) {
          return !/ProcessItem|RetryItemProcessing|AbortItemProcessing/.test(
            key
          );
        };
      } else if (!allowProcess && !allowRevert) {
        // remove all process buttons
        buttonFilter = function buttonFilter(key) {
          return !/Process/.test(key);
        };
      }
    } else {
      // no process controls available
      buttonFilter = function buttonFilter(key) {
        return !/Process/.test(key);
      };
    }

    var enabledButtons = buttonFilter
      ? ButtonKeys.filter(buttonFilter)
      : ButtonKeys.concat();

    // update icon and label for revert button when instant uploading
    if (instantUpload && allowRevert) {
      Buttons['RevertItemProcessing'].label = 'GET_LABEL_BUTTON_REMOVE_ITEM';
      Buttons['RevertItemProcessing'].icon = 'GET_ICON_REMOVE';
    }

    // remove last button (revert) if not allowed
    if (isAsync && !allowRevert) {
      var map = StyleMap['DID_COMPLETE_ITEM_PROCESSING'];
      map.info.translateX = calculateFileHorizontalCenterOffset;
      map.info.translateY = calculateFileVerticalCenterOffset;
      map.status.translateY = calculateFileVerticalCenterOffset;
      map.processingCompleteIndicator = { opacity: 1, scaleX: 1, scaleY: 1 };
    }

    // should align center
    if (isAsync && !allowProcess) {
      [
        'DID_START_ITEM_PROCESSING',
        'DID_REQUEST_ITEM_PROCESSING',
        'DID_UPDATE_ITEM_PROCESS_PROGRESS',
        'DID_THROW_ITEM_PROCESSING_ERROR'
      ].forEach(function(key) {
        StyleMap[key].status.translateY = calculateFileVerticalCenterOffset;
      });
      StyleMap[
        'DID_THROW_ITEM_PROCESSING_ERROR'
      ].status.translateX = calculateButtonWidth;
    }

    // move remove button to right
    if (alignRemoveItemButton && allowRevert) {
      Buttons['RevertItemProcessing'].align = 'BUTTON_REMOVE_ITEM_POSITION';
      var _map = StyleMap['DID_COMPLETE_ITEM_PROCESSING'];
      _map.info.translateX = calculateFileInfoOffset;
      _map.status.translateY = calculateFileVerticalCenterOffset;
      _map.processingCompleteIndicator = { opacity: 1, scaleX: 1, scaleY: 1 };
    }

    if (!allowRemove) {
      Buttons['RemoveItem'].disabled = true;
    }

    // create the button views
    forin(Buttons, function(key, definition) {
      // create button
      var buttonView = root.createChildView(fileActionButton, {
        label: root.query(definition.label),
        icon: root.query(definition.icon),
        opacity: 0
      });

      // should be appended?
      if (enabledButtons.includes(key)) {
        root.appendChildView(buttonView);
      }

      // toggle
      if (definition.disabled) {
        buttonView.element.setAttribute('disabled', 'disabled');
        buttonView.element.setAttribute('hidden', 'hidden');
      }

      // add position attribute
      buttonView.element.dataset.align = root.query(
        'GET_STYLE_' + definition.align
      );

      // add class
      buttonView.element.classList.add(definition.className);

      // handle interactions
      buttonView.on('click', function(e) {
        e.stopPropagation();
        if (definition.disabled) return;
        root.dispatch(definition.action, { query: id });
      });

      // set reference
      root.ref['button' + key] = buttonView;
    });

    // checkmark
    root.ref.processingCompleteIndicator = root.appendChildView(
      root.createChildView(processingCompleteIndicatorView)
    );
    root.ref.processingCompleteIndicator.element.dataset.align = root.query(
      'GET_STYLE_BUTTON_PROCESS_ITEM_POSITION'
    );

    // create file info view
    root.ref.info = root.appendChildView(
      root.createChildView(fileInfo, { id: id })
    );

    // create file status view
    root.ref.status = root.appendChildView(
      root.createChildView(fileStatus, { id: id })
    );

    // add progress indicators
    var loadIndicatorView = root.appendChildView(
      root.createChildView(progressIndicator, {
        opacity: 0,
        align: root.query('GET_STYLE_LOAD_INDICATOR_POSITION')
      })
    );

    loadIndicatorView.element.classList.add('filepond--load-indicator');
    root.ref.loadProgressIndicator = loadIndicatorView;

    var progressIndicatorView = root.appendChildView(
      root.createChildView(progressIndicator, {
        opacity: 0,
        align: root.query('GET_STYLE_PROGRESS_INDICATOR_POSITION')
      })
    );

    progressIndicatorView.element.classList.add('filepond--process-indicator');
    root.ref.processProgressIndicator = progressIndicatorView;

    // current active styles
    root.ref.activeStyles = [];
  };

  var write$2 = function write(_ref3) {
    var root = _ref3.root,
      actions = _ref3.actions,
      props = _ref3.props;

    // route actions
    route({ root: root, actions: actions, props: props });

    // select last state change action
    var action = actions
      .concat()
      .filter(function(action) {
        return /^DID_/.test(action.type);
      })
      .reverse()
      .find(function(action) {
        return StyleMap[action.type];
      });

    // a new action happened, let's get the matching styles
    if (action) {
      // define new active styles
      root.ref.activeStyles = [];

      var stylesToApply = StyleMap[action.type];
      forin(DefaultStyle, function(name, defaultStyles) {
        // get reference to control
        var control = root.ref[name];

        // loop over all styles for this control
        forin(defaultStyles, function(key, defaultValue) {
          var value =
            stylesToApply[name] &&
            typeof stylesToApply[name][key] !== 'undefined'
              ? stylesToApply[name][key]
              : defaultValue;
          root.ref.activeStyles.push({
            control: control,
            key: key,
            value: value
          });
        });
      });
    }

    // apply active styles to element
    root.ref.activeStyles.forEach(function(_ref4) {
      var control = _ref4.control,
        key = _ref4.key,
        value = _ref4.value;
      control[key] = typeof value === 'function' ? value(root) : value;
    });
  };

  var route = createRoute({
    DID_SET_LABEL_BUTTON_ABORT_ITEM_PROCESSING: function DID_SET_LABEL_BUTTON_ABORT_ITEM_PROCESSING(
      _ref5
    ) {
      var root = _ref5.root,
        action = _ref5.action;
      root.ref.buttonAbortItemProcessing.label = action.value;
    },
    DID_SET_LABEL_BUTTON_ABORT_ITEM_LOAD: function DID_SET_LABEL_BUTTON_ABORT_ITEM_LOAD(
      _ref6
    ) {
      var root = _ref6.root,
        action = _ref6.action;
      root.ref.buttonAbortItemLoad.label = action.value;
    },
    DID_SET_LABEL_BUTTON_ABORT_ITEM_REMOVAL: function DID_SET_LABEL_BUTTON_ABORT_ITEM_REMOVAL(
      _ref7
    ) {
      var root = _ref7.root,
        action = _ref7.action;
      root.ref.buttonAbortItemRemoval.label = action.value;
    },
    DID_REQUEST_ITEM_PROCESSING: function DID_REQUEST_ITEM_PROCESSING(_ref8) {
      var root = _ref8.root;
      root.ref.processProgressIndicator.spin = true;
      root.ref.processProgressIndicator.progress = 0;
    },
    DID_START_ITEM_LOAD: function DID_START_ITEM_LOAD(_ref9) {
      var root = _ref9.root;
      root.ref.loadProgressIndicator.spin = true;
      root.ref.loadProgressIndicator.progress = 0;
    },
    DID_START_ITEM_REMOVE: function DID_START_ITEM_REMOVE(_ref10) {
      var root = _ref10.root;
      root.ref.processProgressIndicator.spin = true;
      root.ref.processProgressIndicator.progress = 0;
    },
    DID_UPDATE_ITEM_LOAD_PROGRESS: function DID_UPDATE_ITEM_LOAD_PROGRESS(
      _ref11
    ) {
      var root = _ref11.root,
        action = _ref11.action;
      root.ref.loadProgressIndicator.spin = false;
      root.ref.loadProgressIndicator.progress = action.progress;
    },
    DID_UPDATE_ITEM_PROCESS_PROGRESS: function DID_UPDATE_ITEM_PROCESS_PROGRESS(
      _ref12
    ) {
      var root = _ref12.root,
        action = _ref12.action;
      root.ref.processProgressIndicator.spin = false;
      root.ref.processProgressIndicator.progress = action.progress;
    }
  });

  var file = createView({
    create: create$4,
    write: write$2,
    didCreateView: function didCreateView(root) {
      applyFilters('CREATE_VIEW', Object.assign({}, root, { view: root }));
    },
    name: 'file'
  });

  /**
   * Creates the file view
   */
  var create$5 = function create(_ref) {
    var root = _ref.root,
      props = _ref.props;

    // filename
    root.ref.fileName = createElement$1('legend');
    root.appendChild(root.ref.fileName);

    // file appended
    root.ref.file = root.appendChildView(
      root.createChildView(file, { id: props.id })
    );

    // data has moved to data.js
    root.ref.data = false;
  };

  /**
   * Data storage
   */
  var didLoadItem = function didLoadItem(_ref2) {
    var root = _ref2.root,
      props = _ref2.props;
    // updates the legend of the fieldset so screenreaders can better group buttons
    text(
      root.ref.fileName,
      formatFilename(root.query('GET_ITEM_NAME', props.id))
    );
  };

  var fileWrapper = createView({
    create: create$5,
    ignoreRect: true,
    write: createRoute({
      DID_LOAD_ITEM: didLoadItem
    }),

    didCreateView: function didCreateView(root) {
      applyFilters('CREATE_VIEW', Object.assign({}, root, { view: root }));
    },
    tag: 'fieldset',
    name: 'file-wrapper'
  });

  var PANEL_SPRING_PROPS = { type: 'spring', damping: 0.6, mass: 7 };

  var create$6 = function create(_ref) {
    var root = _ref.root,
      props = _ref.props;
    [
      {
        name: 'top'
      },

      {
        name: 'center',
        props: {
          translateY: null,
          scaleY: null
        },

        mixins: {
          animations: {
            scaleY: PANEL_SPRING_PROPS
          },

          styles: ['translateY', 'scaleY']
        }
      },

      {
        name: 'bottom',
        props: {
          translateY: null
        },

        mixins: {
          animations: {
            translateY: PANEL_SPRING_PROPS
          },

          styles: ['translateY']
        }
      }
    ].forEach(function(section) {
      createSection(root, section, props.name);
    });

    root.element.classList.add('filepond--' + props.name);

    root.ref.scalable = null;
  };

  var createSection = function createSection(root, section, className) {
    var viewConstructor = createView({
      name: 'panel-' + section.name + ' filepond--' + className,
      mixins: section.mixins,
      ignoreRectUpdate: true
    });

    var view = root.createChildView(viewConstructor, section.props);

    root.ref[section.name] = root.appendChildView(view);
  };

  var write$3 = function write(_ref2) {
    var root = _ref2.root,
      props = _ref2.props;

    // update scalable state
    if (root.ref.scalable === null || props.scalable !== root.ref.scalable) {
      root.ref.scalable = isBoolean(props.scalable) ? props.scalable : true;
      root.element.dataset.scalable = root.ref.scalable;
    }

    // no height, can't set
    if (!props.height) return;

    // get child rects
    var topRect = root.ref.top.rect.element;
    var bottomRect = root.ref.bottom.rect.element;

    // make sure height never is smaller than bottom and top seciton heights combined (will probably never happen, but who knows)
    var height = Math.max(topRect.height + bottomRect.height, props.height);

    // offset center part
    root.ref.center.translateY = topRect.height;

    // scale center part
    // use math ceil to prevent transparent lines because of rounding errors
    root.ref.center.scaleY =
      (height - topRect.height - bottomRect.height) / 100;

    // offset bottom part
    root.ref.bottom.translateY = height - bottomRect.height;
  };

  var panel = createView({
    name: 'panel',
    read: function read(_ref3) {
      var root = _ref3.root,
        props = _ref3.props;
      return (props.heightCurrent = root.ref.bottom.translateY);
    },
    write: write$3,
    create: create$6,
    ignoreRect: true,
    mixins: {
      apis: ['height', 'heightCurrent', 'scalable']
    }
  });

  var createDragHelper = function createDragHelper(items) {
    var itemIds = items.map(function(item) {
      return item.id;
    });
    var prevIndex = undefined;
    return {
      setIndex: function setIndex(index) {
        prevIndex = index;
      },
      getIndex: function getIndex() {
        return prevIndex;
      },
      getItemIndex: function getItemIndex(item) {
        return itemIds.indexOf(item.id);
      }
    };
  };

  var ITEM_TRANSLATE_SPRING = {
    type: 'spring',
    stiffness: 0.75,
    damping: 0.45,
    mass: 10
  };

  var ITEM_SCALE_SPRING = 'spring';

  var StateMap = {
    DID_START_ITEM_LOAD: 'busy',
    DID_UPDATE_ITEM_LOAD_PROGRESS: 'loading',
    DID_THROW_ITEM_INVALID: 'load-invalid',
    DID_THROW_ITEM_LOAD_ERROR: 'load-error',
    DID_LOAD_ITEM: 'idle',
    DID_THROW_ITEM_REMOVE_ERROR: 'remove-error',
    DID_START_ITEM_REMOVE: 'busy',
    DID_START_ITEM_PROCESSING: 'busy processing',
    DID_REQUEST_ITEM_PROCESSING: 'busy processing',
    DID_UPDATE_ITEM_PROCESS_PROGRESS: 'processing',
    DID_COMPLETE_ITEM_PROCESSING: 'processing-complete',
    DID_THROW_ITEM_PROCESSING_ERROR: 'processing-error',
    DID_THROW_ITEM_PROCESSING_REVERT_ERROR: 'processing-revert-error',
    DID_ABORT_ITEM_PROCESSING: 'cancelled',
    DID_REVERT_ITEM_PROCESSING: 'idle'
  };

  /**
   * Creates the file view
   */
  var create$7 = function create(_ref) {
    var root = _ref.root,
      props = _ref.props;

    // select
    root.ref.handleClick = function(e) {
      return root.dispatch('DID_ACTIVATE_ITEM', { id: props.id });
    };

    // set id
    root.element.id = 'filepond--item-' + props.id;
    root.element.addEventListener('click', root.ref.handleClick);

    // file view
    root.ref.container = root.appendChildView(
      root.createChildView(fileWrapper, { id: props.id })
    );

    // file panel
    root.ref.panel = root.appendChildView(
      root.createChildView(panel, { name: 'item-panel' })
    );

    // default start height
    root.ref.panel.height = null;

    // by default not marked for removal
    props.markedForRemoval = false;

    // if not allowed to reorder file items, exit here
    if (!root.query('GET_ALLOW_REORDER')) return;

    // set to idle so shows grab cursor
    root.element.dataset.dragState = 'idle';

    var grab = function grab(e) {
      if (!e.isPrimary) return;

      var removedActivateListener = false;

      var origin = {
        x: e.pageX,
        y: e.pageY
      };

      props.dragOrigin = {
        x: root.translateX,
        y: root.translateY
      };

      props.dragCenter = {
        x: e.offsetX,
        y: e.offsetY
      };

      var dragState = createDragHelper(root.query('GET_ACTIVE_ITEMS'));

      root.dispatch('DID_GRAB_ITEM', { id: props.id, dragState: dragState });

      var drag = function drag(e) {
        if (!e.isPrimary) return;

        e.stopPropagation();
        e.preventDefault();

        props.dragOffset = {
          x: e.pageX - origin.x,
          y: e.pageY - origin.y
        };

        // if dragged stop listening to clicks, will re-add when done dragging
        var dist =
          props.dragOffset.x * props.dragOffset.x +
          props.dragOffset.y * props.dragOffset.y;
        if (dist > 16 && !removedActivateListener) {
          removedActivateListener = true;
          root.element.removeEventListener('click', root.ref.handleClick);
        }

        root.dispatch('DID_DRAG_ITEM', { id: props.id, dragState: dragState });
      };

      var drop = function drop(e) {
        if (!e.isPrimary) return;

        document.removeEventListener('pointermove', drag);
        document.removeEventListener('pointerup', drop);

        props.dragOffset = {
          x: e.pageX - origin.x,
          y: e.pageY - origin.y
        };

        root.dispatch('DID_DROP_ITEM', { id: props.id, dragState: dragState });

        // start listening to clicks again
        if (removedActivateListener) {
          setTimeout(function() {
            return root.element.addEventListener('click', root.ref.handleClick);
          }, 0);
        }
      };

      document.addEventListener('pointermove', drag);
      document.addEventListener('pointerup', drop);
    };

    root.element.addEventListener('pointerdown', grab);
  };

  var route$1 = createRoute({
    DID_UPDATE_PANEL_HEIGHT: function DID_UPDATE_PANEL_HEIGHT(_ref2) {
      var root = _ref2.root,
        action = _ref2.action;
      root.height = action.height;
    }
  });

  var write$4 = createRoute(
    {
      DID_GRAB_ITEM: function DID_GRAB_ITEM(_ref3) {
        var root = _ref3.root,
          props = _ref3.props;
        props.dragOrigin = {
          x: root.translateX,
          y: root.translateY
        };
      },
      DID_DRAG_ITEM: function DID_DRAG_ITEM(_ref4) {
        var root = _ref4.root;
        root.element.dataset.dragState = 'drag';
      },
      DID_DROP_ITEM: function DID_DROP_ITEM(_ref5) {
        var root = _ref5.root,
          props = _ref5.props;
        props.dragOffset = null;
        props.dragOrigin = null;
        root.element.dataset.dragState = 'drop';
      }
    },
    function(_ref6) {
      var root = _ref6.root,
        actions = _ref6.actions,
        props = _ref6.props,
        shouldOptimize = _ref6.shouldOptimize;

      if (root.element.dataset.dragState === 'drop') {
        if (root.scaleX <= 1) {
          root.element.dataset.dragState = 'idle';
        }
      }

      // select last state change action
      var action = actions
        .concat()
        .filter(function(action) {
          return /^DID_/.test(action.type);
        })
        .reverse()
        .find(function(action) {
          return StateMap[action.type];
        });

      // no need to set same state twice
      if (action && action.type !== props.currentState) {
        // set current state
        props.currentState = action.type;

        // set state
        root.element.dataset.filepondItemState =
          StateMap[props.currentState] || '';
      }

      // route actions
      var aspectRatio =
        root.query('GET_ITEM_PANEL_ASPECT_RATIO') ||
        root.query('GET_PANEL_ASPECT_RATIO');
      if (!aspectRatio) {
        route$1({ root: root, actions: actions, props: props });
        if (!root.height && root.ref.container.rect.element.height > 0) {
          root.height = root.ref.container.rect.element.height;
        }
      } else if (!shouldOptimize) {
        root.height = root.rect.element.width * aspectRatio;
      }

      // sync panel height with item height
      if (shouldOptimize) {
        root.ref.panel.height = null;
      }

      root.ref.panel.height = root.height;
    }
  );

  var item = createView({
    create: create$7,
    write: write$4,
    destroy: function destroy(_ref7) {
      var root = _ref7.root,
        props = _ref7.props;
      root.element.removeEventListener('click', root.ref.handleClick);
      root.dispatch('RELEASE_ITEM', { query: props.id });
    },
    tag: 'li',
    name: 'item',
    mixins: {
      apis: [
        'id',
        'interactionMethod',
        'markedForRemoval',
        'spawnDate',
        'dragCenter',
        'dragOrigin',
        'dragOffset'
      ],
      styles: [
        'translateX',
        'translateY',
        'scaleX',
        'scaleY',
        'opacity',
        'height'
      ],

      animations: {
        scaleX: ITEM_SCALE_SPRING,
        scaleY: ITEM_SCALE_SPRING,
        translateX: ITEM_TRANSLATE_SPRING,
        translateY: ITEM_TRANSLATE_SPRING,
        opacity: { type: 'tween', duration: 150 }
      }
    }
  });

  var getItemIndexByPosition = function getItemIndexByPosition(
    view,
    children,
    positionInView
  ) {
    if (!positionInView) return;

    var horizontalSpace = view.rect.element.width;
    // const children = view.childViews;
    var l = children.length;
    var last = null;

    // -1, don't move items to accomodate (either add to top or bottom)
    if (l === 0 || positionInView.top < children[0].rect.element.top) return -1;

    // let's get the item width
    var item = children[0];
    var itemRect = item.rect.element;
    var itemHorizontalMargin = itemRect.marginLeft + itemRect.marginRight;
    var itemWidth = itemRect.width + itemHorizontalMargin;
    var itemsPerRow = Math.round(horizontalSpace / itemWidth);

    // stack
    if (itemsPerRow === 1) {
      for (var index = 0; index < l; index++) {
        var child = children[index];
        var childMid = child.rect.outer.top + child.rect.element.height * 0.5;
        if (positionInView.top < childMid) {
          return index;
        }
      }
      return l;
    }

    // grid
    var itemVerticalMargin = itemRect.marginTop + itemRect.marginBottom;
    var itemHeight = itemRect.height + itemVerticalMargin;
    for (var _index = 0; _index < l; _index++) {
      var indexX = _index % itemsPerRow;
      var indexY = Math.floor(_index / itemsPerRow);

      var offsetX = indexX * itemWidth;
      var offsetY = indexY * itemHeight;

      var itemTop = offsetY - itemRect.marginTop;
      var itemRight = offsetX + itemWidth;
      var itemBottom = offsetY + itemHeight + itemRect.marginBottom;

      if (positionInView.top < itemBottom && positionInView.top > itemTop) {
        if (positionInView.left < itemRight) {
          return _index;
        } else if (_index !== l - 1) {
          last = _index;
        } else {
          last = null;
        }
      }
    }

    if (last !== null) {
      return last;
    }

    return l;
  };

  var dropAreaDimensions = {
    height: 0,
    width: 0,
    get getHeight() {
      return this.height;
    },
    set setHeight(val) {
      if (this.height === 0 || val === 0) this.height = val;
    },
    get getWidth() {
      return this.width;
    },
    set setWidth(val) {
      if (this.width === 0 || val === 0) this.width = val;
    },
    setDimensions: function setDimensions(height, width) {
      if (this.height === 0 || height === 0) this.height = height;
      if (this.width === 0 || width === 0) this.width = width;
    }
  };

  var create$8 = function create(_ref) {
    var root = _ref.root;
    // need to set role to list as otherwise it won't be read as a list by VoiceOver
    attr(root.element, 'role', 'list');

    root.ref.lastItemSpanwDate = Date.now();
  };

  /**
   * Inserts a new item
   * @param root
   * @param action
   */
  var addItemView = function addItemView(_ref2) {
    var root = _ref2.root,
      action = _ref2.action;
    var id = action.id,
      index = action.index,
      interactionMethod = action.interactionMethod;

    root.ref.addIndex = index;

    var now = Date.now();
    var spawnDate = now;
    var opacity = 1;

    if (interactionMethod !== InteractionMethod.NONE) {
      opacity = 0;
      var cooldown = root.query('GET_ITEM_INSERT_INTERVAL');
      var dist = now - root.ref.lastItemSpanwDate;
      spawnDate = dist < cooldown ? now + (cooldown - dist) : now;
    }

    root.ref.lastItemSpanwDate = spawnDate;

    root.appendChildView(
      root.createChildView(
        // view type
        item,

        // props
        {
          spawnDate: spawnDate,
          id: id,
          opacity: opacity,
          interactionMethod: interactionMethod
        }
      ),

      index
    );
  };

  var moveItem = function moveItem(item, x, y) {
    var vx =
      arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
    var vy =
      arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;

    // set to null to remove animation while dragging
    if (item.dragOffset) {
      item.translateX = null;
      item.translateY = null;
      item.translateX = item.dragOrigin.x + item.dragOffset.x;
      item.translateY = item.dragOrigin.y + item.dragOffset.y;
      item.scaleX = 1.025;
      item.scaleY = 1.025;
    } else {
      item.translateX = x;
      item.translateY = y;

      if (Date.now() > item.spawnDate) {
        // reveal element
        if (item.opacity === 0) {
          introItemView(item, x, y, vx, vy);
        }

        // make sure is default scale every frame
        item.scaleX = 1;
        item.scaleY = 1;
        item.opacity = 1;
      }
    }
  };

  var introItemView = function introItemView(item, x, y, vx, vy) {
    if (item.interactionMethod === InteractionMethod.NONE) {
      item.translateX = null;
      item.translateX = x;
      item.translateY = null;
      item.translateY = y;
    } else if (item.interactionMethod === InteractionMethod.DROP) {
      item.translateX = null;
      item.translateX = x - vx * 20;

      item.translateY = null;
      item.translateY = y - vy * 10;

      item.scaleX = 0.8;
      item.scaleY = 0.8;
    } else if (item.interactionMethod === InteractionMethod.BROWSE) {
      item.translateY = null;
      item.translateY = y - 30;
    } else if (item.interactionMethod === InteractionMethod.API) {
      item.translateX = null;
      item.translateX = x - 30;
      item.translateY = null;
    }
  };

  /**
   * Removes an existing item
   * @param root
   * @param action
   */
  var removeItemView = function removeItemView(_ref3) {
    var root = _ref3.root,
      action = _ref3.action;
    var id = action.id;

    // get the view matching the given id
    var view = root.childViews.find(function(child) {
      return child.id === id;
    });

    // if no view found, exit
    if (!view) {
      return;
    }

    // animate view out of view
    view.scaleX = 0.9;
    view.scaleY = 0.9;
    view.opacity = 0;

    // mark for removal
    view.markedForRemoval = true;
  };

  var getItemHeight = function getItemHeight(child) {
    return (
      child.rect.element.height +
      child.rect.element.marginBottom * 0.5 +
      child.rect.element.marginTop * 0.5
    );
  };
  var getItemWidth = function getItemWidth(child) {
    return (
      child.rect.element.width +
      child.rect.element.marginLeft * 0.5 +
      child.rect.element.marginRight * 0.5
    );
  };

  var dragItem = function dragItem(_ref4) {
    var root = _ref4.root,
      action = _ref4.action;
    var id = action.id,
      dragState = action.dragState;

    // reference to item
    var item = root.query('GET_ITEM', { id: id });

    // get the view matching the given id
    var view = root.childViews.find(function(child) {
      return child.id === id;
    });

    var numItems = root.childViews.length;
    var oldIndex = dragState.getItemIndex(item);

    // if no view found, exit
    if (!view) return;

    var dragPosition = {
      x: view.dragOrigin.x + view.dragOffset.x + view.dragCenter.x,
      y: view.dragOrigin.y + view.dragOffset.y + view.dragCenter.y

      // get drag area dimensions
    };
    var dragHeight = getItemHeight(view);
    var dragWidth = getItemWidth(view);

    // get rows and columns (There will always be at least one row and one column if a file is present)
    var cols = Math.floor(root.rect.outer.width / dragWidth);
    if (cols > numItems) cols = numItems;

    // rows are used to find when we have left the preview area bounding box
    var rows = Math.floor(numItems / cols + 1);

    dropAreaDimensions.setHeight = dragHeight * rows;
    dropAreaDimensions.setWidth = dragWidth * cols;

    // get new index of dragged item
    var location = {
      y: Math.floor(dragPosition.y / dragHeight),
      x: Math.floor(dragPosition.x / dragWidth),
      getGridIndex: function getGridIndex() {
        if (
          dragPosition.y > dropAreaDimensions.getHeight ||
          dragPosition.y < 0 ||
          dragPosition.x > dropAreaDimensions.getWidth ||
          dragPosition.x < 0
        )
          return oldIndex;
        return this.y * cols + this.x;
      },
      getColIndex: function getColIndex() {
        var items = root.query('GET_ACTIVE_ITEMS');
        var visibleChildren = root.childViews.filter(function(child) {
          return child.rect.element.height;
        });
        var children = items.map(function(item) {
          return visibleChildren.find(function(childView) {
            return childView.id === item.id;
          });
        });
        var currentIndex = children.findIndex(function(child) {
          return child === view;
        });
        var dragHeight = getItemHeight(view);
        var l = children.length;
        var idx = l;
        var childHeight = 0;
        var childBottom = 0;
        var childTop = 0;
        for (var i = 0; i < l; i++) {
          childHeight = getItemHeight(children[i]);
          childTop = childBottom;
          childBottom = childTop + childHeight;
          if (dragPosition.y < childBottom) {
            if (currentIndex > i) {
              if (dragPosition.y < childTop + dragHeight) {
                idx = i;
                break;
              }
              continue;
            }
            idx = i;
            break;
          }
        }
        return idx;
      }

      // get new index
    };
    var index = cols > 1 ? location.getGridIndex() : location.getColIndex();
    root.dispatch('MOVE_ITEM', { query: view, index: index });

    // if the index of the item changed, dispatch reorder action
    var currentIndex = dragState.getIndex();

    if (currentIndex === undefined || currentIndex !== index) {
      dragState.setIndex(index);

      if (currentIndex === undefined) return;

      root.dispatch('DID_REORDER_ITEMS', {
        items: root.query('GET_ACTIVE_ITEMS'),
        origin: oldIndex,
        target: index
      });
    }
  };

  /**
   * Setup action routes
   */
  var route$2 = createRoute({
    DID_ADD_ITEM: addItemView,
    DID_REMOVE_ITEM: removeItemView,
    DID_DRAG_ITEM: dragItem
  });

  /**
   * Write to view
   * @param root
   * @param actions
   * @param props
   */
  var write$5 = function write(_ref5) {
    var root = _ref5.root,
      props = _ref5.props,
      actions = _ref5.actions,
      shouldOptimize = _ref5.shouldOptimize;

    // route actions
    route$2({ root: root, props: props, actions: actions });
    var dragCoordinates = props.dragCoordinates;

    // available space on horizontal axis
    var horizontalSpace = root.rect.element.width;

    // only draw children that have dimensions
    var visibleChildren = root.childViews.filter(function(child) {
      return child.rect.element.height;
    });

    // sort based on current active items
    var children = root
      .query('GET_ACTIVE_ITEMS')
      .map(function(item) {
        return visibleChildren.find(function(child) {
          return child.id === item.id;
        });
      })
      .filter(function(item) {
        return item;
      });

    // get index
    var dragIndex = dragCoordinates
      ? getItemIndexByPosition(root, children, dragCoordinates)
      : null;

    // add index is used to reserve the dropped/added item index till the actual item is rendered
    var addIndex = root.ref.addIndex || null;

    // add index no longer needed till possibly next draw
    root.ref.addIndex = null;

    var dragIndexOffset = 0;
    var removeIndexOffset = 0;
    var addIndexOffset = 0;

    if (children.length === 0) return;

    var childRect = children[0].rect.element;
    var itemVerticalMargin = childRect.marginTop + childRect.marginBottom;
    var itemHorizontalMargin = childRect.marginLeft + childRect.marginRight;
    var itemWidth = childRect.width + itemHorizontalMargin;
    var itemHeight = childRect.height + itemVerticalMargin;
    var itemsPerRow = Math.round(horizontalSpace / itemWidth);

    // stack
    if (itemsPerRow === 1) {
      var offsetY = 0;
      var dragOffset = 0;

      children.forEach(function(child, index) {
        if (dragIndex) {
          var dist = index - dragIndex;
          if (dist === -2) {
            dragOffset = -itemVerticalMargin * 0.25;
          } else if (dist === -1) {
            dragOffset = -itemVerticalMargin * 0.75;
          } else if (dist === 0) {
            dragOffset = itemVerticalMargin * 0.75;
          } else if (dist === 1) {
            dragOffset = itemVerticalMargin * 0.25;
          } else {
            dragOffset = 0;
          }
        }

        if (shouldOptimize) {
          child.translateX = null;
          child.translateY = null;
        }

        if (!child.markedForRemoval) {
          moveItem(child, 0, offsetY + dragOffset);
        }

        var itemHeight = child.rect.element.height + itemVerticalMargin;

        var visualHeight =
          itemHeight * (child.markedForRemoval ? child.opacity : 1);

        offsetY += visualHeight;
      });
    }
    // grid
    else {
      var prevX = 0;
      var prevY = 0;

      children.forEach(function(child, index) {
        if (index === dragIndex) {
          dragIndexOffset = 1;
        }

        if (index === addIndex) {
          addIndexOffset += 1;
        }

        if (child.markedForRemoval && child.opacity < 0.5) {
          removeIndexOffset -= 1;
        }

        var visualIndex =
          index + addIndexOffset + dragIndexOffset + removeIndexOffset;

        var indexX = visualIndex % itemsPerRow;
        var indexY = Math.floor(visualIndex / itemsPerRow);

        var offsetX = indexX * itemWidth;
        var offsetY = indexY * itemHeight;

        var vectorX = Math.sign(offsetX - prevX);
        var vectorY = Math.sign(offsetY - prevY);

        prevX = offsetX;
        prevY = offsetY;

        if (child.markedForRemoval) return;

        if (shouldOptimize) {
          child.translateX = null;
          child.translateY = null;
        }

        moveItem(child, offsetX, offsetY, vectorX, vectorY);
      });
    }
  };

  /**
   * Filters actions that are meant specifically for a certain child of the list
   * @param child
   * @param actions
   */
  var filterSetItemActions = function filterSetItemActions(child, actions) {
    return actions.filter(function(action) {
      // if action has an id, filter out actions that don't have this child id
      if (action.data && action.data.id) {
        return child.id === action.data.id;
      }

      // allow all other actions
      return true;
    });
  };

  var list = createView({
    create: create$8,
    write: write$5,
    tag: 'ul',
    name: 'list',
    didWriteView: function didWriteView(_ref6) {
      var root = _ref6.root;
      root.childViews
        .filter(function(view) {
          return view.markedForRemoval && view.opacity === 0 && view.resting;
        })
        .forEach(function(view) {
          view._destroy();
          root.removeChildView(view);
        });
    },
    filterFrameActionsForChild: filterSetItemActions,
    mixins: {
      apis: ['dragCoordinates']
    }
  });

  var create$9 = function create(_ref) {
    var root = _ref.root,
      props = _ref.props;
    root.ref.list = root.appendChildView(root.createChildView(list));
    props.dragCoordinates = null;
    props.overflowing = false;
  };

  var storeDragCoordinates = function storeDragCoordinates(_ref2) {
    var root = _ref2.root,
      props = _ref2.props,
      action = _ref2.action;
    if (!root.query('GET_ITEM_INSERT_LOCATION_FREEDOM')) return;
    props.dragCoordinates = {
      left: action.position.scopeLeft - root.ref.list.rect.element.left,
      top:
        action.position.scopeTop -
        (root.rect.outer.top +
          root.rect.element.marginTop +
          root.rect.element.scrollTop)
    };
  };

  var clearDragCoordinates = function clearDragCoordinates(_ref3) {
    var props = _ref3.props;
    props.dragCoordinates = null;
  };

  var route$3 = createRoute({
    DID_DRAG: storeDragCoordinates,
    DID_END_DRAG: clearDragCoordinates
  });

  var write$6 = function write(_ref4) {
    var root = _ref4.root,
      props = _ref4.props,
      actions = _ref4.actions;

    // route actions
    route$3({ root: root, props: props, actions: actions });

    // current drag position
    root.ref.list.dragCoordinates = props.dragCoordinates;

    // if currently overflowing but no longer received overflow
    if (props.overflowing && !props.overflow) {
      props.overflowing = false;

      // reset overflow state
      root.element.dataset.state = '';
      root.height = null;
    }

    // if is not overflowing currently but does receive overflow value
    if (props.overflow) {
      var newHeight = Math.round(props.overflow);
      if (newHeight !== root.height) {
        props.overflowing = true;
        root.element.dataset.state = 'overflow';
        root.height = newHeight;
      }
    }
  };

  var listScroller = createView({
    create: create$9,
    write: write$6,
    name: 'list-scroller',
    mixins: {
      apis: ['overflow', 'dragCoordinates'],
      styles: ['height', 'translateY'],
      animations: {
        translateY: 'spring'
      }
    }
  });

  var attrToggle = function attrToggle(element, name, state) {
    var enabledValue =
      arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';
    if (state) {
      attr(element, name, enabledValue);
    } else {
      element.removeAttribute(name);
    }
  };

  var resetFileInput = function resetFileInput(input) {
    // no value, no need to reset
    if (!input || input.value === '') {
      return;
    }

    try {
      // for modern browsers
      input.value = '';
    } catch (err) {}

    // for IE10
    if (input.value) {
      // quickly append input to temp form and reset form
      var form = createElement$1('form');
      var parentNode = input.parentNode;
      var ref = input.nextSibling;
      form.appendChild(input);
      form.reset();

      // re-inject input where it originally was
      if (ref) {
        parentNode.insertBefore(input, ref);
      } else {
        parentNode.appendChild(input);
      }
    }
  };

  var create$a = function create(_ref) {
    var root = _ref.root,
      props = _ref.props;

    // set id so can be referenced from outside labels
    root.element.id = 'filepond--browser-' + props.id;

    // set name of element (is removed when a value is set)
    attr(root.element, 'name', root.query('GET_NAME'));

    // we have to link this element to the status element
    attr(root.element, 'aria-controls', 'filepond--assistant-' + props.id);

    // set label, we use labelled by as otherwise the screenreader does not read the "browse" text in the label (as it has tabindex: 0)
    attr(root.element, 'aria-labelledby', 'filepond--drop-label-' + props.id);

    // set configurable props
    setAcceptedFileTypes({
      root: root,
      action: { value: root.query('GET_ACCEPTED_FILE_TYPES') }
    });
    toggleAllowMultiple({
      root: root,
      action: { value: root.query('GET_ALLOW_MULTIPLE') }
    });
    toggleDirectoryFilter({
      root: root,
      action: { value: root.query('GET_ALLOW_DIRECTORIES_ONLY') }
    });
    toggleDisabled({ root: root });
    toggleRequired({
      root: root,
      action: { value: root.query('GET_REQUIRED') }
    });
    setCaptureMethod({
      root: root,
      action: { value: root.query('GET_CAPTURE_METHOD') }
    });

    // handle changes to the input field
    root.ref.handleChange = function(e) {
      if (!root.element.value) {
        return;
      }

      // extract files and move value of webkitRelativePath path to _relativePath
      var files = Array.from(root.element.files).map(function(file) {
        file._relativePath = file.webkitRelativePath;
        return file;
      });

      // we add a little delay so the OS file select window can move out of the way before we add our file
      setTimeout(function() {
        // load files
        props.onload(files);

        // reset input, it's just for exposing a method to drop files, should not retain any state
        resetFileInput(root.element);
      }, 250);
    };

    root.element.addEventListener('change', root.ref.handleChange);
  };

  var setAcceptedFileTypes = function setAcceptedFileTypes(_ref2) {
    var root = _ref2.root,
      action = _ref2.action;
    if (!root.query('GET_ALLOW_SYNC_ACCEPT_ATTRIBUTE')) return;
    attrToggle(
      root.element,
      'accept',
      !!action.value,
      action.value ? action.value.join(',') : ''
    );
  };

  var toggleAllowMultiple = function toggleAllowMultiple(_ref3) {
    var root = _ref3.root,
      action = _ref3.action;
    attrToggle(root.element, 'multiple', action.value);
  };

  var toggleDirectoryFilter = function toggleDirectoryFilter(_ref4) {
    var root = _ref4.root,
      action = _ref4.action;
    attrToggle(root.element, 'webkitdirectory', action.value);
  };

  var toggleDisabled = function toggleDisabled(_ref5) {
    var root = _ref5.root;
    var isDisabled = root.query('GET_DISABLED');
    var doesAllowBrowse = root.query('GET_ALLOW_BROWSE');
    var disableField = isDisabled || !doesAllowBrowse;
    attrToggle(root.element, 'disabled', disableField);
  };

  var toggleRequired = function toggleRequired(_ref6) {
    var root = _ref6.root,
      action = _ref6.action;
    // want to remove required, always possible
    if (!action.value) {
      attrToggle(root.element, 'required', false);
    }
    // if want to make required, only possible when zero items
    else if (root.query('GET_TOTAL_ITEMS') === 0) {
      attrToggle(root.element, 'required', true);
    }
  };

  var setCaptureMethod = function setCaptureMethod(_ref7) {
    var root = _ref7.root,
      action = _ref7.action;
    attrToggle(
      root.element,
      'capture',
      !!action.value,
      action.value === true ? '' : action.value
    );
  };

  var updateRequiredStatus = function updateRequiredStatus(_ref8) {
    var root = _ref8.root;
    var element = root.element;
    // always remove the required attribute when more than zero items
    if (root.query('GET_TOTAL_ITEMS') > 0) {
      attrToggle(element, 'required', false);
      attrToggle(element, 'name', false);
    } else {
      // add name attribute
      attrToggle(element, 'name', true, root.query('GET_NAME'));

      // remove any validation messages
      var shouldCheckValidity = root.query('GET_CHECK_VALIDITY');
      if (shouldCheckValidity) {
        element.setCustomValidity('');
      }

      // we only add required if the field has been deemed required
      if (root.query('GET_REQUIRED')) {
        attrToggle(element, 'required', true);
      }
    }
  };

  var updateFieldValidityStatus = function updateFieldValidityStatus(_ref9) {
    var root = _ref9.root;
    var shouldCheckValidity = root.query('GET_CHECK_VALIDITY');
    if (!shouldCheckValidity) return;
    root.element.setCustomValidity(root.query('GET_LABEL_INVALID_FIELD'));
  };

  var browser = createView({
    tag: 'input',
    name: 'browser',
    ignoreRect: true,
    ignoreRectUpdate: true,
    attributes: {
      type: 'file'
    },

    create: create$a,
    destroy: function destroy(_ref10) {
      var root = _ref10.root;
      root.element.removeEventListener('change', root.ref.handleChange);
    },
    write: createRoute({
      DID_LOAD_ITEM: updateRequiredStatus,
      DID_REMOVE_ITEM: updateRequiredStatus,
      DID_THROW_ITEM_INVALID: updateFieldValidityStatus,

      DID_SET_DISABLED: toggleDisabled,
      DID_SET_ALLOW_BROWSE: toggleDisabled,
      DID_SET_ALLOW_DIRECTORIES_ONLY: toggleDirectoryFilter,
      DID_SET_ALLOW_MULTIPLE: toggleAllowMultiple,
      DID_SET_ACCEPTED_FILE_TYPES: setAcceptedFileTypes,
      DID_SET_CAPTURE_METHOD: setCaptureMethod,
      DID_SET_REQUIRED: toggleRequired
    })
  });

  var Key = {
    ENTER: 13,
    SPACE: 32
  };

  var create$b = function create(_ref) {
    var root = _ref.root,
      props = _ref.props;

    // create the label and link it to the file browser
    var label = createElement$1('label');
    attr(label, 'for', 'filepond--browser-' + props.id);

    // use for labeling file input (aria-labelledby on file input)
    attr(label, 'id', 'filepond--drop-label-' + props.id);

    // hide the label for screenreaders, the input element will read the contents of the label when it's focussed. If we don't set aria-hidden the screenreader will also navigate the contents of the label separately from the input.
    attr(label, 'aria-hidden', 'true');

    // handle keys
    root.ref.handleKeyDown = function(e) {
      var isActivationKey = e.keyCode === Key.ENTER || e.keyCode === Key.SPACE;
      if (!isActivationKey) return;
      // stops from triggering the element a second time
      e.preventDefault();

      // click link (will then in turn activate file input)
      root.ref.label.click();
    };

    root.ref.handleClick = function(e) {
      var isLabelClick = e.target === label || label.contains(e.target);

      // don't want to click twice
      if (isLabelClick) return;

      // click link (will then in turn activate file input)
      root.ref.label.click();
    };

    // attach events
    label.addEventListener('keydown', root.ref.handleKeyDown);
    root.element.addEventListener('click', root.ref.handleClick);

    // update
    updateLabelValue(label, props.caption);

    // add!
    root.appendChild(label);
    root.ref.label = label;
  };

  var updateLabelValue = function updateLabelValue(label, value) {
    label.innerHTML = value;
    var clickable = label.querySelector('.filepond--label-action');
    if (clickable) {
      attr(clickable, 'tabindex', '0');
    }
    return value;
  };

  var dropLabel = createView({
    name: 'drop-label',
    ignoreRect: true,
    create: create$b,
    destroy: function destroy(_ref2) {
      var root = _ref2.root;
      root.ref.label.addEventListener('keydown', root.ref.handleKeyDown);
      root.element.removeEventListener('click', root.ref.handleClick);
    },
    write: createRoute({
      DID_SET_LABEL_IDLE: function DID_SET_LABEL_IDLE(_ref3) {
        var root = _ref3.root,
          action = _ref3.action;
        updateLabelValue(root.ref.label, action.value);
      }
    }),

    mixins: {
      styles: ['opacity', 'translateX', 'translateY'],
      animations: {
        opacity: { type: 'tween', duration: 150 },
        translateX: 'spring',
        translateY: 'spring'
      }
    }
  });

  var blob = createView({
    name: 'drip-blob',
    ignoreRect: true,
    mixins: {
      styles: ['translateX', 'translateY', 'scaleX', 'scaleY', 'opacity'],
      animations: {
        scaleX: 'spring',
        scaleY: 'spring',
        translateX: 'spring',
        translateY: 'spring',
        opacity: { type: 'tween', duration: 250 }
      }
    }
  });

  var addBlob = function addBlob(_ref) {
    var root = _ref.root;
    var centerX = root.rect.element.width * 0.5;
    var centerY = root.rect.element.height * 0.5;

    root.ref.blob = root.appendChildView(
      root.createChildView(blob, {
        opacity: 0,
        scaleX: 2.5,
        scaleY: 2.5,
        translateX: centerX,
        translateY: centerY
      })
    );
  };

  var moveBlob = function moveBlob(_ref2) {
    var root = _ref2.root,
      action = _ref2.action;
    if (!root.ref.blob) {
      addBlob({ root: root });
      return;
    }

    root.ref.blob.translateX = action.position.scopeLeft;
    root.ref.blob.translateY = action.position.scopeTop;
    root.ref.blob.scaleX = 1;
    root.ref.blob.scaleY = 1;
    root.ref.blob.opacity = 1;
  };

  var hideBlob = function hideBlob(_ref3) {
    var root = _ref3.root;
    if (!root.ref.blob) {
      return;
    }
    root.ref.blob.opacity = 0;
  };

  var explodeBlob = function explodeBlob(_ref4) {
    var root = _ref4.root;
    if (!root.ref.blob) {
      return;
    }
    root.ref.blob.scaleX = 2.5;
    root.ref.blob.scaleY = 2.5;
    root.ref.blob.opacity = 0;
  };

  var write$7 = function write(_ref5) {
    var root = _ref5.root,
      props = _ref5.props,
      actions = _ref5.actions;
    route$4({ root: root, props: props, actions: actions });
    var blob = root.ref.blob;

    if (actions.length === 0 && blob && blob.opacity === 0) {
      root.removeChildView(blob);
      root.ref.blob = null;
    }
  };

  var route$4 = createRoute({
    DID_DRAG: moveBlob,
    DID_DROP: explodeBlob,
    DID_END_DRAG: hideBlob
  });

  var drip = createView({
    ignoreRect: true,
    ignoreRectUpdate: true,
    name: 'drip',
    write: write$7
  });

  var create$c = function create(_ref) {
    var root = _ref.root;
    return (root.ref.fields = {});
  };

  var getField = function getField(root, id) {
    return root.ref.fields[id];
  };

  var syncFieldPositionsWithItems = function syncFieldPositionsWithItems(root) {
    root.query('GET_ACTIVE_ITEMS').forEach(function(item) {
      if (!root.ref.fields[item.id]) return;
      root.element.appendChild(root.ref.fields[item.id]);
    });
  };

  var didReorderItems = function didReorderItems(_ref2) {
    var root = _ref2.root;
    return syncFieldPositionsWithItems(root);
  };

  var didAddItem = function didAddItem(_ref3) {
    var root = _ref3.root,
      action = _ref3.action;
    var dataContainer = createElement$1('input');
    dataContainer.type = 'hidden';
    dataContainer.name = root.query('GET_NAME');
    dataContainer.disabled = root.query('GET_DISABLED');
    root.ref.fields[action.id] = dataContainer;
    syncFieldPositionsWithItems(root);
  };

  var didLoadItem$1 = function didLoadItem(_ref4) {
    var root = _ref4.root,
      action = _ref4.action;
    var field = getField(root, action.id);
    if (!field || action.serverFileReference === null) return;
    field.value = action.serverFileReference;
  };

  var didSetDisabled = function didSetDisabled(_ref5) {
    var root = _ref5.root;
    root.element.disabled = root.query('GET_DISABLED');
  };

  var didRemoveItem = function didRemoveItem(_ref6) {
    var root = _ref6.root,
      action = _ref6.action;
    var field = getField(root, action.id);
    if (!field) return;
    if (field.parentNode) field.parentNode.removeChild(field);
    delete root.ref.fields[action.id];
  };

  var didDefineValue = function didDefineValue(_ref7) {
    var root = _ref7.root,
      action = _ref7.action;
    var field = getField(root, action.id);
    if (!field) return;
    if (action.value === null) {
      field.removeAttribute('value');
    } else {
      field.value = action.value;
    }
    syncFieldPositionsWithItems(root);
  };

  var write$8 = createRoute({
    DID_SET_DISABLED: didSetDisabled,
    DID_ADD_ITEM: didAddItem,
    DID_LOAD_ITEM: didLoadItem$1,
    DID_REMOVE_ITEM: didRemoveItem,
    DID_DEFINE_VALUE: didDefineValue,
    DID_REORDER_ITEMS: didReorderItems,
    DID_SORT_ITEMS: didReorderItems
  });

  var data = createView({
    tag: 'fieldset',
    name: 'data',
    create: create$c,
    write: write$8,
    ignoreRect: true
  });

  var getRootNode = function getRootNode(element) {
    return 'getRootNode' in element ? element.getRootNode() : document;
  };

  var images = ['jpg', 'jpeg', 'png', 'gif', 'bmp', 'webp', 'svg', 'tiff'];
  var text$1 = ['css', 'csv', 'html', 'txt'];
  var map = {
    zip: 'zip|compressed',
    epub: 'application/epub+zip'
  };

  var guesstimateMimeType = function guesstimateMimeType() {
    var extension =
      arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    extension = extension.toLowerCase();
    if (images.includes(extension)) {
      return (
        'image/' +
        (extension === 'jpg'
          ? 'jpeg'
          : extension === 'svg'
          ? 'svg+xml'
          : extension)
      );
    }
    if (text$1.includes(extension)) {
      return 'text/' + extension;
    }

    return map[extension] || '';
  };

  var requestDataTransferItems = function requestDataTransferItems(
    dataTransfer
  ) {
    return new Promise(function(resolve, reject) {
      // try to get links from transfer, if found we'll exit immediately (unless a file is in the dataTransfer as well, this is because Firefox could represent the file as a URL and a file object at the same time)
      var links = getLinks(dataTransfer);
      if (links.length && !hasFiles(dataTransfer)) {
        return resolve(links);
      }
      // try to get files from the transfer
      getFiles(dataTransfer).then(resolve);
    });
  };

  /**
   * Test if datatransfer has files
   */
  var hasFiles = function hasFiles(dataTransfer) {
    if (dataTransfer.files) return dataTransfer.files.length > 0;
    return false;
  };

  /**
   * Extracts files from a DataTransfer object
   */
  var getFiles = function getFiles(dataTransfer) {
    return new Promise(function(resolve, reject) {
      // get the transfer items as promises
      var promisedFiles = (dataTransfer.items
        ? Array.from(dataTransfer.items)
        : []
      )
        // only keep file system items (files and directories)
        .filter(function(item) {
          return isFileSystemItem(item);
        })

        // map each item to promise
        .map(function(item) {
          return getFilesFromItem(item);
        });

      // if is empty, see if we can extract some info from the files property as a fallback
      if (!promisedFiles.length) {
        // TODO: test for directories (should not be allowed)
        // Use FileReader, problem is that the files property gets lost in the process
        resolve(dataTransfer.files ? Array.from(dataTransfer.files) : []);
        return;
      }

      // done!
      Promise.all(promisedFiles)
        .then(function(returnedFileGroups) {
          // flatten groups
          var files = [];
          returnedFileGroups.forEach(function(group) {
            files.push.apply(files, group);
          });

          // done (filter out empty files)!
          resolve(
            files
              .filter(function(file) {
                return file;
              })
              .map(function(file) {
                if (!file._relativePath)
                  file._relativePath = file.webkitRelativePath;
                return file;
              })
          );
        })
        .catch(console.error);
    });
  };

  var isFileSystemItem = function isFileSystemItem(item) {
    if (isEntry(item)) {
      var entry = getAsEntry(item);
      if (entry) {
        return entry.isFile || entry.isDirectory;
      }
    }
    return item.kind === 'file';
  };

  var getFilesFromItem = function getFilesFromItem(item) {
    return new Promise(function(resolve, reject) {
      if (isDirectoryEntry(item)) {
        getFilesInDirectory(getAsEntry(item))
          .then(resolve)
          .catch(reject);
        return;
      }

      resolve([item.getAsFile()]);
    });
  };

  var getFilesInDirectory = function getFilesInDirectory(entry) {
    return new Promise(function(resolve, reject) {
      var files = [];

      // the total entries to read
      var dirCounter = 0;
      var fileCounter = 0;

      var resolveIfDone = function resolveIfDone() {
        if (fileCounter === 0 && dirCounter === 0) {
          resolve(files);
        }
      };

      // the recursive function
      var readEntries = function readEntries(dirEntry) {
        dirCounter++;

        var directoryReader = dirEntry.createReader();

        // directories are returned in batches, we need to process all batches before we're done
        var readBatch = function readBatch() {
          directoryReader.readEntries(function(entries) {
            if (entries.length === 0) {
              dirCounter--;
              resolveIfDone();
              return;
            }

            entries.forEach(function(entry) {
              // recursively read more directories
              if (entry.isDirectory) {
                readEntries(entry);
              } else {
                // read as file
                fileCounter++;

                entry.file(function(file) {
                  var correctedFile = correctMissingFileType(file);
                  if (entry.fullPath)
                    correctedFile._relativePath = entry.fullPath;
                  files.push(correctedFile);
                  fileCounter--;
                  resolveIfDone();
                });
              }
            });

            // try to get next batch of files
            readBatch();
          }, reject);
        };

        // read first batch of files
        readBatch();
      };

      // go!
      readEntries(entry);
    });
  };

  var correctMissingFileType = function correctMissingFileType(file) {
    if (file.type.length) return file;
    var date = file.lastModifiedDate;
    var name = file.name;
    var type = guesstimateMimeType(getExtensionFromFilename(file.name));
    if (!type.length) return file;
    file = file.slice(0, file.size, type);
    file.name = name;
    file.lastModifiedDate = date;
    return file;
  };

  var isDirectoryEntry = function isDirectoryEntry(item) {
    return isEntry(item) && (getAsEntry(item) || {}).isDirectory;
  };

  var isEntry = function isEntry(item) {
    return 'webkitGetAsEntry' in item;
  };

  var getAsEntry = function getAsEntry(item) {
    return item.webkitGetAsEntry();
  };

  /**
   * Extracts links from a DataTransfer object
   */
  var getLinks = function getLinks(dataTransfer) {
    var links = [];
    try {
      // look in meta data property
      links = getLinksFromTransferMetaData(dataTransfer);
      if (links.length) {
        return links;
      }
      links = getLinksFromTransferURLData(dataTransfer);
    } catch (e) {
      // nope nope nope (probably IE trouble)
    }
    return links;
  };

  var getLinksFromTransferURLData = function getLinksFromTransferURLData(
    dataTransfer
  ) {
    var data = dataTransfer.getData('url');
    if (typeof data === 'string' && data.length) {
      return [data];
    }
    return [];
  };

  var getLinksFromTransferMetaData = function getLinksFromTransferMetaData(
    dataTransfer
  ) {
    var data = dataTransfer.getData('text/html');
    if (typeof data === 'string' && data.length) {
      var matches = data.match(/src\s*=\s*"(.+?)"/);
      if (matches) {
        return [matches[1]];
      }
    }
    return [];
  };

  var dragNDropObservers = [];

  var eventPosition = function eventPosition(e) {
    return {
      pageLeft: e.pageX,
      pageTop: e.pageY,
      scopeLeft: e.offsetX || e.layerX,
      scopeTop: e.offsetY || e.layerY
    };
  };

  var createDragNDropClient = function createDragNDropClient(
    element,
    scopeToObserve,
    filterElement
  ) {
    var observer = getDragNDropObserver(scopeToObserve);

    var client = {
      element: element,
      filterElement: filterElement,
      state: null,
      ondrop: function ondrop() {},
      onenter: function onenter() {},
      ondrag: function ondrag() {},
      onexit: function onexit() {},
      onload: function onload() {},
      allowdrop: function allowdrop() {}
    };

    client.destroy = observer.addListener(client);

    return client;
  };

  var getDragNDropObserver = function getDragNDropObserver(element) {
    // see if already exists, if so, return
    var observer = dragNDropObservers.find(function(item) {
      return item.element === element;
    });
    if (observer) {
      return observer;
    }

    // create new observer, does not yet exist for this element
    var newObserver = createDragNDropObserver(element);
    dragNDropObservers.push(newObserver);
    return newObserver;
  };

  var createDragNDropObserver = function createDragNDropObserver(element) {
    var clients = [];

    var routes = {
      dragenter: dragenter,
      dragover: dragover,
      dragleave: dragleave,
      drop: drop
    };

    var handlers = {};

    forin(routes, function(event, createHandler) {
      handlers[event] = createHandler(element, clients);
      element.addEventListener(event, handlers[event], false);
    });

    var observer = {
      element: element,
      addListener: function addListener(client) {
        // add as client
        clients.push(client);

        // return removeListener function
        return function() {
          // remove client
          clients.splice(clients.indexOf(client), 1);

          // if no more clients, clean up observer
          if (clients.length === 0) {
            dragNDropObservers.splice(dragNDropObservers.indexOf(observer), 1);

            forin(routes, function(event) {
              element.removeEventListener(event, handlers[event], false);
            });
          }
        };
      }
    };

    return observer;
  };

  var elementFromPoint = function elementFromPoint(root, point) {
    if (!('elementFromPoint' in root)) {
      root = document;
    }
    return root.elementFromPoint(point.x, point.y);
  };

  var isEventTarget = function isEventTarget(e, target) {
    // get root
    var root = getRootNode(target);

    // get element at position
    // if root is not actual shadow DOM and does not have elementFromPoint method, use the one on document
    var elementAtPosition = elementFromPoint(root, {
      x: e.pageX - window.pageXOffset,
      y: e.pageY - window.pageYOffset
    });

    // test if target is the element or if one of its children is
    return elementAtPosition === target || target.contains(elementAtPosition);
  };

  var initialTarget = null;

  var setDropEffect = function setDropEffect(dataTransfer, effect) {
    // is in try catch as IE11 will throw error if not
    try {
      dataTransfer.dropEffect = effect;
    } catch (e) {}
  };

  var dragenter = function dragenter(root, clients) {
    return function(e) {
      e.preventDefault();

      initialTarget = e.target;

      clients.forEach(function(client) {
        var element = client.element,
          onenter = client.onenter;

        if (isEventTarget(e, element)) {
          client.state = 'enter';

          // fire enter event
          onenter(eventPosition(e));
        }
      });
    };
  };

  var dragover = function dragover(root, clients) {
    return function(e) {
      e.preventDefault();

      var dataTransfer = e.dataTransfer;

      requestDataTransferItems(dataTransfer).then(function(items) {
        var overDropTarget = false;

        clients.some(function(client) {
          var filterElement = client.filterElement,
            element = client.element,
            onenter = client.onenter,
            onexit = client.onexit,
            ondrag = client.ondrag,
            allowdrop = client.allowdrop;

          // by default we can drop
          setDropEffect(dataTransfer, 'copy');

          // allow transfer of these items
          var allowsTransfer = allowdrop(items);

          // only used when can be dropped on page
          if (!allowsTransfer) {
            setDropEffect(dataTransfer, 'none');
            return;
          }

          // targetting this client
          if (isEventTarget(e, element)) {
            overDropTarget = true;

            // had no previous state, means we are entering this client
            if (client.state === null) {
              client.state = 'enter';
              onenter(eventPosition(e));
              return;
            }

            // now over element (no matter if it allows the drop or not)
            client.state = 'over';

            // needs to allow transfer
            if (filterElement && !allowsTransfer) {
              setDropEffect(dataTransfer, 'none');
              return;
            }

            // dragging
            ondrag(eventPosition(e));
          } else {
            // should be over an element to drop
            if (filterElement && !overDropTarget) {
              setDropEffect(dataTransfer, 'none');
            }

            // might have just left this client?
            if (client.state) {
              client.state = null;
              onexit(eventPosition(e));
            }
          }
        });
      });
    };
  };

  var drop = function drop(root, clients) {
    return function(e) {
      e.preventDefault();

      var dataTransfer = e.dataTransfer;

      requestDataTransferItems(dataTransfer).then(function(items) {
        clients.forEach(function(client) {
          var filterElement = client.filterElement,
            element = client.element,
            ondrop = client.ondrop,
            onexit = client.onexit,
            allowdrop = client.allowdrop;

          client.state = null;

          // if we're filtering on element we need to be over the element to drop
          if (filterElement && !isEventTarget(e, element)) return;

          // no transfer for this client
          if (!allowdrop(items)) return onexit(eventPosition(e));

          // we can drop these items on this client
          ondrop(eventPosition(e), items);
        });
      });
    };
  };

  var dragleave = function dragleave(root, clients) {
    return function(e) {
      if (initialTarget !== e.target) {
        return;
      }

      clients.forEach(function(client) {
        var onexit = client.onexit;

        client.state = null;

        onexit(eventPosition(e));
      });
    };
  };

  var createHopper = function createHopper(scope, validateItems, options) {
    // is now hopper scope
    scope.classList.add('filepond--hopper');

    // shortcuts
    var catchesDropsOnPage = options.catchesDropsOnPage,
      requiresDropOnElement = options.requiresDropOnElement,
      _options$filterItems = options.filterItems,
      filterItems =
        _options$filterItems === void 0
          ? function(items) {
              return items;
            }
          : _options$filterItems;

    // create a dnd client
    var client = createDragNDropClient(
      scope,
      catchesDropsOnPage ? document.documentElement : scope,
      requiresDropOnElement
    );

    // current client state
    var lastState = '';
    var currentState = '';

    // determines if a file may be dropped
    client.allowdrop = function(items) {
      // TODO: if we can, throw error to indicate the items cannot by dropped

      return validateItems(filterItems(items));
    };

    client.ondrop = function(position, items) {
      var filteredItems = filterItems(items);

      if (!validateItems(filteredItems)) {
        api.ondragend(position);
        return;
      }

      currentState = 'drag-drop';

      api.onload(filteredItems, position);
    };

    client.ondrag = function(position) {
      api.ondrag(position);
    };

    client.onenter = function(position) {
      currentState = 'drag-over';

      api.ondragstart(position);
    };

    client.onexit = function(position) {
      currentState = 'drag-exit';

      api.ondragend(position);
    };

    var api = {
      updateHopperState: function updateHopperState() {
        if (lastState !== currentState) {
          scope.dataset.hopperState = currentState;
          lastState = currentState;
        }
      },
      onload: function onload() {},
      ondragstart: function ondragstart() {},
      ondrag: function ondrag() {},
      ondragend: function ondragend() {},
      destroy: function destroy() {
        // destroy client
        client.destroy();
      }
    };

    return api;
  };

  var listening = false;
  var listeners$1 = [];

  var handlePaste = function handlePaste(e) {
    // if is pasting in input or textarea and the target is outside of a filepond scope, ignore
    var activeEl = document.activeElement;
    if (activeEl && /textarea|input/i.test(activeEl.nodeName)) {
      // test textarea or input is contained in filepond root
      var inScope = false;
      var element = activeEl;
      while (element !== document.body) {
        if (element.classList.contains('filepond--root')) {
          inScope = true;
          break;
        }
        element = element.parentNode;
      }

      if (!inScope) return;
    }

    requestDataTransferItems(e.clipboardData).then(function(files) {
      // no files received
      if (!files.length) {
        return;
      }

      // notify listeners of received files
      listeners$1.forEach(function(listener) {
        return listener(files);
      });
    });
  };

  var listen = function listen(cb) {
    // can't add twice
    if (listeners$1.includes(cb)) {
      return;
    }

    // add initial listener
    listeners$1.push(cb);

    // setup paste listener for entire page
    if (listening) {
      return;
    }

    listening = true;
    document.addEventListener('paste', handlePaste);
  };

  var unlisten = function unlisten(listener) {
    arrayRemove(listeners$1, listeners$1.indexOf(listener));

    // clean up
    if (listeners$1.length === 0) {
      document.removeEventListener('paste', handlePaste);
      listening = false;
    }
  };

  var createPaster = function createPaster() {
    var cb = function cb(files) {
      api.onload(files);
    };

    var api = {
      destroy: function destroy() {
        unlisten(cb);
      },
      onload: function onload() {}
    };

    listen(cb);

    return api;
  };

  /**
   * Creates the file view
   */
  var create$d = function create(_ref) {
    var root = _ref.root,
      props = _ref.props;
    root.element.id = 'filepond--assistant-' + props.id;
    attr(root.element, 'role', 'status');
    attr(root.element, 'aria-live', 'polite');
    attr(root.element, 'aria-relevant', 'additions');
  };

  var addFilesNotificationTimeout = null;
  var notificationClearTimeout = null;

  var filenames = [];

  var assist = function assist(root, message) {
    root.element.textContent = message;
  };

  var clear$1 = function clear(root) {
    root.element.textContent = '';
  };

  var listModified = function listModified(root, filename, label) {
    var total = root.query('GET_TOTAL_ITEMS');
    assist(
      root,
      label +
        ' ' +
        filename +
        ', ' +
        total +
        ' ' +
        (total === 1
          ? root.query('GET_LABEL_FILE_COUNT_SINGULAR')
          : root.query('GET_LABEL_FILE_COUNT_PLURAL'))
    );

    // clear group after set amount of time so the status is not read twice
    clearTimeout(notificationClearTimeout);
    notificationClearTimeout = setTimeout(function() {
      clear$1(root);
    }, 1500);
  };

  var isUsingFilePond = function isUsingFilePond(root) {
    return root.element.parentNode.contains(document.activeElement);
  };

  var itemAdded = function itemAdded(_ref2) {
    var root = _ref2.root,
      action = _ref2.action;
    if (!isUsingFilePond(root)) {
      return;
    }

    root.element.textContent = '';
    var item = root.query('GET_ITEM', action.id);
    filenames.push(item.filename);

    clearTimeout(addFilesNotificationTimeout);
    addFilesNotificationTimeout = setTimeout(function() {
      listModified(
        root,
        filenames.join(', '),
        root.query('GET_LABEL_FILE_ADDED')
      );

      filenames.length = 0;
    }, 750);
  };

  var itemRemoved = function itemRemoved(_ref3) {
    var root = _ref3.root,
      action = _ref3.action;
    if (!isUsingFilePond(root)) {
      return;
    }

    var item = action.item;
    listModified(root, item.filename, root.query('GET_LABEL_FILE_REMOVED'));
  };

  var itemProcessed = function itemProcessed(_ref4) {
    var root = _ref4.root,
      action = _ref4.action;
    // will also notify the user when FilePond is not being used, as the user might be occupied with other activities while uploading a file

    var item = root.query('GET_ITEM', action.id);
    var filename = item.filename;
    var label = root.query('GET_LABEL_FILE_PROCESSING_COMPLETE');

    assist(root, filename + ' ' + label);
  };

  var itemProcessedUndo = function itemProcessedUndo(_ref5) {
    var root = _ref5.root,
      action = _ref5.action;
    var item = root.query('GET_ITEM', action.id);
    var filename = item.filename;
    var label = root.query('GET_LABEL_FILE_PROCESSING_ABORTED');

    assist(root, filename + ' ' + label);
  };

  var itemError = function itemError(_ref6) {
    var root = _ref6.root,
      action = _ref6.action;
    var item = root.query('GET_ITEM', action.id);
    var filename = item.filename;

    // will also notify the user when FilePond is not being used, as the user might be occupied with other activities while uploading a file

    assist(root, action.status.main + ' ' + filename + ' ' + action.status.sub);
  };

  var assistant = createView({
    create: create$d,
    ignoreRect: true,
    ignoreRectUpdate: true,
    write: createRoute({
      DID_LOAD_ITEM: itemAdded,
      DID_REMOVE_ITEM: itemRemoved,
      DID_COMPLETE_ITEM_PROCESSING: itemProcessed,

      DID_ABORT_ITEM_PROCESSING: itemProcessedUndo,
      DID_REVERT_ITEM_PROCESSING: itemProcessedUndo,

      DID_THROW_ITEM_REMOVE_ERROR: itemError,
      DID_THROW_ITEM_LOAD_ERROR: itemError,
      DID_THROW_ITEM_INVALID: itemError,
      DID_THROW_ITEM_PROCESSING_ERROR: itemError
    }),

    tag: 'span',
    name: 'assistant'
  });

  var toCamels = function toCamels(string) {
    var separator =
      arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '-';
    return string.replace(new RegExp(separator + '.', 'g'), function(sub) {
      return sub.charAt(1).toUpperCase();
    });
  };

  var debounce = function debounce(func) {
    var interval =
      arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 16;
    var immidiateOnly =
      arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
    var last = Date.now();
    var timeout = null;

    return function() {
      for (
        var _len = arguments.length, args = new Array(_len), _key = 0;
        _key < _len;
        _key++
      ) {
        args[_key] = arguments[_key];
      }
      clearTimeout(timeout);

      var dist = Date.now() - last;

      var fn = function fn() {
        last = Date.now();
        func.apply(void 0, args);
      };

      if (dist < interval) {
        // we need to delay by the difference between interval and dist
        // for example: if distance is 10 ms and interval is 16 ms,
        // we need to wait an additional 6ms before calling the function)
        if (!immidiateOnly) {
          timeout = setTimeout(fn, interval - dist);
        }
      } else {
        // go!
        fn();
      }
    };
  };

  var MAX_FILES_LIMIT = 1000000;

  var prevent = function prevent(e) {
    return e.preventDefault();
  };

  var create$e = function create(_ref) {
    var root = _ref.root,
      props = _ref.props;

    // Add id
    var id = root.query('GET_ID');
    if (id) {
      root.element.id = id;
    }

    // Add className
    var className = root.query('GET_CLASS_NAME');
    if (className) {
      className
        .split(' ')
        .filter(function(name) {
          return name.length;
        })
        .forEach(function(name) {
          root.element.classList.add(name);
        });
    }

    // Field label
    root.ref.label = root.appendChildView(
      root.createChildView(
        dropLabel,
        Object.assign({}, props, {
          translateY: null,
          caption: root.query('GET_LABEL_IDLE')
        })
      )
    );

    // List of items
    root.ref.list = root.appendChildView(
      root.createChildView(listScroller, { translateY: null })
    );

    // Background panel
    root.ref.panel = root.appendChildView(
      root.createChildView(panel, { name: 'panel-root' })
    );

    // Assistant notifies assistive tech when content changes
    root.ref.assistant = root.appendChildView(
      root.createChildView(assistant, Object.assign({}, props))
    );

    // Data
    root.ref.data = root.appendChildView(
      root.createChildView(data, Object.assign({}, props))
    );

    // Measure (tests if fixed height was set)
    // DOCTYPE needs to be set for this to work
    root.ref.measure = createElement$1('div');
    root.ref.measure.style.height = '100%';
    root.element.appendChild(root.ref.measure);

    // information on the root height or fixed height status
    root.ref.bounds = null;

    // apply initial style properties
    root
      .query('GET_STYLES')
      .filter(function(style) {
        return !isEmpty(style.value);
      })
      .map(function(_ref2) {
        var name = _ref2.name,
          value = _ref2.value;
        root.element.dataset[name] = value;
      });

    // determine if width changed
    root.ref.widthPrevious = null;
    root.ref.widthUpdated = debounce(function() {
      root.ref.updateHistory = [];
      root.dispatch('DID_RESIZE_ROOT');
    }, 250);

    // history of updates
    root.ref.previousAspectRatio = null;
    root.ref.updateHistory = [];

    // prevent scrolling and zooming on iOS (only if supports pointer events, for then we can enable reorder)
    var canHover = window.matchMedia('(pointer: fine) and (hover: hover)')
      .matches;
    var hasPointerEvents = 'PointerEvent' in window;
    if (root.query('GET_ALLOW_REORDER') && hasPointerEvents && !canHover) {
      root.element.addEventListener('touchmove', prevent, { passive: false });
      root.element.addEventListener('gesturestart', prevent);
    }

    // add credits
    var credits = root.query('GET_CREDITS');
    var hasCredits = credits.length === 2;
    if (hasCredits) {
      var frag = document.createElement('a');
      frag.className = 'filepond--credits';
      frag.setAttribute('aria-hidden', 'true');
      frag.href = credits[0];
      frag.tabindex = -1;
      frag.target = '_blank';
      frag.rel = 'noopener noreferrer';
      frag.textContent = credits[1];
      root.element.appendChild(frag);
      root.ref.credits = frag;
    }
  };

  var write$9 = function write(_ref3) {
    var root = _ref3.root,
      props = _ref3.props,
      actions = _ref3.actions;

    // route actions
    route$5({ root: root, props: props, actions: actions });

    // apply style properties
    actions
      .filter(function(action) {
        return /^DID_SET_STYLE_/.test(action.type);
      })
      .filter(function(action) {
        return !isEmpty(action.data.value);
      })
      .map(function(_ref4) {
        var type = _ref4.type,
          data = _ref4.data;
        var name = toCamels(type.substr(8).toLowerCase(), '_');
        root.element.dataset[name] = data.value;
        root.invalidateLayout();
      });

    if (root.rect.element.hidden) return;

    if (root.rect.element.width !== root.ref.widthPrevious) {
      root.ref.widthPrevious = root.rect.element.width;
      root.ref.widthUpdated();
    }

    // get box bounds, we do this only once
    var bounds = root.ref.bounds;
    if (!bounds) {
      bounds = root.ref.bounds = calculateRootBoundingBoxHeight(root);

      // destroy measure element
      root.element.removeChild(root.ref.measure);
      root.ref.measure = null;
    }

    // get quick references to various high level parts of the upload tool
    var _root$ref = root.ref,
      hopper = _root$ref.hopper,
      label = _root$ref.label,
      list = _root$ref.list,
      panel = _root$ref.panel;

    // sets correct state to hopper scope
    if (hopper) {
      hopper.updateHopperState();
    }

    // bool to indicate if we're full or not
    var aspectRatio = root.query('GET_PANEL_ASPECT_RATIO');
    var isMultiItem = root.query('GET_ALLOW_MULTIPLE');
    var totalItems = root.query('GET_TOTAL_ITEMS');
    var maxItems = isMultiItem
      ? root.query('GET_MAX_FILES') || MAX_FILES_LIMIT
      : 1;
    var atMaxCapacity = totalItems === maxItems;

    // action used to add item
    var addAction = actions.find(function(action) {
      return action.type === 'DID_ADD_ITEM';
    });

    // if reached max capacity and we've just reached it
    if (atMaxCapacity && addAction) {
      // get interaction type
      var interactionMethod = addAction.data.interactionMethod;

      // hide label
      label.opacity = 0;

      if (isMultiItem) {
        label.translateY = -40;
      } else {
        if (interactionMethod === InteractionMethod.API) {
          label.translateX = 40;
        } else if (interactionMethod === InteractionMethod.BROWSE) {
          label.translateY = 40;
        } else {
          label.translateY = 30;
        }
      }
    } else if (!atMaxCapacity) {
      label.opacity = 1;
      label.translateX = 0;
      label.translateY = 0;
    }

    var listItemMargin = calculateListItemMargin(root);

    var listHeight = calculateListHeight(root);

    var labelHeight = label.rect.element.height;
    var currentLabelHeight = !isMultiItem || atMaxCapacity ? 0 : labelHeight;

    var listMarginTop = atMaxCapacity ? list.rect.element.marginTop : 0;
    var listMarginBottom =
      totalItems === 0 ? 0 : list.rect.element.marginBottom;

    var visualHeight =
      currentLabelHeight + listMarginTop + listHeight.visual + listMarginBottom;
    var boundsHeight =
      currentLabelHeight + listMarginTop + listHeight.bounds + listMarginBottom;

    // link list to label bottom position
    list.translateY =
      Math.max(0, currentLabelHeight - list.rect.element.marginTop) -
      listItemMargin.top;

    if (aspectRatio) {
      // fixed aspect ratio

      // calculate height based on width
      var width = root.rect.element.width;
      var height = width * aspectRatio;

      // clear history if aspect ratio has changed
      if (aspectRatio !== root.ref.previousAspectRatio) {
        root.ref.previousAspectRatio = aspectRatio;
        root.ref.updateHistory = [];
      }

      // remember this width
      var history = root.ref.updateHistory;
      history.push(width);

      var MAX_BOUNCES = 2;
      if (history.length > MAX_BOUNCES * 2) {
        var l = history.length;
        var bottom = l - 10;
        var bounces = 0;
        for (var i = l; i >= bottom; i--) {
          if (history[i] === history[i - 2]) {
            bounces++;
          }

          if (bounces >= MAX_BOUNCES) {
            // dont adjust height
            return;
          }
        }
      }

      // fix height of panel so it adheres to aspect ratio
      panel.scalable = false;
      panel.height = height;

      // available height for list
      var listAvailableHeight =
        // the height of the panel minus the label height
        height -
        currentLabelHeight -
        // the room we leave open between the end of the list and the panel bottom
        (listMarginBottom - listItemMargin.bottom) -
        // if we're full we need to leave some room between the top of the panel and the list
        (atMaxCapacity ? listMarginTop : 0);

      if (listHeight.visual > listAvailableHeight) {
        list.overflow = listAvailableHeight;
      } else {
        list.overflow = null;
      }

      // set container bounds (so pushes siblings downwards)
      root.height = height;
    } else if (bounds.fixedHeight) {
      // fixed height

      // fix height of panel
      panel.scalable = false;

      // available height for list
      var _listAvailableHeight =
        // the height of the panel minus the label height
        bounds.fixedHeight -
        currentLabelHeight -
        // the room we leave open between the end of the list and the panel bottom
        (listMarginBottom - listItemMargin.bottom) -
        // if we're full we need to leave some room between the top of the panel and the list
        (atMaxCapacity ? listMarginTop : 0);

      // set list height
      if (listHeight.visual > _listAvailableHeight) {
        list.overflow = _listAvailableHeight;
      } else {
        list.overflow = null;
      }

      // no need to set container bounds as these are handles by CSS fixed height
    } else if (bounds.cappedHeight) {
      // max-height

      // not a fixed height panel
      var isCappedHeight = visualHeight >= bounds.cappedHeight;
      var panelHeight = Math.min(bounds.cappedHeight, visualHeight);
      panel.scalable = true;
      panel.height = isCappedHeight
        ? panelHeight
        : panelHeight - listItemMargin.top - listItemMargin.bottom;

      // available height for list
      var _listAvailableHeight2 =
        // the height of the panel minus the label height
        panelHeight -
        currentLabelHeight -
        // the room we leave open between the end of the list and the panel bottom
        (listMarginBottom - listItemMargin.bottom) -
        // if we're full we need to leave some room between the top of the panel and the list
        (atMaxCapacity ? listMarginTop : 0);

      // set list height (if is overflowing)
      if (
        visualHeight > bounds.cappedHeight &&
        listHeight.visual > _listAvailableHeight2
      ) {
        list.overflow = _listAvailableHeight2;
      } else {
        list.overflow = null;
      }

      // set container bounds (so pushes siblings downwards)
      root.height = Math.min(
        bounds.cappedHeight,
        boundsHeight - listItemMargin.top - listItemMargin.bottom
      );
    } else {
      // flexible height

      // not a fixed height panel
      var itemMargin =
        totalItems > 0 ? listItemMargin.top + listItemMargin.bottom : 0;
      panel.scalable = true;
      panel.height = Math.max(labelHeight, visualHeight - itemMargin);

      // set container bounds (so pushes siblings downwards)
      root.height = Math.max(labelHeight, boundsHeight - itemMargin);
    }

    // move credits to bottom
    if (root.ref.credits && panel.heightCurrent)
      root.ref.credits.style.transform =
        'translateY(' + panel.heightCurrent + 'px)';
  };

  var calculateListItemMargin = function calculateListItemMargin(root) {
    var item = root.ref.list.childViews[0].childViews[0];
    return item
      ? {
          top: item.rect.element.marginTop,
          bottom: item.rect.element.marginBottom
        }
      : {
          top: 0,
          bottom: 0
        };
  };

  var calculateListHeight = function calculateListHeight(root) {
    var visual = 0;
    var bounds = 0;

    // get file list reference
    var scrollList = root.ref.list;
    var itemList = scrollList.childViews[0];
    var visibleChildren = itemList.childViews.filter(function(child) {
      return child.rect.element.height;
    });
    var children = root
      .query('GET_ACTIVE_ITEMS')
      .map(function(item) {
        return visibleChildren.find(function(child) {
          return child.id === item.id;
        });
      })
      .filter(function(item) {
        return item;
      });

    // no children, done!
    if (children.length === 0) return { visual: visual, bounds: bounds };

    var horizontalSpace = itemList.rect.element.width;
    var dragIndex = getItemIndexByPosition(
      itemList,
      children,
      scrollList.dragCoordinates
    );

    var childRect = children[0].rect.element;

    var itemVerticalMargin = childRect.marginTop + childRect.marginBottom;
    var itemHorizontalMargin = childRect.marginLeft + childRect.marginRight;

    var itemWidth = childRect.width + itemHorizontalMargin;
    var itemHeight = childRect.height + itemVerticalMargin;

    var newItem = typeof dragIndex !== 'undefined' && dragIndex >= 0 ? 1 : 0;
    var removedItem = children.find(function(child) {
      return child.markedForRemoval && child.opacity < 0.45;
    })
      ? -1
      : 0;
    var verticalItemCount = children.length + newItem + removedItem;
    var itemsPerRow = Math.round(horizontalSpace / itemWidth);

    // stack
    if (itemsPerRow === 1) {
      children.forEach(function(item) {
        var height = item.rect.element.height + itemVerticalMargin;
        bounds += height;
        visual += height * item.opacity;
      });
    }
    // grid
    else {
      bounds = Math.ceil(verticalItemCount / itemsPerRow) * itemHeight;
      visual = bounds;
    }

    return { visual: visual, bounds: bounds };
  };

  var calculateRootBoundingBoxHeight = function calculateRootBoundingBoxHeight(
    root
  ) {
    var height = root.ref.measureHeight || null;
    var cappedHeight = parseInt(root.style.maxHeight, 10) || null;
    var fixedHeight = height === 0 ? null : height;

    return {
      cappedHeight: cappedHeight,
      fixedHeight: fixedHeight
    };
  };

  var exceedsMaxFiles = function exceedsMaxFiles(root, items) {
    var allowReplace = root.query('GET_ALLOW_REPLACE');
    var allowMultiple = root.query('GET_ALLOW_MULTIPLE');
    var totalItems = root.query('GET_TOTAL_ITEMS');
    var maxItems = root.query('GET_MAX_FILES');

    // total amount of items being dragged
    var totalBrowseItems = items.length;

    // if does not allow multiple items and dragging more than one item
    if (!allowMultiple && totalBrowseItems > 1) {
      return true;
    }

    // limit max items to one if not allowed to drop multiple items
    maxItems = allowMultiple ? maxItems : allowReplace ? maxItems : 1;

    // no more room?
    var hasMaxItems = isInt(maxItems);
    if (hasMaxItems && totalItems + totalBrowseItems > maxItems) {
      root.dispatch('DID_THROW_MAX_FILES', {
        source: items,
        error: createResponse('warning', 0, 'Max files')
      });

      return true;
    }

    return false;
  };

  var getDragIndex = function getDragIndex(list, children, position) {
    var itemList = list.childViews[0];
    return getItemIndexByPosition(itemList, children, {
      left: position.scopeLeft - itemList.rect.element.left,
      top:
        position.scopeTop -
        (list.rect.outer.top +
          list.rect.element.marginTop +
          list.rect.element.scrollTop)
    });
  };

  /**
   * Enable or disable file drop functionality
   */
  var toggleDrop = function toggleDrop(root) {
    var isAllowed = root.query('GET_ALLOW_DROP');
    var isDisabled = root.query('GET_DISABLED');
    var enabled = isAllowed && !isDisabled;
    if (enabled && !root.ref.hopper) {
      var hopper = createHopper(
        root.element,
        function(items) {
          // allow quick validation of dropped items
          var beforeDropFile =
            root.query('GET_BEFORE_DROP_FILE') ||
            function() {
              return true;
            };

          // all items should be validated by all filters as valid
          var dropValidation = root.query('GET_DROP_VALIDATION');
          return dropValidation
            ? items.every(function(item) {
                return (
                  applyFilters('ALLOW_HOPPER_ITEM', item, {
                    query: root.query
                  }).every(function(result) {
                    return result === true;
                  }) && beforeDropFile(item)
                );
              })
            : true;
        },
        {
          filterItems: function filterItems(items) {
            var ignoredFiles = root.query('GET_IGNORED_FILES');
            return items.filter(function(item) {
              if (isFile(item)) {
                return !ignoredFiles.includes(item.name.toLowerCase());
              }
              return true;
            });
          },
          catchesDropsOnPage: root.query('GET_DROP_ON_PAGE'),
          requiresDropOnElement: root.query('GET_DROP_ON_ELEMENT')
        }
      );

      hopper.onload = function(items, position) {
        // get item children elements and sort based on list sort
        var list = root.ref.list.childViews[0];
        var visibleChildren = list.childViews.filter(function(child) {
          return child.rect.element.height;
        });
        var children = root
          .query('GET_ACTIVE_ITEMS')
          .map(function(item) {
            return visibleChildren.find(function(child) {
              return child.id === item.id;
            });
          })
          .filter(function(item) {
            return item;
          });

        applyFilterChain('ADD_ITEMS', items, { dispatch: root.dispatch }).then(
          function(queue) {
            // these files don't fit so stop here
            if (exceedsMaxFiles(root, queue)) return false;

            // go
            root.dispatch('ADD_ITEMS', {
              items: queue,
              index: getDragIndex(root.ref.list, children, position),
              interactionMethod: InteractionMethod.DROP
            });
          }
        );

        root.dispatch('DID_DROP', { position: position });

        root.dispatch('DID_END_DRAG', { position: position });
      };

      hopper.ondragstart = function(position) {
        root.dispatch('DID_START_DRAG', { position: position });
      };

      hopper.ondrag = debounce(function(position) {
        root.dispatch('DID_DRAG', { position: position });
      });

      hopper.ondragend = function(position) {
        root.dispatch('DID_END_DRAG', { position: position });
      };

      root.ref.hopper = hopper;

      root.ref.drip = root.appendChildView(root.createChildView(drip));
    } else if (!enabled && root.ref.hopper) {
      root.ref.hopper.destroy();
      root.ref.hopper = null;
      root.removeChildView(root.ref.drip);
    }
  };

  /**
   * Enable or disable browse functionality
   */
  var toggleBrowse = function toggleBrowse(root, props) {
    var isAllowed = root.query('GET_ALLOW_BROWSE');
    var isDisabled = root.query('GET_DISABLED');
    var enabled = isAllowed && !isDisabled;
    if (enabled && !root.ref.browser) {
      root.ref.browser = root.appendChildView(
        root.createChildView(
          browser,
          Object.assign({}, props, {
            onload: function onload(items) {
              applyFilterChain('ADD_ITEMS', items, {
                dispatch: root.dispatch
              }).then(function(queue) {
                // these files don't fit so stop here
                if (exceedsMaxFiles(root, queue)) return false;

                // add items!
                root.dispatch('ADD_ITEMS', {
                  items: queue,
                  index: -1,
                  interactionMethod: InteractionMethod.BROWSE
                });
              });
            }
          })
        ),

        0
      );
    } else if (!enabled && root.ref.browser) {
      root.removeChildView(root.ref.browser);
      root.ref.browser = null;
    }
  };

  /**
   * Enable or disable paste functionality
   */
  var togglePaste = function togglePaste(root) {
    var isAllowed = root.query('GET_ALLOW_PASTE');
    var isDisabled = root.query('GET_DISABLED');
    var enabled = isAllowed && !isDisabled;
    if (enabled && !root.ref.paster) {
      root.ref.paster = createPaster();
      root.ref.paster.onload = function(items) {
        applyFilterChain('ADD_ITEMS', items, { dispatch: root.dispatch }).then(
          function(queue) {
            // these files don't fit so stop here
            if (exceedsMaxFiles(root, queue)) return false;

            // add items!
            root.dispatch('ADD_ITEMS', {
              items: queue,
              index: -1,
              interactionMethod: InteractionMethod.PASTE
            });
          }
        );
      };
    } else if (!enabled && root.ref.paster) {
      root.ref.paster.destroy();
      root.ref.paster = null;
    }
  };

  /**
   * Route actions
   */
  var route$5 = createRoute({
    DID_SET_ALLOW_BROWSE: function DID_SET_ALLOW_BROWSE(_ref5) {
      var root = _ref5.root,
        props = _ref5.props;
      toggleBrowse(root, props);
    },
    DID_SET_ALLOW_DROP: function DID_SET_ALLOW_DROP(_ref6) {
      var root = _ref6.root;
      toggleDrop(root);
    },
    DID_SET_ALLOW_PASTE: function DID_SET_ALLOW_PASTE(_ref7) {
      var root = _ref7.root;
      togglePaste(root);
    },
    DID_SET_DISABLED: function DID_SET_DISABLED(_ref8) {
      var root = _ref8.root,
        props = _ref8.props;
      toggleDrop(root);
      togglePaste(root);
      toggleBrowse(root, props);
      var isDisabled = root.query('GET_DISABLED');
      if (isDisabled) {
        root.element.dataset.disabled = 'disabled';
      } else {
        // delete root.element.dataset.disabled; <= this does not work on iOS 10
        root.element.removeAttribute('data-disabled');
      }
    }
  });

  var root = createView({
    name: 'root',
    read: function read(_ref9) {
      var root = _ref9.root;
      if (root.ref.measure) {
        root.ref.measureHeight = root.ref.measure.offsetHeight;
      }
    },
    create: create$e,
    write: write$9,
    destroy: function destroy(_ref10) {
      var root = _ref10.root;
      if (root.ref.paster) {
        root.ref.paster.destroy();
      }
      if (root.ref.hopper) {
        root.ref.hopper.destroy();
      }
      root.element.removeEventListener('touchmove', prevent);
      root.element.removeEventListener('gesturestart', prevent);
    },
    mixins: {
      styles: ['height']
    }
  });

  // creates the app
  var createApp = function createApp() {
    var initialOptions =
      arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    // let element
    var originalElement = null;

    // get default options
    var defaultOptions = getOptions();

    // create the data store, this will contain all our app info
    var store = createStore(
      // initial state (should be serializable)
      createInitialState(defaultOptions),

      // queries
      [queries, createOptionQueries(defaultOptions)],

      // action handlers
      [actions, createOptionActions(defaultOptions)]
    );

    // set initial options
    store.dispatch('SET_OPTIONS', { options: initialOptions });

    // kick thread if visibility changes
    var visibilityHandler = function visibilityHandler() {
      if (document.hidden) return;
      store.dispatch('KICK');
    };
    document.addEventListener('visibilitychange', visibilityHandler);

    // re-render on window resize start and finish
    var resizeDoneTimer = null;
    var isResizing = false;
    var isResizingHorizontally = false;
    var initialWindowWidth = null;
    var currentWindowWidth = null;
    var resizeHandler = function resizeHandler() {
      if (!isResizing) {
        isResizing = true;
      }
      clearTimeout(resizeDoneTimer);
      resizeDoneTimer = setTimeout(function() {
        isResizing = false;
        initialWindowWidth = null;
        currentWindowWidth = null;
        if (isResizingHorizontally) {
          isResizingHorizontally = false;
          store.dispatch('DID_STOP_RESIZE');
        }
      }, 500);
    };
    window.addEventListener('resize', resizeHandler);

    // render initial view
    var view = root(store, { id: getUniqueId() });

    //
    // PRIVATE API -------------------------------------------------------------------------------------
    //
    var isResting = false;
    var isHidden = false;

    var readWriteApi = {
      // necessary for update loop

      /**
       * Reads from dom (never call manually)
       * @private
       */
      _read: function _read() {
        // test if we're resizing horizontally
        // TODO: see if we can optimize this by measuring root rect
        if (isResizing) {
          currentWindowWidth = window.innerWidth;
          if (!initialWindowWidth) {
            initialWindowWidth = currentWindowWidth;
          }

          if (
            !isResizingHorizontally &&
            currentWindowWidth !== initialWindowWidth
          ) {
            store.dispatch('DID_START_RESIZE');
            isResizingHorizontally = true;
          }
        }

        if (isHidden && isResting) {
          // test if is no longer hidden
          isResting = view.element.offsetParent === null;
        }

        // if resting, no need to read as numbers will still all be correct
        if (isResting) return;

        // read view data
        view._read();

        // if is hidden we need to know so we exit rest mode when revealed
        isHidden = view.rect.element.hidden;
      },

      /**
       * Writes to dom (never call manually)
       * @private
       */
      _write: function _write(ts) {
        // get all actions from store
        var actions = store
          .processActionQueue()

          // filter out set actions (these will automatically trigger DID_SET)
          .filter(function(action) {
            return !/^SET_/.test(action.type);
          });

        // if was idling and no actions stop here
        if (isResting && !actions.length) return;

        // some actions might trigger events
        routeActionsToEvents(actions);

        // update the view
        isResting = view._write(ts, actions, isResizingHorizontally);

        // will clean up all archived items
        removeReleasedItems(store.query('GET_ITEMS'));

        // now idling
        if (isResting) {
          store.processDispatchQueue();
        }
      }
    };

    //
    // EXPOSE EVENTS -------------------------------------------------------------------------------------
    //
    var createEvent = function createEvent(name) {
      return function(data) {
        // create default event
        var event = {
          type: name
        };

        // no data to add
        if (!data) {
          return event;
        }

        // copy relevant props
        if (data.hasOwnProperty('error')) {
          event.error = data.error ? Object.assign({}, data.error) : null;
        }

        if (data.status) {
          event.status = Object.assign({}, data.status);
        }

        if (data.file) {
          event.output = data.file;
        }

        // only source is available, else add item if possible
        if (data.source) {
          event.file = data.source;
        } else if (data.item || data.id) {
          var item = data.item ? data.item : store.query('GET_ITEM', data.id);
          event.file = item ? createItemAPI(item) : null;
        }

        // map all items in a possible items array
        if (data.items) {
          event.items = data.items.map(createItemAPI);
        }

        // if this is a progress event add the progress amount
        if (/progress/.test(name)) {
          event.progress = data.progress;
        }

        // copy relevant props
        if (data.hasOwnProperty('origin') && data.hasOwnProperty('target')) {
          event.origin = data.origin;
          event.target = data.target;
        }

        return event;
      };
    };

    var eventRoutes = {
      DID_DESTROY: createEvent('destroy'),

      DID_INIT: createEvent('init'),

      DID_THROW_MAX_FILES: createEvent('warning'),

      DID_INIT_ITEM: createEvent('initfile'),
      DID_START_ITEM_LOAD: createEvent('addfilestart'),
      DID_UPDATE_ITEM_LOAD_PROGRESS: createEvent('addfileprogress'),
      DID_LOAD_ITEM: createEvent('addfile'),

      DID_THROW_ITEM_INVALID: [createEvent('error'), createEvent('addfile')],

      DID_THROW_ITEM_LOAD_ERROR: [createEvent('error'), createEvent('addfile')],

      DID_THROW_ITEM_REMOVE_ERROR: [
        createEvent('error'),
        createEvent('removefile')
      ],

      DID_PREPARE_OUTPUT: createEvent('preparefile'),

      DID_START_ITEM_PROCESSING: createEvent('processfilestart'),
      DID_UPDATE_ITEM_PROCESS_PROGRESS: createEvent('processfileprogress'),
      DID_ABORT_ITEM_PROCESSING: createEvent('processfileabort'),
      DID_COMPLETE_ITEM_PROCESSING: createEvent('processfile'),
      DID_COMPLETE_ITEM_PROCESSING_ALL: createEvent('processfiles'),
      DID_REVERT_ITEM_PROCESSING: createEvent('processfilerevert'),

      DID_THROW_ITEM_PROCESSING_ERROR: [
        createEvent('error'),
        createEvent('processfile')
      ],

      DID_REMOVE_ITEM: createEvent('removefile'),

      DID_UPDATE_ITEMS: createEvent('updatefiles'),

      DID_ACTIVATE_ITEM: createEvent('activatefile'),

      DID_REORDER_ITEMS: createEvent('reorderfiles')
    };

    var exposeEvent = function exposeEvent(event) {
      // create event object to be dispatched
      var detail = Object.assign({ pond: exports }, event);
      delete detail.type;
      view.element.dispatchEvent(
        new CustomEvent('FilePond:' + event.type, {
          // event info
          detail: detail,

          // event behaviour
          bubbles: true,
          cancelable: true,
          composed: true // triggers listeners outside of shadow root
        })
      );

      // event object to params used for `on()` event handlers and callbacks `oninit()`
      var params = [];

      // if is possible error event, make it the first param
      if (event.hasOwnProperty('error')) {
        params.push(event.error);
      }

      // file is always section
      if (event.hasOwnProperty('file')) {
        params.push(event.file);
      }

      // append other props
      var filtered = ['type', 'error', 'file'];
      Object.keys(event)
        .filter(function(key) {
          return !filtered.includes(key);
        })
        .forEach(function(key) {
          return params.push(event[key]);
        });

      // on(type, () => { })
      exports.fire.apply(exports, [event.type].concat(params));

      // oninit = () => {}
      var handler = store.query('GET_ON' + event.type.toUpperCase());
      if (handler) {
        handler.apply(void 0, params);
      }
    };

    var routeActionsToEvents = function routeActionsToEvents(actions) {
      if (!actions.length) return;
      actions
        .filter(function(action) {
          return eventRoutes[action.type];
        })
        .forEach(function(action) {
          var routes = eventRoutes[action.type];
          (Array.isArray(routes) ? routes : [routes]).forEach(function(route) {
            // this isn't fantastic, but because of the stacking of settimeouts plugins can handle the did_load before the did_init
            if (action.type === 'DID_INIT_ITEM') {
              exposeEvent(route(action.data));
            } else {
              setTimeout(function() {
                exposeEvent(route(action.data));
              }, 0);
            }
          });
        });
    };

    //
    // PUBLIC API -------------------------------------------------------------------------------------
    //
    var setOptions = function setOptions(options) {
      return store.dispatch('SET_OPTIONS', { options: options });
    };

    var getFile = function getFile(query) {
      return store.query('GET_ACTIVE_ITEM', query);
    };

    var prepareFile = function prepareFile(query) {
      return new Promise(function(resolve, reject) {
        store.dispatch('REQUEST_ITEM_PREPARE', {
          query: query,
          success: function success(item) {
            resolve(item);
          },
          failure: function failure(error) {
            reject(error);
          }
        });
      });
    };

    var addFile = function addFile(source) {
      var options =
        arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return new Promise(function(resolve, reject) {
        addFiles([{ source: source, options: options }], {
          index: options.index
        })
          .then(function(items) {
            return resolve(items && items[0]);
          })
          .catch(reject);
      });
    };

    var isFilePondFile = function isFilePondFile(obj) {
      return obj.file && obj.id;
    };

    var removeFile = function removeFile(query, options) {
      // if only passed options
      if (typeof query === 'object' && !isFilePondFile(query) && !options) {
        options = query;
        query = undefined;
      }

      // request item removal
      store.dispatch(
        'REMOVE_ITEM',
        Object.assign({}, options, { query: query })
      );

      // see if item has been removed
      return store.query('GET_ACTIVE_ITEM', query) === null;
    };

    var addFiles = function addFiles() {
      for (
        var _len = arguments.length, args = new Array(_len), _key = 0;
        _key < _len;
        _key++
      ) {
        args[_key] = arguments[_key];
      }
      return new Promise(function(resolve, reject) {
        var sources = [];
        var options = {};

        // user passed a sources array
        if (isArray(args[0])) {
          sources.push.apply(sources, args[0]);
          Object.assign(options, args[1] || {});
        } else {
          // user passed sources as arguments, last one might be options object
          var lastArgument = args[args.length - 1];
          if (
            typeof lastArgument === 'object' &&
            !(lastArgument instanceof Blob)
          ) {
            Object.assign(options, args.pop());
          }

          // add rest to sources
          sources.push.apply(sources, args);
        }

        store.dispatch('ADD_ITEMS', {
          items: sources,
          index: options.index,
          interactionMethod: InteractionMethod.API,
          success: resolve,
          failure: reject
        });
      });
    };

    var getFiles = function getFiles() {
      return store.query('GET_ACTIVE_ITEMS');
    };

    var processFile = function processFile(query) {
      return new Promise(function(resolve, reject) {
        store.dispatch('REQUEST_ITEM_PROCESSING', {
          query: query,
          success: function success(item) {
            resolve(item);
          },
          failure: function failure(error) {
            reject(error);
          }
        });
      });
    };

    var prepareFiles = function prepareFiles() {
      for (
        var _len2 = arguments.length, args = new Array(_len2), _key2 = 0;
        _key2 < _len2;
        _key2++
      ) {
        args[_key2] = arguments[_key2];
      }
      var queries = Array.isArray(args[0]) ? args[0] : args;
      var items = queries.length ? queries : getFiles();
      return Promise.all(items.map(prepareFile));
    };

    var processFiles = function processFiles() {
      for (
        var _len3 = arguments.length, args = new Array(_len3), _key3 = 0;
        _key3 < _len3;
        _key3++
      ) {
        args[_key3] = arguments[_key3];
      }
      var queries = Array.isArray(args[0]) ? args[0] : args;
      if (!queries.length) {
        var files = getFiles().filter(function(item) {
          return (
            !(
              item.status === ItemStatus.IDLE &&
              item.origin === FileOrigin.LOCAL
            ) &&
            item.status !== ItemStatus.PROCESSING &&
            item.status !== ItemStatus.PROCESSING_COMPLETE &&
            item.status !== ItemStatus.PROCESSING_REVERT_ERROR
          );
        });

        return Promise.all(files.map(processFile));
      }
      return Promise.all(queries.map(processFile));
    };

    var removeFiles = function removeFiles() {
      for (
        var _len4 = arguments.length, args = new Array(_len4), _key4 = 0;
        _key4 < _len4;
        _key4++
      ) {
        args[_key4] = arguments[_key4];
      }

      var queries = Array.isArray(args[0]) ? args[0] : args;

      var options;
      if (typeof queries[queries.length - 1] === 'object') {
        options = queries.pop();
      } else if (Array.isArray(args[0])) {
        options = args[1];
      }

      var files = getFiles();

      if (!queries.length)
        return Promise.all(
          files.map(function(file) {
            return removeFile(file, options);
          })
        );

      // when removing by index the indexes shift after each file removal so we need to convert indexes to ids
      var mappedQueries = queries
        .map(function(query) {
          return isNumber(query)
            ? files[query]
              ? files[query].id
              : null
            : query;
        })
        .filter(function(query) {
          return query;
        });

      return mappedQueries.map(function(q) {
        return removeFile(q, options);
      });
    };

    var exports = Object.assign(
      {},

      on(),
      {},

      readWriteApi,
      {},

      createOptionAPI(store, defaultOptions),
      {
        /**
         * Override options defined in options object
         * @param options
         */
        setOptions: setOptions,

        /**
         * Load the given file
         * @param source - the source of the file (either a File, base64 data uri or url)
         * @param options - object, { index: 0 }
         */
        addFile: addFile,

        /**
         * Load the given files
         * @param sources - the sources of the files to load
         * @param options - object, { index: 0 }
         */
        addFiles: addFiles,

        /**
         * Returns the file objects matching the given query
         * @param query { string, number, null }
         */
        getFile: getFile,

        /**
         * Upload file with given name
         * @param query { string, number, null  }
         */
        processFile: processFile,

        /**
         * Request prepare output for file with given name
         * @param query { string, number, null  }
         */
        prepareFile: prepareFile,

        /**
         * Removes a file by its name
         * @param query { string, number, null  }
         */
        removeFile: removeFile,

        /**
         * Moves a file to a new location in the files list
         */
        moveFile: function moveFile(query, index) {
          return store.dispatch('MOVE_ITEM', { query: query, index: index });
        },

        /**
         * Returns all files (wrapped in public api)
         */
        getFiles: getFiles,

        /**
         * Starts uploading all files
         */
        processFiles: processFiles,

        /**
         * Clears all files from the files list
         */
        removeFiles: removeFiles,

        /**
         * Starts preparing output of all files
         */
        prepareFiles: prepareFiles,

        /**
         * Sort list of files
         */
        sort: function sort(compare) {
          return store.dispatch('SORT', { compare: compare });
        },

        /**
         * Browse the file system for a file
         */
        browse: function browse() {
          // needs to be trigger directly as user action needs to be traceable (is not traceable in requestAnimationFrame)
          var input = view.element.querySelector('input[type=file]');
          if (input) {
            input.click();
          }
        },

        /**
         * Destroys the app
         */
        destroy: function destroy() {
          // request destruction
          exports.fire('destroy', view.element);

          // stop active processes (file uploads, fetches, stuff like that)
          // loop over items and depending on states call abort for ongoing processes
          store.dispatch('ABORT_ALL');

          // destroy view
          view._destroy();

          // stop listening to resize
          window.removeEventListener('resize', resizeHandler);

          // stop listening to the visiblitychange event
          document.removeEventListener('visibilitychange', visibilityHandler);

          // dispatch destroy
          store.dispatch('DID_DESTROY');
        },

        /**
         * Inserts the plugin before the target element
         */
        insertBefore: function insertBefore$1(element) {
          return insertBefore(view.element, element);
        },

        /**
         * Inserts the plugin after the target element
         */
        insertAfter: function insertAfter$1(element) {
          return insertAfter(view.element, element);
        },

        /**
         * Appends the plugin to the target element
         */
        appendTo: function appendTo(element) {
          return element.appendChild(view.element);
        },

        /**
         * Replaces an element with the app
         */
        replaceElement: function replaceElement(element) {
          // insert the app before the element
          insertBefore(view.element, element);

          // remove the original element
          element.parentNode.removeChild(element);

          // remember original element
          originalElement = element;
        },

        /**
         * Restores the original element
         */
        restoreElement: function restoreElement() {
          if (!originalElement) {
            return; // no element to restore
          }

          // restore original element
          insertAfter(originalElement, view.element);

          // remove our element
          view.element.parentNode.removeChild(view.element);

          // remove reference
          originalElement = null;
        },

        /**
         * Returns true if the app root is attached to given element
         * @param element
         */
        isAttachedTo: function isAttachedTo(element) {
          return view.element === element || originalElement === element;
        },

        /**
         * Returns the root element
         */
        element: {
          get: function get() {
            return view.element;
          }
        },

        /**
         * Returns the current pond status
         */
        status: {
          get: function get() {
            return store.query('GET_STATUS');
          }
        }
      }
    );

    // Done!
    store.dispatch('DID_INIT');

    // create actual api object
    return createObject(exports);
  };

  var createAppObject = function createAppObject() {
    var customOptions =
      arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    // default options
    var defaultOptions = {};
    forin(getOptions(), function(key, value) {
      defaultOptions[key] = value[0];
    });

    // set app options
    var app = createApp(
      Object.assign(
        {},

        defaultOptions,
        {},

        customOptions
      )
    );

    // return the plugin instance
    return app;
  };

  var lowerCaseFirstLetter = function lowerCaseFirstLetter(string) {
    return string.charAt(0).toLowerCase() + string.slice(1);
  };

  var attributeNameToPropertyName = function attributeNameToPropertyName(
    attributeName
  ) {
    return toCamels(attributeName.replace(/^data-/, ''));
  };

  var mapObject = function mapObject(object, propertyMap) {
    // remove unwanted
    forin(propertyMap, function(selector, mapping) {
      forin(object, function(property, value) {
        // create regexp shortcut
        var selectorRegExp = new RegExp(selector);

        // tests if
        var matches = selectorRegExp.test(property);

        // no match, skip
        if (!matches) {
          return;
        }

        // if there's a mapping, the original property is always removed
        delete object[property];

        // should only remove, we done!
        if (mapping === false) {
          return;
        }

        // move value to new property
        if (isString(mapping)) {
          object[mapping] = value;
          return;
        }

        // move to group
        var group = mapping.group;
        if (isObject(mapping) && !object[group]) {
          object[group] = {};
        }

        object[group][
          lowerCaseFirstLetter(property.replace(selectorRegExp, ''))
        ] = value;
      });

      // do submapping
      if (mapping.mapping) {
        mapObject(object[mapping.group], mapping.mapping);
      }
    });
  };

  var getAttributesAsObject = function getAttributesAsObject(node) {
    var attributeMapping =
      arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    // turn attributes into object
    var attributes = [];
    forin(node.attributes, function(index) {
      attributes.push(node.attributes[index]);
    });

    var output = attributes
      .filter(function(attribute) {
        return attribute.name;
      })
      .reduce(function(obj, attribute) {
        var value = attr(node, attribute.name);

        obj[attributeNameToPropertyName(attribute.name)] =
          value === attribute.name ? true : value;
        return obj;
      }, {});

    // do mapping of object properties
    mapObject(output, attributeMapping);

    return output;
  };

  var createAppAtElement = function createAppAtElement(element) {
    var options =
      arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    // how attributes of the input element are mapped to the options for the plugin
    var attributeMapping = {
      // translate to other name
      '^class$': 'className',
      '^multiple$': 'allowMultiple',
      '^capture$': 'captureMethod',
      '^webkitdirectory$': 'allowDirectoriesOnly',

      // group under single property
      '^server': {
        group: 'server',
        mapping: {
          '^process': {
            group: 'process'
          },

          '^revert': {
            group: 'revert'
          },

          '^fetch': {
            group: 'fetch'
          },

          '^restore': {
            group: 'restore'
          },

          '^load': {
            group: 'load'
          }
        }
      },

      // don't include in object
      '^type$': false,
      '^files$': false
    };

    // add additional option translators
    applyFilters('SET_ATTRIBUTE_TO_OPTION_MAP', attributeMapping);

    // create final options object by setting options object and then overriding options supplied on element
    var mergedOptions = Object.assign({}, options);

    var attributeOptions = getAttributesAsObject(
      element.nodeName === 'FIELDSET'
        ? element.querySelector('input[type=file]')
        : element,
      attributeMapping
    );

    // merge with options object
    Object.keys(attributeOptions).forEach(function(key) {
      if (isObject(attributeOptions[key])) {
        if (!isObject(mergedOptions[key])) {
          mergedOptions[key] = {};
        }
        Object.assign(mergedOptions[key], attributeOptions[key]);
      } else {
        mergedOptions[key] = attributeOptions[key];
      }
    });

    // if parent is a fieldset, get files from parent by selecting all input fields that are not file upload fields
    // these will then be automatically set to the initial files
    mergedOptions.files = (options.files || []).concat(
      Array.from(element.querySelectorAll('input:not([type=file])')).map(
        function(input) {
          return {
            source: input.value,
            options: {
              type: input.dataset.type
            }
          };
        }
      )
    );

    // build plugin
    var app = createAppObject(mergedOptions);

    // add already selected files
    if (element.files) {
      Array.from(element.files).forEach(function(file) {
        app.addFile(file);
      });
    }

    // replace the target element
    app.replaceElement(element);

    // expose
    return app;
  };

  // if an element is passed, we create the instance at that element, if not, we just create an up object
  var createApp$1 = function createApp() {
    return isNode(arguments.length <= 0 ? undefined : arguments[0])
      ? createAppAtElement.apply(void 0, arguments)
      : createAppObject.apply(void 0, arguments);
  };

  var PRIVATE_METHODS = ['fire', '_read', '_write'];

  var createAppAPI = function createAppAPI(app) {
    var api = {};

    copyObjectPropertiesToObject(app, api, PRIVATE_METHODS);

    return api;
  };

  /**
   * Replaces placeholders in given string with replacements
   * @param string - "Foo {bar}""
   * @param replacements - { "bar": 10 }
   */
  var replaceInString = function replaceInString(string, replacements) {
    return string.replace(/(?:{([a-zA-Z]+)})/g, function(match, group) {
      return replacements[group];
    });
  };

  var createWorker = function createWorker(fn) {
    var workerBlob = new Blob(['(', fn.toString(), ')()'], {
      type: 'application/javascript'
    });

    var workerURL = URL.createObjectURL(workerBlob);
    var worker = new Worker(workerURL);

    return {
      transfer: function transfer(message, cb) {},
      post: function post(message, cb, transferList) {
        var id = getUniqueId();

        worker.onmessage = function(e) {
          if (e.data.id === id) {
            cb(e.data.message);
          }
        };

        worker.postMessage(
          {
            id: id,
            message: message
          },

          transferList
        );
      },
      terminate: function terminate() {
        worker.terminate();
        URL.revokeObjectURL(workerURL);
      }
    };
  };

  var loadImage = function loadImage(url) {
    return new Promise(function(resolve, reject) {
      var img = new Image();
      img.onload = function() {
        resolve(img);
      };
      img.onerror = function(e) {
        reject(e);
      };
      img.src = url;
    });
  };

  var renameFile = function renameFile(file, name) {
    var renamedFile = file.slice(0, file.size, file.type);
    renamedFile.lastModifiedDate = file.lastModifiedDate;
    renamedFile.name = name;
    return renamedFile;
  };

  var copyFile = function copyFile(file) {
    return renameFile(file, file.name);
  };

  // already registered plugins (can't register twice)
  var registeredPlugins = [];

  // pass utils to plugin
  var createAppPlugin = function createAppPlugin(plugin) {
    // already registered
    if (registeredPlugins.includes(plugin)) {
      return;
    }

    // remember this plugin
    registeredPlugins.push(plugin);

    // setup!
    var pluginOutline = plugin({
      addFilter: addFilter,
      utils: {
        Type: Type,
        forin: forin,
        isString: isString,
        isFile: isFile,
        toNaturalFileSize: toNaturalFileSize,
        replaceInString: replaceInString,
        getExtensionFromFilename: getExtensionFromFilename,
        getFilenameWithoutExtension: getFilenameWithoutExtension,
        guesstimateMimeType: guesstimateMimeType,
        getFileFromBlob: getFileFromBlob,
        getFilenameFromURL: getFilenameFromURL,
        createRoute: createRoute,
        createWorker: createWorker,
        createView: createView,
        createItemAPI: createItemAPI,
        loadImage: loadImage,
        copyFile: copyFile,
        renameFile: renameFile,
        createBlob: createBlob,
        applyFilterChain: applyFilterChain,
        text: text,
        getNumericAspectRatioFromString: getNumericAspectRatioFromString
      },

      views: {
        fileActionButton: fileActionButton
      }
    });

    // add plugin options to default options
    extendDefaultOptions(pluginOutline.options);
  };

  // feature detection used by supported() method
  var isOperaMini = function isOperaMini() {
    return (
      Object.prototype.toString.call(window.operamini) === '[object OperaMini]'
    );
  };
  var hasPromises = function hasPromises() {
    return 'Promise' in window;
  };
  var hasBlobSlice = function hasBlobSlice() {
    return 'slice' in Blob.prototype;
  };
  var hasCreateObjectURL = function hasCreateObjectURL() {
    return 'URL' in window && 'createObjectURL' in window.URL;
  };
  var hasVisibility = function hasVisibility() {
    return 'visibilityState' in document;
  };
  var hasTiming = function hasTiming() {
    return 'performance' in window;
  }; // iOS 8.x
  var hasCSSSupports = function hasCSSSupports() {
    return 'supports' in (window.CSS || {});
  }; // use to detect Safari 9+
  var isIE11 = function isIE11() {
    return /MSIE|Trident/.test(window.navigator.userAgent);
  };

  var supported = (function() {
    // Runs immediately and then remembers result for subsequent calls
    var isSupported =
      // Has to be a browser
      isBrowser() &&
      // Can't run on Opera Mini due to lack of everything
      !isOperaMini() &&
      // Require these APIs to feature detect a modern browser
      hasVisibility() &&
      hasPromises() &&
      hasBlobSlice() &&
      hasCreateObjectURL() &&
      hasTiming() &&
      // doesn't need CSSSupports but is a good way to detect Safari 9+ (we do want to support IE11 though)
      (hasCSSSupports() || isIE11());

    return function() {
      return isSupported;
    };
  })();

  /**
   * Plugin internal state (over all instances)
   */
  var state = {
    // active app instances, used to redraw the apps and to find the later
    apps: []
  };

  // plugin name
  var name = 'filepond';

  /**
   * Public Plugin methods
   */
  var fn = function fn() {};
  exports.Status = {};
  exports.FileStatus = {};
  exports.FileOrigin = {};
  exports.OptionTypes = {};
  exports.create = fn;
  exports.destroy = fn;
  exports.parse = fn;
  exports.find = fn;
  exports.registerPlugin = fn;
  exports.getOptions = fn;
  exports.setOptions = fn;

  // if not supported, no API
  if (supported()) {
    // start painter and fire load event
    createPainter(
      function() {
        state.apps.forEach(function(app) {
          return app._read();
        });
      },
      function(ts) {
        state.apps.forEach(function(app) {
          return app._write(ts);
        });
      }
    );

    // fire loaded event so we know when FilePond is available
    var dispatch = function dispatch() {
      // let others know we have area ready
      document.dispatchEvent(
        new CustomEvent('FilePond:loaded', {
          detail: {
            supported: supported,
            create: exports.create,
            destroy: exports.destroy,
            parse: exports.parse,
            find: exports.find,
            registerPlugin: exports.registerPlugin,
            setOptions: exports.setOptions
          }
        })
      );

      // clean up event
      document.removeEventListener('DOMContentLoaded', dispatch);
    };

    if (document.readyState !== 'loading') {
      // move to back of execution queue, FilePond should have been exported by then
      setTimeout(function() {
        return dispatch();
      }, 0);
    } else {
      document.addEventListener('DOMContentLoaded', dispatch);
    }

    // updates the OptionTypes object based on the current options
    var updateOptionTypes = function updateOptionTypes() {
      return forin(getOptions(), function(key, value) {
        exports.OptionTypes[key] = value[1];
      });
    };

    exports.Status = Object.assign({}, Status);
    exports.FileOrigin = Object.assign({}, FileOrigin);
    exports.FileStatus = Object.assign({}, ItemStatus);

    exports.OptionTypes = {};
    updateOptionTypes();

    // create method, creates apps and adds them to the app array
    exports.create = function create() {
      var app = createApp$1.apply(void 0, arguments);
      app.on('destroy', exports.destroy);
      state.apps.push(app);
      return createAppAPI(app);
    };

    // destroys apps and removes them from the app array
    exports.destroy = function destroy(hook) {
      // returns true if the app was destroyed successfully
      var indexToRemove = state.apps.findIndex(function(app) {
        return app.isAttachedTo(hook);
      });
      if (indexToRemove >= 0) {
        // remove from apps
        var app = state.apps.splice(indexToRemove, 1)[0];

        // restore original dom element
        app.restoreElement();

        return true;
      }

      return false;
    };

    // parses the given context for plugins (does not include the context element itself)
    exports.parse = function parse(context) {
      // get all possible hooks
      var matchedHooks = Array.from(context.querySelectorAll('.' + name));

      // filter out already active hooks
      var newHooks = matchedHooks.filter(function(newHook) {
        return !state.apps.find(function(app) {
          return app.isAttachedTo(newHook);
        });
      });

      // create new instance for each hook
      return newHooks.map(function(hook) {
        return exports.create(hook);
      });
    };

    // returns an app based on the given element hook
    exports.find = function find(hook) {
      var app = state.apps.find(function(app) {
        return app.isAttachedTo(hook);
      });
      if (!app) {
        return null;
      }
      return createAppAPI(app);
    };

    // adds a plugin extension
    exports.registerPlugin = function registerPlugin() {
      for (
        var _len = arguments.length, plugins = new Array(_len), _key = 0;
        _key < _len;
        _key++
      ) {
        plugins[_key] = arguments[_key];
      }

      // register plugins
      plugins.forEach(createAppPlugin);

      // update OptionTypes, each plugin might have extended the default options
      updateOptionTypes();
    };

    exports.getOptions = function getOptions$1() {
      var opts = {};
      forin(getOptions(), function(key, value) {
        opts[key] = value[0];
      });
      return opts;
    };

    exports.setOptions = function setOptions$1(opts) {
      if (isObject(opts)) {
        // update existing plugins
        state.apps.forEach(function(app) {
          app.setOptions(opts);
        });

        // override defaults
        setOptions(opts);
      }

      // return new options
      return exports.getOptions();
    };
  }

  exports.supported = supported;

  Object.defineProperty(exports, '__esModule', { value: true });
});


/***/ }),

/***/ "./node_modules/filepond/dist/filepond.min.css":
/*!*****************************************************!*\
  !*** ./node_modules/filepond/dist/filepond.min.css ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../../css-loader??ref--9-1!../../postcss-loader/src??ref--9-2!./filepond.min.css */ "./node_modules/css-loader/index.js?!./node_modules/postcss-loader/src/index.js?!./node_modules/filepond/dist/filepond.min.css");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../../style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ "./node_modules/style-loader/lib/addStyles.js":
/*!****************************************************!*\
  !*** ./node_modules/style-loader/lib/addStyles.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var stylesInDom = {};

var	memoize = function (fn) {
	var memo;

	return function () {
		if (typeof memo === "undefined") memo = fn.apply(this, arguments);
		return memo;
	};
};

var isOldIE = memoize(function () {
	// Test for IE <= 9 as proposed by Browserhacks
	// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
	// Tests for existence of standard globals is to allow style-loader
	// to operate correctly into non-standard environments
	// @see https://github.com/webpack-contrib/style-loader/issues/177
	return window && document && document.all && !window.atob;
});

var getTarget = function (target, parent) {
  if (parent){
    return parent.querySelector(target);
  }
  return document.querySelector(target);
};

var getElement = (function (fn) {
	var memo = {};

	return function(target, parent) {
                // If passing function in options, then use it for resolve "head" element.
                // Useful for Shadow Root style i.e
                // {
                //   insertInto: function () { return document.querySelector("#foo").shadowRoot }
                // }
                if (typeof target === 'function') {
                        return target();
                }
                if (typeof memo[target] === "undefined") {
			var styleTarget = getTarget.call(this, target, parent);
			// Special case to return head of iframe instead of iframe itself
			if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
				try {
					// This will throw an exception if access to iframe is blocked
					// due to cross-origin restrictions
					styleTarget = styleTarget.contentDocument.head;
				} catch(e) {
					styleTarget = null;
				}
			}
			memo[target] = styleTarget;
		}
		return memo[target]
	};
})();

var singleton = null;
var	singletonCounter = 0;
var	stylesInsertedAtTop = [];

var	fixUrls = __webpack_require__(/*! ./urls */ "./node_modules/style-loader/lib/urls.js");

module.exports = function(list, options) {
	if (typeof DEBUG !== "undefined" && DEBUG) {
		if (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};

	options.attrs = typeof options.attrs === "object" ? options.attrs : {};

	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (!options.singleton && typeof options.singleton !== "boolean") options.singleton = isOldIE();

	// By default, add <style> tags to the <head> element
        if (!options.insertInto) options.insertInto = "head";

	// By default, add <style> tags to the bottom of the target
	if (!options.insertAt) options.insertAt = "bottom";

	var styles = listToStyles(list, options);

	addStylesToDom(styles, options);

	return function update (newList) {
		var mayRemove = [];

		for (var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];

			domStyle.refs--;
			mayRemove.push(domStyle);
		}

		if(newList) {
			var newStyles = listToStyles(newList, options);
			addStylesToDom(newStyles, options);
		}

		for (var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];

			if(domStyle.refs === 0) {
				for (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();

				delete stylesInDom[domStyle.id];
			}
		}
	};
};

function addStylesToDom (styles, options) {
	for (var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];

		if(domStyle) {
			domStyle.refs++;

			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}

			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];

			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}

			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles (list, options) {
	var styles = [];
	var newStyles = {};

	for (var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = options.base ? item[0] + options.base : item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};

		if(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});
		else newStyles[id].parts.push(part);
	}

	return styles;
}

function insertStyleElement (options, style) {
	var target = getElement(options.insertInto)

	if (!target) {
		throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
	}

	var lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];

	if (options.insertAt === "top") {
		if (!lastStyleElementInsertedAtTop) {
			target.insertBefore(style, target.firstChild);
		} else if (lastStyleElementInsertedAtTop.nextSibling) {
			target.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			target.appendChild(style);
		}
		stylesInsertedAtTop.push(style);
	} else if (options.insertAt === "bottom") {
		target.appendChild(style);
	} else if (typeof options.insertAt === "object" && options.insertAt.before) {
		var nextSibling = getElement(options.insertAt.before, target);
		target.insertBefore(style, nextSibling);
	} else {
		throw new Error("[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n");
	}
}

function removeStyleElement (style) {
	if (style.parentNode === null) return false;
	style.parentNode.removeChild(style);

	var idx = stylesInsertedAtTop.indexOf(style);
	if(idx >= 0) {
		stylesInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement (options) {
	var style = document.createElement("style");

	if(options.attrs.type === undefined) {
		options.attrs.type = "text/css";
	}

	if(options.attrs.nonce === undefined) {
		var nonce = getNonce();
		if (nonce) {
			options.attrs.nonce = nonce;
		}
	}

	addAttrs(style, options.attrs);
	insertStyleElement(options, style);

	return style;
}

function createLinkElement (options) {
	var link = document.createElement("link");

	if(options.attrs.type === undefined) {
		options.attrs.type = "text/css";
	}
	options.attrs.rel = "stylesheet";

	addAttrs(link, options.attrs);
	insertStyleElement(options, link);

	return link;
}

function addAttrs (el, attrs) {
	Object.keys(attrs).forEach(function (key) {
		el.setAttribute(key, attrs[key]);
	});
}

function getNonce() {
	if (false) {}

	return __webpack_require__.nc;
}

function addStyle (obj, options) {
	var style, update, remove, result;

	// If a transform function was defined, run it on the css
	if (options.transform && obj.css) {
	    result = typeof options.transform === 'function'
		 ? options.transform(obj.css) 
		 : options.transform.default(obj.css);

	    if (result) {
	    	// If transform returns a value, use that instead of the original css.
	    	// This allows running runtime transformations on the css.
	    	obj.css = result;
	    } else {
	    	// If the transform function returns a falsy value, don't add this css.
	    	// This allows conditional loading of css
	    	return function() {
	    		// noop
	    	};
	    }
	}

	if (options.singleton) {
		var styleIndex = singletonCounter++;

		style = singleton || (singleton = createStyleElement(options));

		update = applyToSingletonTag.bind(null, style, styleIndex, false);
		remove = applyToSingletonTag.bind(null, style, styleIndex, true);

	} else if (
		obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function"
	) {
		style = createLinkElement(options);
		update = updateLink.bind(null, style, options);
		remove = function () {
			removeStyleElement(style);

			if(style.href) URL.revokeObjectURL(style.href);
		};
	} else {
		style = createStyleElement(options);
		update = applyToTag.bind(null, style);
		remove = function () {
			removeStyleElement(style);
		};
	}

	update(obj);

	return function updateStyle (newObj) {
		if (newObj) {
			if (
				newObj.css === obj.css &&
				newObj.media === obj.media &&
				newObj.sourceMap === obj.sourceMap
			) {
				return;
			}

			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;

		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag (style, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (style.styleSheet) {
		style.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = style.childNodes;

		if (childNodes[index]) style.removeChild(childNodes[index]);

		if (childNodes.length) {
			style.insertBefore(cssNode, childNodes[index]);
		} else {
			style.appendChild(cssNode);
		}
	}
}

function applyToTag (style, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		style.setAttribute("media", media)
	}

	if(style.styleSheet) {
		style.styleSheet.cssText = css;
	} else {
		while(style.firstChild) {
			style.removeChild(style.firstChild);
		}

		style.appendChild(document.createTextNode(css));
	}
}

function updateLink (link, options, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	/*
		If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
		and there is no publicPath defined then lets turn convertToAbsoluteUrls
		on by default.  Otherwise default to the convertToAbsoluteUrls option
		directly
	*/
	var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;

	if (options.convertToAbsoluteUrls || autoFixUrls) {
		css = fixUrls(css);
	}

	if (sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = link.href;

	link.href = URL.createObjectURL(blob);

	if(oldSrc) URL.revokeObjectURL(oldSrc);
}


/***/ }),

/***/ "./node_modules/style-loader/lib/urls.js":
/*!***********************************************!*\
  !*** ./node_modules/style-loader/lib/urls.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {


/**
 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
 * embed the css on the page. This breaks all relative urls because now they are relative to a
 * bundle instead of the current page.
 *
 * One solution is to only use full urls, but that may be impossible.
 *
 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
 *
 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
 *
 */

module.exports = function (css) {
  // get current location
  var location = typeof window !== "undefined" && window.location;

  if (!location) {
    throw new Error("fixUrls requires window.location");
  }

	// blank or null?
	if (!css || typeof css !== "string") {
	  return css;
  }

  var baseUrl = location.protocol + "//" + location.host;
  var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/");

	// convert each url(...)
	/*
	This regular expression is just a way to recursively match brackets within
	a string.

	 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
	   (  = Start a capturing group
	     (?:  = Start a non-capturing group
	         [^)(]  = Match anything that isn't a parentheses
	         |  = OR
	         \(  = Match a start parentheses
	             (?:  = Start another non-capturing groups
	                 [^)(]+  = Match anything that isn't a parentheses
	                 |  = OR
	                 \(  = Match a start parentheses
	                     [^)(]*  = Match anything that isn't a parentheses
	                 \)  = Match a end parentheses
	             )  = End Group
              *\) = Match anything and then a close parens
          )  = Close non-capturing group
          *  = Match anything
       )  = Close capturing group
	 \)  = Match a close parens

	 /gi  = Get all matches, not the first.  Be case insensitive.
	 */
	var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function(fullMatch, origUrl) {
		// strip quotes (if they exist)
		var unquotedOrigUrl = origUrl
			.trim()
			.replace(/^"(.*)"$/, function(o, $1){ return $1; })
			.replace(/^'(.*)'$/, function(o, $1){ return $1; });

		// already a full url? no change
		if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/|\s*$)/i.test(unquotedOrigUrl)) {
		  return fullMatch;
		}

		// convert the url to a full url
		var newUrl;

		if (unquotedOrigUrl.indexOf("//") === 0) {
		  	//TODO: should we add protocol?
			newUrl = unquotedOrigUrl;
		} else if (unquotedOrigUrl.indexOf("/") === 0) {
			// path should be relative to the base url
			newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
		} else {
			// path should be relative to current directory
			newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
		}

		// send back the fixed url(...)
		return "url(" + JSON.stringify(newUrl) + ")";
	});

	// send back the fixed css
	return fixedCss;
};


/***/ }),

/***/ "./node_modules/sweetalert2/dist/sweetalert2.all.js":
/*!**********************************************************!*\
  !*** ./node_modules/sweetalert2/dist/sweetalert2.all.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*!
* sweetalert2 v9.17.2
* Released under the MIT License.
*/
(function (global, factory) {
   true ? module.exports = factory() :
  undefined;
}(this, function () { 'use strict';

  function _typeof(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _extends() {
    _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends.apply(this, arguments);
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _construct(Parent, args, Class) {
    if (_isNativeReflectConstruct()) {
      _construct = Reflect.construct;
    } else {
      _construct = function _construct(Parent, args, Class) {
        var a = [null];
        a.push.apply(a, args);
        var Constructor = Function.bind.apply(Parent, a);
        var instance = new Constructor();
        if (Class) _setPrototypeOf(instance, Class.prototype);
        return instance;
      };
    }

    return _construct.apply(null, arguments);
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized(self);
  }

  function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();

    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
          result;

      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;

        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }

      return _possibleConstructorReturn(this, result);
    };
  }

  function _superPropBase(object, property) {
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
      object = _getPrototypeOf(object);
      if (object === null) break;
    }

    return object;
  }

  function _get(target, property, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.get) {
      _get = Reflect.get;
    } else {
      _get = function _get(target, property, receiver) {
        var base = _superPropBase(target, property);

        if (!base) return;
        var desc = Object.getOwnPropertyDescriptor(base, property);

        if (desc.get) {
          return desc.get.call(receiver);
        }

        return desc.value;
      };
    }

    return _get(target, property, receiver || target);
  }

  var consolePrefix = 'SweetAlert2:';
  /**
   * Filter the unique values into a new array
   * @param arr
   */

  var uniqueArray = function uniqueArray(arr) {
    var result = [];

    for (var i = 0; i < arr.length; i++) {
      if (result.indexOf(arr[i]) === -1) {
        result.push(arr[i]);
      }
    }

    return result;
  };
  /**
   * Capitalize the first letter of a string
   * @param str
   */

  var capitalizeFirstLetter = function capitalizeFirstLetter(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  };
  /**
   * Returns the array of object values (Object.values isn't supported in IE11)
   * @param obj
   */

  var objectValues = function objectValues(obj) {
    return Object.keys(obj).map(function (key) {
      return obj[key];
    });
  };
  /**
   * Convert NodeList to Array
   * @param nodeList
   */

  var toArray = function toArray(nodeList) {
    return Array.prototype.slice.call(nodeList);
  };
  /**
   * Standardise console warnings
   * @param message
   */

  var warn = function warn(message) {
    console.warn("".concat(consolePrefix, " ").concat(message));
  };
  /**
   * Standardise console errors
   * @param message
   */

  var error = function error(message) {
    console.error("".concat(consolePrefix, " ").concat(message));
  };
  /**
   * Private global state for `warnOnce`
   * @type {Array}
   * @private
   */

  var previousWarnOnceMessages = [];
  /**
   * Show a console warning, but only if it hasn't already been shown
   * @param message
   */

  var warnOnce = function warnOnce(message) {
    if (!(previousWarnOnceMessages.indexOf(message) !== -1)) {
      previousWarnOnceMessages.push(message);
      warn(message);
    }
  };
  /**
   * Show a one-time console warning about deprecated params/methods
   */

  var warnAboutDepreation = function warnAboutDepreation(deprecatedParam, useInstead) {
    warnOnce("\"".concat(deprecatedParam, "\" is deprecated and will be removed in the next major release. Please use \"").concat(useInstead, "\" instead."));
  };
  /**
   * If `arg` is a function, call it (with no arguments or context) and return the result.
   * Otherwise, just pass the value through
   * @param arg
   */

  var callIfFunction = function callIfFunction(arg) {
    return typeof arg === 'function' ? arg() : arg;
  };
  var hasToPromiseFn = function hasToPromiseFn(arg) {
    return arg && typeof arg.toPromise === 'function';
  };
  var asPromise = function asPromise(arg) {
    return hasToPromiseFn(arg) ? arg.toPromise() : Promise.resolve(arg);
  };
  var isPromise = function isPromise(arg) {
    return arg && Promise.resolve(arg) === arg;
  };

  var DismissReason = Object.freeze({
    cancel: 'cancel',
    backdrop: 'backdrop',
    close: 'close',
    esc: 'esc',
    timer: 'timer'
  });

  var isJqueryElement = function isJqueryElement(elem) {
    return _typeof(elem) === 'object' && elem.jquery;
  };

  var isElement = function isElement(elem) {
    return elem instanceof Element || isJqueryElement(elem);
  };

  var argsToParams = function argsToParams(args) {
    var params = {};

    if (_typeof(args[0]) === 'object' && !isElement(args[0])) {
      _extends(params, args[0]);
    } else {
      ['title', 'html', 'icon'].forEach(function (name, index) {
        var arg = args[index];

        if (typeof arg === 'string' || isElement(arg)) {
          params[name] = arg;
        } else if (arg !== undefined) {
          error("Unexpected type of ".concat(name, "! Expected \"string\" or \"Element\", got ").concat(_typeof(arg)));
        }
      });
    }

    return params;
  };

  var swalPrefix = 'swal2-';
  var prefix = function prefix(items) {
    var result = {};

    for (var i in items) {
      result[items[i]] = swalPrefix + items[i];
    }

    return result;
  };
  var swalClasses = prefix(['container', 'shown', 'height-auto', 'iosfix', 'popup', 'modal', 'no-backdrop', 'no-transition', 'toast', 'toast-shown', 'toast-column', 'show', 'hide', 'close', 'title', 'header', 'content', 'html-container', 'actions', 'confirm', 'cancel', 'footer', 'icon', 'icon-content', 'image', 'input', 'file', 'range', 'select', 'radio', 'checkbox', 'label', 'textarea', 'inputerror', 'validation-message', 'progress-steps', 'active-progress-step', 'progress-step', 'progress-step-line', 'loading', 'styled', 'top', 'top-start', 'top-end', 'top-left', 'top-right', 'center', 'center-start', 'center-end', 'center-left', 'center-right', 'bottom', 'bottom-start', 'bottom-end', 'bottom-left', 'bottom-right', 'grow-row', 'grow-column', 'grow-fullscreen', 'rtl', 'timer-progress-bar', 'timer-progress-bar-container', 'scrollbar-measure', 'icon-success', 'icon-warning', 'icon-info', 'icon-question', 'icon-error']);
  var iconTypes = prefix(['success', 'warning', 'info', 'question', 'error']);

  var getContainer = function getContainer() {
    return document.body.querySelector(".".concat(swalClasses.container));
  };
  var elementBySelector = function elementBySelector(selectorString) {
    var container = getContainer();
    return container ? container.querySelector(selectorString) : null;
  };

  var elementByClass = function elementByClass(className) {
    return elementBySelector(".".concat(className));
  };

  var getPopup = function getPopup() {
    return elementByClass(swalClasses.popup);
  };
  var getIcons = function getIcons() {
    var popup = getPopup();
    return toArray(popup.querySelectorAll(".".concat(swalClasses.icon)));
  };
  var getIcon = function getIcon() {
    var visibleIcon = getIcons().filter(function (icon) {
      return isVisible(icon);
    });
    return visibleIcon.length ? visibleIcon[0] : null;
  };
  var getTitle = function getTitle() {
    return elementByClass(swalClasses.title);
  };
  var getContent = function getContent() {
    return elementByClass(swalClasses.content);
  };
  var getHtmlContainer = function getHtmlContainer() {
    return elementByClass(swalClasses['html-container']);
  };
  var getImage = function getImage() {
    return elementByClass(swalClasses.image);
  };
  var getProgressSteps = function getProgressSteps() {
    return elementByClass(swalClasses['progress-steps']);
  };
  var getValidationMessage = function getValidationMessage() {
    return elementByClass(swalClasses['validation-message']);
  };
  var getConfirmButton = function getConfirmButton() {
    return elementBySelector(".".concat(swalClasses.actions, " .").concat(swalClasses.confirm));
  };
  var getCancelButton = function getCancelButton() {
    return elementBySelector(".".concat(swalClasses.actions, " .").concat(swalClasses.cancel));
  };
  var getActions = function getActions() {
    return elementByClass(swalClasses.actions);
  };
  var getHeader = function getHeader() {
    return elementByClass(swalClasses.header);
  };
  var getFooter = function getFooter() {
    return elementByClass(swalClasses.footer);
  };
  var getTimerProgressBar = function getTimerProgressBar() {
    return elementByClass(swalClasses['timer-progress-bar']);
  };
  var getCloseButton = function getCloseButton() {
    return elementByClass(swalClasses.close);
  }; // https://github.com/jkup/focusable/blob/master/index.js

  var focusable = "\n  a[href],\n  area[href],\n  input:not([disabled]),\n  select:not([disabled]),\n  textarea:not([disabled]),\n  button:not([disabled]),\n  iframe,\n  object,\n  embed,\n  [tabindex=\"0\"],\n  [contenteditable],\n  audio[controls],\n  video[controls],\n  summary\n";
  var getFocusableElements = function getFocusableElements() {
    var focusableElementsWithTabindex = toArray(getPopup().querySelectorAll('[tabindex]:not([tabindex="-1"]):not([tabindex="0"])')) // sort according to tabindex
    .sort(function (a, b) {
      a = parseInt(a.getAttribute('tabindex'));
      b = parseInt(b.getAttribute('tabindex'));

      if (a > b) {
        return 1;
      } else if (a < b) {
        return -1;
      }

      return 0;
    });
    var otherFocusableElements = toArray(getPopup().querySelectorAll(focusable)).filter(function (el) {
      return el.getAttribute('tabindex') !== '-1';
    });
    return uniqueArray(focusableElementsWithTabindex.concat(otherFocusableElements)).filter(function (el) {
      return isVisible(el);
    });
  };
  var isModal = function isModal() {
    return !isToast() && !document.body.classList.contains(swalClasses['no-backdrop']);
  };
  var isToast = function isToast() {
    return document.body.classList.contains(swalClasses['toast-shown']);
  };
  var isLoading = function isLoading() {
    return getPopup().hasAttribute('data-loading');
  };

  var states = {
    previousBodyPadding: null
  };
  var setInnerHtml = function setInnerHtml(elem, html) {
    // #1926
    elem.textContent = '';

    if (html) {
      var parser = new DOMParser();
      var parsed = parser.parseFromString(html, "text/html");
      toArray(parsed.querySelector('head').childNodes).forEach(function (child) {
        elem.appendChild(child);
      });
      toArray(parsed.querySelector('body').childNodes).forEach(function (child) {
        elem.appendChild(child);
      });
    }
  };
  var hasClass = function hasClass(elem, className) {
    if (!className) {
      return false;
    }

    var classList = className.split(/\s+/);

    for (var i = 0; i < classList.length; i++) {
      if (!elem.classList.contains(classList[i])) {
        return false;
      }
    }

    return true;
  };

  var removeCustomClasses = function removeCustomClasses(elem, params) {
    toArray(elem.classList).forEach(function (className) {
      if (!(objectValues(swalClasses).indexOf(className) !== -1) && !(objectValues(iconTypes).indexOf(className) !== -1) && !(objectValues(params.showClass).indexOf(className) !== -1)) {
        elem.classList.remove(className);
      }
    });
  };

  var applyCustomClass = function applyCustomClass(elem, params, className) {
    removeCustomClasses(elem, params);

    if (params.customClass && params.customClass[className]) {
      if (typeof params.customClass[className] !== 'string' && !params.customClass[className].forEach) {
        return warn("Invalid type of customClass.".concat(className, "! Expected string or iterable object, got \"").concat(_typeof(params.customClass[className]), "\""));
      }

      addClass(elem, params.customClass[className]);
    }
  };
  function getInput(content, inputType) {
    if (!inputType) {
      return null;
    }

    switch (inputType) {
      case 'select':
      case 'textarea':
      case 'file':
        return getChildByClass(content, swalClasses[inputType]);

      case 'checkbox':
        return content.querySelector(".".concat(swalClasses.checkbox, " input"));

      case 'radio':
        return content.querySelector(".".concat(swalClasses.radio, " input:checked")) || content.querySelector(".".concat(swalClasses.radio, " input:first-child"));

      case 'range':
        return content.querySelector(".".concat(swalClasses.range, " input"));

      default:
        return getChildByClass(content, swalClasses.input);
    }
  }
  var focusInput = function focusInput(input) {
    input.focus(); // place cursor at end of text in text input

    if (input.type !== 'file') {
      // http://stackoverflow.com/a/2345915
      var val = input.value;
      input.value = '';
      input.value = val;
    }
  };
  var toggleClass = function toggleClass(target, classList, condition) {
    if (!target || !classList) {
      return;
    }

    if (typeof classList === 'string') {
      classList = classList.split(/\s+/).filter(Boolean);
    }

    classList.forEach(function (className) {
      if (target.forEach) {
        target.forEach(function (elem) {
          condition ? elem.classList.add(className) : elem.classList.remove(className);
        });
      } else {
        condition ? target.classList.add(className) : target.classList.remove(className);
      }
    });
  };
  var addClass = function addClass(target, classList) {
    toggleClass(target, classList, true);
  };
  var removeClass = function removeClass(target, classList) {
    toggleClass(target, classList, false);
  };
  var getChildByClass = function getChildByClass(elem, className) {
    for (var i = 0; i < elem.childNodes.length; i++) {
      if (hasClass(elem.childNodes[i], className)) {
        return elem.childNodes[i];
      }
    }
  };
  var applyNumericalStyle = function applyNumericalStyle(elem, property, value) {
    if (value || parseInt(value) === 0) {
      elem.style[property] = typeof value === 'number' ? "".concat(value, "px") : value;
    } else {
      elem.style.removeProperty(property);
    }
  };
  var show = function show(elem) {
    var display = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'flex';
    elem.style.opacity = '';
    elem.style.display = display;
  };
  var hide = function hide(elem) {
    elem.style.opacity = '';
    elem.style.display = 'none';
  };
  var toggle = function toggle(elem, condition, display) {
    condition ? show(elem, display) : hide(elem);
  }; // borrowed from jquery $(elem).is(':visible') implementation

  var isVisible = function isVisible(elem) {
    return !!(elem && (elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length));
  };
  /* istanbul ignore next */

  var isScrollable = function isScrollable(elem) {
    return !!(elem.scrollHeight > elem.clientHeight);
  }; // borrowed from https://stackoverflow.com/a/46352119

  var hasCssAnimation = function hasCssAnimation(elem) {
    var style = window.getComputedStyle(elem);
    var animDuration = parseFloat(style.getPropertyValue('animation-duration') || '0');
    var transDuration = parseFloat(style.getPropertyValue('transition-duration') || '0');
    return animDuration > 0 || transDuration > 0;
  };
  var contains = function contains(haystack, needle) {
    if (typeof haystack.contains === 'function') {
      return haystack.contains(needle);
    }
  };
  var animateTimerProgressBar = function animateTimerProgressBar(timer) {
    var reset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var timerProgressBar = getTimerProgressBar();

    if (isVisible(timerProgressBar)) {
      if (reset) {
        timerProgressBar.style.transition = 'none';
        timerProgressBar.style.width = '100%';
      }

      setTimeout(function () {
        timerProgressBar.style.transition = "width ".concat(timer / 1000, "s linear");
        timerProgressBar.style.width = '0%';
      }, 10);
    }
  };
  var stopTimerProgressBar = function stopTimerProgressBar() {
    var timerProgressBar = getTimerProgressBar();
    var timerProgressBarWidth = parseInt(window.getComputedStyle(timerProgressBar).width);
    timerProgressBar.style.removeProperty('transition');
    timerProgressBar.style.width = '100%';
    var timerProgressBarFullWidth = parseInt(window.getComputedStyle(timerProgressBar).width);
    var timerProgressBarPercent = parseInt(timerProgressBarWidth / timerProgressBarFullWidth * 100);
    timerProgressBar.style.removeProperty('transition');
    timerProgressBar.style.width = "".concat(timerProgressBarPercent, "%");
  };

  // Detect Node env
  var isNodeEnv = function isNodeEnv() {
    return typeof window === 'undefined' || typeof document === 'undefined';
  };

  var sweetHTML = "\n <div aria-labelledby=\"".concat(swalClasses.title, "\" aria-describedby=\"").concat(swalClasses.content, "\" class=\"").concat(swalClasses.popup, "\" tabindex=\"-1\">\n   <div class=\"").concat(swalClasses.header, "\">\n     <ul class=\"").concat(swalClasses['progress-steps'], "\"></ul>\n     <div class=\"").concat(swalClasses.icon, " ").concat(iconTypes.error, "\"></div>\n     <div class=\"").concat(swalClasses.icon, " ").concat(iconTypes.question, "\"></div>\n     <div class=\"").concat(swalClasses.icon, " ").concat(iconTypes.warning, "\"></div>\n     <div class=\"").concat(swalClasses.icon, " ").concat(iconTypes.info, "\"></div>\n     <div class=\"").concat(swalClasses.icon, " ").concat(iconTypes.success, "\"></div>\n     <img class=\"").concat(swalClasses.image, "\" />\n     <h2 class=\"").concat(swalClasses.title, "\" id=\"").concat(swalClasses.title, "\"></h2>\n     <button type=\"button\" class=\"").concat(swalClasses.close, "\"></button>\n   </div>\n   <div class=\"").concat(swalClasses.content, "\">\n     <div id=\"").concat(swalClasses.content, "\" class=\"").concat(swalClasses['html-container'], "\"></div>\n     <input class=\"").concat(swalClasses.input, "\" />\n     <input type=\"file\" class=\"").concat(swalClasses.file, "\" />\n     <div class=\"").concat(swalClasses.range, "\">\n       <input type=\"range\" />\n       <output></output>\n     </div>\n     <select class=\"").concat(swalClasses.select, "\"></select>\n     <div class=\"").concat(swalClasses.radio, "\"></div>\n     <label for=\"").concat(swalClasses.checkbox, "\" class=\"").concat(swalClasses.checkbox, "\">\n       <input type=\"checkbox\" />\n       <span class=\"").concat(swalClasses.label, "\"></span>\n     </label>\n     <textarea class=\"").concat(swalClasses.textarea, "\"></textarea>\n     <div class=\"").concat(swalClasses['validation-message'], "\" id=\"").concat(swalClasses['validation-message'], "\"></div>\n   </div>\n   <div class=\"").concat(swalClasses.actions, "\">\n     <button type=\"button\" class=\"").concat(swalClasses.confirm, "\">OK</button>\n     <button type=\"button\" class=\"").concat(swalClasses.cancel, "\">Cancel</button>\n   </div>\n   <div class=\"").concat(swalClasses.footer, "\"></div>\n   <div class=\"").concat(swalClasses['timer-progress-bar-container'], "\">\n     <div class=\"").concat(swalClasses['timer-progress-bar'], "\"></div>\n   </div>\n </div>\n").replace(/(^|\n)\s*/g, '');

  var resetOldContainer = function resetOldContainer() {
    var oldContainer = getContainer();

    if (!oldContainer) {
      return false;
    }

    oldContainer.parentNode.removeChild(oldContainer);
    removeClass([document.documentElement, document.body], [swalClasses['no-backdrop'], swalClasses['toast-shown'], swalClasses['has-column']]);
    return true;
  };

  var oldInputVal; // IE11 workaround, see #1109 for details

  var resetValidationMessage = function resetValidationMessage(e) {
    if (Swal.isVisible() && oldInputVal !== e.target.value) {
      Swal.resetValidationMessage();
    }

    oldInputVal = e.target.value;
  };

  var addInputChangeListeners = function addInputChangeListeners() {
    var content = getContent();
    var input = getChildByClass(content, swalClasses.input);
    var file = getChildByClass(content, swalClasses.file);
    var range = content.querySelector(".".concat(swalClasses.range, " input"));
    var rangeOutput = content.querySelector(".".concat(swalClasses.range, " output"));
    var select = getChildByClass(content, swalClasses.select);
    var checkbox = content.querySelector(".".concat(swalClasses.checkbox, " input"));
    var textarea = getChildByClass(content, swalClasses.textarea);
    input.oninput = resetValidationMessage;
    file.onchange = resetValidationMessage;
    select.onchange = resetValidationMessage;
    checkbox.onchange = resetValidationMessage;
    textarea.oninput = resetValidationMessage;

    range.oninput = function (e) {
      resetValidationMessage(e);
      rangeOutput.value = range.value;
    };

    range.onchange = function (e) {
      resetValidationMessage(e);
      range.nextSibling.value = range.value;
    };
  };

  var getTarget = function getTarget(target) {
    return typeof target === 'string' ? document.querySelector(target) : target;
  };

  var setupAccessibility = function setupAccessibility(params) {
    var popup = getPopup();
    popup.setAttribute('role', params.toast ? 'alert' : 'dialog');
    popup.setAttribute('aria-live', params.toast ? 'polite' : 'assertive');

    if (!params.toast) {
      popup.setAttribute('aria-modal', 'true');
    }
  };

  var setupRTL = function setupRTL(targetElement) {
    if (window.getComputedStyle(targetElement).direction === 'rtl') {
      addClass(getContainer(), swalClasses.rtl);
    }
  };
  /*
   * Add modal + backdrop to DOM
   */


  var init = function init(params) {
    // Clean up the old popup container if it exists
    var oldContainerExisted = resetOldContainer();
    /* istanbul ignore if */

    if (isNodeEnv()) {
      error('SweetAlert2 requires document to initialize');
      return;
    }

    var container = document.createElement('div');
    container.className = swalClasses.container;

    if (oldContainerExisted) {
      addClass(container, swalClasses['no-transition']);
    }

    setInnerHtml(container, sweetHTML);
    var targetElement = getTarget(params.target);
    targetElement.appendChild(container);
    setupAccessibility(params);
    setupRTL(targetElement);
    addInputChangeListeners();
  };

  var parseHtmlToContainer = function parseHtmlToContainer(param, target) {
    // DOM element
    if (param instanceof HTMLElement) {
      target.appendChild(param); // Object
    } else if (_typeof(param) === 'object') {
      handleObject(param, target); // Plain string
    } else if (param) {
      setInnerHtml(target, param);
    }
  };

  var handleObject = function handleObject(param, target) {
    // JQuery element(s)
    if (param.jquery) {
      handleJqueryElem(target, param); // For other objects use their string representation
    } else {
      setInnerHtml(target, param.toString());
    }
  };

  var handleJqueryElem = function handleJqueryElem(target, elem) {
    target.textContent = '';

    if (0 in elem) {
      for (var i = 0; (i in elem); i++) {
        target.appendChild(elem[i].cloneNode(true));
      }
    } else {
      target.appendChild(elem.cloneNode(true));
    }
  };

  var animationEndEvent = function () {
    // Prevent run in Node env

    /* istanbul ignore if */
    if (isNodeEnv()) {
      return false;
    }

    var testEl = document.createElement('div');
    var transEndEventNames = {
      WebkitAnimation: 'webkitAnimationEnd',
      OAnimation: 'oAnimationEnd oanimationend',
      animation: 'animationend'
    };

    for (var i in transEndEventNames) {
      if (Object.prototype.hasOwnProperty.call(transEndEventNames, i) && typeof testEl.style[i] !== 'undefined') {
        return transEndEventNames[i];
      }
    }

    return false;
  }();

  // https://github.com/twbs/bootstrap/blob/master/js/src/modal.js

  var measureScrollbar = function measureScrollbar() {
    var scrollDiv = document.createElement('div');
    scrollDiv.className = swalClasses['scrollbar-measure'];
    document.body.appendChild(scrollDiv);
    var scrollbarWidth = scrollDiv.getBoundingClientRect().width - scrollDiv.clientWidth;
    document.body.removeChild(scrollDiv);
    return scrollbarWidth;
  };

  var renderActions = function renderActions(instance, params) {
    var actions = getActions();
    var confirmButton = getConfirmButton();
    var cancelButton = getCancelButton(); // Actions (buttons) wrapper

    if (!params.showConfirmButton && !params.showCancelButton) {
      hide(actions);
    } // Custom class


    applyCustomClass(actions, params, 'actions'); // Render confirm button

    renderButton(confirmButton, 'confirm', params); // render Cancel Button

    renderButton(cancelButton, 'cancel', params);

    if (params.buttonsStyling) {
      handleButtonsStyling(confirmButton, cancelButton, params);
    } else {
      removeClass([confirmButton, cancelButton], swalClasses.styled);
      confirmButton.style.backgroundColor = confirmButton.style.borderLeftColor = confirmButton.style.borderRightColor = '';
      cancelButton.style.backgroundColor = cancelButton.style.borderLeftColor = cancelButton.style.borderRightColor = '';
    }

    if (params.reverseButtons) {
      confirmButton.parentNode.insertBefore(cancelButton, confirmButton);
    }
  };

  function handleButtonsStyling(confirmButton, cancelButton, params) {
    addClass([confirmButton, cancelButton], swalClasses.styled); // Buttons background colors

    if (params.confirmButtonColor) {
      confirmButton.style.backgroundColor = params.confirmButtonColor;
    }

    if (params.cancelButtonColor) {
      cancelButton.style.backgroundColor = params.cancelButtonColor;
    } // Loading state


    if (!isLoading()) {
      var confirmButtonBackgroundColor = window.getComputedStyle(confirmButton).getPropertyValue('background-color');
      confirmButton.style.borderLeftColor = confirmButtonBackgroundColor;
      confirmButton.style.borderRightColor = confirmButtonBackgroundColor;
    }
  }

  function renderButton(button, buttonType, params) {
    toggle(button, params["show".concat(capitalizeFirstLetter(buttonType), "Button")], 'inline-block');
    setInnerHtml(button, params["".concat(buttonType, "ButtonText")]); // Set caption text

    button.setAttribute('aria-label', params["".concat(buttonType, "ButtonAriaLabel")]); // ARIA label
    // Add buttons custom classes

    button.className = swalClasses[buttonType];
    applyCustomClass(button, params, "".concat(buttonType, "Button"));
    addClass(button, params["".concat(buttonType, "ButtonClass")]);
  }

  function handleBackdropParam(container, backdrop) {
    if (typeof backdrop === 'string') {
      container.style.background = backdrop;
    } else if (!backdrop) {
      addClass([document.documentElement, document.body], swalClasses['no-backdrop']);
    }
  }

  function handlePositionParam(container, position) {
    if (position in swalClasses) {
      addClass(container, swalClasses[position]);
    } else {
      warn('The "position" parameter is not valid, defaulting to "center"');
      addClass(container, swalClasses.center);
    }
  }

  function handleGrowParam(container, grow) {
    if (grow && typeof grow === 'string') {
      var growClass = "grow-".concat(grow);

      if (growClass in swalClasses) {
        addClass(container, swalClasses[growClass]);
      }
    }
  }

  var renderContainer = function renderContainer(instance, params) {
    var container = getContainer();

    if (!container) {
      return;
    }

    handleBackdropParam(container, params.backdrop);

    if (!params.backdrop && params.allowOutsideClick) {
      warn('"allowOutsideClick" parameter requires `backdrop` parameter to be set to `true`');
    }

    handlePositionParam(container, params.position);
    handleGrowParam(container, params.grow); // Custom class

    applyCustomClass(container, params, 'container'); // Set queue step attribute for getQueueStep() method

    var queueStep = document.body.getAttribute('data-swal2-queue-step');

    if (queueStep) {
      container.setAttribute('data-queue-step', queueStep);
      document.body.removeAttribute('data-swal2-queue-step');
    }
  };

  /**
   * This module containts `WeakMap`s for each effectively-"private  property" that a `Swal` has.
   * For example, to set the private property "foo" of `this` to "bar", you can `privateProps.foo.set(this, 'bar')`
   * This is the approach that Babel will probably take to implement private methods/fields
   *   https://github.com/tc39/proposal-private-methods
   *   https://github.com/babel/babel/pull/7555
   * Once we have the changes from that PR in Babel, and our core class fits reasonable in *one module*
   *   then we can use that language feature.
   */
  var privateProps = {
    promise: new WeakMap(),
    innerParams: new WeakMap(),
    domCache: new WeakMap()
  };

  var inputTypes = ['input', 'file', 'range', 'select', 'radio', 'checkbox', 'textarea'];
  var renderInput = function renderInput(instance, params) {
    var content = getContent();
    var innerParams = privateProps.innerParams.get(instance);
    var rerender = !innerParams || params.input !== innerParams.input;
    inputTypes.forEach(function (inputType) {
      var inputClass = swalClasses[inputType];
      var inputContainer = getChildByClass(content, inputClass); // set attributes

      setAttributes(inputType, params.inputAttributes); // set class

      inputContainer.className = inputClass;

      if (rerender) {
        hide(inputContainer);
      }
    });

    if (params.input) {
      if (rerender) {
        showInput(params);
      } // set custom class


      setCustomClass(params);
    }
  };

  var showInput = function showInput(params) {
    if (!renderInputType[params.input]) {
      return error("Unexpected type of input! Expected \"text\", \"email\", \"password\", \"number\", \"tel\", \"select\", \"radio\", \"checkbox\", \"textarea\", \"file\" or \"url\", got \"".concat(params.input, "\""));
    }

    var inputContainer = getInputContainer(params.input);
    var input = renderInputType[params.input](inputContainer, params);
    show(input); // input autofocus

    setTimeout(function () {
      focusInput(input);
    });
  };

  var removeAttributes = function removeAttributes(input) {
    for (var i = 0; i < input.attributes.length; i++) {
      var attrName = input.attributes[i].name;

      if (!(['type', 'value', 'style'].indexOf(attrName) !== -1)) {
        input.removeAttribute(attrName);
      }
    }
  };

  var setAttributes = function setAttributes(inputType, inputAttributes) {
    var input = getInput(getContent(), inputType);

    if (!input) {
      return;
    }

    removeAttributes(input);

    for (var attr in inputAttributes) {
      // Do not set a placeholder for <input type="range">
      // it'll crash Edge, #1298
      if (inputType === 'range' && attr === 'placeholder') {
        continue;
      }

      input.setAttribute(attr, inputAttributes[attr]);
    }
  };

  var setCustomClass = function setCustomClass(params) {
    var inputContainer = getInputContainer(params.input);

    if (params.customClass) {
      addClass(inputContainer, params.customClass.input);
    }
  };

  var setInputPlaceholder = function setInputPlaceholder(input, params) {
    if (!input.placeholder || params.inputPlaceholder) {
      input.placeholder = params.inputPlaceholder;
    }
  };

  var getInputContainer = function getInputContainer(inputType) {
    var inputClass = swalClasses[inputType] ? swalClasses[inputType] : swalClasses.input;
    return getChildByClass(getContent(), inputClass);
  };

  var renderInputType = {};

  renderInputType.text = renderInputType.email = renderInputType.password = renderInputType.number = renderInputType.tel = renderInputType.url = function (input, params) {
    if (typeof params.inputValue === 'string' || typeof params.inputValue === 'number') {
      input.value = params.inputValue;
    } else if (!isPromise(params.inputValue)) {
      warn("Unexpected type of inputValue! Expected \"string\", \"number\" or \"Promise\", got \"".concat(_typeof(params.inputValue), "\""));
    }

    setInputPlaceholder(input, params);
    input.type = params.input;
    return input;
  };

  renderInputType.file = function (input, params) {
    setInputPlaceholder(input, params);
    return input;
  };

  renderInputType.range = function (range, params) {
    var rangeInput = range.querySelector('input');
    var rangeOutput = range.querySelector('output');
    rangeInput.value = params.inputValue;
    rangeInput.type = params.input;
    rangeOutput.value = params.inputValue;
    return range;
  };

  renderInputType.select = function (select, params) {
    select.textContent = '';

    if (params.inputPlaceholder) {
      var placeholder = document.createElement('option');
      setInnerHtml(placeholder, params.inputPlaceholder);
      placeholder.value = '';
      placeholder.disabled = true;
      placeholder.selected = true;
      select.appendChild(placeholder);
    }

    return select;
  };

  renderInputType.radio = function (radio) {
    radio.textContent = '';
    return radio;
  };

  renderInputType.checkbox = function (checkboxContainer, params) {
    var checkbox = getInput(getContent(), 'checkbox');
    checkbox.value = 1;
    checkbox.id = swalClasses.checkbox;
    checkbox.checked = Boolean(params.inputValue);
    var label = checkboxContainer.querySelector('span');
    setInnerHtml(label, params.inputPlaceholder);
    return checkboxContainer;
  };

  renderInputType.textarea = function (textarea, params) {
    textarea.value = params.inputValue;
    setInputPlaceholder(textarea, params);

    if ('MutationObserver' in window) {
      // #1699
      var initialPopupWidth = parseInt(window.getComputedStyle(getPopup()).width);
      var popupPadding = parseInt(window.getComputedStyle(getPopup()).paddingLeft) + parseInt(window.getComputedStyle(getPopup()).paddingRight);

      var outputsize = function outputsize() {
        var contentWidth = textarea.offsetWidth + popupPadding;

        if (contentWidth > initialPopupWidth) {
          getPopup().style.width = "".concat(contentWidth, "px");
        } else {
          getPopup().style.width = null;
        }
      };

      new MutationObserver(outputsize).observe(textarea, {
        attributes: true,
        attributeFilter: ['style']
      });
    }

    return textarea;
  };

  var renderContent = function renderContent(instance, params) {
    var content = getContent().querySelector("#".concat(swalClasses.content)); // Content as HTML

    if (params.html) {
      parseHtmlToContainer(params.html, content);
      show(content, 'block'); // Content as plain text
    } else if (params.text) {
      content.textContent = params.text;
      show(content, 'block'); // No content
    } else {
      hide(content);
    }

    renderInput(instance, params); // Custom class

    applyCustomClass(getContent(), params, 'content');
  };

  var renderFooter = function renderFooter(instance, params) {
    var footer = getFooter();
    toggle(footer, params.footer);

    if (params.footer) {
      parseHtmlToContainer(params.footer, footer);
    } // Custom class


    applyCustomClass(footer, params, 'footer');
  };

  var renderCloseButton = function renderCloseButton(instance, params) {
    var closeButton = getCloseButton();
    setInnerHtml(closeButton, params.closeButtonHtml); // Custom class

    applyCustomClass(closeButton, params, 'closeButton');
    toggle(closeButton, params.showCloseButton);
    closeButton.setAttribute('aria-label', params.closeButtonAriaLabel);
  };

  var renderIcon = function renderIcon(instance, params) {
    var innerParams = privateProps.innerParams.get(instance); // if the give icon already rendered, apply the custom class without re-rendering the icon

    if (innerParams && params.icon === innerParams.icon && getIcon()) {
      applyCustomClass(getIcon(), params, 'icon');
      return;
    }

    hideAllIcons();

    if (!params.icon) {
      return;
    }

    if (Object.keys(iconTypes).indexOf(params.icon) !== -1) {
      var icon = elementBySelector(".".concat(swalClasses.icon, ".").concat(iconTypes[params.icon]));
      show(icon); // Custom or default content

      setContent(icon, params);
      adjustSuccessIconBackgoundColor(); // Custom class

      applyCustomClass(icon, params, 'icon'); // Animate icon

      addClass(icon, params.showClass.icon);
    } else {
      error("Unknown icon! Expected \"success\", \"error\", \"warning\", \"info\" or \"question\", got \"".concat(params.icon, "\""));
    }
  };

  var hideAllIcons = function hideAllIcons() {
    var icons = getIcons();

    for (var i = 0; i < icons.length; i++) {
      hide(icons[i]);
    }
  }; // Adjust success icon background color to match the popup background color


  var adjustSuccessIconBackgoundColor = function adjustSuccessIconBackgoundColor() {
    var popup = getPopup();
    var popupBackgroundColor = window.getComputedStyle(popup).getPropertyValue('background-color');
    var successIconParts = popup.querySelectorAll('[class^=swal2-success-circular-line], .swal2-success-fix');

    for (var i = 0; i < successIconParts.length; i++) {
      successIconParts[i].style.backgroundColor = popupBackgroundColor;
    }
  };

  var setContent = function setContent(icon, params) {
    icon.textContent = '';

    if (params.iconHtml) {
      setInnerHtml(icon, iconContent(params.iconHtml));
    } else if (params.icon === 'success') {
      setInnerHtml(icon, "\n      <div class=\"swal2-success-circular-line-left\"></div>\n      <span class=\"swal2-success-line-tip\"></span> <span class=\"swal2-success-line-long\"></span>\n      <div class=\"swal2-success-ring\"></div> <div class=\"swal2-success-fix\"></div>\n      <div class=\"swal2-success-circular-line-right\"></div>\n    ");
    } else if (params.icon === 'error') {
      setInnerHtml(icon, "\n      <span class=\"swal2-x-mark\">\n        <span class=\"swal2-x-mark-line-left\"></span>\n        <span class=\"swal2-x-mark-line-right\"></span>\n      </span>\n    ");
    } else {
      var defaultIconHtml = {
        question: '?',
        warning: '!',
        info: 'i'
      };
      setInnerHtml(icon, iconContent(defaultIconHtml[params.icon]));
    }
  };

  var iconContent = function iconContent(content) {
    return "<div class=\"".concat(swalClasses['icon-content'], "\">").concat(content, "</div>");
  };

  var renderImage = function renderImage(instance, params) {
    var image = getImage();

    if (!params.imageUrl) {
      return hide(image);
    }

    show(image, ''); // Src, alt

    image.setAttribute('src', params.imageUrl);
    image.setAttribute('alt', params.imageAlt); // Width, height

    applyNumericalStyle(image, 'width', params.imageWidth);
    applyNumericalStyle(image, 'height', params.imageHeight); // Class

    image.className = swalClasses.image;
    applyCustomClass(image, params, 'image');
  };

  var currentSteps = [];
  /*
   * Global function for chaining sweetAlert popups
   */

  var queue = function queue(steps) {
    var Swal = this;
    currentSteps = steps;

    var resetAndResolve = function resetAndResolve(resolve, value) {
      currentSteps = [];
      resolve(value);
    };

    var queueResult = [];
    return new Promise(function (resolve) {
      (function step(i, callback) {
        if (i < currentSteps.length) {
          document.body.setAttribute('data-swal2-queue-step', i);
          Swal.fire(currentSteps[i]).then(function (result) {
            if (typeof result.value !== 'undefined') {
              queueResult.push(result.value);
              step(i + 1, callback);
            } else {
              resetAndResolve(resolve, {
                dismiss: result.dismiss
              });
            }
          });
        } else {
          resetAndResolve(resolve, {
            value: queueResult
          });
        }
      })(0);
    });
  };
  /*
   * Global function for getting the index of current popup in queue
   */

  var getQueueStep = function getQueueStep() {
    return getContainer() && getContainer().getAttribute('data-queue-step');
  };
  /*
   * Global function for inserting a popup to the queue
   */

  var insertQueueStep = function insertQueueStep(step, index) {
    if (index && index < currentSteps.length) {
      return currentSteps.splice(index, 0, step);
    }

    return currentSteps.push(step);
  };
  /*
   * Global function for deleting a popup from the queue
   */

  var deleteQueueStep = function deleteQueueStep(index) {
    if (typeof currentSteps[index] !== 'undefined') {
      currentSteps.splice(index, 1);
    }
  };

  var createStepElement = function createStepElement(step) {
    var stepEl = document.createElement('li');
    addClass(stepEl, swalClasses['progress-step']);
    setInnerHtml(stepEl, step);
    return stepEl;
  };

  var createLineElement = function createLineElement(params) {
    var lineEl = document.createElement('li');
    addClass(lineEl, swalClasses['progress-step-line']);

    if (params.progressStepsDistance) {
      lineEl.style.width = params.progressStepsDistance;
    }

    return lineEl;
  };

  var renderProgressSteps = function renderProgressSteps(instance, params) {
    var progressStepsContainer = getProgressSteps();

    if (!params.progressSteps || params.progressSteps.length === 0) {
      return hide(progressStepsContainer);
    }

    show(progressStepsContainer);
    progressStepsContainer.textContent = '';
    var currentProgressStep = parseInt(params.currentProgressStep === undefined ? getQueueStep() : params.currentProgressStep);

    if (currentProgressStep >= params.progressSteps.length) {
      warn('Invalid currentProgressStep parameter, it should be less than progressSteps.length ' + '(currentProgressStep like JS arrays starts from 0)');
    }

    params.progressSteps.forEach(function (step, index) {
      var stepEl = createStepElement(step);
      progressStepsContainer.appendChild(stepEl);

      if (index === currentProgressStep) {
        addClass(stepEl, swalClasses['active-progress-step']);
      }

      if (index !== params.progressSteps.length - 1) {
        var lineEl = createLineElement(params);
        progressStepsContainer.appendChild(lineEl);
      }
    });
  };

  var renderTitle = function renderTitle(instance, params) {
    var title = getTitle();
    toggle(title, params.title || params.titleText);

    if (params.title) {
      parseHtmlToContainer(params.title, title);
    }

    if (params.titleText) {
      title.innerText = params.titleText;
    } // Custom class


    applyCustomClass(title, params, 'title');
  };

  var renderHeader = function renderHeader(instance, params) {
    var header = getHeader(); // Custom class

    applyCustomClass(header, params, 'header'); // Progress steps

    renderProgressSteps(instance, params); // Icon

    renderIcon(instance, params); // Image

    renderImage(instance, params); // Title

    renderTitle(instance, params); // Close button

    renderCloseButton(instance, params);
  };

  var renderPopup = function renderPopup(instance, params) {
    var popup = getPopup(); // Width

    applyNumericalStyle(popup, 'width', params.width); // Padding

    applyNumericalStyle(popup, 'padding', params.padding); // Background

    if (params.background) {
      popup.style.background = params.background;
    } // Classes


    addClasses(popup, params);
  };

  var addClasses = function addClasses(popup, params) {
    // Default Class + showClass when updating Swal.update({})
    popup.className = "".concat(swalClasses.popup, " ").concat(isVisible(popup) ? params.showClass.popup : '');

    if (params.toast) {
      addClass([document.documentElement, document.body], swalClasses['toast-shown']);
      addClass(popup, swalClasses.toast);
    } else {
      addClass(popup, swalClasses.modal);
    } // Custom class


    applyCustomClass(popup, params, 'popup');

    if (typeof params.customClass === 'string') {
      addClass(popup, params.customClass);
    } // Icon class (#1842)


    if (params.icon) {
      addClass(popup, swalClasses["icon-".concat(params.icon)]);
    }
  };

  var render = function render(instance, params) {
    renderPopup(instance, params);
    renderContainer(instance, params);
    renderHeader(instance, params);
    renderContent(instance, params);
    renderActions(instance, params);
    renderFooter(instance, params);

    if (typeof params.onRender === 'function') {
      params.onRender(getPopup());
    }
  };

  /*
   * Global function to determine if SweetAlert2 popup is shown
   */

  var isVisible$1 = function isVisible$$1() {
    return isVisible(getPopup());
  };
  /*
   * Global function to click 'Confirm' button
   */

  var clickConfirm = function clickConfirm() {
    return getConfirmButton() && getConfirmButton().click();
  };
  /*
   * Global function to click 'Cancel' button
   */

  var clickCancel = function clickCancel() {
    return getCancelButton() && getCancelButton().click();
  };

  function fire() {
    var Swal = this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _construct(Swal, args);
  }

  /**
   * Returns an extended version of `Swal` containing `params` as defaults.
   * Useful for reusing Swal configuration.
   *
   * For example:
   *
   * Before:
   * const textPromptOptions = { input: 'text', showCancelButton: true }
   * const {value: firstName} = await Swal.fire({ ...textPromptOptions, title: 'What is your first name?' })
   * const {value: lastName} = await Swal.fire({ ...textPromptOptions, title: 'What is your last name?' })
   *
   * After:
   * const TextPrompt = Swal.mixin({ input: 'text', showCancelButton: true })
   * const {value: firstName} = await TextPrompt('What is your first name?')
   * const {value: lastName} = await TextPrompt('What is your last name?')
   *
   * @param mixinParams
   */
  function mixin(mixinParams) {
    var MixinSwal = /*#__PURE__*/function (_this) {
      _inherits(MixinSwal, _this);

      var _super = _createSuper(MixinSwal);

      function MixinSwal() {
        _classCallCheck(this, MixinSwal);

        return _super.apply(this, arguments);
      }

      _createClass(MixinSwal, [{
        key: "_main",
        value: function _main(params) {
          return _get(_getPrototypeOf(MixinSwal.prototype), "_main", this).call(this, _extends({}, mixinParams, params));
        }
      }]);

      return MixinSwal;
    }(this);

    return MixinSwal;
  }

  /**
   * Show spinner instead of Confirm button
   */

  var showLoading = function showLoading() {
    var popup = getPopup();

    if (!popup) {
      Swal.fire();
    }

    popup = getPopup();
    var actions = getActions();
    var confirmButton = getConfirmButton();
    show(actions);
    show(confirmButton, 'inline-block');
    addClass([popup, actions], swalClasses.loading);
    confirmButton.disabled = true;
    popup.setAttribute('data-loading', true);
    popup.setAttribute('aria-busy', true);
    popup.focus();
  };

  var RESTORE_FOCUS_TIMEOUT = 100;

  var globalState = {};

  var focusPreviousActiveElement = function focusPreviousActiveElement() {
    if (globalState.previousActiveElement && globalState.previousActiveElement.focus) {
      globalState.previousActiveElement.focus();
      globalState.previousActiveElement = null;
    } else if (document.body) {
      document.body.focus();
    }
  }; // Restore previous active (focused) element


  var restoreActiveElement = function restoreActiveElement() {
    return new Promise(function (resolve) {
      var x = window.scrollX;
      var y = window.scrollY;
      globalState.restoreFocusTimeout = setTimeout(function () {
        focusPreviousActiveElement();
        resolve();
      }, RESTORE_FOCUS_TIMEOUT); // issues/900

      /* istanbul ignore if */

      if (typeof x !== 'undefined' && typeof y !== 'undefined') {
        // IE doesn't have scrollX/scrollY support
        window.scrollTo(x, y);
      }
    });
  };

  /**
   * If `timer` parameter is set, returns number of milliseconds of timer remained.
   * Otherwise, returns undefined.
   */

  var getTimerLeft = function getTimerLeft() {
    return globalState.timeout && globalState.timeout.getTimerLeft();
  };
  /**
   * Stop timer. Returns number of milliseconds of timer remained.
   * If `timer` parameter isn't set, returns undefined.
   */

  var stopTimer = function stopTimer() {
    if (globalState.timeout) {
      stopTimerProgressBar();
      return globalState.timeout.stop();
    }
  };
  /**
   * Resume timer. Returns number of milliseconds of timer remained.
   * If `timer` parameter isn't set, returns undefined.
   */

  var resumeTimer = function resumeTimer() {
    if (globalState.timeout) {
      var remaining = globalState.timeout.start();
      animateTimerProgressBar(remaining);
      return remaining;
    }
  };
  /**
   * Resume timer. Returns number of milliseconds of timer remained.
   * If `timer` parameter isn't set, returns undefined.
   */

  var toggleTimer = function toggleTimer() {
    var timer = globalState.timeout;
    return timer && (timer.running ? stopTimer() : resumeTimer());
  };
  /**
   * Increase timer. Returns number of milliseconds of an updated timer.
   * If `timer` parameter isn't set, returns undefined.
   */

  var increaseTimer = function increaseTimer(n) {
    if (globalState.timeout) {
      var remaining = globalState.timeout.increase(n);
      animateTimerProgressBar(remaining, true);
      return remaining;
    }
  };
  /**
   * Check if timer is running. Returns true if timer is running
   * or false if timer is paused or stopped.
   * If `timer` parameter isn't set, returns undefined
   */

  var isTimerRunning = function isTimerRunning() {
    return globalState.timeout && globalState.timeout.isRunning();
  };

  var defaultParams = {
    title: '',
    titleText: '',
    text: '',
    html: '',
    footer: '',
    icon: undefined,
    iconHtml: undefined,
    toast: false,
    animation: true,
    showClass: {
      popup: 'swal2-show',
      backdrop: 'swal2-backdrop-show',
      icon: 'swal2-icon-show'
    },
    hideClass: {
      popup: 'swal2-hide',
      backdrop: 'swal2-backdrop-hide',
      icon: 'swal2-icon-hide'
    },
    customClass: undefined,
    target: 'body',
    backdrop: true,
    heightAuto: true,
    allowOutsideClick: true,
    allowEscapeKey: true,
    allowEnterKey: true,
    stopKeydownPropagation: true,
    keydownListenerCapture: false,
    showConfirmButton: true,
    showCancelButton: false,
    preConfirm: undefined,
    confirmButtonText: 'OK',
    confirmButtonAriaLabel: '',
    confirmButtonColor: undefined,
    cancelButtonText: 'Cancel',
    cancelButtonAriaLabel: '',
    cancelButtonColor: undefined,
    buttonsStyling: true,
    reverseButtons: false,
    focusConfirm: true,
    focusCancel: false,
    showCloseButton: false,
    closeButtonHtml: '&times;',
    closeButtonAriaLabel: 'Close this dialog',
    showLoaderOnConfirm: false,
    imageUrl: undefined,
    imageWidth: undefined,
    imageHeight: undefined,
    imageAlt: '',
    timer: undefined,
    timerProgressBar: false,
    width: undefined,
    padding: undefined,
    background: undefined,
    input: undefined,
    inputPlaceholder: '',
    inputValue: '',
    inputOptions: {},
    inputAutoTrim: true,
    inputAttributes: {},
    inputValidator: undefined,
    validationMessage: undefined,
    grow: false,
    position: 'center',
    progressSteps: [],
    currentProgressStep: undefined,
    progressStepsDistance: undefined,
    onBeforeOpen: undefined,
    onOpen: undefined,
    onRender: undefined,
    onClose: undefined,
    onAfterClose: undefined,
    onDestroy: undefined,
    scrollbarPadding: true
  };
  var updatableParams = ['allowEscapeKey', 'allowOutsideClick', 'buttonsStyling', 'cancelButtonAriaLabel', 'cancelButtonColor', 'cancelButtonText', 'closeButtonAriaLabel', 'closeButtonHtml', 'confirmButtonAriaLabel', 'confirmButtonColor', 'confirmButtonText', 'currentProgressStep', 'customClass', 'footer', 'hideClass', 'html', 'icon', 'imageAlt', 'imageHeight', 'imageUrl', 'imageWidth', 'onAfterClose', 'onClose', 'onDestroy', 'progressSteps', 'reverseButtons', 'showCancelButton', 'showCloseButton', 'showConfirmButton', 'text', 'title', 'titleText'];
  var deprecatedParams = {
    animation: 'showClass" and "hideClass'
  };
  var toastIncompatibleParams = ['allowOutsideClick', 'allowEnterKey', 'backdrop', 'focusConfirm', 'focusCancel', 'heightAuto', 'keydownListenerCapture'];
  /**
   * Is valid parameter
   * @param {String} paramName
   */

  var isValidParameter = function isValidParameter(paramName) {
    return Object.prototype.hasOwnProperty.call(defaultParams, paramName);
  };
  /**
   * Is valid parameter for Swal.update() method
   * @param {String} paramName
   */

  var isUpdatableParameter = function isUpdatableParameter(paramName) {
    return updatableParams.indexOf(paramName) !== -1;
  };
  /**
   * Is deprecated parameter
   * @param {String} paramName
   */

  var isDeprecatedParameter = function isDeprecatedParameter(paramName) {
    return deprecatedParams[paramName];
  };

  var checkIfParamIsValid = function checkIfParamIsValid(param) {
    if (!isValidParameter(param)) {
      warn("Unknown parameter \"".concat(param, "\""));
    }
  };

  var checkIfToastParamIsValid = function checkIfToastParamIsValid(param) {
    if (toastIncompatibleParams.indexOf(param) !== -1) {
      warn("The parameter \"".concat(param, "\" is incompatible with toasts"));
    }
  };

  var checkIfParamIsDeprecated = function checkIfParamIsDeprecated(param) {
    if (isDeprecatedParameter(param)) {
      warnAboutDepreation(param, isDeprecatedParameter(param));
    }
  };
  /**
   * Show relevant warnings for given params
   *
   * @param params
   */


  var showWarningsForParams = function showWarningsForParams(params) {
    for (var param in params) {
      checkIfParamIsValid(param);

      if (params.toast) {
        checkIfToastParamIsValid(param);
      }

      checkIfParamIsDeprecated(param);
    }
  };



  var staticMethods = /*#__PURE__*/Object.freeze({
    isValidParameter: isValidParameter,
    isUpdatableParameter: isUpdatableParameter,
    isDeprecatedParameter: isDeprecatedParameter,
    argsToParams: argsToParams,
    isVisible: isVisible$1,
    clickConfirm: clickConfirm,
    clickCancel: clickCancel,
    getContainer: getContainer,
    getPopup: getPopup,
    getTitle: getTitle,
    getContent: getContent,
    getHtmlContainer: getHtmlContainer,
    getImage: getImage,
    getIcon: getIcon,
    getIcons: getIcons,
    getCloseButton: getCloseButton,
    getActions: getActions,
    getConfirmButton: getConfirmButton,
    getCancelButton: getCancelButton,
    getHeader: getHeader,
    getFooter: getFooter,
    getTimerProgressBar: getTimerProgressBar,
    getFocusableElements: getFocusableElements,
    getValidationMessage: getValidationMessage,
    isLoading: isLoading,
    fire: fire,
    mixin: mixin,
    queue: queue,
    getQueueStep: getQueueStep,
    insertQueueStep: insertQueueStep,
    deleteQueueStep: deleteQueueStep,
    showLoading: showLoading,
    enableLoading: showLoading,
    getTimerLeft: getTimerLeft,
    stopTimer: stopTimer,
    resumeTimer: resumeTimer,
    toggleTimer: toggleTimer,
    increaseTimer: increaseTimer,
    isTimerRunning: isTimerRunning
  });

  /**
   * Enables buttons and hide loader.
   */

  function hideLoading() {
    // do nothing if popup is closed
    var innerParams = privateProps.innerParams.get(this);

    if (!innerParams) {
      return;
    }

    var domCache = privateProps.domCache.get(this);

    if (!innerParams.showConfirmButton) {
      hide(domCache.confirmButton);

      if (!innerParams.showCancelButton) {
        hide(domCache.actions);
      }
    }

    removeClass([domCache.popup, domCache.actions], swalClasses.loading);
    domCache.popup.removeAttribute('aria-busy');
    domCache.popup.removeAttribute('data-loading');
    domCache.confirmButton.disabled = false;
    domCache.cancelButton.disabled = false;
  }

  function getInput$1(instance) {
    var innerParams = privateProps.innerParams.get(instance || this);
    var domCache = privateProps.domCache.get(instance || this);

    if (!domCache) {
      return null;
    }

    return getInput(domCache.content, innerParams.input);
  }

  var fixScrollbar = function fixScrollbar() {
    // for queues, do not do this more than once
    if (states.previousBodyPadding !== null) {
      return;
    } // if the body has overflow


    if (document.body.scrollHeight > window.innerHeight) {
      // add padding so the content doesn't shift after removal of scrollbar
      states.previousBodyPadding = parseInt(window.getComputedStyle(document.body).getPropertyValue('padding-right'));
      document.body.style.paddingRight = "".concat(states.previousBodyPadding + measureScrollbar(), "px");
    }
  };
  var undoScrollbar = function undoScrollbar() {
    if (states.previousBodyPadding !== null) {
      document.body.style.paddingRight = "".concat(states.previousBodyPadding, "px");
      states.previousBodyPadding = null;
    }
  };

  /* istanbul ignore file */

  var iOSfix = function iOSfix() {
    var iOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream || navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1;

    if (iOS && !hasClass(document.body, swalClasses.iosfix)) {
      var offset = document.body.scrollTop;
      document.body.style.top = "".concat(offset * -1, "px");
      addClass(document.body, swalClasses.iosfix);
      lockBodyScroll();
      addBottomPaddingForTallPopups(); // #1948
    }
  };

  var addBottomPaddingForTallPopups = function addBottomPaddingForTallPopups() {
    var safari = !navigator.userAgent.match(/(CriOS|FxiOS|EdgiOS|YaBrowser|UCBrowser)/i);

    if (safari) {
      var bottomPanelHeight = 44;

      if (getPopup().scrollHeight > window.innerHeight - bottomPanelHeight) {
        getContainer().style.paddingBottom = "".concat(bottomPanelHeight, "px");
      }
    }
  };

  var lockBodyScroll = function lockBodyScroll() {
    // #1246
    var container = getContainer();
    var preventTouchMove;

    container.ontouchstart = function (e) {
      preventTouchMove = shouldPreventTouchMove(e.target);
    };

    container.ontouchmove = function (e) {
      if (preventTouchMove) {
        e.preventDefault();
        e.stopPropagation();
      }
    };
  };

  var shouldPreventTouchMove = function shouldPreventTouchMove(target) {
    var container = getContainer();

    if (target === container) {
      return true;
    }

    if (!isScrollable(container) && target.tagName !== 'INPUT' && // #1603
    !(isScrollable(getContent()) && // #1944
    getContent().contains(target))) {
      return true;
    }

    return false;
  };

  var undoIOSfix = function undoIOSfix() {
    if (hasClass(document.body, swalClasses.iosfix)) {
      var offset = parseInt(document.body.style.top, 10);
      removeClass(document.body, swalClasses.iosfix);
      document.body.style.top = '';
      document.body.scrollTop = offset * -1;
    }
  };

  /* istanbul ignore file */

  var isIE11 = function isIE11() {
    return !!window.MSInputMethodContext && !!document.documentMode;
  }; // Fix IE11 centering sweetalert2/issues/933


  var fixVerticalPositionIE = function fixVerticalPositionIE() {
    var container = getContainer();
    var popup = getPopup();
    container.style.removeProperty('align-items');

    if (popup.offsetTop < 0) {
      container.style.alignItems = 'flex-start';
    }
  };

  var IEfix = function IEfix() {
    if (typeof window !== 'undefined' && isIE11()) {
      fixVerticalPositionIE();
      window.addEventListener('resize', fixVerticalPositionIE);
    }
  };
  var undoIEfix = function undoIEfix() {
    if (typeof window !== 'undefined' && isIE11()) {
      window.removeEventListener('resize', fixVerticalPositionIE);
    }
  };

  // Adding aria-hidden="true" to elements outside of the active modal dialog ensures that
  // elements not within the active modal dialog will not be surfaced if a user opens a screen
  // reader’s list of elements (headings, form controls, landmarks, etc.) in the document.

  var setAriaHidden = function setAriaHidden() {
    var bodyChildren = toArray(document.body.children);
    bodyChildren.forEach(function (el) {
      if (el === getContainer() || contains(el, getContainer())) {
        return;
      }

      if (el.hasAttribute('aria-hidden')) {
        el.setAttribute('data-previous-aria-hidden', el.getAttribute('aria-hidden'));
      }

      el.setAttribute('aria-hidden', 'true');
    });
  };
  var unsetAriaHidden = function unsetAriaHidden() {
    var bodyChildren = toArray(document.body.children);
    bodyChildren.forEach(function (el) {
      if (el.hasAttribute('data-previous-aria-hidden')) {
        el.setAttribute('aria-hidden', el.getAttribute('data-previous-aria-hidden'));
        el.removeAttribute('data-previous-aria-hidden');
      } else {
        el.removeAttribute('aria-hidden');
      }
    });
  };

  /**
   * This module containts `WeakMap`s for each effectively-"private  property" that a `Swal` has.
   * For example, to set the private property "foo" of `this` to "bar", you can `privateProps.foo.set(this, 'bar')`
   * This is the approach that Babel will probably take to implement private methods/fields
   *   https://github.com/tc39/proposal-private-methods
   *   https://github.com/babel/babel/pull/7555
   * Once we have the changes from that PR in Babel, and our core class fits reasonable in *one module*
   *   then we can use that language feature.
   */
  var privateMethods = {
    swalPromiseResolve: new WeakMap()
  };

  /*
   * Instance method to close sweetAlert
   */

  function removePopupAndResetState(instance, container, isToast$$1, onAfterClose) {
    if (isToast$$1) {
      triggerOnAfterCloseAndDispose(instance, onAfterClose);
    } else {
      restoreActiveElement().then(function () {
        return triggerOnAfterCloseAndDispose(instance, onAfterClose);
      });
      globalState.keydownTarget.removeEventListener('keydown', globalState.keydownHandler, {
        capture: globalState.keydownListenerCapture
      });
      globalState.keydownHandlerAdded = false;
    }

    if (container.parentNode && !document.body.getAttribute('data-swal2-queue-step')) {
      container.parentNode.removeChild(container);
    }

    if (isModal()) {
      undoScrollbar();
      undoIOSfix();
      undoIEfix();
      unsetAriaHidden();
    }

    removeBodyClasses();
  }

  function removeBodyClasses() {
    removeClass([document.documentElement, document.body], [swalClasses.shown, swalClasses['height-auto'], swalClasses['no-backdrop'], swalClasses['toast-shown'], swalClasses['toast-column']]);
  }

  function close(resolveValue) {
    var popup = getPopup();

    if (!popup) {
      return;
    }

    var innerParams = privateProps.innerParams.get(this);

    if (!innerParams || hasClass(popup, innerParams.hideClass.popup)) {
      return;
    }

    var swalPromiseResolve = privateMethods.swalPromiseResolve.get(this);
    removeClass(popup, innerParams.showClass.popup);
    addClass(popup, innerParams.hideClass.popup);
    var backdrop = getContainer();
    removeClass(backdrop, innerParams.showClass.backdrop);
    addClass(backdrop, innerParams.hideClass.backdrop);
    handlePopupAnimation(this, popup, innerParams);

    if (typeof resolveValue !== 'undefined') {
      resolveValue.isDismissed = typeof resolveValue.dismiss !== 'undefined';
      resolveValue.isConfirmed = typeof resolveValue.dismiss === 'undefined';
    } else {
      resolveValue = {
        isDismissed: true,
        isConfirmed: false
      };
    } // Resolve Swal promise


    swalPromiseResolve(resolveValue || {});
  }

  var handlePopupAnimation = function handlePopupAnimation(instance, popup, innerParams) {
    var container = getContainer(); // If animation is supported, animate

    var animationIsSupported = animationEndEvent && hasCssAnimation(popup);
    var onClose = innerParams.onClose,
        onAfterClose = innerParams.onAfterClose;

    if (onClose !== null && typeof onClose === 'function') {
      onClose(popup);
    }

    if (animationIsSupported) {
      animatePopup(instance, popup, container, onAfterClose);
    } else {
      // Otherwise, remove immediately
      removePopupAndResetState(instance, container, isToast(), onAfterClose);
    }
  };

  var animatePopup = function animatePopup(instance, popup, container, onAfterClose) {
    globalState.swalCloseEventFinishedCallback = removePopupAndResetState.bind(null, instance, container, isToast(), onAfterClose);
    popup.addEventListener(animationEndEvent, function (e) {
      if (e.target === popup) {
        globalState.swalCloseEventFinishedCallback();
        delete globalState.swalCloseEventFinishedCallback;
      }
    });
  };

  var triggerOnAfterCloseAndDispose = function triggerOnAfterCloseAndDispose(instance, onAfterClose) {
    setTimeout(function () {
      if (typeof onAfterClose === 'function') {
        onAfterClose();
      }

      instance._destroy();
    });
  };

  function setButtonsDisabled(instance, buttons, disabled) {
    var domCache = privateProps.domCache.get(instance);
    buttons.forEach(function (button) {
      domCache[button].disabled = disabled;
    });
  }

  function setInputDisabled(input, disabled) {
    if (!input) {
      return false;
    }

    if (input.type === 'radio') {
      var radiosContainer = input.parentNode.parentNode;
      var radios = radiosContainer.querySelectorAll('input');

      for (var i = 0; i < radios.length; i++) {
        radios[i].disabled = disabled;
      }
    } else {
      input.disabled = disabled;
    }
  }

  function enableButtons() {
    setButtonsDisabled(this, ['confirmButton', 'cancelButton'], false);
  }
  function disableButtons() {
    setButtonsDisabled(this, ['confirmButton', 'cancelButton'], true);
  }
  function enableInput() {
    return setInputDisabled(this.getInput(), false);
  }
  function disableInput() {
    return setInputDisabled(this.getInput(), true);
  }

  function showValidationMessage(error) {
    var domCache = privateProps.domCache.get(this);
    setInnerHtml(domCache.validationMessage, error);
    var popupComputedStyle = window.getComputedStyle(domCache.popup);
    domCache.validationMessage.style.marginLeft = "-".concat(popupComputedStyle.getPropertyValue('padding-left'));
    domCache.validationMessage.style.marginRight = "-".concat(popupComputedStyle.getPropertyValue('padding-right'));
    show(domCache.validationMessage);
    var input = this.getInput();

    if (input) {
      input.setAttribute('aria-invalid', true);
      input.setAttribute('aria-describedBy', swalClasses['validation-message']);
      focusInput(input);
      addClass(input, swalClasses.inputerror);
    }
  } // Hide block with validation message

  function resetValidationMessage$1() {
    var domCache = privateProps.domCache.get(this);

    if (domCache.validationMessage) {
      hide(domCache.validationMessage);
    }

    var input = this.getInput();

    if (input) {
      input.removeAttribute('aria-invalid');
      input.removeAttribute('aria-describedBy');
      removeClass(input, swalClasses.inputerror);
    }
  }

  function getProgressSteps$1() {
    var domCache = privateProps.domCache.get(this);
    return domCache.progressSteps;
  }

  var Timer = /*#__PURE__*/function () {
    function Timer(callback, delay) {
      _classCallCheck(this, Timer);

      this.callback = callback;
      this.remaining = delay;
      this.running = false;
      this.start();
    }

    _createClass(Timer, [{
      key: "start",
      value: function start() {
        if (!this.running) {
          this.running = true;
          this.started = new Date();
          this.id = setTimeout(this.callback, this.remaining);
        }

        return this.remaining;
      }
    }, {
      key: "stop",
      value: function stop() {
        if (this.running) {
          this.running = false;
          clearTimeout(this.id);
          this.remaining -= new Date() - this.started;
        }

        return this.remaining;
      }
    }, {
      key: "increase",
      value: function increase(n) {
        var running = this.running;

        if (running) {
          this.stop();
        }

        this.remaining += n;

        if (running) {
          this.start();
        }

        return this.remaining;
      }
    }, {
      key: "getTimerLeft",
      value: function getTimerLeft() {
        if (this.running) {
          this.stop();
          this.start();
        }

        return this.remaining;
      }
    }, {
      key: "isRunning",
      value: function isRunning() {
        return this.running;
      }
    }]);

    return Timer;
  }();

  var defaultInputValidators = {
    email: function email(string, validationMessage) {
      return /^[a-zA-Z0-9.+_-]+@[a-zA-Z0-9.-]+\.[a-zA-Z0-9-]{2,24}$/.test(string) ? Promise.resolve() : Promise.resolve(validationMessage || 'Invalid email address');
    },
    url: function url(string, validationMessage) {
      // taken from https://stackoverflow.com/a/3809435 with a small change from #1306 and #2013
      return /^https?:\/\/(www\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\.[a-z]{2,63}\b([-a-zA-Z0-9@:%_+.~#?&/=]*)$/.test(string) ? Promise.resolve() : Promise.resolve(validationMessage || 'Invalid URL');
    }
  };

  function setDefaultInputValidators(params) {
    // Use default `inputValidator` for supported input types if not provided
    if (!params.inputValidator) {
      Object.keys(defaultInputValidators).forEach(function (key) {
        if (params.input === key) {
          params.inputValidator = defaultInputValidators[key];
        }
      });
    }
  }

  function validateCustomTargetElement(params) {
    // Determine if the custom target element is valid
    if (!params.target || typeof params.target === 'string' && !document.querySelector(params.target) || typeof params.target !== 'string' && !params.target.appendChild) {
      warn('Target parameter is not valid, defaulting to "body"');
      params.target = 'body';
    }
  }
  /**
   * Set type, text and actions on popup
   *
   * @param params
   * @returns {boolean}
   */


  function setParameters(params) {
    setDefaultInputValidators(params); // showLoaderOnConfirm && preConfirm

    if (params.showLoaderOnConfirm && !params.preConfirm) {
      warn('showLoaderOnConfirm is set to true, but preConfirm is not defined.\n' + 'showLoaderOnConfirm should be used together with preConfirm, see usage example:\n' + 'https://sweetalert2.github.io/#ajax-request');
    } // params.animation will be actually used in renderPopup.js
    // but in case when params.animation is a function, we need to call that function
    // before popup (re)initialization, so it'll be possible to check Swal.isVisible()
    // inside the params.animation function


    params.animation = callIfFunction(params.animation);
    validateCustomTargetElement(params); // Replace newlines with <br> in title

    if (typeof params.title === 'string') {
      params.title = params.title.split('\n').join('<br />');
    }

    init(params);
  }

  /**
   * Open popup, add necessary classes and styles, fix scrollbar
   *
   * @param {Array} params
   */

  var openPopup = function openPopup(params) {
    var container = getContainer();
    var popup = getPopup();

    if (typeof params.onBeforeOpen === 'function') {
      params.onBeforeOpen(popup);
    }

    var bodyStyles = window.getComputedStyle(document.body);
    var initialBodyOverflow = bodyStyles.overflowY;
    addClasses$1(container, popup, params); // scrolling is 'hidden' until animation is done, after that 'auto'

    setScrollingVisibility(container, popup);

    if (isModal()) {
      fixScrollContainer(container, params.scrollbarPadding, initialBodyOverflow);
      setAriaHidden();
    }

    if (!isToast() && !globalState.previousActiveElement) {
      globalState.previousActiveElement = document.activeElement;
    }

    if (typeof params.onOpen === 'function') {
      setTimeout(function () {
        return params.onOpen(popup);
      });
    }

    removeClass(container, swalClasses['no-transition']);
  };

  function swalOpenAnimationFinished(event) {
    var popup = getPopup();

    if (event.target !== popup) {
      return;
    }

    var container = getContainer();
    popup.removeEventListener(animationEndEvent, swalOpenAnimationFinished);
    container.style.overflowY = 'auto';
  }

  var setScrollingVisibility = function setScrollingVisibility(container, popup) {
    if (animationEndEvent && hasCssAnimation(popup)) {
      container.style.overflowY = 'hidden';
      popup.addEventListener(animationEndEvent, swalOpenAnimationFinished);
    } else {
      container.style.overflowY = 'auto';
    }
  };

  var fixScrollContainer = function fixScrollContainer(container, scrollbarPadding, initialBodyOverflow) {
    iOSfix();
    IEfix();

    if (scrollbarPadding && initialBodyOverflow !== 'hidden') {
      fixScrollbar();
    } // sweetalert2/issues/1247


    setTimeout(function () {
      container.scrollTop = 0;
    });
  };

  var addClasses$1 = function addClasses(container, popup, params) {
    addClass(container, params.showClass.backdrop);
    show(popup); // Animate popup right after showing it

    addClass(popup, params.showClass.popup);
    addClass([document.documentElement, document.body], swalClasses.shown);

    if (params.heightAuto && params.backdrop && !params.toast) {
      addClass([document.documentElement, document.body], swalClasses['height-auto']);
    }
  };

  var handleInputOptionsAndValue = function handleInputOptionsAndValue(instance, params) {
    if (params.input === 'select' || params.input === 'radio') {
      handleInputOptions(instance, params);
    } else if (['text', 'email', 'number', 'tel', 'textarea'].indexOf(params.input) !== -1 && (hasToPromiseFn(params.inputValue) || isPromise(params.inputValue))) {
      handleInputValue(instance, params);
    }
  };
  var getInputValue = function getInputValue(instance, innerParams) {
    var input = instance.getInput();

    if (!input) {
      return null;
    }

    switch (innerParams.input) {
      case 'checkbox':
        return getCheckboxValue(input);

      case 'radio':
        return getRadioValue(input);

      case 'file':
        return getFileValue(input);

      default:
        return innerParams.inputAutoTrim ? input.value.trim() : input.value;
    }
  };

  var getCheckboxValue = function getCheckboxValue(input) {
    return input.checked ? 1 : 0;
  };

  var getRadioValue = function getRadioValue(input) {
    return input.checked ? input.value : null;
  };

  var getFileValue = function getFileValue(input) {
    return input.files.length ? input.getAttribute('multiple') !== null ? input.files : input.files[0] : null;
  };

  var handleInputOptions = function handleInputOptions(instance, params) {
    var content = getContent();

    var processInputOptions = function processInputOptions(inputOptions) {
      return populateInputOptions[params.input](content, formatInputOptions(inputOptions), params);
    };

    if (hasToPromiseFn(params.inputOptions) || isPromise(params.inputOptions)) {
      showLoading();
      asPromise(params.inputOptions).then(function (inputOptions) {
        instance.hideLoading();
        processInputOptions(inputOptions);
      });
    } else if (_typeof(params.inputOptions) === 'object') {
      processInputOptions(params.inputOptions);
    } else {
      error("Unexpected type of inputOptions! Expected object, Map or Promise, got ".concat(_typeof(params.inputOptions)));
    }
  };

  var handleInputValue = function handleInputValue(instance, params) {
    var input = instance.getInput();
    hide(input);
    asPromise(params.inputValue).then(function (inputValue) {
      input.value = params.input === 'number' ? parseFloat(inputValue) || 0 : "".concat(inputValue);
      show(input);
      input.focus();
      instance.hideLoading();
    })["catch"](function (err) {
      error("Error in inputValue promise: ".concat(err));
      input.value = '';
      show(input);
      input.focus();
      instance.hideLoading();
    });
  };

  var populateInputOptions = {
    select: function select(content, inputOptions, params) {
      var select = getChildByClass(content, swalClasses.select);

      var renderOption = function renderOption(parent, optionLabel, optionValue) {
        var option = document.createElement('option');
        option.value = optionValue;
        setInnerHtml(option, optionLabel);

        if (params.inputValue.toString() === optionValue.toString()) {
          option.selected = true;
        }

        parent.appendChild(option);
      };

      inputOptions.forEach(function (inputOption) {
        var optionValue = inputOption[0];
        var optionLabel = inputOption[1]; // <optgroup> spec:
        // https://www.w3.org/TR/html401/interact/forms.html#h-17.6
        // "...all OPTGROUP elements must be specified directly within a SELECT element (i.e., groups may not be nested)..."
        // check whether this is a <optgroup>

        if (Array.isArray(optionLabel)) {
          // if it is an array, then it is an <optgroup>
          var optgroup = document.createElement('optgroup');
          optgroup.label = optionValue;
          optgroup.disabled = false; // not configurable for now

          select.appendChild(optgroup);
          optionLabel.forEach(function (o) {
            return renderOption(optgroup, o[1], o[0]);
          });
        } else {
          // case of <option>
          renderOption(select, optionLabel, optionValue);
        }
      });
      select.focus();
    },
    radio: function radio(content, inputOptions, params) {
      var radio = getChildByClass(content, swalClasses.radio);
      inputOptions.forEach(function (inputOption) {
        var radioValue = inputOption[0];
        var radioLabel = inputOption[1];
        var radioInput = document.createElement('input');
        var radioLabelElement = document.createElement('label');
        radioInput.type = 'radio';
        radioInput.name = swalClasses.radio;
        radioInput.value = radioValue;

        if (params.inputValue.toString() === radioValue.toString()) {
          radioInput.checked = true;
        }

        var label = document.createElement('span');
        setInnerHtml(label, radioLabel);
        label.className = swalClasses.label;
        radioLabelElement.appendChild(radioInput);
        radioLabelElement.appendChild(label);
        radio.appendChild(radioLabelElement);
      });
      var radios = radio.querySelectorAll('input');

      if (radios.length) {
        radios[0].focus();
      }
    }
  };
  /**
   * Converts `inputOptions` into an array of `[value, label]`s
   * @param inputOptions
   */

  var formatInputOptions = function formatInputOptions(inputOptions) {
    var result = [];

    if (typeof Map !== 'undefined' && inputOptions instanceof Map) {
      inputOptions.forEach(function (value, key) {
        var valueFormatted = value;

        if (_typeof(valueFormatted) === 'object') {
          // case of <optgroup>
          valueFormatted = formatInputOptions(valueFormatted);
        }

        result.push([key, valueFormatted]);
      });
    } else {
      Object.keys(inputOptions).forEach(function (key) {
        var valueFormatted = inputOptions[key];

        if (_typeof(valueFormatted) === 'object') {
          // case of <optgroup>
          valueFormatted = formatInputOptions(valueFormatted);
        }

        result.push([key, valueFormatted]);
      });
    }

    return result;
  };

  var handleConfirmButtonClick = function handleConfirmButtonClick(instance, innerParams) {
    instance.disableButtons();

    if (innerParams.input) {
      handleConfirmWithInput(instance, innerParams);
    } else {
      confirm(instance, innerParams, true);
    }
  };
  var handleCancelButtonClick = function handleCancelButtonClick(instance, dismissWith) {
    instance.disableButtons();
    dismissWith(DismissReason.cancel);
  };

  var handleConfirmWithInput = function handleConfirmWithInput(instance, innerParams) {
    var inputValue = getInputValue(instance, innerParams);

    if (innerParams.inputValidator) {
      instance.disableInput();
      var validationPromise = Promise.resolve().then(function () {
        return asPromise(innerParams.inputValidator(inputValue, innerParams.validationMessage));
      });
      validationPromise.then(function (validationMessage) {
        instance.enableButtons();
        instance.enableInput();

        if (validationMessage) {
          instance.showValidationMessage(validationMessage);
        } else {
          confirm(instance, innerParams, inputValue);
        }
      });
    } else if (!instance.getInput().checkValidity()) {
      instance.enableButtons();
      instance.showValidationMessage(innerParams.validationMessage);
    } else {
      confirm(instance, innerParams, inputValue);
    }
  };

  var succeedWith = function succeedWith(instance, value) {
    instance.closePopup({
      value: value
    });
  };

  var confirm = function confirm(instance, innerParams, value) {
    if (innerParams.showLoaderOnConfirm) {
      showLoading(); // TODO: make showLoading an *instance* method
    }

    if (innerParams.preConfirm) {
      instance.resetValidationMessage();
      var preConfirmPromise = Promise.resolve().then(function () {
        return asPromise(innerParams.preConfirm(value, innerParams.validationMessage));
      });
      preConfirmPromise.then(function (preConfirmValue) {
        if (isVisible(getValidationMessage()) || preConfirmValue === false) {
          instance.hideLoading();
        } else {
          succeedWith(instance, typeof preConfirmValue === 'undefined' ? value : preConfirmValue);
        }
      });
    } else {
      succeedWith(instance, value);
    }
  };

  var addKeydownHandler = function addKeydownHandler(instance, globalState, innerParams, dismissWith) {
    if (globalState.keydownTarget && globalState.keydownHandlerAdded) {
      globalState.keydownTarget.removeEventListener('keydown', globalState.keydownHandler, {
        capture: globalState.keydownListenerCapture
      });
      globalState.keydownHandlerAdded = false;
    }

    if (!innerParams.toast) {
      globalState.keydownHandler = function (e) {
        return keydownHandler(instance, e, dismissWith);
      };

      globalState.keydownTarget = innerParams.keydownListenerCapture ? window : getPopup();
      globalState.keydownListenerCapture = innerParams.keydownListenerCapture;
      globalState.keydownTarget.addEventListener('keydown', globalState.keydownHandler, {
        capture: globalState.keydownListenerCapture
      });
      globalState.keydownHandlerAdded = true;
    }
  }; // Focus handling

  var setFocus = function setFocus(innerParams, index, increment) {
    var focusableElements = getFocusableElements(); // search for visible elements and select the next possible match

    for (var i = 0; i < focusableElements.length; i++) {
      index = index + increment; // rollover to first item

      if (index === focusableElements.length) {
        index = 0; // go to last item
      } else if (index === -1) {
        index = focusableElements.length - 1;
      }

      return focusableElements[index].focus();
    } // no visible focusable elements, focus the popup


    getPopup().focus();
  };
  var arrowKeys = ['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', 'Left', 'Right', 'Up', 'Down' // IE11
  ];
  var escKeys = ['Escape', 'Esc' // IE11
  ];

  var keydownHandler = function keydownHandler(instance, e, dismissWith) {
    var innerParams = privateProps.innerParams.get(instance);

    if (innerParams.stopKeydownPropagation) {
      e.stopPropagation();
    } // ENTER


    if (e.key === 'Enter') {
      handleEnter(instance, e, innerParams); // TAB
    } else if (e.key === 'Tab') {
      handleTab(e, innerParams); // ARROWS - switch focus between buttons
    } else if (arrowKeys.indexOf(e.key) !== -1) {
      handleArrows(); // ESC
    } else if (escKeys.indexOf(e.key) !== -1) {
      handleEsc(e, innerParams, dismissWith);
    }
  };

  var handleEnter = function handleEnter(instance, e, innerParams) {
    // #720 #721
    if (e.isComposing) {
      return;
    }

    if (e.target && instance.getInput() && e.target.outerHTML === instance.getInput().outerHTML) {
      if (['textarea', 'file'].indexOf(innerParams.input) !== -1) {
        return; // do not submit
      }

      clickConfirm();
      e.preventDefault();
    }
  };

  var handleTab = function handleTab(e, innerParams) {
    var targetElement = e.target;
    var focusableElements = getFocusableElements();
    var btnIndex = -1;

    for (var i = 0; i < focusableElements.length; i++) {
      if (targetElement === focusableElements[i]) {
        btnIndex = i;
        break;
      }
    }

    if (!e.shiftKey) {
      // Cycle to the next button
      setFocus(innerParams, btnIndex, 1);
    } else {
      // Cycle to the prev button
      setFocus(innerParams, btnIndex, -1);
    }

    e.stopPropagation();
    e.preventDefault();
  };

  var handleArrows = function handleArrows() {
    var confirmButton = getConfirmButton();
    var cancelButton = getCancelButton(); // focus Cancel button if Confirm button is currently focused

    if (document.activeElement === confirmButton && isVisible(cancelButton)) {
      cancelButton.focus(); // and vice versa
    } else if (document.activeElement === cancelButton && isVisible(confirmButton)) {
      confirmButton.focus();
    }
  };

  var handleEsc = function handleEsc(e, innerParams, dismissWith) {
    if (callIfFunction(innerParams.allowEscapeKey)) {
      e.preventDefault();
      dismissWith(DismissReason.esc);
    }
  };

  var handlePopupClick = function handlePopupClick(instance, domCache, dismissWith) {
    var innerParams = privateProps.innerParams.get(instance);

    if (innerParams.toast) {
      handleToastClick(instance, domCache, dismissWith);
    } else {
      // Ignore click events that had mousedown on the popup but mouseup on the container
      // This can happen when the user drags a slider
      handleModalMousedown(domCache); // Ignore click events that had mousedown on the container but mouseup on the popup

      handleContainerMousedown(domCache);
      handleModalClick(instance, domCache, dismissWith);
    }
  };

  var handleToastClick = function handleToastClick(instance, domCache, dismissWith) {
    // Closing toast by internal click
    domCache.popup.onclick = function () {
      var innerParams = privateProps.innerParams.get(instance);

      if (innerParams.showConfirmButton || innerParams.showCancelButton || innerParams.showCloseButton || innerParams.input) {
        return;
      }

      dismissWith(DismissReason.close);
    };
  };

  var ignoreOutsideClick = false;

  var handleModalMousedown = function handleModalMousedown(domCache) {
    domCache.popup.onmousedown = function () {
      domCache.container.onmouseup = function (e) {
        domCache.container.onmouseup = undefined; // We only check if the mouseup target is the container because usually it doesn't
        // have any other direct children aside of the popup

        if (e.target === domCache.container) {
          ignoreOutsideClick = true;
        }
      };
    };
  };

  var handleContainerMousedown = function handleContainerMousedown(domCache) {
    domCache.container.onmousedown = function () {
      domCache.popup.onmouseup = function (e) {
        domCache.popup.onmouseup = undefined; // We also need to check if the mouseup target is a child of the popup

        if (e.target === domCache.popup || domCache.popup.contains(e.target)) {
          ignoreOutsideClick = true;
        }
      };
    };
  };

  var handleModalClick = function handleModalClick(instance, domCache, dismissWith) {
    domCache.container.onclick = function (e) {
      var innerParams = privateProps.innerParams.get(instance);

      if (ignoreOutsideClick) {
        ignoreOutsideClick = false;
        return;
      }

      if (e.target === domCache.container && callIfFunction(innerParams.allowOutsideClick)) {
        dismissWith(DismissReason.backdrop);
      }
    };
  };

  function _main(userParams) {
    showWarningsForParams(userParams);

    if (globalState.currentInstance) {
      globalState.currentInstance._destroy();
    }

    globalState.currentInstance = this;
    var innerParams = prepareParams(userParams);
    setParameters(innerParams);
    Object.freeze(innerParams); // clear the previous timer

    if (globalState.timeout) {
      globalState.timeout.stop();
      delete globalState.timeout;
    } // clear the restore focus timeout


    clearTimeout(globalState.restoreFocusTimeout);
    var domCache = populateDomCache(this);
    render(this, innerParams);
    privateProps.innerParams.set(this, innerParams);
    return swalPromise(this, domCache, innerParams);
  }

  var prepareParams = function prepareParams(userParams) {
    var showClass = _extends({}, defaultParams.showClass, userParams.showClass);

    var hideClass = _extends({}, defaultParams.hideClass, userParams.hideClass);

    var params = _extends({}, defaultParams, userParams);

    params.showClass = showClass;
    params.hideClass = hideClass; // @deprecated

    if (userParams.animation === false) {
      params.showClass = {
        popup: 'swal2-noanimation',
        backdrop: 'swal2-noanimation'
      };
      params.hideClass = {};
    }

    return params;
  };

  var swalPromise = function swalPromise(instance, domCache, innerParams) {
    return new Promise(function (resolve) {
      // functions to handle all closings/dismissals
      var dismissWith = function dismissWith(dismiss) {
        instance.closePopup({
          dismiss: dismiss
        });
      };

      privateMethods.swalPromiseResolve.set(instance, resolve);

      domCache.confirmButton.onclick = function () {
        return handleConfirmButtonClick(instance, innerParams);
      };

      domCache.cancelButton.onclick = function () {
        return handleCancelButtonClick(instance, dismissWith);
      };

      domCache.closeButton.onclick = function () {
        return dismissWith(DismissReason.close);
      };

      handlePopupClick(instance, domCache, dismissWith);
      addKeydownHandler(instance, globalState, innerParams, dismissWith);

      if (innerParams.toast && (innerParams.input || innerParams.footer || innerParams.showCloseButton)) {
        addClass(document.body, swalClasses['toast-column']);
      } else {
        removeClass(document.body, swalClasses['toast-column']);
      }

      handleInputOptionsAndValue(instance, innerParams);
      openPopup(innerParams);
      setupTimer(globalState, innerParams, dismissWith);
      initFocus(domCache, innerParams); // Scroll container to top on open (#1247, #1946)

      setTimeout(function () {
        domCache.container.scrollTop = 0;
      });
    });
  };

  var populateDomCache = function populateDomCache(instance) {
    var domCache = {
      popup: getPopup(),
      container: getContainer(),
      content: getContent(),
      actions: getActions(),
      confirmButton: getConfirmButton(),
      cancelButton: getCancelButton(),
      closeButton: getCloseButton(),
      validationMessage: getValidationMessage(),
      progressSteps: getProgressSteps()
    };
    privateProps.domCache.set(instance, domCache);
    return domCache;
  };

  var setupTimer = function setupTimer(globalState$$1, innerParams, dismissWith) {
    var timerProgressBar = getTimerProgressBar();
    hide(timerProgressBar);

    if (innerParams.timer) {
      globalState$$1.timeout = new Timer(function () {
        dismissWith('timer');
        delete globalState$$1.timeout;
      }, innerParams.timer);

      if (innerParams.timerProgressBar) {
        show(timerProgressBar);
        setTimeout(function () {
          if (globalState$$1.timeout.running) {
            // timer can be already stopped at this point
            animateTimerProgressBar(innerParams.timer);
          }
        });
      }
    }
  };

  var initFocus = function initFocus(domCache, innerParams) {
    if (innerParams.toast) {
      return;
    }

    if (!callIfFunction(innerParams.allowEnterKey)) {
      return blurActiveElement();
    }

    if (innerParams.focusCancel && isVisible(domCache.cancelButton)) {
      return domCache.cancelButton.focus();
    }

    if (innerParams.focusConfirm && isVisible(domCache.confirmButton)) {
      return domCache.confirmButton.focus();
    }

    setFocus(innerParams, -1, 1);
  };

  var blurActiveElement = function blurActiveElement() {
    if (document.activeElement && typeof document.activeElement.blur === 'function') {
      document.activeElement.blur();
    }
  };

  /**
   * Updates popup parameters.
   */

  function update(params) {
    var popup = getPopup();
    var innerParams = privateProps.innerParams.get(this);

    if (!popup || hasClass(popup, innerParams.hideClass.popup)) {
      return warn("You're trying to update the closed or closing popup, that won't work. Use the update() method in preConfirm parameter or show a new popup.");
    }

    var validUpdatableParams = {}; // assign valid params from `params` to `defaults`

    Object.keys(params).forEach(function (param) {
      if (Swal.isUpdatableParameter(param)) {
        validUpdatableParams[param] = params[param];
      } else {
        warn("Invalid parameter to update: \"".concat(param, "\". Updatable params are listed here: https://github.com/sweetalert2/sweetalert2/blob/master/src/utils/params.js"));
      }
    });

    var updatedParams = _extends({}, innerParams, validUpdatableParams);

    render(this, updatedParams);
    privateProps.innerParams.set(this, updatedParams);
    Object.defineProperties(this, {
      params: {
        value: _extends({}, this.params, params),
        writable: false,
        enumerable: true
      }
    });
  }

  function _destroy() {
    var domCache = privateProps.domCache.get(this);
    var innerParams = privateProps.innerParams.get(this);

    if (!innerParams) {
      return; // This instance has already been destroyed
    } // Check if there is another Swal closing


    if (domCache.popup && globalState.swalCloseEventFinishedCallback) {
      globalState.swalCloseEventFinishedCallback();
      delete globalState.swalCloseEventFinishedCallback;
    } // Check if there is a swal disposal defer timer


    if (globalState.deferDisposalTimer) {
      clearTimeout(globalState.deferDisposalTimer);
      delete globalState.deferDisposalTimer;
    }

    if (typeof innerParams.onDestroy === 'function') {
      innerParams.onDestroy();
    }

    disposeSwal(this);
  }

  var disposeSwal = function disposeSwal(instance) {
    // Unset this.params so GC will dispose it (#1569)
    delete instance.params; // Unset globalState props so GC will dispose globalState (#1569)

    delete globalState.keydownHandler;
    delete globalState.keydownTarget; // Unset WeakMaps so GC will be able to dispose them (#1569)

    unsetWeakMaps(privateProps);
    unsetWeakMaps(privateMethods);
  };

  var unsetWeakMaps = function unsetWeakMaps(obj) {
    for (var i in obj) {
      obj[i] = new WeakMap();
    }
  };



  var instanceMethods = /*#__PURE__*/Object.freeze({
    hideLoading: hideLoading,
    disableLoading: hideLoading,
    getInput: getInput$1,
    close: close,
    closePopup: close,
    closeModal: close,
    closeToast: close,
    enableButtons: enableButtons,
    disableButtons: disableButtons,
    enableInput: enableInput,
    disableInput: disableInput,
    showValidationMessage: showValidationMessage,
    resetValidationMessage: resetValidationMessage$1,
    getProgressSteps: getProgressSteps$1,
    _main: _main,
    update: update,
    _destroy: _destroy
  });

  var currentInstance;

  var SweetAlert = /*#__PURE__*/function () {
    function SweetAlert() {
      _classCallCheck(this, SweetAlert);

      // Prevent run in Node env
      if (typeof window === 'undefined') {
        return;
      } // Check for the existence of Promise


      if (typeof Promise === 'undefined') {
        error('This package requires a Promise library, please include a shim to enable it in this browser (See: https://github.com/sweetalert2/sweetalert2/wiki/Migration-from-SweetAlert-to-SweetAlert2#1-ie-support)');
      }

      currentInstance = this;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      var outerParams = Object.freeze(this.constructor.argsToParams(args));
      Object.defineProperties(this, {
        params: {
          value: outerParams,
          writable: false,
          enumerable: true,
          configurable: true
        }
      });

      var promise = this._main(this.params);

      privateProps.promise.set(this, promise);
    } // `catch` cannot be the name of a module export, so we define our thenable methods here instead


    _createClass(SweetAlert, [{
      key: "then",
      value: function then(onFulfilled) {
        var promise = privateProps.promise.get(this);
        return promise.then(onFulfilled);
      }
    }, {
      key: "finally",
      value: function _finally(onFinally) {
        var promise = privateProps.promise.get(this);
        return promise["finally"](onFinally);
      }
    }]);

    return SweetAlert;
  }(); // Assign instance methods from src/instanceMethods/*.js to prototype


  _extends(SweetAlert.prototype, instanceMethods); // Assign static methods from src/staticMethods/*.js to constructor


  _extends(SweetAlert, staticMethods); // Proxy to instance methods to constructor, for now, for backwards compatibility


  Object.keys(instanceMethods).forEach(function (key) {
    SweetAlert[key] = function () {
      if (currentInstance) {
        var _currentInstance;

        return (_currentInstance = currentInstance)[key].apply(_currentInstance, arguments);
      }
    };
  });
  SweetAlert.DismissReason = DismissReason;
  SweetAlert.version = '9.17.2';

  var Swal = SweetAlert;
  Swal["default"] = Swal;

  return Swal;

}));
if (typeof this !== 'undefined' && this.Sweetalert2){  this.swal = this.sweetAlert = this.Swal = this.SweetAlert = this.Sweetalert2}

"undefined"!=typeof document&&function(e,t){var n=e.createElement("style");if(e.getElementsByTagName("head")[0].appendChild(n),n.styleSheet)n.styleSheet.disabled||(n.styleSheet.cssText=t);else try{n.innerHTML=t}catch(e){n.innerText=t}}(document,".swal2-popup.swal2-toast{flex-direction:row;align-items:center;width:auto;padding:.625em;overflow-y:hidden;background:#fff;box-shadow:0 0 .625em #d9d9d9}.swal2-popup.swal2-toast .swal2-header{flex-direction:row;padding:0}.swal2-popup.swal2-toast .swal2-title{flex-grow:1;justify-content:flex-start;margin:0 .6em;font-size:1em}.swal2-popup.swal2-toast .swal2-footer{margin:.5em 0 0;padding:.5em 0 0;font-size:.8em}.swal2-popup.swal2-toast .swal2-close{position:static;width:.8em;height:.8em;line-height:.8}.swal2-popup.swal2-toast .swal2-content{justify-content:flex-start;padding:0;font-size:1em}.swal2-popup.swal2-toast .swal2-icon{width:2em;min-width:2em;height:2em;margin:0}.swal2-popup.swal2-toast .swal2-icon .swal2-icon-content{display:flex;align-items:center;font-size:1.8em;font-weight:700}@media all and (-ms-high-contrast:none),(-ms-high-contrast:active){.swal2-popup.swal2-toast .swal2-icon .swal2-icon-content{font-size:.25em}}.swal2-popup.swal2-toast .swal2-icon.swal2-success .swal2-success-ring{width:2em;height:2em}.swal2-popup.swal2-toast .swal2-icon.swal2-error [class^=swal2-x-mark-line]{top:.875em;width:1.375em}.swal2-popup.swal2-toast .swal2-icon.swal2-error [class^=swal2-x-mark-line][class$=left]{left:.3125em}.swal2-popup.swal2-toast .swal2-icon.swal2-error [class^=swal2-x-mark-line][class$=right]{right:.3125em}.swal2-popup.swal2-toast .swal2-actions{flex-basis:auto!important;width:auto;height:auto;margin:0 .3125em}.swal2-popup.swal2-toast .swal2-styled{margin:0 .3125em;padding:.3125em .625em;font-size:1em}.swal2-popup.swal2-toast .swal2-styled:focus{box-shadow:0 0 0 1px #fff,0 0 0 3px rgba(50,100,150,.4)}.swal2-popup.swal2-toast .swal2-success{border-color:#a5dc86}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-circular-line]{position:absolute;width:1.6em;height:3em;transform:rotate(45deg);border-radius:50%}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-circular-line][class$=left]{top:-.8em;left:-.5em;transform:rotate(-45deg);transform-origin:2em 2em;border-radius:4em 0 0 4em}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-circular-line][class$=right]{top:-.25em;left:.9375em;transform-origin:0 1.5em;border-radius:0 4em 4em 0}.swal2-popup.swal2-toast .swal2-success .swal2-success-ring{width:2em;height:2em}.swal2-popup.swal2-toast .swal2-success .swal2-success-fix{top:0;left:.4375em;width:.4375em;height:2.6875em}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-line]{height:.3125em}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-line][class$=tip]{top:1.125em;left:.1875em;width:.75em}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-line][class$=long]{top:.9375em;right:.1875em;width:1.375em}.swal2-popup.swal2-toast .swal2-success.swal2-icon-show .swal2-success-line-tip{-webkit-animation:swal2-toast-animate-success-line-tip .75s;animation:swal2-toast-animate-success-line-tip .75s}.swal2-popup.swal2-toast .swal2-success.swal2-icon-show .swal2-success-line-long{-webkit-animation:swal2-toast-animate-success-line-long .75s;animation:swal2-toast-animate-success-line-long .75s}.swal2-popup.swal2-toast.swal2-show{-webkit-animation:swal2-toast-show .5s;animation:swal2-toast-show .5s}.swal2-popup.swal2-toast.swal2-hide{-webkit-animation:swal2-toast-hide .1s forwards;animation:swal2-toast-hide .1s forwards}.swal2-container{display:flex;position:fixed;z-index:1060;top:0;right:0;bottom:0;left:0;flex-direction:row;align-items:center;justify-content:center;padding:.625em;overflow-x:hidden;transition:background-color .1s;-webkit-overflow-scrolling:touch}.swal2-container.swal2-backdrop-show,.swal2-container.swal2-noanimation{background:rgba(0,0,0,.4)}.swal2-container.swal2-backdrop-hide{background:0 0!important}.swal2-container.swal2-top{align-items:flex-start}.swal2-container.swal2-top-left,.swal2-container.swal2-top-start{align-items:flex-start;justify-content:flex-start}.swal2-container.swal2-top-end,.swal2-container.swal2-top-right{align-items:flex-start;justify-content:flex-end}.swal2-container.swal2-center{align-items:center}.swal2-container.swal2-center-left,.swal2-container.swal2-center-start{align-items:center;justify-content:flex-start}.swal2-container.swal2-center-end,.swal2-container.swal2-center-right{align-items:center;justify-content:flex-end}.swal2-container.swal2-bottom{align-items:flex-end}.swal2-container.swal2-bottom-left,.swal2-container.swal2-bottom-start{align-items:flex-end;justify-content:flex-start}.swal2-container.swal2-bottom-end,.swal2-container.swal2-bottom-right{align-items:flex-end;justify-content:flex-end}.swal2-container.swal2-bottom-end>:first-child,.swal2-container.swal2-bottom-left>:first-child,.swal2-container.swal2-bottom-right>:first-child,.swal2-container.swal2-bottom-start>:first-child,.swal2-container.swal2-bottom>:first-child{margin-top:auto}.swal2-container.swal2-grow-fullscreen>.swal2-modal{display:flex!important;flex:1;align-self:stretch;justify-content:center}.swal2-container.swal2-grow-row>.swal2-modal{display:flex!important;flex:1;align-content:center;justify-content:center}.swal2-container.swal2-grow-column{flex:1;flex-direction:column}.swal2-container.swal2-grow-column.swal2-bottom,.swal2-container.swal2-grow-column.swal2-center,.swal2-container.swal2-grow-column.swal2-top{align-items:center}.swal2-container.swal2-grow-column.swal2-bottom-left,.swal2-container.swal2-grow-column.swal2-bottom-start,.swal2-container.swal2-grow-column.swal2-center-left,.swal2-container.swal2-grow-column.swal2-center-start,.swal2-container.swal2-grow-column.swal2-top-left,.swal2-container.swal2-grow-column.swal2-top-start{align-items:flex-start}.swal2-container.swal2-grow-column.swal2-bottom-end,.swal2-container.swal2-grow-column.swal2-bottom-right,.swal2-container.swal2-grow-column.swal2-center-end,.swal2-container.swal2-grow-column.swal2-center-right,.swal2-container.swal2-grow-column.swal2-top-end,.swal2-container.swal2-grow-column.swal2-top-right{align-items:flex-end}.swal2-container.swal2-grow-column>.swal2-modal{display:flex!important;flex:1;align-content:center;justify-content:center}.swal2-container.swal2-no-transition{transition:none!important}.swal2-container:not(.swal2-top):not(.swal2-top-start):not(.swal2-top-end):not(.swal2-top-left):not(.swal2-top-right):not(.swal2-center-start):not(.swal2-center-end):not(.swal2-center-left):not(.swal2-center-right):not(.swal2-bottom):not(.swal2-bottom-start):not(.swal2-bottom-end):not(.swal2-bottom-left):not(.swal2-bottom-right):not(.swal2-grow-fullscreen)>.swal2-modal{margin:auto}@media all and (-ms-high-contrast:none),(-ms-high-contrast:active){.swal2-container .swal2-modal{margin:0!important}}.swal2-popup{display:none;position:relative;box-sizing:border-box;flex-direction:column;justify-content:center;width:32em;max-width:100%;padding:1.25em;border:none;border-radius:.3125em;background:#fff;font-family:inherit;font-size:1rem}.swal2-popup:focus{outline:0}.swal2-popup.swal2-loading{overflow-y:hidden}.swal2-header{display:flex;flex-direction:column;align-items:center;padding:0 1.8em}.swal2-title{position:relative;max-width:100%;margin:0 0 .4em;padding:0;color:#595959;font-size:1.875em;font-weight:600;text-align:center;text-transform:none;word-wrap:break-word}.swal2-actions{display:flex;z-index:1;flex-wrap:wrap;align-items:center;justify-content:center;width:100%;margin:1.25em auto 0}.swal2-actions:not(.swal2-loading) .swal2-styled[disabled]{opacity:.4}.swal2-actions:not(.swal2-loading) .swal2-styled:hover{background-image:linear-gradient(rgba(0,0,0,.1),rgba(0,0,0,.1))}.swal2-actions:not(.swal2-loading) .swal2-styled:active{background-image:linear-gradient(rgba(0,0,0,.2),rgba(0,0,0,.2))}.swal2-actions.swal2-loading .swal2-styled.swal2-confirm{box-sizing:border-box;width:2.5em;height:2.5em;margin:.46875em;padding:0;-webkit-animation:swal2-rotate-loading 1.5s linear 0s infinite normal;animation:swal2-rotate-loading 1.5s linear 0s infinite normal;border:.25em solid transparent;border-radius:100%;border-color:transparent;background-color:transparent!important;color:transparent!important;cursor:default;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.swal2-actions.swal2-loading .swal2-styled.swal2-cancel{margin-right:30px;margin-left:30px}.swal2-actions.swal2-loading :not(.swal2-styled).swal2-confirm::after{content:\"\";display:inline-block;width:15px;height:15px;margin-left:5px;-webkit-animation:swal2-rotate-loading 1.5s linear 0s infinite normal;animation:swal2-rotate-loading 1.5s linear 0s infinite normal;border:3px solid #999;border-radius:50%;border-right-color:transparent;box-shadow:1px 1px 1px #fff}.swal2-styled{margin:.3125em;padding:.625em 2em;box-shadow:none;font-weight:500}.swal2-styled:not([disabled]){cursor:pointer}.swal2-styled.swal2-confirm{border:0;border-radius:.25em;background:initial;background-color:#3085d6;color:#fff;font-size:1.0625em}.swal2-styled.swal2-cancel{border:0;border-radius:.25em;background:initial;background-color:#aaa;color:#fff;font-size:1.0625em}.swal2-styled:focus{outline:0;box-shadow:0 0 0 1px #fff,0 0 0 3px rgba(50,100,150,.4)}.swal2-styled::-moz-focus-inner{border:0}.swal2-footer{justify-content:center;margin:1.25em 0 0;padding:1em 0 0;border-top:1px solid #eee;color:#545454;font-size:1em}.swal2-timer-progress-bar-container{position:absolute;right:0;bottom:0;left:0;height:.25em;overflow:hidden;border-bottom-right-radius:.3125em;border-bottom-left-radius:.3125em}.swal2-timer-progress-bar{width:100%;height:.25em;background:rgba(0,0,0,.2)}.swal2-image{max-width:100%;margin:1.25em auto}.swal2-close{position:absolute;z-index:2;top:0;right:0;align-items:center;justify-content:center;width:1.2em;height:1.2em;padding:0;overflow:hidden;transition:color .1s ease-out;border:none;border-radius:0;background:0 0;color:#ccc;font-family:serif;font-size:2.5em;line-height:1.2;cursor:pointer}.swal2-close:hover{transform:none;background:0 0;color:#f27474}.swal2-close::-moz-focus-inner{border:0}.swal2-content{z-index:1;justify-content:center;margin:0;padding:0 1.6em;color:#545454;font-size:1.125em;font-weight:400;line-height:normal;text-align:center;word-wrap:break-word}.swal2-checkbox,.swal2-file,.swal2-input,.swal2-radio,.swal2-select,.swal2-textarea{margin:1em auto}.swal2-file,.swal2-input,.swal2-textarea{box-sizing:border-box;width:100%;transition:border-color .3s,box-shadow .3s;border:1px solid #d9d9d9;border-radius:.1875em;background:inherit;box-shadow:inset 0 1px 1px rgba(0,0,0,.06);color:inherit;font-size:1.125em}.swal2-file.swal2-inputerror,.swal2-input.swal2-inputerror,.swal2-textarea.swal2-inputerror{border-color:#f27474!important;box-shadow:0 0 2px #f27474!important}.swal2-file:focus,.swal2-input:focus,.swal2-textarea:focus{border:1px solid #b4dbed;outline:0;box-shadow:0 0 3px #c4e6f5}.swal2-file::-moz-placeholder,.swal2-input::-moz-placeholder,.swal2-textarea::-moz-placeholder{color:#ccc}.swal2-file:-ms-input-placeholder,.swal2-input:-ms-input-placeholder,.swal2-textarea:-ms-input-placeholder{color:#ccc}.swal2-file::-ms-input-placeholder,.swal2-input::-ms-input-placeholder,.swal2-textarea::-ms-input-placeholder{color:#ccc}.swal2-file::placeholder,.swal2-input::placeholder,.swal2-textarea::placeholder{color:#ccc}.swal2-range{margin:1em auto;background:#fff}.swal2-range input{width:80%}.swal2-range output{width:20%;color:inherit;font-weight:600;text-align:center}.swal2-range input,.swal2-range output{height:2.625em;padding:0;font-size:1.125em;line-height:2.625em}.swal2-input{height:2.625em;padding:0 .75em}.swal2-input[type=number]{max-width:10em}.swal2-file{background:inherit;font-size:1.125em}.swal2-textarea{height:6.75em;padding:.75em}.swal2-select{min-width:50%;max-width:100%;padding:.375em .625em;background:inherit;color:inherit;font-size:1.125em}.swal2-checkbox,.swal2-radio{align-items:center;justify-content:center;background:#fff;color:inherit}.swal2-checkbox label,.swal2-radio label{margin:0 .6em;font-size:1.125em}.swal2-checkbox input,.swal2-radio input{margin:0 .4em}.swal2-validation-message{display:none;align-items:center;justify-content:center;padding:.625em;overflow:hidden;background:#f0f0f0;color:#666;font-size:1em;font-weight:300}.swal2-validation-message::before{content:\"!\";display:inline-block;width:1.5em;min-width:1.5em;height:1.5em;margin:0 .625em;border-radius:50%;background-color:#f27474;color:#fff;font-weight:600;line-height:1.5em;text-align:center}.swal2-icon{position:relative;box-sizing:content-box;justify-content:center;width:5em;height:5em;margin:1.25em auto 1.875em;border:.25em solid transparent;border-radius:50%;font-family:inherit;line-height:5em;cursor:default;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.swal2-icon .swal2-icon-content{display:flex;align-items:center;font-size:3.75em}.swal2-icon.swal2-error{border-color:#f27474;color:#f27474}.swal2-icon.swal2-error .swal2-x-mark{position:relative;flex-grow:1}.swal2-icon.swal2-error [class^=swal2-x-mark-line]{display:block;position:absolute;top:2.3125em;width:2.9375em;height:.3125em;border-radius:.125em;background-color:#f27474}.swal2-icon.swal2-error [class^=swal2-x-mark-line][class$=left]{left:1.0625em;transform:rotate(45deg)}.swal2-icon.swal2-error [class^=swal2-x-mark-line][class$=right]{right:1em;transform:rotate(-45deg)}.swal2-icon.swal2-error.swal2-icon-show{-webkit-animation:swal2-animate-error-icon .5s;animation:swal2-animate-error-icon .5s}.swal2-icon.swal2-error.swal2-icon-show .swal2-x-mark{-webkit-animation:swal2-animate-error-x-mark .5s;animation:swal2-animate-error-x-mark .5s}.swal2-icon.swal2-warning{border-color:#facea8;color:#f8bb86}.swal2-icon.swal2-info{border-color:#9de0f6;color:#3fc3ee}.swal2-icon.swal2-question{border-color:#c9dae1;color:#87adbd}.swal2-icon.swal2-success{border-color:#a5dc86;color:#a5dc86}.swal2-icon.swal2-success [class^=swal2-success-circular-line]{position:absolute;width:3.75em;height:7.5em;transform:rotate(45deg);border-radius:50%}.swal2-icon.swal2-success [class^=swal2-success-circular-line][class$=left]{top:-.4375em;left:-2.0635em;transform:rotate(-45deg);transform-origin:3.75em 3.75em;border-radius:7.5em 0 0 7.5em}.swal2-icon.swal2-success [class^=swal2-success-circular-line][class$=right]{top:-.6875em;left:1.875em;transform:rotate(-45deg);transform-origin:0 3.75em;border-radius:0 7.5em 7.5em 0}.swal2-icon.swal2-success .swal2-success-ring{position:absolute;z-index:2;top:-.25em;left:-.25em;box-sizing:content-box;width:100%;height:100%;border:.25em solid rgba(165,220,134,.3);border-radius:50%}.swal2-icon.swal2-success .swal2-success-fix{position:absolute;z-index:1;top:.5em;left:1.625em;width:.4375em;height:5.625em;transform:rotate(-45deg)}.swal2-icon.swal2-success [class^=swal2-success-line]{display:block;position:absolute;z-index:2;height:.3125em;border-radius:.125em;background-color:#a5dc86}.swal2-icon.swal2-success [class^=swal2-success-line][class$=tip]{top:2.875em;left:.8125em;width:1.5625em;transform:rotate(45deg)}.swal2-icon.swal2-success [class^=swal2-success-line][class$=long]{top:2.375em;right:.5em;width:2.9375em;transform:rotate(-45deg)}.swal2-icon.swal2-success.swal2-icon-show .swal2-success-line-tip{-webkit-animation:swal2-animate-success-line-tip .75s;animation:swal2-animate-success-line-tip .75s}.swal2-icon.swal2-success.swal2-icon-show .swal2-success-line-long{-webkit-animation:swal2-animate-success-line-long .75s;animation:swal2-animate-success-line-long .75s}.swal2-icon.swal2-success.swal2-icon-show .swal2-success-circular-line-right{-webkit-animation:swal2-rotate-success-circular-line 4.25s ease-in;animation:swal2-rotate-success-circular-line 4.25s ease-in}.swal2-progress-steps{align-items:center;margin:0 0 1.25em;padding:0;background:inherit;font-weight:600}.swal2-progress-steps li{display:inline-block;position:relative}.swal2-progress-steps .swal2-progress-step{z-index:20;width:2em;height:2em;border-radius:2em;background:#3085d6;color:#fff;line-height:2em;text-align:center}.swal2-progress-steps .swal2-progress-step.swal2-active-progress-step{background:#3085d6}.swal2-progress-steps .swal2-progress-step.swal2-active-progress-step~.swal2-progress-step{background:#add8e6;color:#fff}.swal2-progress-steps .swal2-progress-step.swal2-active-progress-step~.swal2-progress-step-line{background:#add8e6}.swal2-progress-steps .swal2-progress-step-line{z-index:10;width:2.5em;height:.4em;margin:0 -1px;background:#3085d6}[class^=swal2]{-webkit-tap-highlight-color:transparent}.swal2-show{-webkit-animation:swal2-show .3s;animation:swal2-show .3s}.swal2-hide{-webkit-animation:swal2-hide .15s forwards;animation:swal2-hide .15s forwards}.swal2-noanimation{transition:none}.swal2-scrollbar-measure{position:absolute;top:-9999px;width:50px;height:50px;overflow:scroll}.swal2-rtl .swal2-close{right:auto;left:0}.swal2-rtl .swal2-timer-progress-bar{right:0;left:auto}@supports (-ms-accelerator:true){.swal2-range input{width:100%!important}.swal2-range output{display:none}}@media all and (-ms-high-contrast:none),(-ms-high-contrast:active){.swal2-range input{width:100%!important}.swal2-range output{display:none}}@-moz-document url-prefix(){.swal2-close:focus{outline:2px solid rgba(50,100,150,.4)}}@-webkit-keyframes swal2-toast-show{0%{transform:translateY(-.625em) rotateZ(2deg)}33%{transform:translateY(0) rotateZ(-2deg)}66%{transform:translateY(.3125em) rotateZ(2deg)}100%{transform:translateY(0) rotateZ(0)}}@keyframes swal2-toast-show{0%{transform:translateY(-.625em) rotateZ(2deg)}33%{transform:translateY(0) rotateZ(-2deg)}66%{transform:translateY(.3125em) rotateZ(2deg)}100%{transform:translateY(0) rotateZ(0)}}@-webkit-keyframes swal2-toast-hide{100%{transform:rotateZ(1deg);opacity:0}}@keyframes swal2-toast-hide{100%{transform:rotateZ(1deg);opacity:0}}@-webkit-keyframes swal2-toast-animate-success-line-tip{0%{top:.5625em;left:.0625em;width:0}54%{top:.125em;left:.125em;width:0}70%{top:.625em;left:-.25em;width:1.625em}84%{top:1.0625em;left:.75em;width:.5em}100%{top:1.125em;left:.1875em;width:.75em}}@keyframes swal2-toast-animate-success-line-tip{0%{top:.5625em;left:.0625em;width:0}54%{top:.125em;left:.125em;width:0}70%{top:.625em;left:-.25em;width:1.625em}84%{top:1.0625em;left:.75em;width:.5em}100%{top:1.125em;left:.1875em;width:.75em}}@-webkit-keyframes swal2-toast-animate-success-line-long{0%{top:1.625em;right:1.375em;width:0}65%{top:1.25em;right:.9375em;width:0}84%{top:.9375em;right:0;width:1.125em}100%{top:.9375em;right:.1875em;width:1.375em}}@keyframes swal2-toast-animate-success-line-long{0%{top:1.625em;right:1.375em;width:0}65%{top:1.25em;right:.9375em;width:0}84%{top:.9375em;right:0;width:1.125em}100%{top:.9375em;right:.1875em;width:1.375em}}@-webkit-keyframes swal2-show{0%{transform:scale(.7)}45%{transform:scale(1.05)}80%{transform:scale(.95)}100%{transform:scale(1)}}@keyframes swal2-show{0%{transform:scale(.7)}45%{transform:scale(1.05)}80%{transform:scale(.95)}100%{transform:scale(1)}}@-webkit-keyframes swal2-hide{0%{transform:scale(1);opacity:1}100%{transform:scale(.5);opacity:0}}@keyframes swal2-hide{0%{transform:scale(1);opacity:1}100%{transform:scale(.5);opacity:0}}@-webkit-keyframes swal2-animate-success-line-tip{0%{top:1.1875em;left:.0625em;width:0}54%{top:1.0625em;left:.125em;width:0}70%{top:2.1875em;left:-.375em;width:3.125em}84%{top:3em;left:1.3125em;width:1.0625em}100%{top:2.8125em;left:.8125em;width:1.5625em}}@keyframes swal2-animate-success-line-tip{0%{top:1.1875em;left:.0625em;width:0}54%{top:1.0625em;left:.125em;width:0}70%{top:2.1875em;left:-.375em;width:3.125em}84%{top:3em;left:1.3125em;width:1.0625em}100%{top:2.8125em;left:.8125em;width:1.5625em}}@-webkit-keyframes swal2-animate-success-line-long{0%{top:3.375em;right:2.875em;width:0}65%{top:3.375em;right:2.875em;width:0}84%{top:2.1875em;right:0;width:3.4375em}100%{top:2.375em;right:.5em;width:2.9375em}}@keyframes swal2-animate-success-line-long{0%{top:3.375em;right:2.875em;width:0}65%{top:3.375em;right:2.875em;width:0}84%{top:2.1875em;right:0;width:3.4375em}100%{top:2.375em;right:.5em;width:2.9375em}}@-webkit-keyframes swal2-rotate-success-circular-line{0%{transform:rotate(-45deg)}5%{transform:rotate(-45deg)}12%{transform:rotate(-405deg)}100%{transform:rotate(-405deg)}}@keyframes swal2-rotate-success-circular-line{0%{transform:rotate(-45deg)}5%{transform:rotate(-45deg)}12%{transform:rotate(-405deg)}100%{transform:rotate(-405deg)}}@-webkit-keyframes swal2-animate-error-x-mark{0%{margin-top:1.625em;transform:scale(.4);opacity:0}50%{margin-top:1.625em;transform:scale(.4);opacity:0}80%{margin-top:-.375em;transform:scale(1.15)}100%{margin-top:0;transform:scale(1);opacity:1}}@keyframes swal2-animate-error-x-mark{0%{margin-top:1.625em;transform:scale(.4);opacity:0}50%{margin-top:1.625em;transform:scale(.4);opacity:0}80%{margin-top:-.375em;transform:scale(1.15)}100%{margin-top:0;transform:scale(1);opacity:1}}@-webkit-keyframes swal2-animate-error-icon{0%{transform:rotateX(100deg);opacity:0}100%{transform:rotateX(0);opacity:1}}@keyframes swal2-animate-error-icon{0%{transform:rotateX(100deg);opacity:0}100%{transform:rotateX(0);opacity:1}}@-webkit-keyframes swal2-rotate-loading{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}@keyframes swal2-rotate-loading{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}body.swal2-shown:not(.swal2-no-backdrop):not(.swal2-toast-shown){overflow:hidden}body.swal2-height-auto{height:auto!important}body.swal2-no-backdrop .swal2-container{top:auto;right:auto;bottom:auto;left:auto;max-width:calc(100% - .625em * 2);background-color:transparent!important}body.swal2-no-backdrop .swal2-container>.swal2-modal{box-shadow:0 0 10px rgba(0,0,0,.4)}body.swal2-no-backdrop .swal2-container.swal2-top{top:0;left:50%;transform:translateX(-50%)}body.swal2-no-backdrop .swal2-container.swal2-top-left,body.swal2-no-backdrop .swal2-container.swal2-top-start{top:0;left:0}body.swal2-no-backdrop .swal2-container.swal2-top-end,body.swal2-no-backdrop .swal2-container.swal2-top-right{top:0;right:0}body.swal2-no-backdrop .swal2-container.swal2-center{top:50%;left:50%;transform:translate(-50%,-50%)}body.swal2-no-backdrop .swal2-container.swal2-center-left,body.swal2-no-backdrop .swal2-container.swal2-center-start{top:50%;left:0;transform:translateY(-50%)}body.swal2-no-backdrop .swal2-container.swal2-center-end,body.swal2-no-backdrop .swal2-container.swal2-center-right{top:50%;right:0;transform:translateY(-50%)}body.swal2-no-backdrop .swal2-container.swal2-bottom{bottom:0;left:50%;transform:translateX(-50%)}body.swal2-no-backdrop .swal2-container.swal2-bottom-left,body.swal2-no-backdrop .swal2-container.swal2-bottom-start{bottom:0;left:0}body.swal2-no-backdrop .swal2-container.swal2-bottom-end,body.swal2-no-backdrop .swal2-container.swal2-bottom-right{right:0;bottom:0}@media print{body.swal2-shown:not(.swal2-no-backdrop):not(.swal2-toast-shown){overflow-y:scroll!important}body.swal2-shown:not(.swal2-no-backdrop):not(.swal2-toast-shown)>[aria-hidden=true]{display:none}body.swal2-shown:not(.swal2-no-backdrop):not(.swal2-toast-shown) .swal2-container{position:static!important}}body.swal2-toast-shown .swal2-container{background-color:transparent}body.swal2-toast-shown .swal2-container.swal2-top{top:0;right:auto;bottom:auto;left:50%;transform:translateX(-50%)}body.swal2-toast-shown .swal2-container.swal2-top-end,body.swal2-toast-shown .swal2-container.swal2-top-right{top:0;right:0;bottom:auto;left:auto}body.swal2-toast-shown .swal2-container.swal2-top-left,body.swal2-toast-shown .swal2-container.swal2-top-start{top:0;right:auto;bottom:auto;left:0}body.swal2-toast-shown .swal2-container.swal2-center-left,body.swal2-toast-shown .swal2-container.swal2-center-start{top:50%;right:auto;bottom:auto;left:0;transform:translateY(-50%)}body.swal2-toast-shown .swal2-container.swal2-center{top:50%;right:auto;bottom:auto;left:50%;transform:translate(-50%,-50%)}body.swal2-toast-shown .swal2-container.swal2-center-end,body.swal2-toast-shown .swal2-container.swal2-center-right{top:50%;right:0;bottom:auto;left:auto;transform:translateY(-50%)}body.swal2-toast-shown .swal2-container.swal2-bottom-left,body.swal2-toast-shown .swal2-container.swal2-bottom-start{top:auto;right:auto;bottom:0;left:0}body.swal2-toast-shown .swal2-container.swal2-bottom{top:auto;right:auto;bottom:0;left:50%;transform:translateX(-50%)}body.swal2-toast-shown .swal2-container.swal2-bottom-end,body.swal2-toast-shown .swal2-container.swal2-bottom-right{top:auto;right:0;bottom:0;left:auto}body.swal2-toast-column .swal2-toast{flex-direction:column;align-items:stretch}body.swal2-toast-column .swal2-toast .swal2-actions{flex:1;align-self:stretch;height:2.2em;margin-top:.3125em}body.swal2-toast-column .swal2-toast .swal2-loading{justify-content:center}body.swal2-toast-column .swal2-toast .swal2-input{height:2em;margin:.3125em auto;font-size:1em}body.swal2-toast-column .swal2-toast .swal2-validation-message{font-size:1em}");

/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "./resources/js/dashboard/bundles/bundleProfile.js":
/*!*********************************************************!*\
  !*** ./resources/js/dashboard/bundles/bundleProfile.js ***!
  \*********************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _main__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../main */ "./resources/js/dashboard/main.js");
/* harmony import */ var _plugins_article_editor_article_editor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../plugins/article-editor/article-editor */ "./resources/plugins/article-editor/article-editor.js");
/* harmony import */ var _plugins_article_editor_article_editor__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_plugins_article_editor_article_editor__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var filepond__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! filepond */ "./node_modules/filepond/dist/filepond.js");
/* harmony import */ var filepond__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(filepond__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var filepond_plugin_file_validate_type__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! filepond-plugin-file-validate-type */ "./node_modules/filepond-plugin-file-validate-type/dist/filepond-plugin-file-validate-type.js");
/* harmony import */ var filepond_plugin_file_validate_type__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(filepond_plugin_file_validate_type__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var filepond_dist_filepond_min_css__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! filepond/dist/filepond.min.css */ "./node_modules/filepond/dist/filepond.min.css");
/* harmony import */ var filepond_dist_filepond_min_css__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(filepond_dist_filepond_min_css__WEBPACK_IMPORTED_MODULE_4__);
//!######################################
//! 				Imports				#
//!######################################



__webpack_require__(/*! ../../../plugins/article-editor/plugins/reorder/reorder */ "./resources/plugins/article-editor/plugins/reorder/reorder.js");



 //!##############################################
//! 			GLOBAL VARIABLES				#
//!##############################################

var bundleId = $("#bundle-title")[0].dataset.bundleId;
var bundleSlug = $("#bundle-title")[0].dataset.bundleSlug;
var namespace = "App\\Models\\Bundle";
var baseUrl = window.location.origin; //!##########################################
//! 			EventListerners				#
//!##########################################

$(".js-editors-toggle").on("change", function () {
  var _this = this;

  var editorToggles = $(".js-editors-toggle");
  var field = {};

  for (var i = 0; i < editorToggles.length; i++) {
    field["".concat(editorToggles[i].dataset.field)] = editorToggles[i].checked ? 1 : 0;
  }

  var fields = JSON.stringify(field);
  axios.patch("/bundle-ajax/".concat(bundleId, "/toggle-editors"), {
    fields: fields
  }).then(function (res) {
    var icon = _this.checked ? "success" : "info";
    var message = _this.checked ? "Ενεργοποιήθηκε" : "Απενεργοποιήθηκε";
    _main__WEBPACK_IMPORTED_MODULE_0__["default"].toastAlert(icon, message);
  })["catch"](function (err) {
    console.log(err);
    _main__WEBPACK_IMPORTED_MODULE_0__["default"].toastAlert("error", "Παρουσιάστηκε κάποιο πρόβλημα ...");
  });
});
$("#remove-cover-btn").on("click", function () {
  var _this2 = this;

  axios.patch("/media/remove-cover", {
    namespace: namespace,
    id: bundleId
  }).then(function (res) {
    var cnt = _this2.parentElement;
    $("#cover-image").addClass("d-none");
    $("#cover-status").removeClass("d-none");
    $("#change-cover-btn").text("Προσθήκη");
    cnt.classList.remove("d-flex");
    cnt.classList.add("d-none");
  })["catch"](function (err) {
    console.log(err);
  });
});
$("#add-users-btn").on("click", function () {
  var pickedUsers = $(".js-remaining-user-checkbox:checked");
  var ids = [];

  for (var i = 0; i < pickedUsers.length; i++) {
    ids.push(pickedUsers[i].dataset.userId);
  }

  addUserBundle(ids);
});
$("#remove-selected-users-btn").on("click", function () {
  var pickUsers = $(".js-active-user-checkbox:checked");
  var ids = [];

  for (var i = 0; i < pickUsers.length; i++) {
    ids.push(pickUsers[i].dataset.userId);
  }

  Swal.fire({
    title: "Είστε σίγουρος/η;",
    text: "\u0397 \u03B5\u03BD\u03AD\u03C1\u03B3\u03B5\u03B9\u03B1 \u03B8\u03B1 \u03B1\u03C6\u03B1\u03B9\u03C1\u03AD\u03C3\u03B5\u03B9 ".concat(i, " \u03B1\u03C0\u03BF \u03C4\u03BF\u03C5\u03C2 \u03C7\u03C1\u03AE\u03C3\u03C4\u03B5\u03C2 \u03C4\u03BF\u03C5 Bundle."),
    icon: 'warning',
    showCancelButton: true,
    confirmButtonColor: '#536de6',
    confirmButtonText: 'Ναι, αφαίρεση!',
    cancelButtonText: 'Άκυρο'
  }).then(function (result) {
    if (result.isConfirmed) {
      removeUsers(ids);
    }
  });
});
$("#remaining-all-users-checkbox").on("click", function () {
  var minorCheckboxes = $(".js-remaining-user-checkbox");
  var bulk = $("#add-users-btn")[0];
  _main__WEBPACK_IMPORTED_MODULE_0__["default"].minorCheckboxSwitcher(this, minorCheckboxes, bulk);
});
$("#main-active-users-checkbox").on("change", function () {
  var minorCheckboxes = $(".js-active-user-checkbox");
  var bulk = $("#users-bulk")[0];
  _main__WEBPACK_IMPORTED_MODULE_0__["default"].minorCheckboxSwitcher(this, minorCheckboxes, bulk);
});
$("#change-cover-btn").on("click", function () {
  $("#gallery-content")[0].dataset.type = "cover";
  $("#gallery-modal").modal('show');
});
$("#image-search").on("input", _main__WEBPACK_IMPORTED_MODULE_0__["default"].searchHandler);
$(".js-gallery-page-btn").on('click', _main__WEBPACK_IMPORTED_MODULE_0__["default"].paginationHandler);
$(".js-add-image").on("click", _main__WEBPACK_IMPORTED_MODULE_0__["default"].imageHandler);
$(".tab-link").on("show.bs.tab", function (event) {
  event.preventDefault();
  Swal.fire('Προσοχή', '<p>Θα πρέπει να αποθηκεύσετε το Bundle</p>για να συνεχίσετε!', 'info');
});
$(".under-development").on('click', function () {
  Swal.fire({
    toast: 'true',
    position: 'top-end',
    icon: "info",
    title: "Under Development...",
    showConfirmButton: false,
    timer: 3000,
    timerProgressBar: true
  });
});
$("#bundle-delete-btn").on("click", function () {
  Swal.fire({
    title: 'Είστε σίγουρος;',
    text: "Η ενέργεια θα είναι μη αναστρέψιμη!",
    icon: 'warning',
    showCancelButton: true,
    confirmButtonColor: '#ff5b5b',
    confirmButtonText: 'Ναι, διαγραφή!',
    cancelButtonText: 'Άκυρο'
  }).then(function (result) {
    if (result.value) {
      $("#delete-bundle-form").submit();
    }
  });
});
var publishDate = $("#publish-date-select").daterangepicker({
  singleDatePicker: true,
  drops: "auto",
  opens: "center",
  timePicker: true,
  autoUpdateInput: false,
  timePicker24Hour: true,
  cancelButtonClasses: "btn-secondary",
  locale: {
    format: "DD-MM-YYYY H:mm"
  }
});
publishDate.on("apply.daterangepicker", function (event, picker) {
  var startDate = picker.startDate.format('DD-MM-YYYY H:mm');
  this.value = startDate;
});
publishDate.on('cancel.daterangepicker', function (event, picker) {
  this.value = "";
});
$('#main-active-courses-checkbox').on("click", function () {
  var checkboxes = $('.js-course-checkbox');
  var bulkBtn = $("#courses-bulk")[0];
  _main__WEBPACK_IMPORTED_MODULE_0__["default"].minorCheckboxSwitcher(this, checkboxes, bulkBtn);
});
$('#all-courses-checkbox').on("change", function () {
  var checkboxes = $('.js-remainings-checkbox');
  var bulkBtn = $("#add-courses-btn")[0];
  _main__WEBPACK_IMPORTED_MODULE_0__["default"].minorCheckboxSwitcher(this, checkboxes, bulkBtn);
});
$('#add-courses-btn').on("click", function () {
  var checkboxes = $('.js-remainings-checkbox:checked');
  var ids = [];

  if (checkboxes.length == 0) {
    _main__WEBPACK_IMPORTED_MODULE_0__["default"].toastAlert('info', "Δεν υπάρχουν επιλεγμένα μαθήματα...");
    return;
  } else {
    for (var i = 0; i < checkboxes.length; i++) {
      ids.push(checkboxes[i].dataset.courseId);
    }

    postCourseIds(ids);
    $("#remaining-courses-modal").modal("hide");
  }
});
$('#remove-selected-courses-btn').on("click", function () {
  var checkboxes = $('.js-course-checkbox:checked');
  var ids = [];

  if (checkboxes.length == 0) {
    _main__WEBPACK_IMPORTED_MODULE_0__["default"].toastAlert('info', "Δεν υπάρχουν επιλεγμένα μαθήματα...");
    return;
  } else {
    for (var i = 0; i < checkboxes.length; i++) {
      ids.push(checkboxes[i].dataset.courseId);
    }

    Swal.fire({
      title: "Είστε σίγουρος/η;",
      html: "<p class=\"mb-0\">\u0397 \u03B5\u03BD\u03AD\u03C1\u03B3\u03B5\u03B9\u03B1 \u03B8\u03B1 \u03B1\u03C6\u03B1\u03B9\u03C1\u03AD\u03C3\u03B5\u03B9 ".concat(i, " Course(s)</p>\u03B1\u03C0\u03BF \u03C4\u03BF Bundle."),
      icon: 'warning',
      showCancelButton: true,
      confirmButtonColor: '#536de6',
      confirmButtonText: 'Ναι, αφαίρεση!',
      cancelButtonText: 'Άκυρο'
    }).then(function (result) {
      if (result.isConfirmed) {
        removeCourses(ids);
      }
    });
  }
}); //! EventListerners /end
//! Datatables

var bundleCoursesTable = $("#bundle-courses-list").DataTable({
  order: [3, "desc"],
  searchDelay: "1000",
  processing: true,
  serverSide: true,
  ajax: {
    url: "/bundle-datatables/bundle-courses",
    headers: {
      'X-CSRF-TOKEN': $('meta[name="csrf-token"]').attr('content')
    },
    type: "post",
    data: function data(d) {
      return $.extend({}, d, {
        bundleId: bundleId,
        startDate: _main__WEBPACK_IMPORTED_MODULE_0__["default"].startDate($("#bundle-course-date-range")[0]),
        endDate: _main__WEBPACK_IMPORTED_MODULE_0__["default"].endDate($("#bundle-course-date-range")[0])
      });
    }
  },
  columns: [{
    data: 'action',
    name: 'action',
    className: "align-middle text-center",
    orderable: false,
    width: "5%"
  }, {
    data: 'title',
    name: 'title',
    className: "align-middle cursor-default"
  }, {
    data: 'curator',
    name: 'curator',
    className: "align-middle cursor-default"
  }, {
    data: 'topics',
    name: 'topics',
    className: "align-middle cursor-default"
  }, {
    data: 'version',
    name: 'version',
    className: "align-middle text-center cursor-default"
  }, {
    data: 'updated_at',
    name: 'updated_at',
    className: "align-middle text-center cursor-default",
    render: function render(data) {
      var date = new Date(data);
      var day = date.toLocaleDateString().replace(/[/]/g, "-");
      var hours = "".concat(date.getHours()).padStart(2, "0");
      var minutes = "".concat(date.getMinutes()).padStart(2, "0");
      var time = "".concat(hours, ":").concat(minutes);
      return "<p class=\"mb-0\">".concat(day, "</p><p class=\"mb-0\">").concat(time, "</p>");
    }
  }, {
    data: 'created_at',
    name: 'created_at',
    className: "align-middle text-center cursor-default",
    render: function render(data) {
      var date = new Date(data);
      var day = date.toLocaleDateString().replace(/[/]/g, "-");
      var hours = "".concat(date.getHours()).padStart(2, "0");
      var minutes = "".concat(date.getMinutes()).padStart(2, "0");
      var time = "".concat(hours, ":").concat(minutes);
      return "<p class=\"mb-0\">".concat(day, "</p><p class=\"mb-0\">").concat(time, "</p>");
    }
  }, {
    data: 'btns',
    className: "align-middle text-center",
    searchable: false,
    orderable: false
  }],
  language: _main__WEBPACK_IMPORTED_MODULE_0__["default"].tableLocale,
  fnInitComplete: function fnInitComplete(oSettings, json) {
    var lenthSelection = $("select[name='bundle-courses-list_length']");
    lenthSelection.addClass("select2");
    lenthSelection.select2({
      minimumResultsForSearch: -1
    });
  },
  drawCallback: function drawCallback() {
    $(".dataTables_paginate > .pagination").addClass("pagination-rounded");
    $(".dataTables_wrapper > .row:first-child > div").removeClass("col-sm-12 col-md-6");
    $(".dataTables_wrapper > .row:first-child > div").addClass("col-lg-12 col-xl-6 d-md-flex justify-content-md-center d-xl-block");
    $(".js-remove-table-classes > thead > tr > th").removeClass("cursor-default");
    activeCoursesCheckboxToggle();
    removeCourseBtnInit();
    _main__WEBPACK_IMPORTED_MODULE_0__["default"].resetBulk($("#courses-bulk"), $("#main-active-courses-checkbox"));
  }
}); //!##########################################
//!				Datatable filters			#
//!##########################################
//* Append Course Materials Date Picker Filter

var bundleCourseSearchInput = $("#bundle-courses-list_filter > label > input")[0];
var bundleCourseDateInput = _main__WEBPACK_IMPORTED_MODULE_0__["default"].createDateElm("bundle-course-date-range");
bundleCourseDateInput.appendBefore(bundleCourseSearchInput); //* Topic Filter

var courseLengthElm = $("#bundle-courses-list_length > label")[0];
var topicFIlter = $("#topic-filter")[0];
courseLengthElm.append(topicFIlter);
$("#topic-filter").select2({});
$("#topic-filter").on("change", function () {
  var label = $("#select2-topic-filter-container")[0];
  _main__WEBPACK_IMPORTED_MODULE_0__["default"].filterStyle(label, this.value);
  bundleCoursesTable.column(3).search(this.value).draw();
}); //* Course type filter

var activeCoursesType = _main__WEBPACK_IMPORTED_MODULE_0__["default"].createCourseTypeSelect("active-course-type-slt");
courseLengthElm.append(activeCoursesType);
$("#active-course-type-slt").select2({
  minimumResultsForSearch: -1
});
$("#active-course-type-slt").on("change", function () {
  var label = $("#select2-active-course-type-slt-container")[0];
  _main__WEBPACK_IMPORTED_MODULE_0__["default"].filterStyle(label, this.value);
  bundleCoursesTable.column(4).search(this.value).draw();
}); //! Event Initializers!

function removeCourseBtnInit() {
  $(".js-remove-course").on("click", function () {
    var id = this.dataset.courseId;
    Swal.fire({
      title: "Είστε σίγουρος/η;",
      text: "\u0397 \u03B5\u03BD\u03AD\u03C1\u03B3\u03B5\u03B9\u03B1 \u03B8\u03B1 \u03B1\u03C6\u03B1\u03B9\u03C1\u03AD\u03C3\u03B5\u03B9 \u03AD\u03BD\u03B1 \u03B1\u03C0\u03BF \u03C4\u03B1 Courses.",
      icon: 'warning',
      showCancelButton: true,
      confirmButtonColor: '#536de6',
      confirmButtonText: 'Ναι, αφαίρεση!',
      cancelButtonText: 'Άκυρο'
    }).then(function (result) {
      if (result.isConfirmed) {
        removeCourses([id]);
      }
    });
  });
}

function activeCoursesCheckboxToggle() {
  var mainCheckbox = $('#main-active-courses-checkbox')[0];
  var minorCheckbox = $('.js-course-checkbox');
  var bulkBtn = $("#courses-bulk")[0];
  minorCheckbox.unbind();
  minorCheckbox.on("change", function () {
    _main__WEBPACK_IMPORTED_MODULE_0__["default"].mainCheckboxSwitcher(mainCheckbox, minorCheckbox, bulkBtn);
  });
}

var bundleUsersTable = $("#bundle-users-table").DataTable({
  order: [1, "asc"],
  searchDelay: "1000",
  processing: true,
  serverSide: true,
  ajax: {
    url: "/bundle-datatables/bundle-users",
    headers: {
      'X-CSRF-TOKEN': $('meta[name="csrf-token"]').attr('content')
    },
    type: "post",
    data: {
      id: bundleId
    }
  },
  columns: [{
    data: 'action',
    name: 'action',
    orderable: false,
    searchable: false,
    className: "align-middle text-center"
  }, {
    data: 'last_name',
    name: 'last_name',
    className: "align-middle cursor-default"
  }, {
    data: 'email',
    name: 'email',
    className: "align-middle text-center cursor-default"
  }, {
    data: 'phone',
    name: 'phone',
    className: "align-middle text-center cursor-default"
  }, {
    data: 'btn',
    name: 'btn',
    orderable: false,
    searchable: false,
    className: "align-middle text-center"
  }],
  language: _main__WEBPACK_IMPORTED_MODULE_0__["default"].tableLocale,
  drawCallback: function drawCallback() {
    $(".dataTables_paginate > .pagination").addClass("pagination-rounded");
    $(".dataTables_wrapper > .row:first-child > div").removeClass("col-sm-12 col-md-6");
    $(".dataTables_wrapper > .row:first-child > div").addClass("col-lg-12 col-xl-6 d-md-flex justify-content-md-center d-xl-block");
    _main__WEBPACK_IMPORTED_MODULE_0__["default"].resetBulk($("#users-bulk"), $("#main-active-users-checkbox"));
    activeUsersCheckboxesInit();
    removeUserBinInit();
  }
}); //* Table eventlisteners init

function removeUserBinInit() {
  var bin = $(".js-remove-user");
  bin.off();
  bin.on("click", function () {
    var _this3 = this;

    Swal.fire({
      title: 'Είστε σίγουρος/η;',
      html: "<p class=\"mb-0\">\u0397 \u03B5\u03BD\u03AD\u03C1\u03B3\u03B5\u03B9\u03B1 \u03B8\u03B1 \u03B1\u03C6\u03B1\u03B9\u03C1\u03AD\u03C3\u03B5\u03B9 \u03AD\u03BD\u03B1\u03BD \u03B1\u03C0\u03BF</p>\u03C4\u03BF\u03C5\u03C2 \u03C7\u03C1\u03AE\u03C3\u03C4\u03B5\u03C2 \u03C4\u03BF\u03C5 Bundle.",
      icon: 'warning',
      showCancelButton: true,
      confirmButtonColor: '#536de6',
      confirmButtonText: 'Ναι, αφαίρεση!',
      cancelButtonText: 'Άκυρο'
    }).then(function (result) {
      if (result.value) {
        removeUsers([_this3.dataset.userId]);
      }
    });
  });
}

function activeUsersCheckboxesInit() {
  var minorCheckboxes = $(".js-active-user-checkbox");
  var mainCheckbox = $("#main-active-users-checkbox")[0];
  var bulk = $("#users-bulk")[0];
  minorCheckboxes.off();
  minorCheckboxes.on("change", function () {
    _main__WEBPACK_IMPORTED_MODULE_0__["default"].mainCheckboxSwitcher(mainCheckbox, minorCheckboxes, bulk);
  });
}

var remainingCoursesTable = $("#remaining-courses-table").DataTable({
  order: [1, "asc"],
  searchDelay: "1000",
  processing: true,
  serverSide: true,
  ajax: {
    url: "/bundle-datatables/courses",
    headers: {
      'X-CSRF-TOKEN': $('meta[name="csrf-token"]').attr('content')
    },
    type: "post",
    data: {
      bundleId: bundleId
    }
  },
  columns: [{
    data: 'action',
    name: 'action',
    orderable: false,
    searchable: false,
    className: "align-middle text-center"
  }, {
    data: 'title',
    name: 'title',
    className: "cursor-default"
  }, {
    data: 'curator',
    name: 'curator',
    className: "align-middle text-center cursor-default"
  }, {
    data: 'topics',
    name: 'topics',
    className: "align-middle cursor-default"
  }, {
    data: 'version',
    name: 'version',
    className: "align-middle text-center cursor-default"
  }, {
    data: 'addBtn',
    name: 'addBtn',
    orderable: false,
    searchable: false,
    className: "align-middle text-center"
  }],
  language: _main__WEBPACK_IMPORTED_MODULE_0__["default"].tableLocale,
  fnInitComplete: function fnInitComplete(oSettings, json) {
    var lenthSelection = $("select[name='remaining-courses-table_length']");
    lenthSelection.addClass("select2");
    lenthSelection.select2({
      minimumResultsForSearch: -1
    });
  },
  drawCallback: function drawCallback() {
    $(".dataTables_paginate > .pagination").addClass("pagination-rounded");
    $(".dataTables_wrapper > .row:first-child > div").removeClass("col-sm-12 col-md-6");
    $(".dataTables_wrapper > .row:first-child > div").addClass("col-lg-12 col-xl-6 d-md-flex justify-content-md-center d-xl-block");
    $(".js-remove-table-classes > thead > tr > th").removeClass("cursor-pointer");
    $(".js-remove-table-classes > tfoot > tr > th").removeClass("cursor-pointer");
    addcourse();
    remainingsCheckboxes();
    _main__WEBPACK_IMPORTED_MODULE_0__["default"].resetAddButton($("#add-courses-btn"), $("#all-courses-checkbox"));
  }
}); //! DataTables /end
//! DataTables function / EventListener

function addcourse() {
  $('.js-add-course-btn').on("click", function () {
    $('.js-add-course-btn').prop("disabled", true);
    var courseId = [this.dataset.courseId];
    postCourseIds(courseId);
  });
}

function remainingsCheckboxes() {
  var mainCheckbox = $('#all-courses-checkbox')[0];
  var minorCheckbox = $('.js-remainings-checkbox');
  var bulkBtn = $("#add-courses-btn")[0];
  minorCheckbox.unbind();
  minorCheckbox.on("change", function () {
    _main__WEBPACK_IMPORTED_MODULE_0__["default"].mainCheckboxSwitcher(mainCheckbox, minorCheckbox, bulkBtn);
  });
} // DataTables function / EventListener End
//!##################################################
//!					Add Courses Filters				#
//!##################################################
//* Topic Filter


var remainingCoursesLength = $("#remaining-courses-table_length > label")[0];
var addCourseTopicFilter = $("#add-course-topic-filter")[0];
remainingCoursesLength.append(addCourseTopicFilter);
$("#add-course-topic-filter").select2({});
$("#add-course-topic-filter").on("change", function () {
  var label = $("#select2-add-course-topic-filter-container")[0];
  _main__WEBPACK_IMPORTED_MODULE_0__["default"].filterStyle(label, this.value);
  remainingCoursesTable.column(3).search(this.value).draw();
}); //* Course type filter

var addCoursesTypesFilter = _main__WEBPACK_IMPORTED_MODULE_0__["default"].createCourseTypeSelect("add-courses-type-filter");
remainingCoursesLength.append(addCoursesTypesFilter), $("#add-courses-type-filter").select2({
  minimumResultsForSearch: -1
});
$("#add-courses-type-filter").on("change", function () {
  var label = $("#select2-add-courses-type-filter-container")[0];
  _main__WEBPACK_IMPORTED_MODULE_0__["default"].filterStyle(label, this.value);
  remainingCoursesTable.column(4).search(this.value).draw();
});

function postCourseIds(courseIds) {
  axios.patch("/bundle-ajax/".concat(bundleId, "/add-courses"), {
    courseIds: courseIds
  }).then(function (res) {
    var message = courseIds.length == 1 ? "1 Course προστέθηκε" : "".concat(courseIds.length, " Course \u03C0\u03C1\u03BF\u03C3\u03C4\u03AD\u03B8\u03B7\u03BA\u03B1\u03BD");
    bundleCoursesTable.ajax.reload();
    remainingCoursesTable.ajax.reload();
    _main__WEBPACK_IMPORTED_MODULE_0__["default"].toastAlert('success', message);
  })["catch"](function (err) {
    console.log(err);
    _main__WEBPACK_IMPORTED_MODULE_0__["default"].toastAlert('error', "Παρουσιάστηκε κάποιο πρόβλημα ...");
  });
}

function removeCourses(courseIds) {
  axios.patch("/bundle-ajax/".concat(bundleId, "/remove-courses"), {
    courseIds: courseIds
  }).then(function (res) {
    var message = courseIds.length == 1 ? "1 Course Αφαιρέθηκε" : "".concat(courseIds.length, " Course \u03B1\u03C6\u03B1\u03B9\u03C1\u03AD\u03B8\u03B7\u03BA\u03B1\u03BD");
    _main__WEBPACK_IMPORTED_MODULE_0__["default"].toastAlert('info', message);
    bundleCoursesTable.ajax.reload();
    remainingCoursesTable.ajax.reload();
    _main__WEBPACK_IMPORTED_MODULE_0__["default"].resetBulk($("#courses-bulk"), $("#main-active-courses-checkbox"));
  })["catch"](function (err) {
    _main__WEBPACK_IMPORTED_MODULE_0__["default"].toastAlert('error', "Παρουσιάστηκε κάποιο πρόβλημα ...");
  });
}

function removeUsers(users) {
  axios.post("/bundle-ajax/".concat(bundleId, "/remove-users"), {
    users: users
  }).then(function (res) {
    var count = users.length;
    var message = count == 1 ? "\u039F \u03C7\u03C1\u03AE\u03C3\u03C4\u03B7\u03C2 \u03B1\u03C6\u03B1\u03B9\u03C1\u03AD\u03B8\u03B7\u03BA\u03B5..." : "".concat(count, " \u03C7\u03C1\u03AE\u03C3\u03C4\u03B5\u03C2 \u03B1\u03C6\u03B1\u03B9\u03C1\u03AD\u03B8\u03B7\u03BA\u03B1\u03BD...");
    _main__WEBPACK_IMPORTED_MODULE_0__["default"].toastAlert("info", message);
    bundleUsersTable.ajax.reload();
    remainingUsersTable.ajax.reload();
  })["catch"](function (err) {
    _main__WEBPACK_IMPORTED_MODULE_0__["default"].toastAlert('error', "Παρουσιάστηκε κάποιο πρόβλημα ...");
  });
}

var remainingUsersTable = $("#remaining-users-table").DataTable({
  order: [1, "asc"],
  searchDelay: "1000",
  processing: true,
  serverSide: true,
  ajax: {
    url: "/bundle-datatables/users",
    headers: {
      'X-CSRF-TOKEN': $('meta[name="csrf-token"]').attr('content')
    },
    type: "post",
    data: {
      bundleId: bundleId
    }
  },
  columns: [{
    data: 'action',
    name: 'action',
    orderable: false,
    searchable: false,
    className: "align-middle text-center"
  }, {
    data: 'last_name',
    name: 'last_name',
    className: "align-middle cursor-default"
  }, {
    data: 'email',
    name: 'email',
    className: "align-middle text-center cursor-default"
  }, {
    data: 'phone',
    name: 'phone',
    className: "align-middle text-center cursor-default"
  }, {
    data: 'btn',
    name: 'btn',
    orderable: false,
    searchable: false,
    className: "align-middle text-center"
  }],
  language: _main__WEBPACK_IMPORTED_MODULE_0__["default"].tableLocale,
  drawCallback: function drawCallback() {
    $(".dataTables_paginate > .pagination").addClass("pagination-rounded");
    $(".dataTables_wrapper > .row:first-child > div").removeClass("col-sm-12 col-md-6");
    $(".dataTables_wrapper > .row:first-child > div").addClass("col-lg-12 col-xl-6 d-md-flex justify-content-md-center d-xl-block");
    addUserBtnInit();
    minorUsersCheckboxInit();
    _main__WEBPACK_IMPORTED_MODULE_0__["default"].resetAddButton($("#add-users-btn"), $("#remaining-all-users-checkbox"));
  }
});

function addUserBtnInit() {
  var addBtn = $(".js-add-user-btn");
  addBtn.on("click", function () {
    addBtn.prop("disabled", true);
    addUserBundle([this.dataset.userId]);
  });
}

function minorUsersCheckboxInit() {
  var main = $("#remaining-all-users-checkbox")[0];
  var minors = $(".js-remaining-user-checkbox");
  var bulk = $("#add-users-btn")[0];
  minors.off();
  minors.on("change", function () {
    _main__WEBPACK_IMPORTED_MODULE_0__["default"].mainCheckboxSwitcher(main, minors, bulk);
  });
}

function addUserBundle(users) {
  axios.post("/bundle-ajax/".concat(bundleId, "/add-users"), {
    users: users
  }).then(function (res) {
    var count = users.length;
    var message = count == 1 ? "Ένας χρήστης προστέθηκε." : "".concat(count, " \u03C7\u03C1\u03AE\u03C3\u03C4\u03B5\u03C2 \u03C0\u03C1\u03BF\u03C3\u03C4\u03AD\u03B8\u03B7\u03BA\u03B1\u03BD.");
    remainingUsersTable.ajax.reload();
    bundleUsersTable.ajax.reload();
    _main__WEBPACK_IMPORTED_MODULE_0__["default"].toastAlert("success", message);

    if (count > 1) {
      $("#add-users").modal("hide");
    }
  })["catch"](function (err) {
    _main__WEBPACK_IMPORTED_MODULE_0__["default"].toastAlert('error', "Παρουσιάστηκε κάποιο πρόβλημα ...");
  });
} //!##########################################
//!				Initializations				#
//!##########################################
//* Date Search


var dateRange = $(".js-date-search");
dateRange.daterangepicker(_main__WEBPACK_IMPORTED_MODULE_0__["default"].datePickerConfig);
dateRange.on("apply.daterangepicker", function (event, picker) {
  var startDate = picker.startDate.format('DD/MM/YYYY');
  var endDate = picker.endDate.format('DD/MM/YYYY');
  this.value = "".concat(startDate, " - ").concat(endDate);
  this.classList.add("select2-selected");
  var tableId = $(this).closest(".table-cnt").find(".js-table").attr("id");
  $("#".concat(tableId)).DataTable().ajax.reload();
});
dateRange.on('cancel.daterangepicker', function (event, picker) {
  this.value = "";
  this.classList.remove("select2-selected");
  var tableId = $(this).closest(".table-cnt").find(".js-table").attr("id");
  $("#".concat(tableId)).DataTable().ajax.reload();
});
dateRange.on("input", function () {
  this.value = this.value.replace(/[^0-9]/g, "").replace(/^(\d{2})?(\d{2})?(\d{4})?(\d{2})?(\d{2})?(\d{4})?/g, '$1/$2/$3 - $4/$5/$6').substr(0, 23);
});
$R.add('plugin', 'mediaLibrary', {
  translations: {
    en: {
      "mediaLibrary": "Media Library"
    }
  },
  init: function init(app) {
    this.app = app;
    this.lang = app.lang;
    this.toolbar = app.toolbar;
  },
  start: function start() {
    var buttonData = {
      title: this.lang.get("mediaLibrary"),
      icon: "<i class='mdi mdi-book-open-page-variant'></i>",
      api: "plugin.mediaLibrary.toggle"
    };
    var $button = this.toolbar.addButton("mediaLibrary", buttonData);
  },
  toggle: function toggle() {
    $('#gallery-content')[0].dataset.editorId = "#summary";
    $('#gallery-content')[0].dataset.type = "redactor";
    $('#gallery-modal').modal('show');
  }
});
$R("#summary", {
  buttons: ['html', 'undo', 'redo', 'format', 'bold', 'underline', 'italic', 'deleted', 'sup', 'sub', 'lists', 'file', 'link', 'image'],
  buttonsAddBefore: {
    before: 'image',
    buttons: ['mediaLibrary']
  },
  style: false,
  plugins: ["mediaLibrary", 'alignment'],
  minHeight: '150px',
  imageResizable: true,
  imagePosition: {
    "left": "image-left",
    "right": "image-right",
    "center": "image-center text-center"
  },
  imageFloatMargin: '20px',
  imageUpload: "/media/upload-images",
  // imageData: {
  // 	id: bundleId,
  // 	namespace: "App\\Bundle"
  // },
  callbacks: {
    upload: {
      beforeSend: function beforeSend(xhr) {
        xhr.setRequestHeader('X-CSRF-Token', $('meta[name="csrf-token"]').attr('content'));
      }
    }
  }
});
_plugins_article_editor_article_editor__WEBPACK_IMPORTED_MODULE_1___default.a.add('plugin', 'mediaLibrary', {
  start: function start() {
    this.app.addbar.add('mediaButton', {
      title: 'Media Library',
      icon: "<i class='mdi mdi-book-open-page-variant'></i>'",
      command: 'mediaLibrary.modal'
    });
  },
  modal: function modal(params, button) {
    this.app.popup.close();
    $('#gallery-content')[0].dataset.editorId = "#description";
    $('#gallery-content')[0].dataset.type = "article";
    $('#gallery-modal').modal('show');
  }
});
_plugins_article_editor_article_editor__WEBPACK_IMPORTED_MODULE_1___default()('#description', {
  css: "/css/",
  custom: {
    css: ["/css/bootstrap.min.css", "/css/customArticleStyle.css"]
  },
  plugins: ['mediaLibrary', 'reorder'],
  classes: {
    img: 'img-fluid',
    p: 'text-wrap'
  },
  grid: {
    classname: 'row',
    columns: 12,
    gutter: '1px',
    offset: {
      left: '15px',
      right: '15px'
    },
    patterns: {
      '6|6': 'col-6|col-6',
      '4|4|4': 'col-4|col-4|col-4',
      '3|3|3|3': 'col-3|col-3|col-3|col-3',
      '2|2|2|2|2|2': 'col-2|col-2|col-2|col-2|col-2|col-2',
      '3|6|3': 'col-3|col-6|col-3',
      '2|8|2': 'col-2|col-8|col-2',
      '5|7': 'col-5|col-7',
      '7|5': 'col-7|col-5',
      '4|8': 'col-4|col-8',
      '8|4': 'col-8|col-4',
      '3|9': 'col-3|col-9',
      '9|3': 'col-9|col-3',
      '2|10': 'col-2|col-10',
      '10|2': 'col-10|col-2',
      '12': 'col-12'
    }
  },
  align: {
    left: "text-left",
    center: "text-center",
    right: "text-right"
  },
  editor: {
    minHeight: "300px"
  },
  image: {
    upload: "/media/upload-images",
    data: {
      "_token": $('meta[name="csrf-token"]').attr('content') // "id": bundleId,
      // namespace: "App\\Bundle"

    }
  }
});
var dropzone = document.getElementById("file-pond");
filepond__WEBPACK_IMPORTED_MODULE_2__["registerPlugin"](filepond_plugin_file_validate_type__WEBPACK_IMPORTED_MODULE_3___default.a);
var pond = filepond__WEBPACK_IMPORTED_MODULE_2__["create"](dropzone, {
  name: 'file[]',
  labelIdle: "Drag & Drop your files or Browse",
  server: {
    url: baseUrl,
    process: {
      url: '/media/upload-images',
      headers: {
        "X-CSRF-TOKEN": $('meta[name="csrf-token"]').attr('content')
      }
    }
  },
  onprocessfiles: function onprocessfiles() {
    _main__WEBPACK_IMPORTED_MODULE_0__["default"].paginationRequest(1, "");
  },
  allowMultiple: true,
  allowRemove: true,
  allowRevert: false,
  acceptedFileTypes: ['image/png', 'image/jpeg'],
  className: "js-filepond-file-dragging"
});
var dropArea = document.getElementsByClassName("js-filepond-file-dragging");

for (var i = 0; i < dropArea.length; i++) {
  dropArea[i].addEventListener("dragover", function (event) {
    var draggingArea = this.getElementsByClassName("filepond--drop-label")[0];
    var label = draggingArea.querySelector("label");
    draggingArea.classList.add("limegreen");
    label.classList.add("text-limegreen");
  });
  dropArea[i].addEventListener("dragleave", function (event) {
    var draggingArea = this.getElementsByClassName("filepond--drop-label")[0];
    var label = draggingArea.querySelector("label");
    draggingArea.classList.remove("limegreen");
    label.classList.remove("text-limegreen");
  });
  dropArea[i].addEventListener("mouseleave", function (event) {
    var draggingArea = this.getElementsByClassName("filepond--drop-label")[0];
    var label = draggingArea.querySelector("label");
    draggingArea.classList.remove("limegreen");
    label.classList.remove("text-limegreen");
  });
}

/***/ }),

/***/ "./resources/js/dashboard/main.js":
/*!****************************************!*\
  !*** ./resources/js/dashboard/main.js ***!
  \****************************************/
/*! exports provided: ALLOWEDTYPES, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ALLOWEDTYPES", function() { return ALLOWEDTYPES; });
/* harmony import */ var sweetalert2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! sweetalert2 */ "./node_modules/sweetalert2/dist/sweetalert2.all.js");
/* harmony import */ var sweetalert2__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(sweetalert2__WEBPACK_IMPORTED_MODULE_0__);

Element.prototype.findParent = function (loops) {
  var parent = this;

  for (var i = 0; i < loops; i++) {
    parent = parent.parentElement;
  }

  return parent;
}, false;
Element.prototype.appendBefore = function (element) {
  element.parentNode.insertBefore(this, element);
}, false;
Element.prototype.appendAfter = function (element) {
  element.parentNode.insertBefore(this, element.nextSibling);
}, false; //!##########################################
//!				Global Variables		F	#
//!##########################################

var baseUrl = window.location.origin;
var timer = 0;
var ALLOWEDTYPES = ["application/octet-stream", "application/x-zip-compressed", "application/pdf", "application/msword", "application/vnd.openxmlformats-officedocument.wordprocessingml.document", "application/vnd.openxmlformats-officedocument.wordprocessingml.template", "application/vnd.ms-word.document.macroEnabled.12", "application/vnd.ms-word.template.macroEnabled.12", "application/vnd.ms-excel", "application/vnd.ms-excel", "application/vnd.ms-excel", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet", "application/vnd.openxmlformats-officedocument.spreadsheetml.template", "application/vnd.ms-excel.sheet.macroEnabled.12", "application/vnd.ms-excel.template.macroEnabled.12", "application/vnd.ms-excel.addin.macroEnabled.12", "application/vnd.ms-excel.sheet.binary.macroEnabled.12", "application/vnd.ms-powerpoint", "application/vnd.openxmlformats-officedocument.presentationml.presentation", "application/vnd.openxmlformats-officedocument.presentationml.template", "application/vnd.openxmlformats-officedocument.presentationml.slideshow", "application/vnd.ms-powerpoint.addin.macroEnabled.12", "application/vnd.ms-powerpoint.presentation.macroEnabled.12", "application/vnd.ms-powerpoint.template.macroEnabled.12", "application/vnd.ms-powerpoint.slideshow.macroEnabled.12", "application/vnd.ms-access", "audio/mpeg", "application/vnd.oasis.opendocument.presentation", "application/vnd.oasis.opendocument.spreadsheet", "application/vnd.oasis.opendocument.text", "application/rtf", "application/vnd.oasis.opendocument.graphics", "text/html"]; //!##########################################
//!				Configurations				#
//!##########################################
//!ALERT
//!============================================================

function toastAlert(icon, message) {
  sweetalert2__WEBPACK_IMPORTED_MODULE_0___default.a.fire({
    toast: 'true',
    position: 'top-end',
    icon: icon,
    title: message,
    showConfirmButton: false,
    timer: 3000,
    timerProgressBar: true
  });
}

function toastAlertDelete(text) {
  var icon = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "warning";
  return sweetalert2__WEBPACK_IMPORTED_MODULE_0___default.a.fire({
    title: 'Είστε σίγουρος/η;',
    text: text,
    icon: icon,
    showCancelButton: true,
    confirmButtonColor: '#ff5b5b',
    confirmButtonText: 'Ναί, διαγραφή!',
    cancelButtonText: 'Άκυρο'
  });
}

function removeAlert(text) {
  var icon = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "warning";
  return sweetalert2__WEBPACK_IMPORTED_MODULE_0___default.a.fire({
    title: 'Είστε σίγουρος/η;',
    text: text,
    icon: icon,
    showCancelButton: true,
    confirmButtonColor: '#536de6',
    confirmButtonText: 'Ναί, αφαίρεση!',
    cancelButtonText: 'Άκυρο'
  });
} //!CONFIG
//!============================================================


var articleConfig = {
  css: "/css/",
  custom: {
    css: ["/css/bootstrap.min.css", "/css/customArticleStyle.css"]
  },
  // plugins: ['mediaLibrary', 'reorder'],
  classes: {
    img: 'img-fluid',
    p: 'text-wrap'
  },
  grid: {
    classname: 'row',
    columns: 12,
    gutter: '1px',
    offset: {
      left: '15px',
      right: '15px'
    },
    patterns: {
      '6|6': 'col-6|col-6',
      '4|4|4': 'col-4|col-4|col-4',
      '3|3|3|3': 'col-3|col-3|col-3|col-3',
      '2|2|2|2|2|2': 'col-2|col-2|col-2|col-2|col-2|col-2',
      '3|6|3': 'col-3|col-6|col-3',
      '2|8|2': 'col-2|col-8|col-2',
      '5|7': 'col-5|col-7',
      '7|5': 'col-7|col-5',
      '4|8': 'col-4|col-8',
      '8|4': 'col-8|col-4',
      '3|9': 'col-3|col-9',
      '9|3': 'col-9|col-3',
      '2|10': 'col-2|col-10',
      '10|2': 'col-10|col-2',
      '12': 'col-12'
    }
  },
  align: {
    left: "text-left",
    center: "text-center",
    right: "text-right"
  },
  editor: {
    minHeight: "300px"
  },
  image: {
    upload: "/media/upload-images",
    data: {
      "_token": $('meta[name="csrf-token"]').attr('content')
    }
  }
};
var redactorConfig = {
  buttons: ['html', 'undo', 'redo', 'format', 'bold', 'underline', 'italic', 'deleted', 'sup', 'sub', 'lists', 'file', 'link', 'image'],
  style: false,
  plugins: ['alignment'],
  minHeight: '150px'
};
var datePickerConfig = {
  ranges: {
    'Today': [moment(), moment()],
    'Yesterday': [moment().subtract(1, 'days'), moment().subtract(1, 'days')],
    'Last 7 Days': [moment().subtract(6, 'days'), moment()],
    'Last 30 Days': [moment().subtract(29, 'days'), moment()],
    'This Month': [moment().startOf('month'), moment().endOf('month')],
    'Last Month': [moment().subtract(1, 'month').startOf('month'), moment().subtract(1, 'month').endOf('month')],
    'This Year': [moment().startOf('year'), moment().endOf('year')],
    'Last Year': [moment().subtract(1, 'year').startOf('year'), moment().subtract(1, 'year').endOf('year')]
  },
  alwaysShowCalendars: true,
  showCustomRangeLabel: false,
  drops: "auto",
  autoUpdateInput: false,
  opens: "center",
  locale: {
    format: "DD/MM/YYYY"
  }
};
var tableLocale = {
  emptyTable: "Δεν υπάρχουν εγγραφές",
  info: "_START_ έως _END_ απο τα _TOTAL_ αποτελέσματα",
  infoEmpty: "0 απο 0 τα 0 αποτελέσματα",
  lengthMenu: "_MENU_",
  loadingRecords: "Φόρτωση ...",
  processing: "Επεξεργασία ...",
  search: "",
  searchPlaceholder: "Αναζήτηση... ",
  zeroRecords: "Δεν βρέθηκαν αποτελέσματα",
  paginate: {
    previous: "<i class='mdi mdi-chevron-left'>",
    next: "<i class='mdi mdi-chevron-right'>"
  },
  infoFiltered: "(Φιλτραρισμένα απο τις _MAX_ εγγραφές)"
}; //!GLOBAL FUNCTION
//!============================================================

function mainCheckboxSwitcher(main, minor) {
  var bulkBtn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var status = true;
  var counter = 0;
  main.checked = true;

  for (var i = 0; i < minor.length; i++) {
    if (!minor[i].checked) {
      minor[i].findParent(3).classList.remove("bg-selected");
      main.checked = false;
    } else {
      minor[i].findParent(3).classList.add("bg-selected");
      counter++;
      status = false;
    }
  }

  if (bulkBtn) {
    bulkModifier(bulkBtn, status, counter);
  }
}

function minorCheckboxSwitcher(main, minor) {
  var bulkBtn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var counter = 0;
  var status = true;

  if (main.checked && minor.length > 0) {
    counter = minor.length;
    status = false;

    for (var i = 0; i < minor.length; i++) {
      minor[i].checked = true;
      minor[i].findParent(3).classList.add("bg-selected");
    }
  } else {
    for (var i = 0; i < minor.length; i++) {
      minor[i].checked = false;
      minor[i].findParent(3).classList.remove("bg-selected");
    }
  }

  if (bulkBtn) {
    bulkModifier(bulkBtn, status, counter);
  }
}

function bulkModifier(bulkBtn, status, sum) {
  var text = bulkBtn.dataset.text ? bulkBtn.dataset.text : "Επιλογές";
  var enabledColor = bulkBtn.dataset.enabledColor ? bulkBtn.dataset.enabledColor : "btn-warning";
  var disabledColor = bulkBtn.dataset.disabledColor ? bulkBtn.dataset.disabledColor : "btn-secondary";

  if (status) {
    bulkBtn.classList.remove(enabledColor);
    bulkBtn.classList.add(disabledColor);
    bulkBtn.textContent = "".concat(text, " (0)  ");
    bulkBtn.disabled = true;
  } else {
    bulkBtn.classList.remove(disabledColor);
    bulkBtn.classList.add(enabledColor);
    bulkBtn.textContent = "".concat(text, "  (").concat(sum, ")  ");
    bulkBtn.disabled = false;
  }
}

function filterStyle(input, value) {
  if (value == "") {
    input.classList.remove("select2-selected");
  } else {
    input.classList.add("select2-selected");
  }
}

var filterButton = function filterButton(attr, column, table, tableId) {
  $(attr).detach().appendTo(tableId);
  $(attr).on('change', function () {
    table.columns(column).search(this.value).draw();
  });
};

var changeInputHidden = function changeInputHidden(attr, hiddenAttr) {
  $(attr).change(function () {
    if (attr == "#activeMaterial") {
      this.value = $(this).prop('checked') == true ? 1 : 0;
    }

    var hiddenValue = $(hiddenAttr)[0].value = this.value;
  });
};

function createStateSelect() {
  var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
  var selectElm = document.createElement("select");
  selectElm.classList.add("ml-1", "select2");
  selectElm.id = id;
  selectElm.innerHTML = "\n\t\t<option value=\"\">\u038C\u03BB\u03B5\u03C2 \u03BF\u03B9 \u039A\u03B1\u03C4\u03B1\u03C3\u03C4\u03AC\u03C3\u03B5\u03B9\u03C2</option>\n\t\t<option value=\"1\">\u0395\u03BD\u03B5\u03C1\u03B3\u03AC</option>\n\t\t<option value=\"0\">\u0391\u03BD\u03B5\u03BD\u03B5\u03C1\u03B3\u03AC</option>\n\t";
  return selectElm;
}

function createDateElm(id) {
  var input = document.createElement("input");
  input.classList.add("form-control", "date", "d-inline-block", "ml-1", "js-date-search");
  input.id = id;
  input.dataset.toggle = "date-picker";
  input.dataset.cancelClass = "btn-secondary";
  input.style.height = "31.96px";
  input.style.width = "195px";
  input.placeholder = "Επιλέξτε ημερομηνίες...";
  return input;
}

function createCourseTypeSelect() {
  var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
  var selectElm = document.createElement("select");
  selectElm.classList.add("ml-1", "select2");
  selectElm.id = id;
  selectElm.innerHTML = "\n\t\t<option value=\"\">\u038C\u03BB\u03B5\u03C2 \u03BF\u03B9 \u0395\u03BA\u03B4\u03CC\u03C3\u03B5\u03B9\u03C2</option>\n\t\t<option value=\"Normal\">Normal</option>\n\t\t<option value=\"Trial\">Trial</option>\n\t";
  return selectElm;
}

function startDate(input) {
  var dateInput = input;

  if (!dateInput || dateInput.value == "") {
    return "";
  }

  var dateInputValue = dateInput.value.split(" - ");
  var firstDate = dateInputValue[0].split("/").reverse().join("-");
  return firstDate;
}

function endDate(input) {
  var dateInput = input;

  if (!dateInput || dateInput.value == "") {
    return "";
  }

  var dateInputValue = dateInput.value.split(" - ");
  var secondDate = dateInputValue[1].split("/").reverse().join("-");
  return secondDate;
}

function resetBulk(bulkBtn, checkbox) {
  var text = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "Επιλογές  (0)";
  bulkBtn.text(text);
  bulkBtn.addClass("btn-secondary");
  bulkBtn.removeClass("btn-warning btn-danger");
  bulkBtn.prop("disabled", true);
  checkbox.prop("checked", false);
}

function resetAddButton(addBtn, checkbox) {
  addBtn.text("Προσθήκη Επιλογών (0)");
  addBtn.addClass("btn-secondary");
  addBtn.removeClass("btn-primary");
  addBtn.prop("disabled", true);
  checkbox.prop("checked", false);
}

function passwordValidation() {
  return sweetalert2__WEBPACK_IMPORTED_MODULE_0___default.a.fire({
    title: "Παρακαλώ εισάγεται Κωδικό",
    input: "password",
    showCancelButton: true,
    confirmButtonColor: "#536de6",
    showLoaderOnConfirm: true,
    preConfirm: function preConfirm(password) {
      return axios.post("/users-ajax/confirm-password", {
        password: password
      }).then(function (res) {
        return res.status;
      })["catch"](function (err) {
        sweetalert2__WEBPACK_IMPORTED_MODULE_0___default.a.showValidationMessage(err.response.data);
      });
    }
  });
} //!##############################################
//!				Media Library Functions			#
//!##############################################


function paginationHandler(event) {
  event.preventDefault();
  var activePage = this.href.split("page=")[1];
  var search = $("#image-search").val();
  paginationRequest(activePage, search);
}

function searchHandler() {
  clearTimeout(timer);

  if (this.value.length < 3 || this.value == "") {
    timer = setTimeout(paginationRequest, 800, 1, "");
  } else {
    timer = setTimeout(paginationRequest, 800, 1, this.value);
  }
}

function imageHandler() {
  var modal = $("#gallery-content")[0];
  var model = modal.dataset.model;
  var modelId = modal.dataset.id;
  var editorId = modal.dataset.editorId;
  var type = modal.dataset.type;
  var image = {
    'img': {
      url: "".concat(this.dataset.imageSource)
    }
  };

  if (type == "article") {
    ArticleEditor(editorId).image.insert(image);
  } else if (type == "redactor") {
    $R(editorId, 'insertion.insertHtml', "<img class=\"img-fluid\" src=\"".concat(this.dataset.imageSource, "\" alt=\"").concat(this.dataset.name, "\" />"));
  } else if (type == "gallery") {
    $("#remove-all-images-btn").removeClass("d-none");
    addToGallery(model, modelId, this.dataset.imageId);
    return;
  } else {
    changeCoverRequest(model, modelId, this.dataset.imageSource);
  }

  $("#gallery-modal").modal('hide');
}

function paginationRequest(activePage, search) {
  axios.get("/media/images", {
    params: {
      page: activePage,
      search: search
    }
  }).then(function (res) {
    var gallery = $("#gallery-content")[0];
    gallery.innerHTML = res.data;
    var pagination = gallery.getElementsByClassName("js-gallery-page-btn");
    var addBtns = gallery.getElementsByClassName("js-add-image");

    for (var i = 0; i < addBtns.length; i++) {
      addBtns[i].removeEventListener("click", imageHandler);
      addBtns[i].addEventListener("click", imageHandler);
    }

    for (var _i = 0; _i < pagination.length; _i++) {
      pagination[_i].removeEventListener("click", paginationHandler);

      pagination[_i].addEventListener("click", paginationHandler);
    }
  });
}

function changeCoverRequest(namespace, id, url) {
  if (typeof id === "undefined" && namespace == "App\\Models\\User") {
    var img = $("#cover-image")[0];
    var removeBtnCnt = $("#remove-cover-btn").parent();
    img.src = "".concat(url);
    img.classList.remove("d-none");
    removeBtnCnt.removeClass("d-none");
    removeBtnCnt.addClass("d-flex");
    $("#custom-file")[0].value = "".concat(url);
  } else {
    axios.patch("/media/cover/replace", {
      namespace: namespace,
      id: id,
      url: url
    }).then(function (res) {
      var img = $("#cover-image")[0];
      var removeBtnCnt = $("#remove-cover-btn").parent();
      img.src = res.data.imgUrl;
      img.classList.remove("d-none");
      $("#change-cover-btn").text("Αλλαγή");
      $("#cover-status").addClass("d-none");
      removeBtnCnt.removeClass("d-none");
      removeBtnCnt.addClass("d-flex");
      toastAlert("success", "Το Cover άλλαξε!");
    })["catch"](function (err) {
      console.log(err);
      toastAlert('error', "Παρουσιάστηκε κάποιο πρόβλημα ...");
    });
  }
}

function addToGallery(namespace, id, imageId) {
  axios.post("/media/gallery", {
    namespace: namespace,
    modelId: id,
    ids: [imageId]
  }).then(function (res) {
    var gallery = $("#gallery-cnt");
    gallery.html(res.data);
    var closeBtns = gallery.find(".js-remove-image");
    closeBtns.on("click", removeImageHandler);
    toastAlert("success", "Η εικόνα προστέθηκε.");
    gallery.modal("hide");
    var bulk = $("#gallery-bulk-action-btn");
    var checkboxes = $(".js-gallery-checkbox");
    resetGalleryBtns(bulk, checkboxes);
  })["catch"](function (err) {
    console.log(err);
    toastAlert('error', "Παρουσιάστηκε κάποιο πρόβλημα ...");
  });
}

function removeImageHandler() {
  var _this = this;

  sweetalert2__WEBPACK_IMPORTED_MODULE_0___default.a.fire({
    icon: 'info',
    title: 'Προσοχή!',
    text: 'Η εικόνα θα αφαιρεθεί απο το Gallery.',
    showCancelButton: true,
    confirmButtonColor: '#536de6',
    confirmButtonText: "\u039D\u03B1\u03B9, \u03B1\u03C6\u03B1\u03AF\u03C1\u03B5\u03C3\u03B7!",
    cancelButtonText: "Άκυρο"
  }).then(function (result) {
    if (result.isConfirmed) {
      removeImages([_this.dataset.imageId]);
    }
  });
}

function removeImages(ids) {
  var gallery = $("#gallery-cnt")[0];
  var namespace = gallery.dataset.namespace;
  var modelId = gallery.dataset.modelId;
  axios.post("/media/gallery-remove", {
    namespace: namespace,
    modelId: modelId,
    ids: ids
  }).then(function (res) {
    var gallery = $("#gallery-cnt");
    gallery.html(res.data);
    var closeBtns = gallery.find(".js-remove-image");
    closeBtns.on("click", removeImageHandler);

    if (closeBtns.length == 0) {
      $("#remove-all-images-btn").addClass("d-none");
    }
  })["catch"](function (err) {
    console.log(err);
    utilities.toastAlert('error', "Παρουσιάστηκε κάποιο πρόβλημα ...");
  });
}

function resetGalleryBtns(bulk, checkboxes) {
  bulk.text("Επιλογές (0)");
  bulk.prop("disabled", true);
  bulk.removeClass("btn-warning");
  bulk.addClass("btn-secondary");

  for (var i = 0; i < checkboxes.length; i++) {
    checkboxes[i].checked = false;
  }
} //!######################################################
//!				Media Library Functions End				#
//!######################################################


/* harmony default export */ __webpack_exports__["default"] = ({
  toastAlert: toastAlert,
  mainCheckboxSwitcher: mainCheckboxSwitcher,
  minorCheckboxSwitcher: minorCheckboxSwitcher,
  filterButton: filterButton,
  tableLocale: tableLocale,
  changeInputHidden: changeInputHidden,
  redactorConfig: redactorConfig,
  createStateSelect: createStateSelect,
  datePickerConfig: datePickerConfig,
  toastAlertDelete: toastAlertDelete,
  filterStyle: filterStyle,
  createDateElm: createDateElm,
  startDate: startDate,
  endDate: endDate,
  resetBulk: resetBulk,
  resetAddButton: resetAddButton,
  createCourseTypeSelect: createCourseTypeSelect,
  paginationHandler: paginationHandler,
  searchHandler: searchHandler,
  imageHandler: imageHandler,
  paginationRequest: paginationRequest,
  resetGalleryBtns: resetGalleryBtns,
  removeImageHandler: removeImageHandler,
  removeImages: removeImages,
  articleConfig: articleConfig,
  ALLOWEDTYPES: ALLOWEDTYPES,
  passwordValidation: passwordValidation,
  removeAlert: removeAlert
});

/***/ }),

/***/ "./resources/plugins/article-editor/article-editor.js":
/*!************************************************************!*\
  !*** ./resources/plugins/article-editor/article-editor.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*
    Article Editor JS
    Version 2.1.4
    Updated: November 2, 2020

    http://imperavi.com/article/

    Copyright (c) 2009-2020, Imperavi Ltd.
    License: http://imperavi.com/article/license/
*/
if (typeof CodeMirror === 'undefined') {
  var CodeMirror = undefined;
}

if (typeof jQuery === 'undefined') {
  var jQuery = undefined;
}

(function () {
  var Ajax = {};
  Ajax.settings = {};

  Ajax.post = function (options) {
    return new AjaxRequest('post', options);
  };

  Ajax.get = function (options) {
    return new AjaxRequest('get', options);
  };

  var AjaxRequest = function AjaxRequest(method, options) {
    var defaults = {
      method: method,
      url: '',
      before: function before() {},
      success: function success() {},
      error: function error() {},
      data: false,
      async: true,
      headers: {}
    };
    this.p = this.extend(defaults, options);
    this.p = this.extend(this.p, Ajax.settings);
    this.p.method = this.p.method.toUpperCase();
    this.prepareData();
    this.xhr = new XMLHttpRequest();
    this.xhr.open(this.p.method, this.p.url, this.p.async);
    this.setHeaders();
    var before = typeof this.p.before === 'function' ? this.p.before(this.xhr) : true;

    if (before !== false) {
      this.send();
    }
  };

  AjaxRequest.prototype = {
    extend: function extend(obj1, obj2) {
      if (obj2) for (var name in obj2) {
        obj1[name] = obj2[name];
      }
      return obj1;
    },
    prepareData: function prepareData() {
      if (this.p.method === 'POST' && !this.isFormData()) this.p.headers['Content-Type'] = 'application/x-www-form-urlencoded';
      if (_typeof(this.p.data) === 'object' && !this.isFormData()) this.p.data = this.toParams(this.p.data);
      if (this.p.method === 'GET') this.p.url = this.p.data ? this.p.url + '?' + this.p.data : this.p.url;
    },
    setHeaders: function setHeaders() {
      this.xhr.setRequestHeader('X-Requested-With', this.p.headers['X-Requested-With'] || 'XMLHttpRequest');

      for (var name in this.p.headers) {
        this.xhr.setRequestHeader(name, this.p.headers[name]);
      }
    },
    isFormData: function isFormData() {
      return typeof window.FormData !== 'undefined' && this.p.data instanceof window.FormData;
    },
    isComplete: function isComplete() {
      return !(this.xhr.status < 200 || this.xhr.status >= 300 && this.xhr.status !== 304);
    },
    send: function send() {
      if (this.p.async) {
        this.xhr.onload = this.loaded.bind(this);
        this.xhr.send(this.p.data);
      } else {
        this.xhr.send(this.p.data);
        this.loaded.call(this);
      }
    },
    loaded: function loaded() {
      if (this.isComplete()) {
        var response = this.xhr.response;
        var json = this.parseJson(response);
        response = json ? json : response;
        if (typeof this.p.success === 'function') this.p.success(response, this.xhr);
      } else {
        if (typeof this.p.error === 'function') this.p.error(this.xhr.statusText);
      }
    },
    parseJson: function parseJson(str) {
      try {
        var o = JSON.parse(str);

        if (o && _typeof(o) === 'object') {
          return o;
        }
      } catch (e) {}

      return false;
    },
    toParams: function toParams(obj) {
      return Object.keys(obj).map(function (k) {
        return encodeURIComponent(k) + '=' + encodeURIComponent(obj[k]);
      }).join('&');
    }
  }; // version 2

  var DomCache = [0];
  var DomExpando = 'data' + new Date().getTime();

  var Dom = function Dom(selector, context) {
    return this.parse(selector, context);
  };

  Dom.ready = function (fn) {
    document.addEventListener('DOMContentLoaded', fn);
  };

  Dom.prototype = {
    get length() {
      return this.nodes.length;
    },

    parse: function parse(s, c) {
      var n;
      var rehtml = /^\s*<(\w+|!)[^>]*>/;

      if (!s) {
        n = [];
      } else if (s instanceof Dom) {
        this.nodes = s.nodes;
        return s;
      } else if (rehtml.test(s)) {
        n = this.create(s);
      } else if (typeof s !== 'string') {
        if (s.nodeType && s.nodeType === 11) n = s.childNodes;else n = s.nodeType || this._isWindowNode(s) ? [s] : s;
      } else {
        n = this._query(s, c);
      }

      this.nodes = this._slice(n);
    },
    create: function create(html) {
      if (/^<(\w+)\s*\/?>(?:<\/\1>|)$/.test(html)) {
        return [document.createElement(RegExp.$1)];
      }

      var elmns = [];
      var c = document.createElement('div');
      c.innerHTML = html;

      for (var i = 0, l = c.childNodes.length; i < l; i++) {
        elmns.push(c.childNodes[i]);
      }

      return elmns;
    },
    // dataset/dataget
    dataset: function dataset(key, value) {
      return this.each(function ($node) {
        DomCache[this.dataindex($node.get())][key] = value;
      });
    },
    dataget: function dataget(key) {
      return DomCache[this.dataindex(this.get())][key];
    },
    dataindex: function dataindex(el) {
      var index = el[DomExpando];
      var nextIndex = DomCache.length;

      if (!index) {
        index = nextIndex;
        if (el) el[DomExpando] = nextIndex;
        DomCache[index] = {};
      }

      return index;
    },
    // add
    add: function add(n) {
      this.nodes = this.nodes.concat(this._array(n));
      return this;
    },
    // get
    get: function get(index) {
      return this.nodes[index || 0] || false;
    },
    getAll: function getAll() {
      return this.nodes;
    },
    eq: function eq(index) {
      return new Dom(this.nodes[index]);
    },
    first: function first() {
      return new Dom(this.nodes[0]);
    },
    last: function last() {
      return new Dom(this.nodes[this.nodes.length - 1]);
    },
    contents: function contents() {
      return this.get().childNodes;
    },
    // loop
    each: function each(fn) {
      var len = this.nodes.length;

      for (var i = 0; i < len; i++) {
        fn.call(this, new Dom(this.nodes[i]), i);
      }

      return this;
    },
    // traversing
    is: function is(s) {
      return this.filter(s).length > 0;
    },
    filter: function filter(s) {
      var fn;

      if (s === undefined) {
        return this;
      } else if (typeof s === 'function') {
        fn = function fn(node) {
          return s(new Dom(node));
        };
      } else {
        fn = function fn(node) {
          if (s && s.nodeType || s instanceof Node) {
            return s === node;
          } else {
            node.matches = node.matches || node.msMatchesSelector || node.webkitMatchesSelector;
            return node.nodeType === 1 ? node.matches(s || '*') : false;
          }
        };
      }

      return new Dom(this.nodes.filter.call(this.nodes, fn));
    },
    not: function not(filter) {
      return this.filter(function (node) {
        return !new Dom(node).is(filter || true);
      });
    },
    find: function find(s) {
      var n = [];
      this.each(function ($n) {
        var node = $n.get();

        var ns = this._query(s, node);

        for (var i = 0; i < ns.length; i++) {
          n.push(ns[i]);
        }
      });
      return new Dom(n);
    },
    children: function children(s) {
      var n = [];
      this.each(function ($n) {
        var node = $n.get();

        if (node.children) {
          var ns = node.children;

          for (var i = 0; i < ns.length; i++) {
            n.push(ns[i]);
          }
        }
      });
      return new Dom(n).filter(s);
    },
    parent: function parent(s) {
      var node = this.get();
      var p = node.parentNode ? node.parentNode : false;
      return p ? new Dom(p).filter(s) : new Dom();
    },
    parents: function parents(s, c) {
      c = this._context(c);
      var n = [];
      this.each(function ($n) {
        var node = $n.get();
        var p = node.parentNode;

        while (p && p !== c) {
          if (s) {
            if (new Dom(p).is(s)) {
              n.push(p);
            }
          } else {
            n.push(p);
          }

          p = p.parentNode;
        }
      });
      return new Dom(n);
    },
    closest: function closest(s, c) {
      c = this._context(c);
      var n = [];
      var isNode = s && s.nodeType;
      this.each(function ($n) {
        var node = $n.get();

        do {
          if (isNode && node === s || new Dom(node).is(s)) return n.push(node);
        } while ((node = node.parentNode) && node !== c);
      });
      return new Dom(n);
    },
    next: function next(s) {
      return this._sibling(s, 'nextSibling');
    },
    nextElement: function nextElement(s) {
      return this._sibling(s, 'nextElementSibling');
    },
    prev: function prev(s) {
      return this._sibling(s, 'previousSibling');
    },
    prevElement: function prevElement(s) {
      return this._sibling(s, 'previousElementSibling');
    },
    // css
    css: function css(name, value) {
      if (value === undefined && _typeof(name) !== 'object') {
        var node = this.get();

        if (name === 'width' || name === 'height') {
          return node.style ? this._getHeightOrWidth(name) + 'px' : undefined;
        } else {
          return node.style ? getComputedStyle(node, null)[name] : undefined;
        }
      } // set


      return this.each(function ($n) {
        var node = $n.get();
        var o = {};
        if (_typeof(name) === 'object') o = name;else o[name] = value;

        for (var key in o) {
          if (node.style) node.style[key] = o[key];
        }
      });
    },
    // attr
    attr: function attr(name, value, data) {
      data = data ? 'data-' : '';

      if (typeof value === 'undefined' && _typeof(name) !== 'object') {
        var node = this.get();

        if (node && node.nodeType !== 3) {
          return name === 'checked' ? node.checked : this._boolean(node.getAttribute(data + name));
        } else {
          return;
        }
      } // set


      return this.each(function ($n) {
        var node = $n.get();
        var o = {};
        if (_typeof(name) === 'object') o = name;else o[name] = value;

        for (var key in o) {
          if (node.nodeType !== 3) {
            if (key === 'checked') node.checked = o[key];else node.setAttribute(data + key, o[key]);
          }
        }
      });
    },
    data: function data(name, value) {
      if (name === undefined) {
        var reDataAttr = /^data-(.+)$/;
        var attrs = this.get().attributes;
        var data = {};

        var replacer = function replacer(g) {
          return g[1].toUpperCase();
        };

        for (var key in attrs) {
          if (attrs[key] && reDataAttr.test(attrs[key].nodeName)) {
            var dataName = attrs[key].nodeName.match(reDataAttr)[1];
            var val = attrs[key].value;
            dataName = dataName.replace(/-([a-z])/g, replacer);
            if (val.search(/^{/) !== -1) val = this._object(val);else val = this._number(val) ? parseFloat(val) : this._boolean(val);
            data[dataName] = val;
          }
        }

        return data;
      }

      return this.attr(name, value, true);
    },
    val: function val(value) {
      if (value === undefined) {
        var el = this.get();
        if (el.type && el.type === 'checkbox') return el.checked;else return el.value;
      }

      return this.each(function ($n) {
        var el = $n.get();
        if (el.type && el.type === 'checkbox') el.checked = value;else el.value = value;
      });
    },
    removeAttr: function removeAttr(value) {
      return this.each(function ($n) {
        var node = $n.get();

        var fn = function fn(name) {
          if (node.nodeType !== 3) node.removeAttribute(name);
        };

        value.split(' ').forEach(fn);
      });
    },
    // class
    addClass: function addClass(value) {
      return this._eachClass(value, 'add');
    },
    removeClass: function removeClass(value) {
      return this._eachClass(value, 'remove');
    },
    toggleClass: function toggleClass(value) {
      return this._eachClass(value, 'toggle');
    },
    hasClass: function hasClass(value) {
      var node = this.get();
      return node.classList ? node.classList.contains(value) : false;
    },
    // html & text
    empty: function empty() {
      return this.each(function ($n) {
        $n.get().innerHTML = '';
      });
    },
    html: function html(_html) {
      return _html === undefined ? this.get().innerHTML || '' : this.empty().append(_html);
    },
    text: function text(_text) {
      return _text === undefined ? this.get().textContent || '' : this.each(function ($n) {
        $n.get().textContent = _text;
      });
    },
    // manipulation
    after: function after(html) {
      return this._inject(html, function (frag, node) {
        if (typeof frag === 'string') {
          node.insertAdjacentHTML('afterend', frag);
        } else {
          if (node.parentNode !== null) {
            for (var i = frag instanceof Node ? [frag] : this._array(frag).reverse(), s = 0; s < i.length; s++) {
              node.parentNode.insertBefore(i[s], node.nextSibling);
            }
          }
        }

        return node;
      });
    },
    before: function before(html) {
      return this._inject(html, function (frag, node) {
        if (typeof frag === 'string') {
          node.insertAdjacentHTML('beforebegin', frag);
        } else {
          var elms = frag instanceof Node ? [frag] : this._array(frag);

          for (var i = 0; i < elms.length; i++) {
            node.parentNode.insertBefore(elms[i], node);
          }
        }

        return node;
      });
    },
    append: function append(html) {
      return this._inject(html, function (frag, node) {
        if (typeof frag === 'string' || typeof frag === 'number') {
          node.insertAdjacentHTML('beforeend', frag);
        } else {
          var elms = frag instanceof Node ? [frag] : this._array(frag);

          for (var i = 0; i < elms.length; i++) {
            node.appendChild(elms[i]);
          }
        }

        return node;
      });
    },
    prepend: function prepend(html) {
      return this._inject(html, function (frag, node) {
        if (typeof frag === 'string' || typeof frag === 'number') {
          node.insertAdjacentHTML('afterbegin', frag);
        } else {
          var elms = frag instanceof Node ? [frag] : this._array(frag).reverse();

          for (var i = 0; i < elms.length; i++) {
            node.insertBefore(elms[i], node.firstChild);
          }
        }

        return node;
      });
    },
    wrap: function wrap(html) {
      return this._inject(html, function (frag, node) {
        var wrapper = typeof frag === 'string' || typeof frag === 'number' ? this.create(frag)[0] : frag instanceof Node ? frag : this._array(frag)[0];

        if (node.parentNode) {
          node.parentNode.insertBefore(wrapper, node);
        }

        wrapper.appendChild(node);
        return wrapper;
      });
    },
    unwrap: function unwrap() {
      return this.each(function ($n) {
        var node = $n.get();
        var docFrag = document.createDocumentFragment();

        while (node.firstChild) {
          var child = node.removeChild(node.firstChild);
          docFrag.appendChild(child);
        }

        node.parentNode.replaceChild(docFrag, node);
      });
    },
    replaceWith: function replaceWith(html) {
      return this._inject(html, function (frag, node) {
        var docFrag = document.createDocumentFragment();
        var elms = typeof frag === 'string' || typeof frag === 'number' ? this.create(frag) : frag instanceof Node ? [frag] : this._array(frag);

        for (var i = 0; i < elms.length; i++) {
          docFrag.appendChild(elms[i]);
        }

        var result = docFrag.childNodes[0];

        if (node.parentNode) {
          node.parentNode.replaceChild(docFrag, node);
        }

        return result;
      });
    },
    remove: function remove() {
      return this.each(function ($n) {
        var node = $n.get();
        if (node.parentNode) node.parentNode.removeChild(node);
      });
    },
    clone: function clone(events) {
      var n = [];
      this.each(function ($n) {
        var node = $n.get();

        var copy = this._clone(node);

        if (events) copy = this._cloneEvents(node, copy);
        n.push(copy);
      });
      return new Dom(n);
    },
    // show/hide
    show: function show() {
      return this.each(function ($n) {
        var node = $n.get();
        if (!node.style || !this._hasDisplayNone(node)) return;
        var target = node.getAttribute('domTargetShow');
        node.style.display = target ? target : 'block';
        node.removeAttribute('domTargetShow');
      }.bind(this));
    },
    hide: function hide() {
      return this.each(function ($n) {
        var node = $n.get();
        if (!node.style || this._hasDisplayNone(node)) return;
        var display = node.style.display;
        if (display !== 'block') node.setAttribute('domTargetShow', display);
        node.style.display = 'none';
      });
    },
    // dimensions
    scrollTop: function scrollTop(value) {
      var node = this.get();

      var isWindow = this._isWindowNode(node);

      var isDocument = node.nodeType === 9;
      var el = isDocument ? node.scrollingElement || node.body.parentNode || node.body || node.documentElement : node;

      if (typeof value !== 'undefined') {
        value = parseInt(value);
        if (isWindow) node.scrollTo(0, value);else el.scrollTop = value;
        return;
      }

      return isWindow ? node.pageYOffset : el.scrollTop;
    },
    offset: function offset() {
      return this._getPos('offset');
    },
    position: function position() {
      return this._getPos('position');
    },
    width: function width(value) {
      return value !== undefined ? this.css('width', parseInt(value) + 'px') : this._getSize('width', 'Width');
    },
    height: function height(value) {
      return value !== undefined ? this.css('height', parseInt(value) + 'px') : this._getSize('height', 'Height');
    },
    outerWidth: function outerWidth() {
      return this._getSize('width', 'Width', 'outer');
    },
    outerHeight: function outerHeight() {
      return this._getSize('height', 'Height', 'outer');
    },
    innerWidth: function innerWidth() {
      return this._getSize('width', 'Width', 'inner');
    },
    innerHeight: function innerHeight() {
      return this._getSize('height', 'Height', 'inner');
    },
    // events
    click: function click() {
      return this._trigger('click');
    },
    focus: function focus() {
      return this._trigger('focus');
    },
    blur: function blur() {
      return this._trigger('blur');
    },
    on: function on(names, handler, one) {
      return this.each(function ($n) {
        var node = $n.get();
        var events = names.split(' ');

        for (var i = 0; i < events.length; i++) {
          var event = this._getEventName(events[i]);

          var namespace = this._getEventNamespace(events[i]);

          handler = one ? this._getOneHandler(handler, names) : handler;
          node.addEventListener(event, handler);
          node._e = node._e || {};
          node._e[namespace] = node._e[namespace] || {};
          node._e[namespace][event] = node._e[namespace][event] || [];

          node._e[namespace][event].push(handler);
        }
      });
    },
    one: function one(events, handler) {
      return this.on(events, handler, true);
    },
    off: function off(names, handler) {
      var testEvent = function testEvent(name, key, event) {
        return name === event;
      };

      var testNamespace = function testNamespace(name, key, event, namespace) {
        return key === namespace;
      };

      var testEventNamespace = function testEventNamespace(name, key, event, namespace) {
        return name === event && key === namespace;
      };

      var testPositive = function testPositive() {
        return true;
      };

      if (names === undefined) {
        // all
        return this.each(function ($n) {
          this._offEvent($n.get(), false, false, handler, testPositive);
        });
      }

      return this.each(function ($n) {
        var node = $n.get();
        var events = names.split(' ');

        for (var i = 0; i < events.length; i++) {
          var event = this._getEventName(events[i]);

          var namespace = this._getEventNamespace(events[i]); // 1) event without namespace


          if (namespace === '_events') this._offEvent(node, event, namespace, handler, testEvent); // 2) only namespace
          else if (!event && namespace !== '_events') this._offEvent(node, event, namespace, handler, testNamespace); // 3) event + namespace
            else this._offEvent(node, event, namespace, handler, testEventNamespace);
        }
      });
    },
    // form
    serialize: function serialize(asObject) {
      var obj = {};
      var elms = this.get().elements;

      for (var i = 0; i < elms.length; i++) {
        var el = elms[i];
        if (/(checkbox|radio)/.test(el.type) && !el.checked) continue;
        if (!el.name || el.disabled || el.type === 'file') continue;

        if (el.type === 'select-multiple') {
          for (var z = 0; z < el.options.length; z++) {
            var opt = el.options[z];
            if (opt.selected) obj[el.name] = opt.value;
          }
        }

        obj[el.name] = this._number(el.value) ? parseFloat(el.value) : this._boolean(el.value);
      }

      return asObject ? obj : this._params(obj);
    },
    // animation
    scroll: function scroll() {
      this.get().scrollIntoView({
        behavior: 'smooth'
      });
    },
    fadeIn: function fadeIn(speed, fn) {
      var anim = this._anim(speed, fn, 500);

      return this.each(function ($n) {
        $n.css({
          'display': 'block',
          'opacity': 0,
          'animation': 'fadeIn ' + anim.speed + 's ease-in-out'
        });
        $n.one('animationend', function (e) {
          $n.css({
            'opacity': '',
            'animation': ''
          });
          if (anim.fn) anim.fn($n);
        });
      });
    },
    fadeOut: function fadeOut(speed, fn) {
      var anim = this._anim(speed, fn, 300);

      return this.each(function ($n) {
        $n.css({
          'opacity': 1,
          'animation': 'fadeOut ' + anim.speed + 's ease-in-out'
        });
        $n.one('animationend', function (e) {
          $n.css({
            'display': 'none',
            'opacity': '',
            'animation': ''
          });
          if (anim.fn) anim.fn($n);
        });
      });
    },
    slideUp: function slideUp(speed, fn) {
      var anim = this._anim(speed, fn, 300);

      return this.each(function ($n) {
        $n.height($n.height());
        $n.css({
          'overflow': 'hidden',
          'animation': 'slideUp ' + anim.speed + 's ease-out'
        });
        $n.one('animationend', function (e) {
          $n.css({
            'display': 'none',
            'height': '',
            'animation': ''
          });
          if (anim.fn) anim.fn($n);
        });
      });
    },
    slideDown: function slideDown(speed, fn) {
      var anim = this._anim(speed, fn, 400);

      return this.each(function ($n) {
        $n.height($n.height());
        $n.css({
          'display': 'block',
          'overflow': 'hidden',
          'animation': 'slideDown ' + anim.speed + 's ease-in-out'
        });
        $n.one('animationend', function (e) {
          $n.css({
            'overflow': '',
            'height': '',
            'animation': ''
          });
          if (anim.fn) anim.fn($n);
        });
      });
    },
    // private
    _queryContext: function _queryContext(s, c) {
      c = this._context(c);
      return c.nodeType !== 3 && typeof c.querySelectorAll === 'function' ? c.querySelectorAll(s) : [];
    },
    _query: function _query(s, c) {
      var d = document;

      if (c) {
        return this._queryContext(s, c);
      } else if (/^[.#]?[\w-]*$/.test(s)) {
        if (s[0] === '#') {
          var el = d.getElementById(s.slice(1));
          return el ? [el] : [];
        }

        if (s[0] === '.') {
          return d.getElementsByClassName(s.slice(1));
        }

        return d.getElementsByTagName(s);
      }

      return d.querySelectorAll(s);
    },
    _context: function _context(c) {
      return !c ? document : typeof c === 'string' ? document.querySelector(c) : c;
    },
    _sibling: function _sibling(s, method) {
      var isNode = s && s.nodeType;
      var sibling;
      this.each(function ($n) {
        var node = $n.get();

        while (node = node[method]) {
          if (isNode && node === s || new Dom(node).is(s)) {
            sibling = node;
            return;
          }
        }
      });
      return new Dom(sibling);
    },
    _slice: function _slice(o) {
      return !o || o.length === 0 ? [] : o.length ? [].slice.call(o.nodes || o) : [o];
    },
    _array: function _array(o) {
      if (o === undefined) return [];else if (o instanceof NodeList) {
        var arr = [];

        for (var i = 0; i < o.length; i++) {
          arr[i] = o[i];
        }

        return arr;
      }
      return o instanceof Dom ? o.nodes : o;
    },
    _object: function _object(str) {
      return new Function("return " + str)();
    },
    _params: function _params(obj) {
      var params = '';

      for (var key in obj) {
        params += '&' + this._encodeUri(key) + '=' + this._encodeUri(obj[key]);
      }

      return params.replace(/^&/, '');
    },
    _boolean: function _boolean(str) {
      if (str === 'true') return true;else if (str === 'false') return false;
      return str;
    },
    _number: function _number(str) {
      return !isNaN(str) && !isNaN(parseFloat(str));
    },
    _inject: function _inject(html, fn) {
      var len = this.nodes.length;
      var nodes = [];

      while (len--) {
        var res = typeof html === 'function' ? html.call(this, this.nodes[len]) : html;
        var el = len === 0 ? res : this._clone(res);
        var node = fn.call(this, el, this.nodes[len]);

        if (node) {
          if (node.dom) nodes.push(node.get());else nodes.push(node);
        }
      }

      return new Dom(nodes);
    },
    _clone: function _clone(node) {
      if (typeof node === 'undefined') return;
      if (typeof node === 'string') return node;else if (node instanceof Node || node.nodeType) return node.cloneNode(true);else if ('length' in node) {
        return [].map.call(this._array(node), function (el) {
          return el.cloneNode(true);
        });
      }
    },
    _cloneEvents: function _cloneEvents(node, copy) {
      var events = node._e;

      if (events) {
        copy._e = events;

        for (var name in events._events) {
          for (var i = 0; i < events._events[name].length; i++) {
            copy.addEventListener(name, events._events[name][i]);
          }
        }
      }

      return copy;
    },
    _trigger: function _trigger(name) {
      var node = this.get();
      if (node && node.nodeType !== 3) node[name]();
      return this;
    },
    _encodeUri: function _encodeUri(str) {
      return encodeURIComponent(str).replace(/!/g, '%21').replace(/'/g, '%27').replace(/\(/g, '%28').replace(/\)/g, '%29').replace(/\*/g, '%2A').replace(/%20/g, '+');
    },
    _getSize: function _getSize(name, cname, type) {
      var el = this.get();
      var value = 0;

      if (el.nodeType === 3) {
        value = 0;
      } else if (el.nodeType === 9) {
        value = this._getDocSize(el, cname);
      } else if (this._isWindowNode(el)) {
        value = window['inner' + cname];
      } else {
        value = this._getHeightOrWidth(name);
      }

      return Math.round(value);
    },
    _getDocSize: function _getDocSize(node, type) {
      var body = node.body,
          html = node.documentElement;
      return Math.max(body['scroll' + type], body['offset' + type], html['client' + type], html['scroll' + type], html['offset' + type]);
    },
    _getPos: function _getPos(type) {
      var node = this.get();
      var dim = {
        top: 0,
        left: 0
      };

      if (node.nodeType === 3 || this._isWindowNode(node) || node.nodeType === 9) {
        return dim;
      } else if (type === 'position') {
        return {
          top: node.offsetTop,
          left: node.offsetLeft
        };
      } else if (type === 'offset') {
        var rect = node.getBoundingClientRect();
        var doc = node.ownerDocument;
        var docElem = doc.documentElement;
        var win = doc.defaultView;
        return {
          top: rect.top + win.pageYOffset - docElem.clientTop,
          left: rect.left + win.pageXOffset - docElem.clientLeft
        };
      }

      return dim;
    },
    _getHeightOrWidth: function _getHeightOrWidth(name, type) {
      var cname = name.charAt(0).toUpperCase() + name.slice(1);
      var mode = type ? type : 'offset';
      var result = 0;
      var el = this.get();
      var style = getComputedStyle(el, null);
      var $targets = this.parents().filter(function ($n) {
        var node = $n.get();
        return node.nodeType === 1 && getComputedStyle(node, null).display === 'none' ? node : false;
      });
      if (style.display === 'none') $targets.add(el);

      if ($targets.length !== 0) {
        var fixStyle = 'visibility: hidden !important; display: block !important;';
        var tmp = [];
        $targets.each(function ($n) {
          var thisStyle = $n.attr('style');
          if (thisStyle !== null) tmp.push(thisStyle);
          $n.attr('style', thisStyle !== null ? thisStyle + ';' + fixStyle : fixStyle);
        });
        result = el[mode + cname];
        $targets.each(function ($n, i) {
          if (tmp[i] === undefined) $n.removeAttr('style');else $n.attr('style', tmp[i]);
        });
      } else {
        result = el[mode + cname];
      }

      return result;
    },
    _eachClass: function _eachClass(value, type) {
      return this.each(function ($n) {
        if (value) {
          var node = $n.get();

          var fn = function fn(name) {
            if (node.classList) node.classList[type](name);
          };

          value.split(' ').forEach(fn);
        }
      });
    },
    _getOneHandler: function _getOneHandler(handler, events) {
      var self = this;
      return function () {
        handler.apply(this, arguments);
        self.off(events);
      };
    },
    _getEventNamespace: function _getEventNamespace(event) {
      var arr = event.split('.');
      var namespace = arr[1] ? arr[1] : '_events';
      return arr[2] ? namespace + arr[2] : namespace;
    },
    _getEventName: function _getEventName(event) {
      return event.split('.')[0];
    },
    _offEvent: function _offEvent(node, event, namespace, handler, condition) {
      for (var key in node._e) {
        for (var name in node._e[key]) {
          if (condition(name, key, event, namespace)) {
            var handlers = node._e[key][name];

            for (var i = 0; i < handlers.length; i++) {
              if (typeof handler !== 'undefined' && handlers[i].toString() !== handler.toString()) {
                continue;
              }

              node.removeEventListener(name, handlers[i]);

              node._e[key][name].splice(i, 1);

              if (node._e[key][name].length === 0) delete node._e[key][name];
              if (Object.keys(node._e[key]).length === 0) delete node._e[key];
            }
          }
        }
      }
    },
    _hasDisplayNone: function _hasDisplayNone(el) {
      return el.style.display === 'none' || (el.currentStyle ? el.currentStyle.display : getComputedStyle(el, null).display) === 'none';
    },
    _anim: function _anim(speed, fn, speedDef) {
      if (typeof speed === 'function') {
        fn = speed;
        speed = speedDef;
      } else {
        speed = speed || speedDef;
      }

      return {
        fn: fn,
        speed: speed / 1000
      };
    },
    _isWindowNode: function _isWindowNode(node) {
      return node === window || node.parent && node.parent === window;
    }
  }; // Unique ID

  var arx_uuid = 0; // Init

  var ArticleEditor = function ArticleEditor(selector, settings) {
    return ArticleEditorInit(selector, settings);
  }; // Class


  var ArticleEditorInit = function ArticleEditorInit(selector, settings) {
    var $elms = $ARX.dom(selector);
    var instance;
    $elms.each(function ($el) {
      instance = $el.dataget($ARX.namespace);

      if (!instance) {
        // Initialization
        instance = new App($el, settings, arx_uuid);
        $el.dataset($ARX.namespace, instance);
        $ARX.instances[arx_uuid] = instance;
        arx_uuid++;
      }
    });
    return instance;
  };

  var $ARX = ArticleEditor; // Dom & Ajax

  $ARX.dom = function (selector, context) {
    return new Dom(selector, context);
  };

  $ARX.ajax = Ajax; // Globals

  $ARX.instances = [];
  $ARX.namespace = 'article-editor';
  $ARX.prefix = 'arx';
  $ARX.version = '2.1.4';
  $ARX.settings = {};
  $ARX.lang = {};
  $ARX._mixins = {};
  $ARX._repository = {};
  $ARX._subscribe = {};
  $ARX.keycodes = {
    BACKSPACE: 8,
    DELETE: 46,
    UP: 38,
    DOWN: 40,
    ENTER: 13,
    SPACE: 32,
    ESC: 27,
    TAB: 9,
    CTRL: 17,
    META: 91,
    SHIFT: 16,
    ALT: 18,
    RIGHT: 39,
    LEFT: 37
  }; // Add

  $ARX.add = function (type, name, obj) {
    // translations
    if (obj.translations) {
      $ARX.lang = $ARX.extend(true, $ARX.lang, obj.translations);
    } // defaults


    if (obj.defaults) {
      var localopts = {};
      localopts[name] = obj.defaults;
      $ARX.opts = $ARX.extend(true, $ARX.opts, localopts);
    } // extend parser


    if (obj.parser) {
      var opt = {};
      opt[obj.type] = obj.parser;
      $ARX.opts.parser = $ARX.extend({}, true, $ARX.opts.parser, opt);
    } // extend nested


    if (obj.nested) {
      $ARX.opts.nested.push(obj.type);
    }

    if (type === 'mixin') {
      $ARX._mixins[name] = obj;
    } else {
      // subscribe
      if (obj.subscribe) {
        for (var key in obj.subscribe) {
          var arr = key.split(',');

          for (var i = 0; i < arr.length; i++) {
            var ns = arr[i].trim();
            if (typeof $ARX._subscribe[ns] === 'undefined') $ARX._subscribe[ns] = [];

            $ARX._subscribe[ns].push({
              module: name,
              func: obj.subscribe[key]
            });
          }
        }
      } // prototype


      var F = function F() {};

      F.prototype = obj; // mixins

      if (obj.mixins) {
        for (var z = 0; z < obj.mixins.length; z++) {
          $ARX.inherit(F, $ARX._mixins[obj.mixins[z]]);
        }
      }

      $ARX._repository[name] = {
        type: type,
        proto: F,
        obj: obj
      };
    }
  }; // Extend


  $ARX.extend = function () {
    var extended = {};
    var deep = false;
    var i = 0;
    var length = arguments.length;

    if (Object.prototype.toString.call(arguments[0]) === '[object Boolean]') {
      deep = arguments[0];
      i++;
    }

    var merge = function merge(obj) {
      for (var prop in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, prop)) {
          if (deep && Object.prototype.toString.call(obj[prop]) === '[object Object]') extended[prop] = $ARX.extend(true, extended[prop], obj[prop]);else extended[prop] = obj[prop];
        }
      }
    };

    for (; i < length; i++) {
      var obj = arguments[i];
      merge(obj);
    }

    return extended;
  }; // Error


  $ARX.error = function (exception) {
    throw exception;
  }; // Inherit


  $ARX.inherit = function (current, parent) {
    var F = function F() {};

    F.prototype = parent;
    var f = new F();

    for (var prop in current.prototype) {
      if (current.prototype.__lookupGetter__(prop)) f.__defineGetter__(prop, current.prototype.__lookupGetter__(prop));else f[prop] = current.prototype[prop];
    }

    current.prototype = f;
    current.prototype["super"] = parent;
    return current;
  }; // Lang


  $ARX.addLang = function (lang, obj) {
    if (typeof $ARX.lang[lang] === 'undefined') $ARX.lang[lang] = {};
    $ARX.lang[lang] = $ARX.extend(true, $ARX.lang[lang], obj);
  };

  ArticleEditor.opts = {
    plugins: [],
    content: false,
    placeholder: false,
    css: false,
    custom: {
      css: false,
      js: false
    },
    editor: {
      classname: 'entry',
      focus: false,
      sync: true,
      drop: true,
      lang: 'en',
      add: 'top',
      padding: true,
      markup: 'paragraph',
      mobile: 400,
      scrollTarget: window,
      direction: 'ltr',
      spellcheck: true,
      grammarly: false,
      notranslate: false,
      minHeight: '100px',
      // string, '500px'
      maxHeight: false,
      // string, '500px'
      doctype: '<!doctype html>'
    },
    selection: {
      multiple: true
    },
    control: true,
    source: true,
    image: {
      states: true,
      upload: false,
      url: true,
      select: false,
      name: 'file',
      data: false,
      drop: true,
      multiple: true,
      clipboard: true,
      types: ['image/*'],
      tag: 'figure',
      // p, div, figure
      newtab: false,
      link: true
    },
    classes: false,
    codemirrorSrc: false,
    codemirror: false,
    state: {
      limit: 100
    },
    path: {
      title: '## editor.title ##',
      sticky: true,
      stickyMinHeight: 200,
      // pixels
      stickyTopOffset: 0 // number

    },
    autosave: {
      url: false,
      name: false,
      data: false
    },
    paste: {
      clean: true,
      autolink: true,
      paragraphize: true,
      plaintext: false,
      linkTarget: false,
      images: true,
      links: true,
      keepStyle: [],
      keepClass: [],
      keepAttrs: ['td', 'th'],
      formTags: ['form', 'input', 'button', 'select', 'textarea', 'legend', 'fieldset'],
      blockTags: ['pre', 'div', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'table', 'tbody', 'thead', 'tfoot', 'th', 'tr', 'td', 'ul', 'ol', 'li', 'blockquote', 'p', 'hr', 'figure', 'iframe', 'figcaption', 'address', 'section', 'header', 'footer', 'aside', 'article'],
      inlineTags: ['a', 'svg', 'img', 'br', 'strong', 'ins', 'code', 'del', 'span', 'samp', 'kbd', 'sup', 'sub', 'mark', 'var', 'cite', 'small', 'b', 'u', 'em', 'i', 'abbr']
    },
    clean: {
      comments: false,
      enter: true,
      enterinline: false
    },
    tab: {
      key: true,
      spaces: false // true or number of spaces

    },
    topbar: {
      undoredo: false,
      shortcuts: true
    },
    toolbar: {
      sticky: true,
      stickyMinHeight: 200,
      // pixels
      stickyTopOffset: 0 // number

    },
    buttons: {
      editor: {
        add: {
          command: 'addbar.popup',
          title: '## buttons.add ##'
        },
        template: {
          title: '## buttons.templates ##',
          command: 'template.popup',
          observer: 'template.observe'
        },
        mobile: {
          title: '## buttons.mobile-view ##',
          command: 'editor.toggleView'
        },
        html: {
          title: '## buttons.html ##',
          command: 'source.toggle'
        }
      },
      topbar: {
        undo: {
          title: '## buttons.undo ##',
          command: 'buffer.undo'
        },
        redo: {
          title: '## buttons.redo ##',
          command: 'buffer.redo'
        },
        shortcut: {
          title: '## buttons.shortcuts ##',
          observer: 'shortcut.observe',
          command: 'shortcut.popup'
        }
      },
      except: false,
      add: false,
      tags: {
        'b': ['bold'],
        'strong': ['bold'],
        'i': ['italic'],
        'em': ['italic'],
        'del': ['deleted'],
        'a': ['link']
      },
      types: false,
      hidden: {}
    },
    card: {
      classname: 'card',
      template: '<div class="card"><div class="card-head"><h3>Card title</h3></div><div class="card-body"><p>Card body</p></div></div>'
    },
    text: {
      classname: 'arx-text'
    },
    noneditable: {
      classname: 'noneditable'
    },
    embed: {
      responsive: 'embed-responsive'
    },
    code: {
      template: '<pre></pre>',
      spaces: 4 // or false

    },
    line: true,
    layer: {
      template: '<div></div>'
    },
    table: {
      template: '<table><tr><td></td><td></td></tr><tr><td></td><td></td></tr></table>'
    },
    quote: {
      template: '<blockquote><p>Quote...</p><p><cite>Author Attribution</cite></p></blockquote>'
    },
    snippets: false,
    templates: false,
    grid: {
      classname: 'grid',
      classes: '',
      overlay: true,
      offset: {
        left: 0,
        right: 0
      },
      columns: 12,
      gutter: '1.25rem',
      patterns: {
        '6|6': 'column column-6|column column-6',
        '4|4|4': 'column column-4|column column-4|column column-4',
        '3|3|3|3': 'column column-3|column column-3|column column-3|column column-3',
        '2|2|2|2|2|2': 'column column-2|column column-2|column column-2|column column-2|column column-2|column column-2',
        '3|6|3': 'column column-3|column column-6|column column-3',
        '2|8|2': 'column column-2|column column-8|column column-2',
        '5|7': 'column column-5|column column-7',
        '7|5': 'column column-7|column column-5',
        '4|8': 'column column-4|column column-8',
        '8|4': 'column column-8|column column-4',
        '3|9': 'column column-3|column column-9',
        '9|3': 'column column-9|column column-3',
        '2|10': 'column column-2|column column-10',
        '10|2': 'column column-10|column column-2',
        '12': 'column column-12'
      }
    },
    link: {
      size: 30,
      nofollow: false,
      target: false
    },
    addbar: ['paragraph', 'image', 'embed', 'line', 'table', 'snippet', 'quote', 'code', 'grid', 'layer'],
    // text, card
    addbarAdd: [],
    addbarHide: [],
    format: ['p', 'h1', 'h2', 'h3', 'ul', 'ol'],
    // h4, h5, h6,  dl, address, div (text)
    outset: {
      none: 'none',
      left: 'outset-left',
      both: 'outset-both',
      right: 'outset-right'
    },
    align: {
      left: 'align-left',
      center: 'align-center',
      right: 'align-right',
      justify: 'align-justify'
    },
    valign: {
      none: 'none',
      top: 'valign-top',
      middle: 'valign-middle',
      bottom: 'valign-bottom'
    },
    shortcutsBase: {
      'meta+z': '## shortcuts.meta-z ##',
      'meta+shift+z': '## shortcuts.meta-shift-z ##',
      'meta+a': '## shortcuts.meta-a ##',
      'meta+shift+a': '## shortcuts.meta-shift-a ##',
      'meta+click': '## shortcuts.meta-click ##'
    },
    shortcuts: {
      'ctrl+shift+d, meta+shift+d': {
        title: '## shortcuts.meta-shift-d ##',
        name: 'meta+shift+d',
        command: 'block.duplicate'
      },
      'ctrl+shift+up, meta+shift+up': {
        title: '## shortcuts.meta-shift-up ##',
        name: 'meta+shift+&uarr;',
        command: 'block.moveUp'
      },
      'ctrl+shift+down, meta+shift+down': {
        title: '## shortcuts.meta-shift-down ##',
        name: 'meta+shift+&darr;',
        command: 'block.moveDown'
      },
      'ctrl+shift+m, meta+shift+m': {
        title: '## shortcuts.meta-shift-m ##',
        name: 'meta+shift+m',
        command: 'inline.removeFormat'
      },
      'ctrl+b, meta+b': {
        title: '## shortcuts.meta-b ##',
        name: 'meta+b',
        command: 'inline.set',
        params: {
          tag: 'b'
        }
      },
      'ctrl+i, meta+i': {
        title: '## shortcuts.meta-i ##',
        name: 'meta+i',
        command: 'inline.set',
        params: {
          tag: 'i'
        }
      },
      'ctrl+u, meta+u': {
        title: '## shortcuts.meta-u ##',
        name: 'meta+u',
        command: 'inline.set',
        params: {
          tag: 'u'
        }
      },
      'ctrl+h, meta+h': {
        title: '## shortcuts.meta-h ##',
        name: 'meta+h',
        command: 'inline.set',
        params: {
          tag: 'sup'
        }
      },
      'ctrl+l, meta+l': {
        title: '## shortcuts.meta-l ##',
        name: 'meta+l',
        command: 'inline.set',
        params: {
          tag: 'sub'
        }
      },
      'ctrl+alt+0, meta+alt+0': {
        title: '## shortcuts.meta-alt-0 ##',
        name: 'meta+alt+0',
        command: 'block.format',
        params: {
          tag: 'p'
        }
      },
      'ctrl+alt+1, meta+alt+1': {
        title: '## shortcuts.meta-alt-1 ##',
        name: 'meta+alt+1',
        command: 'block.format',
        params: {
          tag: 'h1'
        }
      },
      'ctrl+alt+2, meta+alt+2': {
        title: '## shortcuts.meta-alt-2 ##',
        name: 'meta+alt+2',
        command: 'block.format',
        params: {
          tag: 'h2'
        }
      },
      'ctrl+alt+3, meta+alt+3': {
        title: '## shortcuts.meta-alt-3 ##',
        name: 'meta+alt+3',
        command: 'block.format',
        params: {
          tag: 'h3'
        }
      },
      'ctrl+alt+4, meta+alt+4': {
        title: '## shortcuts.meta-alt-4 ##',
        name: 'meta+alt+4',
        command: 'block.format',
        params: {
          tag: 'h4'
        }
      },
      'ctrl+alt+5, meta+alt+5': {
        title: '## shortcuts.meta-alt-5 ##',
        name: 'meta+alt+5',
        command: 'block.format',
        params: {
          tag: 'h5'
        }
      },
      'ctrl+alt+6, meta+alt+6': {
        title: '## shortcuts.meta-alt-6 ##',
        name: 'meta+alt+6',
        command: 'block.format',
        params: {
          tag: 'h6'
        }
      },
      'ctrl+shift+7, meta+shift+7': {
        title: '## shortcuts.meta-shift-7 ##',
        name: 'meta+shift+7',
        command: 'block.format',
        params: {
          tag: 'ol'
        }
      },
      'ctrl+shift+8, meta+shift+8': {
        title: '## shortcuts.meta-shift-8 ##',
        name: 'meta+shift+8',
        command: 'block.format',
        params: {
          tag: 'ul'
        }
      },
      'ctrl+], meta+]': {
        title: '## shortcuts.meta-indent ##',
        name: 'meta+]',
        command: 'list.indent'
      },
      'ctrl+[, meta+[': {
        title: '## shortcuts.meta-outdent ##',
        name: 'meta+[',
        command: 'list.outdent'
      },
      'ctrl+k, meta+k': {
        title: '## shortcuts.meta-k ##',
        name: 'meta+k',
        command: 'link.format'
      }
    },
    // private
    markerChar: "\uFEFF",
    tags: {
      denied: ['font', 'html', 'head', 'link', 'title', 'body', 'meta', 'applet', 'marquee'],
      incode: ['!DOCTYPE', '!doctype', 'html', 'head', 'link', 'title', 'body', 'meta', 'textarea', 'style'],
      form: ['form', 'input', 'button', 'select', 'textarea', 'legend', 'fieldset'],
      inline: ['a', 'svg', 'span', 'strong', 'strike', 'b', 'u', 'em', 'i', 'code', 'del', 'ins', 'samp', 'kbd', 'sup', 'sub', 'mark', 'var', 'cite', 'small', 'abbr'],
      block: ['pre', 'hr', 'ul', 'ol', 'li', 'p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'dl', 'dt', 'dd', 'div', 'table', 'tbody', 'thead', 'tfoot', 'tr', 'th', 'td', 'blockquote', 'output', 'figcaption', 'figure', 'address', 'main', 'section', 'header', 'footer', 'aside', 'article', 'iframe'],
      parser: ['pre', 'hr', 'ul', 'ol', 'dl', 'p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'div', 'table', 'address', 'blockquote', 'figure', 'main', 'section', 'header', 'footer', 'aside', 'article', 'iframe']
    },
    bsmodal: false,
    regex: {
      youtube: /https?:\/\/(?:[0-9A-Z-]+\.)?(?:youtu\.be\/|youtube\.com\S*[^\w-\s])([\w-]{11})(?=[^\w-]|$)(?![?=&+%\w.-]*(?:['"][^<>]*>|<\/a>))[?=&+%\w.-]*/gi,
      vimeo: /(http|https)?:\/\/(?:www.|player.)?vimeo.com\/(?:channels\/(?:\w+\/)?|groups\/(?:[^/]*)\/videos\/|album\/(?:\d+)\/video\/|video\/|)(\d+)(?:\/[a-zA-Z0-9_-]+)?/gi,
      imageurl: /((https?|www)[^\s]+\.)(jpe?g|png|gif)(\?[^\s-]+)?/gi,
      url: /https?:\/\/(www\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()@:%_+.~#?&//=]*)/gi
    },
    addbarExtend: {},
    addbarObj: {
      paragraph: {
        title: '## blocks.paragraph ##',
        command: 'block.add'
      },
      image: {
        title: '## blocks.image ##',
        command: 'image.popup',
        observer: 'image.observe'
      },
      embed: {
        title: '## blocks.embed ##',
        command: 'embed.popup',
        observer: 'embed.observe'
      },
      line: {
        title: '## blocks.line ##',
        command: 'block.add',
        observer: 'block.observe'
      },
      table: {
        title: '## blocks.table ##',
        command: 'table.add',
        observer: 'table.observe'
      },
      snippet: {
        title: '## blocks.snippet ##',
        command: 'snippet.popup',
        observer: 'snippet.observe'
      },
      quote: {
        title: '## blocks.quote ##',
        command: 'block.add',
        observer: 'block.observe'
      },
      text: {
        title: '## blocks.text ##',
        command: 'block.add'
      },
      code: {
        title: '## blocks.code ##',
        command: 'block.add',
        observer: 'block.observe'
      },
      grid: {
        title: '## blocks.grid ##',
        command: 'grid.popup',
        observer: 'grid.observe'
      },
      layer: {
        title: '## blocks.layer ##',
        command: 'block.add',
        observer: 'block.observe'
      },
      card: {
        title: '## blocks.card ##',
        command: 'block.add'
      }
    },
    nested: [],
    parser: {},
    parserTags: [],
    formatObj: {
      p: {
        title: '## blocks.paragraph ##',
        type: 'paragraph',
        shortcut: 'Ctrl+Alt+0'
      },
      div: {
        title: '## blocks.text ##',
        type: 'text'
      },
      h1: {
        title: '<span style="font-size: 20px; font-weight: bold;">## headings.h1 ##</span>',
        type: 'heading',
        shortcut: 'Ctrl+Alt+1'
      },
      h2: {
        title: '<span style="font-size: 16px; font-weight: bold;">## headings.h2 ##</span>',
        type: 'heading',
        shortcut: 'Ctrl+Alt+2'
      },
      h3: {
        title: '<span style="font-weight: bold;">## headings.h3 ##</span>',
        type: 'heading',
        shortcut: 'Ctrl+Alt+3'
      },
      h4: {
        title: '<span style="font-weight: bold;">## headings.h4 ##</span>',
        type: 'heading',
        shortcut: 'Ctrl+Alt+4'
      },
      h5: {
        title: '<span style="font-weight: bold;">## headings.h5 ##</span>',
        type: 'heading',
        shortcut: 'Ctrl+Alt+5'
      },
      h6: {
        title: '<span style="font-weight: bold;">## headings.h6 ##</span>',
        type: 'heading',
        shortcut: 'Ctrl+Alt+6'
      },
      ul: {
        title: '&bull; ## list.unordered-list ##',
        type: 'list',
        shortcut: 'Ctrl+Shift+7'
      },
      ol: {
        title: '1. ## list.ordered-list ##',
        type: 'list',
        shortcut: 'Ctrl+Shift+8'
      },
      dl: {
        title: '## blocks.dlist ##',
        type: 'dlist'
      },
      address: {
        title: '<em>## blocks.address ##</em>',
        type: 'address'
      }
    }
  };
  ArticleEditor.lang['en'] = {
    "accessibility": {
      "help-label": "Rich text editor"
    },
    "editor": {
      "title": "Article",
      "multiple": "Multiple"
    },
    "placeholders": {
      "figcaption": "Type caption (optional)",
      "text": "Type something...",
      "code": "Edit to add code...",
      "layer": "Press enter to add a new text..."
    },
    "popup": {
      "link": "Link",
      "add": "Add",
      "grid": "Grid",
      "back": "Back",
      "image": "Image",
      "snippets": "Snippets",
      "add-image": "Add Image"
    },
    "shortcuts": {
      "meta-a": "Select text in the block",
      "meta-shift-a": "Select all blocks",
      "meta-click": "Select multiple blocks",
      "meta-z": "Undo",
      "meta-shift-z": "Redo",
      "meta-shift-m": "Remove inline format",
      "meta-b": "Bold",
      "meta-i": "Italic",
      "meta-u": "Underline",
      "meta-h": "Superscript",
      "meta-l": "Subscript",
      "meta-k": "Link",
      "meta-alt-0": "Normal text",
      "meta-alt-1": "Heading 1",
      "meta-alt-2": "Heading 2",
      "meta-alt-3": "Heading 3",
      "meta-alt-4": "Heading 4",
      "meta-alt-5": "Heading 5",
      "meta-alt-6": "Heading 6",
      "meta-shift-7": "Ordered List",
      "meta-shift-8": "Unordered List",
      "meta-indent": "Indent",
      "meta-outdent": "Outdent",
      "meta-shift-backspace": "Delete block",
      "meta-shift-d": "Duplicate block",
      "meta-shift-up": "Move line up",
      "meta-shift-down": "Move line down"
    },
    "headings": {
      "h1": "Large Heading",
      "h2": "Medium Heading",
      "h3": "Small Heading",
      "h4": "Heading 4",
      "h5": "Heading 5",
      "h6": "Heading 6"
    },
    "inline": {
      "bold": "Bold",
      "italic": "Italic",
      "deleted": "Deleted"
    },
    "list": {
      "unordered-list": "Unordered List",
      "ordered-list": "Ordered List",
      "indent": "Indent",
      "outdent": "Outdent"
    },
    "link": {
      "link": "Link",
      "edit-link": "Edit link",
      "unlink": "Unlink",
      "link-in-new-tab": "Open link in new tab",
      "save": "Save",
      "insert": "Insert",
      "cancel": "Cancel",
      "text": "Text",
      "url": "URL"
    },
    "table": {
      "width": "Width",
      "nowrap": "Nowrap",
      "save": "Save",
      "cancel": "Cancel",
      "table-cell": "Table Cell",
      "add-head": "Add head",
      "remove-head": "Remove head",
      "add-row-below": "Add row below",
      "add-row-above": "Add row above",
      "remove-row": "Remove row",
      "add-column-after": "Add column after",
      "add-column-before": "Add column before",
      "remove-column": "Remove column"
    },
    "image": {
      "or": "or",
      "alt-text": "Alt Text",
      "save": "Save",
      "link": "Link",
      "delete": "Delete",
      "cancel": "Cancel",
      "insert": "Insert",
      "caption": "Caption",
      "link-in-new-tab": "Open link in new tab",
      "url-placeholder": "Paste url of image...",
      "upload-new-placeholder": "Drag to upload a new image<br>or click to select"
    },
    "code": {
      "code": "Code",
      "insert": "Insert",
      "save": "Save",
      "cancel": "Cancel"
    },
    "embed": {
      "embed": "Embed",
      "caption": "Caption",
      "insert": "Insert",
      "save": "Save",
      "cancel": "Cancel",
      "description": "Paste any embed/html code or enter the url (vimeo or youtube video only)",
      "responsive-video": "Responsive video"
    },
    "upload": {
      "placeholder": "Drag to upload <br>or click to select"
    },
    "templates": {
      "templates": "Templates"
    },
    "snippets": {
      "snippets": "Snippets"
    },
    "form": {
      "link": "Link",
      "url": "Url",
      "text": "Text",
      "name": "Name",
      "alt-text": "Alt Text",
      "image": "Image",
      "upload": "Upload",
      "alignment": "Alignment",
      "outset": "Outset",
      "valign": "Valign"
    },
    "buttons": {
      "mobile-view": "Mobile View",
      "cancel": "Cancel",
      "insert": "Insert",
      "unlink": "Unlink",
      "save": "Save",
      "add": "Add",
      "transform-to-text": "Transform to text",
      "align": "Alignment",
      "valign": "Valign",
      "outset": "Outset",
      "indent": "Indent",
      "outdent": "Outdent",
      "head": "Head",
      "row": "Row",
      "cell": "Cell",
      "html": "HTML",
      "templates": "Templates",
      "shortcuts": "Keyboard Shortcuts",
      "format": "Format",
      "bold": "Bold",
      "italic": "Italic",
      "deleted": "Deleted",
      "underline": "Underline",
      "table": "Table",
      "link": "Link",
      "undo": "Undo",
      "redo": "Redo",
      "style": "Style",
      "config": "Config",
      "settings": "Settings",
      "text": "Text",
      "embed": "Embed",
      "grid": "Grid",
      "image": "Image",
      "list": "List",
      "delete": "Delete",
      "duplicate": "Duplicate",
      "sort": "Sort",
      "edit": "Edit",
      "inline": "Inline"
    },
    "blocks": {
      "noneditable": "Noneditable",
      "paragraph": "Paragraph",
      "heading": "Heading",
      "image": "Image",
      "figcaption": "Figcaption",
      "embed": "Embed",
      "line": "Line",
      "code": "Code",
      "quote": "Quote",
      "quoteitem": "Paragraph",
      "snippet": "Snippet",
      "column": "Column",
      "grid": "Grid",
      "list": "List",
      "table": "Table",
      "layer": "Layer",
      "row": "Row",
      "text": "Text",
      "cell": "Cell",
      "dlist": "Definition List",
      "address": "Address",
      "form": "Form",
      "card": "Card"
    }
  };

  var App = function App($element, settings, uuid) {
    // environment
    var maps = ['keycodes', 'prefix', 'dom', 'ajax', '_repository', '_subscribe'];

    for (var i = 0; i < maps.length; i++) {
      this[maps[i]] = $ARX[maps[i]];
    }

    this.uuid = uuid;
    this.$win = this.dom(window);
    this.$doc = this.dom(document);
    this.$body = this.dom('body');
    this.$element = $element;
    this.app = this; // initial

    this.initialSettings = settings; // starter

    this._initer = ['setting', 'lang'];
    this._priority = ['container', 'editor', 'accessibility', 'state'];
    this._plugins = []; // started

    this.started = false; // start

    this.start();
  };

  App.prototype = {
    // start
    start: function start(settings) {
      if (!this.isTextarea()) return;
      if (this.isStarted()) return;
      if (settings) this.initialSettings = settings; // core

      this._initCore();

      this._plugins = this.setting.get('plugins'); // starting

      this.broadcast('app.before.start'); // init

      this._initModules();

      this._initPlugins(); // start


      this._startPriority();

      this._startModules();

      this._startPlugins();

      this.started = true; // started

      this.broadcast('app.start'); // call load methods

      this._loadModulesAndPlugins();
    },
    isStarted: function isStarted() {
      return this.started;
    },
    isTextarea: function isTextarea() {
      return this.$element.get().tagName === 'TEXTAREA';
    },
    // stop
    stop: function stop() {
      if (this.isStopped()) return; // stopping

      this.broadcast('app.before.stop');

      this._stopPriority();

      this._stopModules();

      this._stopPlugins();

      this.started = false; // stopped

      this.broadcast('app.stop');
    },
    isStopped: function isStopped() {
      return !this.started;
    },
    // textarea
    // broadcast
    broadcast: function broadcast(name, params) {
      var event = params instanceof App.Event ? params : new App.Event(name, params);

      if (typeof this._subscribe[name] !== 'undefined') {
        var events = this._subscribe[name];

        for (var i = 0; i < events.length; i++) {
          var instance = this[events[i].module];

          if (instance) {
            events[i].func.call(instance, event);
          }
        }
      } // callbacks


      var callbacks = this.setting.has('subscribe') ? this.setting.get('subscribe') : {};

      if (typeof callbacks[name] === 'function') {
        callbacks[name].call(this, event);
      }

      return event;
    },
    broadcastParams: function broadcastParams(name, params) {
      var event = this.broadcast(name, params);
      return event.getAll();
    },
    broadcastHtml: function broadcastHtml(name, html) {
      var event = this.broadcast(name, {
        html: html
      });
      return event.get('html');
    },
    // create
    create: function create(name) {
      if (typeof this._repository[name] === 'undefined') {
        $ARX.error('The class "' + name + '" does not exist.');
      }

      var args = [].slice.call(arguments, 1);
      var instance = new this._repository[name].proto(); // extend

      instance._name = name;
      instance.app = this;
      var maps = ['uuid', 'prefix', 'dom', 'ajax'];

      for (var i = 0; i < maps.length; i++) {
        instance[maps[i]] = this[maps[i]];
      } // lang & settings


      if (this.lang) instance.lang = this.lang;
      if (this.opts) instance.opts = this.opts; // init

      var result;

      if (instance.init) {
        result = instance.init.apply(instance, args);
      }

      return result ? result : instance;
    },
    // api
    api: function api(name) {
      var args = [].slice.call(arguments, 1);
      var namespaces = name.split(".");
      var func = namespaces.pop();
      var context = this;

      for (var i = 0; i < namespaces.length; i++) {
        context = context[namespaces[i]];
      }

      if (context && typeof context[func] === 'function') {
        return context[func].apply(context, args);
      }
    },
    // init
    _initCore: function _initCore() {
      for (var i = 0; i < this._initer.length; i++) {
        this[this._initer[i]] = this.create(this._initer[i]);
      } // opts


      if (this.setting) {
        this.opts = this.setting.dump();
      }
    },
    _initModules: function _initModules() {
      for (var key in this._repository) {
        if (this._repository[key].type === 'module' && this._initer.indexOf(key) === -1) {
          this[key] = this.create(key);
        }
      }
    },
    _initPlugins: function _initPlugins() {
      var plugins = this.setting.get('plugins');

      for (var key in this._repository) {
        if (this._repository[key].type === 'plugin' && plugins.indexOf(key) !== -1) {
          this[key] = this.create(key);
        }
      }
    },
    // start
    _startPriority: function _startPriority() {
      for (var i = 0; i < this._priority.length; i++) {
        this._call(this[this._priority[i]], 'start');
      }
    },
    _startModules: function _startModules() {
      this._iterate('module', 'start');
    },
    _startPlugins: function _startPlugins() {
      this._iterate('plugin', 'start');
    },
    // stop
    _stopPriority: function _stopPriority() {
      var priority = this._priority.slice().reverse();

      for (var i = 0; i < priority.length; i++) {
        this._call(this[priority[i]], 'stop');
      }
    },
    _stopModules: function _stopModules() {
      this._iterate('module', 'stop');
    },
    _stopPlugins: function _stopPlugins() {
      this._iterate('plugin', 'stop');
    },
    // load
    _loadModulesAndPlugins: function _loadModulesAndPlugins() {
      this._iterate('module', 'load');

      this._iterate('plugin', 'load');
    },
    // iterate
    _iterate: function _iterate(type, method) {
      for (var key in this._repository) {
        var isIn = type === 'module' ? method === 'load' || this._priority.indexOf(key) === -1 : this._plugins.indexOf(key) !== -1;

        if (this._repository[key].type === type && isIn) {
          this._call(this[key], method);
        }
      }
    },
    // call
    _call: function _call(instance, method) {
      if (typeof instance[method] === 'function') {
        instance[method].apply(instance);
      }
    }
  };

  App.Event = function (name, params) {
    // local
    this.name = name;
    this.params = typeof params === 'undefined' ? {} : params;
    this.stopped = false;
  };

  App.Event.prototype = {
    is: function is(name) {
      if (Array.isArray(name)) {
        for (var i = 0; i < name.length; i++) {
          if (this.params[name[i]]) {
            return true;
          }
        }
      } else {
        return this.get(name);
      }
    },
    has: function has(name) {
      return typeof this.params[name] !== 'undefined';
    },
    getAll: function getAll() {
      return this.params;
    },
    get: function get(name) {
      return this.params[name];
    },
    set: function set(name, value) {
      this.params[name] = value;
    },
    stop: function stop() {
      this.stopped = true;
    },
    isStopped: function isStopped() {
      return this.stopped;
    }
  };
  ArticleEditor.add('mixin', 'block', {
    defaults: {
      id: {
        getter: 'getId',
        setter: 'setId'
      },
      html: {
        getter: 'getHtml',
        setter: 'setHtml'
      },
      align: {
        getter: 'getAlign',
        setter: 'setAlign'
      },
      valign: {
        getter: 'getValign',
        setter: 'setValign'
      },
      outset: {
        getter: 'getOutset',
        setter: 'setOutset'
      }
    },
    init: function init(source) {
      this.$block = source ? this.dom(source) : this.create(); // build & render

      this._build();

      this._buildData();

      this._render();
    },
    // is
    isBlock: function isBlock() {
      return true;
    },
    isAllowedButton: function isAllowedButton(name, obj) {
      // type
      var type = this.getType(); // hidden

      if (typeof this.opts.buttons.hidden[name] !== 'undefined') {
        var val = this.opts.buttons.hidden[name];

        if (val === true) {
          return false;
        } else if (Array.isArray(val) && val.indexOf(type) !== -1) {
          return false;
        }
      } // all


      if (typeof obj.blocks === 'undefined') {
        return true;
      }

      var blocks = obj.blocks; // except

      if (blocks.except && blocks.except.indexOf(type) !== -1) {
        return false;
      } // array of elements


      if (Array.isArray(blocks.types) && blocks.types.indexOf(type) !== -1) {
        return true;
      }

      if (blocks.all) {
        // editable
        if (blocks.all === true || blocks.all === 'all') {
          return true;
        } else if (blocks.all === 'editable' && this.isEditable()) {
          return true;
        } else if (blocks.all === 'first-level' && this.isFirstLevel()) {
          return true;
        } else if (blocks.all === 'noneditable' && !this.isEditable()) {
          return true;
        }
      }

      return false;
    },
    isFirstLevel: function isFirstLevel() {
      return this.$block.attr('data-' + this.prefix + '-first-level');
    },
    isEditable: function isEditable() {
      return typeof this.editable !== 'undefined' && this.editable === true;
    },
    isInlineBlock: function isInlineBlock() {
      return typeof this.inline !== 'undefined';
    },
    isAllSelected: function isAllSelected() {
      if (this.isEditable()) {
        return this.app.selection.isAll(this.$block);
      } else {
        return true;
      }
    },
    isEmpty: function isEmpty() {
      if (this.isEmptiable()) {
        if (this.$block.hasClass(this.prefix + '-empty-layer')) {
          return true;
        } else {
          var html = this.$block.html();
          html = html.trim();
          html = this._cleanEmpty(html);
          return html === '';
        }
      } else if (this.isEditable()) {
        return this._isEmpty();
      }
    },
    isEmptiable: function isEmptiable() {
      return typeof this.emptiable !== 'undefined';
    },
    isCaretStart: function isCaretStart() {
      if (this.getType() === 'code') {
        return this.app.caret.is(this.$block, 'start', false, false);
      } else if (this.isEditable()) {
        return this.app.caret.is(this.$block, 'start');
      }

      return true;
    },
    isCaretEnd: function isCaretEnd() {
      if (this.getType() === 'code') {
        return this.app.caret.is(this.$block, 'end', false, false);
      } else if (this.isEditable()) {
        return this.app.caret.is(this.$block, 'end');
      }

      return true;
    },
    // get
    getData: function getData(name) {
      var data = {};

      for (var key in this.data) {
        data[key] = this[this.data[key].getter].apply(this);
      }

      return name ? data[name] : data;
    },
    getType: function getType() {
      return this.type;
    },
    getTag: function getTag() {
      return this.$block ? this.$block.get().tagName.toLowerCase() : false;
    },
    getTitle: function getTitle() {
      var type = this.getType();
      var titles = this.lang.get('blocks');
      var title = this.$block.attr('data-title');
      return typeof titles[type] !== 'undefined' ? titles[type] : title;
    },
    getOffset: function getOffset() {
      var offset = this.app.editor.getFrame().offset();
      var elOffset = this.$block.offset();
      return {
        top: offset.top + elOffset.top,
        left: offset.left + elOffset.left
      };
    },
    getBlock: function getBlock() {
      return this.$block;
    },
    getHtml: function getHtml() {
      return this.$block.html();
    },
    getPlainText: function getPlainText() {
      var html = this.$block.html();
      return this.app.content.getTextFromHtml(html, {
        nl: true
      });
    },
    getOuterHtml: function getOuterHtml() {
      return this.$block.get().outerHTML;
    },
    getParents: function getParents(types) {
      var selector = '[' + this.opts.names.datatype + '=' + types.join('],[' + this.opts.names.datatype + '=') + ']';
      return this.$block.parents(selector);
    },
    getParent: function getParent(type) {
      type = type ? '=' + type : '';
      var $el = this.$block.parent().closest('[data-' + this.prefix + '-type' + type + ']');

      if ($el.length !== 0) {
        return $el.dataget('instance');
      }

      return false;
    },
    getNext: function getNext(type) {
      type = type ? '=' + type : '';
      var $el = this.$block.nextElement();

      if ($el.length !== 0 && $el.is('[data-' + this.prefix + '-type' + type + ']')) {
        return $el.dataget('instance');
      }

      return false;
    },
    getPrev: function getPrev(type) {
      type = type ? '=' + type : '';
      var $el = this.$block.prevElement();

      if ($el.length !== 0 && $el.is('[data-' + this.prefix + '-type' + type + ']')) {
        return $el.dataget('instance');
      }

      return false;
    },
    getChildFirst: function getChildFirst(type) {
      type = type ? '=' + type : '';
      var $el = this.$block.find('[data-' + this.prefix + '-type' + type + ']').first();

      if ($el.length !== 0) {
        return $el.dataget('instance');
      }

      return false;
    },
    getChildLast: function getChildLast(type) {
      type = type ? '=' + type : '';
      var $el = this.$block.find('[data-' + this.prefix + '-type' + type + ']').last();

      if ($el.length !== 0) {
        return $el.dataget('instance');
      }

      return false;
    },
    getId: function getId() {
      return this.$block.attr('id');
    },
    getAlign: function getAlign() {
      var obj = this.opts.align;
      if (!obj) return false;
      var value = 'left';

      for (var key in obj) {
        if (this.$block.hasClass(obj[key])) {
          value = key;
        }
      }

      return value;
    },
    getValign: function getValign() {
      var obj = this.opts.valign;
      if (!obj) return false;
      var value = 'none';

      for (var key in obj) {
        if (this.$block.hasClass(obj[key])) {
          value = key;
        }
      }

      return value;
    },
    getOutset: function getOutset() {
      var obj = this.opts.outset;
      if (!obj) return false;
      var value = 'none';

      for (var key in obj) {
        if (this.$block.hasClass(obj[key])) {
          value = key;
        }
      }

      return value;
    },
    getCaption: function getCaption() {
      var $caption = this.$block.find('figcaption');
      return $caption.length !== 0 ? $caption.html() : '';
    },
    // set
    setData: function setData(data) {
      for (var key in data) {
        if (!this.data[key]) continue;
        this[this.data[key].setter].call(this, data[key]);
      }
    },
    setEmpty: function setEmpty() {
      this.$block.html('');

      if (this.isEmptiable()) {
        this.app.content.addEmptyButton(this.$block);
      }
    },
    setSelectAll: function setSelectAll() {
      if (this.isEditable()) {
        this.app.selection.select(this.$block);
      }
    },
    setHtml: function setHtml(html) {
      this.$block.html(html);

      if (html !== '') {
        this._buildInstancesInside(this.$block);
      }
    },
    setId: function setId(value) {
      if (value === '') {
        this.$block.removeAttr('id');
      } else {
        this.$block.attr('id', value);
      }
    },
    setAlign: function setAlign(value) {
      this._removeObjClasses(this.opts.align);

      this.$block.addClass(this.opts.align[value]);
    },
    setValign: function setValign(value) {
      this._removeObjClasses(this.opts.valign);

      if (value !== 'none') {
        this.$block.addClass(this.opts.valign[value]);
      }
    },
    setOutset: function setOutset(value) {
      this._removeObjClasses(this.opts.outset);

      if (value !== 'none') {
        this.$block.addClass(this.opts.outset[value]);
      } // ui


      this.app.control.updatePosition();
    },
    setCaption: function setCaption(value) {
      if (value === '') {
        this.$block.find('figcaption').remove();
      } else {
        var $caption = this.$block.find('figcaption');

        if ($caption.length === 0) {
          $caption = this.dom('<figcaption>');
          $caption.attr('data-placeholder', this.lang.get('placeholders.figcaption'));
          this.$block.append($caption); // create

          this.app.create('block.figcaption', $caption);
        }

        $caption.html(value);
      }
    },
    // has
    hasClass: function hasClass(value) {
      value = typeof value === 'string' ? [value] : value;

      for (var i = 0; i < value.length; i++) {
        if (this.$block.hasClass(value[i])) {
          return value[i];
        }
      }

      return false;
    },
    // remove
    remove: function remove() {
      var parent = this.getParent();
      this.$block.remove(); // emptiable

      if (parent && parent.isEmptiable() && parent.isEmpty()) {
        parent.setEmpty();
      }
    },
    // duplicate
    duplicate: function duplicate(empty) {
      var type = this.getType();
      var $clone = this.$block.clone();
      $clone.removeClass(this.prefix + '-block-focus ' + this.prefix + '-block-multiple-hover');

      if (empty) {
        $clone.html('');
      }

      return this.app.create('block.' + type, $clone);
    },
    duplicateEmpty: function duplicateEmpty() {
      return this.duplicate(true);
    },
    // insert
    insertEmpty: function insertEmpty(params) {
      params = params || {};
      params.instance = this.app.block.create();
      return this.insert(params);
    },
    insert: function insert(params) {
      var defs = {
        instance: false,
        position: false,
        caret: false
      }; // params

      var p = $ARX.extend({}, defs, params);
      var $block = p.instance.getBlock(); // delete selection

      if (this.isEditable()) {
        this.app.selection.deleteContents();
      } // list to list


      if (p.instance.getType() === 'list' && this.getType() === 'list') {
        this.app.insertion.insertListToList($block, this.$block, p.caret);
      } else {
        // variable to variable
        if (p.instance.isInlineBlock() && this.isInlineBlock()) {
          this.$block.after($block);
          this.$block.remove();
        } // like variable
        else if (p.instance.isInlineBlock() && this.isEditable()) {
            this.app.insertion.insertNode(p.instance.getBlock(), 'end', true);
          } // editable
          else if (this.isEditable() && this.getType() !== 'card') {
              // detect position
              p.position = this.app.insertion.detectPosition(this.$block, p.position); // insert

              if (p.position === 'split') {
                this.app.element.split(this.$block).before($block);
              } else {
                this.$block[p.position]($block); // remove

                if (this.isEmpty()) {
                  this.$block.remove();
                }
              }
            } // non editable
            else {
                p.position = p.position || 'after';
                this.$block[p.position]($block);
              } // set caret


        if (p.caret) {
          this.app.block.set(p.instance, p.caret);
        } // rebuild


        this.app.editor.build();
        this.app.toolbar.observe(); // broadcast

        this.app.broadcast('block.add', {
          instance: p.instance
        });
        return p.instance;
      }
    },
    // append
    appendNext: function appendNext() {
      var next = this.getNext(); // next empty

      if (next.isEmpty()) {
        next.remove();
        return;
      } // current empty
      else if (this.isEmpty()) {
          this.remove();
          this.app.block.set(next, 'start');
          return;
        } // not empty


      var html = next.getHtml();
      var type = this.getType();
      var nextType = next.getType();
      var insert = true;
      var remove = true; // code

      if (type === 'code' && nextType !== 'code') {
        html = next.getPlainText();
      } // next type


      if (nextType === 'dlist') {
        if (type === 'dlist') {
          // append as nodes
          var nodes = next.getBlock().children();
          this.$block.append(nodes);
          insert = false;
        } else {
          // insert with br
          html = next.getPlainText(true);
        }
      } else if (nextType === 'list') {
        if (type === 'list') {
          var $items = next.getBlock().children();
          this.$block.append($items);
          insert = false;
          remove = true;
        } else {
          html = this._appendListHtml(next.getBlock(), html);
          remove = next.isEmpty();
        }
      } // append


      if (insert) {
        // set caret after inline
        var inline = this.app.selection.getTopInline();

        if (inline) {
          this.app.caret.set(inline, 'after');
        } // insert


        this.app.insertion.insertHtml(html, 'start');

        this._buildInstancesInside(this.$block);
      } // remove


      if (remove) {
        next.remove();
      }
    },
    appendToPrev: function appendToPrev() {
      var prev = this.getPrev(); // current empty

      if (this.isEmpty()) {
        this.remove();
        this.app.block.set(prev, 'end');
        return;
      } // prev empty
      else if (prev.isEmpty()) {
          prev.remove();
          this.app.control.updatePosition();
          return;
        } // not empty


      var prevType = prev.getType();
      var html = this.getHtml();
      var type = this.getType();
      var insert = true;
      var remove = true; // code

      if (type !== 'code' && prevType === 'code') {
        html = this.getPlainText();
      } // current type


      if (type === 'dlist') {
        if (prevType === 'dlist') {
          // append as nodes
          var nodes = this.getBlock().children();
          this.app.block.set(prev, 'end');
          prev.getBlock().append(nodes);
          insert = false;
        } else {
          // insert with br
          html = this.getPlainText(true);
        }
      } else if (type === 'list') {
        if (prevType === 'list') {
          var $items = this.getBlock().children();
          this.app.block.set(prev, 'end');
          prev.getBlock().append($items);
          insert = false;
          remove = true;
        } else {
          html = this._appendListHtml(this.getBlock(), html);
          remove = this.isEmpty();
        }
      } // append


      if (insert) {
        // set
        this.app.block.set(prev, 'end'); // set caret after inline

        var inline = this.app.selection.getTopInline();

        if (inline) {
          this.app.caret.set(inline, 'after');
        } // insert


        this.app.insertion.insertHtml(html, 'start');

        this._buildInstancesInside(prev.getBlock());
      } // remove


      if (remove) {
        this.remove();
      }
    },
    append: function append(instance, set) {
      if (this.isEmptiable() && this.isEmpty()) {
        this.$block.html('');
        this.$block.removeClass(this.prefix + '-empty-layer');
      }

      this.$block.append(instance.getBlock());

      if (set !== false) {
        this.app.block.set(instance);
      } // broadcast


      this.app.broadcast('block.add', {
        instance: instance
      });
    },
    // change
    change: function change(newInstance, broadcast) {
      var $newBlock = newInstance.getBlock();
      this.$block.after($newBlock);
      this.$block.remove(); // rebuild

      this.app.editor.build();
      this.app.toolbar.observe(); // set

      this.app.block.set(newInstance); // broadcast

      if (broadcast !== false) {
        this.app.broadcast('block.change', {
          instance: newInstance
        });
      }
    },
    // move
    moveUp: function moveUp() {
      var target = this.getPrev();
      if (!target) return;

      this._move(target, 'before');
    },
    moveDown: function moveDown(direction) {
      var target = this.getNext();
      if (!target) return;

      this._move(target, 'after');
    },
    // private
    _appendListHtml: function _appendListHtml($target, html) {
      var $item = $target.find('li').first();
      html = $item.html().trim();
      html = html.replace(/<\/li>/gi, '</li><br>');
      html = html.replace(/<(ul|ol)/gi, '<br><$1');
      html = this.app.content.removeTags(html, ['ul', 'ol', 'li']);
      html = html.trim();
      html = html.replace(/<br\s?\/?>$/gi, '');
      $item.remove();
      return html;
    },
    _move: function _move(target, func) {
      // save selection
      if (this.isEditable()) this.app.selection.save(this.$block); // move

      var $targetBlock = target.getBlock();
      $targetBlock[func](this.$block, true); // set force

      this.app.block.set(this.$block, false, true); // restore selection

      if (this.isEditable()) this.app.selection.restore(this.$block);
    },
    _build: function _build() {
      // build empty
      if (this.isEmptiable() && this.isEmpty()) {
        this.app.content.addEmptyButton(this.$block);
      } // build


      if (this.build) {
        this.build();
      } // instances inside


      this._buildInstancesInside(this.$block);
    },
    _buildData: function _buildData() {
      if (!this.data) this.data = {};
      this.data = $ARX.extend({}, true, this.defaults, this.data);
    },
    _buildInstancesInside: function _buildInstancesInside($block) {
      $block.find('[data-' + this.prefix + '-type]').each(this._buildInstanceInside.bind(this));
    },
    _buildInstanceInside: function _buildInstanceInside($node) {
      var instance = $node.dataget('instance');

      if (!instance) {
        var type = $node.attr('data-' + this.prefix + '-type');
        this.app.create('block.' + type, $node);
      }
    },
    _buildItems: function _buildItems(selector, type) {
      var $items = this.$block.find(selector);

      if ($items.length !== 0) {
        $items.each(function ($node) {
          this.app.create('block.' + type, $node);
        }.bind(this));
      }
    },
    _buildCaption: function _buildCaption() {
      if (this.getTag() !== 'figure') return;
      this.$block.find('figcaption').attr('data-placeholder', this.lang.get('placeholders.figcaption'));
    },
    _isEmpty: function _isEmpty() {
      var html = this.$block.text();
      html = this._cleanEmpty(html);
      return html === '';
    },
    _getNameByTag: function _getNameByTag() {
      var tag = this.getTag();
      var name = this.app.utils.capitalize(tag);
      return name;
    },
    _render: function _render() {
      this._renderEdit();

      this._renderDraggable();

      this._renderEditable();
    },
    _renderDraggable: function _renderDraggable() {
      if (typeof this.draggable !== 'undefined' && this.draggable === false) {
        this.$block.on('dragstart', function (e) {
          e.preventDefault();
          return false;
        });
        this.$block.find('img').on('dragstart', function (e) {
          e.preventDefault();
          return false;
        });
      }
    },
    _renderEditable: function _renderEditable() {
      if (this.isEditable()) {
        this.$block.attr('contenteditable', true);
      } else if (typeof this.editable !== 'undefined' && this.editable === false) {
        this.$block.attr('contenteditable', false);
      }

      if (this.isEditable() && !this.opts.editor.grammarly) this.$block.attr('data-gramm_editor', false);
    },
    _renderEdit: function _renderEdit() {
      this.$block.dataset('instance', this);
      this.$block.attr('data-' + this.prefix + '-type', this.getType());
    },
    _cleanEmpty: function _cleanEmpty(html) {
      html = this.app.utils.removeInvisibleChars(html);
      html = html.search(/^<br\s?\/?>$/) !== -1 ? '' : html;
      html = html.replace(/\n/g, '');
      return html;
    },
    _removeObjClasses: function _removeObjClasses(obj) {
      var classes = this._buildObjClasses(obj);

      this.$block.removeClass(classes.join(' '));
      this.app.element.removeEmptyAttrs(this.$block, ['class']);
    },
    _buildObjClasses: function _buildObjClasses(obj) {
      var classes = [];

      for (var key in obj) {
        if (obj[key]) {
          classes.push(obj[key]);
        }
      }

      return classes;
    }
  });
  ArticleEditor.add('mixin', 'tool', {
    init: function init(name, obj, stack, data, instance) {
      this.name = name;
      this.setter = stack.setter;
      this.stack = stack;
      this.data = data;
      this.instance = instance;
      this.obj = this._observe(obj);

      if (this.obj) {
        this._build();
      }
    },
    getElement: function getElement() {
      return this.$tool;
    },
    getInput: function getInput() {
      return this.$input;
    },
    getValue: function getValue() {
      var value = this.$input.val();
      return value.trim();
    },
    setValue: function setValue(value) {
      this.$input.val(value);
    },
    setFocus: function setFocus() {
      this.$input.focus();
    },
    trigger: function trigger(value) {
      this.setValue(value);

      if (this.setter) {
        this.app.api(this.setter, this.stack);
      }
    },
    // private
    _build: function _build() {
      this._buildTool();

      this._buildLabel();

      this._buildInputElement();

      this._buildInput();

      this._buildEvent(); // props


      if (this._has('placeholder')) this.$input.attr('placeholder', this.lang.parse(this.obj.placeholder));
      if (this._has('width')) this.$input.css('width', this.obj.width);
      if (this._has('classname')) this.$input.addClass(this.obj.classname);
    },
    _buildInputElement: function _buildInputElement() {
      this.$input = this.dom('<' + this._getInputParam('tag') + '>').addClass(this.prefix + this._getInputParam('classname'));
      this.$input.attr({
        'name': this.name,
        'type': this._getInputParam('type'),
        'data-type': this.type
      });
      this.$input.dataset('instance', this);
    },
    _buildInput: function _buildInput() {
      return;
    },
    _buildEvent: function _buildEvent() {
      var types = ['segment'];

      if (types.indexOf(this.type) === -1 && this.setter) {
        var events = this.type === 'checkbox' || this.type === 'select' ? 'change' : 'keydown blur';
        this.$input.on(events, this._catchSetter.bind(this));
      }
    },
    _buildTool: function _buildTool() {
      this.$tool = this.dom('<div>').addClass(this.prefix + '-form-item').dataset('instance', this);
    },
    _buildLabel: function _buildLabel() {
      if (this.type !== 'checkbox' && this._has('label')) {
        this.$label = this.dom('<label>').addClass(this.prefix + '-form-label').html(this.lang.parse(this.obj.label));
        this.$tool.append(this.$label);
      }
    },
    _getInputParam: function _getInputParam(name) {
      return this.input && typeof this.input[name] !== 'undefined' ? this.input[name] : '';
    },
    _get: function _get(name) {
      return this.obj[name];
    },
    _has: function _has(name) {
      return this.obj.hasOwnProperty(name);
    },
    _observe: function _observe(obj) {
      if (obj.hasOwnProperty('observer')) {
        obj = this.app.api(obj.observer, obj, this.name);
      }

      return obj;
    },
    _catchSetter: function _catchSetter(e) {
      if (e.type === 'keydown' && e.which !== 13) return;
      if (e.type === 'keydown') e.preventDefault(); // call setter

      this.app.api(this.setter, this.stack);
    }
  });
  ArticleEditor.add('module', 'lang', {
    init: function init() {
      this.langKey = this.app.setting.get('editor.lang');
      this.vars = this._build();
    },
    get: function get(name) {
      var value = this._get(name, this.vars);

      if (typeof value === 'undefined' && this.langKey !== 'en') {
        value = this._get(name, $ARX.lang['en']);
      }

      return typeof value === 'undefined' ? '' : value;
    },
    parse: function parse(str) {
      if (typeof str !== 'string') return str;
      var matches = str.match(/## (.*?) ##/g);

      if (matches) {
        for (var i = 0; i < matches.length; i++) {
          var key = matches[i].replace(/^##\s/g, '').replace(/\s##$/g, '');
          str = str.replace(matches[i], this.get(key));
        }
      }

      return str;
    },
    // private
    _get: function _get(name, vars) {
      var value;
      var arr = name.split('.');
      if (arr.length === 1) value = vars[name];else value = typeof vars[arr[0]] !== 'undefined' ? vars[arr[0]][arr[1]] : undefined;
      return value;
    },
    _build: function _build() {
      var vars = $ARX.lang['en'];

      if (this.langKey !== 'en') {
        vars = $ARX.lang[this.langKey] !== 'undefined' ? $ARX.lang[this.langKey] : vars;
      }

      return vars;
    }
  });
  ArticleEditor.add('module', 'setting', {
    init: function init() {
      this.opts = this._build();
    },
    dump: function dump() {
      return this.opts;
    },
    has: function has(name) {
      var value;
      var arr = name.split('.');
      if (arr.length === 1) value = typeof this.opts[name] !== 'undefined';else value = typeof this.opts[arr[0]] !== 'undefined' && typeof this.opts[arr[1]] !== 'undefined';
      return value;
    },
    set: function set(section, name, value) {
      if (typeof this.opts[section] === 'undefined') this.opts[section] = {};
      if (typeof value === 'undefined') this.opts[section] = name;else this.opts[section][name] = value;
    },
    get: function get(name) {
      var value;
      var arr = name.split('.');
      if (arr.length === 1) value = this.opts[name];else value = typeof this.opts[arr[0]] !== 'undefined' ? this.opts[arr[0]][arr[1]] : undefined;
      return value;
    },
    // private
    _build: function _build() {
      var opts = $ARX.extend(true, {}, $ARX.opts, this.app.initialSettings);
      opts = $ARX.extend(true, opts, $ARX.settings);
      return opts;
    }
  });
  ArticleEditor.add('module', 'container', {
    init: function init() {
      this.containers = {
        main: ['bars', 'editor', 'source', 'statusbar'],
        bars: ['pathbar', 'toolbar']
      };
    },
    start: function start() {
      this._buildMain();

      this._buildContainers(this.$main, this.containers.main);

      this._buildBSModal();
    },
    stop: function stop() {
      this.$main.remove();
    },
    get: function get(name) {
      return this['$' + name];
    },
    // private
    _buildMain: function _buildMain() {
      this.$main = this.dom('<div>');
      this.$main.addClass(this.prefix + '-container ' + this.prefix + '-container-' + this.uuid);
      this.$main.attr(this.prefix + '-uuid', this.uuid); // place

      this.app.$element.after(this.$main);
    },
    _buildContainers: function _buildContainers($target, containers) {
      for (var i = 0; i < containers.length; i++) {
        var name = containers[i];
        var elName = '$' + name; // create

        this[elName] = this._createContainer(name); // nested

        if (typeof this.containers[name] !== 'undefined') {
          this._buildContainers(this[elName], this.containers[name]);
        } // append


        $target.append(this[elName]);
      }
    },
    _buildBSModal: function _buildBSModal() {
      this.opts.bsmodal = this.$main.closest('.modal-dialog').length !== 0;
    },
    _createContainer: function _createContainer(name) {
      return this.dom('<div>').addClass(this.prefix + '-' + name + '-container');
    }
  });
  ArticleEditor.add('module', 'editor', {
    init: function init() {
      this.mobileMode = false;
    },
    start: function start() {
      this._buildFrame();

      this._buildBlurClass();

      this._buildOptions();

      this._buildParserTags();

      this._buildStartHtml();

      this._buildLayout();

      this._buildContent();
    },
    stop: function stop() {
      this.$editor = false;
      this.app.$element.show();
    },
    load: function load() {
      this._setFocusOnStart();
    },
    build: function build() {
      this.app.embed.build();
      this.app.blocks.build();
      this.app.image.observeStates();
    },
    // insert
    insertContent: function insertContent(params) {
      this.app.insertion.insertContent(params);
    },
    // set
    setContent: function setContent(params) {
      this.app.insertion.setContent(params);
    },
    setEmpty: function setEmpty() {
      this.app.insertion.setContent({
        html: ''
      });
    },
    setFocus: function setFocus(caret) {
      if (caret) {
        this._setFocusCaret(caret);
      } else {
        this._setFocusEvent();
      }
    },
    setBlur: function setBlur() {
      if (!this.isFocus()) return;

      this._unsetFocusContainerClass();

      this._enableToolbarButtons();

      this.app.block.unset();
      this.app.blocks.unset();
      this.app.selection.removeAllRanges(); // ui

      if (!this.isMobileView()) {
        this.app.path.build();
        this.app.toolbar.build();
        this.app.control.close();
      }

      this.app.popup.close(false); // broadcast

      this.app.broadcast('editor.blur');
    },
    // select
    selectAll: function selectAll(type) {
      if (this.isAllSelected()) return;

      this._setSelectAllClass();

      this.app.blocks.unset();
      this.app.blocks.setFirstLevel();
      this.app.selection.removeAllRanges(); // ui

      this.app.path.build();
      this.app.toolbar.build();
      this.app.control.close();
    },
    // unselect
    unselectAll: function unselectAll() {
      if (!this.isAllSelected()) return;
      this.unsetSelectAllClass();
      this.app.block.unset();
      this.app.blocks.unset();
    },
    // unset
    unsetSelectAllClass: function unsetSelectAllClass() {
      this.$editor.removeClass(this.prefix + '-select-all');
    },
    // add
    addButton: function addButton(name, obj) {
      this.opts.buttons.editor[name] = obj;
    },
    // get
    getButtons: function getButtons() {
      var buttons = this.opts.buttons.editor;
      var res = {};

      for (var name in buttons) {
        if (name === 'html' && !this.opts.source) continue;
        if (name === 'templates' && !this.opts.templates.json) continue;
        res[name] = buttons[name];
      }

      return res;
    },
    getContent: function getContent(tidy) {
      var html = '';

      if (this.app.source.is()) {
        html = this.app.source.getContent();
      } else {
        html = this._getContent();
        html = tidy ? this.app.tidy.parse(html) : html;
      } // decode href


      html = this.app.content.decodeHref(html);
      return html;
    },
    getFrameRect: function getFrameRect() {
      var offset = this.$editor.offset();
      var width = this.$editor.width();
      var height = this.$editor.height();
      var top = Math.round(offset.top);
      var left = Math.round(offset.left);
      return {
        top: top,
        left: left,
        bottom: top + height,
        right: left + width,
        width: width,
        height: height
      };
    },
    getFrame: function getFrame() {
      return this.$editor ? this.$editor : this.dom();
    },
    getLayout: function getLayout() {
      return this.$layout;
    },
    getHead: function getHead() {
      return this.getDoc().find('head');
    },
    getBody: function getBody() {
      return this.$editor ? this.getDoc().find('body') : this.dom();
    },
    getDoc: function getDoc() {
      return this.dom(this.getDocNode());
    },
    getDocNode: function getDocNode() {
      return this.$editor.get().contentWindow.document;
    },
    getWin: function getWin() {
      return this.dom(this.getWinNode());
    },
    getWinNode: function getWinNode() {
      return this.$editor.get().contentWindow;
    },
    // adjust
    adjustHeight: function adjustHeight() {
      if (!this.$editor) return;
      setTimeout(function () {
        this.$editor.height(this.getBody().height());
      }.bind(this), 1);
    },
    // toggle
    toggleView: function toggleView(button) {
      if (this.mobileMode) {
        this.$editor.css('width', '');
        this.app.path.enable();
        this.app.topbar.enable();
        this.app.toolbar.enable();
        this.app.toolbar.unsetToggled('mobile');
        this.app.event.run();
        this.app.blocks.runEditableBlocks();
        this.app.observer.build();
        this.mobileMode = false;
      } else {
        this.$editor.css('width', this.opts.editor.mobile + 'px');
        this.app.path.disable();
        this.app.topbar.disable();
        this.app.toolbar.disable();
        this.app.toolbar.setToggled('mobile');
        this.app.popup.close();
        this.app.control.close();
        this.app.event.pause();
        this.app.blocks.pauseEditableBlocks();
        this.app.observer.stop();
        this.mobileMode = true;
      }

      this.adjustHeight();
    },
    // is
    isLayout: function isLayout(el) {
      return this.dom(el).get() === this.$layout.get();
    },
    isTextarea: function isTextarea() {
      return this.opts.content === false;
    },
    isAllSelected: function isAllSelected() {
      return this.$editor.hasClass(this.prefix + '-select-all');
    },
    isFocus: function isFocus() {
      return this.app.container.get('main').hasClass(this.prefix + '-in-focus');
    },
    isEmpty: function isEmpty(emptyparagraph) {
      return this.app.content.isEmptyHtml(this.$layout.html(), emptyparagraph);
    },
    isMobileView: function isMobileView() {
      return this.mobileMode;
    },
    // build
    _buildFrame: function _buildFrame() {
      this.app.$element.hide();
      this.$editor = this.dom('<iframe>').addClass(this.prefix + '-editor-frame'); // append

      this.app.container.get('editor').append(this.$editor);
    },
    _buildBlurClass: function _buildBlurClass() {
      this.app.container.get('main').addClass(this.prefix + '-in-blur');
    },
    _buildOptions: function _buildOptions() {
      var $e = this.$editor;
      var o = this.opts.editor;
      $e.attr('dir', o.direction);
      $e.attr('scrolling', 'no');
      $e.css('visibility', 'hidden');
      if (o.minHeight) $e.css('min-height', o.minHeight);

      if (o.maxHeight) {
        $e.css('max-height', o.maxHeight);
        $e.attr('scrolling', 'yes');
      }

      if (o.notranslate) $e.addClass('notranslate');
      if (!o.spellcheck) $e.attr('spellcheck', false);
    },
    _buildStartHtml: function _buildStartHtml() {
      var doctype = this._createDoctype();

      var scripts = this._createScripts();

      var layout = '<div class="' + this.opts.editor.classname + '"></div>';
      var code = doctype + '<html><head></head><body>' + layout + scripts + '</body></html>'; // write code

      this._writeCode(code);
    },
    _buildLayout: function _buildLayout() {
      var $body = this.getBody();
      this.$layout = $body.find('.' + this.opts.editor.classname).first();
      this.$layout.attr('dir', this.opts.editor.direction);

      if (this.opts.editor.padding === false) {
        this.$layout.css('padding', 0);
      } // body height


      $body.css('height', 'auto');
    },
    _buildContent: function _buildContent() {
      var content = this._getContentValue();

      content = this.app.broadcastHtml('editor.before.load', content); // set parsed

      var $parsed = this.app.parser.parse(content);
      this.$layout.html($parsed.children()); // set unparsed

      var unparsed = this.app.parser.unparse(this.$layout.html());
      this.app.$element.val(unparsed); // load

      this._load();
    },
    _buildVisibility: function _buildVisibility() {
      this.$editor.css('visibility', 'visible');
    },
    _buildEditorCss: function _buildEditorCss() {
      if (!this.opts.css) return;
      var css;

      if (Array.isArray(this.opts.css)) {
        css = this.opts.css;
      } else {
        css = [this.opts.css + 'arx-frame.min.css', this.opts.css + 'arx-content.min.css'];
      }

      for (var i = 0; i < css.length; i++) {
        this._buildCssLink(css[i]);
      }
    },
    _buildCustomCss: function _buildCustomCss() {
      if (!this.opts.custom.css) return;

      for (var i = 0; i < this.opts.custom.css.length; i++) {
        this._buildCssLink(this.opts.custom.css[i]);
      }
    },
    _buildCssLink: function _buildCssLink(href) {
      var obj = _typeof(href) === 'object' ? href : {
        href: href
      };
      obj.href = obj.href + '?' + new Date().getTime(); // link tag

      var $css = this.dom('<link>').attr({
        'class': this.prefix + '-css',
        'rel': 'stylesheet'
      });
      $css.attr(obj); // append

      this.getHead().append($css);
    },
    _buildGridCssVar: function _buildGridCssVar() {
      if (!this.opts.grid) return;
      var style = this.getDocNode().documentElement.style;
      style.setProperty('--' + this.prefix + '-grid-columns', this.opts.grid.columns);
      style.setProperty('--' + this.prefix + '-grid-gutter', this.opts.grid.gutter);
      style.setProperty('--' + this.prefix + '-grid-offset-left', this.opts.grid.offset.left);
      style.setProperty('--' + this.prefix + '-grid-offset-right', this.opts.grid.offset.right); // patterns opts

      if (this.app.initialSettings.grid && this.app.initialSettings.grid.patterns) {
        this.opts.grid.patterns = this.app.initialSettings.grid.patterns;
      }
    },
    _buildParserTags: function _buildParserTags() {
      var parser = this.opts.parser;

      for (var key in parser) {
        // add tag
        if (parser[key].parse && parser[key].tag) {
          var tag = parser[key].tag;
          if (typeof this.opts.parserTags[tag] === 'undefined') this.opts.parserTags[tag] = [];
          this.opts.parserTags[tag].push(parser[key].parse);
        }
      }
    },
    _buildDraggable: function _buildDraggable() {
      var $items = this.app.$body.find('[data-' + this.prefix + '-drop-id]');
      $items.each(function ($node) {
        $node.attr('draggable', true);
        $node.on('dragstart', function (e) {
          var $target = this.dom(e.target);
          var id = $target.attr('data-' + this.prefix + '-drop-id');
          e.dataTransfer.setData('item', id);
        }.bind(this));
      }.bind(this));
    },
    // load
    _load: function _load() {
      try {
        this._loadImages();

        this._loaded();
      } catch (e) {
        $ARX.error(e);
      }
    },
    _loaded: function _loaded() {
      this.app.sync.build();
      this.app.observer.build();
      this.app.event.build();
      this.app.embed.build();
      this.app.blocks.build();
      this.app.image.observeStates();

      this._buildVisibility();

      this._buildEditorCss();

      this._buildCustomCss();

      this._buildGridCssVar();

      this._buildDraggable(); // adjust on resize


      this.getWin().on('resize.' + this.prefix + '-editor-frame', this.adjustHeight.bind(this)); // broadcast

      this.app.broadcast('editor.load'); // adjust height

      setTimeout(this.adjustHeight.bind(this), 1000);
      setTimeout(this.adjustHeight.bind(this), 3000);
    },
    _loadedImage: function _loadedImage() {
      this.imageslen--;
    },
    _loadImages: function _loadImages() {
      var $doc = this.getDoc();
      var $images = $doc.find('img');
      this.imageslen = $images.length;
      $images.each(this._loadImage.bind(this));
      var timerImg = setInterval(function () {
        if (this.imageslen === 0) {
          this.adjustHeight();
          clearInterval(timerImg);
          return;
        }
      }.bind(this), 50);
    },
    _loadImage: function _loadImage($img) {
      var img = $img.get();

      if (this.opts.editor.images) {
        var arr = img.src.split('/');
        var last = arr[arr.length - 1];
        img.src = this.opts.editor.images + last;
      }

      $img.one('load', this._loadedImage.bind(this));
    },
    // set
    _setFocusOnStart: function _setFocusOnStart() {
      if (!this.opts.editor.focus) return;
      this.setFocus();
      this.setFocus(this.opts.editor.focus);
    },
    _setSelectAllClass: function _setSelectAllClass() {
      this.$editor.addClass(this.prefix + '-select-all');
    },
    _setFocusCaret: function _setFocusCaret(caret) {
      caret = this._getCaretPosition(caret);

      var target = this._getFocusTarget(caret);

      this.app.block.set(target, caret);
    },
    _setFocusEvent: function _setFocusEvent() {
      if (this.isFocus()) return;

      for (var i = 0; i < $ARX.instances.length; i++) {
        if ($ARX.instances[i] !== this.app) {
          $ARX.instances[i].editor.setBlur();
        }
      }

      this._setFocusContainerClass(); // broadcast


      this.app.broadcast('editor.focus');
    },
    _setFocusContainerClass: function _setFocusContainerClass() {
      this.app.container.get('main').removeClass(this.prefix + '-in-blur').addClass(this.prefix + '-in-focus');
    },
    // unset
    _unsetFocusContainerClass: function _unsetFocusContainerClass() {
      this.app.container.get('main').removeClass(this.prefix + '-in-focus').addClass(this.prefix + '-in-blur');
    },
    // get
    _getCaretPosition: function _getCaretPosition(caret) {
      return caret === true ? 'start' : caret;
    },
    _getFocusTarget: function _getFocusTarget(caret) {
      return caret === 'start' ? this.app.blocks.getFirst() : this.app.blocks.getLast();
    },
    _getContent: function _getContent() {
      var html = this.$layout.html();
      html = this.app.parser.unparse(html);
      return html;
    },
    _getContentValue: function _getContentValue() {
      return this.opts.content ? this.opts.content : this.app.$element.val();
    },
    // enable
    _enableToolbarButtons: function _enableToolbarButtons() {
      if (this.app.source.is() || this.isMobileView()) return;
      this.app.toolbar.enable();
    },
    // write
    _writeCode: function _writeCode(html) {
      var doc = this.getDocNode();
      doc.open();
      doc.write(html);
      doc.close();
    },
    // create
    _createDoctype: function _createDoctype() {
      return this.opts.editor.doctype + '\n';
    },
    _createScripts: function _createScripts() {
      if (!this.opts.custom.js) return '';
      var str = '';
      var scripts = this.opts.custom.js;

      for (var i = 0; i < scripts.length; i++) {
        var obj = _typeof(scripts[i]) === 'object' ? scripts[i] : {
          src: scripts[i]
        };
        obj.src = obj.src + '?' + new Date().getTime(); // script tag

        var $el = this.dom('<script>').addClass(this.prefix + '-js').attr(obj); // all scripts str

        str = str + $el.get().outerHTML;
      }

      return str;
    }
  });
  ArticleEditor.add('module', 'source', {
    start: function start() {
      this.eventname = this.prefix + '-source-events';

      this._build();
    },
    toggle: function toggle() {
      if (this.is()) this.close();else this.open();
    },
    is: function is() {
      return this.app.container.get('source').css('display') !== 'none';
    },
    open: function open() {
      this.app.broadcast('source.before.open');
      var html = this.app.editor.getContent();
      html = this.app.tidy.parse(html);
      var height = this.app.container.get('editor').height();
      this.$source.height(height);
      this.$source.val(html);
      this.$source.on('input.' + this.eventname, this._handleChanges.bind(this));
      this.$source.on('keydown.' + this.eventname, this.app.input.handleTextareaTab.bind(this));
      this.app.editor.unselectAll();
      this.app.container.get('editor').hide();
      this.app.container.get('source').show(); // codemirror

      var codemirror = this.app.codemirror.create({
        el: this.$source,
        height: height,
        focus: true
      });

      if (codemirror) {
        codemirror.on('change', this._handleChanges.bind(this));
      } // ui


      this.app.path.disable();
      this.app.topbar.disable();
      this.app.toolbar.disable();
      this.app.toolbar.disableSticky();
      this.app.toolbar.setToggled('html'); // broadcast

      this.app.broadcast('source.open');
    },
    close: function close() {
      this.app.broadcast('source.before.close');
      var html = this.getContent();
      this.app.codemirror.destroy();
      this.$source.off('.' + this.eventname);
      this.app.container.get('source').hide();
      this.app.container.get('editor').show(); // set code

      this.app.editor.setContent({
        html: html,
        caret: false
      }); // ui

      this.app.path.enable();
      this.app.topbar.enable();
      this.app.toolbar.enable();
      this.app.toolbar.enableSticky();
      this.app.toolbar.unsetToggled('html'); // broadcast

      this.app.broadcast('source.close');
    },
    update: function update(html) {
      var func = this.app.editor.isTextarea() ? 'val' : 'html';
      this.app.$element[func](html);
    },
    getContent: function getContent() {
      var html = this.$source.val();
      html = this.app.codemirror.val(html);
      return html;
    },
    // private
    _build: function _build() {
      this.$source = this.dom('<textarea>').addClass(this.prefix + '-source');
      this.$source.attr('data-gramm_editor', false);
      this.app.container.get('source').append(this.$source);
    },
    _handleChanges: function _handleChanges(e) {
      var html = this.getContent();
      this.update(html);
      this.app.broadcast('source.change', {
        e: e
      });
    }
  });
  ArticleEditor.add('module', 'placeholder', {
    start: function start() {
      this.placeholder = false;
      this.$layout = this.app.editor.getLayout(); // build

      this._build();
    },
    handleClick: function handleClick(e) {
      if (this.dom(e.target).hasClass(this.prefix + '-placeholder')) {
        this.app.editor.setFocus('start');
      }
    },
    toggle: function toggle() {
      if (this.placeholder && this.app.editor.isEmpty(true)) {
        this.show();
      } else {
        this.hide();
      }
    },
    show: function show() {
      this.$layout.addClass(this.prefix + '-placeholder');
    },
    hide: function hide() {
      this.$layout.removeClass(this.prefix + '-placeholder');
    },
    // private
    _build: function _build() {
      var is = this.opts.placeholder !== false || this.app.$element.attr('placeholder');
      if (!is) return;
      var text = this.opts.placeholder !== false ? this.opts.placeholder : this.app.$element.attr('placeholder');
      this.$layout.attr('placeholder', text);
      this.placeholder = true;
      this.toggle();
    }
  });
  ArticleEditor.add('module', 'accessibility', {
    start: function start() {
      this._buildRole();

      this._buildLabel();
    },
    _buildRole: function _buildRole() {
      this.app.editor.getFrame().attr({
        'aria-labelledby': this.prefix + '-voice',
        'role': 'presentation'
      });
    },
    _buildLabel: function _buildLabel() {
      var html = this.lang.get('accessibility.help-label');

      var $label = this._createLabel(html); // append


      this.app.container.get('main').prepend($label);
    },
    _createLabel: function _createLabel(html) {
      return this.dom('<span />').addClass(this.prefix + '-voice-label').attr({
        'id': this.prefix + '-voice-' + this.uuid,
        'aria-hidden': false
      }).html(html);
    }
  });
  ArticleEditor.add('module', 'observer', {
    init: function init() {
      this.observer = false;
      this.trigger = true;
    },
    build: function build() {
      if (window.MutationObserver) {
        var el = this.app.editor.getLayout().get();
        this.observer = this._build(el);
        this.observer.observe(el, {
          attributes: true,
          subtree: true,
          childList: true,
          characterData: true,
          characterDataOldValue: true
        });
      }
    },
    stop: function stop() {
      if (this.observer) this.observer.disconnect();
      this.trigger = true;
    },
    // private
    _build: function _build(el) {
      var self = this;
      return new MutationObserver(function (mutations) {
        self._observe(mutations[mutations.length - 1], el);
      });
    },
    _observe: function _observe(mutation, el) {
      if (mutation.type === 'attributes' && mutation.target === el) {
        return;
      } // sync


      if (this.trigger) {
        this.app.editor.adjustHeight();
        this.app.broadcast('observer.change');
        this.app.placeholder.toggle();
        this.app.sync.trigger();
      }
    }
  });
  ArticleEditor.add('module', 'utils', {
    // invisible chars
    createInvisibleChar: function createInvisibleChar() {
      return document.createTextNode(this.opts.markerChar);
    },
    searchInvisibleChars: function searchInvisibleChars(str) {
      return str.search(/^\uFEFF$/g);
    },
    removeInvisibleChars: function removeInvisibleChars(str) {
      return str.replace(/\uFEFF/g, '');
    },
    // wrapper
    wrap: function wrap(html, func) {
      var $w = this.dom('<div>').html(html);
      func($w);
      html = $w.html();
      $w.remove();
      return html;
    },
    // arrays
    extendArray: function extendArray(arr, extend) {
      arr = arr.concat(arr);

      if (extend) {
        for (var i = 0; i < extend.length; i++) {
          arr.push(extend[i]);
        }
      }

      return arr;
    },
    removeFromArrayByValue: function removeFromArrayByValue(arr, val) {
      val = Array.isArray(val) ? val : [val];
      var index;

      for (var i = 0; i < val.length; i++) {
        index = arr.indexOf(val[i]);
        if (index > -1) arr.splice(index, 1);
      }

      return arr;
    },
    sumOfArray: function sumOfArray(arr) {
      return arr.reduce(function (a, b) {
        return parseInt(a) + parseInt(b);
      }, 0);
    },
    // object
    getObjectIndex: function getObjectIndex(obj, key) {
      return Object.keys(obj).indexOf(key);
    },
    insertToObject: function insertToObject(key, value, obj, pos) {
      return Object.keys(obj).reduce(function (ac, a, i) {
        if (i === pos) ac[key] = value;
        ac[a] = obj[a];
        return ac;
      }, {});
    },
    // random
    getRandomId: function getRandomId() {
      var id = '';
      var possible = 'abcdefghijklmnopqrstuvwxyz0123456789';

      for (var i = 0; i < 12; i++) {
        id += possible.charAt(Math.floor(Math.random() * possible.length));
      }

      return id;
    },
    // escape
    escapeRegExp: function escapeRegExp(s) {
      return s.replace(/[-/\\^$*+?.()|[\]{}]/g, '\\$&');
    },
    // string
    capitalize: function capitalize(str) {
      str = str.toLowerCase();
      return str.charAt(0).toUpperCase() + str.slice(1);
    },
    // data
    extendData: function extendData(data, obj) {
      for (var key in obj) {
        if (key === 'elements') {
          data = this._extendDataElements(data, obj[key]);
        } else {
          data = this._setData(data, key, obj[key]);
        }
      }

      return data;
    },
    _extendDataElements: function _extendDataElements(data, value) {
      this.dom(value).each(function ($node) {
        if ($node.get().tagName === 'FORM') {
          var serializedData = $node.serialize(true);

          for (var z in serializedData) {
            data = this._setData(data, z, serializedData[z]);
          }
        } else {
          var name = $node.attr('name') ? $node.attr('name') : $node.attr('id');
          data = this._setData(data, name, $node.val());
        }
      }.bind(this));
      return data;
    },
    _setData: function _setData(data, name, value) {
      if (data instanceof FormData) data.append(name, value);else data[name] = value;
      return data;
    }
  });
  ArticleEditor.add('module', 'content', {
    init: function init() {
      this._selectors = {
        code: ['pre', 'code'],
        embed: ['figure'],
        noneditable: ['.' + this.opts.noneditable.classname],
        images: ['img'],
        links: ['a']
      };
    },
    // paragraphize
    paragraphize: function paragraphize(html) {
      return this.app.paragraphizer.paragraphize(html);
    },
    // encode
    encodeEntities: function encodeEntities(str) {
      return this.decodeEntities(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
    },
    encodeCode: function encodeCode(html) {
      // replace all tags
      html = html.replace(/<(.*?)>/gi, 'xtagstartz$1xtagendz'); // revert pre / code

      html = html.replace(/xtagstartzpre(.*?)xtagendz/g, '<pre$1>');
      html = html.replace(/xtagstartzcode(.*?)xtagendz/g, '<code$1>');
      html = html.replace(/xtagstartz\/codextagendz/g, '</code>');
      html = html.replace(/xtagstartz\/prextagendz/g, '</pre>'); // encode

      html = this._encodeCode(html); // revert all tags

      html = html.replace(/xtagstartz(.*?)xtagendz/g, '<$1>');
      html = html.replace(/xtagstartz\/(.*?)xtagendz/g, '</$1>');
      return html;
    },
    // decode
    decodeEntities: function decodeEntities(str) {
      return String(str).replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&quot;/g, '"').replace(/&amp;/g, '&');
    },
    decodeHref: function decodeHref(html) {
      var pattern = "(href=\".*?)(&amp;)(.*?\">)";
      var matches = html.match(new RegExp(pattern, 'g'));

      if (matches !== null) {
        for (var i = 0; i < matches.length; i++) {
          html = html.replace(matches[i], matches[i].replace(/&amp;/g, '&'));
        }
      }

      return html;
    },
    // sanitize
    sanitize: function sanitize(html) {
      html = this.app.utils.wrap(html, function ($w) {
        $w.find('[src]').each(this._sanitizeSrc);
        $w.find('a').each(this._sanitizeHref);
        $w.find('a,b,i,svg,img,details').each(this._sanitizeEvents);
      }.bind(this));
      return html;
    },
    // escape
    escapeHtml: function escapeHtml(str) {
      return str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
    },
    // store / restore
    store: function store(html, name, stored, storedIndex) {
      var selectors = this._selectors[name];

      for (var i = 0; i < selectors.length; i++) {
        var matched = this._getElementsFromHtml(html, selectors[i]);

        html = this._store(html, name, matched, stored, storedIndex);
      }

      return html;
    },
    restore: function restore(html, name, stored) {
      if (typeof stored[name] === 'undefined') return html;

      for (var i = 0; i < stored[name].length; i++) {
        html = html.replace('####_' + name + i + '_####', stored[name][i]);
      }

      return html;
    },
    storeComments: function storeComments(html, storedComments) {
      var comments = html.match(new RegExp('<!--([\\w\\W]*?)-->', 'gi'));
      if (comments === null) return html;

      for (var i = 0; i < comments.length; i++) {
        html = html.replace(comments[i], '#####xstarthtmlcommentzz' + i + 'xendhtmlcommentzz#####');
        storedComments.push(comments[i]);
      }

      return html;
    },
    restoreComments: function restoreComments(html, storedComments) {
      for (var i = 0; i < storedComments.length; i++) {
        var str = storedComments[i].replace(/\$/gi, '&#36;');
        html = html.replace('#####xstarthtmlcommentzz' + i + 'xendhtmlcommentzz#####', str);
      }

      return html;
    },
    // cache / recache
    cacheStyle: function cacheStyle(html) {
      var selector = this.opts.tags.block.join(',') + ',img,' + this.opts.tags.inline.join(',');
      return this.app.utils.wrap(html, function ($w) {
        $w.find(selector).each(this._cacheStyle.bind(this));
      }.bind(this));
    },
    recacheStyle: function recacheStyle(html) {
      return this.app.utils.wrap(html, function ($w) {
        $w.find('[data-' + this.prefix + '-style-cache]').each(this._recacheStyle.bind(this));
      }.bind(this));
    },
    // add
    addNofollow: function addNofollow(html) {
      if (!this.opts.link.nofollow) return html;
      return this.app.utils.wrap(html, function ($w) {
        $w.find('a').attr('rel', 'nofollow');
      });
    },
    addHttps: function addHttps(html) {
      if (!this.opts.editor.https) {
        return html;
      }

      html = html.replace('href="http://', 'href="https://');
      html = html.replace('src="http://', 'src="https://');
      html = html.replace('srcset="http://', 'srcset="https://');
      return html;
    },
    addSpaceToBlocks: function addSpaceToBlocks(html) {
      return html.replace(/<\/(div|li|dt|dd|td|p|H[1-6])>\n?/gi, '</$1> ');
    },
    addBrToBlocks: function addBrToBlocks(html) {
      return html.replace(/<\/(div|li|dt|dd|td|p|H[1-6])>\n?/gi, '</$1><br>');
    },
    addEmptyButton: function addEmptyButton($el) {
      if ($el.hasClass(this.prefix + '-empty-layer')) return;
      $el.addClass(this.prefix + '-empty-layer');
      var $plus = this.dom('<span>').addClass(this.prefix + '-plus-button'); // button

      this.app.create('button', {
        name: 'plus',
        element: $plus
      }, {
        command: 'addbar.popup'
      }); // append

      $el.append($plus);
    },
    // fix
    fixListMargin: function fixListMargin($block) {
      var ml = parseInt($block.css('margin-left'));

      if (ml !== 0) {
        var pl = parseInt($block.css('padding-left'));
        $block.css({
          'margin-left': 0,
          'padding-left': pl + ml + 'px'
        });
        $block.attr(this.prefix + '-list-left', ml);
      }
    },
    unfixListMargin: function unfixListMargin($block) {
      if ($block.attr(this.prefix + '-list-left')) {
        $block.css({
          'padding-left': '',
          'margin-left': ''
        });
        $block.removeAttr(this.prefix + '-list-left');
      }
    },
    // get
    getText: function getText(n) {
      var rv = '';

      if (n.nodeType === 3) {
        rv = n.nodeValue;
      } else {
        for (var i = 0; i < n.childNodes.length; i++) {
          rv += this.getText(n.childNodes[i]);
        }

        var d = n.nodeType === 1 ? getComputedStyle(n).getPropertyValue('display') : '';

        if (d.match(/^block/) || d.match(/list/) || n.tagName === 'BR' || n.tagName === 'HR') {
          rv += "\n";
        }
      }

      return rv;
    },
    getTextFromHtml: function getTextFromHtml(html, params) {
      var stored = {};
      var storedIndex = 0;
      var defaults = {
        br: false,
        nl: false,
        trimlines: true,
        images: false,
        links: false
      };
      params = $ARX.extend({}, defaults, params);
      html = this.store(html, 'code', stored, storedIndex);
      html = params.links ? this.store(html, 'links', stored, storedIndex) : html;
      html = params.images ? this.store(html, 'images', stored, storedIndex) : html;
      html = html.replace(/<(ul|ol)>\s+<li>/gi, '<$1><li>');
      html = html.replace(/<li[^>]*>\n/gi, '<li$1>');
      html = html.replace(/<p[^>]*>(\s+|)<\/p>/gi, 'xemptyz');
      html = html.replace(/<!--[\s\S]*?-->/gi, '');
      html = html.replace(/<style[\s\S]*?style>/gi, '');
      html = html.replace(/<script[\s\S]*?script>/gi, '');
      html = html.replace(/<\/(div|li|dt|dd|td|p|H[1-6])>\n?/gi, '</$1>\n');
      html = html.replace(/&(lt|gt);/gi, 'x$1z');
      var $tmp = this.dom('<div>').html(html);
      html = this.getText($tmp.get()); // trim lines

      if (params.trimlines) {
        var str = '';
        var arr = html.split("\n");

        for (var i = 0; i < arr.length; i++) {
          str += arr[i].trim() + '\n';
        }

        html = str;
      }

      html = html.replace(/[\n]+/g, "\n");
      html = html.replace('xemptyz', "\n");
      html = html.replace(/x(lt|gt)z/gi, '&$1;'); // keep newlines

      if (params.br) {
        html = html.replace(/\n/g, "<br>\n");
        html = html.replace(/<br\s?\/?>\n?$/gi, '');
      } else {
        html = params.nl ? html : html.replace(/\n/gi, ' ');
      }

      html = this.restore(html, 'code', stored);
      html = params.links ? this.restore(html, 'links', stored) : html;
      html = params.images ? this.restore(html, 'images', stored) : html;
      html = html.replace(/<pre[^>]*>/g, '');
      html = html.replace(/<code[^>]*>/g, '');
      html = html.replace(/<\/pre>\n?/g, '');
      html = html.replace(/<\/code>/g, '');

      if (!params.images) {
        html = html.replace(/<img[\s\S]*?>/gi, '');
        html = html.replace(/<a[^>]*>(\s+|)<\/a>/gi, '');
      }

      return html.trim();
    },
    // extract
    extractHtmlFromCaret: function extractHtmlFromCaret(el) {
      var node = this.dom(el).get();
      var range = this.app.selection.getRange();

      if (range) {
        var cloned = range.cloneRange();
        cloned.selectNodeContents(node);
        cloned.setStart(range.endContainer, range.endOffset);
        return cloned.extractContents();
      }
    },
    // is
    isEmptyHtml: function isEmptyHtml(html, emptyparagraph) {
      html = html.trim();
      html = this.app.utils.removeInvisibleChars(html);
      html = html.replace(/^&nbsp;$/gi, '1');
      html = html.replace(/&nbsp;/gi, '');
      html = html.replace(/<\/?br\s?\/?>/g, '');
      html = html.replace(/\s/g, '');
      html = html.replace(/^<p>\s\S<\/p>$/i, '');
      html = html.replace(/<hr(.*?[^>])>$/i, 'hr');
      html = html.replace(/<iframe(.*?[^>])>$/i, 'iframe');
      html = html.replace(/<source(.*?[^>])>$/i, 'source'); // remove comments

      html = this.removeComments(html); // remove empty tags

      html = emptyparagraph ? html.replace(/<p[^>]*><\/p>/gi, '') : html;
      html = html.replace(/<[^/>]><\/[^>]+>/gi, '');
      html = html.replace(/<[^/>]><\/[^>]+>/gi, ''); // trim

      html = html.trim();
      return html === '';
    },
    isLine: function isLine(html) {
      var element = document.createElement("div");
      element.innerHTML = html;
      return this.dom(element).find(this.opts.tags.block.join(',') + ',img').length === 0;
    },
    // drop
    drop: function drop(e, html, position, cleanDrop) {
      var target = this.app.element.getDataBlock(e.target);
      target = target.length === 0 ? this.app.blocks.getFirst() : target; // set target

      this.app.block.set(target); // drop point

      if (!position) {
        this.app.insertion.insertPoint(e);
      }

      var clean = true;
      var parse = true;
      var instance = this.app.block.get();
      var isAll = this.app.editor.isAllSelected();

      if (instance && instance.getType() === 'code' && !isAll) {
        clean = false;
        parse = false;
        html = this.getTextFromHtml(html, {
          nl: true,
          trimlines: false
        });
      }

      if (cleanDrop === false) {
        clean = false;
      } // empty


      if (html === '') {
        return;
      } // autolink


      html = clean ? this.app.autolink.parse(html) : html; // insert

      return this.app.insertion.insertContent({
        html: html,
        clean: clean,
        parse: parse,
        position: position
      });
    },
    // paste
    paste: function paste(e) {
      // broadcast
      var event = this.app.broadcast('editor.before.paste', {
        e: e
      });
      if (event.isStopped()) return e.preventDefault();
      e.preventDefault();
      var clipboard = e.clipboardData; // image

      if (this.app.image.insertFromClipboard(clipboard)) {
        return;
      } // html / text


      var url = clipboard.getData('URL');
      var html = this.app.clipboard.getContent(clipboard); // get safari anchor links

      html = !url || url === '' ? html : url; // clean

      var instance = this.app.block.get();
      var clean = true;
      var parse = true;
      var isAll = this.app.editor.isAllSelected();

      if (this.opts.paste.plaintext) {
        clean = false;
        parse = false;
        html = this.getTextFromHtml(html, {
          br: true
        });
      } else if (instance && instance.getType() === 'code' && !isAll) {
        clean = false;
        parse = false;
        html = this.getTextFromHtml(html, {
          nl: true,
          trimlines: false
        });
      } // empty


      if (html === '') {
        return;
      } // autolink


      html = clean ? this.app.autolink.parse(html) : html; // insert

      var inserted = this.app.insertion.insertContent({
        html: html,
        clean: clean,
        parse: parse
      }); // broadcast

      this.app.broadcast('editor.paste', inserted);
    },
    // copy
    copy: function copy(e) {
      this._copy(e, 'copy');
    },
    // cut
    cut: function cut(e) {
      this._copy(e, 'cut');
    },
    // remove
    removeDoctype: function removeDoctype(html) {
      return html.replace(new RegExp("<!doctype[^>]*>", 'gi'), '');
    },
    removeComments: function removeComments(html) {
      return html.replace(/<!--[\s\S]*?-->\n?/g, '');
    },
    removeTags: function removeTags(input, denied) {
      var re = denied ? /<\/?([a-z][a-z0-9]*)\b[^>]*>/gi : /(<([^>]+)>)/gi;
      var replacer = !denied ? '' : function ($0, $1) {
        return denied.indexOf($1.toLowerCase()) === -1 ? $0 : '';
      };
      return input.replace(re, replacer);
    },
    removeTagsExcept: function removeTagsExcept(input, except) {
      if (except === undefined) {
        return input.replace(/(<([^>]+)>)/gi, '');
      }

      var tags = /<\/?([a-z][a-z0-9]*)\b[^>]*>/gi;
      return input.replace(tags, function ($0, $1) {
        return except.indexOf($1.toLowerCase()) === -1 ? '' : $0;
      });
    },
    removeTagsWithContent: function removeTagsWithContent(html, tags) {
      return this.app.utils.wrap(html, function ($w) {
        $w.find(tags.join(',')).remove();
      });
    },
    removeMarkers: function removeMarkers(html) {
      return this.app.utils.wrap(html, function ($w) {
        $w.find('.' + this.prefix + '-plus-button').remove();
        $w.find('.' + this.prefix + 'pastemarker').removeClass(this.prefix + 'pastemarker');
        $w.find('.' + this.prefix + 'pasteitems').removeClass(this.prefix + 'pasteitems');
        $w.find('.' + this.prefix + '-selection-marker').remove();
      }.bind(this));
    },
    removeEmptySpans: function removeEmptySpans(html) {
      return this.app.utils.wrap(html, function ($w) {
        $w.find('span').each(this._removeEmptySpan.bind(this));
      }.bind(this));
    },
    removeEmptyInlines: function removeEmptyInlines(html) {
      return this.app.utils.wrap(html, function ($w) {
        $w.find(this.opts.tags.inline.join(',')).each(this._removeEmptyTag.bind(this));
      }.bind(this));
    },
    removeEmptyAttrs: function removeEmptyAttrs(html, attrs) {
      return this.app.utils.wrap(html, function ($w) {
        for (var i = 0; i < attrs.length; i++) {
          $w.find('[' + attrs[i] + '=""]').removeAttr(attrs[i]);
        }
      });
    },
    removeBlockTags: function removeBlockTags(html, tags, except) {
      var blocks = this.opts.tags.block.concat(); // except

      if (except) {
        blocks = this.app.utils.removeFromArrayByValue(blocks, except);
      } // extend


      if (tags) {
        tags = tags ? this.app.utils.extendArray(blocks, tags) : blocks;
      }

      return this.removeTags(html, tags);
    },
    removeBlockTagsInside: function removeBlockTagsInside(html, tags) {
      this.blockListTags = this.app.utils.removeFromArrayByValue(this.opts.tags.block.concat(), ['ul', 'ol', 'li']);
      return this.app.utils.wrap(html, function ($w) {
        $w.find(tags.join(',')).each(this._removeBlockTagsInside.bind(this));
      }.bind(this));
    },
    removeInlineStyles: function removeInlineStyles(html) {
      var inlines = this.app.utils.removeFromArrayByValue(this.opts.tags.inline, 'a');
      return this.app.utils.wrap(html, function ($w) {
        $w.find(inlines.join(',')).removeAttr('style');
      });
    },
    removeStyleAttr: function removeStyleAttr(html, filter) {
      filter = filter || '';
      return this.app.utils.wrap(html, function ($w) {
        $w.find('*').not('[data-' + this.prefix + '-style-cache]' + filter).removeAttr('style');
      }.bind(this));
    },
    // private
    _cacheStyle: function _cacheStyle($el) {
      var name = 'data-' + this.prefix + '-style-cache';
      var style = $el.attr('style');

      if (style) {
        style = style.replace(/"/g, '');
        $el.attr(name, style);
      } else if (!style || style === '') {
        $el.removeAttr(name);
      }
    },
    _recacheStyle: function _recacheStyle($el) {
      var name = 'data-' + this.prefix + '-style-cache';
      var style = $el.attr(name);
      $el.attr('style', style).removeAttr(name);
    },
    // clean
    _cleanEmpty: function _cleanEmpty(html) {
      html = html.trim();
      html = this.app.utils.removeInvisibleChars(html);
      html = html.replace(/<\/?br\s?\/?>/g, '');
      html = html.replace(/\s/g, '');
      return html;
    },
    // copy
    _copyFromAllSelected: function _copyFromAllSelected(name, html) {
      html = this.app.editor.getLayout().html(); // set empty

      if (name === 'cut') this.app.editor.setEmpty();
      return html;
    },
    _copyFromMultiple: function _copyFromMultiple(name, html) {
      var $blocks = this.app.blocks.getSelected();
      var $tmp = this.dom('<div>');
      $blocks.each(function ($node) {
        $tmp.append($node.clone());
      });
      html = $tmp.html(); // remove selected blocks

      if (name === 'cut') this.app.blocks.removeSelected(false);
      return html;
    },
    _copyFromEditable: function _copyFromEditable(name, html, instance) {
      var type = instance.getType();

      if (type === 'figcaption' || type === 'cell') {
        html = this.app.selection.getHtml(); // delete selection

        if (name === 'cut') {
          this.app.selection.deleteContents();
        }
      } else if (instance.isAllSelected()) {
        html = instance.getOuterHtml(); // remove block

        if (name === 'cut') {
          instance.remove();
        }
      } else if (type === 'dlist') {
        html = this.app.selection.getHtml();

        if (html.search(/<dl/gi) === -1) {
          // wrap to list
          html = '<dl>' + html + '</dl>';
        } // delete selection


        if (name === 'cut') {
          this.app.selection.deleteContents();
        }
      } else if (type === 'list') {
        var tag = instance.getTag(); // contains li

        html = this.app.selection.getHtml();

        if (html.search(/<li/gi) !== -1) {
          // does not have li at start
          if (html.search(/^<li/g) === -1) {
            html = '<li>' + html + '</li>';
          } // wrap to list


          html = '<' + tag + '>' + html + '</' + tag + '>';
        } // delete selection


        if (name === 'cut') {
          this.app.selection.deleteContents();
        }
      } else {
        html = this.app.selection.getHtml(); // delete selection

        if (name === 'cut') {
          this.app.selection.deleteContents();
        }
      }

      return html;
    },
    _copyFromNonEditable: function _copyFromNonEditable(name, html, instance) {
      var $block = instance.getBlock();
      var type = instance.getType(); // column

      if (type === 'column') {
        html = $block.html();
      } // row
      else if (type === 'row') {
          // wrap to table
          html = instance.getOuterHtml();
          html = '<table>' + html + '</table>'; // delete cell content

          if (name === 'cut') {
            $block.find('td, th').html('');
          }
        } else {
          html = instance.getOuterHtml();
        } // remove block


      if (name === 'cut') {
        var parentInstance = instance.getParent('layer');

        if (type === 'column') {
          instance.setEmpty();
        } else {
          instance.remove();
        }

        if (type === 'layer' && parentInstance && parentInstance.isEmpty()) {
          parentInstance.setEmpty();
        }
      }

      return html;
    },
    _copy: function _copy(e, name) {
      var instance = this.app.block.get();
      var isMultiple = this.app.blocks.is();
      var html = false; // do nothing

      if (!isMultiple && !instance) return;
      if (!isMultiple && instance && instance.isEditable() && this.app.selection.isCollapsed()) return; // stop event

      e.preventDefault(); // select all

      if (this.app.editor.isAllSelected()) {
        html = this._copyFromAllSelected(name, html);
      } // multiple
      else if (isMultiple) {
          html = this._copyFromMultiple(name, html);
        } // single editable
        else if (instance && instance.isEditable()) {
            html = this._copyFromEditable(name, html, instance);
          } // single non editable
          else if (instance) {
              html = this._copyFromNonEditable(name, html, instance);
            } // broadcast


      var event = this.app.broadcast('editor.before.' + name, {
        e: e,
        html: html
      });
      if (event.isStopped()) return e.preventDefault();
      html = event.get('html'); // set to clipboard

      html = this.app.clipboard.setContent(e, html); // broadcast

      this.app.broadcastHtml('editor.' + name, html);
    },
    // remove
    _removeEmptySpan: function _removeEmptySpan($node) {
      if ($node.get().attributes.length === 0) {
        $node.unwrap();
      }
    },
    _removeEmptyTag: function _removeEmptyTag($node) {
      var html = $node.html().trim();

      if ($node.get().attributes.length === 0 && html === '') {
        $node.unwrap();
      }
    },
    _removeBlockTagsInside: function _removeBlockTagsInside($node) {
      var tags = $node.get().tagName === 'LI' ? this.blockListTags : this.opts.tags.block;
      $node.find(tags.join(',')).append('<br>').unwrap();
    },
    // store
    _store: function _store(html, name, matched, stored, storedIndex) {
      if (!matched) return html;
      if (typeof stored[name] === 'undefined') stored[name] = [];

      for (var i = 0; i < matched.length; i++) {
        stored[name][storedIndex] = matched[i];
        html = html.replace(matched[i], '####_' + name + storedIndex + '_####');
        storedIndex++;
      }

      return html;
    },
    // get
    _getElementsFromHtml: function _getElementsFromHtml(html, selector) {
      var matched = [];
      var $div = this.dom('<div>').html(html);
      $div.find(selector).each(function ($node) {
        matched.push($node.get().outerHTML);
      });
      return matched;
    },
    // sanitize
    _sanitizeSrc: function _sanitizeSrc($node) {
      var node = $node.get();

      if (node.getAttribute('src').search(/^data|javascript:/i) !== -1) {
        node.setAttribute('src', '');
      }
    },
    _sanitizeHref: function _sanitizeHref($node) {
      var node = $node.get();
      var str = node.getAttribute('href');

      if (str && str.search(/^javascript:/i) !== -1) {
        node.setAttribute('href', '');
      }
    },
    _sanitizeEvents: function _sanitizeEvents($node) {
      $node.removeAttr('onload onerror ontoggle onwheel onmouseover oncopy');
    },
    // encode
    _encodeCode: function _encodeCode(html) {
      return this.app.utils.wrap(html, function ($w) {
        $w.find('pre code, pre, code').each(this._encodeNode.bind(this));
      }.bind(this));
    },
    _encodeNode: function _encodeNode($node) {
      var node = $node.get();
      var first = node.firstChild;
      var html = node.innerHTML;

      if (node.tagName === 'PRE' && first && first.tagName === 'CODE') {
        return;
      }

      html = html.replace(/xtagstartz/g, '<');
      html = html.replace(/xtagendz/g, '>');
      var encoded = this.decodeEntities(html);
      node.textContent = this._encodeNodeHtml(encoded);
    },
    _encodeNodeHtml: function _encodeNodeHtml(html) {
      html = html.replace(/&nbsp;/g, ' ').replace(/<br\s?\/?>/g, '\n');
      html = this.opts.code.spaces ? html.replace(/\t/g, new Array(this.opts.code.spaces + 1).join(' ')) : html;
      return html;
    }
  });
  ArticleEditor.add('module', 'paragraphizer', {
    init: function init() {
      this.remStart = '#####replace';
      this.remEnd = '#####';
      var extendTags = ['form', 'figcaption', 'object', 'style', 'script', 'iframe', 'select', 'input', 'textarea', 'button', 'option', 'map', 'area', 'math', 'fieldset', 'legend', 'hgroup', 'nav', 'details', 'menu', 'summary'];
      this.tags = this.opts.tags.parser.concat(extendTags);
    },
    paragraphize: function paragraphize(html) {
      // build markup tag
      var tag = 'p';
      var stored = [];
      var storedComments = []; // store

      html = this._storeTags(html, stored);
      html = this.app.content.storeComments(html, storedComments); // trim

      html = html.trim();
      html = this._trimLinks(html); // replace new lines

      html = html.replace(/xparagraphmarkerz(?:\r\n|\r|\n)$/g, '');
      html = html.replace(/xparagraphmarkerz$/g, '');
      html = html.replace(/xparagraphmarkerz(?:\r\n|\r|\n)/g, '\n');
      html = html.replace(/xparagraphmarkerz/g, '\n');
      html = html.replace(/[\n]+/g, "\n"); // wrap to tag

      var str = '';
      var arr = html.split("\n");

      for (var i = 0; i < arr.length; i++) {
        str += '<' + tag + '>' + arr[i].trim() + '</' + tag + '>\n';
      } // trim new line at the end


      html = str.replace(/\n$/, ''); // clean

      html = html.replace(new RegExp('<' + tag + '>\\s+#####', 'gi'), '#####');
      html = html.replace(new RegExp('<' + tag + '>#####', 'gi'), '#####');
      html = html.replace(new RegExp('#####</' + tag + '>', 'gi'), '#####'); // restore

      html = this._restoreTags(html, stored);
      html = this.app.content.restoreComments(html, storedComments); // clean empty

      html = html.replace(/<p(.*?)><\/?br\s?\/?><\/p>/gi, "<p$1></p>");
      html = html.replace(/<div(.*?)><\/?br\s?\/?><\/div>/gi, "<div$1></div>");
      return html;
    },
    // private
    _storeTags: function _storeTags(html, stored) {
      return this.app.utils.wrap(html, function ($w) {
        $w.find(this.tags.join(', ')).each(function ($node, i) {
          this._replaceTag($node, i, stored);
        }.bind(this));
      }.bind(this));
    },
    _restoreTags: function _restoreTags(html, stored) {
      for (var i = 0; i < stored.length; i++) {
        var str = stored[i].replace(/\$/gi, '&#36;');
        html = html.replace(this.remStart + i + this.remEnd, str);
      }

      return html;
    },
    _replaceTag: function _replaceTag($node, i, stored) {
      var node = $node.get();
      var replacement = document.createTextNode(this.remStart + i + this.remEnd + 'xparagraphmarkerz');
      stored.push(node.outerHTML);
      node.parentNode.replaceChild(replacement, node);
    },
    _trimLinks: function _trimLinks(html) {
      return this.app.utils.wrap(html, function ($w) {
        $w.find('a').each(this._trimLink.bind(this));
      }.bind(this));
    },
    _trimLink: function _trimLink($node) {
      $node.html($node.html().trim());
    }
  });
  ArticleEditor.add('module', 'parser', {
    build: function build(html) {
      this.$layout = this.dom('<div>');
      this.$layout.html(html);
      this.$layout.find('[data-' + this.prefix + '-type]').each(this._build.bind(this));
      return this.$layout;
    },
    buildElement: function buildElement($el) {
      $el.find('[data-' + this.prefix + '-type]').each(this._build.bind(this));
    },
    // parse
    parse: function parse(html, build) {
      // parse
      html = html.trim();
      html = this.app.broadcastHtml('editor.before.parse', html); // check empty

      if (this.app.content.isEmptyHtml(html)) {
        html = this.app.block.createHtml();
      } // clean & parse
      else {
          html = this._clean(html);
          html = this._parse(html);
        } // broadcast


      html = this.app.broadcastHtml('editor.parse', html); // build

      return build !== false ? this.build(html) : html;
    },
    parseLine: function parseLine(html, build) {
      if (html === ' ') {
        html = '&nbsp;';
      } else {
        // broadcast
        html = this.app.broadcastHtml('editor.before.parse', html); // convert newlines to br

        html = html.replace(/\r?\n/g, "<br>");
        html = this.app.content.encodeCode(html);
        html = this.app.content.sanitize(html);
        html = this.app.content.removeEmptySpans(html);
        html = this.app.content.addHttps(html); // broadcast

        html = this.app.broadcastHtml('editor.parse', html);
      } // build


      return build !== false ? this.build(html) : html;
    },
    // unparse
    unparse: function unparse(html) {
      var stored = {};
      var storedIndex = 0;
      html = html.trim();
      html = this.app.broadcastHtml('editor.before.unparse', html); // empty

      if (this.app.content.isEmptyHtml(html)) {
        return '';
      } // revert


      html = this._revertForms(html);
      html = this._revertFrames(html); // store

      html = this.app.content.store(html, 'noneditable', stored, storedIndex);
      html = this.app.content.store(html, 'embed', stored, storedIndex); // link nofollow

      html = this.app.content.addNofollow(html); // remove selection markers

      html = this.app.content.removeMarkers(html); // restore data style cache

      html = this.app.content.recacheStyle(html); // restore

      html = this.app.content.restore(html, 'noneditable', stored);
      html = this.app.content.restore(html, 'embed', stored); // remove empty attrs

      html = this.app.content.removeEmptyAttrs(html, ['style', 'class', 'rel', 'alt', 'title']); // unparse

      html = this._unparseAllTags(html);
      html = this._unparseDataType(html); // remove empty attrs again

      html = this.app.content.removeEmptyAttrs(html, ['style', 'class', 'rel', 'alt', 'title']);

      if (html === '<p></p>') {
        html = '';
      } // tidy
      //html = this.app.content.tidy.html(html);
      // broadcast


      return this.app.broadcastHtml('editor.unparse', html);
    },
    // private
    _build: function _build($node) {
      var type = $node.attr('data-' + this.prefix + '-type');
      this.app.create('block.' + type, $node);
    },
    _clean: function _clean(html) {
      var stored = {};
      var storedIndex = 0;
      var storedComments = []; // store comments

      html = this.app.content.storeComments(html, storedComments); // encode

      if (this.app.editor.isTextarea()) {
        html = this.app.content.encodeCode(html);
      } // sanitize


      html = this.app.content.sanitize(html); // convert

      html = this._convertFrames(html);
      html = this._convertForms(html); // store

      html = this.app.content.store(html, 'noneditable', stored, storedIndex);
      html = this.app.content.store(html, 'embed', stored, storedIndex); // remove denied tags

      html = this.app.content.removeTags(html, this.opts.tags.denied); // remove doctype tag

      html = this.app.content.removeDoctype(html); // remove style & script tag

      html = this.app.content.removeTagsWithContent(html, ['script', 'style']); // remove comments

      if (this.opts.clean.comments) {
        html = this.app.content.removeComments(html);
      } // remove empty spans


      html = this.app.content.removeEmptySpans(html); // add https for links and images

      html = this.app.content.addHttps(html); // remove block tags in

      html = this.app.content.removeBlockTagsInside(html, ['th', 'td', 'li', 'dt', 'dd', 'address']); // cache styles for block and inline tags and img

      html = this.app.content.cacheStyle(html); // restore

      html = this.app.content.restore(html, 'noneditable', stored);
      html = this.app.content.restore(html, 'embed', stored); // restore comments

      html = this.app.content.restoreComments(html, storedComments); // empty or paragraphize

      if (this.app.content.isEmptyHtml(html)) {
        html = this.app.block.createHtml();
      } else {
        html = this.app.content.paragraphize(html);
      }

      return html;
    },
    _parse: function _parse(html) {
      return this.app.utils.wrap(html, function ($w) {
        var nodes = this.app.element.getBlocks($w);

        for (var i = 0; i < nodes.length; i++) {
          this._parseHtml(nodes[i]);
        } // predefined classes


        if (this.opts.classes) {
          $w.find(this._getPredefinedTags().join(',')).each(this._addPredefinedClass.bind(this));
        }
      }.bind(this));
    },
    _parseHtml: function _parseHtml(el) {
      var tag = el.tagName.toLowerCase();
      var $el = this.dom(el);
      var type; // check custom

      var parser = this.opts.parserTags;

      if (parser[tag]) {
        for (var i = 0; i < parser[tag].length; i++) {
          type = parser[tag][i].call(this.app, $el);
          if (type) break;
        }
      }

      if (!type) {
        type = this._parseType($el, tag);
      } // set


      if (type) {
        $el.attr('data-' + this.prefix + '-type', type); // nested

        if (this.opts.nested.indexOf(type) !== -1) {
          this._parseNested($el);
        }
      }
    },
    _parseType: function _parseType($el, tag) {
      var type;

      if ($el.attr('data-' + this.prefix + '-type')) {
        type = $el.attr('data-' + this.prefix + '-type');
      } else if (this._isNoneditable($el)) {
        type = 'noneditable';
      } else {
        type = this._parseTypeByTag($el, tag);
      }

      return type;
    },
    _parseNested: function _parseNested($el) {
      var nodes = this.app.element.getBlocks($el);

      for (var i = 0; i < nodes.length; i++) {
        this._parseHtml(nodes[i]);
      }
    },
    _parseTypeByTag: function _parseTypeByTag($el, tag) {
      var type;

      switch (tag) {
        case 'p':
          type = 'paragraph';

          if (this._isImageBlock($el, 'p')) {
            type = 'image';
          }

          break;

        case 'figure':
          type = 'embed';

          if (this._isImageBlock($el, 'figure')) {
            type = 'image';
          } else if (this._hasChild($el, 'pre')) {
            type = 'code';
          } else if (this._hasChild($el, 'blockquote')) {
            type = 'quote';
          }

          break;

        case 'div':
          type = 'layer';

          if ($el.attr('data-' + this.prefix + '-type')) {
            type = false;
          } else if (this._isGridBlock($el)) {
            type = 'grid';
          } else if (this._isColumnBlock($el)) {
            type = 'column';
          } else if (this._isTextBlock($el)) {
            type = 'text';
          } else if (this._isCardBlock($el)) {
            type = 'card';
          } else if (this._isImageBlock($el, 'div')) {
            type = 'image';
          }

          break;

        case 'h1':
        case 'h2':
        case 'h3':
        case 'h4':
        case 'h5':
        case 'h6':
          type = 'heading';
          break;

        case 'blockquote':
          type = 'quote';
          break;

        case 'table':
          type = 'table';
          break;

        case 'pre':
          type = 'code';
          break;

        case 'hr':
          type = 'line';
          break;

        case 'dl':
          type = 'dlist';
          break;

        case 'address':
          type = 'address';
          break;

        case 'ul':
        case 'ol':
          type = 'list';
          break;

        case 'main':
        case 'section':
        case 'header':
        case 'footer':
        case 'aside':
        case 'article':
          type = 'layer';
          break;

        default:
          break;
      }

      return type;
    },
    // is
    _isNoneditable: function _isNoneditable($el) {
      return $el.hasClass(this.opts.noneditable.classname);
    },
    _isColumnBlock: function _isColumnBlock($el) {
      if (!this.opts.grid) return;
      var $parent = $el.parent();

      if ($parent.length !== 0 && $parent.attr('data-' + this.prefix + '-type') === 'grid') {
        return true;
      }
    },
    _isGridBlock: function _isGridBlock($el) {
      if (!this.opts.grid) return;
      return $el.hasClass(this.opts.grid.classname);
    },
    _isTextBlock: function _isTextBlock($el) {
      return this.opts.text && $el.hasClass(this.opts.text.classname);
    },
    _isCardBlock: function _isCardBlock($el) {
      return this.opts.card && $el.hasClass(this.opts.card.classname);
    },
    _isImageBlock: function _isImageBlock($el, tag) {
      var $img = $el.find('img');
      if ($img.length === 0) return;
      if (tag === 'div' && $img.closest('figure').length !== 0) return;
      var $target = $img;
      var $parent = $img.parent();
      var parentTag = $parent.length !== 0 ? $parent.get().tagName : false;

      if (parentTag && (parentTag === 'A' || parentTag === 'SPAN')) {
        $target = $parent;
      } else if (parentTag && $parent.get() !== $el.get()) {
        return;
      }

      if ($target.prevElement().length !== 0) return;
      if (tag !== 'figure' && $target.nextElement().length !== 0) return;
      return true;
    },
    // has
    _hasChild: function _hasChild($el, tag) {
      if (tag === 'pre') {
        var $pre = $el.find('pre');

        if ($pre.length !== 0) {
          return true;
        }
      } else if (tag === 'blockquote') {
        var $quote = $el.find('blockquote');
        var $script = $el.find('script');

        if ($script.length === 0 && $quote.length !== 0) {
          return true;
        }
      }
    },
    // get
    _getPredefinedTags: function _getPredefinedTags() {
      var tags = [];

      for (var z in this.opts.classes) {
        tags.push(z);
      }

      return tags;
    },
    // add
    _addPredefinedClass: function _addPredefinedClass($node) {
      var tag = $node.get().tagName.toLowerCase();

      if (typeof this.opts.classes[tag] !== 'undefined') {
        $node.addClass(this.opts.classes[tag]);
      }
    },
    // unparse
    _unparseAllTags: function _unparseAllTags(html) {
      return this.app.utils.wrap(html, function ($w) {
        $w.find('*').removeAttr('contenteditable data-gramm_editor'); // remove images states

        if (!this.opts.image.states) {
          $w.find('img').removeAttr('data-image');
        }
      }.bind(this));
    },
    _unparseDataType: function _unparseDataType(html) {
      return this.app.utils.wrap(html, function ($w) {
        var $elms = $w.find('[data-' + this.prefix + '-type]');
        $elms.removeAttr('data-' + this.prefix + '-first-level data-' + this.prefix + '-parsed');
        $elms.removeClass(this.prefix + '-block-focus ' + this.prefix + '-block-multiple-focus ' + this.prefix + '-block-multiple-hover ' + this.prefix + '-editable-pause');
        $elms.removeClass(this.prefix + '-empty-layer');
        $elms.each(this._unparseByType.bind(this));
        $elms.removeAttr('data-' + this.prefix + '-type');
        $w.find('figcaption').removeAttr('data-' + this.prefix + '-type data-placeholder').each(this.app.content._removeEmptyTag.bind(this));
      }.bind(this));
    },
    _unparseByType: function _unparseByType($node) {
      var type = $node.attr('data-' + this.prefix + '-type');

      if (this.opts.parser[type] && this.opts.parser[type].unparse) {
        this.opts.parser[type].unparse.call(this.app, $node);
      }
    },
    // convert
    _convertFrames: function _convertFrames(html) {
      return this.app.utils.wrap(html, function ($w) {
        $w.find('iframe').each(this._convertFrame.bind(this));
      }.bind(this));
    },
    _convertForms: function _convertForms(html) {
      return this.app.utils.wrap(html, function ($w) {
        $w.find('form').each(this._convertForm.bind(this));
      }.bind(this));
    },
    _convertFrame: function _convertFrame($node) {
      if ($node.closest('figure').length === 0) {
        $node.wrap('<figure>');
        $node.parent().addClass(this.prefix + '-figure-iframe');
      }
    },
    _convertForm: function _convertForm($node) {
      var $el = this.app.element.replaceToTag($node, 'figure');
      $el.addClass(this.prefix + '-figure-form');
      $el.attr('data-' + this.prefix + '-type', 'form');
    },
    // revert
    _revertFrames: function _revertFrames(html) {
      return this.app.utils.wrap(html, function ($w) {
        $w.find('.' + this.prefix + '-figure-iframe').each(this._revertFrame.bind(this));
      }.bind(this));
    },
    _revertForms: function _revertForms(html) {
      return this.app.utils.wrap(html, function ($w) {
        $w.find('.' + this.prefix + '-figure-form').each(this._revertForm.bind(this));
      }.bind(this));
    },
    _revertFrame: function _revertFrame($node) {
      var $figcaption = $node.find('figcaption');

      if ($figcaption.length !== 0) {
        $node.removeClass(this.prefix + '-figure-iframe');
      } else {
        $node.unwrap();
      }
    },
    _revertForm: function _revertForm($node) {
      var $el = this.app.element.replaceToTag($node, 'form');
      $el.removeClass(this.prefix + '-figure-form');
    }
  });
  ArticleEditor.add('module', 'element', {
    // is
    is: function is(el, type, extend) {
      var res = false;
      var node = type === 'text' ? el : this._getNode(el);

      if (type === 'inline') {
        res = this._isElement(node) && this._isInlineTag(node.tagName, extend);
      } else if (type === 'block') {
        res = this._isElement(node) && this._isBlockTag(node.tagName, extend);
      } else if (type === 'element') {
        res = this._isElement(node);
      } else if (type === 'text') {
        res = typeof node === 'string' && !/^\s*<(\w+|!)[^>]*>/.test(node) ? true : this.isTextNode(node);
      } else if (type === 'list') {
        res = this._isElement(node) && ['ul', 'ol'].indexOf(node.tagName.toLowerCase()) !== -1;
      } else if (type === 'heading') {
        res = this._isElement(node) && ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'].indexOf(node.tagName.toLowerCase()) !== -1;
      }

      return res;
    },
    isEmptyOrImageInline: function isEmptyOrImageInline(el) {
      var node = this.dom(el).get();

      if (!node || node.nodeType === 3) {
        return false;
      }

      var tag = node.tagName.toLowerCase();
      var tags = ['svg', 'img'];
      var noeditattr = node.getAttribute('contenteditable') === 'false';
      var isInline = this.is(node, 'inline');

      if (isInline && this.isEmpty(node) || isInline && noeditattr || tags.indexOf(tag) !== -1) {
        return true;
      }

      return false;
    },
    isEmpty: function isEmpty(el) {
      var node = this._getNode(el);

      if (node) {
        return node.nodeType === 3 ? node.textContent.trim().replace(/\n/, '') === '' : node.innerHTML === '';
      }

      return false;
    },
    isTag: function isTag(el, tag) {
      return this._getNode(el).tagName.toLowerCase() === tag;
    },
    isTextNode: function isTextNode(el) {
      var node = this._getNode(el);

      return node && node.nodeType && node.nodeType === 3;
    },
    isVisible: function isVisible(el) {
      var node = this._getNode(el);

      return !!(node.offsetWidth || node.offsetHeight || node.getClientRects().length);
    },
    isScrollVisible: function isScrollVisible(el, tolerance) {
      var $scrollTarget = this.app.scroll.getTarget();
      var $el = this.dom(el);
      var docViewTop = $scrollTarget.scrollTop();
      var docViewBottom = docViewTop + $scrollTarget.height();
      var elemTop = $el.offset().top;
      tolerance = tolerance || 0;
      return elemTop <= docViewBottom;
    },
    // get
    getDataBlock: function getDataBlock(el) {
      return this.dom(el).closest('[data-' + this.prefix + '-type]');
    },
    getType: function getType(el) {
      return this.dom(el).attr('data-' + this.prefix + '-type');
    },
    getAllInlines: function getAllInlines(inline) {
      var inlines = [];
      var node = inline;

      while (node) {
        if (this.is(node, 'inline')) {
          inlines.push(node);
        }

        node = node.parentNode;
      }

      return inlines;
    },
    // scroll
    scrollTo: function scrollTo($el, tolerance) {
      if (!this.isScrollVisible($el)) {
        tolerance = tolerance || 60;
        var offset = $el.offset();
        var $target = this.app.scroll.getTarget();
        var value = offset.top - tolerance;
        $target.scrollTop(value);
        setTimeout(function () {
          $target.scrollTop(value);
        }, 1);
      }
    },
    // replace
    replaceToTag: function replaceToTag(el, tag) {
      return this.dom(el).replaceWith(function (node) {
        var $el = this.dom('<' + tag + '>').append(node.innerHTML);

        if (node.attributes) {
          var attrs = node.attributes;

          for (var i = 0; i < attrs.length; i++) {
            $el.attr(attrs[i].nodeName, attrs[i].value);
          }
        }

        return $el;
      }.bind(this));
    },
    // split
    split: function split(el) {
      var $el = this.dom(el);
      el = $el.get();
      var tag = el.tagName.toLowerCase();
      var fragment = this.app.content.extractHtmlFromCaret(el);

      if (fragment.nodeType && fragment.nodeType === 11) {
        fragment = this.dom(fragment.childNodes);
      }

      var $secondPart = this.dom('<' + tag + ' />');
      $secondPart = this.cloneAttrs(el, $secondPart);
      $secondPart.append(fragment);
      $el.after($secondPart);
      var $last = $el.children().last();

      if (this.is($last, 'inline')) {
        var html = $last.html();
        html = this.app.utils.removeInvisibleChars(html);

        if (html === '') {
          $last.remove();
        }
      }

      var type = this.getType($secondPart);

      if (type) {
        this.app.create('block.' + type, $secondPart, true);
      }

      if ($el.html() === '') $el.remove();
      return $secondPart;
    },
    // clone
    cloneEmpty: function cloneEmpty(el) {
      var $el = this.dom(el);
      var tag = $el.get().tagName.toLowerCase();
      var $clone = this.dom('<' + tag + '>');
      return $clone;
    },
    cloneAttrs: function cloneAttrs(elFrom, elTo) {
      var $elTo = this.dom(elTo);

      var attrs = this._getNode(elFrom).attributes;

      var len = attrs.length;

      while (len--) {
        var attr = attrs[len];
        $elTo.attr(attr.name, attr.value);
      }

      return $elTo;
    },
    // attrs
    getAttrs: function getAttrs(el) {
      var node = this._getNode(el);

      var attr = {};

      if (node.attributes != null && node.attributes.length) {
        for (var i = 0; i < node.attributes.length; i++) {
          var val = node.attributes[i].nodeValue;
          val = this._isNumber(val) ? parseFloat(val) : this._getBooleanFromStr(val);
          attr[node.attributes[i].nodeName] = val;
        }
      }

      return attr;
    },
    removeEmptyAttrs: function removeEmptyAttrs(el, attrs) {
      var $el = this.dom(el);
      var name = attrs.join(' ');
      var res = false;

      if (typeof $el.attr(name) === 'undefined' || $el.attr(name) === null) {
        res = true;
      } else if ($el.attr(name) === '') {
        $el.removeAttr(name);
        res = true;
      }

      return res;
    },
    // blocks
    getBlocks: function getBlocks(el, parsertags, extendtags) {
      var node = this._getNode(el);

      var nodes = node.childNodes;
      var finalNodes = [];
      var tags = parsertags || this.opts.tags.parser;

      if (extendtags) {
        tags = this.app.utils.extendArray(tags, extendtags);
      }

      for (var i = 0; i < nodes.length; i++) {
        if (nodes[i].nodeType === 1 && tags.indexOf(nodes[i].tagName.toLowerCase()) !== -1) {
          finalNodes.push(nodes[i]);
        }
      }

      return finalNodes;
    },
    hasBlocks: function hasBlocks(el) {
      return this.getBlocks(el).length !== 0;
    },
    // siblings
    hasTextSiblings: function hasTextSiblings(el) {
      var node = this._getNode(el);

      var hasPrev = node.previousSibling && node.previousSibling.nodeType === 3 && !this.isEmpty(node.previousSibling);
      var hasNext = node.nextSibling && node.nextSibling.nodeType === 3 && !this.isEmpty(node.nextSibling);
      return hasPrev || hasNext;
    },
    // private
    _getNode: function _getNode(el) {
      return this.dom(el).get();
    },
    _getBooleanFromStr: function _getBooleanFromStr(str) {
      if (str === 'true') return true;else if (str === 'false') return false;
      return str;
    },
    _isBlockTag: function _isBlockTag(tag, extend) {
      var arr = this.app.utils.extendArray(this.opts.tags.block, extend);
      return arr.indexOf(tag.toLowerCase()) !== -1;
    },
    _isInlineTag: function _isInlineTag(tag, extend) {
      var arr = this.app.utils.extendArray(this.opts.tags.inline, extend);
      return arr.indexOf(tag.toLowerCase()) !== -1;
    },
    _isElement: function _isElement(node) {
      return node && node.nodeType && node.nodeType === 1;
    },
    _isTag: function _isTag(tag) {
      return tag !== undefined && tag;
    },
    _isNumber: function _isNumber(str) {
      return !isNaN(str) && !isNaN(parseFloat(str));
    }
  });
  ArticleEditor.add('module', 'blocks', {
    build: function build() {
      this._buildFirstLevel();
    },
    is: function is() {
      return this.getSelected().length > 1;
    },
    set: function set($block) {
      $block = $block.closest('[data-' + this.prefix + '-first-level]'); // unset not first level

      this.unsetNotFirstLevel(); // set focus class

      this._setFocus($block);

      setTimeout(function () {
        this.app.selection.removeAllRanges();
      }.bind(this), 0); // ui

      this.app.path.build();
      this.app.toolbar.build();
      this.app.control.close(); // check all or one selected

      this._checkSelected();
    },
    setFirstLevel: function setFirstLevel() {
      this.app.blocks.getFirstLevel().addClass(this.prefix + '-block-focus');
    },
    unset: function unset() {
      this.getBlocks().removeClass(this.prefix + '-block-focus ' + this.prefix + '-block-multiple-hover');
    },
    unsetNotFirstLevel: function unsetNotFirstLevel() {
      this.getBlocks().not('[data-' + this.prefix + '-first-level]').removeClass(this.prefix + '-block-focus');
    },
    unsetHover: function unsetHover() {
      this.getBlocks().removeClass(this.prefix + '-block-multiple-hover');
    },
    getBlocks: function getBlocks() {
      return this.app.editor.getLayout().find('[data-' + this.prefix + '-type]');
    },
    getFirstLevel: function getFirstLevel() {
      return this.app.editor.getLayout().find('[data-' + this.prefix + '-first-level]');
    },
    getEditableBlocks: function getEditableBlocks() {
      return this.app.editor.getLayout().find('[contenteditable=true]');
    },
    getSelected: function getSelected() {
      return this.app.editor.getLayout().find('.' + this.prefix + '-block-focus');
    },
    getFirst: function getFirst() {
      return this.getBlocks().first().dataget('instance');
    },
    getFirstSelected: function getFirstSelected() {
      return this.getSelected().first().dataget('instance');
    },
    getLast: function getLast() {
      return this.getBlocks().last().dataget('instance');
    },
    getLastSelected: function getLastSelected() {
      return this.getSelected().last().dataget('instance');
    },
    pauseEditableBlocks: function pauseEditableBlocks() {
      this.getEditableBlocks().attr('contenteditable', false).addClass(this.prefix + '-editable-pause');
    },
    runEditableBlocks: function runEditableBlocks() {
      var $blocks = this.app.editor.getLayout().find('.' + this.prefix + '-editable-pause');
      $blocks.attr('contenteditable', true).removeClass(this.prefix + '-editable-pause');
    },
    removeSelected: function removeSelected(traverse) {
      var last = this.getLastSelected();
      var next;

      if (traverse !== false && last) {
        next = last.getNext();
      } // remove


      this.getSelected().each(this._removeSelectedBlock.bind(this)); // traverse

      if (next) {
        this.app.block.set(next, 'start');
      }
    },
    // private
    _buildFirstLevel: function _buildFirstLevel() {
      var name = 'data-' + this.prefix + '-first-level';
      var $layout = this.app.editor.getLayout();
      $layout.find('[' + name + ']').removeAttr(name);
      $layout.children('[data-' + this.prefix + '-type]').attr(name, true);
    },
    _checkSelected: function _checkSelected() {
      var $all = this.getFirstLevel();
      var $selected = this.getSelected();

      if ($selected.length === 0) {
        this.unsetHover();
        this.app.block.unset();
      } else if ($selected.length === 1) {
        this.unsetHover();
        this.app.block.set($selected.eq(0), false, true);
      } else if ($all.length === $selected.length) {
        this.unsetHover();
        this.app.editor.selectAll();
      } else {
        this.app.editor.unsetSelectAllClass();
      }
    },
    _setFocus: function _setFocus($block) {
      var func = $block.hasClass(this.prefix + '-block-focus') ? 'removeClass' : 'addClass';
      $block[func](this.prefix + '-block-focus');
      $block.removeClass(this.prefix + '-block-multiple-hover');
    },
    _removeSelectedBlock: function _removeSelectedBlock($node) {
      var instance = $node.dataget('instance');
      instance.remove({
        traverse: false
      });
    }
  });
  ArticleEditor.add('module', 'block', {
    init: function init() {
      this.instance = false;
      this.$block = false;
    },
    create: function create(html) {
      var instance = this.app.create('block.' + this.opts.editor.markup);
      if (html) instance.getBlock().html(html);
      return instance;
    },
    createHtml: function createHtml(html) {
      return this.create(html).getOuterHtml();
    },
    is: function is($el) {
      return $el ? this._isBlockActive($el) : this.get();
    },
    get: function get() {
      return this.instance;
    },
    set: function set(el, caret, force) {
      // is instance
      if (el.isBlock) {
        el = el.getBlock();
      } // check if active


      if (force !== true && this._isBlockActive(el)) return; // unset

      this.unset(); // set

      this.instance = this._getInstance(el);
      this.$block = this.instance.getBlock();
      this.$block.addClass(this.prefix + '-block-focus'); // caret

      this._setCaret(caret); // ui


      this.app.path.build();
      this.app.toolbar.build();
      this.app.control.build(); // broadcast

      this.app.broadcast('block.set');
    },
    unset: function unset() {
      if (!this.instance) return;
      this.instance = false;
      this.$block = false; // unset

      this.app.blocks.unset();
      this.app.editor.unsetSelectAllClass(); // ui

      this.app.path.build();
      this.app.toolbar.build();
      this.app.control.close(); // broadcast

      this.app.broadcast('block.unset');
    },
    duplicate: function duplicate() {
      if (!this._isAction()) return;
      var instance = this.get();
      var clone = instance.duplicate();
      var newInstance = instance.insert({
        instance: clone,
        position: 'after',
        caret: 'start'
      });
      this.app.broadcast('block.duplicate', {
        instance: newInstance
      });
      return newInstance;
    },
    moveUp: function moveUp() {
      if (!this._isAction()) return;
      this.get().moveUp();
    },
    moveDown: function moveDown() {
      if (!this._isAction()) return;
      this.get().moveDown();
    },
    change: function change(instance) {
      if (!this.is()) return;
      var current = this.get();
      var $block = current.getBlock();
      var $newBlock = instance.getBlock();
      $block.after($newBlock);
      $block.remove(); // rebuild

      this.app.parser.buildElement($newBlock);
      this.app.editor.build(); // set

      this.set(instance); // broadcast

      this.app.broadcast('block.change', {
        instance: instance
      });
    },
    add: function add(params) {
      this.app.popup.close();
      var current = this.get();
      var remove = false;
      var position = false; // all selected

      if (this.app.editor.isAllSelected()) {
        current = this.create();
        this.app.editor.unsetSelectAllClass();
        this.app.editor.getLayout().html('').append(current.getBlock());
        position = 'after';
        remove = true;
      } // blocks
      else if (this.app.blocks.is()) {
          current = this.app.blocks.getLastSelected();
          position = 'after';
        } // not selected
        else if (!current) {
            if (this.opts.editor.add === 'top') {
              current = this.app.blocks.getFirst();
              position = 'before';
            } else {
              current = this.app.blocks.getLast();
              position = 'after';
            }
          } // like variable
          else if (current.isInlineBlock()) {
              var parent = current.getParent();
              this.app.caret.set(current.getBlock(), 'after');
              this.app.block.set(parent);
              current = this.get();
            } // empty emptiable
            else if (current.isEmptiable() && current.isEmpty()) {
                var $block = current.getBlock();
                $block.removeClass(this.prefix + '-empty-layer');
                $block.html('');
                position = 'append';
              } // position


      position = params.position ? params.position : position; // create

      var newInstance = params.instance ? params.instance : this.app.create('block.' + params.name, params.source); // insert

      current.insert({
        instance: newInstance,
        position: position,
        caret: params.caret ? params.caret : 'end'
      });

      if (remove) {
        current.remove();
      }

      return newInstance;
    },
    format: function format(params) {
      this.app.format.set(params);
    },
    remove: function remove(params) {
      var instance = this.get();
      if (!instance) return;
      var type = instance.getType();
      var parent = instance.getParent();
      var imageUrl = type === 'image' ? instance.getSrc() : false;
      var isTraverse = params && typeof params.tarverse !== 'undefined' && params.tarverse === false ? false : true;

      if (isTraverse) {
        var next = instance.getNext();
        var prev = instance.getPrev();
        instance.remove();

        if (next) {
          this.app.block.set(next, 'start');
        } else if (prev) {
          this.app.block.set(prev, 'end');
        } else {
          this.unset();
        }
      } else {
        this.unset();
        instance.remove();
      } // broadcast image


      if (type === 'image') {
        this.app.broadcast('image.remove', {
          url: imageUrl
        });
      } // broadcast


      this.app.broadcast('block.remove', {
        type: type,
        parent: parent
      }); // check empty

      if (this.app.editor.isEmpty()) {
        this.app.editor.setEmpty();
      }
    },
    observe: function observe(obj, name) {
      var types = ['line', 'quote', 'layer', 'code'];
      if (types.indexOf(name) !== -1 && !this.opts[name]) return false; // align / valign / outset

      if (name === 'alignment' && !this.opts.align) return false;
      if (name === 'valign' && !this.opts.valign) return false;
      if (name === 'outset' && !this.opts.outset) return false;
    },
    observeCard: function observeCard(obj, name) {
      if (name === 'image') {
        var instance = this.get();
        if (!instance.hasImage()) return false;
      }
    },
    popup: function popup(params, button, name) {
      // alignment
      var form;

      if (name === 'alignment') {
        form = this._buildSegments('align', 'alignment');
      } // valign
      else if (name === 'valign') {
          form = this._buildSegments('valign');
        } // outset
        else if (name === 'outset') {
            form = this._buildSegments('outset');
          } // popup


      this.app.popup.create(name, {
        setter: 'block.setData',
        getter: 'block.getData',
        form: form
      });
      this.app.popup.open({
        button: button
      });
    },
    css: function css(name, value) {
      if (!this.is()) return;
      var $el = this.get().getBlock();
      $el.css(name, value); // save

      var name = 'data-' + this.prefix + '-style-cache';
      var style = $el.attr('style');

      if (style) {
        style = style.replace(/"/g, '');
        $el.attr(name, style);
      }
    },
    // data
    getData: function getData() {
      if (!this.is()) return;
      var instance = this.get();
      return instance.getData();
    },
    setData: function setData(stack) {
      if (!this.is()) return;
      var data = stack.getData();
      var instance = this.get();
      instance.setData(data);
    },
    // private
    _isBlockActive: function _isBlockActive(el) {
      if (this.app.blocks.is()) return false;
      return this.instance && this.dom(el).get() === this.$block.get();
    },
    _isAction: function _isAction() {
      return !this.app.blocks.is() && this.is();
    },
    _buildSegments: function _buildSegments(name, title) {
      var form = {};
      var segments = {};
      var obj = this.opts[name];

      for (var key in obj) {
        if (!obj[key]) continue;
        segments[key] = {
          name: obj[key],
          prefix: name
        };
      }

      title = title || name;
      form[name] = {
        type: 'segment',
        label: '## form.' + title + ' ##',
        segments: segments
      };
      return form;
    },
    _appendToEmptyBlock: function _appendToEmptyBlock(instance) {
      var emptyBlock = this.app.block.create();
      emptyBlock.append(instance);
      return emptyBlock.getBlock();
    },
    _getInstance: function _getInstance(el) {
      return this.dom(el).dataget('instance');
    },
    _setCaret: function _setCaret(caret) {
      if (this.instance.isEditable()) {
        if (caret) {
          var $target = this.$block;

          if (this.instance.getType() === 'list' && (caret === 'start' || caret === 'end')) {
            $target = caret === 'start' ? this.$block.find('li').first() : this.$block.find('li').last();
          }

          this.app.caret.set($target, caret);
        }
      } else {
        this.app.scroll.save();
        this.app.editor.getWin().focus();
        this.$block.focus();
        setTimeout(function () {
          this.app.selection.removeAllRanges();
        }.bind(this), 0);
        this.app.scroll.restore();
      }
    }
  });
  ArticleEditor.add('module', 'event', {
    init: function init() {
      // local
      this.dragoverEvent = false;
      this.imageDrag = false;
      this.pressedCmd = false;
      this.isPopupMouseUp = false; // events

      this.events = {
        frame: ['click', 'contextmenu', 'touchstart', 'mouseover', 'mouseup', 'mousedown', 'keydown', 'keyup', 'paste', 'copy', 'cut', 'drop', 'dragstart', 'dragover', 'dragleave'],
        doc: ['keydown', 'mousedown', 'click'],
        win: ['focus']
      };
    },
    run: function run() {
      this._runEvents();
    },
    pause: function pause() {
      this._pauseEvents();
    },
    build: function build() {
      this._buildTargets();

      this._buildPreventLinks();

      this._buildEvents();
    },
    stop: function stop() {
      var eventname = this.prefix + '-events';
      this.$body.off('.' + eventname);
      this.$win.off('.' + eventname);
      this.app.$doc.off('.' + eventname);
    },
    // on
    onmouseover: function onmouseover(e) {
      // multiple hover
      this._buildHover(e); // broadcast


      this.app.broadcast('editor.mouseover', {
        e: e
      });
    },
    oncontextmenu: function oncontextmenu(e) {
      if (this.pressedCmd) {
        e.preventDefault();

        var $block = this._getBlock(e);

        this.app.blocks.set($block);
      }
    },
    onclick: function onclick(e) {
      this.app.broadcast('editor.click', {
        e: e
      });
    },
    onmouseup: function onmouseup(e) {
      // state
      this.app.state.add(e); // broadcast

      this.app.broadcast('editor.mouseup', {
        e: e
      }); // ui

      this.app.toolbar.observe();
    },
    onmousedown: function onmousedown(e) {
      if (this.app.popup.isOpen()) {
        this.app.popup.close();
      }

      this._setBlock(e);

      this._setCaretInline(e);

      this.app.placeholder.handleClick(e); // state

      this.app.state.add(e); // broadcast

      this.app.broadcast('editor.mousedown', {
        e: e
      });
    },
    ontouchstart: function ontouchstart(e) {
      // state
      this.app.state.add(e);
    },
    onkeydown: function onkeydown(e) {
      // broadcast
      var event = this.app.broadcast('editor.keydown', this._buildEventKeysObj(e));
      if (event.isStopped()) return e.preventDefault(); // listen undo & redo

      if (this.app.state.listen(e)) {
        this.pressedCmd = false;
        return;
      }

      this.pressedCmd = this._isCmdPressed(e); // esc

      if (this._isEsc(e)) {
        this.app.block.unset();
        this.app.selection.removeAllRanges();
      } // handle shortcut


      if (this.app.shortcut.handle(e)) return; // release keydown

      this.app.input.handle(event);
    },
    onkeyup: function onkeyup(e) {
      // broadcast
      var event = this.app.broadcast('editor.keyup', this._buildEventKeysObj(e));
      if (event.isStopped()) return e.preventDefault(); // catch tab

      var key = e.which;

      if (key === this.app.keycodes.TAB && !this.app.block.is()) {
        if (e.target && e.target.tagName === 'BODY') {
          var $first = this.app.blocks.getFirst();
          this.app.editor.setFocus();
          this.app.block.set($first);
        } else {
          this._setBlock(e);
        }
      }

      this.pressedCmd = false;
      this.app.blocks.unsetHover(); // ui

      this.app.toolbar.observe();
    },
    onpaste: function onpaste(e) {
      this.app.content.paste(e);
    },
    oncopy: function oncopy(e) {
      this.app.content.copy(e);
    },
    oncut: function oncut(e) {
      this.app.content.cut(e);
    },
    ondrop: function ondrop(e) {
      if (!this.opts.editor.drop) return e.preventDefault(); // broadcast

      var event = this.app.broadcast('editor.drop', {
        e: e
      });
      if (event.isStopped()) return e.preventDefault(); // drop

      var html;
      var dt = e.dataTransfer;
      var item = dt.getData('item');

      if (item !== '') {
        e.preventDefault();

        if (this.opts.draggable && typeof this.opts.draggable[item] !== 'undefined') {
          html = this.opts.draggable[item];
        } else {
          html = this.dom('[data-' + this.prefix + '-drop-item=' + item + ']').html();
          html = html.trim();
        } // drop


        if (html) {
          var position = 'after';
          var $over = this.app.editor.getBody().find('.' + this.prefix + '-draggable-over');

          if ($over.length !== 0) {
            position = 'append';
          }

          this.app.content.drop(e, html, position, false);
        }
      } else if (this.opts.image && this.opts.image.upload && dt.files !== null && dt.files.length > 0) {
        e.preventDefault();
        this.app.image.drop(e, dt);
      } else {
        html = dt.getData("text/html");
        html = html.trim() === '' ? dt.getData('Text') : html; // drop

        var dropped = this.app.content.drop(e, html);

        if (this.imageDrag && dropped.instances.length !== 0) {
          var instance = dropped.instances[0];
          instance.change(this.imageDrag, false);
        }
      }

      this._removeDragPlaceholder();

      this.imageDrag = false;
      this.app.observer.trigger = true;
    },
    ondragstart: function ondragstart(e) {
      var $block = this._getBlock(e.target);

      if ($block.length !== 0 && this.app.element.getType($block) === 'image') {
        this.imageDrag = $block.dataget('instance');
      } // broadcast


      this.app.broadcast('editor.dragstart', {
        e: e
      });
    },
    ondragover: function ondragover(e) {
      e.preventDefault();
      this.dragoverEvent = true;
      this.app.observer.trigger = false;

      this._removeDragPlaceholder(); // data


      var types = e.dataTransfer.types;

      if (types.indexOf('item') !== -1) {
        var $block = this._getBlock(e.target);

        if ($block.length !== 0) {
          var instance = $block.dataget('instance');

          if (instance.getType('layer') && instance.isEmpty()) {
            $block.addClass(this.prefix + '-draggable-over');
          } else {
            var $pl = this.dom('<div>').addClass(this.prefix + '-draggable-placeholder');
            $block.after($pl);
          }
        }
      } // broadcast


      this.app.broadcast('editor.dragover', {
        e: e
      });
    },
    ondragleave: function ondragleave(e) {
      e.preventDefault();
      this.dragoverEvent = false;

      this._removeDragPlaceholder();

      this.app.observer.trigger = true; // broadcast

      this.app.broadcast('editor.dragleave', {
        e: e
      });
    },
    // on win
    onwinfocus: function onwinfocus(e) {
      if (this._isRemoveRanges()) {
        setTimeout(function () {
          this.app.selection.removeAllRanges();
        }.bind(this), 0);
        return;
      }
    },
    // on doc
    ondockeydown: function ondockeydown(e) {
      if (this._isEsc(e) && this.app.popup.isOpen()) {
        this.app.popup.close(false);
      }
    },
    ondocmousedown: function ondocmousedown(e) {
      this.isPopupMouseUp = this.dom(e.target).closest('.' + this.prefix + '-popup-' + this.uuid).length !== 0;
    },
    ondocclick: function ondocclick(e) {
      if (!this._isOutsideEditor(e)) return;

      if (this.app.popup.isOpen()) {
        if (this.isPopupMouseUp === false) this.app.popup.close(false);
      } else {
        this.app.editor.setBlur();
      }

      this.pressedCmd = false;
    },
    // private
    _buildPreventLinks: function _buildPreventLinks() {
      var eventname = this.prefix + '-prevent-events';
      this.$body.on('click.' + eventname + ' dblclick.' + eventname, this._preventLinks.bind(this));
    },
    _buildTargets: function _buildTargets() {
      this.$body = this.app.editor.getBody();
      this.$win = this.app.editor.getWin();
    },
    _buildEventKeysObj: function _buildEventKeysObj(e) {
      var key = e.which;
      var arrowKeys = [this.app.keycodes.UP, this.app.keycodes.DOWN, this.app.keycodes.LEFT, this.app.keycodes.RIGHT];
      var isAlphaKeys = !e.ctrlKey && !e.metaKey && (key >= 48 && key <= 57 || key >= 65 && key <= 90);
      var k = this.app.keycodes;
      return {
        'e': e,
        'key': key,
        'ctrl': e.ctrlKey || e.metaKey,
        'shift': e.shiftKey,
        'alt': e.altKey,
        'select': (e.ctrlKey || e.metaKey) && !e.altKey && key === 65,
        'enter': key === k.ENTER,
        'space': key === k.SPACE,
        'esc': key === k.ESC,
        'tab': key === k.TAB && !e.shiftKey && !e.altKey && !e.ctrlKey && !e.metaKey,
        'delete': key === k.DELETE,
        'backspace': key === k.BACKSPACE,
        'alpha': isAlphaKeys,
        'arrow': arrowKeys.indexOf(key) !== -1,
        'left': key === k.LEFT,
        'right': key === k.RIGHT,
        'up': key === k.UP,
        'down': key === k.DOWN,
        'left-right': key === k.LEFT || key === k.RIGHT,
        'up-left': key === k.UP || key === k.LEFT,
        'down-right': key === k.DOWN || key === k.RIGHT
      };
    },
    _buildEvents: function _buildEvents() {
      var eventname = this.prefix + '-events';

      this._buildTargetEvents(this.$body, this.events.frame, eventname, '');

      this._buildTargetEvents(this.$win, this.events.win, eventname, 'win');

      this._buildTargetEvents(this.app.$doc, this.events.doc, eventname, 'doc');
    },
    _buildTargetEvents: function _buildTargetEvents($target, events, eventname, type) {
      for (var i = 0; i < events.length; i++) {
        $target.on(events[i] + '.' + eventname, this['on' + type + events[i]].bind(this));
      }
    },
    _buildHover: function _buildHover(e) {
      var instance = this.app.block.get(); // check pressed & instance

      if (!this.pressedCmd || !instance) return;
      var $block = this.dom(e.target).closest('[data-' + this.prefix + '-first-level]');
      if ($block.length === 0) return; // unset

      this.app.blocks.unsetHover(); // build hover

      if (!$block.hasClass(this.prefix + '-block-focus')) {
        $block.addClass(this.prefix + '-block-multiple-hover');
      }
    },
    _runEvents: function _runEvents() {
      var eventname = this.prefix + '-events';

      this._buildTargetEvents(this.$body, this.events.frame, eventname, '');

      this._buildTargetEvents(this.$win, this.events.win, eventname, 'win');
    },
    _pauseEvents: function _pauseEvents() {
      var eventname = this.prefix + '-events';

      if (this.$body) {
        this.$body.off('.' + eventname);
        this.$win.off('.' + eventname);
      }
    },
    _getBlock: function _getBlock(target) {
      return this.dom(target).closest('[data-' + this.prefix + '-type]');
    },
    _setCaretInline: function _setCaretInline(e) {
      var instance = this.app.block.get();
      var code = false;

      if (instance && instance.isEditable()) {
        // svg or img
        if (this.app.element.isEmptyOrImageInline(e.target)) {
          this.app.caret.set(e.target, 'after');
        } // code
        else if (this.app.selection.isCollapsed() && e.target.tagName === 'CODE') {
            code = true;
            setTimeout(function () {
              var current = this.app.selection.getElement();

              if (current && code && current.tagName !== 'CODE') {
                this.app.caret.set(e.target, 'start');
                code = false;
              }
            }.bind(this), 1);
          }
      }
    },
    _setBlock: function _setBlock(e) {
      // set focus event
      this.app.editor.setFocus();
      var $block = e ? this._getBlock(e.target) : this.app.selection.getDataBlock();
      if ($block.length === 0) return; // prevent contenteditable false focus

      if ($block.attr('contenteditable') === false) {
        e.preventDefault();
      } // multiple


      if (this.pressedCmd) {
        if (e) e.preventDefault();
        this.app.blocks.set($block);
      } // single
      else {
          this.app.block.set($block);
        }
    },
    _isRemoveRanges: function _isRemoveRanges() {
      var instance = this.app.block.get();
      return this.app.blocks.is() || instance && instance.isInlineBlock();
    },
    _isEsc: function _isEsc(e) {
      return e.which === this.app.keycodes.ESC;
    },
    _isOutsideEditor: function _isOutsideEditor(e) {
      var $target = this.dom(e.target);
      var targets = ['-container-', '-popup-', '-control-'];
      return $target.closest('.' + this.prefix + targets.join(this.uuid + ',.' + this.prefix) + this.uuid).length === 0;
    },
    _isCmdPressed: function _isCmdPressed(e) {
      return this.opts.selection.multiple ? (e.ctrlKey || e.metaKey) && !e.shiftKey && !e.altKey : false;
    },
    _isLinkClick: function _isLinkClick(e) {
      return this.dom(e.target).closest('a').length !== 0;
    },
    _removeDragPlaceholder: function _removeDragPlaceholder() {
      var $body = this.app.editor.getBody();
      $body.find('.' + this.prefix + '-draggable-placeholder').remove();
      $body.find('.' + this.prefix + '-draggable-over').removeClass(this.prefix + '-draggable-over');
    },
    _preventLinks: function _preventLinks(e) {
      if (this._isLinkClick(e)) e.preventDefault();
    }
  });
  ArticleEditor.add('module', 'selection', {
    init: function init() {
      this.savedSelection = false;
      this.savedMarker = false;
    },
    start: function start() {
      this.win = this.app.editor.getWinNode();
      this.doc = this.app.editor.getDocNode();
    },
    // get
    get: function get() {
      var sel = this._getSelection();

      var range = this._getRange(sel);

      var current = this._getCurrent(sel);

      return {
        selection: sel,
        range: range,
        collapsed: this._getCollapsed(sel, range),
        current: current,
        parent: this._getParent(current)
      };
    },
    getRange: function getRange() {
      return this._getRange(this.get().selection);
    },
    getNodes: function getNodes(data) {
      var sel = this.get();
      var isInline = data && (data.type && data.type === 'inline' || data.tags && data.tags.indexOf('a') !== -1);
      var func = isInline ? '_getAllRangeNodes' : '_getRangeNodes';
      var nodes = [];

      if (this.app.editor.isAllSelected()) {
        nodes = this.app.editor.getLayout().children().getAll();
      } else {
        nodes = sel.selection && sel.range ? this[func](sel.range) : nodes;
      }

      return nodes.length > 0 ? this._filterNodes(nodes, sel.range, isInline, data) : nodes;
    },
    getCurrent: function getCurrent() {
      var sel = this._getSelection();

      return this._getCurrent(sel);
    },
    getParent: function getParent() {
      var current = this.getCurrent();
      return this._getParent(current);
    },
    getElement: function getElement(el) {
      return this._getElement(el, 'element');
    },
    getInline: function getInline(el) {
      return this._getElement(el, 'inline');
    },
    getTopInline: function getTopInline(el) {
      var node = el ? this.dom(el).get() : this.getCurrent();
      var inlines = [];

      while (node) {
        if (this._getElement(node, 'inline')) {
          inlines.push(node);
        } else {
          break;
        }

        node = node.parentNode;
      }

      return inlines[inlines.length - 1];
    },
    getDataBlock: function getDataBlock(el) {
      var sel = this._getSelection();

      var node = el || this._getCurrent(sel);

      if (node) {
        node = this.dom(node).get();

        while (node) {
          if (node.nodeType === 1 && node.getAttribute('data-' + this.prefix + '-type')) {
            return this.dom(node);
          }

          node = node.parentNode;
        }
      }

      return this.dom();
    },
    getBlock: function getBlock(el) {
      return this._getElement(el, 'block');
    },
    getText: function getText(type, num) {
      var sel = this.get();
      var text = false;
      if (!sel.selection) return false;

      if (type && sel.range) {
        num = typeof num === 'undefined' ? 1 : num;
        var el = this.app.editor.getLayout().get();
        var cloned = sel.range.cloneRange();

        if (type === 'before') {
          cloned.collapse(true);
          cloned.setStart(el, 0);
          text = cloned.toString().slice(-num);
        } else if (type === 'after') {
          cloned.selectNodeContents(el);
          cloned.setStart(sel.range.endContainer, sel.range.endOffset);
          text = cloned.toString().slice(0, num);
        }
      } else {
        text = sel.selection ? sel.selection.toString() : '';
      }

      return text;
    },
    getHtml: function getHtml() {
      var html = '';
      var sel = this.get();

      if (sel.selection) {
        var cloned = sel.range.cloneContents();
        var div = document.createElement('div');
        div.appendChild(cloned);
        html = div.innerHTML;
        html = html.replace(/<p><\/p>$/i, '');
      }

      return html;
    },
    getPosition: function getPosition() {
      var range = this.getRange();
      var pos = {
        top: 0,
        left: 0,
        width: 0,
        height: 0
      };

      if (this.win.getSelection && range.getBoundingClientRect) {
        range = range.cloneRange();
        var offset = range.startOffset - 1;
        range.setStart(range.startContainer, offset < 0 ? 0 : offset);
        var rect = range.getBoundingClientRect();
        pos = {
          top: rect.top,
          left: rect.left,
          width: rect.right - rect.left,
          height: rect.bottom - rect.top
        };
      }

      return pos;
    },
    // set
    set: function set(sel, range) {
      if (sel) {
        sel.removeAllRanges();
        sel.addRange(range);
      }
    },
    setRange: function setRange(range) {
      this.set(this.win.getSelection(), range);
    },
    // is
    is: function is(el) {
      if (typeof el !== 'undefined') {
        var node = this.dom(el).get();
        var nodes = this.getNodes();

        for (var i = 0; i < nodes.length; i++) {
          if (nodes[i] === node) return true;
        }
      } else {
        return this.get().selection;
      }

      return false;
    },
    isCollapsed: function isCollapsed() {
      var sel = this.get();
      return this._getCollapsed(sel.selection, sel.range);
    },
    isIn: function isIn(el) {
      var node = this.dom(el).get();
      var current = this.getCurrent();
      return current && node ? node.contains(current) : false;
    },
    isAll: function isAll(el) {
      var node = this.dom(el).get();
      var selection = this.win.getSelection();

      var range = this._getRange(selection);

      if (selection.isCollapsed) return false;

      if (this.is(node)) {
        return typeof node.textContent !== 'undefined' && node.textContent.trim().length === range.toString().trim().length;
      } else {
        return false;
      }
    },
    // select
    select: function select(el) {
      var node = this.dom(el).get();
      var range = this.doc.createRange();
      range.selectNodeContents(node);
      this.setRange(range);
    },
    // remove
    removeAllRanges: function removeAllRanges() {
      var sel = this._getSelection();

      if (sel) {
        sel.removeAllRanges();
      }
    },
    // delete
    deleteContents: function deleteContents() {
      var range = this.getRange();

      if (!this.isCollapsed() && range) {
        range.deleteContents();
      }
    },
    // collapse
    collapse: function collapse(type) {
      type = type || 'start';
      var sel = this.get();

      if (sel.selection && !sel.collapsed) {
        if (type === 'start') sel.selection.collapseToStart();else sel.selection.collapseToEnd();
      }
    },
    // save & restore
    save: function save(el) {
      if (!el) {
        var instance = this.app.block.get();

        if (instance) {
          el = instance.getBlock();
        }
      }

      this.savedSelection = {
        el: el,
        offset: this.app.offset.get(el)
      };
    },
    restore: function restore() {
      if (this.savedMarker) return;
      if (!this.savedSelection) return;
      this.app.editor.getWinNode().focus();
      var el = this.savedSelection.el;
      var instance = this.dom(el).dataget('instance');

      if (instance) {
        this.app.block.set(el);
      }

      if (el) {
        el.focus();
        this.app.offset.set(el, this.savedSelection.offset);
      }

      this.savedSelection = false;
    },
    saveMarker: function saveMarker() {
      this.savedMarker = true;
      this.app.marker.insert();
    },
    restoreMarker: function restoreMarker() {
      this.app.marker.restore();
      this.savedMarker = false;
      this.savedSelection = false;
    },
    // private
    _getSelection: function _getSelection() {
      var sel = this.win.getSelection();
      return sel.rangeCount > 0 ? sel : false;
    },
    _getRange: function _getRange(selection) {
      return selection ? selection.rangeCount > 0 ? selection.getRangeAt(0) : false : false;
    },
    _getCurrent: function _getCurrent(selection) {
      return selection ? selection.anchorNode : false;
    },
    _getParent: function _getParent(current) {
      return current ? current.parentNode : false;
    },
    _getElement: function _getElement(el, type) {
      var sel = this._getSelection();

      if (sel) {
        var node = el || this._getCurrent(sel);

        node = this.dom(node).get();

        while (node) {
          if (this.app.element.is(node, type)) {
            return node;
          }

          node = node.parentNode;
        }
      }

      return false;
    },
    _getCollapsed: function _getCollapsed(selection, range) {
      var collapsed = false;
      if (selection && selection.isCollapsed) collapsed = true;else if (range && range.toString().length === 0) collapsed = true;
      return collapsed;
    },
    _getNextNode: function _getNextNode(node) {
      if (node.firstChild) return node.firstChild;

      while (node) {
        if (node.nextSibling) return node.nextSibling;
        node = node.parentNode;
      }
    },
    _getRangeNodes: function _getRangeNodes(range, all) {
      var start = range.startContainer.childNodes[range.startOffset] || range.startContainer;
      var end = range.endContainer.childNodes[range.endOffset] || range.endContainer;
      var commonAncestor = range.commonAncestorContainer;
      var nodes = [];
      var node;

      if (all) {
        if (!this.app.editor.isLayout(start)) {
          nodes.push(start);
        }

        for (node = start.parentNode; node; node = node.parentNode) {
          if (this.app.editor.isLayout(node)) break;
          nodes.push(node);
          if (node === commonAncestor) break;
        }

        nodes.reverse();

        for (node = start; node; node = this._getNextNode(node)) {
          if (node.nodeType !== 3 && this.dom(node.parentNode).closest(commonAncestor).length === 0) break;
          nodes.push(node);
          if (node === end) break;
        }
      } else {
        // push first element
        if (start.nodeType === 3) {
          nodes.push(this.getBlock());
        }

        for (node = start; node; node = this._getNextNode(node)) {
          if (node === commonAncestor) break;
          if (node.nodeType !== 3 && this.dom(node.parentNode).closest(commonAncestor).length === 0) break;
          nodes.push(node);
          if (node === end) break;
        }
      }

      return nodes;
    },
    _getAllRangeNodes: function _getAllRangeNodes(range) {
      return this._getRangeNodes(range, true);
    },
    _filterNodes: function _filterNodes(nodes, range, isInline, data) {
      var selected = this.getText();
      selected = selected.replace(/[-[\]/{}()*+?.\\^$|]/g, "\\$&");
      var finalNodes = [];

      for (var i = 0; i < nodes.length; i++) {
        var push = true;

        if (data) {
          push = data.types ? this._filterByTypes(push, data, nodes[i]) : push;
          push = data.selected ? this._filterBySelected(push, data, nodes[i], range, selected) : push;
          push = data.type ? this._filterByType(push, data, nodes[i], isInline) : push;
          push = data.tags ? this._filterByTags(push, data, nodes[i]) : push;
        }

        if (push) {
          finalNodes.push(nodes[i]);
        }
      }

      return finalNodes;
    },
    _filterByTypes: function _filterByTypes(push, data, node) {
      var type;

      if (data.types === true) {
        type = this.app.element.getType(node);

        if (!type) {
          push = false;
        }
      } else {
        type = this.app.element.getType(node);

        if (data.types.indexOf(type) === -1) {
          push = false;
        }
      }

      return push;
    },
    _filterByType: function _filterByType(push, data, node, isInline) {
      if (isInline) {
        if (data.links) {
          if (!this.app.element.is(node, data.type)) {
            push = false;
          }
        } else {
          if (node.nodeType === 1 && node.tagName === 'A' || !this.app.element.is(node, data.type)) {
            push = false;
          }
        }
      } else if (!this.app.element.is(node, data.type)) {
        push = false;
      }

      return push;
    },
    _filterByTags: function _filterByTags(push, data, node) {
      var isTagName = typeof node.tagName !== 'undefined';

      if (!isTagName) {
        push = false;
      } else if (isTagName && data.tags.indexOf(node.tagName.toLowerCase()) === -1) {
        push = false;
      }

      return push;
    },
    _filterBySelected: function _filterBySelected(push, data, node, range, selected) {
      if (data.selected === true && !this._containsNodeText(range, node)) {
        push = false;
      } else if (data.selected === 'inside') {
        if (node.nodeType === 1 && node.tagName === 'A') {
          push = true;
        } else if (!this._isTextSelected(node, selected)) {
          push = false;
        }
      }

      return push;
    },
    _isTextSelected: function _isTextSelected(node, selected) {
      var text = this.app.utils.removeInvisibleChars(node.textContent);
      return selected === text || text.search(selected) !== -1 || selected.search(new RegExp('^' + this.app.utils.escapeRegExp(text) + '$')) !== -1;
    },
    _containsNodeText: function _containsNodeText(range, node) {
      var treeWalker = this.doc.createTreeWalker(node, NodeFilter.SHOW_TEXT, {
        acceptNode: function acceptNode(node) {
          return NodeFilter.FILTER_ACCEPT;
        }
      }, false);
      var first, last, textNode;

      while (textNode = treeWalker.nextNode()) {
        if (!first) {
          first = textNode;
        }

        last = textNode;
      }

      var nodeRange = range.cloneRange();

      if (first) {
        nodeRange.setStart(first, 0);
        nodeRange.setEnd(last, last.length);
      } else {
        nodeRange.selectNodeContents(node);
      }

      return range.compareBoundaryPoints(Range.START_TO_START, nodeRange) < 1 && range.compareBoundaryPoints(Range.END_TO_END, nodeRange) > -1;
    }
  });
  ArticleEditor.add('module', 'caret', {
    start: function start() {
      this.win = this.app.editor.getWinNode();
      this.doc = this.app.editor.getDocNode();
    },
    set: function set(el, type) {
      var node = this.dom(el).get();
      if (!node) return;

      this._apply(node, type);
    },
    is: function is(el, type, removeblocks, trimmed) {
      var node = this.dom(el).get();
      if (!node) return false;
      var sel = this.doc.getSelection();
      if (!sel.isCollapsed) return false;

      var position = this._position(node, trimmed);

      var size = this._size(node, removeblocks, trimmed);

      if (type === 'end') {
        return position === size;
      } else if (type === 'start') {
        return position === 0;
      }

      return false;
    },
    // private
    _apply: function _apply(node, type) {
      if (!this._isInPage(node)) return; // focus

      this.app.editor.getWin().focus(); // range

      var range = this.doc.createRange();
      var tag = node.nodeType !== 3 ? node.tagName.toLowerCase() : false; // non editable inline node

      if (this.app.element.is(node, 'inline') && this._isNon(node)) {
        if (type === 'start') type = 'before';else if (type === 'end') type = 'after';
      }

      if (type === 'start') {
        range.setStart(node, 0);
        range.collapse(true);

        var inline = this._getInlineInside(node);

        if (inline) {
          var inlines = this.app.element.getAllInlines(inline);
          node = inlines[0];
          range.selectNodeContents(node);
          range.collapse(true);
        }

        if (this.app.element.is(node, 'inline')) {
          this._insertInvisibleNode(range);
        }
      } else if (type === 'end') {
        var set;
        var last = node.nodeType === 1 ? node.lastChild : false;
        var lastInline = last && this.app.element.is(last, 'inline');

        if (lastInline && this._isNon(last)) {
          set = true;
          range.setStartAfter(last);
          range.collapse(true); // set after

          this._insertInvisibleNode(range);
        } else if (lastInline) {
          node = last;
        }

        if (set !== true) {
          range.selectNodeContents(node);
          range.collapse(false);
        }
      } else if (type === 'before') {
        range.setStartBefore(node);
        range.collapse(true);

        if (this.app.element.is(node, 'inline')) {
          this._insertInvisibleNode(range, node);
        }
      } else if (type === 'after') {
        range.setStartAfter(node);
        range.collapse(true);

        if (this.app.element.is(node, 'inline') || tag === 'br' || tag === 'svg') {
          this._insertInvisibleNode(range);
        }
      } // set range


      var sel = this.win.getSelection();
      sel.removeAllRanges();
      sel.addRange(range);
    },
    _insertInvisibleNode: function _insertInvisibleNode(range, before) {
      var textNode = this.app.utils.createInvisibleChar();

      if (before) {
        before.parentNode.insertBefore(textNode, before);
      } else {
        range.insertNode(textNode);
      }

      range.selectNodeContents(textNode);
      range.collapse(false);
      return textNode;
    },
    _getInlineInside: function _getInlineInside(node) {
      var inline = node.firstChild;

      if (this.app.element.is(inline, 'inline')) {
        var inlineInside = inline.firstChild;

        while (inlineInside) {
          if (this.app.element.is(inlineInside, 'inline')) {
            return inlineInside;
          }

          inlineInside = inlineInside.firstChild;
        }

        return inline;
      }
    },
    _size: function _size(node, removeblocks, trimmed) {
      var str;
      var isTextNode = node.nodeType === 3;

      if (removeblocks && removeblocks.length !== 0) {
        var $node = this.dom(node);
        var $cloned = $node.clone();
        $cloned.find(removeblocks.join(',')).remove();
        str = $cloned.html().trim();
      } else {
        str = isTextNode ? node.textContent : node.innerHTML;
        str = isTextNode || trimmed === false ? str : str.trim();
      }

      return this._trimmed(str, isTextNode, trimmed).length;
    },
    _position: function _position(node, trimmed) {
      var range = this.win.getSelection().getRangeAt(0);
      var caretRange = range.cloneRange();
      var tmp = document.createElement("div");
      var isTextNode = node.nodeType === 3;
      caretRange.selectNodeContents(node);
      caretRange.setEnd(range.endContainer, range.endOffset);
      tmp.appendChild(caretRange.cloneContents());
      var str = isTextNode || trimmed === false ? tmp.innerHTML : tmp.innerHTML.trim();
      var brEnd = str.search(/<\/?br\s?\/?>$/g) !== -1 ? 1 : 0;
      str = this._trimmed(str, isTextNode, trimmed);
      return str.length + brEnd;
    },
    _trimmed: function _trimmed(str, isTextNode, trimmed) {
      if (trimmed === false) {
        str = str.replace(/\n$/g, '');
        return str;
      }

      str = this.app.utils.removeInvisibleChars(str);
      str = str.replace(/<\/?([a-z][a-z0-9]*)\b[^>]*>/gi, '');
      str = str.replace(/\s+/g, ' ');

      if (str !== '' && !isTextNode) {
        str = str.replace(/\s$/, '');
      }

      return str;
    },
    _isInPage: function _isInPage(node) {
      if (node && node.nodeType) {
        return node === this.doc.body ? false : this.doc.body.contains(node);
      }

      return false;
    },
    _isNon: function _isNon(node) {
      return node.getAttribute('contenteditable') === 'false';
    }
  });
  ArticleEditor.add('module', 'scroll', {
    init: function init() {
      this.scrolltop = false;
    },
    save: function save() {
      this.scrolltop = this.getTarget().scrollTop();
    },
    restore: function restore() {
      if (this.scrolltop !== false) {
        this.getTarget().scrollTop(this.scrolltop);
        this.scrolltop = false;
      }
    },
    isTarget: function isTarget() {
      return this.opts.editor.scrollTarget !== window;
    },
    getTarget: function getTarget() {
      return this.dom(this.opts.editor.scrollTarget);
    }
  });
  ArticleEditor.add('module', 'offset', {
    start: function start() {
      this.win = this.app.editor.getWinNode();
      this.doc = this.app.editor.getDocNode();
    },
    get: function get(el) {
      el = this._getEl(el);
      var sel = this.win.getSelection();
      var offset = false;

      if (sel && sel.rangeCount > 0) {
        var range = sel.getRangeAt(0);

        if (el.contains(sel.anchorNode)) {
          var cloned = range.cloneRange();
          cloned.selectNodeContents(el);
          cloned.setEnd(range.startContainer, range.startOffset);
          var start = cloned.toString().length;
          offset = {
            start: start,
            end: start + range.toString().length
          };
        }
      }

      return offset;
    },
    set: function set(el, offset) {
      if (!offset) {
        offset = el;
        el = false;
      } // el


      el = this._getEl(el);
      var charIndex = 0,
          range = this.doc.createRange();
      var nodeStack = [el],
          node,
          foundStart = false,
          stop = false;
      range.setStart(el, 0);
      range.collapse(true);

      while (!stop && (node = nodeStack.pop())) {
        if (node.nodeType === 3) {
          var nextCharIndex = charIndex + node.length;

          if (!foundStart && offset.start >= charIndex && offset.start <= nextCharIndex) {
            range.setStart(node, offset.start - charIndex);
            foundStart = true;
          }

          if (foundStart && offset.end >= charIndex && offset.end <= nextCharIndex) {
            range.setEnd(node, offset.end - charIndex);
            stop = true;
          }

          charIndex = nextCharIndex;
        } else {
          var i = node.childNodes.length;

          while (i--) {
            nodeStack.push(node.childNodes[i]);
          }
        }
      }

      var sel = this.win.getSelection();
      sel.removeAllRanges();
      sel.addRange(range);
    },
    // private
    _getEl: function _getEl(el) {
      return !el ? this.app.editor.getLayout().get() : this.dom(el).get();
    }
  });
  ArticleEditor.add('module', 'input', {
    handle: function handle(event) {
      var e = event.get('e');
      var key = event.get('key');

      if (this._doSelectAll(e, event)) {
        return;
      } // events


      if (event.is('enter') && event.is('shift')) {
        this.handleShiftEnter(e, key, event);
      } else if (event.is('enter')) {
        this.handleEnter(e, key, event);
      } else if (event.is('space') && event.is('shift')) {
        this.handleShiftSpace(e, key, event);
      } else if (event.is('space')) {
        this.handleSpace(e, key, event);
      } else if (event.is('tab') && this.opts.tab.key) {
        this.handleTab(e, key, event);
      } else if (event.is('arrow')) {
        if (event.is(['shift', 'alt', 'ctrl'])) return;
        this.handleArrow(e, key, event);
      } else if (event.is(['delete', 'backspace'])) {
        this.handleDelete(e, key, event);
      }
    },
    // handle
    handleDelete: function handleDelete(e, key, event) {
      var instance = this.app.block.get();
      var isBackspace = event.is('backspace');
      var isDelete = event.is('delete');

      if (this.app.blocks.is()) {
        e.preventDefault();
        this.app.blocks.removeSelected();
        return;
      } // trim invisible char


      if (instance && instance.isEditable() && this._trimInvisibleChar(e, event.is('backspace') ? 'left' : 'right', isDelete)) {
        return;
      } // inline


      var inline = this.app.selection.getInline();

      if (inline && inline.innerHTML.length === 1) {
        e.preventDefault();
        inline.innerHTML = '';
        return;
      } // handle block


      if (instance.handleDelete && instance.handleDelete(e, key, event)) {
        return;
      } // instance


      var next = instance.getNext();
      var prev = instance.getPrev(); // like variable

      if (instance.isInlineBlock()) {
        e.preventDefault();
        var $block = instance.getBlock();
        var parent = instance.getParent();
        this.app.caret.set($block, 'after');
        instance.remove();
        this.app.block.set(parent);
      } // non editable
      else if (!instance.isEditable()) {
          e.preventDefault();
          instance.remove();

          if (next) {
            this.app.block.set(next, 'start');
          } else if (prev) {
            this.app.block.set(prev, 'end');
          } else {
            if (this.app.editor.isEmpty()) {
              this.app.editor.setEmpty();
            } else {
              this.app.block.unset();
            }
          }
        } // editable
        else if (instance.isEditable()) {
            var type = instance.getType(); // all block selected

            if (instance.isAllSelected()) {
              e.preventDefault();

              if (type === 'card') {
                this.app.block.remove();
              } else {
                instance.setEmpty();
              }

              return;
            } // delete & end


            if (isDelete && next && instance.isCaretEnd()) {
              e.preventDefault();

              if (next.getType() === 'card' || !next.isEditable()) {
                this.app.block.set(next);
              } else {
                if (type === 'card') {
                  return;
                } else {
                  instance.appendNext();
                }
              }
            } // backspace & start
            else if (isBackspace && prev && instance.isCaretStart()) {
                e.preventDefault();

                if (prev.getType() === 'card' || !prev.isEditable()) {
                  this.app.block.set(prev);
                } else {
                  if (type === 'card') {
                    return;
                  } else {
                    instance.appendToPrev();
                  }
                }
              }
          }
    },
    handleArrow: function handleArrow(e, key, event) {
      var instance = this.app.block.get(); // multiple

      if (this.app.blocks.is()) {
        return;
      } // editable & inline code or like variable


      if (instance.isEditable()) {
        var current = this.app.selection.getCurrent();
        var inline = this.app.selection.getTopInline(); // inline code

        if (event.is('left') && inline && inline.tagName === 'CODE') {
          var offset = this.app.offset.get(inline);
          var caretStart = this.app.caret.is(inline, 'start');

          if (!caretStart && offset.start === 1 && offset.end === 1) {
            e.preventDefault();
            this.app.caret.set(inline, 'start');
            return;
          } else if (caretStart) {
            e.preventDefault();
            this.app.caret.set(inline, 'before');
            return;
          }
        } else {
          // variable
          if (inline && this._catchInlineBlock(e, event, inline)) {
            return;
          } else if (current && this._catchInlineBlock(e, event, current)) {
            return;
          }
        }
      } // trim invisible char


      if (instance.isEditable() && this._trimInvisibleChar(e, event.is('left') ? 'left' : 'right')) {
        return;
      } // handle block


      if (instance.handleArrow && instance.handleArrow(e, key, event)) {
        return;
      } // like variable


      if (instance.isInlineBlock()) {
        e.preventDefault();
        var $block = instance.getBlock();
        var parent = instance.getParent();
        var caret = event.is('up-left') ? 'before' : 'after';
        this.app.caret.set($block, caret);
        this.app.block.set(parent);
      } else {
        // editable & non editable
        var target;

        if (event.is('up-left') && instance.isCaretStart()) {
          caret = 'end';
          target = instance.getPrev();
        } else if (event.is('down-right') && instance.isCaretEnd()) {
          caret = 'start';
          target = instance.getNext();
        }

        if (target) {
          e.preventDefault();
          this.app.block.set(target, caret);
        }
      }
    },
    handleTab: function handleTab(e, key, event) {
      var instance = this.app.block.get(); // multiple

      if (this.app.blocks.is()) {
        e.preventDefault();
        return;
      } // handle block tab


      if (instance.handleTab && instance.handleTab(e, key, event)) {
        return;
      } // tab as spaces


      if (this.opts.tab.spaces && instance.isEditable()) {
        e.preventDefault();
        var num = this.opts.tab.spaces;
        var node = document.createTextNode(Array(num + 1).join("\xA0"));
        this.app.insertion.insertNode(node, 'end');
        return;
      } // like variable
      else if (instance.isInlineBlock()) {
          e.preventDefault();
          var $block = instance.getBlock();
          var parent = instance.getParent();
          this.app.caret.set($block, 'after');
          this.app.block.set(parent);
        } else {
          e.preventDefault();
          var next = instance.getNext();

          if (next) {
            this.app.block.set(next, 'start');
          }
        }
    },
    handleShiftSpace: function handleShiftSpace(e, key, event) {
      var instance = this.app.block.get(); // multiple

      if (this.app.blocks.is()) return; // instance

      var $block = instance.getBlock(); // editable

      if (instance.isEditable()) {
        // selected all
        if (instance.isAllSelected()) {
          instance.setEmpty();
          return;
        } else {
          if (instance.getType() !== 'code') {
            e.preventDefault();
            this.app.insertion.insertHtml('&nbsp;', 'end');
          }
        }
      } // like variable
      else if (instance.isInlineBlock()) {
          e.preventDefault();
          var parent = instance.getParent();
          this.app.caret.set($block, 'after');
          instance.remove();
          this.app.block.set(parent);
          this.app.insertion.insertHtml('&nbsp;', 'end');
        } // emptiable
        else if (instance.isEmptiable() && instance.isEmpty()) {
            e.preventDefault();
            $block.removeClass(this.prefix + '-empty-layer');
            $block.html('');
            instance.insertEmpty({
              position: 'append',
              caret: 'start'
            });
          }
    },
    handleSpace: function handleSpace(e, key, event) {
      var instance = this.app.block.get(); // multiple

      if (this.app.blocks.is()) {
        e.preventDefault();
        var last = this.app.blocks.getLastSelected();
        last.insertEmpty({
          position: 'after',
          caret: 'start'
        });
        this.app.blocks.removeSelected(false);
        return;
      } // instance


      var $block = instance.getBlock();
      var type = instance.getType(); // handle block space

      if (instance.handleSpace && instance.handleSpace(e, key, event)) {
        return;
      } // do nothing


      if (type === 'row') {
        e.preventDefault();
        return;
      } // editable
      else if (instance.isEditable() && instance.isAllSelected()) {
          instance.setEmpty();
          return;
        } // like variable
        else if (instance.isInlineBlock()) {
            e.preventDefault();
            var parent = instance.getParent();
            this.app.caret.set($block, 'after');
            instance.remove();
            this.app.block.set(parent);
            this.app.insertion.insertHtml('&nbsp;', 'end');
          } // emptiable
          else if (instance.isEmptiable() && instance.isEmpty()) {
              e.preventDefault();
              $block.removeClass(this.prefix + '-empty-layer');
              $block.html('');
              instance.insertEmpty({
                position: 'append',
                caret: 'start'
              });
            } // non editable
            else if (!instance.isEditable()) {
                e.preventDefault();
                instance.insertEmpty({
                  position: 'after',
                  caret: 'start'
                });
                instance.remove();
                this.app.control.updatePosition();
              }
    },
    handleShiftEnter: function handleShiftEnter(e, key, event) {
      var instance = this.app.block.get();
      var type = instance.getType();
      var $block = instance.getBlock();

      if (this.app.blocks.is() || type === 'row') {
        e.preventDefault();
      } // like variable
      else if (instance.isInlineBlock()) {
          e.preventDefault();
          var parent = instance.getParent();
          this.app.caret.set($block, 'after');
          instance.remove();
          this.app.block.set(parent);
          this.app.insertion.insertBreakline();
        } // editable
        else if (instance.isEditable()) {
            e.preventDefault();
            this.app.insertion.insertBreakline();
          } // non editable
          else {
              e.preventDefault();
              var position = 'after';

              if (instance.isEmptiable() && instance.isEmpty()) {
                position = 'append';
                $block.removeClass(this.prefix + '-empty-layer');
                $block.html('');
              }

              instance.insertEmpty({
                position: position,
                caret: 'start'
              });
            }
    },
    handleEnter: function handleEnter(e, key, event) {
      var instance = this.app.block.get(); // blocks

      if (this.app.blocks.is()) {
        e.preventDefault();
        var last = this.app.blocks.getLastSelected();
        last.insertEmpty({
          position: 'after',
          caret: 'start'
        });
        return;
      } // instance


      var $block = instance.getBlock(); // editable

      if (instance.isEditable()) {
        // all block selected
        if (instance.isAllSelected()) {
          e.preventDefault();
          instance.setEmpty();
          return;
        } // theme selected
        else if (!this.app.selection.isCollapsed()) {
            e.preventDefault();

            if (instance.getType() === 'code') {
              this.app.insertion.insertNewline();
            } else {
              this.app.insertion.insertBreakline();
            }

            return;
          }
      } // like variable


      if (instance.isInlineBlock()) {
        e.preventDefault();
        var parent = instance.getParent();
        this.app.caret.set($block, 'after');
        instance.remove();
        this.app.block.set(parent);
      } // emptiable
      else if (instance.isEmptiable() && instance.isEmpty()) {
          e.preventDefault();
          $block.removeClass(this.prefix + '-empty-layer');
          $block.html('');
          instance.insertEmpty({
            position: 'append',
            caret: 'start'
          });
        } // non editable
        else if (!instance.isEditable()) {
            e.preventDefault();
            instance.insertEmpty({
              position: 'after',
              caret: 'start'
            });
          } // handle block enter


      if (instance.handleEnter) {
        instance.handleEnter(e, key, event);
      } // ui


      this.app.control.updatePosition();
    },
    handleTextareaTab: function handleTextareaTab(e) {
      if (e.keyCode !== 9) return true;
      e.preventDefault();
      var el = e.target;
      var val = el.value;
      var start = el.selectionStart;
      el.value = val.substring(0, start) + "    " + val.substring(el.selectionEnd);
      el.selectionStart = el.selectionEnd = start + 4;
    },
    // private
    _isNextBlock: function _isNextBlock(event, node) {
      return event.is('right') && this.app.caret.is(node, 'end') && this.app.element.getType(node.nextSibling);
    },
    _isPrevBlock: function _isPrevBlock(event, node) {
      return event.is('left') && this.app.caret.is(node, 'start') && this.app.element.getType(node.previousSibling);
    },
    _isSiblingInlineBlock: function _isSiblingInlineBlock(e, node) {
      var $el = this.dom(node);
      var instance = $el.dataget('instance');

      if (instance && instance.isInlineBlock()) {
        e.preventDefault();
        this.app.block.set(instance);
        return true;
      }
    },
    _isInvisibleChar: function _isInvisibleChar(direction) {
      var sel = this.app.selection.get();
      var text = this.app.selection.getText(direction);
      return sel.current && sel.current.nodeType === 3 && this.app.utils.searchInvisibleChars(text) === 0;
    },
    _catchInlineBlock: function _catchInlineBlock(e, event, node) {
      if (event.is('left') && node.nodeType === 3) {
        var str = node.textContent;
        var isChar = this.app.utils.searchInvisibleChars(str) !== -1;

        if (isChar) {
          var charnode = node;

          if (this._isSiblingInlineBlock(e, node.previousSibling)) {
            charnode.parentNode.removeChild(charnode);
            return true;
          }
        }
      }

      if (this._isPrevBlock(event, node)) {
        if (this._isSiblingInlineBlock(e, node.previousSibling)) return true;
      } else if (this._isNextBlock(event, node)) {
        if (this._isSiblingInlineBlock(e, node.nextSibling)) return true;
      }
    },
    _trimInvisibleChar: function _trimInvisibleChar(e, pointer, remove) {
      var direction = pointer === 'left' ? 'before' : 'after';
      var sel = this.app.selection.get();

      var isChar = this._isInvisibleChar(direction);

      var el;

      if (isChar && pointer === 'left') {
        el = sel.current;
        this.dom(el).replaceWith(el.textContent.replace(/\s+$/, ""));
      } else if (isChar && remove && sel.current && sel.current.nextSibling) {
        el = sel.current.nextSibling;
        this.dom(el).replaceWith(el.textContent.replace(/^\s+/, ""));
      } else if (isChar && pointer === 'right') {
        e.preventDefault();
        var data = this.app.offset.get();
        this.app.offset.set({
          start: data.start + 1,
          end: data.end + 1
        });
        return true;
      }
    },
    _doSelectAll: function _doSelectAll(e, event) {
      var instance = this.app.block.get(); // if select all & action key - make empty

      if (this._isAllSelected(event)) {
        this._setEditorEmpty(e, event);

        return true;
      } // select all


      if (event.is('select')) {
        e.preventDefault();

        if (!this.app.blocks.is() && instance) {
          if (instance.isAllSelected()) {
            this.app.editor.selectAll();
          } else {
            instance.setSelectAll();
          }
        } else {
          this.app.editor.selectAll();
        }

        return true;
      }
    },
    _isAllSelected: function _isAllSelected(event) {
      return this.app.editor.isAllSelected() && event.is(['enter', 'delete', 'backspace', 'alpha', 'space']);
    },
    _setEditorEmpty: function _setEditorEmpty(e, event) {
      if (!event.is(['alpha', 'space'])) e.preventDefault();
      this.app.editor.setEmpty();
    }
  });
  ArticleEditor.add('module', 'shortcut', {
    init: function init() {
      // local
      this.shortcuts = this.opts.shortcuts; // based on https://github.com/jeresig/jquery.hotkeys

      this.hotkeys = {
        8: "backspace",
        9: "tab",
        10: "return",
        13: "return",
        16: "shift",
        17: "ctrl",
        18: "alt",
        19: "pause",
        20: "capslock",
        27: "esc",
        32: "space",
        33: "pageup",
        34: "pagedown",
        35: "end",
        36: "home",
        37: "left",
        38: "up",
        39: "right",
        40: "down",
        45: "insert",
        46: "del",
        59: ";",
        61: "=",
        96: "0",
        97: "1",
        98: "2",
        99: "3",
        100: "4",
        101: "5",
        102: "6",
        103: "7",
        104: "8",
        105: "9",
        106: "*",
        107: "+",
        109: "-",
        110: ".",
        111: "/",
        112: "f1",
        113: "f2",
        114: "f3",
        115: "f4",
        116: "f5",
        117: "f6",
        118: "f7",
        119: "f8",
        120: "f9",
        121: "f10",
        122: "f11",
        123: "f12",
        144: "numlock",
        145: "scroll",
        173: "-",
        186: ";",
        187: "=",
        188: ",",
        189: "-",
        190: ".",
        191: "/",
        192: "`",
        219: "[",
        220: "\\",
        221: "]",
        222: "'"
      };
      this.hotkeysShiftNums = {
        "`": "~",
        "1": "!",
        "2": "@",
        "3": "#",
        "4": "$",
        "5": "%",
        "6": "^",
        "7": "&",
        "8": "*",
        "9": "(",
        "0": ")",
        "-": "_",
        "=": "+",
        ";": ": ",
        "'": "\"",
        ",": "<",
        ".": ">",
        "/": "?",
        "\\": "|"
      };

      if (this.opts.selection.multiple === false) {
        this.remove('meta+click');
      }
    },
    add: function add(keys, obj) {
      this.shortcuts[keys] = obj;
    },
    remove: function remove(keys) {
      this.opts.shortcutsBase = this._remove(keys, this.opts.shortcutsBase);
      this.opts.shortcuts = this._remove(keys, this.opts.shortcuts);
    },
    handle: function handle(e) {
      this.triggered = false; // disable browser's hot keys for bold and italic if shortcuts off

      if (this.shortcuts === false) {
        if ((e.ctrlKey || e.metaKey) && (e.which === 66 || e.which === 73)) {
          e.preventDefault();
        }

        return true;
      } // build


      if (e.ctrlKey || e.metaKey || e.shoftKey || e.altKey) {
        for (var key in this.shortcuts) {
          this._build(e, key, this.shortcuts[key]);
        }
      }

      return this.triggered;
    },
    observe: function observe(obj, name) {
      return this.opts.topbar.shortcuts ? obj : false;
    },
    popup: function popup(params, button) {
      var meta = /(Mac|iPhone|iPod|iPad)/i.test(navigator.platform) ? '<b>&#8984;</b>' : 'ctrl';
      var items = {};
      var z = 0; // items

      this._buildPopupItems(items, z, this.opts.shortcutsBase, meta, 'base');

      this._buildPopupItems(items, z, this.opts.shortcuts, meta); // create


      this.app.popup.create('shortcuts', {
        width: '360px',
        items: items
      }); // open

      this.app.popup.open({
        button: button
      });
    },
    // private
    _buildPopupItems: function _buildPopupItems(items, z, shortcuts, meta, type) {
      for (var key in shortcuts) {
        var $item = this.dom('<div>').addClass(this.prefix + '-popup-shortcut-item');
        var title = type === 'base' ? shortcuts[key] : shortcuts[key].title;
        var $title = this.dom('<span>').addClass(this.prefix + '-popup-shortcut-title').html(this.lang.parse(title));
        var $kbd = this.dom('<span>').addClass(this.prefix + '-popup-shortcut-kbd');
        var name = type === 'base' ? key.replace('meta', meta) : shortcuts[key].name.replace('meta', meta);
        var arr = name.split('+');

        for (var i = 0; i < arr.length; i++) {
          arr[i] = '<span>' + arr[i] + '</span>';
        }

        $kbd.html(arr.join('+'));
        $item.append($title);
        $item.append($kbd);
        items[z] = {
          html: $item
        };
        z++;
      }
    },
    _build: function _build(e, str, obj) {
      var keys = str.split(',');
      var len = keys.length;

      for (var i = 0; i < len; i++) {
        if (typeof keys[i] === 'string' && !obj.hasOwnProperty('trigger')) {
          this._handler(e, keys[i].trim(), obj);
        }
      }
    },
    _handler: function _handler(e, keys, obj) {
      keys = keys.toLowerCase().split(" ");
      var special = this.hotkeys[e.keyCode];
      var character = e.which !== 91 ? String.fromCharCode(e.which).toLowerCase() : false;
      var modif = "",
          possible = {};
      var cmdKeys = ["meta", "ctrl", "alt", "shift"];

      for (var i = 0; i < cmdKeys.length; i++) {
        var specialKey = cmdKeys[i];

        if (e[specialKey + 'Key'] && special !== specialKey) {
          modif += specialKey + '+';
        }
      } // right cmd


      if (e.keyCode === 93) {
        modif += 'meta+';
      }

      if (special) possible[modif + special] = true;

      if (character) {
        possible[modif + character] = true;
        possible[modif + this.hotkeysShiftNums[character]] = true; // "$" can be triggered as "Shift+4" or "Shift+$" or just "$"

        if (modif === "shift+") {
          possible[this.hotkeysShiftNums[character]] = true;
        }
      }

      var len = keys.length;

      for (var z = 0; z < len; z++) {
        if (possible[keys[z]]) {
          e.preventDefault();
          this.triggered = true;
          this.app.api(obj.command, obj.params, e);
          return;
        }
      }
    },
    _remove: function _remove(keys, obj) {
      return Object.keys(obj).reduce(function (object, key) {
        if (key !== keys) {
          object[key] = obj[key];
        }

        ;
        return object;
      }, {});
    }
  });
  ArticleEditor.add('module', 'toolbar', {
    init: function init() {
      // local
      this.activeClass = 'active';
      this.toggledClass = 'toggled';
      this.disableClass = 'disable';
      this.customButtons = {};
      this.aTags = {};
      this.aTypes = {};
    },
    start: function start() {
      if (this.opts.toolbar) {
        this.sticky = this.opts.toolbar;
      } else if (this.opts.path && this.opts.path.sticky) {
        this.sticky = this.opts.path;
      }

      if (this._isToolbar()) {
        this.$container = this.app.container.get('toolbar');

        this._build();
      }

      this._buildSticky();
    },
    load: function load() {
      this._buildActiveButtons();

      if (this._isToolbar()) {
        this.$toolbar.html('');

        this._buildButtons();
      }
    },
    stop: function stop() {
      this.$toolbar.remove();
      this.customButtons = {};
      this.editorButtons = {};
    },
    build: function build() {
      if (!this._isToolbar()) return;
      this.$toolbar.html('');

      this._buildButtons();
    },
    observe: function observe() {
      if (!this._isToolbar()) return;
      this.unsetActive();
      if (this.app.blocks.is() || this.app.editor.isAllSelected()) return;
      if (!this._isObserveButtons()) return;
      var instance = this.app.block.get();
      var type = instance ? instance.getType() : false;
      var tag = instance ? instance.getTag() : false;
      var inlines = this.app.selection.getNodes({
        type: 'inline',
        selected: 'inside',
        links: true
      });

      var tags = this._getObservedTags(tag, inlines);

      var buttons = [];
      var keys; // tags

      for (var i = 0; i < tags.length; i++) {
        keys = this.aTags[tags[i]];

        if (keys) {
          buttons = buttons.concat(keys);
        }
      } // types


      if (type) {
        keys = this.aTypes[type];

        if (keys) {
          buttons = buttons.concat(keys);
        }
      } // set active


      this._setActiveKeys(buttons);
    },
    // public
    getElement: function getElement() {
      return this.$toolbar;
    },
    get: function get(name) {
      return this._findButton(name);
    },
    add: function add(name, obj) {
      this.customButtons[name] = obj;
    },
    setActive: function setActive(name) {
      if (!this._isToolbar()) return;

      this._findButtons().removeClass(this.activeClass);

      this._findButton(name).removeClass(this.disableClass).addClass(this.activeClass);
    },
    setToggled: function setToggled(name) {
      if (!this._isToolbar()) return;

      this._findButtons().removeClass(this.toggledClass);

      this._findButton(name).removeClass(this.disableClass).addClass(this.toggledClass);
    },
    unsetActive: function unsetActive(name) {
      if (!this._isToolbar()) return;
      var $elms = name ? this._findButton(name) : this._findButtons();
      $elms.removeClass(this.activeClass);
    },
    unsetToggled: function unsetToggled(name) {
      if (!this._isToolbar()) return;
      var $elms = name ? this._findButton(name) : this._findButtons();
      $elms.removeClass(this.toggledClass);
    },
    enable: function enable() {
      if (!this._isToolbar()) return;

      this._findButtons().removeClass(this.disableClass);
    },
    disable: function disable(except) {
      if (!this._isToolbar()) return;

      this._findButtons().removeClass(this.toggledClass).removeClass(this.activeClass).addClass(this.disableClass);
    },
    disableSticky: function disableSticky() {
      if (!this._isToolbar()) return;
      var $container = this.app.container.get('bars');
      $container.removeClass(this.prefix + '-bars-sticky');
      $container.css('top', '');
    },
    enableSticky: function enableSticky() {
      if (!this._isToolbar()) return;

      if (this.opts.toolbar.sticky) {
        var $container = this.app.container.get('bars');
        $container.addClass(this.prefix + '-bars-sticky');
        $container.css('top', this.opts.toolbar.stickyTopOffset + 'px');
      }
    },
    isSticky: function isSticky() {
      var $container = this.app.container.get('bars');
      var $main = this.app.container.get('main');
      var mainTop = $main.offset().top + parseInt($main.css('border-top-width'));
      var containerTop = $container.offset().top;
      return containerTop > mainTop || containerTop < mainTop;
    },
    // private
    _build: function _build() {
      this.$toolbar = this.dom('<div>').addClass(this.prefix + '-toolbar');
      this.$container.append(this.$toolbar);
      this.app.container.get('bars').addClass('has-toolbar');
    },
    _buildSticky: function _buildSticky() {
      if (this.sticky) {
        var $container = this.app.container.get('bars');
        $container.addClass(this.prefix + '-bars-sticky');
        $container.css('top', this.sticky.stickyTopOffset + 'px');
        var $scrollTarget = this.app.scroll.getTarget();
        $scrollTarget.on('scroll.' + this.prefix + '-toolbar', this._observeSticky.bind(this));
      }
    },
    _buildActiveButtons: function _buildActiveButtons() {
      this.aTags = this.opts.buttons.tags ? this.opts.buttons.tags : {};
      this.aTypes = this.opts.buttons.types ? this.opts.buttons.types : {};
      var btns = this.customButtons;

      for (var key in btns) {
        var active = btns[key].active;

        if (active) {
          this._buildActiveButton(key, active.tags, this.aTags);

          this._buildActiveButton(key, active.types, this.aTypes);
        }
      }
    },
    _buildActiveButton: function _buildActiveButton(key, arr, obj) {
      if (!arr) return;

      for (var i = 0; i < arr.length; i++) {
        var item = arr[i];

        if (obj[item]) {
          obj[item].push(key);
        } else {
          obj[item] = [key];
        }
      }
    },
    _buildButtons: function _buildButtons() {
      var instance = this._getCurrentInstance();

      var buttons = instance ? instance.toolbar : this.app.editor.getButtons(); // create button

      this._createButtons(buttons, instance); // create custom (plugin)


      if (instance) {
        this._createButtons(this.customButtons, instance);
      }
    },
    _createButtons: function _createButtons(buttons, instance) {
      for (var name in buttons) {
        if (instance && !instance.isAllowedButton(name, buttons[name])) continue;
        this.app.create('button', name, buttons[name], this.$toolbar, 'toolbar');
      }
    },
    _observeSticky: function _observeSticky() {
      if (this.app.source.is()) {
        this.app.container.get('bars').css('top', 0);
        return;
      }

      var $scrollTarget = this.app.scroll.getTarget();
      var paddingTop = this.app.scroll.isTarget() ? parseInt($scrollTarget.css('padding-top')) : 0;
      var $container = this.app.container.get('bars');
      $container.css('top', 0 - paddingTop + this.sticky.stickyTopOffset + 'px');

      if (this.isSticky()) {
        this.app.broadcast('toolbar.sticky');
      } else {
        this.app.broadcast('toolbar.static');
      }
    },
    _findButtons: function _findButtons() {
      return this.$toolbar.find('.' + this.prefix + '-button-toolbar');
    },
    _findButton: function _findButton(name) {
      return this.$toolbar.find('[data-name=' + name + ']');
    },
    _isToolbar: function _isToolbar() {
      return this.opts.toolbar;
    },
    _isObserveButtons: function _isObserveButtons() {
      if (!this.opts.buttons.tags && !this.opts.buttons.types) return false;
      return true;
    },
    _setActiveKeys: function _setActiveKeys(keys) {
      for (var i = 0; i < keys.length; i++) {
        this._findButton(keys[i]).addClass(this.activeClass);
      }
    },
    _getCurrentInstance: function _getCurrentInstance() {
      var instance = this.app.block.is() ? this.app.block.get() : false;
      return this.app.blocks.is() ? false : instance;
    },
    _getObservedTags: function _getObservedTags(tag, inlines) {
      var tags = [];

      if (tag) {
        tags.push(tag);
      }

      if (inlines.length > 0) {
        for (var i = 0; i < inlines.length; i++) {
          tags.push(inlines[i].tagName.toLowerCase());
        }
      }

      return tags;
    }
  });
  ArticleEditor.add('module', 'button', {
    init: function init(name, obj, $container, type) {
      // build
      if (_typeof(name) === 'object') {
        this.name = name.name;
        this.obj = obj;

        this._buildFromElement(name.element);
      } else if (name) {
        this.type = type || false;
        this.name = name;

        var res = this._observe(obj);

        this.obj = typeof res === 'undefined' ? obj : res;

        if (this.obj) {
          this._build(name, $container);
        }
      }
    },
    setColor: function setColor(stack, data) {
      var name = stack.getName();

      if (name === 'background' || name === 'text-color') {
        var key = name === 'background' ? 'background-color' : 'color';
        this.setBackground(data[key]);
      }
    },
    isButton: function isButton() {
      return true;
    },
    getName: function getName() {
      return this.name;
    },
    getTitle: function getTitle() {
      return this.title;
    },
    getParams: function getParams() {
      return this._has('params') ? this.obj.params : false;
    },
    getOffset: function getOffset() {
      return this.$button.offset();
    },
    getDimension: function getDimension() {
      return {
        width: this.$button.width(),
        height: this.$button.height()
      };
    },
    getElement: function getElement() {
      return this.$button;
    },
    setBackground: function setBackground(color) {
      this._background('add', color);
    },
    resetBackground: function resetBackground() {
      this._background('remove', '');
    },
    // private
    _has: function _has(name) {
      return this.obj.hasOwnProperty(name);
    },
    _observe: function _observe(obj) {
      if (obj.hasOwnProperty('observer')) {
        obj = this.app.api(obj.observer, obj, this.name);
      }

      return obj;
    },
    _background: function _background(type, color) {
      var func = type === 'remove' ? 'removeClass' : 'addClass';
      this.$icon[func](this.prefix + '-button-icon-color').css({
        'background-color': color,
        'color': color !== '' ? this.app.color.invert(color) : ''
      });
    },
    _buildFromElement: function _buildFromElement(element) {
      this.$button = this.dom(element);
      this.$button.addClass(this.prefix + '-button-target');

      this._buildData();
    },
    _build: function _build(name, $container) {
      this._buildTitle();

      this._buildElement();

      this._buildIcon();

      this._buildData($container);
    },
    _buildData: function _buildData($container) {
      // data
      this.$button.attr({
        'tabindex': '-1',
        'data-name': this.name,
        'data-command': this.obj.command || false
      });
      this.$button.dataset('instance', this); // func

      var func = this._has('command') ? '_catch' : '_stop'; // events

      this.$button.on('click.' + this.prefix + '-button', this[func].bind(this));
      this.$button.on('dragstart.' + this.prefix + '-button', function (e) {
        e.preventDefault();
        return;
      });

      if ($container) {
        this._buildTooltip();

        this._buildBackground();

        this._buildPosition($container);
      }
    },
    _buildTitle: function _buildTitle() {
      this.title = typeof this.obj.title !== 'undefined' ? this.lang.parse(this.obj.title) : '';
    },
    _buildElement: function _buildElement() {
      this.$button = this.dom('<a href="#"></a>');
      this.$button.addClass(this.prefix + '-button ' + this.prefix + '-button-target');

      if (this.type) {
        this.$button.addClass(this.prefix + '-button-' + this.type);
      }

      if (this._has('classname')) {
        this.$button.addClass(this.obj.classname);
      }
    },
    _buildIcon: function _buildIcon() {
      var isIcon = this._has('icon');

      var span = '<span class="' + this.prefix + '-icon-' + this.name + '"></span>';
      this.$icon = this._buildIconElement();

      if (isIcon) {
        span = this.obj.icon.search(/</) !== -1 ? this.obj.icon : '<span class="' + this.prefix + '-icon-' + this.obj.icon + '"></span>';
      }

      this.$icon.append(span);
      this.$button.append(this.$icon);
    },
    _buildIconElement: function _buildIconElement() {
      return this.dom('<span>').addClass(this.prefix + '-button-icon');
    },
    _buildTooltip: function _buildTooltip() {
      if (this.type === 'toolbar') {
        this.app.tooltip.build(this.$button, this.title);
      }
    },
    _buildBackground: function _buildBackground() {
      if (this._has('background')) {
        this.setBackground(this.obj.background);
      }
    },
    _buildPosition: function _buildPosition($container) {
      if (this._has('position')) {
        var pos = this.obj.position;

        if (pos === 'first') {
          $container.prepend(this.$button);
        } else if (_typeof(pos) === 'object') {
          var type = pos.hasOwnProperty('after') ? 'after' : 'before';
          var name = pos[type];
          var $el = $container.find('[data-name=' + name + ']');

          if ($el.length !== 0) {
            $el[type](this.$button);
          } else {
            $container.append(this.$button);
          }
        }
      } else {
        $container.append(this.$button);
      }
    },
    _stop: function _stop(e) {
      e.preventDefault();
      e.stopPropagation();
    },
    _catch: function _catch(e) {
      e.preventDefault();
      e.stopPropagation();
      var $btn = this.dom(e.target).closest('.' + this.prefix + '-button-target');
      if ($btn.hasClass('disable')) return; // editor focus

      this.app.editor.setFocus();
      var command = $btn.attr('data-command');
      var name = $btn.attr('data-name');
      var instance = $btn.dataget('instance'); // command

      this.app.api(command, this.getParams(), instance, name, e);
      this.app.tooltip.close();
    }
  });
  ArticleEditor.add('module', 'tooltip', {
    build: function build($button, title) {
      title = title ? title.replace(/(<([^>]+)>)/gi, '') : false;

      if (title) {
        var name = this.prefix + '-button-' + this.uuid;
        $button.attr('data-tooltip', title);
        $button.on('mouseover.' + name, this.open.bind(this));
        $button.on('mouseout.' + name, this.close.bind(this));
      }
    },
    open: function open(e) {
      if (this.app.popup.isOpen()) return;
      var $btn = this.dom(e.target).closest('.' + this.prefix + '-button-target');

      if ($btn.hasClass('disable')) {
        return;
      }

      var $tooltip = this.dom('<span>').addClass(this.prefix + '-tooltip').html($btn.attr('data-tooltip'));
      var offset = $btn.offset();
      var height = $btn.height();
      $tooltip.css({
        top: offset.top + height + 'px',
        left: offset.left + 'px'
      }); // bs modal

      if (this.opts.bsmodal) {
        $tooltip.css('z-index', 1051);
      }

      this.app.$body.append($tooltip);
    },
    close: function close() {
      this.app.$body.find('.' + this.prefix + '-tooltip').remove();
    }
  });
  ArticleEditor.add('module', 'path', {
    init: function init() {
      this.activeClass = 'active';
      this.disableClass = 'disable';
      this.pathItemClass = this.prefix + '-path-item';
    },
    start: function start() {
      if (!this.opts.path) return;
      this.$container = this.app.container.get('pathbar');

      this._build();

      this._buildRoot();

      this._buildActive();
    },
    build: function build() {
      if (!this.opts.path) return;

      this._clear();

      this._buildRoot();

      if (this.app.blocks.is()) {
        this._buildMultipleItem();
      } else {
        this._buildItems();

        this._buildActive();
      }
    },
    disable: function disable() {
      if (!this.opts.path) return;

      this._getAll().addClass(this.disableClass);
    },
    enable: function enable() {
      if (!this.opts.path) return;

      this._getAll().removeClass(this.disableClass);
    },
    // private
    _clear: function _clear() {
      this.$path.find('.' + this.pathItemClass).off('.' + this.prefix + '-path-' + this.uuid);
      this.$path.html('');
    },
    _getAll: function _getAll() {
      return this.$path.find('.' + this.pathItemClass);
    },
    _selectItem: function _selectItem(e) {
      e.stopPropagation();
      e.preventDefault();
      var $item = this.dom(e.target).closest('.' + this.pathItemClass);
      if ($item.hasClass(this.disableClass)) return;
      var instance = $item.dataget('instance');

      if (instance) {
        this.app.popup.close();
        this.app.block.set(instance, 'start');
      } else {
        this._clear();

        this._buildRoot();

        this._buildActive();

        this.app.block.unset();
      }
    },
    _createItem: function _createItem() {
      return this.dom('<a href="#"></a>').attr('tabindex', '-1').addClass(this.pathItemClass);
    },
    _build: function _build() {
      this.$path = this.dom('<div>').addClass(this.prefix + '-path');
      this.$container.append(this.$path);
    },
    _buildRoot: function _buildRoot() {
      this._buildItem(false, this.lang.parse(this.opts.path.title));
    },
    _buildActive: function _buildActive() {
      this.$path.find('a').removeClass(this.activeClass).last().addClass(this.activeClass);
    },
    _buildItems: function _buildItems() {
      var current = this.app.block.get();
      if (!current) return; // parents

      var $parents = current.getBlock().parents('[data-' + this.prefix + '-type]');
      $parents.nodes.reverse();
      $parents.each(this._buildParentItem.bind(this)); // current

      this._buildItem(current);
    },
    _buildParentItem: function _buildParentItem($el) {
      var instance = $el.dataget('instance');

      this._buildItem(instance);
    },
    _buildMultipleItem: function _buildMultipleItem() {
      var $item = this._createItem();

      $item.addClass(this.activeClass);

      this._buildTitle($item, this.lang.get('editor.multiple'));

      this.$path.append($item);
    },
    _buildItem: function _buildItem(instance, root) {
      var $item = this._createItem();

      $item.dataset('instance', instance);
      $item.on('click.' + this.prefix + '-path-' + this.uuid, this._selectItem.bind(this));

      this._buildTitle($item, root || instance.getTitle());

      this.$path.append($item);
    },
    _buildTitle: function _buildTitle($item, title) {
      var $title = this.dom('<span>').html(title);
      $item.append($title);
    }
  });
  ArticleEditor.add('module', 'topbar', {
    init: function init() {
      this.activeClass = 'active';
      this.toggledClass = 'disable';
      this.disableClass = 'disable';
      this.customButtons = {};
    },
    start: function start() {
      if (!this._isTopbar()) return;

      this._build();

      this._buildButtons();
    },
    get: function get(name) {
      return this._findButton(name);
    },
    add: function add(name, obj) {
      this.customButtons[name] = obj;
    },
    setToggled: function setToggled(name) {
      if (!this._isTopbar()) return;

      this._findButtons().removeClass(this.toggledClass);

      this._findButton(name).addClass(this.toggledClass);
    },
    unsetToggled: function unsetToggled(name) {
      if (!this._isTopbar()) return;
      var $elms = name ? this._findButton(name) : this._findButtons();
      $elms.removeClass(this.toggledClass);
    },
    enable: function enable() {
      if (!this._isTopbar()) return;

      this._findButtons().removeClass(this.disableClass);
    },
    disable: function disable() {
      if (!this._isTopbar()) return;

      this._findButtons().removeClass(this.toggledClass).removeClass(this.activeClass).addClass(this.disableClass);
    },
    // private
    _isTopbar: function _isTopbar() {
      return this.opts.path;
    },
    _build: function _build() {
      this.$topbar = this.dom('<div>').addClass(this.prefix + '-topbar');
      this.app.container.get('pathbar').append(this.$topbar);
    },
    _buildButtons: function _buildButtons() {
      var buttons = this.opts.buttons.topbar;

      for (var name in buttons) {
        if (name === 'undo' && !this.opts.topbar.undoredo) continue;
        if (name === 'redo' && !this.opts.topbar.undoredo) continue;
        if (name === 'shortcut' && !this.opts.topbar.shortcuts) continue;
        this.app.create('button', name, buttons[name], this.$topbar, 'topbar');
      }
    },
    _findButtons: function _findButtons() {
      return this.$topbar.find('.' + this.prefix + '-button-topbar');
    },
    _findButton: function _findButton(name) {
      return this.$topbar.find('[data-name=' + name + ']');
    }
  });
  ArticleEditor.add('module', 'control', {
    init: function init() {
      this.instance = false;
      this.customButtons = {};
      this.eventName = this.prefix + '-control';
    },
    start: function start() {
      if (!this.opts.control) return;

      this._build();
    },
    stop: function stop() {
      this.$control.remove();
      this.instance = false;
      this.customButtons = {};
    },
    isOpen: function isOpen() {
      return this.$control.css('display') !== 'none';
    },
    getElement: function getElement() {
      return this.$control;
    },
    get: function get(name) {
      return this._findButton(name);
    },
    add: function add(name, obj) {
      this.customButtons[name] = obj;
    },
    remove: function remove(name) {
      this._findButton(name).remove();
    },
    build: function build() {
      if (!this.opts.control) return;
      var instance = this.app.block.get();

      if (!instance) {
        this.close();
      } else {
        this.open(instance);
      }
    },
    open: function open(instance) {
      if (!this.opts.control) return;
      this.$control.html('');
      this.instance = instance;

      var len = this._buildButtons();

      if (len > 0) {
        var $scrollTarget = this.app.scroll.getTarget();
        this.updatePosition();
        $scrollTarget.on('resize.' + this.eventName, this.updatePosition.bind(this));
        $scrollTarget.on('scroll.' + this.eventName, this.updatePosition.bind(this));
        this.app.editor.getWin().on('scroll.' + this.eventName, this.updatePosition.bind(this));
        this.instance.getBlock().on('keyup.' + this.eventName, this.updatePosition.bind(this));
        this.updatePosition();
      } else {
        this.close();
      }
    },
    close: function close() {
      if (!this.opts.control) return;
      this.$control.hide();

      if (this.instance) {
        var $block = this.instance.getBlock();
        this.app.content.unfixListMargin($block);
        $block.off('.' + this.eventName);
      }

      this.app.scroll.getTarget().off('.' + this.eventName);
      this.app.editor.getDoc().off('.' + this.eventName);
      this.instance = false;
    },
    updatePosition: function updatePosition() {
      if (!this.opts.control) return;

      if (!this.instance) {
        this.close();
        return;
      }

      var isEditable = this.instance.isEditable();
      var offset = this.instance.getOffset();
      var width = this.$control.width();
      var scrollTop = this.app.editor.getWin().scrollTop();
      var topOutlineFix = isEditable ? 4 : 2;
      var leftOutlineFix = isEditable ? 6 : 4;
      var top = offset.top - topOutlineFix - scrollTop;
      var left = offset.left - width - leftOutlineFix;
      var $container = this.app.container.get('toolbar');
      var toolbarBottom = $container.offset().top + $container.height() - topOutlineFix;
      var frameRect = this.app.editor.getFrameRect();

      if (this.instance.getType() === 'list') {
        var $block = this.instance.getBlock();
        this.app.content.fixListMargin($block);
      }

      if (top < toolbarBottom || frameRect.bottom < top) {
        this.$control.hide();
      } else {
        this.$control.show();
      } // scroll target bottom hide


      if (this.app.scroll.isTarget()) {
        var $target = this.app.scroll.getTarget();
        var targetBottom = $target.offset().top + $target.height();
        var bottom = top + this.$control.height();

        if (bottom > targetBottom) {
          this.$control.hide();
        }
      } // left out of edge


      if (!isEditable && left + width / 2 < frameRect.left) {
        left = frameRect.left + 3;
        top = top + 6;
      } // position


      this.$control.css({
        top: top + 'px',
        left: left + 'px'
      });
    },
    // private
    _buildButtons: function _buildButtons() {
      var buttons = this.instance.control;
      var count = 0;
      count = this._createButtons(buttons, count);
      count = this._createButtons(this.customButtons, count);
      return count;
    },
    _build: function _build() {
      this.$control = this.dom('<div>').addClass(this.prefix + '-control ' + this.prefix + '-control-' + this.uuid).hide(); // bs modal

      if (this.opts.bsmodal) {
        this.$control.css('z-index', 1051);
      }

      this.app.$body.append(this.$control);
    },
    _createButtons: function _createButtons(buttons, count) {
      for (var name in buttons) {
        if (!this.instance.isAllowedButton(name, buttons[name])) continue;
        this.app.create('button', name, buttons[name], this.$control, 'control');
        count++;
      }

      return count;
    },
    _findButton: function _findButton(name) {
      return this.$control.find('[data-name=' + name + ']');
    }
  });
  ArticleEditor.add('module', 'cleaner', {
    cleanHtml: function cleanHtml(html) {
      html = this.app.broadcastHtml('editor.before.clean', html); // local

      var exceptedTags = this.opts.paste.blockTags.concat(this.opts.paste.inlineTags).concat(this.opts.paste.formTags);
      var filterStyle = this.opts.paste.keepStyle.length !== 0 ? ',' + this.opts.paste.keepStyle.join(',') : ''; // gdocs & word

      var isPages = this._isPages(html);

      var isMsWord = this._isHtmlMsWord(html);

      var isEditor = this._isEditor(html); // remove doctype tag


      html = this.app.content.removeDoctype(html); // remove denied tags

      html = this.app.content.removeTags(html, this.opts.tags.denied); // remove comments

      html = this.app.content.removeComments(html); // remove style & script tag

      html = this.app.content.removeTagsWithContent(html, ['script', 'style']); // clean pages

      html = isPages ? this._cleanPages(html) : html; // clean gdocs

      html = this._cleanGDocs(html); // encode php code

      html = this._encodePhp(html); // remove tags

      html = this.app.content.removeTagsExcept(html, exceptedTags); // clean ms word

      html = isMsWord ? this._cleanMsWord(html) : html; // remove style

      if (!isEditor) {
        html = this.app.content.removeStyleAttr(html, filterStyle);
      } // restore data style


      html = this.app.content.cacheStyle(html); // remove empty inline

      html = this.app.content.removeEmptyInlines(html); // clean empty p

      html = html.replace(/<p>&nbsp;<\/p>/gi, '<p></p>');
      html = html.replace(/<p><br\s?\/?><\/p>/gi, '<p></p>'); // gmail list paste

      html = html.replace(/^<li/gi, '<ul><li');
      html = html.replace(/<\/li>$/gi, '</li></ul>');

      if (isMsWord) {
        html = html.replace(/<p><\/p>/gi, '');
        html = html.replace(/<p>\s<\/p>/gi, '');
      } // tidy lists


      html = this.app.utils.wrap(html, function ($w) {
        // place ul/ol into li
        $w.find('ul, ol').each(this._placeListToItem.bind(this)); // remove p in li

        $w.find('li p').unwrap();
      }.bind(this)); // broadcast

      return this.app.broadcastHtml('editor.clean', html);
    },
    // private
    _encodePhp: function _encodePhp(html) {
      html = html.replace('<?php', '&lt;?php');
      html = html.replace('<?', '&lt;?');
      html = html.replace('?>', '?&gt;');
      return html;
    },
    _isEditor: function _isEditor(html) {
      return html.match(new RegExp('meta\\stype="' + this.prefix + '-editor"', 'i'));
    },
    _isHtmlMsWord: function _isHtmlMsWord(html) {
      return html.match(/class="?Mso|style="[^"]*\bmso-|style='[^'']*\bmso-|w:WordDocument/i);
    },
    _isPages: function _isPages(html) {
      return html.match(/name="Generator"\scontent="Cocoa\sHTML\sWriter"/i);
    },
    _placeListToItem: function _placeListToItem($node) {
      var node = $node.get();
      var prev = node.previousSibling;

      if (prev && prev.tagName === 'LI') {
        var $li = this.dom(prev);
        $li.find('p').unwrap();
        $li.append(node);
      }
    },
    _cleanPages: function _cleanPages(html) {
      html = html.replace(/\sclass="s[0-9]"/gi, '');
      html = html.replace(/\sclass="p[0-9]"/gi, '');
      html = this.app.utils.wrap(html, function ($w) {
        $w.find('.Apple-converted-space').remove();
      });
      return html;
    },
    _cleanGDocs: function _cleanGDocs(html) {
      html = html.replace(/<b\sid="internal-source-marker(.*?)">([\w\W]*?)<\/b>/gi, "$2");
      html = html.replace(/<b(.*?)id="docs-internal-guid(.*?)">([\w\W]*?)<\/b>/gi, "$3");
      html = html.replace(/<span[^>]*(font-style:\s?italic;\s?font-weight:\s?bold|font-weight:\s?bold;\s?font-style:\s?italic)[^>]*>([\w\W]*?)<\/span>/gi, '<b><i>$2</i></b>');
      html = html.replace(/<span[^>]*(font-style:\s?italic;\s?font-weight:\s?600|font-weight:\s?600;\s?font-style:\s?italic)[^>]*>([\w\W]*?)<\/span>/gi, '<b><i>$2</i></b>');
      html = html.replace(/<span[^>]*(font-style:\s?italic;\s?font-weight:\s?700|font-weight:\s?700;\s?font-style:\s?italic)[^>]*>([\w\W]*?)<\/span>/gi, '<b><i>$2</i></b>');
      html = html.replace(/<span[^>]*font-style:\s?italic[^>]*>([\w\W]*?)<\/span>/gi, '<i>$1</i>');
      html = html.replace(/<span[^>]*font-weight:\s?(bold|600|700)[^>]*>([\w\W]*?)<\/span>/gi, '<b>$2</b>');
      return html;
    },
    _cleanMsWord: function _cleanMsWord(html) {
      // comments
      html = html.replace(/<!--[\s\S]+?-->/gi, '');
      html = html.trim();
      html = html.replace(/<(!|script[^>]*>.*?<\/script(?=[>\s])|\/?(\?xml(:\w+)?|img|meta|link|style|\w:\w+)(?=[\s/>]))[^>]*>/gi, '');
      html = html.replace(/<(\/?)s>/gi, "<$1strike>");
      html = html.replace(/&nbsp;/gi, ' ');
      html = html.replace(/<span\s+style\s*=\s*"\s*mso-spacerun\s*:\s*yes\s*;?\s*"\s*>([\s\u00a0]*)<\/span>/gi, function (str, spaces) {
        return spaces.length > 0 ? spaces.replace(/./, " ").slice(Math.floor(spaces.length / 2)).split("").join("\xA0") : '';
      });
      html = this.app.utils.wrap(html, function ($w) {
        // build lists
        $w.find('p').each(function ($node) {
          var matches = /mso-list:\w+ \w+([0-9]+)/.exec($node.attr('style'));

          if (matches) {
            $node.attr('data-listLevel', parseInt(matches[1], 10));
          }
        }); // parse Lists

        this._parseWordLists($w);

        $w.find('[align]').removeAttr('align');
        $w.find('[name]').removeAttr('name');
        $w.find('span').each(function ($node) {
          var str = $node.attr('style');
          var matches = /mso-list:Ignore/.exec(str);
          if (matches) $node.remove();else $node.unwrap();
        });
        $w.find('[style]').removeAttr('style');
        $w.find("[class^='Mso']").removeAttr('class');
        $w.find('a').filter(function ($node) {
          return !$node.attr('href');
        }).unwrap();
      }.bind(this));
      html = html.replace(/<p[^>]*><\/p>/gi, '');
      html = html.replace(/<li>·/gi, '<li>');
      html = html.trim(); // remove spaces between

      html = html.replace(/\/(p|ul|ol|h1|h2|h3|h4|h5|h6|blockquote)>\s+<(p|ul|ol|h1|h2|h3|h4|h5|h6|blockquote)/gi, '/$1>\n<$2');
      var result = '';
      var lines = html.split(/\n/);

      for (var i = 0; i < lines.length; i++) {
        var space = lines[i] !== '' && lines[i].search(/>$/) === -1 ? ' ' : '\n';
        result += lines[i] + space;
      }

      result = result.trim();
      return result;
    },
    _parseWordLists: function _parseWordLists($w) {
      var lastLevel = 0;
      var $item = null;
      var $list = null;
      var $listChild = null;
      $w.find('p').each(function ($node) {
        var level = $node.attr('data-listLevel');

        if (level === null && $node.hasClass('MsoListParagraphCxSpMiddle')) {
          level = 1;
        }

        if (level !== null) {
          var txt = $node.text();
          var listTag = /^\s*\w+\./.test(txt) ? '<ol></ol>' : '<ul></ul>'; // new parent list

          if ($node.hasClass('MsoListParagraphCxSpFirst') || $node.hasClass('MsoNormal')) {
            $list = this.dom(listTag);
            $node.before($list);
          } // new child list
          else if (level > lastLevel && lastLevel !== 0) {
              $listChild = this.dom(listTag);
              $item.append($listChild);
              $list = $listChild;
            } // level up


          if (level < lastLevel) {
            var len = lastLevel - level + 1;

            for (var i = 0; i < len; i++) {
              $list = $list.parent();
            }
          } // create item


          $node.find('span').first().unwrap();
          $item = this.dom('<li>' + $node.html().trim() + '</li>');

          if ($list === null) {
            $node.before(listTag);
            $list = $node.prev();
          } // append


          $list.append($item);
          $node.remove();
          lastLevel = level;
        } else {
          $list = null;
          lastLevel = 0;
        }
      }.bind(this));
    }
  });
  ArticleEditor.add('module', 'insertion', {
    init: function init() {
      this._clear();
    },
    start: function start() {
      this.win = this.app.editor.getWinNode();
      this.doc = this.app.editor.getDocNode();
    },
    // get
    getFirstInserted: function getFirstInserted() {
      return this.inserted.instances[0];
    },
    getLastInserted: function getLastInserted() {
      var len = this.inserted.instances.length;
      var last = this.inserted.instances[len - 1];

      if (last && last.isInlineBlock()) {
        last = last.getParent();
      }

      return last;
    },
    getInserted: function getInserted() {
      return this.inserted;
    },
    // set
    setContent: function setContent(params) {
      this._insert(params, 'set');

      var inserted = this.getInserted();
      this.inserted = false;
      return inserted;
    },
    // insert
    insertContent: function insertContent(params) {
      this._insert(params, 'insert');

      var inserted = this.getInserted();
      this.inserted = false;
      return inserted;
    },
    insertEmptyBlock: function insertEmptyBlock() {
      this._insert({
        html: this.app.block.createHtml()
      }, 'insert');

      var inserted = this.getInserted();
      this.inserted = false;
      return inserted;
    },
    insertNewline: function insertNewline(caret, doublenode) {
      var str = doublenode ? '\n\n' : '\n';
      return this._insertFragment({
        node: document.createTextNode(str)
      }, caret ? caret : 'after');
    },
    insertPoint: function insertPoint(e) {
      var range;
      var marker = this.app.utils.createInvisibleChar();
      var doc = this.app.editor.getDocNode();
      var x = e.clientX,
          y = e.clientY;

      if (doc.caretPositionFromPoint) {
        var pos = doc.caretPositionFromPoint(x, y);
        var sel = doc.getSelection();
        range = sel.getRangeAt(0);
        range.setStart(pos.offsetNode, pos.offset);
        range.collapse(true);
        range.insertNode(marker);
      } else if (doc.caretRangeFromPoint) {
        range = doc.caretRangeFromPoint(x, y);
        range.insertNode(marker);
      }

      this.app.caret.set(marker, 'after');
    },
    insertBreakline: function insertBreakline(caret) {
      // split inline
      var inlines = this.app.selection.getNodes({
        type: 'inline'
      });

      if (this.app.selection.isCollapsed() && inlines.length !== 0) {
        return this._splitInline(inlines, document.createElement('br'));
      }

      return this._insertFragment({
        node: document.createElement('br')
      }, caret ? caret : 'after');
    },
    insertNode: function insertNode(node, caret, splitinline) {
      if (splitinline) {
        var inlines = this.app.selection.getNodes({
          type: 'inline'
        });

        if (inlines.length !== 0) {
          return this._splitInline(inlines, node);
        }
      }

      return this._insertFragment({
        node: this.dom(node).get()
      }, caret);
    },
    insertHtml: function insertHtml(html, caret) {
      return this._insertFragment({
        html: html
      }, caret);
    },
    insertText: function insertText(text, caret) {
      var instance = this.app.block.get();

      if (instance && !instance.isEditable() || this.app.blocks.is()) {
        this.insertContent({
          html: text,
          caret: caret
        });
        return;
      }

      var sel = this.win.getSelection();
      var node;

      if (sel.getRangeAt && sel.rangeCount) {
        text = this.app.content.getTextFromHtml(text, {
          nl: true
        });
        node = document.createTextNode(text);
        var range = sel.getRangeAt(0);
        range.deleteContents();
        range.insertNode(node);
        caret = caret || 'end';
        this.app.caret.set(node, caret);
      }

      return node;
    },
    insertListToList: function insertListToList($list, $target, caret) {
      // add paste marker
      var $items = $list.find('li');
      var $last = $items.last();
      $items.addClass(this.prefix + '-pasteitems');
      $last.addClass(this.prefix + '-pastemarker'); // build nodes

      var $nodes = $list.children(); // current li item

      var $item = this.dom(this.app.selection.getBlock()); // caret position

      var isStart = this.app.caret.is($target, 'start');
      var isEnd = this.app.caret.is($target, 'end');
      var isStartItem = this.app.caret.is($item, 'start');
      var isEndItem = this.app.caret.is($item, 'end', ['ul', 'ol']); // start

      if (isStart) {
        $target.prepend($nodes);
      } // end
      else if (isEnd) {
          $target.append($nodes);
        } // middle
        else {
            // item empty
            if (this.app.content.isEmptyHtml($item.html())) {
              $item.after($nodes);
              $item.remove();
            } // item before
            else if (isStartItem) {
                $item.before($nodes);
              } // item after
              else if (isEndItem) {
                  var $childList = $item.find('ul, ol');

                  if ($childList.length !== 0) {
                    $childList.prepend($nodes);
                  } else {
                    $item.after($nodes);
                  }
                } // item middle
                else {
                    this.app.element.split($item).before($nodes);
                  }
          } // set caret


      var pastemarker = this.prefix + '-pastemarker';
      var pasteitems = this.prefix + '-pasteitems';

      if (caret) {
        $last = this.app.editor.getLayout().find('.' + pastemarker).removeClass(pastemarker);
        this.app.caret.set($last, 'end');
      }

      return this.app.editor.getLayout().find('.' + pasteitems).removeClass(pasteitems);
    },
    // detect
    detectPosition: function detectPosition($target, position) {
      if (position) return position; // caret position

      var isStart = this.app.caret.is($target, 'start');
      var isEnd = this.app.caret.is($target, 'end'); // end

      if (isEnd) {
        position = 'after';
      } // start
      else if (isStart) {
          position = 'before';
        } // middle
        else {
            position = 'split';
          }

      return position;
    },
    // private
    // insert
    _insert: function _insert(params, type) {
      this.html = params.html; // broadcast before

      this.html = this.app.broadcastHtml('editor.before.insert', this.html); // params

      this.isParse = typeof params.parse === 'undefined' ? true : params.parse;
      this.isClean = typeof params.clean === 'undefined' ? false : params.clean;
      this.isCaret = typeof params.caret === 'undefined' ? true : params.caret;
      this.isPosition = typeof params.position === 'undefined' ? false : params.position; // type

      if (type === 'set' || this.app.editor.isAllSelected()) {
        // set
        this._setContent();
      } else {
        // insert
        this._insertContent();
      } // broadcast


      this.app.broadcast('editor.insert', this.inserted);
    },
    _insertContent: function _insertContent() {
      var current = this.app.block.get();
      var position = false;
      var remove = false;
      var nodes, $block; // check

      this._checkEmpty();

      this._checkLine(); // blocks


      if (this.app.blocks.is()) {
        // insert to blocks
        if (this.isEmpty) {
          return;
        } else if (this.isLine) {
          this.html = this.app.block.createHtml(this.html);
        } // parse & clean


        this._clean();

        this._parse();

        this._parseBuild(); // nodes


        nodes = this._buildParsedNodes(); // insert

        var last = this.app.blocks.getLastSelected();
        var $last = last.getBlock();
        $last.after(nodes); // remove

        this.app.blocks.removeSelected(false);
      } // not selected
      else if (!current || this.isPosition) {
          // insert to blocks
          if (this.isEmpty) {
            return;
          } else if (this.isLine) {
            this.html = this.app.block.createHtml(this.html);
          } // parse & clean


          this._clean();

          this._parse();

          this._parseBuild(); // nodes


          nodes = this._buildParsedNodes();
          var positions = ['after', 'before', 'append'];
          var emptyLayer = false;

          if (this.isPosition === 'top' || !this.isPosition && this.opts.editor.add === 'top') {
            current = this.app.blocks.getFirst();
            position = 'before';
          } else if (current && positions.indexOf(this.isPosition) !== -1) {
            position = this.isPosition;
            emptyLayer = current.getType('layer') && current.isEmpty();
          } else {
            current = this.app.blocks.getLast();
            position = 'after';
          }

          $block = current.getBlock();

          if (emptyLayer) {
            $block.removeClass(this.prefix + '-empty-layer');
            $block.html('');
          }

          $block[position](nodes);
        } // list to list
        else if (this._isListToList(current)) {
            // delete selection
            this.app.selection.deleteContents(); // parse & clean

            this._clean();

            this._parse();

            this._parseBuild(); // insert


            $block = current.getBlock();
            var $list = this.$parsed.children().first();
            this.$nodes = this.insertListToList($list, $block, 'end');
            this.isCaret = false;
          } else if (current) {
            // like variable
            if (current.isInlineBlock()) {
              var parent = current.getParent();
              this.app.caret.set(current.getBlock(), 'after');
              current.remove();
              this.app.block.set(parent);
              current = parent;
            } // editable


            if (current.isEditable()) {
              if (this.isEmpty) {
                return;
              } // parse & clean


              this._clean();

              this._cleanSpecial();

              if (this.isLine) this._parseLine();else this._parse();

              this._parseBuild();

              if (current.isEmpty()) {
                remove = true;
                position = 'after';
              } else {
                // delete selection
                this.app.selection.deleteContents();
              } // nodes


              nodes = this._buildParsedNodes();
              $block = current.getBlock(); // insert

              this._insertToEditable(current, $block, nodes, position, remove);
            } // non editable
            else {
                // set position
                position = 'after'; // check

                if (this.isEmpty) {
                  return;
                } else if (this.isLine) {
                  this.html = this.app.block.createHtml(this.html);
                } // parse & clean


                this._clean();

                if (this.isLine) this._parseLine();else this._parse();

                this._parseBuild(); // nodes


                nodes = this._buildParsedNodes();
                $block = current.getBlock(); // emptiable empty

                if (current.isEmptiable() && current.isEmpty()) {
                  $block.removeClass(this.prefix + '-empty-layer');
                  $block.html('');
                  position = 'append';
                } // insert


                $block[position](nodes);
              }
          } else {
            return;
          } // inserted


      this._buildInserted();

      this._buildCaret();

      this._buildEditor();
    },
    _insertToEditable: function _insertToEditable(current, $block, nodes, position, remove) {
      if (this.isLine) {
        this.$nodes = this._insertFragment({
          fragment: this.$parsed.get()
        }, 'end');
        this.isCaret = false;
      } else {
        // detect position
        if (this.app.content.isEmptyHtml($block.html())) {
          position = 'after';
          remove = true;
        } else {
          position = this.detectPosition($block, position);
        } // insert


        if (position === 'split') {
          this.app.element.split($block).before(nodes);
        } else {
          $block[position](nodes);
        } // remove


        if (remove) current.remove();
      }
    },
    _insertFragment: function _insertFragment(obj, caret) {
      if (obj.html || obj.fragment) {
        var fragment = this.app.fragment.build(obj.html || obj.fragment);
        this.app.fragment.insert(fragment);
      } else {
        this.app.fragment.insert(obj.node);
      }

      if (caret) {
        var target = obj.node ? obj.node : caret === 'start' ? fragment.first : fragment.last;
        this.app.caret.set(target, caret);
      }

      if (obj.node) {
        return this.dom(obj.node);
      } else {
        return this.dom(fragment.nodes);
      }
    },
    // set
    _setContent: function _setContent() {
      // check
      this._checkEmpty();

      this._checkLine(); // set to editor


      if (this.isEmpty) {
        this.html = this.app.block.createHtml();
      } else if (this.isLine) {
        this.html = this.app.block.createHtml(this.html);
      } // parse & clean


      this._clean();

      this._parse();

      this._parseBuild(); // nodes


      var nodes = this._buildParsedNodes(); // set


      this.app.editor.unsetSelectAllClass();
      this.app.editor.getLayout().html('').append(nodes); // broadcast empty

      if (this.isEmpty) {
        this.app.broadcast('editor.empty');
      } // inserted


      this._buildInserted();

      this._buildCaret();

      this._buildEditor();
    },
    // split
    _splitInline: function _splitInline(inlines, node) {
      var $part = this.app.element.split(inlines[0]);
      $part.before(node);
      this.app.caret.set($part, 'start');
      return this.dom(node);
    },
    // build
    _buildEditor: function _buildEditor() {
      this.app.editor.build();
      this.app.editor.setFocus();
    },
    _buildCaret: function _buildCaret() {
      if (!this.isCaret) return;
      var instance,
          caret = 'end';

      if (this.isCaret === 'start') {
        instance = this.getFirstInserted();
        caret = 'start';
      } else {
        instance = this.getLastInserted();
      } // set


      if (instance) {
        this.app.block.set(instance, caret);
      } // ui


      this.app.toolbar.observe();
    },
    _buildInserted: function _buildInserted() {
      this.inserted = {
        $nodes: this.$nodes,
        instances: []
      };
      this.inserted.$nodes.each(this._buildInstance.bind(this));
    },
    _buildInstance: function _buildInstance($node) {
      var instance = $node.dataget('instance');

      if (instance) {
        this.inserted.instances.push(instance);
      }

      var $nodes = $node.find('[data-' + this.prefix + '-type]');

      if ($nodes.length !== 0) {
        $nodes.each(this._buildInstance.bind(this));
      }
    },
    _buildParsedNodes: function _buildParsedNodes() {
      return this.$parsed.get().childNodes;
    },
    // clear
    _clear: function _clear() {
      this.html = false;
      this.isLine = false;
      this.isEmpty = false;
      this.isSplit = false;
      this.isClean = false;
      this.isParse = true;
      this.isCaret = true;
      this.isPosition = false;
    },
    // clean
    _clean: function _clean() {
      if (this.isClean) {
        this.html = this.app.cleaner.cleanHtml(this.html);
      }
    },
    _cleanSpecial: function _cleanSpecial(type) {
      var clean, extend, except;

      if (['cell', 'address', 'figcaption', 'quoteitem'].indexOf(type) !== -1) {
        clean = true;
      } else if (type === 'dlist') {
        clean = true;
        except = ['dt', 'dd'];
      } else if (type === 'list') {
        clean = true;
        except = ['ul', 'ol', 'li'];
      }

      if (clean) {
        this.isLine = true;
        this.html = this.app.content.addBrToBlocks(this.html);
        this.html = this.app.content.removeBlockTags(this.html, extend, except);
        this.html = this.html.replace(/<br\s?\/?>\n?$/gi, '');
      }
    },
    // parse
    _parse: function _parse() {
      if (this.isParse) {
        this.html = this.app.parser.parse(this.html, false);
      }
    },
    _parseLine: function _parseLine() {
      if (this.isParse) {
        this.html = this.app.parser.parseLine(this.html, false);
      }
    },
    _parseBuild: function _parseBuild() {
      this.$parsed = this.app.parser.build(this.html);
      this.$nodes = this.$parsed.children();
    },
    // check
    _checkEmpty: function _checkEmpty() {
      this.isEmpty = this.app.content.isEmptyHtml(this.html);
    },
    _checkLine: function _checkLine() {
      this.isLine = this.app.content.isLine(this.html);
    },
    // is
    _isListToList: function _isListToList(instance) {
      var $target = instance.getBlock();
      var type = $target.attr('data-' + this.prefix + '-type');
      var $list = this.dom('<div>').html(this.html).children().first();
      return type === 'list' && $list.length !== 0 && ['ul', 'ol'].indexOf($list.get().tagName.toLowerCase()) !== -1;
    }
  });
  ArticleEditor.add('module', 'fragment', {
    build: function build(node) {
      return this.is(node) ? node : this.create(node);
    },
    insert: function insert(fragment) {
      var sel = this.app.selection.get();
      if (!sel.range) return;

      if (sel.collapsed) {
        var start = sel.range.startContainer;

        if (start.nodeType !== 3 && start.tagName === 'BR') {
          start.parentNode.removeChild(start);
        }
      } else {
        sel.range.deleteContents();
      }

      if (fragment.frag) {
        sel.range.insertNode(fragment.frag);
      } else {
        sel.range.insertNode(fragment);
      }
    },
    createContainer: function createContainer(html) {
      var $div = this.dom('<div>');
      if (typeof html === 'string') $div.html(html);else $div.append(this.dom(html).clone(true));
      return $div.get();
    },
    create: function create(html) {
      var el = typeof html === 'string' ? this.createContainer(html) : html;
      var frag = document.createDocumentFragment(),
          node,
          firstNode,
          lastNode;
      var nodes = [];
      var i = 0;

      while (node = el.firstChild) {
        i++;
        var n = frag.appendChild(node);
        if (i === 1) firstNode = n;
        nodes.push(n);
        lastNode = n;
      }

      return {
        frag: frag,
        first: firstNode,
        last: lastNode,
        nodes: nodes
      };
    },
    is: function is(obj) {
      return _typeof(obj) === 'object' && obj.frag;
    }
  });
  ArticleEditor.add('module', 'clipboard', {
    getContent: function getContent(clipboard) {
      var type = this.isPlainText(clipboard) ? 'text/plain' : 'text/html';
      var html = clipboard.getData(type);
      html = type === 'text/plain' ? this.app.content.escapeHtml(html) : html;
      return html;
    },
    setContent: function setContent(e, html, text) {
      var clipboard = e.clipboardData; // unparse

      html = this.app.parser.unparse(html);
      html = '<meta type="' + this.prefix + '-editor"/>' + html;
      text = text || this.app.content.getTextFromHtml(html, {
        nl: true
      }); // set

      clipboard.setData('text/html', html);
      clipboard.setData('text/plain', text);
    },
    isPlainText: function isPlainText(clipboard) {
      var text = clipboard.getData('text/plain');
      var html = clipboard.getData('text/html');

      if (html && html.trim() !== '') {
        return false;
      } else {
        return text !== null;
      }
    }
  });
  ArticleEditor.add('module', 'addbar', {
    init: function init() {
      this.customButtons = {};
    },
    popup: function popup(params, button) {
      // create
      this.app.popup.create('addbar', {
        width: '476px',
        items: this.buildItems()
      }); // open

      this.app.popup.open({
        button: button
      });
    },
    buildItems: function buildItems() {
      var items = {};
      var obj = $ARX.extend(true, this.opts.addbarObj);
      var arr = this.opts.addbar.concat(this.opts.addbarAdd);

      if (this.opts.addbarAdd.length !== 0 && this.opts.addbarAdd.indexOf('text') !== -1) {
        var tin = arr.indexOf('text');
        var pin = arr.indexOf('paragraph');
        var to = pin !== -1 ? pin + 1 : 0; // move text block button

        arr.splice(to, 0, arr.splice(tin, 1)[0]);
      }

      for (var i = 0; i < arr.length; i++) {
        var name = arr[i];
        if (this.opts.addbarHide.indexOf(name) !== -1) continue;
        items[name] = obj[name];
      }

      var customItems = $ARX.extend(true, this.customButtons);
      var instance = this.app.block.get(); // build custom

      for (var key in customItems) {
        items[key] = customItems[key];
      } // build all


      for (var index in items) {
        this._buildItem(instance, items, items[index], index);
      }

      return items;
    },
    add: function add(name, obj) {
      this.customButtons[name] = obj;
    },
    // private
    _buildItem: function _buildItem(instance, items, item, key) {
      // allowed buttons
      if (item.blocks && !instance || instance && item.blocks && !instance.isAllowedButton(key, item)) {
        items[key] = false;
        return;
      }

      items[key] = {
        container: true,
        title: item.title,
        icon: item.icon || key,
        command: item.command,
        params: {
          name: key
        }
      };
    }
  });
  ArticleEditor.add('module', 'marker', {
    start: function start() {
      this.win = this.app.editor.getWinNode();
      this.doc = this.app.editor.getDocNode();
    },
    build: function build(pos) {
      var $marker = this.dom('<span>').attr('id', 'selection-marker-' + pos);
      $marker.addClass(this.prefix + '-selection-marker');
      $marker.html(this.opts.markerChar);
      return $marker.get();
    },
    insert: function insert() {
      this.remove();
      var sel = this.app.selection.get();
      var both = !sel.collapsed;
      if (!sel.range) return;
      var start = this.build('start');
      var end = this.build('end');
      var cloned = sel.range.cloneRange();

      if (both) {
        cloned.collapse(false);
        cloned.insertNode(end);
      }

      cloned.setStart(sel.range.startContainer, sel.range.startOffset);
      cloned.collapse(true);
      cloned.insertNode(start);
      sel.range.setStartAfter(start);

      if (both) {
        sel.range.setEndBefore(end);
      }

      this.app.selection.setRange(sel.range);
    },
    restore: function restore() {
      var start = this.find('start');
      var end = this.find('end');
      var sel = this.app.selection.get();
      var range = sel.range ? sel.range : this.doc.createRange();

      if (start) {
        var prev = end ? end.previousSibling : false;
        var next = start.nextSibling;
        next = next && next.nodeType === 3 && next.textContent.replace(/[\n\t]/g, '') === '' ? false : next;

        if (!end) {
          if (next) {
            range.selectNodeContents(next);
            range.collapse(true);
          } else {
            this._restoreInject(range, start);
          }
        } else if (next && next.id === 'selection-marker-end') {
          this._restoreInject(range, start);
        } else {
          if (prev && next) {
            range.selectNodeContents(prev);
            range.collapse(false);
            range.setStart(next, 0);
          } else if (prev && !next) {
            range.selectNodeContents(prev);
            range.collapse(false);
            range.setStartAfter(start);
          } else {
            range.setStartAfter(start);
            range.setEndBefore(end);
          }
        }

        this.app.selection.setRange(range);
        var fix = start && end ? 2 : 1;
        var offset = this.app.offset.get();
        offset = {
          start: offset.start - fix,
          end: offset.end - fix
        };
        if (start) start.parentNode.removeChild(start);
        if (end) end.parentNode.removeChild(end);
        this.app.editor.getWin().focus();
        this.app.offset.set(offset);
      }
    },
    find: function find(pos) {
      var $editor = this.app.editor.getLayout();
      var $marker = $editor.find('#selection-marker-' + pos);
      return $marker.length !== 0 ? $marker.get() : false;
    },
    remove: function remove() {
      var start = this.find('start');
      var end = this.find('end');
      if (start) start.parentNode.removeChild(start);
      if (end) end.parentNode.removeChild(end);
    },
    // private
    _restoreInject: function _restoreInject(range, start) {
      var textNode = this.app.utils.createInvisibleChar();
      this.dom(start).after(textNode);
      range.selectNodeContents(textNode);
      range.collapse(false);
    }
  });
  ArticleEditor.add('module', 'format', {
    popup: function popup(params, button) {
      var instance = this.app.block.get();
      var tag = instance.getTag();
      var tags = this.opts.format; // build items

      var items = {};

      for (var i = 0; i < tags.length; i++) {
        var key = tags[i];
        items[key] = {
          title: this.opts.formatObj[key].title,
          params: {
            tag: key
          },
          command: 'block.format',
          shortcut: this.opts.formatObj[key].shortcut,
          active: key === tag
        };
      }

      this.app.popup.create('format', {
        width: '300px',
        items: items
      });
      this.app.popup.open({
        button: button
      });
    },
    set: function set(params) {
      // popup
      if (this.app.popup.isOpen()) {
        this.app.popup.close();
      } // blocks


      if (this.app.blocks.is()) {
        return;
      }

      var instance = this.app.block.get();
      var isEmpty = instance.isEmpty();
      var caret = isEmpty ? 'start' : false;
      var format = {
        type: this.opts.formatObj[params.tag].type,
        tag: params.tag
      };
      var $items; // current params

      this.tag = instance.getTag();
      this.type = instance.getType();
      this.$block = instance.getBlock(); // selection

      if (!isEmpty) {
        this.app.selection.saveMarker();
      } // check same


      if (this._isSameTag(format)) {
        format = this._checkSameFormat(format);
      } // format


      if (format) {
        if (this._isListToText(format, 'list')) {
          $items = this._formatListToText(format);
        } else if (this._isListToText(format, 'dlist')) {
          $items = this._formatListToText(format, true);
        } else if (this._isTextToList(format, 'list')) {
          this._formatTextToList(format, false, caret);
        } else if (this._isTextToList(format, 'dlist')) {
          this._formatTextToList(format, true, caret);
        } else {
          this._replaceTo(instance, format, caret);
        }
      } // restore


      if (!isEmpty) {
        this.app.selection.restoreMarker();
      }

      if ($items) {
        var $block = this.app.selection.getDataBlock();
        this.app.block.set($block, caret);
      } // broadcast


      instance = this.app.block.get();
      this.app.broadcast('block.format', {
        instance: instance
      });
    },
    // private
    _isSameTag: function _isSameTag(format) {
      return this.tag === format.tag && this.type === format.type;
    },
    _checkSameFormat: function _checkSameFormat(format) {
      if (['heading', 'list', 'dlist', 'address'].indexOf(this.type) !== -1) {
        format = this._buildDefaultFormat();
      } else if (['paragraph', 'text'].indexOf(this.type) !== -1) {
        format = false;
      }

      return format;
    },
    _buildDefaultFormat: function _buildDefaultFormat() {
      var type = this.opts.editor.markup;
      var tag = type === 'paragraph' ? 'p' : 'div';
      return {
        type: type,
        tag: tag
      };
    },
    _formatListToText: function _formatListToText(format, dlist) {
      var $items = dlist ? this._getDlistItems() : this._getListItems();

      this._createItems($items, format);

      this.$block.remove();
      return $items;
    },
    _formatTextToList: function _formatTextToList(format, dlist, caret) {
      var newInstance = this.app.create('block.' + format.type, '<' + format.tag + '>');
      var $newBlock = newInstance.getBlock();

      if (dlist && this.type === 'list') {
        var z = 0;

        this._getListItems().each(function ($node) {
          var tag = z === 0 ? 'dt' : 'dd';
          var $item = this.dom('<' + tag + '>').html($node.html());
          z = tag === 'dt' ? 1 : 0;
          $newBlock.append($item);
        }.bind(this));
      } else if (!dlist && this.type === 'dlist') {
        this._getDlistItems().each(function ($node) {
          var $item = this.dom('<li>').html($node.html());
          $newBlock.append($item);
        }.bind(this));
      } else {
        var tag = dlist ? '<dt>' : '<li>';
        var $item = this.dom(tag).html(this.$block.html());
        $newBlock.append($item);
      } // parse instance


      this.app.create('block.' + format.type, $newBlock);
      this.$block.after($newBlock);
      this.$block.remove(); // set

      this.app.block.set($newBlock, caret);
    },
    _replaceTo: function _replaceTo(instance, format, caret) {
      var $block = instance.getBlock();
      var $newBlock = this.app.element.replaceToTag($block, format.tag); // clean classes & styles

      $newBlock.removeAttr('style class data-' + this.prefix + '-style-cache'); // new instance

      this.app.create('block.' + format.type, $newBlock); // set

      this.app.block.set($newBlock, caret);
    },
    _createItems: function _createItems($items, format) {
      $items.each(function ($node) {
        var $item = this.dom('<' + format.tag + '>');
        $item.html($node.html());
        $node.remove();
        this.app.create('block.' + format.type, $item);
        this.$block.before($item);
      }.bind(this));
    },
    _isListToText: function _isListToText(format, type) {
      return this.type === type && ['heading', 'address', 'paragraph', 'text'].indexOf(format.type) !== -1;
    },
    _isTextToList: function _isTextToList(format, type) {
      var checkType = type === 'list' ? 'dlist' : 'list';
      return format.type === type && ['heading', 'address', 'paragraph', 'text', checkType].indexOf(this.type) !== -1;
    },
    _getListItems: function _getListItems() {
      var $items = this.$block.find('li');
      $items.find('ul, ol').each(function ($node) {
        $node.parent().after($node);
      });
      $items.find('ul, ol').unwrap();
      return $items;
    },
    _getDlistItems: function _getDlistItems() {
      return this.$block.find('dt, dd');
    }
  });
  ArticleEditor.add('module', 'inline', {
    removeFormat: function removeFormat() {
      this.app.popup.close();
      var instance = this.app.block.get();
      var $block = instance.getBlock();
      this.app.selection.save($block);
      var nodes = this.app.selection.getNodes({
        type: 'inline'
      });

      for (var i = 0; i < nodes.length; i++) {
        var $node = this.dom(nodes[i]);

        if (!$node.attr('data-' + this.prefix + '-type')) {
          $node.unwrap();
        }
      }

      this.app.selection.restore();
      this.app.toolbar.observe();
    },
    set: function set(params) {
      // popup
      if (this.app.popup.isOpen()) {
        this.app.popup.close();
      } // params


      this.params = params;
      var nodes = [];
      var sel = this.app.selection.get();

      if (sel.collapsed) {
        nodes = this.formatCollapsed();
      } else {
        nodes = this.formatUncollapsed();
      }

      this.app.toolbar.observe();
      this.app.broadcast('inline.format', {
        nodes: nodes
      });
      return nodes;
    },
    formatCollapsed: function formatCollapsed() {
      var node;
      var inline = this.app.selection.getInline();
      var $inline = this.dom(inline);

      var tags = this._getParamsTags();

      var hasSameTag = this._isSameTag(inline, tags);

      var caret = this.params && this.params.caret ? this.params.caret : false; // 1) not inline

      if (!inline) {
        node = this._insertInline(this.params.tag, caret);
      } else {
        // 2) inline is empty
        if (this.app.content.isEmptyHtml(inline.innerHTML)) {
          // 2.1) has same tag
          if (hasSameTag) {
            this.app.caret.set(inline, caret ? caret : 'after');
            $inline.remove();
          } // 2.2) has a different tag
          else {
              var $el = this.app.element.replaceToTag(inline, this.params.tag);
              this.app.caret.set($el, caret ? caret : 'start');
            }
        } // 3) inline isn't empty
        else {
            // 3.1) has same tag
            if (hasSameTag) {
              var extractedContent = this.app.content.extractHtmlFromCaret(inline);
              var $secondPart = this.dom('<' + this.params.tag + ' />');
              $secondPart = this.app.element.cloneAttrs(inline, $secondPart);
              $inline.after($secondPart.append(extractedContent));
              this.app.caret.set($secondPart, caret ? caret : 'before');
            } // 3.2) has a different tag
            else {
                node = this._insertInline(this.params.tag, caret);
              }
          }
      }

      return node ? node : [];
    },
    formatUncollapsed: function formatUncollapsed() {
      var instance = this.app.block.get();
      var $block = instance.getBlock();
      var inlines = this.app.selection.getNodes({
        type: 'inline'
      }); // convert del / u

      this._convertTags('u', instance); // convert target tags


      this._convertToStrike(inlines, instance); // save selection


      this.app.selection.save($block); // apply strike

      this.app.editor.getDocNode().execCommand('strikethrough'); // revert to inlines

      var nodes = this._revertToInlines(instance); // restore selection


      this.app.selection.restore(); // filter if node is not selected

      var finalNodes = [];
      var selected = this.app.selection.getText();

      for (var i = 0; i < nodes.length; i++) {
        if (this._isInSelection(nodes[i], selected)) {
          finalNodes.push(nodes[i]);
        }
      } // clear and normalize


      this._clearEmptyStyle(); // apply attr


      if (this.params && typeof this.params.attr !== 'undefined') {
        for (var z = 0; z < finalNodes.length; z++) {
          for (var name in this.params.attr) {
            finalNodes[z].setAttribute(name, this.params.attr[name]);
          }
        }
      }

      this.app.selection.save($block);
      $block.get().normalize();

      this._revertTags('u', instance);

      this.app.selection.restore(); // caret

      if (this.params && this.params.caret) {
        var len = finalNodes.length;
        var last = finalNodes[len - 1];
        this.app.caret.set(last, this.params.caret);
      }

      return finalNodes;
    },
    // private
    _clearEmptyStyle: function _clearEmptyStyle() {
      var inlines = this.app.selection.getNodes({
        type: 'inline'
      });

      for (var i = 0; i < inlines.length; i++) {
        this._clearEmptyStyleAttr(inlines[i]);

        var childNodes = inlines[i].childNodes;

        if (childNodes) {
          for (var z = 0; z < childNodes.length; z++) {
            this._clearEmptyStyleAttr(childNodes[z]);
          }
        }
      }
    },
    _clearEmptyStyleAttr: function _clearEmptyStyleAttr(node) {
      if (node.nodeType !== 3 && node.getAttribute('style') === '') {
        node.removeAttribute('style');
      }
    },
    _isSameTag: function _isSameTag(inline, tags) {
      return inline && tags.indexOf(inline.tagName.toLowerCase()) !== -1;
    },
    _isInSelection: function _isInSelection(node, selected) {
      var text = this.app.utils.removeInvisibleChars(node.textContent);
      return selected.search(new RegExp(this.app.utils.escapeRegExp(text))) !== -1;
    },
    _insertInline: function _insertInline(nodes, tag, caret) {
      return this.app.insertion.insertNode(document.createElement(tag), caret ? caret : 'start');
    },
    _convertTags: function _convertTags(tag, instance) {
      if (this.params.tag !== tag) {
        var $block = instance.getBlock();
        $block.find(tag).each(function (node) {
          var $el = this.app.element.replaceToTag(node, 'span');
          $el.addClass(this.prefix + '-convertable-' + tag);
        }.bind(this));
      }
    },
    _revertTags: function _revertTags(tag, instance) {
      var $block = instance.getBlock();
      $block.find('span.' + this.prefix + '-convertable-' + tag).each(function (node) {
        var $el = this.app.element.replaceToTag(node, tag);
        $el.removeClass(this.prefix + '-convertable-' + tag);
        if (this.app.element.removeEmptyAttrs($el, 'class')) $el.removeAttr('class');
      }.bind(this));
    },
    _convertToStrike: function _convertToStrike(inlines, instance) {
      var $block = instance.getBlock();
      this.app.selection.save($block);

      var tags = this._getParamsTags();

      for (var i = 0; i < inlines.length; i++) {
        var inline = inlines[i];
        var $inline = this.dom(inline);
        var tag = inlines[i].tagName.toLowerCase();

        if (tags.indexOf(tag) !== -1) {
          this._replaceToStrike($inline);
        }
      }

      this.app.selection.restore();
    },
    _getParamsTags: function _getParamsTags() {
      var tags = [this.params.tag];

      if (this.params.tag === 'b' || this.params.tag === 'strong') {
        tags = ['b', 'strong'];
      } else if (this.params.tag === 'i' || this.params.tag === 'em') {
        tags = ['i', 'em'];
      }

      return tags;
    },
    _replaceToStrike: function _replaceToStrike($el) {
      $el.replaceWith(function () {
        return this.dom('<strike>').append($el.html());
      }.bind(this));
    },
    _revertToInlines: function _revertToInlines(instance) {
      var nodes = [];
      var $block = instance.getBlock(); // strike

      $block.find('strike').each(function (node) {
        var $node = this.app.element.replaceToTag(node, this.params.tag);
        nodes.push($node.get());
      }.bind(this));
      return nodes;
    }
  });
  ArticleEditor.add('module', 'codemirror', {
    init: function init() {
      this.cm = false;
    },
    create: function create(params) {
      if (!this.is()) return;
      var opts = _typeof(this.opts.codemirror) === 'object' ? this.opts.codemirror : {};
      var instance = this.opts.codemirrorSrc ? this.opts.codemirrorSrc : CodeMirror;
      this.cm = instance.fromTextArea(this.dom(params.el).get(), opts);
      if (params.height) this.cm.setSize(null, params.height);
      if (params.focus) this.cm.focus();
      return this.cm;
    },
    destroy: function destroy(html) {
      if (this.cm) {
        this.cm.toTextArea();
        this.cm = false;
      }
    },
    is: function is() {
      return this.opts.codemirror;
    },
    val: function val(html) {
      if (this.is() && this.cm) {
        html = this.cm.getValue();
      }

      return html;
    }
  });
  ArticleEditor.add('class', 'upload', {
    defaults: {
      type: 'image',
      box: false,
      url: false,
      cover: true,
      // 'cover'
      name: 'file',
      data: false,
      multiple: true,
      placeholder: false,
      hidden: true,
      target: false,
      success: false,
      error: false,
      remove: false,
      trigger: false,
      input: false
    },
    init: function init($el, params) {
      this.eventname = this.prefix + '-upload';

      if ($el) {
        this._build($el, params);
      }
    },
    send: function send(e, files, params) {
      this.p = this._buildParams(params);

      this._send(e, files);
    },
    complete: function complete(response, e) {
      this._complete(response, e);
    },
    // build
    _build: function _build($el, params) {
      this.p = this._buildParams(params);
      this.$element = this.dom($el);
      var tag = this.$element.get().tagName;

      if (tag === 'INPUT') {
        this._buildByInput();
      } else {
        this._buildByBox();
      }
    },
    _buildParams: function _buildParams(params) {
      return $ARX.extend(true, this.defaults, params);
    },
    // by input
    _buildByInput: function _buildByInput() {
      this.$input = this.$element; // box

      if (this.p.box) {
        this._buildBox();

        this._buildPlaceholder();
      } // input
      else {
          this.p.input = true;
        }

      this._buildAccept();

      this._buildMultiple();

      this._buildEvents();
    },
    // by box
    _buildByBox: function _buildByBox() {
      this._buildInput();

      this._buildAccept();

      this._buildMultiple();

      this._buildBox();

      this._buildPlaceholder();

      this._buildEvents();
    },
    _buildBox: function _buildBox() {
      this.$box = this.dom('<div>').addClass(this.prefix + '-form-upload-box');
      this.$element.before(this.$box); // hide

      if (this.p.hidden) {
        this.$element.hide();
      }
    },
    _buildPlaceholder: function _buildPlaceholder() {
      if (!this.p.placeholder) return;
      this.$placeholder = this.dom('<span>').addClass(this.prefix + '-form-upload-placeholder');
      this.$placeholder.html(this.p.placeholder);
      this.$box.append(this.$placeholder);
    },
    _buildInput: function _buildInput() {
      this.$input = this.dom('<input>');
      this.$input.attr('type', 'file');
      this.$input.attr('name', this._getUploadParam());
      this.$input.hide();
      this.$element.before(this.$input);
    },
    _buildAccept: function _buildAccept() {
      if (this.p.type !== 'image') return;
      var types = this.opts.image.types.join(',');
      this.$input.attr('accept', types);
    },
    _buildMultiple: function _buildMultiple() {
      if (this.p.type !== 'image') return;

      if (this.p.multiple) {
        this.$input.attr('multiple', 'multiple');
      } else {
        this.$input.removeAttr('multiple');
      }
    },
    _buildEvents: function _buildEvents() {
      this.$input.on('change.' + this.eventname + '-' + this.uuid, this._change.bind(this));

      if (this.p.input === false) {
        this.$box.on('click.' + this.eventname, this._click.bind(this));
        this.$box.on('drop.' + this.eventname, this._drop.bind(this));
        this.$box.on('dragover.' + this.eventname, this._dragover.bind(this));
        this.$box.on('dragleave.' + this.eventname, this._dragleave.bind(this));
      }
    },
    _buildData: function _buildData(name, files, data) {
      if (this.p.multiple) {
        for (var i = 0; i < files.length; i++) {
          data.append(name + '[]', files[i]);
        }
      } else {
        data.append(name + '[]', files[0]);
      }

      return data;
    },
    // get
    _getUploadParam: function _getUploadParam() {
      return this.p.name;
    },
    // events
    _click: function _click(e) {
      e.preventDefault();
      this.$input.click();
    },
    _change: function _change(e) {
      this._send(e, this.$input.get().files);
    },
    _drop: function _drop(e) {
      e.preventDefault();

      this._send(e);
    },
    _dragover: function _dragover(e) {
      e.preventDefault();

      this._setStatus('hover');

      return false;
    },
    _dragleave: function _dragleave(e) {
      e.preventDefault();

      this._removeStatus();

      return false;
    },
    // set
    _setStatus: function _setStatus(status) {
      if (this.p.input || !this.p.box) return;

      this._removeStatus();

      this.$box.addClass(this.prefix + '-form-upload-' + status);
    },
    // remove
    _removeStatus: function _removeStatus() {
      if (this.p.input || !this.p.box) return;
      var status = ['hover', 'error'];

      for (var i = 0; i < status.length; i++) {
        this.$box.removeClass(this.prefix + '-form-upload-' + status[i]);
      }
    },
    // send
    _send: function _send(e, files) {
      files = files || e.dataTransfer.files;
      var data = new FormData();

      var name = this._getUploadParam();

      data = this._buildData(name, files, data);
      data = this.app.utils.extendData(data, this.p.data); // send data

      this._sendData(e, files, data);
    },
    _sendData: function _sendData(e, files, data) {
      if (typeof this.p.url === 'function') {
        this.p.url.call(this.app, this, {
          data: data,
          files: files,
          e: e
        });
      } else {
        this.app.progress.show();
        this.ajax.post({
          url: this.p.url,
          data: data,
          before: function (xhr) {
            var event = this.app.broadcast('upload.before.send', {
              xhr: xhr,
              data: data,
              files: files,
              e: e
            });

            if (event.isStopped()) {
              this.app.progress.hide();
              return false;
            }
          }.bind(this),
          success: function (response) {
            this._complete(response, e);
          }.bind(this)
        });
      }
    },
    // complete
    _complete: function _complete(response, e) {
      if (response && response.error) {
        this._setStatus('error');

        if (this.p.error) {
          this.app.broadcast('upload.error', {
            response: response
          });
          this.app.api(this.p.error, response, e);
        }
      } else {
        this._removeStatus();

        if (this.p.success) {
          this.app.broadcast('upload.complete', {
            response: response
          });
          this.app.api(this.p.success, response, e);
        }
      }

      setTimeout(this.app.progress.hide.bind(this.app), 500);
    }
  });
  ArticleEditor.add('module', 'progress', {
    stop: function stop() {
      this.hide();
    },
    show: function show() {
      this.hide();
      this.$progress = this.dom('<div>');
      this.$progress.attr('id', this.prefix + '-progress');
      this.$progress.addClass(this.prefix + '-editor-progress');
      this.$progressBar = this.dom('<span>');
      this.$progress.append(this.$progressBar);
      this.app.$body.append(this.$progress);
    },
    hide: function hide(settings) {
      this.app.$body.find('#' + this.prefix + '-progress').remove();
    }
  });
  ArticleEditor.add('module', 'sync', {
    build: function build() {
      this.syncedHtml = this.app.$element.val();
    },
    trigger: function trigger() {
      if (!this.opts.editor.sync) return;

      var html = this._getHtml();

      if (this.is(html)) {
        if (this.timeout) {
          clearTimeout(this.timeout);
        }

        this.timeout = setTimeout(function () {
          this._sync(html);
        }.bind(this), 200);
      }
    },
    invoke: function invoke() {
      var html = this._getHtml();

      this.syncedHtml = html;

      this._sync(html);
    },
    is: function is(html) {
      var sync = false;

      if (this.syncedHtml !== html) {
        this.syncedHtml = html;
        sync = true;
      }

      return sync;
    },
    // private
    _getHtml: function _getHtml() {
      var html = this.app.editor.getLayout().html();
      return this.app.parser.unparse(html);
    },
    _sync: function _sync(html) {
      var event = this.app.broadcast('editor.before.change', {
        html: html
      });

      if (!event.isStopped()) {
        this.app.$element.val(event.get('html'));
        this.app.autosave.send();
        this.app.state.trigger();
        this.app.broadcast('editor.change', event);
      }
    }
  });
  ArticleEditor.add('module', 'autosave', {
    send: function send() {
      if (this.opts.autosave.url) {
        this._sending();
      }
    },
    // private
    _getName: function _getName() {
      var name;

      if (this.opts.autosave.name) {
        name = this.opts.autosave.name;
      } else {
        name = this.app.$element.attr('name');
        name = !name ? 'content' + this.uuid : name;
      }

      return name;
    },
    _sending: function _sending() {
      var name = this._getName();

      var data = {};
      data[name] = this.app.$element.val();
      data = this.app.utils.extendData(data, this.opts.autosave.data);
      this.ajax.post({
        url: this.opts.autosave.url,
        data: data,
        before: function (xhr) {
          var event = this.app.broadcast('autosave.before.send', {
            xhr: xhr,
            name: name,
            data: data
          });

          if (event.isStopped()) {
            return false;
          }
        }.bind(this),
        success: function (response) {
          this._complete(response, name, data);
        }.bind(this)
      });
    },
    _complete: function _complete(response, name, data) {
      var callback = response && response.error ? 'autosave.error' : 'autosave.send';
      this.app.broadcast(callback, {
        name: name,
        data: data,
        response: response
      });
    }
  });
  ArticleEditor.add('module', 'tidy', {
    init: function init() {},
    parse: function parse(code) {
      // clean setup
      var ownLine = [];
      var contOwnLine = [];
      var newLevel = ['p', 'ul', 'ol', 'div', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'blockquote', 'figure', 'figcaption', 'table', 'thead', 'tbody', 'tfoot', 'tr', 'td', 'th'];
      this.lineBefore = new RegExp('^<(/?' + ownLine.join('|/?') + '|' + contOwnLine.join('|') + ')[ >]');
      this.lineAfter = new RegExp('^<(br|/?' + ownLine.join('|/?') + '|/' + contOwnLine.join('|/') + ')[ >]');
      this.newLevel = new RegExp('^</?(' + newLevel.join('|') + ')[ >]');
      var i = 0,
          codeLength = code.length,
          point = 0,
          start = null,
          end = null,
          tag = '',
          out = '',
          cont = '';
      this.cleanlevel = 0;

      for (; i < codeLength; i++) {
        point = i; // if no more tags, copy and exit

        if (-1 === code.substr(i).indexOf('<')) {
          out += code.substr(i);
          return this.finish(out);
        } // copy verbatim until a tag


        while (point < codeLength && code.charAt(point) !== '<') {
          point++;
        }

        if (i !== point) {
          cont = code.substr(i, point - i);

          if (!cont.match(/^\s{2,}$/g)) {
            if ('\n' === out.charAt(out.length - 1)) out += this.getTabs();else if ('\n' === cont.charAt(0)) {
              out += '\n' + this.getTabs();
              cont = cont.replace(/^\s+/, '');
            }
            out += cont;
          }

          if (cont.match(/\n/)) out += '\n' + this.getTabs();
        }

        start = point; // find the end of the tag

        while (point < codeLength && '>' !== code.charAt(point)) {
          point++;
        }

        tag = code.substr(start, point - start);
        i = point;
        var t;

        if ('!--' === tag.substr(1, 3)) {
          if (!tag.match(/--$/)) {
            while ('-->' !== code.substr(point, 3)) {
              point++;
            }

            point += 2;
            tag = code.substr(start, point - start);
            i = point;
          }

          if ('\n' !== out.charAt(out.length - 1)) out += '\n';
          out += this.getTabs();
          out += tag + '>\n';
        } else if ('!' === tag[1]) {
          out = this.placeTag(tag + '>', out);
        } else if ('?' === tag[1]) {
          out += tag + '>\n';
        } else if (t === tag.match(/^<(script|style|pre)/i)) {
          t[1] = t[1].toLowerCase();
          tag = this.cleanTag(tag);
          out = this.placeTag(tag, out);
          end = String(code.substr(i + 1)).toLowerCase().indexOf('</' + t[1]);

          if (end) {
            cont = code.substr(i + 1, end);
            i += end;
            out += cont;
          }
        } else {
          tag = this.cleanTag(tag);
          out = this.placeTag(tag, out);
        }
      }

      return this.finish(out);
    },
    getTabs: function getTabs() {
      var s = '';

      for (var j = 0; j < this.cleanlevel; j++) {
        s += '    ';
      }

      return s;
    },
    finish: function finish(code) {
      code = code.replace(/\n\s*\n/g, '\n');
      code = code.replace(/^[\s\n]*/, '');
      code = code.replace(/[\s\n]*$/, '');
      code = code.replace(/<script(.*?)>\n<\/script>/gi, '<script$1></script>');
      this.cleanlevel = 0;
      return code;
    },
    cleanTag: function cleanTag(tag) {
      var tagout = '';
      tag = tag.replace(/\n/g, ' ');
      tag = tag.replace(/\s{2,}/g, ' ');
      tag = tag.replace(/^\s+|\s+$/g, ' ');
      var suffix = '';

      if (tag.match(/\/$/)) {
        suffix = '/';
        tag = tag.replace(/\/+$/, '');
      }

      var m;

      while (m = /\s*([^= ]+)(?:=((['"']).*?\3|[^ ]+))?/.exec(tag)) {
        if (m[2]) tagout += m[1].toLowerCase() + '=' + m[2];else if (m[1]) tagout += m[1].toLowerCase();
        tagout += ' ';
        tag = tag.substr(m[0].length);
      }

      return tagout.replace(/\s*$/, '') + suffix + '>';
    },
    placeTag: function placeTag(tag, out) {
      var nl = tag.match(this.newLevel);

      if (tag.match(this.lineBefore) || nl) {
        out = out.replace(/\s*$/, '');
        out += '\n';
      }

      if (nl && '/' === tag.charAt(1)) this.cleanlevel--;
      if ('\n' === out.charAt(out.length - 1)) out += this.getTabs();
      if (nl && '/' !== tag.charAt(1)) this.cleanlevel++;
      out += tag;

      if (tag.match(this.lineAfter) || tag.match(this.newLevel)) {
        out = out.replace(/ *$/, '');
        out += '\n';
      }

      return out;
    }
  });
  ArticleEditor.add('module', 'autolink', {
    parse: function parse(html) {
      if (!this.opts.paste.autolink) {
        return html;
      }

      var storedComments = []; // store comments

      html = this.app.content.storeComments(html, storedComments); // remove doctype tag

      html = this.app.content.removeDoctype(html);
      var tags = ['figure', 'html', 'form', 'pre', 'iframe', 'code', 'a', 'img', 'link', 'script'];
      var stored = [];
      var z = 0; // store tags

      for (var i = 0; i < tags.length; i++) {
        var reTags = tags[i] === 'img' || tags[i] === 'html' ? '<' + tags[i] + '[^>]*>' : '<' + tags[i] + '[^>]*>([\\w\\W]*?)</' + tags[i] + '>';
        var matched = html.match(new RegExp(reTags, 'gi'));

        if (matched !== null) {
          for (var y = 0; y < matched.length; y++) {
            html = html.replace(matched[y], '#####replaceparse' + z + '#####');
            stored.push(matched[y]);
            z++;
          }
        }
      } // links


      html = html.replace('&amp;', '&');

      if (html.match(this.opts.regex.url) && !html.match(this.opts.regex.imageurl)) {
        html = this._formatLinks(html);
      } // restore


      html = this._restoreReplaced(stored, html);
      html = this.app.content.restoreComments(html, storedComments); // repeat for nested tags

      html = this._restoreReplaced(stored, html);
      return html;
    },
    // private
    _formatLinks: function _formatLinks(content) {
      var matches = content.match(this.opts.regex.url);
      var obj = {};

      for (var i = 0; i < matches.length; i++) {
        var href = matches[i],
            text = href;
        var linkProtocol = href.match(/(https?|ftp):\/\//i) !== null ? '' : 'http://';
        var regexB = ["/", "&", "="].indexOf(href.slice(-1)) !== -1 ? '' : '\\b';
        var target = this.opts.paste.linkTarget !== false ? ' target="' + this.opts.paste.linkTarget + '"' : '';
        text = text.length > this.opts.link.size ? text.substring(0, this.opts.link.size) + '...' : text;
        text = text.search('%') === -1 ? decodeURIComponent(text) : text; // escaping url

        var regexp = '(' + href.replace(/[-[\]/{}()*+?.\\^$|]/g, '\\$&') + regexB + ')';
        obj[regexp] = '<a href="' + linkProtocol + href.trim() + '"' + target + '>' + text.trim() + '</a>';
      } // replace


      for (var key in obj) {
        content = content.replace(new RegExp(key, 'g'), obj[key]);
      }

      return content;
    },
    _restoreReplaced: function _restoreReplaced(stored, html) {
      for (var i = 0; i < stored.length; i++) {
        html = html.replace('#####replaceparse' + i + '#####', stored[i]);
      }

      return html;
    }
  });
  ArticleEditor.add('module', 'state', {
    init: function init() {
      this.started = false;
      this.storage = false;
      this.state = false;
      this.passed = true;
      this.undoStorage = [];
      this.redoStorage = [];
    },
    load: function load() {
      this.clear();
      this.trigger(true);
    },
    stop: function stop() {
      this.clear();
    },
    clear: function clear() {
      this.storage = false;
      this.state = false;
      this.passed = true;
      this.undoStorage = [];
      this.redoStorage = [];
    },
    get: function get() {
      return this.undoStorage;
    },
    add: function add(e) {
      if (e && (e.ctrlKey || e.metaKey || this._isUndo(e) || this._isRedo(e)) || !this.app.observer.trigger) {
        return;
      } // state


      this.state = this._createState();

      if (this.started === false) {
        this._setState(this.state, 0);

        this.started = true;
      }
    },
    trigger: function trigger(start) {
      if (!this.passed) {
        return;
      } // storage


      var storage = this._createState(); // storage


      if (this.state) {
        storage = this.state;
      } else if (!this.state && !start) {
        storage = this.storage;
        this.started = true;
      }

      this._addState(storage); // previous state


      this.storage = this._createState();
      this.state = false;
    },
    listen: function listen(e) {
      // undo
      if (this._isUndo(e)) {
        e.preventDefault();
        this.undo();
        return true;
      } // redo
      else if (this._isRedo(e)) {
          e.preventDefault();
          this.redo();
          return true;
        }

      this.passed = true;
    },
    undo: function undo() {
      if (!this._hasUndo()) return;
      this.passed = false;

      var state = this._getUndo();

      this._setRedo();

      var $parsed = this.app.parser.parse(state[0]);
      this.app.editor.getLayout().html($parsed.children());

      this._rebuild(state, 'undo');

      var instance = this.app.block.get();
      var el = instance && instance.isEditable() ? instance.getBlock() : false;
      this.app.offset.set(el, state[1]);
    },
    redo: function redo() {
      if (!this._hasRedo()) return;
      this.passed = false;
      var state = this.redoStorage.pop();

      this._addState(state);

      var $parsed = this.app.parser.parse(state[0]);
      this.app.editor.getLayout().html($parsed.children());

      this._rebuild(state, 'redo');

      var instance = this.app.block.get();
      var el = instance && instance.isEditable() ? instance.getBlock() : false;
      this.app.offset.set(el, state[1]);
    },
    // private
    _rebuild: function _rebuild(state, type) {
      this.app.editor.build();
      this.app.editor.getLayout().find('.' + this.prefix + '-block-state').each(function ($node) {
        this.app.block.set($node);
      }.bind(this));
      this.app.broadcast('state.' + type, {
        html: state[0],
        offset: state[1]
      });
    },
    _isUndo: function _isUndo(e) {
      var key = e.which;
      var ctrl = e.ctrlKey || e.metaKey;
      return ctrl && key === 90 && !e.shiftKey && !e.altKey;
    },
    _isRedo: function _isRedo(e) {
      var key = e.which;
      var ctrl = e.ctrlKey || e.metaKey;
      return ctrl && (key === 90 && e.shiftKey || key === 89 && !e.shiftKey) && !e.altKey;
    },
    _hasUndo: function _hasUndo() {
      return this.undoStorage.length !== 0;
    },
    _hasRedo: function _hasRedo() {
      return this.redoStorage.length !== 0;
    },
    _getUndo: function _getUndo() {
      return this.undoStorage.length === 1 ? this.undoStorage[0] : this.undoStorage.pop();
    },
    _createState: function _createState() {
      var html = this.app.editor.getLayout().html();
      html = this.app.utils.wrap(html, function ($w) {
        $w.find('.' + this.prefix + '-block-focus').addClass(this.prefix + '-block-state');
      }.bind(this));
      var instance = this.app.block.get();
      var el = instance && instance.isEditable() ? instance.getBlock() : false;
      var unparsed = this.app.parser.unparse(html);
      var offset = this.app.offset.get(el);
      return {
        html: unparsed,
        offset: offset
      };
    },
    _setState: function _setState(state, pos) {
      this.undoStorage[pos] = [state.html, state.offset];
    },
    _addState: function _addState(state) {
      var last = this.undoStorage[this.undoStorage.length - 1];

      if (typeof last === 'undefined' || last[0] !== state.html) {
        this.undoStorage.push([state.html, state.offset]);

        this._removeOverStorage();
      } else {
        last[1] = state.offset;
      }
    },
    _setRedo: function _setRedo() {
      var state = this._createState();

      this.redoStorage.push([state.html, state.offset]);
      this.redoStorage = this.redoStorage.slice(0, this.opts.state.limit);
    },
    _removeOverStorage: function _removeOverStorage() {
      if (this.undoStorage.length > this.opts.state.limit) {
        this.undoStorage = this.undoStorage.slice(0, this.undoStorage.length - this.opts.state.limit);
      }
    }
  });
  ArticleEditor.add('module', 'statusbar', {
    init: function init() {
      this.items = {};
    },
    start: function start() {
      this._build();
    },
    add: function add(name, html) {
      return this.update(name, html);
    },
    update: function update(name, html) {
      var $item;

      if (typeof this.items[name] !== 'undefined') {
        $item = this.items[name];
      } else {
        $item = this.dom('<li>');
        this.$statusbar.append($item);
        this.items[name] = $item;
      }

      return $item.html(html);
    },
    get: function get(name) {
      return this.items[name] ? this.items[name] : this.items;
    },
    remove: function remove(name) {
      if (this.items[name]) {
        this.items[name].remove();
        delete this.items[name];
      }
    },
    clear: function clear() {
      this.items = {};
      this.$statusbar.html('');
    },
    // private
    _build: function _build() {
      this.$statusbar = this.dom('<ul>');
      this.$statusbar.addClass(this.prefix + '-statusbar ' + this.prefix + '-statusbar-' + this.uuid);
      this.$statusbar.attr('dir', this.opts.editor.direction);
      this.app.container.get('statusbar').append(this.$statusbar);
    }
  });
  ArticleEditor.add('module', 'popup', {
    init: function init() {
      this.name = false;
      this.stack = false;
      this.button = false;
    },
    start: function start() {
      this._build();

      this._buildDepth();
    },
    stop: function stop() {
      this._stopEvents();

      if (this.$popup) {
        this.$popup.remove();
      }
    },
    isOpen: function isOpen(name) {
      var opened = this.$popup.hasClass('open');

      if (name) {
        return this._getName() === name && opened;
      }

      return opened;
    },
    create: function create(name, params) {
      if (this.isOpen(name)) {
        return this.stack;
      }

      this._reset(name);

      this.name = name;

      if (params) {
        params.collapse = false;
      } // create stack


      this.stack = this._createStack(name, params, true);
      this.stack.setActive();
      return this.stack;
    },
    add: function add(name, params) {
      return this._createStack(name, params);
    },
    open: function open(params) {
      // all popups are closed
      if (!this.isOpen()) {
        this._open(params);
      } // current open
      else if (this.isOpen(this.name)) {
          this.close(false);
        } // another is opened
        else {
            this.close(false);

            this._open(params, false);
          }
    },
    close: function close(e) {
      if (!this.isOpen()) return;
      if (e && this._isPopupTarget(e)) return; // close

      this._stopEvents();

      this._resetToolbarToggledButton(); // selection


      if (e !== false) {
        this.app.selection.restore();
      }

      this.$popup.hide();

      this._closed();
    },
    getElement: function getElement() {
      return this.$popup;
    },
    getButton: function getButton() {
      return this.button;
    },
    getStack: function getStack(name) {
      return name ? this._findStack(name) : this._findStackActive();
    },
    renderHeaderBack: function renderHeaderBack(stack) {
      this._buildHeaderBack(stack);
    },
    closeStacks: function closeStacks() {
      this._findStacks().each(function ($node) {
        var stack = $node.dataget('instance');
        stack.close();
      });
    },
    updatePosition: function updatePosition(e) {
      this._buildPosition(e);

      this._cropHeight();
    },
    // open
    _open: function _open(params, animation) {
      // input focus
      this.focus = params && params.focus ? params.focus : false; // selection

      this.app.selection.save(); // build

      this._buildButton(params);

      this._buildName();

      this._setToolbarToggledButton();

      this._startEvents(); // broadcast


      this.app.broadcast('popup.before.open'); // render stack

      this.stack.render(); // build header

      this._buildHeader(); // build position


      this._buildPosition(); // show


      if (animation === false) {
        this.$popup.show();

        this._opened();
      } else {
        this.$popup.fadeIn(100, this._opened.bind(this));
      }
    },
    // build
    _build: function _build() {
      this.$popup = this.dom('<div>').addClass(this.prefix + '-popup ' + this.prefix + '-popup-' + this.uuid).hide();
      this.$popup.attr('dir', this.opts.editor.direction); // header

      this.$header = this.dom('<div>').addClass(this.prefix + '-popup-header');
      this.$popup.append(this.$header); // stacks

      this.$stacks = this.dom('<div>').addClass(this.prefix + '-popup-stacks');
      this.$popup.append(this.$stacks); // append

      this.app.$body.append(this.$popup);
    },
    _buildDepth: function _buildDepth() {
      if (this.opts.bsmodal) {
        this.$popup.css('z-index', 1052); // fix bootstrap modal focus

        if (window.jQuery) jQuery(document).off('focusin.modal');
      }
    },
    _buildButton: function _buildButton(params) {
      if (!params) return;
      this.button = params.hasOwnProperty('button') ? params.button : false;
    },
    _buildFocus: function _buildFocus() {
      if (this.focus) {
        this.getStack().setFocus(this.focus);
      }
    },
    _buildName: function _buildName() {
      this.$popup.attr('data-' + this.prefix + '-popup-name', this.name);
    },
    _buildPosition: function _buildPosition(e) {
      var topFix = 1;
      var pos = this._isButton() ? this._buildPositionButton() : this._buildPositionModal(); // set

      this.$popup.css({
        top: pos.top - topFix + 'px',
        left: pos.left + 'px'
      });
    },
    _buildPositionButton: function _buildPositionButton() {
      var editorRect = this.app.editor.getFrameRect();
      var offset = this.button.getOffset();
      var dim = this.button.getDimension();
      var popupWidth = this.$popup.width();
      var pos = {};

      if (this._isToolbarButton()) {
        pos = {
          top: offset.top + dim.height,
          left: offset.left
        }; // out of the right edge

        if (pos.left + popupWidth > editorRect.right) {
          pos.left = offset.left + dim.width - popupWidth;
        }
      } else {
        pos = {
          top: offset.top + editorRect.top + dim.height,
          left: offset.left + editorRect.left + dim.width / 2 - popupWidth / 2
        }; // out of the right edge

        if (pos.left + popupWidth > editorRect.right) {
          pos.left = editorRect.left + editorRect.width - popupWidth;
        }
      } // out of the left edge


      if (pos.left < editorRect.left || pos.left < 0) {
        pos.left = editorRect.left;
      }

      return pos;
    },
    _buildPositionModal: function _buildPositionModal() {
      var $container = this.app.container.get('bars');
      var offset = $container.offset();
      var height = $container.height();
      var pos = {
        top: offset.top + height,
        left: offset.left
      };
      return pos;
    },
    _buildHeader: function _buildHeader() {
      var stacks = [];
      this.$header.html('');

      this._findStacks().each(function ($node) {
        var stack = $node.dataget('instance');
        var title = stack.getTitle();

        if (title) {
          stacks.push(stack);
        }
      });

      var len = stacks.length; // path

      if (len !== 0) {
        this._buildPath();

        this._buildClose();
      } // items


      for (var i = 0; i < len; i++) {
        var $item = this._buildPathItem(stacks[i]);

        this.$path.append($item);
      }
    },
    _buildHeaderBack: function _buildHeaderBack(stack) {
      this._buildPath();

      this._buildBack(stack);

      this._buildBackItem(stack);
    },
    _buildPath: function _buildPath() {
      var name = this.prefix + '-popup-header-path';
      this.$header.find('.' + name).remove();
      this.$path = this.dom('<div>').addClass(name);
      this.$header.append(this.$path);
    },
    _buildPathItem: function _buildPathItem(stack) {
      var title = stack.getTitle();
      var $item = this.dom('<span>').addClass(this.prefix + '-popup-header-item');
      $item.html(this.lang.parse(title));
      $item.dataset('stack', stack);
      $item.on('click', this._catchOpen.bind(this));

      if (stack.isActive()) {
        $item.addClass('active');
      }

      return $item;
    },
    _buildBack: function _buildBack(stack) {
      var $back = this.dom('<span>').addClass(this.prefix + '-popup-header-item');
      $back.html(this.lang.get('popup.back'));
      $back.dataset('stack-prev', stack.prev);
      $back.dataset('stack-current', stack);
      $back.on('click', this._catchBack.bind(this));
      this.$path.append($back);
    },
    _buildBackItem: function _buildBackItem(stack) {
      var title = stack.getTitle();
      var $item = this.dom('<span>').addClass(this.prefix + '-popup-header-item');
      $item.html(this.lang.parse(title));
      $item.addClass('active');
      this.$path.append($item);
    },
    _buildClose: function _buildClose() {
      var $close = this.dom('<span>').addClass(this.prefix + '-popup-close');
      $close.one('click', this._catchClose.bind(this));
      this.$header.append($close);
    },
    // create
    _createStack: function _createStack(name, params) {
      var stack = this.app.create('popup.stack', name, params);
      this.$stacks.append(stack.getElement());
      return stack;
    },
    // catch
    _catchClose: function _catchClose(e) {
      e.preventDefault();
      e.stopPropagation();
      this.close();
    },
    _catchOpen: function _catchOpen(e) {
      e.preventDefault();
      e.stopPropagation();
      var $target = this.dom(e.target);
      var targetStack = $target.dataget('stack');
      var $items = this.$path.find('.' + this.prefix + '-popup-header-item');
      $items.each(function ($item) {
        var stack = $item.dataget('stack');
        stack.close();
        $item.removeClass('active');
      });
      $target.addClass('active');
      targetStack.open();
    },
    _catchBack: function _catchBack(e) {
      e.preventDefault();
      e.stopPropagation();
      var $item = this.dom(e.target);
      var prev = $item.dataget('stack-prev');
      var current = $item.dataget('stack-current');
      current.collapse();
      prev.rebuild();
      prev.open(); // rebuild header

      this._buildHeader();
    },
    // find
    _findStacks: function _findStacks() {
      return this.$popup.find('.' + this.prefix + '-popup-stack');
    },
    _findStack: function _findStack(name) {
      return this.$popup.find('[data-' + this.prefix + '-popup-stack-name=' + name + ']').dataget('instance');
    },
    _findStackActive: function _findStackActive() {
      return this.$popup.find('.' + this.prefix + '-popup-stack.open').dataget('instance');
    },
    // events
    _startEvents: function _startEvents() {
      var $target = this.app.scroll.getTarget();
      var eventname = this.prefix + '-popup';
      $target.on('resize.' + eventname, this.updatePosition.bind(this));
      $target.on('scroll.' + eventname, this.updatePosition.bind(this));
      this.app.editor.getFrame().on('resize.' + eventname, this.updatePosition.bind(this));
    },
    _stopEvents: function _stopEvents() {
      var eventname = this.prefix + '-popup';
      this.app.scroll.getTarget().off('.' + eventname);
      this.app.editor.getFrame().off('.' + eventname);
    },
    // opened
    _opened: function _opened() {
      this._buildFocus();

      this._cropHeight();

      this.$popup.addClass('open'); // broadcast

      this.app.broadcast('popup.open');
    },
    // closed
    _closed: function _closed() {
      this.$popup.removeAttr('data-' + this.prefix + '-popup-name');
      this.$popup.removeClass('open'); // broadcast

      this.app.broadcast('popup.close');
    },
    // crop
    _cropHeight: function _cropHeight() {
      var $target = this.app.scroll.getTarget();
      var $toolbar = this.app.toolbar.getElement();
      var tolerance = 10;
      var offset = this.$popup.offset();
      var top = offset.top - $target.scrollTop();
      var targetHeight = $target.height();
      var cropHeight = targetHeight - top - tolerance;

      if (this.app.scroll.isTarget()) {
        top = $toolbar.offset().top - $target.offset().top + $toolbar.height();
        var targetOffset = $target.offset();
        var winHeight = this.app.$win.height();
        var winCropHeight = winHeight - targetOffset.top;
        targetHeight = winCropHeight > targetHeight ? targetHeight : winCropHeight;
        cropHeight = targetHeight - top - tolerance;
      }

      this.$popup.css('max-height', cropHeight + 'px');
    },
    // set
    _setToolbarToggledButton: function _setToolbarToggledButton() {
      this.app.toolbar.unsetToggled();
      if (!this._isToolbarButton()) return;
      var name = this.button.getName();
      this.app.toolbar.setToggled(name);
    },
    // is
    _isButton: function _isButton() {
      return this.button;
    },
    _isToolbarButton: function _isToolbarButton() {
      return this.button && (this.button.type === 'toolbar' || this.button.type === 'topbar');
    },
    _isPopupTarget: function _isPopupTarget(e) {
      return this.dom(e.target).closest('.' + this.prefix + '-popup').length !== 0;
    },
    // get
    _getName: function _getName() {
      return this.$popup.attr('data-' + this.prefix + '-popup-name');
    },
    // reset
    _reset: function _reset(name) {
      this.stack = false;
      this.button = false;
      this.$header.html('');
      this.$stacks.html('');
      this.$popup.removeClass('has-items has-form has-footer');
    },
    _resetToolbarToggledButton: function _resetToolbarToggledButton() {
      if (!this.button) return;
      var name = this.button.getName();
      this.app.toolbar.unsetToggled(name);
    }
  });
  ArticleEditor.add('class', 'popup.item', {
    defaults: {
      container: false,
      title: false,
      html: false,
      active: false,
      divider: false,
      remover: false,
      classname: false,
      params: false,
      instance: false,
      observer: false,
      command: false
    },
    init: function init(stack, name, params) {
      this.stack = stack;
      this.name = name;
      this.params = this._buildParams(params);

      this._build();

      this._buildContainer();

      this._buildIcon();

      this._buildTitle();

      this._buildImage();

      this._buildShortcut();

      this._buildActive();

      this._buildHidden();

      this._buildDivider();

      this._buildCommand();

      this._buildRemover();
    },
    // get
    getStack: function getStack() {
      return this.stack;
    },
    getName: function getName() {
      return this.name;
    },
    getParams: function getParams() {
      return this.params.params;
    },
    getElement: function getElement() {
      return this.$item;
    },
    getInstance: function getInstance() {
      return this.params.instance;
    },
    // private
    _build: function _build() {
      this.$item = this.params.html ? this.dom(this.params.html) : this.dom('<div>');
      this.$item.addClass(this.prefix + '-popup-item ' + this.prefix + '-popup-stack-item');
      this.$item.attr({
        'name': this.name
      });
    },
    _buildContainer: function _buildContainer() {
      if (this.params.container) {
        this.$item.addClass(this.prefix + '-popup-item-container');
      }
    },
    _buildTitle: function _buildTitle() {
      if (this.params.title) {
        this.$title = this.dom('<span>').addClass(this.prefix + '-popup-item-title');
        this.$title.html(this.lang.parse(this.params.title));
        this.$item.append(this.$title);
      }
    },
    _buildImage: function _buildImage() {
      if (this.params.image) {
        this.$image = this.dom('<span>').addClass(this.prefix + '-popup-item-image');
        this.$image.html(this.params.image);
        this.$item.append(this.$image);
      }
    },
    _buildIcon: function _buildIcon() {
      if (this.params.icon) {
        this.$icon = this.dom('<span>').addClass(this.prefix + '-popup-item-icon'); // html icon

        if (this.params.icon.search(/</) !== -1) {
          this.$icon.html(this.params.icon);
        } else {
          this.$icon.addClass(this.prefix + '-icon-' + this.params.icon);
        }

        this.$item.append(this.$icon);
      }
    },
    _buildShortcut: function _buildShortcut() {
      if (this.params.shortcut) {
        var meta = /(Mac|iPhone|iPod|iPad)/i.test(navigator.platform) ? '<b>&#8984;</b>' : 'ctrl';
        meta = this.params.shortcut.replace('Ctrl', meta);
        this.$shortcut = this.dom('<span>').addClass(this.prefix + '-popup-item-shortcut');
        this.$shortcut.html(meta);
        this.$item.append(this.$shortcut);
      }
    },
    _buildParams: function _buildParams(params) {
      return $ARX.extend({}, true, this.defaults, params);
    },
    _buildActive: function _buildActive() {
      if (this.params.active) {
        this.$item.addClass('active');
      }
    },
    _buildHidden: function _buildHidden() {
      if (this.params.hidden) {
        this.$item.addClass(this.prefix + '-popup-item-hidden');
      }
    },
    _buildDivider: function _buildDivider() {
      if (this.params.divider) {
        this.$item.addClass(this.prefix + '-popup-item-divider-' + this.params.divider);
      }
    },
    _buildCommand: function _buildCommand() {
      if (this.params.command) {
        this.$item.on('click.' + this.prefix + '-popup-item-' + this.uuid, this._catch.bind(this));
        this.$item.attr('command', this.params.command);
      }
    },
    _buildRemover: function _buildRemover() {
      if (!this.params.title) return;

      if (this.params.remover) {
        var $trash = this.dom('<span>').addClass(this.prefix + '-popup-item-trash ' + this.prefix + '-icon-trash');
        $trash.attr('command', this.params.remover);
        $trash.on('click.' + this.prefix + '-popup-item-' + this.uuid, this._catchRemover.bind(this));
        this.$item.append($trash);
      }
    },
    _catchRemover: function _catchRemover(e) {
      e.preventDefault();
      e.stopPropagation();
      var $item = this.dom(e.target).closest('.' + this.prefix + '-popup-stack-item');
      var $trash = this.dom(e.target).closest('.' + this.prefix + '-popup-item-trash');
      var command = $trash.attr('command');
      var name = $item.attr('name');
      this.app.api(command, this, name);
      $item.fadeOut(200, function ($node) {
        $node.remove();
      });
    },
    _catch: function _catch(e) {
      e.preventDefault();
      e.stopPropagation();
      var $item = this.dom(e.target).closest('.' + this.prefix + '-popup-stack-item');
      var name = $item.attr('name');
      var command = $item.attr('command');
      this.stack.$items.find('.' + this.prefix + '-popup-stack-item').removeClass('active');
      $item.addClass('active'); // command

      this.app.api(command, this.getParams(), this, name, e);
    }
  });
  ArticleEditor.add('class', 'popup.stack', {
    defaults: {
      title: false,
      type: false,
      // grid
      name: false,
      path: false,
      width: false,
      // string like '200px' or '100%'
      setter: false,
      getter: false,
      builder: false,
      observer: false,
      instance: false,
      collapse: true,
      form: false,
      items: false,
      focus: false,
      footer: false
    },
    init: function init(name, params) {
      this.defaultWidth = '240px';
      this.prev = this.app.popup.getStack();
      this.name = name;
      this.tools = {};
      this.params = this._buildParams(params);
      this.$popup = this.app.popup.getElement(); // data

      this.instance = false;
      this.width = false;
      this.type = false;
      this.data = false;
      this.form = false;
      this.items = false;
      this.footer = false;
      this.getter = false;
      this.setter = false; // build

      this._build(); // observe


      if (this.params.observer) {
        this.app.api(this.params.observer, this);
      }
    },
    rebuild: function rebuild() {
      this._renderItems();
    },
    open: function open(params) {
      if (this.isCollapsed()) {
        this.app.popup.closeStacks();
        this.app.popup.renderHeaderBack(this);
      } // active


      this.setActive(); // broadcast

      this.app.broadcast('popup.before.open'); // render

      this.render();
      this.app.popup.updatePosition(); // focus

      if (params && params.focus) {
        this.setFocus(params.focus);
      } // broadcast


      this.app.broadcast('popup.open');
    },
    close: function close() {
      this.$stack.hide();
      this.$stack.removeClass('open');
    },
    collapse: function collapse() {
      this.$stack.remove();
    },
    render: function render() {
      this._renderWidth();

      this._renderType();

      this._renderItems();

      this._renderForm();

      this._renderFooter();
    },
    // updatePosition
    updatePosition: function updatePosition() {
      this.app.popup.updatePosition();
    },
    // is
    isCollapsed: function isCollapsed() {
      return this.params.collapse;
    },
    isActive: function isActive() {
      return this.$stack.hasClass('open');
    },
    // set
    setActive: function setActive() {
      this.$stack.show();
      this.$stack.addClass('open');
    },
    setData: function setData(data) {
      this.data = data;
    },
    setForm: function setForm(form) {
      this.form = form;
    },
    setFooter: function setFooter(footer) {
      this.footer = footer;
    },
    setWidth: function setWidth(width) {
      this.$stack.attr('data-width', width);

      if (width === '100%') {
        width = this.app.container.get('main').width() + 'px';
      }

      this.$stack.css('width', width);
      this.app.$win.on('resize.' + this.prefix + '-stack-' + this.uuid, this._resize.bind(this));

      this._resize();
    },
    setFocus: function setFocus(name) {
      if (typeof this.tools[name] !== 'undefined') {
        this.tools[name].setFocus();
      }
    },
    setItems: function setItems(items) {
      this.items = items;
    },
    setType: function setType(type) {
      this.type = type;
    },
    // get
    getElement: function getElement() {
      return this.$stack;
    },
    getTitle: function getTitle() {
      return this.params.title;
    },
    getName: function getName() {
      return this.name;
    },
    getInstance: function getInstance() {
      return this.instance;
    },
    getItems: function getItems() {
      return this.items;
    },
    getTool: function getTool(name) {
      return typeof this.tools[name] !== 'undefined' ? this.tools[name] : false;
    },
    getInput: function getInput(name) {
      var tool = this.getTool(name);
      return tool ? tool.getInput() : this.dom();
    },
    getFormItem: function getFormItem(name) {
      var tool = this.getTool(name);
      return tool ? tool.getInput().closest('.' + this.prefix + '-form-item') : this.dom();
    },
    getFormElement: function getFormElement() {
      return this.$form;
    },
    getForm: function getForm() {
      return this.form;
    },
    getFooter: function getFooter() {
      return this.footer;
    },
    getBody: function getBody() {
      return this.$body;
    },
    getData: function getData(name) {
      var data;

      if (name) {
        if (typeof this.tools[name] !== 'undefined') {
          data = this.tools[name].getValue();
        }
      } else {
        data = {};

        for (var key in this.tools) {
          data[key] = this.tools[key].getValue();
        }
      }

      return data;
    },
    // build
    _build: function _build() {
      this._buildElement();

      this._buildBody();

      this._buildRender();
    },
    _buildParams: function _buildParams(params) {
      return $ARX.extend({}, true, this.defaults, params);
    },
    _buildElement: function _buildElement() {
      this.$stack = this.dom('<div>').addClass(this.prefix + '-popup-stack ' + this.prefix + '-popup-' + this.name);
      this.$stack.dataset('instance', this);
      this.$stack.attr('data-' + this.prefix + '-popup-stack-name', this.name);
      this.$stack.hide();
    },
    _buildBody: function _buildBody() {
      this.$body = this.dom('<div>').addClass(this.prefix + '-popup-body');
      this.$items = this.dom('<div>').addClass(this.prefix + '-popup-items');
      this.$stack.append(this.$body);
    },
    _buildRender: function _buildRender() {
      this.width = this.params.width ? this.params.width : this.defaultWidth;
      this.type = this.params.type;
      this.form = this.params.form;
      this.footer = this.params.footer;
      this.instance = this.params.instance;
      this.setter = this.params.setter ? this.params.setter : false;
      this.getter = this.params.getter ? this.params.getter : false;
      this.data = this.getter ? this.app.api(this.getter, this) : false; // items

      if (this.params.builder) {
        this.items = this.app.api(this.params.builder, this);
      } else if (this.params.items) {
        this.items = this.params.items;
      }
    },
    // render
    _renderType: function _renderType() {
      this.$stack.removeClass(this.prefix + '-popup-stack-type-grid');

      if (this.type) {
        this.$stack.addClass(this.prefix + '-popup-stack-type-' + this.type);
      }
    },
    _renderWidth: function _renderWidth() {
      this.setWidth(this.width);
    },
    _renderForm: function _renderForm() {
      if (!this.form) return; // build form element

      this.$form = this.dom('<form>').addClass(this.prefix + '-popup-form');
      this.formitems = this.form;

      this._renderTools();

      this._renderData();

      this.$popup.addClass('has-form'); // append

      this.$body.find('.' + this.prefix + '-popup-form').remove();
      this.$body.append(this.$form);
    },
    _renderTools: function _renderTools() {
      for (var name in this.formitems) {
        this._renderTool(name, this.formitems[name]);
      }
    },
    _renderTool: function _renderTool(name, obj) {
      var tool = this.app.create('tool.' + obj.type, name, obj, this, this.data, this.instance);
      var $tool = tool.getElement();

      if ($tool) {
        this.tools[name] = tool;
        this.$form.append($tool);
      }
    },
    _renderData: function _renderData() {
      if (!this.data) return;

      for (var name in this.data) {
        if (typeof this.tools[name] !== 'undefined') {
          this.tools[name].setValue(this.data[name]);
        }
      }
    },
    _renderItems: function _renderItems() {
      this.$popup.removeClass('has-items');
      if (!this.items) return;
      this.$popup.addClass('has-items');
      this.$body.find('.' + this.prefix + '-popup-item').off('.' + this.prefix + '-popup-item-' + this.uuid);
      this.$items.html('');
      this.$body.html('');
      this.$body.append(this.$items); // build items

      for (var name in this.items) {
        if (this.items[name].hasOwnProperty('observer')) {
          var res = this.app.api(this.items[name].observer, this.items[name], name, this);

          if (typeof res !== 'undefined') {
            this.items[name] = res;
          }
        }

        if (this.items[name] === false) continue;
        var item = this.app.create('popup.item', this, name, this.items[name]);
        this.$items.append(item.getElement());
      }
    },
    _renderFooter: function _renderFooter() {
      this.$popup.removeClass('has-footer');
      if (!this.footer) return;
      if (this.$footer) this.$footer.remove();
      this.$footer = this.dom('<div>').addClass(this.prefix + '-popup-footer'); // buttons

      var buttons = this.footer;
      var len = 0;

      for (var key in buttons) {
        if (buttons[key] === false) continue;
        var button = this.app.create('popup.button', key, this, buttons[key]);
        this.$footer.append(button.getElement());
        len++;
      }

      if (len !== 0) {
        this.$stack.append(this.$footer);
        this.$popup.addClass('has-footer');
      }
    },
    _resize: function _resize() {
      var data = this.$stack.attr('data-width');
      var width = this.app.container.get('main').width();

      if (data !== '100%') {
        var w = parseInt(data);

        if (w < width) {
          return;
        }
      }

      this.$stack.css('width', width + 'px');
    }
  });
  ArticleEditor.add('class', 'popup.button', {
    init: function init(name, stack, obj) {
      this.name = name;
      this.obj = obj;
      this.stack = stack;
      this.$button = this.dom('<button>').addClass(this.prefix + '-form-button');
      this.$button.attr('data-name', this.name);
      this.$button.html(this.lang.parse(this.obj.title));
      this.$button.dataset('instance', this);
      if (this._has('type')) this.$button.addClass(this.prefix + '-form-button-' + this.obj.type);
      if (this._has('classname')) this.$button.addClass(this.obj.classname);
      if (this._has('fullwidth')) this.$button.addClass(this.prefix + '-form-button-fullwidth'); // event

      this.$button.on('click.' + this.prefix + '-popup-button' + this.uuid, this._catch.bind(this));
    },
    getName: function getName() {
      return this.name;
    },
    getElement: function getElement() {
      return this.$button;
    },
    // private
    _has: function _has(name) {
      return this.obj.hasOwnProperty(name);
    },
    _catch: function _catch(e) {
      e.preventDefault();
      e.stopPropagation();

      if (this._has('command')) {
        this.app.api(this.obj.command, this.stack, this.name, e);
      } else if (this._has('collapse')) {
        this.stack.collapse();
      } else if (this._has('close')) {
        this.app.popup.close();
      }
    }
  });
  ArticleEditor.add('module', 'link', {
    popups: {
      format: {
        format: {
          title: '## link.link ##',
          command: 'link.format',
          shortcut: 'Ctrl+k'
        },
        unlink: {
          title: '## link.unlink ##',
          command: 'link.unlink'
        }
      },
      edit: {
        edit: {
          title: '## link.edit-link ##',
          command: 'link.edit',
          shortcut: 'Ctrl+k'
        },
        unlink: {
          title: '## link.unlink ##',
          command: 'link.unlink'
        }
      },
      form: {
        text: {
          type: 'input',
          label: '## link.text ##'
        },
        url: {
          type: 'input',
          label: '## link.url ##'
        },
        target: {
          type: 'checkbox',
          text: '## link.link-in-new-tab ##'
        }
      },
      insert: {
        insert: {
          title: '## link.insert ##',
          command: 'link.insert',
          type: 'primary'
        },
        cancel: {
          title: '## link.cancel ##',
          command: 'popup.close'
        }
      },
      save: {
        save: {
          title: '## link.save ##',
          command: 'link.save',
          type: 'primary'
        },
        cancel: {
          title: '## link.cancel ##',
          command: 'popup.close'
        }
      }
    },
    popup: function popup(params, button) {
      // get link
      var $link = this.getLink();
      var popup = $link.length === 0 ? this.popups.format : this.popups.edit;
      this.app.popup.create('link', {
        items: popup
      });
      this.app.popup.open({
        button: button
      });
    },
    format: function format(params) {
      // selection
      var text = this.app.selection.getText(); // popup

      var stack = this.app.popup.create('link-create', {
        title: '## popup.link ##',
        width: '600px',
        form: this.popups.form,
        footer: this.popups.insert
      }); // set data

      stack.setData({
        text: text
      }); // open

      this.app.popup.open({
        focus: text ? 'url' : 'text'
      });
    },
    edit: function edit() {
      // get link
      var $link = this.getLink();
      var stack = this.app.popup.create('link-edit', {
        title: '## popup.link ##',
        width: '600px',
        form: this.popups.form,
        footer: this.popups.save
      }); // set

      var data = {
        text: $link.text(),
        url: $link.attr('href'),
        target: $link.attr('target') || this.opts.link.target
      }; // clean

      data = this._encodeUrl(data); // set data

      stack.setData(data); // open

      this.app.popup.open({
        focus: 'url'
      });
    },
    insert: function insert(stack) {
      this.app.popup.close();
      var nodes = this.app.inline.set({
        tag: 'a',
        caret: 'after'
      });
      var $link = this.dom(nodes); // data

      this._save(stack, $link, 'add');
    },
    save: function save(stack) {
      this.app.popup.close();
      var $link = this.getLink(); // data

      this._save(stack, $link, 'change');
    },
    unlink: function unlink() {
      this.app.popup.close();
      var links = this.app.selection.getNodes({
        tags: ['a']
      });
      if (links.length === 0) return; // unlink

      for (var i = 0; i < links.length; i++) {
        var $link = this.dom(links[i]);
        this.app.broadcast('link.remove', {
          url: $link.attr('href'),
          text: $link.text()
        });
        $link.unwrap();
      } // ui


      this.app.toolbar.observe();
    },
    getLink: function getLink() {
      var links = this.app.selection.getNodes({
        tags: ['a']
      });
      var $link = links.length !== 0 ? this.dom(links[0]) : this.dom([]);
      return $link;
    },
    // private
    _save: function _save(stack, $link, type) {
      var data = stack.getData();
      data = this._cleanUrl(data);
      data = this._encodeUrl(data);
      if (data.url === '') return;
      data = this._setUrl($link, data);

      if ($link.length === 1) {
        data = this._setText($link, data);
      }

      data = this._setTarget($link, data);
      this.app.broadcast('link.' + type, data);
    },
    _cleanUrl: function _cleanUrl(data) {
      data.url = this.app.content.escapeHtml(data.url);
      data.url = data.url.search(/^javascript:/i) !== -1 ? '' : data.url;
      return data;
    },
    _encodeUrl: function _encodeUrl(data) {
      data.url = data.url.replace(/&amp;/g, '&');
      return data;
    },
    _setUrl: function _setUrl($link, data) {
      $link.attr('href', data.url);
      return data;
    },
    _setText: function _setText($link, data) {
      data.text = data.text === '' ? data.url : data.text;
      $link.text(data.text);
      return data;
    },
    _setTarget: function _setTarget($link, data) {
      if (data.target) $link.attr('target', '_blank');else $link.removeAttr('target');
      return data;
    }
  });
  ArticleEditor.add('module', 'embed', {
    popups: {
      insert: {
        insert: {
          title: '## buttons.insert ##',
          command: 'embed.insert',
          type: 'primary'
        },
        cancel: {
          title: '## embed.cancel ##',
          command: 'popup.close'
        }
      },
      save: {
        save: {
          title: '## buttons.save ##',
          command: 'embed.save',
          type: 'primary'
        },
        cancel: {
          title: '## embed.cancel ##',
          command: 'popup.close'
        }
      },
      edit: {
        title: '## embed.embed ##',
        width: '100%',
        form: {
          embed: {
            type: 'textarea',
            label: '## embed.description ##',
            rows: 6
          },
          caption: {
            type: 'input',
            label: '## embed.caption ##'
          },
          responsive: {
            type: 'checkbox',
            text: '## embed.responsive-video ##'
          }
        }
      }
    },
    build: function build(scripts) {
      if (scripts) {
        this._callScripts(scripts);
      } else {
        this._findScripts();
      }
    },
    observe: function observe() {
      if (!this.opts.embed) return false;
    },
    popup: function popup() {
      var popup = this.popups.edit;
      popup.footer = this.popups.insert;
      popup.collapse = true;
      var stack = this.app.popup.add('embed', popup);
      stack.open({
        focus: 'embed'
      }); // codemirror

      this._buildCodemirror(stack);
    },
    edit: function edit(params, button) {
      var instance = this.app.block.get();
      var popup = this.popups.edit;
      popup.footer = this.popups.save;
      var data = {
        embed: instance.getEmbedCode(),
        caption: instance.getCaption(),
        responsive: instance.isResponsive()
      }; // popup & data

      var stack = this.app.popup.create('embed', popup);
      stack.setData(data); // open

      this.app.popup.open({
        button: button,
        focus: 'embed'
      }); // codemirror

      this._buildCodemirror(stack);
    },
    insert: function insert(stack) {
      this.app.popup.close(); // data

      var data = stack.getData();

      var code = this._getEmbedCode(data);

      if (code === '') {
        return;
      } // create


      var instance = this._createInstance(data, code);

      this.app.block.add({
        instance: instance
      });
    },
    save: function save(stack) {
      this.app.popup.close(); // data

      var current = this.app.block.get();
      var data = stack.getData();

      var code = this._getEmbedCode(data);

      if (code === '') {
        this.app.block.remove();
        return;
      } // create


      var instance = this._createInstance(data, code, current); // change


      if (this._isNeedToChange(data, instance, current)) {
        this.app.block.change(instance);
      }
    },
    // private
    _buildCodemirror: function _buildCodemirror(stack) {
      var $input = stack.getInput('embed');
      this.app.codemirror.create({
        el: $input,
        height: '200px',
        focus: true
      });
      this.app.popup.updatePosition();
    },
    _findScripts: function _findScripts() {
      var scripts = this.app.editor.getLayout().find('[data-' + this.prefix + '-type=embed]').find('script').getAll();
      this.build.call(this, scripts);
    },
    _callScripts: function _callScripts(scripts) {
      for (var i = 0; i < scripts.length; i++) {
        if (scripts[i].src !== '') {
          var src = scripts[i].src;
          this.app.editor.getDoc().find('head script[src="' + src + '"]').remove();
          var $script = this.dom('<script>').attr({
            'src': src,
            'async': true,
            'defer': 'true'
          });
          $script.on('load', function () {
            if (src.search('instagram') !== -1) {
              var win = this.app.editor.getWinNode();

              if (win.instgrm) {
                win.instgrm.Embeds.process();
              }
            }

            this.build(scripts.slice(i + 1));
          }.bind(this));
          var head = this.app.editor.getDocNode().getElementsByTagName('head')[0];
          if (head) head.appendChild($script.get());
        } else {
          try {
            eval(scripts[i].innerHTML);
          } catch (e) {}
        }
      }
    },
    _getEmbedCode: function _getEmbedCode(data) {
      var code = data.embed.trim();
      code = this.app.codemirror.val(code);
      code = this.app.content.sanitize(code);
      code = !this._isHtmlString(code) && code !== '' ? this._parseUrl(code) : code;
      return code;
    },
    _createInstance: function _createInstance(data, code, current) {
      var $figure;

      if (current) {
        var figure = current.duplicateEmpty();
        $figure = figure.getBlock();
        $figure.html(code);
      } else {
        $figure = this._isFigure(code) ? code : '<figure>' + code + '</figure>';
      }

      var instance = this.app.create('block.embed', $figure); // caption

      instance.setCaption(data.caption); // responsive

      if (data.responsive) {
        instance.addResponsive();
      }

      return instance;
    },
    _parseUrl: function _parseUrl(str) {
      var iframeStart = '<iframe width="560" height="315" src="';
      var iframeEnd = '" frameborder="0" allowfullscreen></iframe>';
      var parsed;

      if (str.match(this.opts.regex.youtube)) {
        parsed = str.replace(this.opts.regex.youtube, '//www.youtube.com/embed/$1');
        return iframeStart + parsed + iframeEnd;
      } else if (str.match(this.opts.regex.vimeo)) {
        parsed = str.replace(this.opts.regex.vimeo, '//player.vimeo.com/video/$2');
        return iframeStart + parsed + iframeEnd;
      }

      return str;
    },
    _isNeedToChange: function _isNeedToChange(data, instance, current) {
      if (current.getEmbedCode() !== instance.getEmbedCode()) return true;
      if (data.responsive !== current.isResponsive()) return true;
      if (data.caption !== current.getCaption()) return true;
    },
    _isHtmlString: function _isHtmlString(str) {
      return /^\s*<(\w+|!)[^>]*>/.test(str);
    },
    _isFigure: function _isFigure(str) {
      return /^<figure/.test(str);
    }
  });
  ArticleEditor.add('module', 'list', {
    indent: function indent(params, itemInstance) {
      var sel = this.app.selection.get();
      var item = this.app.selection.getBlock();
      var $item = this.dom(item);
      var $prev = $item.prevElement();
      var prev = $prev.get();
      var isIndent = sel.collapsed && item && prev && prev.tagName === 'LI';
      this.app.selection.save(item);

      if (isIndent) {
        $prev = this.dom(prev);
        var $prevChild = $prev.children('ul, ol');
        var $list = $item.closest('ul, ol');

        if ($prevChild.length !== 0) {
          $prevChild.append($item);
        } else {
          var listTag = $list.get().tagName.toLowerCase();
          var $newList = this.dom('<' + listTag + '>');
          $newList.append($item);
          $prev.append($newList);
        }
      }

      this.app.selection.restore();
    },
    outdent: function outdent(params, itemInstance) {
      var sel = this.app.selection.get();
      var item = this.app.selection.getBlock();
      var $item = this.dom(item);

      if (sel.collapsed && item) {
        var $listItem = $item.parent();
        var $liItem = $listItem.closest('li');
        var $prev = $item.prevElement();
        var $next = $item.nextElement();
        var prev = $prev.get();
        var next = $next.get();
        var nextItems, $newList;
        var isTop = prev === false;
        var isMiddle = prev !== false && next !== false;
        this.app.selection.save(item); // out

        if ($liItem.length !== 0) {
          if (isMiddle) {
            nextItems = this._getAllNext($item.get());
            $newList = this.dom('<' + $listItem.get().tagName.toLowerCase() + '>');

            for (var i = 0; i < nextItems.length; i++) {
              $newList.append(nextItems[i]);
            }

            $liItem.after($item);
            $item.append($newList);
          } else {
            $liItem.after($item);

            if ($listItem.children().length === 0) {
              $listItem.remove();
            } else {
              if (isTop) $item.append($listItem);
            }
          }
        }

        this.app.selection.restore();
      }
    },
    // private
    _getAllNext: function _getAllNext(next) {
      var nodes = [];

      while (next) {
        var $next = this.dom(next).nextElement();
        next = $next.get();
        if (next) nodes.push(next);else return nodes;
      }

      return nodes;
    }
  });
  ArticleEditor.add('module', 'grid', {
    popup: function popup() {
      // create
      var stack = this.app.popup.add('grid', {
        title: '## popup.grid ##',
        width: '320px',
        items: this.buildItems()
      });
      stack.open();
    },
    observe: function observe() {
      if (!this.opts.grid) return false;
    },
    buildItems: function buildItems() {
      var items = {};
      var z = 0;

      for (var pattern in this.opts.grid.patterns) {
        z++;

        var $item = this._createPattern(pattern);

        items['column' + z] = {
          html: $item,
          command: 'grid.add',
          params: {
            pattern: pattern,
            columns: this.opts.grid.patterns[pattern]
          }
        };
      }

      return items;
    },
    add: function add(params) {
      this.app.popup.close();
      var pattern = params.columns === '';
      var columns = pattern ? params.pattern.split('|') : params.columns.split('|');
      var $grid = this.dom('<div>').addClass(this.opts.grid.classname);

      if (this.opts.grid.classes !== '') {
        $grid.addClass(this.opts.grid.classes);
      }

      for (var i = 0; i < columns.length; i++) {
        var column = this.app.create('block.column');
        var $column = column.getBlock();

        if (!pattern) {
          $column.addClass(columns[i]);
        }

        $grid.append($column);
      } // add


      var instance = this.app.block.add({
        name: 'grid',
        source: $grid,
        caret: false
      }); // set

      this.app.block.set(instance);
    },
    // private
    _createPattern: function _createPattern(pattern) {
      var $item = this.dom('<div>').addClass(this.prefix + '-popup-grid-box');
      var columns = pattern.split('|');
      var sum = this.app.utils.sumOfArray(columns);
      var unit = 100 / sum;

      for (var i = 0; i < columns.length; i++) {
        var $column = this.dom('<span>');
        $column.addClass(this.prefix + '-popup-grid-column');
        $column.css('width', columns[i] * unit + '%');
        $item.append($column);
      }

      return $item;
    }
  });
  ArticleEditor.add('module', 'image', {
    init: function init() {
      this.dataStates = [];
    },
    popup: function popup() {
      var stack = this.app.popup.add('image', {
        title: '## popup.add-image ##',
        width: '100%'
      });
      stack.open(); // body

      var $body = stack.getBody(); // by url

      if (this.opts.image.url) {
        this._createImageByUrl($body);
      } // section or


      if (this.opts.image.url && (this.opts.image.upload || this.opts.image.select)) {
        this._createOrSection($body);
      } // upload


      this.$upload = this.createUploadBox(this.opts.image.upload, $body); // list of images

      this.createSelectBox(this.opts.image.select, $body, 'image.insertFromSelect'); // build upload

      this._buildUpload(this.$upload, 'image.insertByUpload');
    },
    edit: function edit(params, button) {
      this.app.popup.create('image-edit', {
        title: '## popup.image ##',
        width: '100%',
        getter: 'block.getData',
        setter: 'block.setData',
        form: {
          alt: {
            type: 'input',
            label: '## image.alt-text ##'
          },
          caption: {
            type: 'input',
            label: '## image.caption ##',
            observer: 'image.observeImageCaption'
          },
          link: {
            type: 'input',
            label: '## image.link ##',
            observer: 'image.observeImageLink'
          },
          target: {
            type: 'checkbox',
            text: '## image.link-in-new-tab ##',
            observer: 'image.observeImageLink'
          }
        },
        footer: {
          'save': {
            title: '## image.save ##',
            command: 'image.save',
            type: 'primary'
          },
          'cancel': {
            title: '## image.cancel ##',
            command: 'popup.close'
          }
        }
      }); // upload

      this._buildEditUpload(); // open


      this.app.popup.open({
        button: button
      });
    },
    editCard: function editCard(params, button) {
      this.app.popup.create('image-edit', {
        title: '## popup.image ##',
        width: '100%',
        getter: 'block.getData',
        setter: 'block.setData',
        form: {
          alt: {
            type: 'input',
            label: '## image.alt-text ##'
          }
        },
        footer: {
          'save': {
            title: '## image.save ##',
            command: 'image.save',
            type: 'primary'
          },
          'cancel': {
            title: '## image.cancel ##',
            command: 'popup.close'
          }
        }
      }); // upload

      this._buildEditUpload(); // open


      this.app.popup.open({
        button: button
      });
    },
    observe: function observe() {
      if (!this.opts.image) return false;
    },
    observeStates: function observeStates() {
      this._findImages().each(this._addImageState.bind(this));
    },
    observeImageLink: function observeImageLink(obj) {
      return this.opts.image.link ? obj : false;
    },
    observeImageCaption: function observeImageCaption(obj) {
      var instance = this.app.block.get();

      if (instance && instance.getTag() === 'figure') {
        return obj;
      } else {
        return false;
      }
    },
    paste: function paste(blob, e) {
      var params = {
        url: this.opts.image.upload,
        name: this.opts.image.name,
        data: this.opts.image.data,
        multiple: false,
        success: 'image.insertFromBlob',
        error: 'image.error'
      }; // upload

      var upload = this.app.create('upload');
      upload.send(e, [blob], params);
    },
    drop: function drop(e, dt) {
      var files = [];

      for (var i = 0; i < dt.files.length; i++) {
        var file = dt.files[i] || dt.items[i].getAsFile();

        if (file) {
          files.push(file);
        }
      }

      var params = {
        url: this.opts.image.upload,
        name: this.opts.image.name,
        data: this.opts.image.data,
        multiple: this.opts.image.multiple,
        success: 'image.insertByDrop',
        error: 'image.error'
      };

      if (files.length > 0) {
        var $block = this.dom(e.target).closest('[data-' + this.prefix + '-type]');

        if ($block.length !== 0) {
          this.app.block.set($block);
        } // upload


        var upload = this.app.create('upload');
        upload.send(e, files, params);
      }
    },
    insertFromClipboard: function insertFromClipboard(clipboard) {
      var text = clipboard.getData("text/plain") || clipboard.getData("text/html");
      text = text.trim();

      if (text !== '') {
        return;
      }

      var items = clipboard.items;
      var blob = null;

      for (var i = 0; i < items.length; i++) {
        if (items[i].type.indexOf("image") === 0) {
          blob = items[i].getAsFile();
        }
      }

      if (blob !== null) {
        this.paste(blob);
        return true;
      }
    },
    insertFromBlob: function insertFromBlob(response) {
      this.insert(response);
    },
    insertByDrop: function insertByDrop(response, e) {
      if (this.app.block.is()) {
        var instance = this.app.block.get();
        var target = e.target;
        var type = instance.getType();
        var isChange = type === 'card' && target && target.tagName === 'IMG' && instance.hasImage() || type === 'image';

        if (isChange) {
          this.change(response);
          return;
        } else if (e && type !== 'card' && instance.isEditable()) {
          this.app.insertion.insertPoint(e);
        }
      }

      this.insert(response);
    },
    insertByUpload: function insertByUpload(response) {
      this.insert(response);
    },
    insertByUrl: function insertByUrl(e) {
      e.preventDefault();
      var str = this.$urlinput.val();

      if (str.trim() === '') {
        return;
      }

      var response = {
        file: {
          url: str,
          id: this.app.utils.getRandomId()
        }
      }; // insert

      this.insert(response);
    },
    insertFromSelect: function insertFromSelect(e) {
      e.preventDefault();
      var $target = this.dom(e.target);
      var obj = {
        url: $target.attr('data-url')
      };
      var id = $target.attr('data-id');

      if (id !== null) {
        obj.id = id;
      } // insert


      this.insert({
        file: obj
      });
    },
    changeClone: function changeClone(response) {
      for (var key in response) {
        this.$imageclone.attr('src', response[key].url);
        break;
      }

      this.change(response, false);
    },
    change: function change(response, closepopup) {
      if (closepopup !== false) {
        this.app.popup.close();
      }

      var instance = this.app.block.get();

      for (var key in response) {
        instance.setImage(response[key]); // broadcast

        this.app.broadcast('image.change', response[key]);
        this.app.broadcast('image.upload', {
          instance: instance,
          data: response[key]
        });
        return;
      }
    },
    save: function save(stack) {
      this.app.popup.close();
      this.app.block.setData(stack);
    },
    insert: function insert(response) {
      // popup close
      this.app.popup.close(); // insert

      this.imageslen = 0;
      this.imagescount = 0; // tag

      var tag = this.opts.image.tag; // loop

      for (var key in response) {
        var $source = this.dom('<' + tag + '>');

        var $image = this._createImageFromResponseItem(response[key]);

        $source.append($image);
        var instance = this.app.create('block.image', $source);
        this.app.block.add({
          instance: instance
        }); // broadcast

        this.app.broadcast('image.upload', {
          instance: instance,
          data: response[key]
        });
        this.$last = instance.getBlock();
        this.imageslen++;
      }
    },
    error: function error(response) {
      this.app.broadcast('image.upload.error', {
        response: response
      });
    },
    getStates: function getStates() {
      var $images = this._findImages(); // check status


      for (var key in this.dataStates) {
        var data = this.dataStates[key];
        var status = $images.is('[data-image="' + data.id + '"]');

        this._setImageState(data.id, status);
      }

      return this.dataStates;
    },
    createUploadBox: function createUploadBox(upload, $body) {
      if (!upload) return;
      var $upload = this.dom('<div>');
      $body.append($upload);
      return $upload;
    },
    createSelectBox: function createSelectBox(select, $body, callback) {
      if (!select) return; // images box

      this.$selectbox = this._createImagesBox($body);

      if (_typeof(select) === 'object') {
        this._parseList(select, callback);
      } else {
        this.ajax.get({
          url: select,
          data: {
            d: new Date().getTime()
          },
          success: function (data) {
            this._parseList(data, callback);
          }.bind(this)
        });
      }
    },
    // private
    _findImages: function _findImages() {
      return this.app.editor.getLayout().find('[data-image]');
    },
    _addImageState: function _addImageState($node) {
      var id = $node.attr('data-image');
      this.dataStates[id] = {
        type: 'image',
        status: true,
        url: $node.attr('src'),
        $img: $node,
        id: id
      };
    },
    _setImageState: function _setImageState(url, status) {
      this.dataStates[url].status = status;
    },
    _checkImageLoad: function _checkImageLoad() {
      this.imagescount++;

      if (this.imagescount === this.imageslen) {
        this.app.block.unset();
        this.app.block.set(this.$last);
        this.app.editor.adjustHeight();
      }
    },
    _buildEditUpload: function _buildEditUpload() {
      if (!this.opts.image.upload) return;
      var instance = this.app.block.get(); // stack

      var stack = this.app.popup.getStack();
      var $body = stack.getBody(); // form item

      var $item = this._createFormItem();

      $item.addClass(this.prefix + '-form-item-edit-image-box'); // image

      this.$imageclone = instance.getImage().clone();
      var $imageitem = this.dom('<div>').addClass(this.prefix + '-form-item-image');
      $imageitem.append(this.$imageclone);
      $item.append($imageitem); // upload item

      this.$upload = this.dom('<div>');
      $item.append(this.$upload); // append to popup

      $body.prepend($item); // build upload

      this._buildUpload(this.$upload, 'image.changeClone');
    },
    _buildUpload: function _buildUpload($item, callback) {
      if (!this.opts.image.upload) return;
      var params = {
        box: true,
        placeholder: this.lang.get('image.upload-new-placeholder'),
        url: this.opts.image.upload,
        name: this.opts.image.name,
        data: this.opts.image.data,
        multiple: this.opts.image.multiple,
        success: callback,
        error: 'image.error'
      };
      this.app.create('upload', $item, params);
    },
    _createImageFromResponseItem: function _createImageFromResponseItem(item) {
      var $image = this.dom('<img>').attr('src', item.url).one('load', this._checkImageLoad.bind(this));
      if (item.hasOwnProperty('id')) $image.attr('data-image', item.id);
      if (item.hasOwnProperty('2x')) $image.attr('srcset', item['2x'] + ' 2x');
      return $image;
    },
    _createImagesBox: function _createImagesBox($body) {
      var $box = this.dom('<div>').addClass(this.prefix + '-popup-images-box');
      $body.append($box);
      return $box;
    },
    _createOrSection: function _createOrSection($body) {
      var $section = this.dom('<div>').addClass(this.prefix + '-popup-image-section-or');
      $section.html(this.lang.get('image.or'));
      $body.append($section);
    },
    _createImageByUrl: function _createImageByUrl($body) {
      var $item = this._createFormItem();

      this.$urlinput = this._createUrlInput();
      this.$urlbutton = this._createUrlButton();
      $item.append(this.$urlinput);
      $item.append(this.$urlbutton);
      $body.append($item); // focus

      this.$urlinput.focus();
    },
    _createFormItem: function _createFormItem() {
      return this.dom('<div>').addClass(this.prefix + '-form-container-flex');
    },
    _createUrlInput: function _createUrlInput() {
      var $input = this.dom('<input>').addClass(this.prefix + '-form-input');
      $input.attr('placeholder', this.lang.get('image.url-placeholder'));
      return $input;
    },
    _createUrlButton: function _createUrlButton() {
      var $button = this.dom('<button>').addClass(this.prefix + '-form-button ' + this.prefix + '-form-button-primary');
      $button.html(this.lang.get('image.insert'));
      $button.one('click', this.insertByUrl.bind(this));
      return $button;
    },
    _parseList: function _parseList(data, callback) {
      for (var key in data) {
        var obj = data[key];
        if (_typeof(obj) !== 'object') continue;
        var $img = this.dom('<img>');
        var url = obj.thumb ? obj.thumb : obj.url;
        $img.addClass(this.prefix + '-popup-event');
        $img.attr('src', url);
        $img.attr('data-url', obj.url);
        $img.attr('data-callback', callback);

        if (obj.hasOwnProperty('id')) {
          $img.attr('data-id', obj.id);
        }

        $img.on('click.' + this.prefix + '-popup-event-' + this.uuid, function (e) {
          var $target = this.dom(e.target);
          var callback = $target.attr('data-callback');
          this.app.api(callback, e);
        }.bind(this));
        this.$selectbox.append($img);
      }
    }
  });
  ArticleEditor.add('module', 'table', {
    add: function add() {
      // add
      var instance = this.app.block.add({
        name: 'table',
        source: this.opts.table.template,
        caret: false
      }); // focus

      var cell = instance.getFirstCell();

      if (cell) {
        this.app.block.set(cell, 'start');
      }
    },
    observe: function observe() {
      if (!this.opts.table) return false;
    },
    popup: function popup(params, button) {
      var instance = this.app.block.get();
      var type = instance.getType();
      var items = {};

      if (type === 'table') {
        items = {
          addhead: {
            title: '## table.add-head ##',
            command: 'table.addHead'
          },
          removehead: {
            title: '## table.remove-head ##',
            command: 'table.removeHead'
          }
        };
      } else if (type === 'row') {
        items = {
          addrowbelow: {
            title: '## table.add-row-below ##',
            command: 'table.addRowBelow'
          },
          addrowabove: {
            title: '## table.add-row-above ##',
            command: 'table.addRowAbove'
          },
          removerow: {
            title: '## table.remove-row ##',
            command: 'table.removeRow'
          }
        };
      } else if (type === 'cell') {
        items = {
          addcolumnafter: {
            title: '## table.add-column-after ##',
            command: 'table.addColumnAfter'
          },
          addcolumnbefore: {
            title: '## table.add-column-before ##',
            command: 'table.addColumnBefore'
          },
          addrowbelow: {
            title: '## table.add-row-below ##',
            command: 'table.addRowBelow'
          },
          addrowabove: {
            title: '## table.add-row-above ##',
            command: 'table.addRowAbove'
          },
          removecolumn: {
            title: '## table.remove-column ##',
            command: 'table.removeColumn'
          },
          removerow: {
            title: '## table.remove-row ##',
            command: 'table.removeRow'
          }
        };
      }

      this.app.popup.create('table', {
        items: items
      }); // open

      this.app.popup.open({
        button: button
      });
    },
    addHead: function addHead() {
      this.removeHead();
      var instance = this.app.block.get();
      var $block = instance.getBlock();
      var columns = $block.find('tr').first().children('td, th').length;
      var $head = this.dom('<thead>');

      var $row = this._buildRow(columns, '<th>');

      $head.append($row);
      $block.prepend($head); // set

      this.app.block.set($row.children('td, th').first(), 'start');
    },
    addRowBelow: function addRowBelow() {
      this._addRow('below');
    },
    addRowAbove: function addRowAbove() {
      this._addRow('above');
    },
    addColumnBefore: function addColumnBefore() {
      this._addColumn('before');
    },
    addColumnAfter: function addColumnAfter() {
      this._addColumn('after');
    },
    removeHead: function removeHead() {
      this.app.popup.close();
      var instance = this.app.block.get();
      var $block = instance.getBlock();
      var $head = $block.find('thead');

      if ($head.length !== 0) {
        $head.remove();
      }
    },
    removeRow: function removeRow() {
      this.app.popup.close();
      this.app.control.close();
      var instance = this.app.block.get();

      if (instance.getType() === 'cell') {
        instance = instance.getParent(['row']);
      }

      instance.remove();
    },
    removeColumn: function removeColumn() {
      this.app.popup.close();
      this.app.control.close();
      var instance = this.app.block.get();
      var $block = instance.getBlock();
      var $table = $block.closest('table');
      var $row = $block.closest('tr');
      var index = 0;
      $row.find('td, th').each(function ($node, i) {
        if ($node.get() === $block.get()) index = i;
      });
      $table.find('tr').each(function ($node) {
        var cell = $node.find('td, th').get(index);
        var $cell = this.dom(cell);
        $cell.remove();
      }.bind(this));
    },
    cellSetting: function cellSetting(params, button) {
      var instance = this.app.block.get();
      var stack = this.app.popup.create('cell', {
        title: '## table.table-cell ##',
        width: '300px',
        form: {
          width: {
            type: 'input',
            label: '## table.width ##'
          },
          nowrap: {
            type: 'checkbox',
            text: '## table.nowrap ##'
          }
        },
        footer: {
          insert: {
            title: '## table.save ##',
            command: 'table.save',
            type: 'primary'
          },
          cancel: {
            title: '## table.cancel ##',
            command: 'popup.close'
          }
        }
      }); // data

      stack.setData({
        width: instance.getWidth(),
        nowrap: instance.getNowrap()
      }); // open

      this.app.popup.open({
        button: button,
        focus: 'width'
      });
    },
    save: function save(stack) {
      // popup close
      this.app.popup.close(); // data

      var data = stack.getData();
      var instance = this.app.block.get();

      if (data.width !== '') {
        instance.setWidth(data.width);
      }

      instance.setNowrap(data.nowrap);
    },
    // private
    _addColumn: function _addColumn(name) {
      this.app.popup.close();
      var instance = this.app.block.get();
      var $block = instance.getBlock();
      var $table = $block.closest('table');
      var $row = $block.closest('tr');
      var index = 0;
      $row.find('td, th').each(function ($node, i) {
        if ($node.get() === $block.get()) index = i;
      });
      var rowIndex = 0;
      $table.find('tr').each(function ($node, i) {
        if ($node.get() === $row.get()) rowIndex = i;
      });
      var $newCell;
      $table.find('tr').each(function ($node, i) {
        var cell = $node.find('td, th').get(index);
        var $cell = this.dom(cell);
        var $td = $cell.clone();
        $td.html(''); // create instance

        this.app.create('block.cell', $td);

        if (rowIndex === i) {
          $newCell = $td;
        } // after / before


        $cell[name]($td);
      }.bind(this)); // set focus

      if ($newCell) {
        this.app.block.set($newCell, 'start');
      }
    },
    _addRow: function _addRow(name) {
      this.app.popup.close();
      var position = name === 'below' ? 'after' : 'before';
      var instance = this.app.block.get();
      var $block = instance.getBlock();
      var $row = $block.closest('tr');
      var $head = $block.closest('thead');
      var columns = $row.children('td, th').length;

      var $newRow = this._buildRow(columns, '<td>');

      if ($head.length !== 0) {
        $head.after($newRow);
      } else {
        $row[position]($newRow);
      } // set focus


      this.app.block.set($newRow.find('td, th').first(), 'start');
    },
    _buildRow: function _buildRow(columns, tag) {
      var $row = this.dom('<tr>'); // create instance

      this.app.create('block.row', $row);

      for (var i = 0; i < columns; i++) {
        var $cell = this.dom(tag); // create instance

        this.app.create('block.cell', $cell); // append

        $row.append($cell);
      }

      return $row;
    }
  });
  ArticleEditor.add('module', 'snippet', {
    init: function init() {
      this.json = {};
    },
    observe: function observe() {
      if (!this.opts.snippets) return false;
    },
    popup: function popup() {
      var stack = this.app.popup.add('snippets', {
        title: '## popup.snippets ##',
        width: '100%'
      }); // data

      var $body = stack.getBody(); // json url

      if (typeof this.opts.snippets === 'string') {
        this.ajax.get({
          url: this.opts.snippets,
          data: {
            d: new Date().getTime()
          },
          success: function (data) {
            this._buildPopup(data, $body);
          }.bind(this)
        });
      } // json object
      else {
          this._buildPopup(this.opts.snippets, $body);
        } // open


      stack.open();
    },
    insert: function insert(e) {
      var $trigger = this.dom(e.target).closest('.' + this.prefix + '-snippet-container');
      var key = $trigger.attr('data-snippet-key');

      if (this.json.hasOwnProperty(key)) {
        this.app.popup.close();
        var html = this.json[key].html;
        this.app.editor.insertContent({
          html: html,
          caret: 'start'
        });
      }
    },
    // private
    _buildPopup: function _buildPopup(data, $body) {
      this.json = data;

      if (typeof data === 'string') {
        this.json = JSON.parse(data);
      }

      for (var key in this.json) {
        var $container = this._buildPreviewContainer($body, key); // preview


        this._buildPreview($container, key);

        this._buildPreviewName($container, key);
      }
    },
    _buildPreviewContainer: function _buildPreviewContainer($body, key) {
      var $div = this.dom('<div>').addClass(this.prefix + '-snippet-container');
      $div.attr('data-snippet-key', key);
      $div.one('click', this.insert.bind(this)); // append

      $body.append($div);
      return $div;
    },
    _buildPreview: function _buildPreview($container, key) {
      var $div = this.dom('<div>');

      if (this.json[key].hasOwnProperty('image')) {
        $div.addClass(this.prefix + '-snippet-image');
        var $img = this.dom('<img>').attr('src', this.json[key].image);
        $div.html($img);
      } else {
        $div.addClass(this.prefix + '-snippet-preview');
        $div.html(this.json[key].html);
      }

      $container.append($div);
    },
    _buildPreviewName: function _buildPreviewName($container, key) {
      if (!this.json[key].hasOwnProperty('name')) return;
      var $span = this.dom('<div>').addClass(this.prefix + '-snippet-name');
      $span.text(this.json[key].name);
      $container.append($span);
    }
  });
  ArticleEditor.add('module', 'template', {
    init: function init() {
      this.json = {};
    },
    observe: function observe() {
      if (!this.opts.templates) return false;
    },
    popup: function popup(params, button) {
      // json url
      if (typeof this.opts.templates === 'string') {
        this.ajax.get({
          url: this.opts.templates,
          data: {
            d: new Date().getTime()
          },
          success: function (data) {
            this._buildPopup(button, data);
          }.bind(this)
        });
      } // json object
      else {
          this._buildPopup(button, this.opts.templates);
        }
    },
    insert: function insert(e) {
      var $trigger = this.dom(e.target).closest('.' + this.prefix + '-template-container');
      var key = $trigger.attr('data-template-key');

      if (this.json.hasOwnProperty(key)) {
        this.app.popup.close();
        var html = this.json[key].html;
        this.app.editor.setContent({
          html: html,
          caret: false
        });
      }
    },
    // private
    _buildPopup: function _buildPopup(button, data) {
      // popup
      this.app.popup.create('templates', {
        title: '## templates.templates ##',
        width: '100%'
      }); // stack

      var stack = this.app.popup.getStack();
      var $body = stack.getBody(); // json

      this.json = typeof data === 'string' ? JSON.parse(data) : data; // items

      for (var key in this.json) {
        // container
        var $container = this._buildPreviewContainer($body, key); // preview


        this._buildPreview($container, key);

        this._buildPreviewName($container, key);
      } // open


      this.app.popup.open({
        button: button
      });
    },
    _buildPreviewContainer: function _buildPreviewContainer($body, key) {
      var $div = this.dom('<div>').addClass(this.prefix + '-template-container');
      $div.attr('data-template-key', key);
      $div.one('click', this.insert.bind(this)); // append

      $body.append($div);
      return $div;
    },
    _buildPreview: function _buildPreview($container, key) {
      var $div = this.dom('<div>');

      if (this.json[key].hasOwnProperty('image')) {
        $div.addClass(this.prefix + '-template-image');
        var $img = this.dom('<img>').attr('src', this.json[key].image);
        $div.html($img);
      } else {
        $div.addClass(this.prefix + '-template-preview');
        $div.html(this.json[key].html);
      }

      $container.append($div);
    },
    _buildPreviewName: function _buildPreviewName($container, key) {
      if (!this.json[key].hasOwnProperty('name')) return;
      var $span = this.dom('<div>').addClass(this.prefix + '-template-name');
      $span.text(this.json[key].name);
      $container.append($span);
    }
  });
  ArticleEditor.add('class', 'tool.checkbox', {
    mixins: ['tool'],
    type: 'checkbox',
    input: {
      tag: 'input',
      type: 'checkbox',
      classname: '-form-checkbox'
    },
    getValue: function getValue() {
      return this.$input.val();
    },
    // private
    _buildInput: function _buildInput() {
      this.$box = this.dom('<label>').addClass(this.prefix + '-form-checkbox-item');
      this.$box.append(this.$input); // checkbox text

      if (this._has('text')) {
        var $span = this.dom('<span>').html(this.lang.parse(this.obj.text));
        this.$box.append($span);
      }

      this.$tool.append(this.$box);
    }
  });
  ArticleEditor.add('class', 'tool.color', {
    mixins: ['tool'],
    type: 'color',
    input: {
      tag: 'input',
      type: 'text',
      classname: '-form-input'
    },
    setValue: function setValue(value) {
      this.$input.val(value);
      this.$select.css('background-color', value);

      if (this.$picker) {
        this.setColor(value);
      }

      if (value && this.$checkbox) {
        this.$checkbox.attr('checked', true);
      }
    },
    setColor: function setColor(color) {
      this.$picker.attr('data-current-color', color);
      this.$picker.find('.' + this.prefix + '-color').removeClass('active');
      this.$picker.find('.' + this.prefix + '-color').each(function ($node) {
        var value = $node.attr('data-value'); // active

        if (value === color) {
          $node.addClass('active');
          $node.css('color', this.app.color.invert(color));
        }
      }.bind(this));
    },
    // private
    _buildInput: function _buildInput() {
      this.$box = this.dom('<div>').addClass(this.prefix + '-form-container-flex ' + this.prefix + '-form-container-color');
      this.$select = this.dom('<span>').addClass(this.prefix + '-form-color-select');
      this.$checkbox = this.dom('<input>').addClass(this.prefix + '-form-checkbox').attr('type', 'checkbox');
      this.$input.css('max-width', '90px');
      this.$input.on('keydown blur', this._changeColorSelect.bind(this));

      if (this._has('picker')) {
        this.$picker = this._createPicker();
        this.$tool.append(this.$picker);
      } else {
        this.$select.addClass(this.prefix + '-form-color-select-pointer');
        this.$select.on('click', this._buildColorpicker.bind(this));
      }

      if (this.name === 'background-color') {
        this.$box.append(this.$checkbox);
        this.$checkbox.on('change', this._changeColorState.bind(this));
      }

      this.$box.append(this.$select);
      this.$box.append(this.$input);
      this.$tool.append(this.$box);

      if (this._has('picker')) {
        this._buildColors();
      }
    },
    _buildColors: function _buildColors() {
      this.$picker.html('');

      for (var key in this.opts.colors) {
        var $div = this.dom('<div class="' + this.prefix + '-form-colors">');

        for (var i = 0; i < this.opts.colors[key].length; i++) {
          var color = this.opts.colors[key][i];

          var $span = this._createColor(color, key, i);

          if (color === '#fff' || color === '#ffffff') {
            $span.addClass(this.prefix + '-form-color-contrast');
          }

          $div.append($span);
        }

        this.$picker.append($div);
      }
    },
    _buildColorpicker: function _buildColorpicker(e) {
      e.preventDefault();
      e.stopPropagation();
      this.$picker = this._createPicker();
      var stack = this.app.popup.add('colorpicker', {
        title: '## popup.pick-color ##',
        collapse: true
      });
      stack.getBody().append(this.$picker);

      this._buildColors();

      this.setColor(this.$input.val());
      stack.open();
    },
    _createPicker: function _createPicker() {
      return this.dom('<div>').addClass(this.prefix + '-form-colorpicker');
    },
    _createColor: function _createColor(color, key, i) {
      var $span = this.dom('<span>').addClass(this.prefix + '-color').css('background-color', color);
      $span.attr({
        'title': key + '-' + i,
        'data-value': color
      });
      $span.on('mouseover', this._inColor.bind(this));
      $span.on('mouseout', this._outColor.bind(this));
      $span.on('click', this._setColor.bind(this));
      return $span;
    },
    _inColor: function _inColor(e) {
      var $color = this.dom(e.target);
      var value = $color.attr('data-value');

      this._setColorToInput(value);
    },
    _outColor: function _outColor() {
      this._setColorToInput(this.$picker.attr('data-current-color'));
    },
    _setColorToInput: function _setColorToInput(value) {
      this.$input.val(value);
      this.$select.css('background-color', value);
    },
    _setColor: function _setColor(e) {
      e.preventDefault();
      e.stopPropagation();
      var $color = this.dom(e.target);
      var value = $color.attr('data-value');
      this.$picker.attr('data-current-color', value);
      this.$picker.find('.' + this.prefix + '-color').removeClass('active');
      $color.addClass('active');
      $color.css('color', this.app.color.invert(value));

      this._setColorToInput(value);

      if (this.setter) {
        this.app.api(this.setter, this.stack);
      }

      if (this._has('picker')) {
        this.app.popup.close();
      } else {
        var stack = this.app.popup.getStack();
        stack.collapse();
      }
    },
    _changeColorSelect: function _changeColorSelect(e) {
      if (e.type === 'keydown' && e.which !== 13) return;
      if (e.type === 'keydown') e.preventDefault();
      var value = this.$input.val();
      value = this.app.color.normalize(value);
      this.$input.val(value);
      this.$select.css('background-color', value);

      if (this.picker) {
        this.picker.setColor(value);
      }

      this.$checkbox.attr('checked', value !== '');
    },
    _changeColorState: function _changeColorState(e) {
      e.preventDefault();
      e.stopPropagation();
      var state = this.$checkbox.attr('checked');
      var value = state ? '#ffffff' : '';
      this.setValue(value);
      this.app.api(this.setter, this.stack);
    }
  });
  ArticleEditor.add('class', 'tool.input', {
    mixins: ['tool'],
    type: 'input',
    input: {
      tag: 'input',
      type: 'text',
      classname: '-form-input'
    },
    // private
    _buildInput: function _buildInput() {
      this.$tool.append(this.$input);
    }
  });
  ArticleEditor.add('class', 'tool.number', {
    mixins: ['tool'],
    type: 'number',
    input: {
      tag: 'input',
      type: 'number',
      classname: '-form-input'
    },
    // private
    _buildInput: function _buildInput() {
      this.$input.attr('min', 0).css('max-width', '65px');
      this.$tool.append(this.$input);
    }
  });
  ArticleEditor.add('class', 'tool.segment', {
    mixins: ['tool'],
    type: 'segment',
    input: {
      tag: 'input',
      type: 'hidden',
      classname: '-form-input'
    },
    setValue: function setValue(value) {
      this.$segment.find('.' + this.prefix + '-form-segment-item').removeClass('active');
      this.$segment.find('[data-segment=' + value + ']').addClass('active');
      this.$input.val(value);
    },
    // private
    _buildInput: function _buildInput() {
      this.$segment = this.dom('<div>').addClass(this.prefix + '-form-segment').css('max-width', '200px');
      var segments = this.obj.segments;

      for (var name in segments) {
        var $segment = this.dom('<span>').addClass(this.prefix + '-form-segment-item');
        $segment.attr('data-segment', name).on('click', this._catchSegment.bind(this));

        if (segments[name].hasOwnProperty('icon')) {
          $segment.html(segments[name].icon);
        } else {
          $segment.addClass(this.prefix + '-icon-' + segments[name].prefix + '-' + name);
        }

        this.$segment.append($segment);
      }

      this.$segment.append(this.$input);
      this.$tool.append(this.$segment);
    },
    _catchSegment: function _catchSegment(e) {
      e.preventDefault();
      e.stopPropagation();
      var $item = this.dom(e.target).closest('.' + this.prefix + '-form-segment-item');
      var value = $item.attr('data-segment');
      this.$segment.find('.' + this.prefix + '-form-segment-item').removeClass('active');
      $item.addClass('active');
      this.$input.val(value); // call setter

      this.app.api(this.setter, this.stack);
    }
  });
  ArticleEditor.add('class', 'tool.select', {
    mixins: ['tool'],
    type: 'select',
    input: {
      tag: 'select',
      classname: '-form-select'
    },
    // private
    _buildInput: function _buildInput() {
      for (var value in this.obj.options) {
        var $option = this.dom('<option>');
        $option.val(value);
        $option.html(this.lang.parse(this.obj.options[value]));
        this.$input.append($option);
      }

      this.$tool.append(this.$input);
    }
  });
  ArticleEditor.add('class', 'tool.textarea', {
    mixins: ['tool'],
    type: 'textarea',
    input: {
      tag: 'textarea',
      classname: '-form-textarea'
    },
    setFocus: function setFocus() {
      this.$input.focus();
      this.$input.get().setSelectionRange(0, 0);
      this.$input.scrollTop(0);
    },
    // private
    _buildInput: function _buildInput() {
      if (this._has('rows')) {
        this.$input.attr('rows', this._get('rows'));
      }

      this.$input.attr('data-gramm_editor', false);
      this.$tool.append(this.$input);
    }
  });
  ArticleEditor.add('block', 'block.paragraph', {
    mixins: ['block'],
    type: 'paragraph',
    editable: true,
    toolbar: {
      add: {
        command: 'addbar.popup',
        title: '## buttons.add ##'
      },
      format: {
        command: 'format.popup',
        title: '## buttons.format ##'
      },
      alignment: {
        command: 'block.popup',
        observer: 'block.observe',
        title: '## buttons.align ##'
      },
      bold: {
        command: 'inline.set',
        title: '## buttons.bold ##',
        params: {
          tag: 'b'
        }
      },
      italic: {
        command: 'inline.set',
        title: '## buttons.italic ##',
        params: {
          tag: 'i'
        }
      },
      deleted: {
        command: 'inline.set',
        title: '## buttons.deleted ##',
        params: {
          tag: 'del'
        }
      },
      link: {
        command: 'link.popup',
        title: '## buttons.link ##'
      }
    },
    control: {
      trash: {
        command: 'block.remove',
        title: '## buttons.delete ##'
      },
      duplicate: {
        command: 'block.duplicate',
        title: '## buttons.duplicate ##'
      }
    },
    create: function create() {
      return this.dom('<p>');
    },
    // handle
    handleEnter: function handleEnter(e, key, event) {
      e.preventDefault(); // empty or end

      if (this.isEmpty() || this.isCaretEnd()) {
        var clone = this.app.block.create(); // clone paragraph styles

        if (!this.opts.clean.enter) {
          clone = this.duplicateEmpty();
        }

        if (!this.opts.clean.enterinline) {
          // clone inline
          var inline = this.app.selection.getInline();

          if (inline) {
            var cloned;
            var inlines = this.app.element.getAllInlines(inline);

            for (var i = 0; i < inlines.length; i++) {
              if (i === 0) {
                cloned = inlines[i].cloneNode();
                cloned.innerHTML = '';
              } else {
                var clonedInline = inlines[i].cloneNode();
                clonedInline.innerHTML = '';
                cloned.appendChild(clonedInline);
              }
            }

            clone = this.app.block.create(cloned.outerHTML);
          }
        }

        this.insert({
          instance: clone,
          position: 'after',
          caret: 'start'
        });
      } // start
      else if (this.isCaretStart()) {
          this.insert({
            instance: this.duplicateEmpty(),
            position: 'before'
          });
        } // middle
        else {
            var $block = this.getBlock();
            var $part = this.app.element.split($block);
            this.app.block.set($part, 'start');
          }

      return true;
    }
  });
  ArticleEditor.add('block', 'block.text', {
    mixins: ['block'],
    type: 'text',
    editable: true,
    toolbar: {
      add: {
        command: 'addbar.popup',
        title: '## buttons.add ##'
      },
      format: {
        command: 'format.popup',
        title: '## buttons.format ##'
      },
      alignment: {
        command: 'block.popup',
        observer: 'block.observe',
        title: '## buttons.align ##'
      },
      bold: {
        command: 'inline.set',
        title: '## buttons.bold ##',
        params: {
          tag: 'b'
        }
      },
      italic: {
        command: 'inline.set',
        title: '## buttons.italic ##',
        params: {
          tag: 'i'
        }
      },
      deleted: {
        command: 'inline.set',
        title: '## buttons.deleted ##',
        params: {
          tag: 'del'
        }
      },
      link: {
        command: 'link.popup',
        title: '## buttons.link ##'
      }
    },
    control: {
      trash: {
        command: 'block.remove',
        title: '## buttons.delete ##'
      },
      duplicate: {
        command: 'block.duplicate',
        title: '## buttons.duplicate ##'
      }
    },
    create: function create() {
      return this.dom('<div>').addClass(this.opts.text.classname);
    },
    // handle
    handleEnter: function handleEnter(e, key, event) {
      e.preventDefault();
      this.app.insertion.insertBreakline();
      return true;
    }
  });
  ArticleEditor.add('block', 'block.address', {
    mixins: ['block'],
    type: 'address',
    editable: true,
    toolbar: {
      add: {
        command: 'addbar.popup',
        title: '## buttons.add ##'
      },
      format: {
        command: 'format.popup',
        title: '## buttons.format ##'
      },
      alignment: {
        command: 'block.popup',
        observer: 'block.observe',
        title: '## buttons.align ##'
      },
      bold: {
        command: 'inline.set',
        title: '## buttons.bold ##',
        params: {
          tag: 'b'
        }
      },
      italic: {
        command: 'inline.set',
        title: '## buttons.italic ##',
        params: {
          tag: 'i'
        }
      },
      deleted: {
        command: 'inline.set',
        title: '## buttons.deleted ##',
        params: {
          tag: 'del'
        }
      },
      link: {
        command: 'link.popup',
        title: '## buttons.link ##'
      }
    },
    control: {
      trash: {
        command: 'block.remove',
        title: '## buttons.delete ##'
      },
      duplicate: {
        command: 'block.duplicate',
        title: '## buttons.duplicate ##'
      }
    },
    create: function create() {
      return this.dom('<address>');
    },
    // handle
    handleEnter: function handleEnter(e, key, event) {
      e.preventDefault(); // empty or end  check address exit

      if (this.isEmpty() || this.isCaretEnd()) {
        var $block = this.getBlock();
        var $nodes = $block.children();
        var len = $nodes.length;
        var $last = $nodes.eq(len - 1);
        var $lastPrev = $nodes.eq(len - 2);
        var html = $block.html().trim();
        html = this.app.utils.removeInvisibleChars(html);

        if (html.search(/<br\s?\/?><br\s?\/?>$/) !== -1) {
          // remove empty
          $lastPrev.remove();
          $last.remove(); // insert

          this.insertEmpty({
            position: 'after',
            caret: 'start'
          });
          return;
        }
      } // insert br


      this.app.insertion.insertBreakline();
      return true;
    }
  });
  ArticleEditor.add('block', 'block.cell', {
    mixins: ['block'],
    type: 'cell',
    editable: true,
    toolbar: {
      table: {
        command: 'table.popup',
        title: '## buttons.table ##'
      },
      alignment: {
        command: 'block.popup',
        observer: 'block.observe',
        title: '## buttons.align ##'
      },
      bold: {
        command: 'inline.set',
        title: '## buttons.bold ##',
        params: {
          tag: 'b'
        }
      },
      italic: {
        command: 'inline.set',
        title: '## buttons.italic ##',
        params: {
          tag: 'i'
        }
      },
      deleted: {
        command: 'inline.set',
        title: '## buttons.deleted ##',
        params: {
          tag: 'del'
        }
      },
      link: {
        command: 'link.popup',
        title: '## buttons.link ##'
      },
      tune: {
        command: 'table.cellSetting',
        title: '## buttons.settings ##'
      }
    },
    create: function create() {
      return this.dom('<td>');
    },
    getNextCell: function getNextCell() {
      var cell = this.getNext();

      if (!cell) {
        var row = this.getParent('row');

        if (row) {
          var nextRow = row.getNextRow();

          if (nextRow) {
            cell = nextRow.getChildFirst('cell');
          }
        }
      }

      return cell;
    },
    getPrevCell: function getPrevCell() {
      var cell = this.getPrev();

      if (!cell) {
        var row = this.getParent('row');

        if (row) {
          var prevRow = row.getPrevRow();

          if (prevRow) {
            cell = prevRow.getChildLast('cell');
          }
        }
      }

      return cell;
    },
    getWidth: function getWidth() {
      var value = this.$block.attr('width');
      return value ? value : '';
    },
    getNowrap: function getNowrap() {
      var value = this.$block.css('white-space');
      return value === 'nowrap';
    },
    setWidth: function setWidth(value) {
      this._eachCell(function ($cell) {
        if (value === '') {
          $cell.removeAttr('width');
        } else {
          $cell.attr('width', value);
        }
      });
    },
    setNowrap: function setNowrap(value) {
      this._eachCell(function ($cell) {
        value = value ? 'nowrap' : '';
        $cell.css('white-space', value);
      });
    },
    // handle
    handleArrow: function handleArrow(e, key, event) {
      var parentInstance;

      if (event.is('up-left') && this.isCaretStart()) {
        e.preventDefault();
        var prev = this.getPrevCell();

        if (prev) {
          this.app.block.set(prev, 'end');
        } else {
          parentInstance = this.getParent('table');
          this.app.block.set(parentInstance);
        }

        return true;
      } else if (event.is('down-right') && this.isCaretEnd()) {
        e.preventDefault();
        var next = this.getNextCell();

        if (next) {
          this.app.block.set(next, 'start');
        } else {
          parentInstance = this.getParent('table');
          this.app.block.set(parentInstance);
        }

        return true;
      }
    },
    handleTab: function handleTab(e, key, event) {
      e.preventDefault();
      var next = this.getNextCell();

      if (next) {
        this.app.block.set(next, 'start');
      } else {
        var parentInstance = this.getParent('table');
        this.app.block.set(parentInstance);
      }

      return true;
    },
    handleEnter: function handleEnter(e, key, event) {
      e.preventDefault();
      this.app.insertion.insertBreakline();
      return true;
    },
    // private
    _eachCell: function _eachCell(func) {
      var index = 0;
      var $table = this.$block.closest('table'); // index

      this.$block.closest('tr').find('td, th').each(function ($node, i) {
        if ($node.get() === this.$block.get()) index = i;
      }.bind(this));
      $table.find('tr').each(function ($node) {
        var cell = $node.find('td, th').get(index);
        var $cell = this.dom(cell);
        func($cell); //content.cacheBlocksStyle($cell);
      }.bind(this));
    }
  });
  ArticleEditor.add('block', 'block.code', {
    mixins: ['block'],
    type: 'code',
    editable: true,
    toolbar: {
      add: {
        command: 'addbar.popup',
        title: '## buttons.add ##'
      }
    },
    control: {
      trash: {
        command: 'block.remove',
        title: '## buttons.delete ##'
      },
      duplicate: {
        command: 'block.duplicate',
        title: '## buttons.duplicate ##'
      }
    },
    create: function create() {
      return this.dom(this.opts.code.template);
    },
    build: function build() {
      this._buildCaption();

      this._buildItems('figcaption', 'figcaption');
    },
    // handle
    handleArrow: function handleArrow(e, key, event) {
      if (event.is('down-right') && this.isCaretEnd()) {
        var next = this.getNext();

        if (next) {
          this.app.block.set(next, 'start');
          return true;
        } else {
          this.app.insertion.insertEmptyBlock({
            position: 'after',
            caret: 'start'
          });
          return true;
        }
      }
    },
    handleTab: function handleTab(e, key, event) {
      e.preventDefault();
      var num = this.opts.code.spaces;
      var node = document.createTextNode(Array(num + 1).join(' '));
      this.app.insertion.insertNode(node, 'end');
      return true;
    },
    handleEnter: function handleEnter(e, key, event) {
      e.preventDefault();
      var last = this.$block.html().search(/\n$/);

      if (this.isCaretEnd() && last === -1) {
        this.app.insertion.insertNewline('after', true);
      } else {
        this.app.insertion.insertNewline();
      }

      return true;
    }
  });
  ArticleEditor.add('block', 'block.column', {
    mixins: ['block'],
    type: 'column',
    nested: true,
    emptiable: true,
    toolbar: {
      alignment: {
        command: 'block.popup',
        observer: 'block.observe',
        title: '## buttons.align ##'
      }
    },
    create: function create() {
      return this.dom('<div>');
    }
  });
  ArticleEditor.add('block', 'block.dlist', {
    mixins: ['block'],
    type: 'dlist',
    editable: true,
    toolbar: {
      add: {
        command: 'addbar.popup',
        title: '## buttons.add ##'
      },
      format: {
        command: 'format.popup',
        title: '## buttons.format ##'
      },
      alignment: {
        command: 'block.popup',
        observer: 'block.observe',
        title: '## buttons.align ##'
      },
      bold: {
        command: 'inline.set',
        title: '## buttons.bold ##',
        params: {
          tag: 'b'
        }
      },
      italic: {
        command: 'inline.set',
        title: '## buttons.italic ##',
        params: {
          tag: 'i'
        }
      },
      deleted: {
        command: 'inline.set',
        title: '## buttons.deleted ##',
        params: {
          tag: 'del'
        }
      },
      link: {
        command: 'link.popup',
        title: '## buttons.link ##'
      }
    },
    control: {
      trash: {
        command: 'block.remove',
        title: '## buttons.delete ##'
      },
      duplicate: {
        command: 'block.duplicate',
        title: '## buttons.duplicate ##'
      }
    },
    create: function create() {
      return this.dom('<dl>');
    },
    getPlainText: function getPlainText(keepbr) {
      var html = '';
      var $items = this.$block.find('dt, dd');
      var len = $items.length;
      $items.each(function ($node, i) {
        var br = keepbr ? '<br>' : '';
        if (i === len) br = '';
        html += $node.html() + br;
      });
      return html;
    },
    setEmpty: function setEmpty() {
      this.$block.html('');
      var $item = this.dom('<dt>');
      this.$block.append($item);
      this.app.caret.set($item, 'start');
    },
    isEmpty: function isEmpty() {
      var html = this.$block.html();
      html = this._cleanEmpty(html);
      var $items = this.$block.find('dt, dd');

      if ($items.length === 0) {
        html = html.trim();
        return html === '';
      } else if ($items.length === 1) {
        html = $items.eq(0).html();
        html = this._cleanEmpty(html);
        return html === '';
      }

      return false;
    },
    // handle
    handleEnter: function handleEnter(e, key, event) {
      e.preventDefault(); // empty or end

      if (this.isEmpty() || this.isCaretEnd()) {
        var currentItem = this.app.selection.getBlock();
        var $currentItem = this.dom(currentItem);
        var tag = currentItem.tagName.toLowerCase();
        var isItemEmpty = this.app.content.isEmptyHtml(currentItem.innerHTML);

        if (tag === 'dt' && isItemEmpty) {
          // remove empty
          $currentItem.remove(); // insert

          this.insertEmpty({
            position: 'after',
            caret: 'start'
          });
          return true;
        } // insert dt or dd


        var $newItem;

        if (tag === 'dt') {
          $newItem = this.dom('<dd>');
        } else {
          $newItem = this.dom('<dt>');
        }

        this.dom(currentItem).after($newItem);
        this.app.caret.set($newItem, 'start');
      } // start
      else if (this.isCaretStart()) {
          return true;
        } // middle
        else {
            this.app.insertion.insertBreakline();
          }

      return true;
    }
  });
  ArticleEditor.add('block', 'block.embed', {
    mixins: ['block'],
    type: 'embed',
    parser: {
      unparse: function unparse($node) {
        var code = decodeURI($node.attr('data-embed-code'));
        var $responsive = $node.find('.' + this.opts.embed.responsive);
        var $el = $node.find('figcaption');
        var $figcaption;

        if ($el.length !== 0) {
          $figcaption = $el.clone();
          $el.remove();
        }

        if ($responsive.length === 0) {
          $node.html(code);
        } else {
          $responsive.html(code);
        }

        if ($figcaption) {
          $node.append($figcaption);
        }

        $node.removeAttr('data-embed-code');
      }
    },
    toolbar: {
      add: {
        command: 'addbar.popup',
        title: '## buttons.add ##'
      },
      outset: {
        command: 'block.popup',
        observer: 'block.observe',
        title: '## buttons.outset ##'
      },
      embed: {
        command: 'embed.edit',
        title: '## buttons.embed ##'
      }
    },
    control: {
      trash: {
        command: 'block.remove',
        title: '## buttons.delete ##'
      },
      duplicate: {
        command: 'block.duplicate',
        title: '## buttons.duplicate ##'
      }
    },
    create: function create() {
      return this.dom('<figure>');
    },
    build: function build() {
      this._buildCaption();

      this._buildItems('figcaption', 'figcaption');

      this._buildEmbedCode();
    },
    addResponsive: function addResponsive() {
      var $responsive = this.dom('<div>').addClass(this.opts.embed.responsive);
      var $figcaption = this.$block.find('figcaption');
      var $cloneFigcaption = $figcaption.clone();
      var html = this.getEmbedCode();
      $figcaption.remove();
      $responsive.html(html);
      this.$block.html('').append($responsive);

      if ($cloneFigcaption.length !== 0) {
        this.app.create('block.figcaption', $cloneFigcaption);
        this.$block.append($cloneFigcaption);
      }
    },
    removeResponsive: function removeResponsive() {
      this.$block.find('.' + this.opts.embed.responsive).unwrap();
    },
    getEmbedCode: function getEmbedCode() {
      return decodeURI(this.$block.attr('data-embed-code'));
    },
    isResponsive: function isResponsive() {
      return this.$block.find('.' + this.opts.embed.responsive).length !== 0;
    },
    // private
    _buildEmbedCode: function _buildEmbedCode() {
      var $clone = this.$block.clone();
      $clone.find('.' + this.opts.embed.responsive).unwrap();
      $clone.find('figcaption').remove();
      var code = $clone.html().trim();
      this.$block.attr('data-embed-code', encodeURI(code));
    }
  });
  ArticleEditor.add('block', 'block.figcaption', {
    mixins: ['block'],
    type: 'figcaption',
    editable: true,
    toolbar: {
      alignment: {
        command: 'block.popup',
        observer: 'block.observe',
        title: '## buttons.align ##'
      },
      bold: {
        command: 'inline.set',
        title: '## buttons.bold ##',
        params: {
          tag: 'b'
        }
      },
      italic: {
        command: 'inline.set',
        title: '## buttons.italic ##',
        params: {
          tag: 'i'
        }
      },
      deleted: {
        command: 'inline.set',
        title: '## buttons.deleted ##',
        params: {
          tag: 'del'
        }
      },
      link: {
        command: 'link.popup',
        title: '## buttons.link ##'
      }
    },
    create: function create() {
      return this.dom('<figcaption>');
    },
    getFigure: function getFigure() {
      return this.$block.closest('figure').dataget('instance');
    },
    // handle
    handleArrow: function handleArrow(e, key, event) {
      if (event.is('up-left') && this.isCaretStart() || event.is('down-right') && this.isCaretEnd()) {
        e.preventDefault();
        var parentInstance = this.getFigure();
        this.app.block.set(parentInstance);
        return true;
      }
    },
    handleTab: function handleTab(e, key, event) {
      e.preventDefault();
      var parentInstance = this.getFigure();
      this.app.block.set(parentInstance);
      return true;
    },
    handleEnter: function handleEnter(e, key, event) {
      e.preventDefault(); // empty or end

      if (this.isEmpty() || this.isCaretEnd() || this.isCaretStart()) {
        return true;
      } // middle
      else {
          this.app.insertion.insertBreakline();
        }

      return true;
    }
  });
  ArticleEditor.add('block', 'block.grid', {
    mixins: ['block'],
    type: 'grid',
    nested: true,
    parser: {
      unparse: function unparse($node) {
        $node.removeClass(this.prefix + '-grid-overlay');
      }
    },
    toolbar: {
      add: {
        command: 'addbar.popup',
        title: '## buttons.add ##'
      },
      valign: {
        command: 'block.popup',
        observer: 'block.observe',
        title: '## buttons.valign ##'
      }
    },
    control: {
      trash: {
        command: 'block.remove',
        title: '## buttons.delete ##'
      },
      duplicate: {
        command: 'block.duplicate',
        title: '## buttons.duplicate ##'
      }
    },
    create: function create() {
      var $block = this.dom('<div>').addClass(this.opts.grid.classname);

      if (this.opts.grid.classes !== '') {
        $block.addClass(this.opts.grid.classes);
      }

      return $block;
    },
    build: function build() {
      this._buildOverlay();
    },
    // privae
    _buildOverlay: function _buildOverlay() {
      if (this.opts.grid && this.opts.grid.overlay) {
        this.$block.addClass(this.prefix + '-grid-overlay');
      }
    }
  });
  ArticleEditor.add('block', 'block.heading', {
    mixins: ['block'],
    type: 'heading',
    editable: true,
    toolbar: {
      add: {
        command: 'addbar.popup',
        title: '## buttons.add ##'
      },
      format: {
        command: 'format.popup',
        title: '## buttons.format ##'
      },
      alignment: {
        command: 'block.popup',
        observer: 'block.observe',
        title: '## buttons.align ##'
      },
      bold: {
        command: 'inline.set',
        title: '## buttons.bold ##',
        params: {
          tag: 'b'
        }
      },
      italic: {
        command: 'inline.set',
        title: '## buttons.italic ##',
        params: {
          tag: 'i'
        }
      },
      deleted: {
        command: 'inline.set',
        title: '## buttons.deleted ##',
        params: {
          tag: 'del'
        }
      },
      link: {
        command: 'link.popup',
        title: '## buttons.link ##'
      }
    },
    control: {
      trash: {
        command: 'block.remove',
        title: '## buttons.delete ##'
      },
      duplicate: {
        command: 'block.duplicate',
        title: '## buttons.duplicate ##'
      }
    },
    create: function create() {
      return this.dom('<h2>');
    },
    getTitle: function getTitle() {
      var titles = this.lang.get('headings');
      var tag = this.getTag();
      var title = this.$block.attr('data-title');
      return typeof titles[tag] !== 'undefined' ? titles[tag] : title;
    },
    // handle
    handleEnter: function handleEnter(e, key, event) {
      e.preventDefault(); // empty or end

      if (this.isEmpty() || this.isCaretEnd()) {
        this.insertEmpty({
          position: 'after',
          caret: 'start'
        });
      } // start
      else if (this.isCaretStart()) {
          this.insert({
            instance: this.duplicateEmpty(),
            position: 'before'
          });
        } // middle
        else {
            var $block = this.getBlock();
            var $part = this.app.element.split($block);
            this.app.block.set($part, 'start');
          }

      return true;
    }
  });
  ArticleEditor.add('block', 'block.image', {
    mixins: ['block'],
    type: 'image',
    toolbar: {
      add: {
        command: 'addbar.popup',
        title: '## buttons.add ##'
      },
      outset: {
        command: 'block.popup',
        observer: 'block.observe',
        title: '## buttons.outset ##'
      },
      image: {
        command: 'image.edit',
        title: '## buttons.settings ##'
      }
    },
    control: {
      trash: {
        command: 'block.remove',
        title: '## buttons.delete ##'
      },
      duplicate: {
        command: 'block.duplicate',
        title: '## buttons.duplicate ##'
      }
    },
    create: function create() {
      return this.dom('<' + this.opts.image.tag + '>');
    },
    build: function build() {
      this._buildCaption();

      this._buildItems('figcaption', 'figcaption');

      this.data = {
        'alt': {
          getter: 'getAlt',
          setter: 'setAlt'
        },
        'link': {
          getter: 'getLinkUrl',
          setter: 'setLinkUrl'
        },
        'target': {
          getter: 'getTarget',
          setter: 'setTarget'
        },
        'caption': {
          getter: 'getCaption',
          setter: 'setCaption'
        }
      };
    },
    getImage: function getImage() {
      return this.$block.find('img').eq(0);
    },
    getSrc: function getSrc() {
      var $img = this.getImage();
      return $img.attr('src');
    },
    getLink: function getLink() {
      var $link = this.getImage().parent();
      $link = $link.get().tagName !== 'A' ? false : $link;
      return $link;
    },
    getAlt: function getAlt() {
      var $img = this.getImage();
      var alt = $img.attr('alt');
      return alt ? alt : '';
    },
    getLinkUrl: function getLinkUrl() {
      var $link = this.getLink();
      return $link ? $link.attr('href') : '';
    },
    getTarget: function getTarget() {
      var $link = this.getLink();
      return $link ? $link.attr('target') : this.opts.image.newtab;
    },
    setAlt: function setAlt(value) {
      var $img = this.getImage();
      $img.attr('alt', value);
    },
    setTarget: function setTarget(value) {
      var $link = this.getLink();
      if (!$link) return;
      if (value) $link.attr('target', '_blank');else $link.removeAttr('target');
    },
    setLinkUrl: function setLinkUrl(value) {
      var $link = this.getLink();

      if (value === '' && $link) {
        this.removeLink();
        return;
      } else if (!$link) {
        var $img = this.getImage();
        $link = this.dom('<a>');
        $img.wrap($link);
      }

      $link.attr('href', value);
    },
    setImage: function setImage(data) {
      var $img = this.getImage();
      $img.attr('src', data.url);
      if (data.hasOwnProperty('id')) $img.attr('data-image', data.id);
      if (data.hasOwnProperty('2x')) $img.attr('srcset', data['2x'] + ' 2x');
      $img.one('load', this.app.editor.adjustHeight.bind(this.app.editor));
    },
    removeLink: function removeLink() {
      var $link = this.getLink();

      if ($link) {
        $link.unwrap();
      }
    }
  });
  ArticleEditor.add('block', 'block.layer', {
    mixins: ['block'],
    type: 'layer',
    nested: true,
    emptiable: true,
    toolbar: {
      add: {
        command: 'addbar.popup',
        title: '## buttons.add ##'
      }
    },
    control: {
      trash: {
        command: 'block.remove',
        title: '## buttons.delete ##'
      },
      duplicate: {
        command: 'block.duplicate',
        title: '## buttons.duplicate ##'
      }
    },
    create: function create() {
      return this.dom(this.opts.layer.template);
    },
    getTitle: function getTitle() {
      var title = this.$block.attr('data-title');
      return title || this._getNameByTag();
    }
  });
  ArticleEditor.add('block', 'block.line', {
    mixins: ['block'],
    type: 'line',
    toolbar: {
      add: {
        command: 'addbar.popup',
        title: '## buttons.add ##'
      }
    },
    control: {
      trash: {
        command: 'block.remove',
        title: '## buttons.delete ##'
      },
      duplicate: {
        command: 'block.duplicate',
        title: '## buttons.duplicate ##'
      }
    },
    create: function create() {
      return this.dom('<hr>');
    }
  });
  ArticleEditor.add('block', 'block.list', {
    mixins: ['block'],
    type: 'list',
    editable: true,
    toolbar: {
      add: {
        command: 'addbar.popup',
        title: '## buttons.add ##'
      },
      format: {
        command: 'format.popup',
        title: '## buttons.format ##'
      },
      alignment: {
        command: 'block.popup',
        observer: 'block.observe',
        title: '## buttons.align ##'
      },
      bold: {
        command: 'inline.set',
        title: '## buttons.bold ##',
        params: {
          tag: 'b'
        }
      },
      italic: {
        command: 'inline.set',
        title: '## buttons.italic ##',
        params: {
          tag: 'i'
        }
      },
      deleted: {
        command: 'inline.set',
        title: '## buttons.deleted ##',
        params: {
          tag: 'del'
        }
      },
      outdent: {
        command: 'list.outdent',
        title: '## buttons.outdent ##'
      },
      indent: {
        command: 'list.indent',
        title: '## buttons.indent ##'
      },
      link: {
        command: 'link.popup',
        title: '## buttons.link ##'
      }
    },
    control: {
      trash: {
        command: 'block.remove',
        title: '## buttons.delete ##'
      },
      duplicate: {
        command: 'block.duplicate',
        title: '## buttons.duplicate ##'
      }
    },
    create: function create() {
      return this.dom('<ul>');
    },
    unparse: function unparse($el) {
      this.app.content.unfixListMargin($el);
    },
    setEmpty: function setEmpty() {
      this.$block.html('');
      var $item = this.dom('<li>');
      this.$block.append($item);
      this.app.caret.set($item, 'start');
    },
    isEmpty: function isEmpty() {
      var html = this.$block.html();
      html = this._cleanEmpty(html);
      var $items = this.$block.find('li');

      if ($items.length === 0) {
        html = html.trim();
        return html === '';
      } else if ($items.length === 1) {
        html = $items.eq(0).html();
        html = this._cleanEmpty(html);
        return html === '';
      }

      return false;
    },
    // handle
    handleTab: function handleTab(e, key, event) {
      var currentItem = this.app.selection.getBlock();
      var isItemStart = this.app.caret.is(currentItem, 'start');

      if (this.isCaretStart() || this.isCaretEnd()) {
        var next = this.getNext();

        if (next) {
          e.preventDefault();
          this.app.block.set(next, 'start');
          return true;
        }
      } else {
        if (this.opts.tab.spaces && !isItemStart) {
          return;
        }

        e.preventDefault();
        this.app.list.indent();
        return true;
      }
    },
    handleEnter: function handleEnter(e, key, event) {
      e.preventDefault();
      var $newItem, $currentItem, currentItem, isItemEmpty; // empty or end

      if (this.isEmpty() || this.isCaretEnd()) {
        currentItem = this.app.selection.getBlock();
        $currentItem = this.dom(currentItem);
        isItemEmpty = this.app.content.isEmptyHtml(currentItem.innerHTML); // list exit

        if (isItemEmpty) {
          // remove empty
          $currentItem.remove(); // insert

          this.insertEmpty({
            position: 'after',
            caret: 'start'
          });
          return true;
        } // insert li


        $newItem = this.dom('<li>');
        this.app.element.cloneAttrs(currentItem, $newItem);
        this.dom(currentItem).after($newItem);
        this.app.caret.set($newItem, 'start');
      } // start
      else if (this.isCaretStart()) {
          $newItem = this.dom('<li>');
          currentItem = this.app.selection.getBlock();
          this.app.element.cloneAttrs(currentItem, $newItem);
          this.dom(currentItem).before($newItem);
        } // middle
        else {
            currentItem = this.app.selection.getBlock();
            $currentItem = this.dom(currentItem);
            isItemEmpty = this.app.content.isEmptyHtml(currentItem.innerHTML);
            var isItemStart = this.app.caret.is(currentItem, 'start');
            var isItemEnd = this.app.caret.is(currentItem, 'end', ['ul', 'ol']);
            $newItem = this.dom('<li>');
            this.app.element.cloneAttrs(currentItem, $newItem); // empty

            if (isItemEmpty) {
              $currentItem.after($newItem);
              this.app.caret.set($newItem, 'start');
            } // start
            else if (isItemStart) {
                $currentItem.before($newItem);
              } // end
              else if (isItemEnd) {
                  var $listInside = $currentItem.find('ul, ol').first();

                  if ($listInside.length !== 0) {
                    $newItem.append(this.app.utils.createInvisibleChar());
                    $newItem.append($listInside);
                    $currentItem.after($newItem);
                  } else {
                    $currentItem.after($newItem);
                  }

                  this.app.caret.set($newItem, 'start');
                } // middle
                else {
                    var $part = this.app.element.split(currentItem);
                    this.app.caret.set($part, 'start');
                  }
          }

      return true;
    }
  });
  ArticleEditor.add('block', 'block.noneditable', {
    mixins: ['block'],
    type: 'noneditable',
    toolbar: {
      add: {
        command: 'addbar.popup',
        title: '## buttons.add ##'
      }
    },
    control: {
      trash: {
        command: 'block.remove',
        title: '## buttons.delete ##'
      },
      duplicate: {
        command: 'block.duplicate',
        title: '## buttons.duplicate ##'
      }
    },
    create: function create() {
      return this.dom('<div>').addClass(this.opts.noneditable.classname);
    }
  });
  ArticleEditor.add('block', 'block.quote', {
    mixins: ['block'],
    type: 'quote',
    toolbar: {
      add: {
        command: 'addbar.popup',
        title: '## buttons.add ##'
      }
    },
    control: {
      trash: {
        command: 'block.remove',
        title: '## buttons.delete ##'
      },
      duplicate: {
        command: 'block.duplicate',
        title: '## buttons.duplicate ##'
      }
    },
    create: function create() {
      return this.dom(this.opts.quote.template);
    },
    build: function build() {
      this._buildCaption();

      this._buildItems('p', 'quoteitem');

      this._buildItems('figcaption', 'figcaption');
    }
  });
  ArticleEditor.add('block', 'block.quoteitem', {
    mixins: ['block'],
    type: 'quoteitem',
    editable: true,
    toolbar: {
      alignment: {
        command: 'addbar.popup',
        observer: 'block.observe',
        title: '## buttons.align ##'
      },
      bold: {
        command: 'inline.set',
        title: '## buttons.bold ##',
        params: {
          tag: 'b'
        }
      },
      italic: {
        command: 'inline.set',
        title: '## buttons.italic ##',
        params: {
          tag: 'i'
        }
      },
      deleted: {
        command: 'inline.set',
        title: '## buttons.deleted ##',
        params: {
          tag: 'del'
        }
      },
      link: {
        command: 'link.popup',
        title: '## buttons.link ##'
      }
    },
    create: function create() {
      return this.dom('<p>');
    },
    getBlockquote: function getBlockquote() {
      return this.$block.closest('blockquote');
    },
    // handle
    handleArrow: function handleArrow(e, key, event) {
      var $blockquote = this.getBlockquote();
      if ($blockquote.length === 0) return;
      var isStart = this.app.caret.is($blockquote, 'start');
      var isEnd = this.app.caret.is($blockquote, 'end');

      if (event.is('up-left') && isStart || event.is('down-right') && isEnd) {
        e.preventDefault();
        var parentInstance = this.getParent('quote');
        this.app.block.set(parentInstance);
        return true;
      }
    },
    handleTab: function handleTab(e, key, event) {
      e.preventDefault();
      var next = this.getNext();

      if (next) {
        this.app.block.set(next, 'start');
        return true;
      } else {
        var quote = this.getParent('quote');
        this.app.block.set(quote);
        return true;
      }
    },
    handleEnter: function handleEnter(e, key, event) {
      e.preventDefault(); // prepare new instance

      var newInstance = this.app.create('block.quoteitem'); // empty or end

      if (this.isEmpty() || this.isCaretEnd()) {
        this.insert({
          instance: newInstance,
          position: 'after',
          caret: 'start'
        });
      } // start
      else if (this.isCaretStart()) {
          this.insert({
            instance: newInstance,
            position: 'before'
          });
        } // middle
        else {
            var $block = this.getBlock();
            var $part = this.app.element.split($block);
            this.app.block.set($part, 'start');
          }

      return true;
    }
  });
  ArticleEditor.add('block', 'block.row', {
    mixins: ['block'],
    type: 'row',
    toolbar: {
      table: {
        command: 'table.popup',
        title: '## buttons.table ##'
      }
    },
    create: function create() {
      return this.dom('<tr>');
    },
    getNextRow: function getNextRow() {
      var row = this.getNext();
      var $parent = this.$block.parent();

      if (!row && $parent.get().tagName !== 'TABLE') {
        row = $parent.nextElement().find('tr').first().dataget('instance');
      }

      return row;
    },
    getPrevRow: function getPrevRow() {
      var row = this.getPrev();
      var $parent = this.$block.parent();

      if (!row && $parent.get().tagName !== 'TABLE') {
        row = $parent.prevElement().find('tr').last().dataget('instance');
      }

      return row;
    },
    // handle
    handleDelete: function handleDelete(e, key, event) {
      e.preventDefault();
      return true;
    },
    handleArrow: function handleArrow(e, key, event) {
      e.preventDefault();

      if (event.is('up-left')) {
        var parentInstance = this.getParent('table');
        this.app.block.set(parentInstance);
      } else {
        var cellInstance = this.getChildFirst('cell');
        this.app.block.set(cellInstance, 'start');
      }

      return true;
    },
    handleTab: function handleTab(e, key, event) {
      e.preventDefault();
      var next = this.getNextRow();

      if (next) {
        this.app.block.set(next);
      } else {
        var parentInstance = this.getParent('table');
        this.app.block.set(parentInstance);
      }

      return true;
    },
    handleEnter: function handleEnter(e, key, event) {
      e.preventDefault();
      return true;
    }
  });
  ArticleEditor.add('block', 'block.table', {
    mixins: ['block'],
    type: 'table',
    toolbar: {
      add: {
        command: 'addbar.popup',
        title: '## buttons.add ##'
      },
      table: {
        command: 'table.popup',
        title: '## buttons.table ##'
      }
    },
    control: {
      trash: {
        command: 'block.remove',
        title: '## buttons.delete ##'
      },
      duplicate: {
        command: 'block.duplicate',
        title: '## buttons.duplicate ##'
      }
    },
    create: function create() {
      return this.dom(this.opts.table.template);
    },
    build: function build() {
      this._buildItems('tr', 'row');

      this._buildItems('td, th', 'cell');
    },
    getFirstCell: function getFirstCell() {
      var $cell = this.$block.find('th, td').first();

      if ($cell.length !== 0) {
        return $cell.dataget('instance');
      }
    }
  });
  ArticleEditor.add('block', 'block.variable', {
    mixins: ['block'],
    type: 'variable',
    editable: false,
    inline: true,
    toolbar: {
      add: {
        command: 'addbar.popup',
        title: '## buttons.add ##'
      }
    },
    create: function create() {
      return this.dom('<span>').addClass(this.opts.variable.classname);
    },
    build: function build() {
      this.$block.addClass(this.opts.variable.classname);
    }
  });
  ArticleEditor.add('block', 'block.form', {
    mixins: ['block'],
    type: 'form',
    create: function create() {
      return this.dom('<form>');
    },
    control: {
      trash: {
        command: 'block.remove',
        title: '## buttons.delete ##'
      },
      duplicate: {
        command: 'block.duplicate',
        title: '## buttons.duplicate ##'
      }
    }
  });
  ArticleEditor.add('block', 'block.card', {
    mixins: ['block'],
    type: 'card',
    editable: true,
    toolbar: {
      add: {
        command: 'addbar.popup',
        title: '## buttons.add ##'
      },
      bold: {
        command: 'inline.set',
        title: '## buttons.bold ##',
        params: {
          tag: 'b'
        }
      },
      italic: {
        command: 'inline.set',
        title: '## buttons.italic ##',
        params: {
          tag: 'i'
        }
      },
      deleted: {
        command: 'inline.set',
        title: '## buttons.deleted ##',
        params: {
          tag: 'del'
        }
      },
      link: {
        command: 'link.popup',
        title: '## buttons.link ##'
      },
      image: {
        command: 'image.editCard',
        title: '## buttons.settings ##',
        observer: 'block.observeCard'
      }
    },
    control: {
      trash: {
        command: 'block.remove',
        title: '## buttons.delete ##'
      },
      duplicate: {
        command: 'block.duplicate',
        title: '## buttons.duplicate ##'
      }
    },
    create: function create() {
      return this.dom(this.opts.card.template);
    },
    build: function build() {
      this.data = {
        'alt': {
          getter: 'getAlt',
          setter: 'setAlt'
        }
      };
    },
    hasImage: function hasImage() {
      return this.$block.find('img').length !== 0;
    },
    getImage: function getImage() {
      return this.$block.find('img').eq(0);
    },
    getAlt: function getAlt() {
      var $img = this.getImage();
      var alt = $img.attr('alt');
      return alt ? alt : '';
    },
    setAlt: function setAlt(value) {
      var $img = this.getImage();
      $img.attr('alt', value);
    },
    setImage: function setImage(data) {
      var $img = this.getImage();
      $img.attr('src', data.url);

      if (data.hasOwnProperty('id')) {
        $img.attr('data-image', data.id);
      }

      $img.one('load', this.app.editor.adjustHeight.bind(this.app.editor));
    },
    // handle
    handleEnter: function handleEnter(e, key, event) {
      e.preventDefault();
      this.app.insertion.insertBreakline();
      return true;
    }
  });
  window.ArticleEditor = ArticleEditor; // Data attribute load

  window.addEventListener('load', function () {
    ArticleEditor('[data-article-editor]');
  }); // Export for webpack

  if (( false ? undefined : _typeof(module)) === 'object' && module.exports) {
    module.exports = ArticleEditor;
    module.exports.ArticleEditor = ArticleEditor;
  }
})();
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./resources/plugins/article-editor/plugins/reorder/reorder.js":
/*!*********************************************************************!*\
  !*** ./resources/plugins/article-editor/plugins/reorder/reorder.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

ArticleEditor.add('plugin', 'reorder', {
  defaults: {
    icon: '<svg height="16" viewBox="0 0 16 16" width="16" xmlns="http://www.w3.org/2000/svg"><g fill="#000" fill-rule="nonzero"><path d="m13 5c.5522847 0 1 .44771525 1 1 0 .51283584-.3860402.93550716-.8833789.99327227l-.1166211.00672773h-10c-.55228475 0-1-.44771525-1-1 0-.51283584.38604019-.93550716.88337887-.99327227l.11662113-.00672773z"/><path d="m13 9c.5522847 0 1 .44771525 1 1 0 .5128358-.3860402.9355072-.8833789.9932723l-.1166211.0067277h-10c-.55228475 0-1-.4477153-1-1 0-.51283584.38604019-.93550716.88337887-.99327227l.11662113-.00672773z"/></g></svg>'
  },
  subscribe: {
    'block.set': function blockSet() {
      this._observe();
    }
  },
  init: function init() {},
  start: function start() {
    this.app.control.add('reorder', {
      icon: this.opts.reorder.icon,
      position: 'first',
      blocks: {
        'all': 'first-level'
      }
    });
  },
  stop: function stop() {
    this._stopEvents();
  },
  // private
  _observe: function _observe() {
    this.$btn = this.app.control.get('reorder');
    if (this.$btn.length === 0) return;
    this.$btn.addClass(this.prefix + '-handle');

    this._sortable();
  },
  _sortable: function _sortable() {
    this.instance = this.app.block.get();
    this.$win = this.app.editor.getWin();
    this.tolerance = this.$btn.width();
    this.$clickItem = null;
    this.$dragItem = null;
    this.oldY = 0;
    this.dragging = false;
    this.$btn.on('mousedown.' + this.prefix + '-reorder touchstart.' + this.prefix + '-reorder', this._press.bind(this));
  },
  _press: function _press(e) {
    var $target = this.dom(e.target).closest('.' + this.prefix + '-button');

    if (e && e.target && $target.hasClass(this.prefix + '-handle')) {
      e.preventDefault();
      this.app.observer.trigger = false;
      this.$win.on('mouseup.' + this.prefix + '-reorder touchend.' + this.prefix + '-reorder', this._release.bind(this));
      this.$win.on('mousemove.' + this.prefix + '-reorder touchmove.' + this.prefix + '-reorder', this._move.bind(this));
      var item = this.instance.getBlock().get();
      this.app.block.unset();
      this.dragging = true;
      this.$dragItem = this._makeDragItem(item, e.target);
    }
  },
  _release: function _release(e) {
    this._stopEvents();

    this.app.observer.trigger = true;
    this.oldY = 0;
    this.dragging = false;

    this._trashDragItem();

    this.app.block.set(this.instance);
  },
  _move: function _move(e) {
    if (!this.$dragItem && !this.dragging) {
      return;
    }

    e.preventDefault();
    var framePos = this.app.editor.getFrameRect(); // direction & delta

    var direction = false;
    var deltaY = this.oldY === 0 ? 0 : this.oldY - e.pageY;

    if (deltaY > 0) {
      direction = 'up';
    } else if (deltaY < 0) {
      direction = 'down';
    } // env


    var tolerance = 40;
    var isScrollTarget = this.app.scroll.isTarget();

    var isFrameScroll = this._isFrameScroll();

    var docScrollTop = this.app.$doc.scrollTop();
    var $target = isScrollTarget ? this.app.scroll.getTarget() : this.app.$doc;
    var scrollTop = isFrameScroll ? this.app.editor.getDoc().scrollTop() : $target.scrollTop(); // move

    this._moveItem(this.$dragItem, deltaY);

    this.oldY = e.pageY; // autoscroll

    var end,
        startStop = false;

    if (isScrollTarget) {
      end = $target.height() + $target.offset().top - tolerance;
    } else if (isFrameScroll) {
      end = framePos.bottom - tolerance;
      endWin = this.app.$win.height() + docScrollTop - tolerance;

      if (endWin < end) {
        end = endWin;
      }
    } else {
      startStop = !this.app.toolbar.isSticky();
      end = this.app.$win.height() + scrollTop - tolerance;
    }

    var $toolbar = this.app.container.get('bars');
    var toolbarHeight = $toolbar.height();
    var scrollPoint = isFrameScroll ? e.pageY + framePos.top - scrollTop : e.pageY + framePos.top;
    var start = $toolbar.offset().top + toolbarHeight + tolerance; // scroll up

    if (direction === 'up' && scrollTop > 0 && scrollPoint < start && startStop === false) {
      this._scroll(-10);
    } // scroll down
    else if (direction === 'down' && scrollPoint > end) {
        this._scroll(10);
      } // place


    var $elms = this.app.editor.getLayout().children();
    var len = $elms.length;

    for (var b = 0; b < len; b++) {
      var subItem = $elms.eq(b).get();

      if (subItem === this.$clickItem.get()) {
        continue;
      }

      if (this._isOver(this.dom(subItem))) {
        this._swapItems(subItem);
      }
    }
  },
  _scroll: function _scroll(step) {
    var $target = this.app.scroll.isTarget() ? this.app.scroll.getTarget() : this.app.$win;

    var isFrameScroll = this._isFrameScroll();

    if (isFrameScroll) {
      $target = this.app.editor.getWin();
    }

    var scrollY = $target.scrollTop();
    $target.scrollTop(scrollY + step);
  },
  _swapItems: function _swapItems(target) {
    var y = this.$dragItem.offset().top;
    var $item = this.$clickItem;
    var $target = this.dom(target);
    var offset = $target.offset();
    var height = $target.height() / 2;
    var func = height + offset.top > y ? 'before' : 'after';
    $target[func]($item);
  },
  _stopEvents: function _stopEvents() {
    if (this.$win) {
      this.$btn.off('.' + this.prefix + '-reorder');
      this.$win.off('.' + this.prefix + '-reorder');
    }
  },
  _isFrameScroll: function _isFrameScroll() {
    var frameHeight = this.app.editor.getFrame().height();
    var bodyHeight = this.app.editor.getBody().height();
    return bodyHeight > frameHeight;
  },
  _isOver: function _isOver($target) {
    var y = this.$dragItem.offset().top;
    var offset = $target.offset();
    var height = $target.height();
    return y > offset.top && y < offset.top + height;
  },
  _moveItem: function _moveItem($item, deltaY) {
    var top = $item.offset().top;
    top -= deltaY;
    $item.css('top', top + 'px');
  },
  _makeDragItem: function _makeDragItem(item) {
    this._trashDragItem();

    var $item = this.dom(item);
    var offset = $item.offset();
    this.$clickItem = $item;
    this.$clickItem.addClass(this.prefix + '-drag-active');
    var $cloned = $item.clone();
    $cloned.removeClass(this.prefix + '-drag-active ' + this.prefix + '-element-active');
    var $dragItem = this.dom('<div>').addClass(this.prefix + '-dragging');
    $dragItem.append($cloned);
    $dragItem.css({
      'opacity': 0.95,
      'position': 'absolute',
      'z-index': 999,
      'left': offset.left + 'px',
      'top': offset.top + 'px',
      'width': $item.width() + 'px'
    });
    this.app.editor.getBody().append($dragItem);
    return $dragItem;
  },
  _trashDragItem: function _trashDragItem() {
    if (this.$dragItem && this.$clickItem) {
      this.$clickItem.removeClass(this.prefix + '-drag-active');
      this.$clickItem = null;
      this.$dragItem.remove();
      this.$dragItem = null;
    }
  }
});

/***/ }),

/***/ 7:
/*!***************************************************************!*\
  !*** multi ./resources/js/dashboard/bundles/bundleProfile.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! D:\Coding\Darkpony\Idrogeios\lmsdemo\resources\js\dashboard\bundles\bundleProfile.js */"./resources/js/dashboard/bundles/bundleProfile.js");


/***/ })

/******/ });